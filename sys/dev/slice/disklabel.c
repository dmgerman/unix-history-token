begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (C) 1997,1998 Julian Elischer.  All rights reserved.  * julian@freebsd.org  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  1. Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  2. Redistributions in binary form must reproduce the above copyright notice,  *     this list of conditions and the following disclaimer in the documentation  *     and/or other materials provided with the distribution.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER ``AS IS'' AND ANY EXPRESS  * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE HOLDER OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *   *	$Id: disklabel.c,v 1.3 1998/04/22 19:27:51 julian Exp $  */
end_comment

begin_define
define|#
directive|define
name|BAD144
end_define

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_include
include|#
directive|include
file|<sys/diskslice.h>
end_include

begin_include
include|#
directive|include
file|<sys/dkstat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|BAD144
end_ifdef

begin_include
include|#
directive|include
file|<sys/dkbad.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<dev/slice/slice.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sliceio.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_struct
struct|struct
name|private_data
block|{
name|u_int32_t
name|flags
decl_stmt|;
name|u_int8_t
name|rflags
decl_stmt|;
name|u_int8_t
name|wflags
decl_stmt|;
name|int
name|savedoflags
decl_stmt|;
name|struct
name|slice
modifier|*
name|slice_down
decl_stmt|;
name|struct
name|disklabel
name|disklabel
decl_stmt|;
struct|struct
name|subdev
block|{
name|int
name|part
decl_stmt|;
name|struct
name|slice
modifier|*
name|slice
decl_stmt|;
name|struct
name|slicelimits
name|limit
decl_stmt|;
name|struct
name|private_data
modifier|*
name|pd
decl_stmt|;
name|u_int32_t
name|offset
decl_stmt|;
comment|/*  all disklabel supports */
block|}
name|subdevs
index|[
name|MAXPARTITIONS
index|]
struct|;
ifdef|#
directive|ifdef
name|BAD144
name|struct
name|dkbad_intern
modifier|*
name|bad
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|sl_h_constructor_t
name|dkl_constructor
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* constructor (from device) */
end_comment

begin_decl_stmt
specifier|static
name|sl_h_IO_req_t
name|dkl_IOreq
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* IO req downward (to device) */
end_comment

begin_decl_stmt
specifier|static
name|sl_h_ioctl_t
name|dkl_ioctl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ioctl req downward (to device) */
end_comment

begin_decl_stmt
specifier|static
name|sl_h_open_t
name|dkl_open
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* downwards travelling open */
end_comment

begin_comment
comment|/*static sl_h_close_t dkl_close; */
end_comment

begin_comment
comment|/* downwards travelling close */
end_comment

begin_decl_stmt
specifier|static
name|sl_h_claim_t
name|dkl_claim
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* upwards travelling claim */
end_comment

begin_decl_stmt
specifier|static
name|sl_h_revoke_t
name|dkl_revoke
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* upwards travelling revokation */
end_comment

begin_decl_stmt
specifier|static
name|sl_h_verify_t
name|dkl_verify
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* things changed, are we stil valid? */
end_comment

begin_decl_stmt
specifier|static
name|sl_h_upconfig_t
name|dkl_upconfig
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* config requests from below */
end_comment

begin_decl_stmt
specifier|static
name|sl_h_dump_t
name|dkl_dump
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* core dump req downward */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|slice_handler
name|slicetype
init|=
block|{
literal|"disklabel"
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|,
operator|&
name|dkl_constructor
block|,
comment|/* constructor */
operator|&
name|dkl_IOreq
block|,
operator|&
name|dkl_ioctl
block|,
operator|&
name|dkl_open
block|,
comment|/*&dkl_close*/
name|NULL
block|,
operator|&
name|dkl_revoke
block|,
comment|/* revoke */
operator|&
name|dkl_claim
block|,
comment|/* claim */
operator|&
name|dkl_verify
block|,
comment|/* verify */
operator|&
name|dkl_upconfig
block|,
comment|/* subslice manipulation */
operator|&
name|dkl_dump
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|sd_drvinit
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|sl_newtype
argument_list|(
operator|&
name|slicetype
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|sddev
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|,
name|sd_drvinit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*-  * Given a slice, extract out our table of information  */
end_comment

begin_comment
comment|/*-  * Attempt to read a disk label from a slice.  * The label must be partly set up before this: secpercyl, secsize  * and anything required in the strategy routine (e.g., dummy bounds for the  * partition containing the label) must be filled in before calling us.  * Returns NULL on success and an error string on failure.  */
end_comment

begin_function
specifier|static
name|int
name|dkl_extract_table
parameter_list|(
name|sl_p
name|slice
parameter_list|,
name|struct
name|disklabel
modifier|*
name|lp
parameter_list|)
block|{
name|int
name|error
init|=
name|EINVAL
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|disklabel
modifier|*
name|dlp
decl_stmt|;
name|struct
name|partition
modifier|*
name|dp
decl_stmt|;
name|int
name|part
decl_stmt|;
name|int
name|slice_offset
decl_stmt|;
comment|/* XXX */
name|RR
expr_stmt|;
comment|/* start off with a known result */
name|bzero
argument_list|(
name|lp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|slice_readblock
argument_list|(
name|slice
argument_list|,
name|LABELSECTOR
argument_list|,
operator|&
name|bp
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Step through the block looking for the label. 	 * It may not be at the front (Though I have never seen this). 	 * When found, copy it to the destination supplied. 	 */
name|error
operator|=
name|EINVAL
expr_stmt|;
for|for
control|(
name|dlp
operator|=
operator|(
expr|struct
name|disklabel
operator|*
operator|)
name|bp
operator|->
name|b_data
init|;
name|dlp
operator|<=
operator|(
expr|struct
name|disklabel
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|bp
operator|->
name|b_data
operator|+
name|slice
operator|->
name|limits
operator|.
name|blksize
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|dlp
argument_list|)
operator|)
condition|;
name|dlp
operator|=
operator|(
expr|struct
name|disklabel
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|dlp
operator|+
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|)
control|)
block|{
if|if
condition|(
operator|(
name|dlp
operator|->
name|d_magic
operator|!=
name|DISKMAGIC
operator|)
operator|||
operator|(
name|dlp
operator|->
name|d_magic2
operator|!=
name|DISKMAGIC
operator|)
operator|||
operator|(
name|dlp
operator|->
name|d_npartitions
operator|>
name|MAXPARTITIONS
operator|)
operator|||
name|dkcksum
argument_list|(
name|dlp
argument_list|)
condition|)
continue|continue;
name|error
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
name|dlp
argument_list|,
name|lp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * disklabels are done relative to the base of the disk, 		 * rather than the local partition, (DUH!) 		 * so use partition 2 (c) to get the base, 		 * and subtract it from all non-0 offsets. 		 */
name|dp
operator|=
name|lp
operator|->
name|d_partitions
expr_stmt|;
name|slice_offset
operator|=
name|dp
index|[
literal|2
index|]
operator|.
name|p_offset
expr_stmt|;
for|for
control|(
name|part
operator|=
literal|0
init|;
name|part
operator|<
name|MAXPARTITIONS
condition|;
name|part
operator|++
operator|,
name|dp
operator|++
control|)
block|{
comment|/* 			 * We could be reloading, in which case skip 			 * entries already set up. 			 */
if|if
condition|(
name|dp
operator|->
name|p_size
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|dp
operator|->
name|p_offset
operator|<
name|slice_offset
condition|)
block|{
name|printf
argument_list|(
literal|"slice before 'c'\n"
argument_list|)
expr_stmt|;
name|dp
operator|->
name|p_size
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|dp
operator|->
name|p_offset
operator|-=
name|slice_offset
expr_stmt|;
block|}
break|break;
block|}
name|done
label|:
name|bp
operator|->
name|b_flags
operator||=
name|B_INVAL
operator||
name|B_AGE
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * given a table, write it to disk.  */
end_comment

begin_function
specifier|static
name|int
name|dkl_insert_table
parameter_list|(
name|sl_p
name|slice
parameter_list|,
name|struct
name|disklabel
modifier|*
name|lp
parameter_list|)
block|{
name|int
name|error
init|=
name|EINVAL
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|disklabel
modifier|*
name|dlp
decl_stmt|;
name|struct
name|partition
modifier|*
name|dp
decl_stmt|;
name|int
name|part
decl_stmt|;
name|int
name|slice_offset
decl_stmt|;
comment|/* XXX */
name|RR
expr_stmt|;
comment|/* start off with a known result */
if|if
condition|(
name|error
operator|=
name|slice_readblock
argument_list|(
name|slice
argument_list|,
name|LABELSECTOR
argument_list|,
operator|&
name|bp
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Step through the block looking for the label. 	 * It may not be at the front (Though I have never seen this). 	 * When found, replace it witht he new one.  	 */
name|error
operator|=
name|EINVAL
expr_stmt|;
for|for
control|(
name|dlp
operator|=
operator|(
expr|struct
name|disklabel
operator|*
operator|)
name|bp
operator|->
name|b_data
init|;
name|dlp
operator|<=
operator|(
expr|struct
name|disklabel
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|bp
operator|->
name|b_data
operator|+
name|slice
operator|->
name|limits
operator|.
name|blksize
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|dlp
argument_list|)
operator|)
condition|;
name|dlp
operator|=
operator|(
expr|struct
name|disklabel
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|dlp
operator|+
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|)
control|)
block|{
if|if
condition|(
operator|(
name|dlp
operator|->
name|d_magic
operator|!=
name|DISKMAGIC
operator|)
operator|||
operator|(
name|dlp
operator|->
name|d_magic2
operator|!=
name|DISKMAGIC
operator|)
operator|||
operator|(
name|dlp
operator|->
name|d_npartitions
operator|>
name|MAXPARTITIONS
operator|)
operator|||
name|dkcksum
argument_list|(
name|dlp
argument_list|)
condition|)
continue|continue;
name|error
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
comment|/* 		 * We didn't find one.. 		 * so clear the block and place the new disklabel 		 * at the start. 		 */
name|bzero
argument_list|(
name|bp
operator|->
name|b_data
argument_list|,
name|slice
operator|->
name|limits
operator|.
name|blksize
argument_list|)
expr_stmt|;
name|dlp
operator|=
operator|(
expr|struct
name|disklabel
operator|*
operator|)
name|bp
operator|->
name|b_data
expr_stmt|;
block|}
comment|/* 	 * old disklabels are done relative to the base of the disk, 	 * rather than the local partition, (DUH!) 	 * so use partition 2 (c) to get the base, 	 * and subtract it from all non-0 offsets. 	 */
name|dp
operator|=
name|dlp
operator|->
name|d_partitions
expr_stmt|;
name|slice_offset
operator|=
name|dp
index|[
literal|2
index|]
operator|.
name|p_offset
expr_stmt|;
name|bcopy
argument_list|(
name|lp
argument_list|,
name|dlp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lp
argument_list|)
argument_list|)
expr_stmt|;
name|slice_offset
operator|-=
name|dp
index|[
literal|2
index|]
operator|.
name|p_offset
expr_stmt|;
comment|/* size we adjust by? */
for|for
control|(
name|part
operator|=
literal|0
init|;
name|part
operator|<
name|MAXPARTITIONS
condition|;
name|part
operator|++
operator|,
name|dp
operator|++
control|)
block|{
if|if
condition|(
name|dp
operator|->
name|p_size
operator|==
literal|0
condition|)
continue|continue;
name|dp
operator|->
name|p_offset
operator|+=
name|slice_offset
expr_stmt|;
block|}
name|error
operator|=
name|slice_writeblock
argument_list|(
name|slice
argument_list|,
name|LABELSECTOR
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|quit
label|:
name|bp
operator|->
name|b_flags
operator||=
name|B_INVAL
operator||
name|B_AGE
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BAD144
end_ifdef

begin_function
specifier|static
name|int
name|dkl_internbad144
parameter_list|(
name|struct
name|private_data
modifier|*
name|pd
parameter_list|,
name|struct
name|dkbad
modifier|*
name|btp
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|struct
name|disklabel
modifier|*
name|lp
init|=
operator|&
name|pd
operator|->
name|disklabel
decl_stmt|;
name|struct
name|dkbad_intern
modifier|*
name|bip
init|=
name|pd
operator|->
name|bad
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|bip
operator|==
name|NULL
condition|)
block|{
name|bip
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|bip
argument_list|,
name|M_DEVBUF
argument_list|,
name|flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|bip
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|pd
operator|->
name|bad
operator|=
name|bip
expr_stmt|;
block|}
comment|/* 	 * Spare sectors are allocated beginning with the last sector of 	 * the second last track of the disk (the last track is used for 	 * the bad sector list). 	 */
name|bip
operator|->
name|bi_maxspare
operator|=
name|lp
operator|->
name|d_secperunit
operator|-
name|lp
operator|->
name|d_nsectors
operator|-
literal|1
expr_stmt|;
name|bip
operator|->
name|bi_nbad
operator|=
name|DKBAD_MAXBAD
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DKBAD_MAXBAD
operator|&&
name|btp
operator|->
name|bt_bad
index|[
name|i
index|]
operator|.
name|bt_cyl
operator|!=
name|DKBAD_NOCYL
condition|;
name|i
operator|++
control|)
name|bip
operator|->
name|bi_bad
index|[
name|i
index|]
operator|=
name|btp
operator|->
name|bt_bad
index|[
name|i
index|]
operator|.
name|bt_cyl
operator|*
name|lp
operator|->
name|d_secpercyl
operator|+
operator|(
name|btp
operator|->
name|bt_bad
index|[
name|i
index|]
operator|.
name|bt_trksec
operator|>>
literal|8
operator|)
operator|*
name|lp
operator|->
name|d_nsectors
operator|+
operator|(
name|btp
operator|->
name|bt_bad
index|[
name|i
index|]
operator|.
name|bt_trksec
operator|&
literal|0x00ff
operator|)
expr_stmt|;
name|bip
operator|->
name|bi_bad
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
if|#
directive|if
literal|1
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DKBAD_MAXBAD
operator|&&
name|bip
operator|->
name|bi_bad
index|[
name|i
index|]
operator|!=
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"  %8d => %8d\n"
argument_list|,
name|bip
operator|->
name|bi_bad
index|[
name|i
index|]
argument_list|,
name|bip
operator|->
name|bi_maxspare
operator|-
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dkl_readbad144
parameter_list|(
name|struct
name|private_data
modifier|*
name|pd
parameter_list|)
block|{
name|sl_p
name|slice
init|=
name|pd
operator|->
name|slice_down
decl_stmt|;
name|struct
name|disklabel
modifier|*
name|lp
init|=
operator|&
name|pd
operator|->
name|disklabel
decl_stmt|;
name|struct
name|dkbad
modifier|*
name|db
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|blkno
decl_stmt|,
name|i
decl_stmt|,
name|error
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|min
argument_list|(
literal|10
argument_list|,
name|lp
operator|->
name|d_nsectors
argument_list|)
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|blkno
operator|=
name|lp
operator|->
name|d_secperunit
operator|-
name|lp
operator|->
name|d_nsectors
operator|+
name|i
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|d_secsize
operator|>
name|slice
operator|->
name|limits
operator|.
name|blksize
condition|)
name|blkno
operator|*=
name|lp
operator|->
name|d_secsize
operator|/
name|slice
operator|->
name|limits
operator|.
name|blksize
expr_stmt|;
else|else
name|blkno
operator|/=
name|slice
operator|->
name|limits
operator|.
name|blksize
operator|/
name|lp
operator|->
name|d_secsize
expr_stmt|;
name|error
operator|=
name|slice_readblock
argument_list|(
name|slice
argument_list|,
name|blkno
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|bp
operator|->
name|b_flags
operator||=
name|B_INVAL
operator||
name|B_AGE
expr_stmt|;
name|db
operator|=
operator|(
expr|struct
name|dkbad
operator|*
operator|)
name|bp
operator|->
name|b_data
expr_stmt|;
if|if
condition|(
name|db
operator|->
name|bt_mbz
operator|==
literal|0
operator|&&
name|db
operator|->
name|bt_flag
operator|==
name|DKBAD_MAGIC
condition|)
block|{
name|printf
argument_list|(
literal|" bad144 table found at block %d\n"
argument_list|,
name|blkno
argument_list|)
expr_stmt|;
name|error
operator|=
name|dkl_internbad144
argument_list|(
name|pd
argument_list|,
name|db
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|daddr_t
name|dkl_transbad144
parameter_list|(
name|struct
name|private_data
modifier|*
name|pd
parameter_list|,
name|daddr_t
name|blkno
parameter_list|)
block|{
return|return
name|transbad144
argument_list|(
name|pd
operator|->
name|bad
argument_list|,
name|blkno
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*-  * look at a slice and figure out if we should be interested in it. (Is it  * ours?)  */
end_comment

begin_function
specifier|static
name|int
name|dkl_claim
parameter_list|(
name|struct
name|slice
modifier|*
name|slice
parameter_list|,
name|struct
name|slice
modifier|*
name|lower
parameter_list|,
name|void
modifier|*
name|ID
parameter_list|)
block|{
name|struct
name|disklabel
name|disklabel
decl_stmt|;
name|struct
name|disklabel
modifier|*
name|dl
decl_stmt|,
modifier|*
name|dl0
decl_stmt|;
name|int
name|error
decl_stmt|;
name|RR
expr_stmt|;
comment|/*-  	 * Try load a valid disklabel table. 	 * This is 90% of what we need to check. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|dkl_extract_table
argument_list|(
name|slice
argument_list|,
operator|&
name|disklabel
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/*- 	 * If there is no geometry info, extract it from the label 	 * as some drivers need this. 	 */
comment|/* XXX */
comment|/*- 	 * well, it looks like one of ours. 	 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  * This is a special HACK function for the IDE driver.  * It is here because everything it need is in scope here,  * but it is not really part of the SLICE code.  * Because old ESDI drives could not tell their geometry, They need  * to get it from the MBR or the disklabel. This is the disklabel bit.  */
end_comment

begin_function
name|int
name|dkl_geom_hack
parameter_list|(
name|struct
name|slice
modifier|*
name|slice
parameter_list|,
name|struct
name|ide_geom
modifier|*
name|geom
parameter_list|)
block|{
name|struct
name|disklabel
name|disklabel
decl_stmt|;
name|struct
name|disklabel
modifier|*
name|dl
decl_stmt|,
modifier|*
name|dl0
decl_stmt|;
name|int
name|error
decl_stmt|;
name|RR
expr_stmt|;
comment|/* first check it's a disklabel*/
if|if
condition|(
operator|(
name|error
operator|=
name|dkl_claim
argument_list|(
name|slice
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/*-  	 * Try load a valid disklabel table. 	 * This is wasteful but never called on new (< 5 YO ) drives. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|dkl_extract_table
argument_list|(
name|slice
argument_list|,
operator|&
name|disklabel
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
name|geom
operator|->
name|secpertrack
operator|=
name|disklabel
operator|.
name|d_nsectors
expr_stmt|;
name|geom
operator|->
name|trackpercyl
operator|=
name|disklabel
operator|.
name|d_ntracks
expr_stmt|;
name|geom
operator|->
name|cyls
operator|=
name|disklabel
operator|.
name|d_ncylinders
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  * look at a slice we know to be ours and decide what the #$%^ to do with it.  */
end_comment

begin_function
specifier|static
name|int
name|dkl_constructor
parameter_list|(
name|sl_p
name|slice
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_int64_t
name|disksize
init|=
name|slice
operator|->
name|limits
operator|.
name|slicesize
decl_stmt|;
name|struct
name|private_data
modifier|*
name|pd
decl_stmt|;
name|struct
name|partition
modifier|*
name|dp
decl_stmt|,
modifier|*
name|dp0
decl_stmt|;
name|struct
name|disklabel
modifier|*
name|dl
decl_stmt|;
name|sh_p
name|tp
decl_stmt|;
name|char
name|name
index|[
literal|64
index|]
decl_stmt|;
name|int
name|part
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|u_long
name|dkl_offset
decl_stmt|;
name|RR
expr_stmt|;
comment|/*- 	 * If we are being called to re-load a slice, 	 * then don't reallocate resources. 	 */
if|if
condition|(
operator|(
name|pd
operator|=
name|slice
operator|->
name|private_up
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|slice
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"name is NULL\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|slice
operator|->
name|name
argument_list|)
operator|>
literal|58
condition|)
block|{
name|printf
argument_list|(
literal|"slice: name %s too long\n"
argument_list|,
name|slice
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENAMETOOLONG
operator|)
return|;
block|}
name|pd
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pd
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|pd
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"fdisk: failed malloc\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|pd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pd
argument_list|)
argument_list|)
expr_stmt|;
name|pd
operator|->
name|slice_down
operator|=
name|slice
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|dkl_extract_table
argument_list|(
name|slice
argument_list|,
operator|&
name|pd
operator|->
name|disklabel
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|partinfo
name|data
decl_stmt|;
comment|/*  			 * If it's just that there is no disklabel there, 			 * Then we fake one up and write it. if this were 			 * not ok, then we would have not been called. 			 * (as probe will have failed). If it's  			 * a physical error, then that's reason to fail. 			 */
if|if
condition|(
name|error
operator|!=
name|EINVAL
condition|)
block|{
name|free
argument_list|(
name|pd
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|dkl_dummy_ioctl
argument_list|(
name|slice
argument_list|,
name|DIOCGPART
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|data
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|data
operator|.
name|disklab
argument_list|,
operator|&
name|pd
operator|->
name|disklabel
argument_list|,
sizeof|sizeof
argument_list|(
name|pd
operator|->
name|disklabel
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|dkl_insert_table
argument_list|(
name|slice
argument_list|,
operator|&
name|pd
operator|->
name|disklabel
argument_list|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|pd
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|BAD144
if|if
condition|(
name|pd
operator|->
name|disklabel
operator|.
name|d_flags
operator|&
name|D_BADSECT
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|dkl_readbad144
argument_list|(
name|pd
argument_list|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|pd
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
endif|#
directive|endif
name|slice
operator|->
name|refs
operator|++
expr_stmt|;
name|slice
operator|->
name|handler_up
operator|=
operator|&
name|slicetype
expr_stmt|;
name|slice
operator|->
name|private_up
operator|=
name|pd
expr_stmt|;
name|slicetype
operator|.
name|refs
operator|++
expr_stmt|;
block|}
name|dl
operator|=
operator|&
name|pd
operator|->
name|disklabel
expr_stmt|;
name|dp0
operator|=
name|dl
operator|->
name|d_partitions
expr_stmt|;
comment|/*- 	 * Handle each of the partitions. 	 * We should check that each makes sence and is legal. 	 * 1/ it should not already have a slice. 	 * 2/ should not be 0 length. 	 * 3/ should not go past end of our slice. 	 * 4/ should not overlap other slices. 	 *  It can include sector 0 (unfortunatly) 	 */
name|dp
operator|=
name|dp0
expr_stmt|;
for|for
control|(
name|part
operator|=
literal|0
init|;
name|part
operator|<
name|MAXPARTITIONS
condition|;
name|part
operator|++
operator|,
name|dp
operator|++
control|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|part
operator|==
literal|2
condition|)
continue|continue;
comment|/* XXX skip the 'c' partition */
comment|/* 		 * We could be reloading, in which case skip 		 * entries already set up. 		 */
if|if
condition|(
name|pd
operator|->
name|subdevs
index|[
name|part
index|]
operator|.
name|slice
operator|!=
name|NULL
condition|)
name|breakout
label|:
continue|continue;
comment|/* 		 * also skip partitions not present 		 */
if|if
condition|(
name|dp
operator|->
name|p_size
operator|==
literal|0
condition|)
continue|continue;
name|printf
argument_list|(
literal|" part %d, start=%d, size=%d\n"
argument_list|,
name|part
argument_list|,
name|dp
operator|->
name|p_offset
argument_list|,
name|dp
operator|->
name|p_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|->
name|p_offset
operator|+
name|dp
operator|->
name|p_size
operator|)
operator|>
operator|(
name|slice
operator|->
name|limits
operator|.
name|slicesize
operator|/
name|slice
operator|->
name|limits
operator|.
name|blksize
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"dkl: slice %d too big "
argument_list|,
name|part
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(%x> %x:%x )\n"
argument_list|,
operator|(
name|dp
operator|->
name|p_offset
operator|+
name|dp
operator|->
name|p_size
operator|)
argument_list|,
operator|(
name|slice
operator|->
name|limits
operator|.
name|slicesize
operator|/
name|slice
operator|->
name|limits
operator|.
name|blksize
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* check for overlaps with existing slices */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXPARTITIONS
condition|;
name|i
operator|++
control|)
block|{
comment|/* 			 * Don't bother if that slice was not made. 			 * This handles the (i == part) case. 			 */
if|if
condition|(
name|pd
operator|->
name|subdevs
index|[
name|i
index|]
operator|.
name|slice
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
name|dp0
index|[
name|i
index|]
operator|.
name|p_offset
operator|<
operator|(
name|dp
operator|->
name|p_offset
operator|+
name|dp
operator|->
name|p_size
operator|)
operator|)
operator|&&
operator|(
operator|(
name|dp0
index|[
name|i
index|]
operator|.
name|p_offset
operator|+
name|dp0
index|[
name|i
index|]
operator|.
name|p_size
operator|)
operator|>
name|dp
operator|->
name|p_offset
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"dkl: slice %d overlaps slice %d\n"
argument_list|,
name|part
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|breakout
goto|;
block|}
block|}
comment|/*- 		 * the slice seems to make sense. Use it. 		 */
name|pd
operator|->
name|subdevs
index|[
name|part
index|]
operator|.
name|part
operator|=
name|part
expr_stmt|;
name|pd
operator|->
name|subdevs
index|[
name|part
index|]
operator|.
name|pd
operator|=
name|pd
expr_stmt|;
name|pd
operator|->
name|subdevs
index|[
name|part
index|]
operator|.
name|offset
operator|=
name|dp
operator|->
name|p_offset
expr_stmt|;
name|pd
operator|->
name|subdevs
index|[
name|part
index|]
operator|.
name|limit
operator|.
name|blksize
operator|=
name|slice
operator|->
name|limits
operator|.
name|blksize
expr_stmt|;
name|pd
operator|->
name|subdevs
index|[
name|part
index|]
operator|.
name|limit
operator|.
name|slicesize
operator|=
operator|(
name|slice
operator|->
name|limits
operator|.
name|blksize
operator|*
operator|(
name|u_int64_t
operator|)
name|dp
operator|->
name|p_size
operator|)
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%s%c"
argument_list|,
name|slice
operator|->
name|name
argument_list|,
call|(
name|char
call|)
argument_list|(
literal|'a'
operator|+
name|part
argument_list|)
argument_list|)
expr_stmt|;
name|sl_make_slice
argument_list|(
operator|&
name|slicetype
argument_list|,
operator|&
name|pd
operator|->
name|subdevs
index|[
name|part
index|]
argument_list|,
operator|&
name|pd
operator|->
name|subdevs
index|[
name|part
index|]
operator|.
name|limit
argument_list|,
operator|&
name|pd
operator|->
name|subdevs
index|[
name|part
index|]
operator|.
name|slice
argument_list|,
name|NULL
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|pd
operator|->
name|subdevs
index|[
name|part
index|]
operator|.
name|slice
operator|->
name|probeinfo
operator|.
name|typespecific
operator|=
operator|&
name|dp
operator|->
name|p_fstype
expr_stmt|;
switch|switch
condition|(
name|dp
operator|->
name|p_fstype
condition|)
block|{
case|case
name|FS_UNUSED
case|:
comment|/* allow unuseed to be further split */
name|pd
operator|->
name|subdevs
index|[
name|part
index|]
operator|.
name|slice
operator|->
name|probeinfo
operator|.
name|type
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|FS_V6
case|:
case|case
name|FS_V7
case|:
case|case
name|FS_SYSV
case|:
case|case
name|FS_V71K
case|:
case|case
name|FS_V8
case|:
case|case
name|FS_MSDOS
case|:
case|case
name|FS_BSDLFS
case|:
case|case
name|FS_OTHER
case|:
case|case
name|FS_HPFS
case|:
case|case
name|FS_ISO9660
case|:
case|case
name|FS_BOOT
case|:
if|#
directive|if
literal|0
block|printf("%s: type %d. Leaving\n", 				pd->subdevs[part].slice->name, 				(u_int)dp->p_fstype);
endif|#
directive|endif
case|case
name|FS_SWAP
case|:
case|case
name|FS_BSDFFS
case|:
name|pd
operator|->
name|subdevs
index|[
name|part
index|]
operator|.
name|slice
operator|->
name|probeinfo
operator|.
name|type
operator|=
name|NO_SUBPART
expr_stmt|;
break|break;
default|default:
name|pd
operator|->
name|subdevs
index|[
name|part
index|]
operator|.
name|slice
operator|->
name|probeinfo
operator|.
name|type
operator|=
name|NULL
expr_stmt|;
block|}
comment|/*  		 * Dont allow further breakup of slices that 		 * cover our disklabel 		 */
if|if
condition|(
name|dp
operator|->
name|p_offset
operator|<
literal|16
condition|)
block|{
if|#
directive|if
literal|0
block|printf("%s: covers disklabel. Leaving\n", 				pd->subdevs[part].slice->name);
endif|#
directive|endif
name|pd
operator|->
name|subdevs
index|[
name|part
index|]
operator|.
name|slice
operator|->
name|probeinfo
operator|.
name|type
operator|=
name|NO_SUBPART
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tp
operator|=
name|slice_probeall
argument_list|(
name|pd
operator|->
name|subdevs
index|[
name|part
index|]
operator|.
name|slice
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
call|(
modifier|*
name|tp
operator|->
name|constructor
call|)
argument_list|(
name|pd
operator|->
name|subdevs
index|[
name|part
index|]
operator|.
name|slice
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  * look at a slice that USED to be ours.  * decide if any sub-slices need to be revoked.  * If not then at least ask them to verify themselves.  */
end_comment

begin_function
specifier|static
name|int
name|dkl_verify
parameter_list|(
name|sl_p
name|slice
parameter_list|)
block|{
specifier|register
name|struct
name|private_data
modifier|*
name|pd
decl_stmt|;
name|struct
name|disklabel
name|label
decl_stmt|;
name|struct
name|partition
modifier|*
name|dp
decl_stmt|,
modifier|*
name|dp2
decl_stmt|;
name|struct
name|disklabel
modifier|*
name|dl
decl_stmt|;
name|int
name|part
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* register struct slice *slice; */
name|RR
expr_stmt|;
name|pd
operator|=
name|slice
operator|->
name|private_up
expr_stmt|;
comment|/* slice = pd->slice_down; */
name|bzero
argument_list|(
operator|&
name|label
argument_list|,
sizeof|sizeof
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Try load a valid disklabel. This is 90% of what we need to check. 	 */
if|if
condition|(
operator|(
operator|(
name|error
operator|=
name|dkl_extract_table
argument_list|(
name|slice
argument_list|,
operator|&
name|label
argument_list|)
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|slice
operator|->
name|limits
operator|.
name|blksize
operator|!=
literal|512
operator|)
condition|)
block|{
comment|/*- 		 * Oh oh, we need to invalidate all the subslices. 		 * and relinquish this slice. 		 */
return|return
operator|(
name|dkl_revoke
argument_list|(
name|pd
argument_list|)
operator|)
return|;
block|}
name|dl
operator|=
operator|&
operator|(
name|pd
operator|->
name|disklabel
operator|)
expr_stmt|;
name|dp
operator|=
name|dl
operator|->
name|d_partitions
expr_stmt|;
name|dp2
operator|=
name|label
operator|.
name|d_partitions
expr_stmt|;
for|for
control|(
name|part
operator|=
literal|0
init|;
name|part
operator|<
name|MAXPARTITIONS
condition|;
name|part
operator|++
operator|,
name|dp
operator|++
operator|,
name|dp2
operator|++
control|)
block|{
if|if
condition|(
name|pd
operator|->
name|subdevs
index|[
name|part
index|]
operator|.
name|slice
condition|)
block|{
if|if
condition|(
operator|(
name|dp2
operator|->
name|p_offset
operator|!=
name|dp
operator|->
name|p_offset
operator|)
operator|||
operator|(
name|dp2
operator|->
name|p_size
operator|!=
name|dp
operator|->
name|p_size
operator|)
condition|)
block|{
name|sl_rmslice
argument_list|(
name|pd
operator|->
name|subdevs
index|[
name|part
index|]
operator|.
name|slice
argument_list|)
expr_stmt|;
name|pd
operator|->
name|subdevs
index|[
name|part
index|]
operator|.
name|slice
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pd
operator|->
name|subdevs
index|[
name|part
index|]
operator|.
name|slice
operator|->
name|handler_up
condition|)
block|{
operator|(
operator|*
name|pd
operator|->
name|subdevs
index|[
name|part
index|]
operator|.
name|slice
operator|->
name|handler_up
operator|->
name|verify
operator|)
operator|(
name|pd
operator|->
name|subdevs
index|[
name|part
index|]
operator|.
name|slice
operator|)
expr_stmt|;
block|}
block|}
block|}
comment|/*- having got rid of changing slices, replace 	 * the old table with the new one, and 	 * handle any new slices by calling the constructor. 	 */
name|bcopy
argument_list|(
operator|&
name|label
argument_list|,
name|dl
argument_list|,
sizeof|sizeof
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|dkl_constructor
argument_list|(
name|slice
argument_list|)
expr_stmt|;
name|done
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  * Invalidate all subslices, and free resources for this handler instance.  */
end_comment

begin_function
specifier|static
name|int
name|dkl_revoke
parameter_list|(
name|void
modifier|*
name|private
parameter_list|)
block|{
specifier|register
name|struct
name|private_data
modifier|*
name|pd
decl_stmt|;
specifier|register
name|struct
name|slice
modifier|*
name|slice
decl_stmt|;
name|int
name|part
decl_stmt|;
name|RR
expr_stmt|;
name|pd
operator|=
name|private
expr_stmt|;
name|slice
operator|=
name|pd
operator|->
name|slice_down
expr_stmt|;
for|for
control|(
name|part
operator|=
literal|0
init|;
name|part
operator|<
name|MAXPARTITIONS
condition|;
name|part
operator|++
control|)
block|{
if|if
condition|(
name|pd
operator|->
name|subdevs
index|[
name|part
index|]
operator|.
name|slice
condition|)
block|{
name|sl_rmslice
argument_list|(
name|pd
operator|->
name|subdevs
index|[
name|part
index|]
operator|.
name|slice
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*- 	 * remove ourself as a handler 	 */
name|slice
operator|->
name|handler_up
operator|=
name|NULL
expr_stmt|;
name|slice
operator|->
name|private_up
operator|=
name|NULL
expr_stmt|;
name|slicetype
operator|.
name|refs
operator|--
expr_stmt|;
ifdef|#
directive|ifdef
name|BAD144
if|if
condition|(
name|pd
operator|->
name|bad
condition|)
name|free
argument_list|(
name|pd
operator|->
name|bad
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|pd
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|sl_unref
argument_list|(
name|slice
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  * shift the appropriate IO by the offset for that slice.  */
end_comment

begin_function
specifier|static
name|void
name|dkl_IOreq
parameter_list|(
name|void
modifier|*
name|private
parameter_list|,
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
specifier|register
name|struct
name|private_data
modifier|*
name|pd
decl_stmt|;
name|struct
name|subdev
modifier|*
name|sdp
decl_stmt|;
specifier|register
name|struct
name|slice
modifier|*
name|slice
decl_stmt|;
name|RR
expr_stmt|;
name|sdp
operator|=
name|private
expr_stmt|;
name|pd
operator|=
name|sdp
operator|->
name|pd
expr_stmt|;
name|slice
operator|=
name|pd
operator|->
name|slice_down
expr_stmt|;
name|bp
operator|->
name|b_pblkno
operator|+=
name|sdp
operator|->
name|offset
expr_stmt|;
comment|/* add the offset for that slice */
name|sliceio
argument_list|(
name|slice
argument_list|,
name|bp
argument_list|,
name|SLW_ABOVE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dkl_open
parameter_list|(
name|void
modifier|*
name|private
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
specifier|register
name|struct
name|private_data
modifier|*
name|pd
decl_stmt|;
name|struct
name|subdev
modifier|*
name|sdp
decl_stmt|;
specifier|register
name|struct
name|slice
modifier|*
name|slice
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_int8_t
name|newrflags
init|=
literal|0
decl_stmt|;
name|u_int8_t
name|newwflags
init|=
literal|0
decl_stmt|;
name|int
name|newoflags
decl_stmt|;
name|int
name|part
decl_stmt|;
name|u_int8_t
name|partbit
decl_stmt|;
name|RR
expr_stmt|;
name|sdp
operator|=
name|private
expr_stmt|;
name|part
operator|=
name|sdp
operator|->
name|part
expr_stmt|;
name|partbit
operator|=
operator|(
literal|1
operator|<<
name|part
operator|)
expr_stmt|;
name|pd
operator|=
name|sdp
operator|->
name|pd
expr_stmt|;
name|slice
operator|=
name|pd
operator|->
name|slice_down
expr_stmt|;
comment|/* 	 * Calculate the change to to over-all picture here. 	 * Notice that this might result in LESS open bits 	 * if that was what was passed from above. 	 * (Prelude to 'mode-change' instead of open/close.) 	 */
comment|/* work out what our stored flags will be if this succeeds */
name|newwflags
operator|&=
operator|~
operator|(
name|partbit
operator|)
expr_stmt|;
name|newrflags
operator|&=
operator|~
operator|(
name|partbit
operator|)
expr_stmt|;
name|newwflags
operator||=
operator|(
name|flags
operator|&
name|FWRITE
operator|)
condition|?
operator|(
name|partbit
operator|)
else|:
literal|0
expr_stmt|;
name|newrflags
operator||=
operator|(
name|flags
operator|&
name|FREAD
operator|)
condition|?
operator|(
name|partbit
operator|)
else|:
literal|0
expr_stmt|;
comment|/* work out what we want to pass down this time */
name|newoflags
operator|=
name|newwflags
condition|?
name|FWRITE
else|:
literal|0
expr_stmt|;
name|newoflags
operator||=
name|newrflags
condition|?
name|FREAD
else|:
literal|0
expr_stmt|;
comment|/* 	 * If the agregate flags we used last time are the same as 	 * the agregate flags we would use this time, then don't 	 * bother re-doing the command. 	 */
if|if
condition|(
name|newoflags
operator|!=
name|pd
operator|->
name|savedoflags
condition|)
block|{
if|if
condition|(
name|error
operator|=
name|sliceopen
argument_list|(
name|slice
argument_list|,
name|newoflags
argument_list|,
name|mode
argument_list|,
name|p
argument_list|,
name|SLW_ABOVE
argument_list|)
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* 	 * Now that we know it succeeded, commit, by replacing the old 	 * flags with the new ones. 	 */
name|pd
operator|->
name|rflags
operator|=
name|newrflags
expr_stmt|;
name|pd
operator|->
name|wflags
operator|=
name|newwflags
expr_stmt|;
name|pd
operator|->
name|savedoflags
operator|=
name|newoflags
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static  void dkl_close(void *private, int flags, int mode, struct proc * p) { 	register struct private_data *pd; 	struct subdev		*sdp; 	register struct slice	*slice; 	u_int8_t		 newrflags = 0; 	u_int8_t		 newwflags = 0; 	int			 newoflags; 	int			 part; 	u_int8_t		 partbit;  RR; 	sdp = private; 	part = sdp->part; 	partbit = (1<< part); 	pd = sdp->pd; 	slice = pd->slice_down;  	if ((pd->rflags == 0)&& (pd->wflags == 0)) 		return;
comment|/* work out what our stored flags will be if this succeeds */
end_comment

begin_comment
unit|newwflags&= ~ (partbit); 	newrflags&= ~ (partbit); 	newwflags |= (flags& FWRITE) ? (partbit) : 0; 	newrflags |= (flags& FREAD) ? (partbit) : 0;
comment|/* work out what we want to pass down this time */
end_comment

begin_comment
unit|newoflags = newwflags ? FWRITE : 0; 	newoflags |= newrflags ? FREAD : 0;
comment|/*                                                                       	 * If this was the last open slice above, then release our own open      	 */
end_comment

begin_endif
unit|if ((pd->rflags == 0)&& (pd->wflags == 0)) { 		sliceclose(slice, newoflags, mode, p, SLW_ABOVE); 	} 	pd->rflags = newrflags; 	pd->wflags = newwflags; 	pd->savedoflags = newoflags; 	return ; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_function
specifier|static
name|int
name|dkl_ioctl
parameter_list|(
name|void
modifier|*
name|private
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
specifier|register
name|struct
name|private_data
modifier|*
name|pd
decl_stmt|;
name|struct
name|subdev
modifier|*
name|sdp
decl_stmt|;
specifier|register
name|struct
name|slice
modifier|*
name|slice
decl_stmt|;
name|struct
name|disklabel
modifier|*
name|lp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|RR
expr_stmt|;
name|sdp
operator|=
name|private
expr_stmt|;
name|pd
operator|=
name|sdp
operator|->
name|pd
expr_stmt|;
name|slice
operator|=
name|pd
operator|->
name|slice_down
expr_stmt|;
name|lp
operator|=
operator|&
name|pd
operator|->
name|disklabel
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DIOCGDINFO
case|:
operator|*
operator|(
expr|struct
name|disklabel
operator|*
operator|)
name|addr
operator|=
operator|*
name|lp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|DIOCGPART
case|:
if|if
condition|(
name|lp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|(
operator|(
expr|struct
name|partinfo
operator|*
operator|)
name|addr
operator|)
operator|->
name|disklab
operator|=
name|lp
expr_stmt|;
operator|(
operator|(
expr|struct
name|partinfo
operator|*
operator|)
name|addr
operator|)
operator|->
name|part
operator|=
name|lp
operator|->
name|d_partitions
operator|+
name|sdp
operator|->
name|part
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|BAD144
case|case
name|DIOCSBAD
case|:
if|if
condition|(
operator|!
operator|(
name|flag
operator|&
name|FWRITE
operator|)
condition|)
return|return
operator|(
name|EBADF
operator|)
return|;
return|return
operator|(
name|dkl_internbad144
argument_list|(
name|pd
argument_list|,
operator|(
expr|struct
name|dkbad
operator|*
operator|)
name|addr
argument_list|,
name|M_WAITOK
argument_list|)
operator|)
return|;
endif|#
directive|endif
comment|/* These don't really make sense. keep the headers for a reminder */
case|case
name|DIOCSDINFO
case|:
case|case
name|DIOCSYNCSLICEINFO
case|:
case|case
name|DIOCWDINFO
case|:
case|case
name|DIOCWLABEL
case|:
return|return
operator|(
name|ENOIOCTL
operator|)
return|;
block|}
return|return
operator|(
call|(
modifier|*
name|slice
operator|->
name|handler_down
operator|->
name|ioctl
call|)
argument_list|(
name|slice
operator|->
name|private_down
argument_list|,
name|cmd
argument_list|,
name|addr
argument_list|,
name|flag
argument_list|,
name|p
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dkl_upconfig
parameter_list|(
name|struct
name|slice
modifier|*
name|slice
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|RR
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SLCIOCRESET
case|:
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|BAD144
case|case
name|SLCIOCTRANSBAD
case|:
block|{
name|struct
name|private_data
modifier|*
name|pd
decl_stmt|;
name|daddr_t
name|blkno
decl_stmt|;
name|pd
operator|=
name|slice
operator|->
name|private_up
expr_stmt|;
if|if
condition|(
name|pd
operator|->
name|bad
condition|)
operator|*
operator|(
name|daddr_t
operator|*
operator|)
name|addr
operator|=
name|dkl_transbad144
argument_list|(
name|pd
argument_list|,
operator|*
operator|(
name|daddr_t
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* These don't really make sense. keep the headers for a reminder */
default|default:
return|return
operator|(
name|ENOIOCTL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|disklabel
name|static_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This is a hack routine called from the slice generic code to produce a dummy  * disklabel when given a slice descriptor. It's in here because this code  * knows about disklabels.  */
end_comment

begin_function
name|int
name|dkl_dummy_ioctl
parameter_list|(
name|struct
name|slice
modifier|*
name|slice
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|disklabel
modifier|*
name|lp
init|=
operator|&
name|static_label
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DIOCGDINFO
case|:
case|case
name|DIOCGPART
case|:
name|bzero
argument_list|(
name|lp
argument_list|,
sizeof|sizeof
argument_list|(
name|static_label
argument_list|)
argument_list|)
expr_stmt|;
name|lp
operator|->
name|d_magic
operator|=
name|DISKMAGIC
expr_stmt|;
name|lp
operator|->
name|d_magic2
operator|=
name|DISKMAGIC
expr_stmt|;
name|lp
operator|->
name|d_secsize
operator|=
name|slice
operator|->
name|limits
operator|.
name|blksize
expr_stmt|;
name|lp
operator|->
name|d_nsectors
operator|=
literal|1
expr_stmt|;
name|lp
operator|->
name|d_ntracks
operator|=
literal|1
expr_stmt|;
name|lp
operator|->
name|d_secpercyl
operator|=
literal|1
expr_stmt|;
name|lp
operator|->
name|d_ncylinders
operator|=
name|lp
operator|->
name|d_secperunit
operator|=
name|slice
operator|->
name|limits
operator|.
name|slicesize
operator|/
name|slice
operator|->
name|limits
operator|.
name|blksize
expr_stmt|;
name|lp
operator|->
name|d_npartitions
operator|=
name|RAW_PART
operator|+
literal|1
expr_stmt|;
name|lp
operator|->
name|d_partitions
index|[
name|RAW_PART
index|]
operator|.
name|p_size
operator|=
name|lp
operator|->
name|d_secperunit
expr_stmt|;
name|lp
operator|->
name|d_partitions
index|[
name|RAW_PART
index|]
operator|.
name|p_offset
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENOIOCTL
operator|)
return|;
block|}
name|lp
operator|->
name|d_checksum
operator|=
name|dkcksum
argument_list|(
name|lp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DIOCGDINFO
case|:
operator|*
operator|(
expr|struct
name|disklabel
operator|*
operator|)
name|addr
operator|=
operator|*
name|lp
expr_stmt|;
break|break;
case|case
name|DIOCGPART
case|:
comment|/*  XXX hack alert. 		 * This is a hack as this information is consumed immediatly 		 * otherwise the use of a static buffer would be dangerous. 		 */
operator|(
operator|(
expr|struct
name|partinfo
operator|*
operator|)
name|addr
operator|)
operator|->
name|disklab
operator|=
name|lp
expr_stmt|;
operator|(
operator|(
expr|struct
name|partinfo
operator|*
operator|)
name|addr
operator|)
operator|->
name|part
operator|=
name|lp
operator|->
name|d_partitions
operator|+
name|RAW_PART
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* use the existing one for now */
end_comment

begin_comment
comment|/*-  * Compute checksum for disk label.  */
end_comment

begin_endif
unit|u_int dkcksum(lp) 	register struct disklabel *lp; { 	register u_short *start, *end; 	register u_short sum = 0;  	start = (u_short *) lp; 	end = (u_short *)& lp->d_partitions[lp->d_npartitions]; 	while (start< end) 		sum ^= *start++; 	return (sum); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_function
specifier|static
name|int
name|dkl_dump
parameter_list|(
name|void
modifier|*
name|private
parameter_list|,
name|int32_t
name|blkoff
parameter_list|,
name|int32_t
name|blkcnt
parameter_list|)
block|{
name|struct
name|private_data
modifier|*
name|pd
decl_stmt|;
name|struct
name|subdev
modifier|*
name|sdp
decl_stmt|;
specifier|register
name|struct
name|slice
modifier|*
name|slice
decl_stmt|;
name|RR
expr_stmt|;
name|sdp
operator|=
name|private
expr_stmt|;
name|pd
operator|=
name|sdp
operator|->
name|pd
expr_stmt|;
name|slice
operator|=
name|pd
operator|->
name|slice_down
expr_stmt|;
name|blkoff
operator|+=
name|sdp
operator|->
name|offset
expr_stmt|;
return|return
call|(
modifier|*
name|slice
operator|->
name|handler_down
operator|->
name|dump
call|)
argument_list|(
name|slice
operator|->
name|private_down
argument_list|,
name|blkoff
argument_list|,
name|blkcnt
argument_list|)
return|;
block|}
end_function

end_unit

