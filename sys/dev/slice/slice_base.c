begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (C) 1997,1998 Julian Elischer.  All rights reserved.  * julian@freebsd.org  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  1. Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  2. Redistributions in binary form must reproduce the above copyright notice,  *     this list of conditions and the following disclaimer in the documentation  *     and/or other materials provided with the distribution.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER ``AS IS'' AND ANY EXPRESS  * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE HOLDER OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *   *	$Id: slice_base.c,v 1.5 1998/07/13 08:22:56 julian Exp $  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_comment
comment|/* SYSINIT stuff */
end_comment

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_comment
comment|/* FREAD/FWRITE */
end_comment

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_comment
comment|/* cdevsw stuff */
end_comment

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_comment
comment|/* malloc region definitions */
end_comment

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_comment
comment|/* buffers for IO */
end_comment

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_comment
comment|/* linked lists etc. */
end_comment

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_comment
comment|/* S_IFCHR, S_IFBLK */
end_comment

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_comment
comment|/* the sysctl for shooting self in foot */
end_comment

begin_comment
comment|/*#include<sys/devfsext.h> */
end_comment

begin_comment
comment|/* DEVFS defintitions */
end_comment

begin_include
include|#
directive|include
file|<dev/slice/slice.h>
end_include

begin_comment
comment|/* temporary location */
end_comment

begin_define
define|#
directive|define
name|SLICESPL
parameter_list|()
value|splbio()
end_define

begin_function_decl
specifier|static
name|void
name|sl_async_done
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|slicexclusive
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default value == "foot shootable" */
end_comment

begin_comment
comment|/*  * Make a new type available. Just link it in, but first make sure there is  * no name collision.  */
end_comment

begin_decl_stmt
specifier|static
name|sh_p
name|types
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|sl_newtype
parameter_list|(
name|sh_p
name|tp
parameter_list|)
block|{
if|if
condition|(
name|sl_findtype
argument_list|(
name|tp
operator|->
name|name
argument_list|)
condition|)
block|{
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
name|tp
operator|->
name|next
operator|=
name|types
expr_stmt|;
name|types
operator|=
name|tp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Look for a type of the name given.  */
end_comment

begin_function
name|sh_p
name|sl_findtype
parameter_list|(
name|char
modifier|*
name|type
parameter_list|)
block|{
name|sh_p
name|tp
decl_stmt|;
name|tp
operator|=
name|types
expr_stmt|;
while|while
condition|(
name|tp
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|tp
operator|->
name|name
argument_list|,
name|type
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|tp
operator|)
return|;
name|tp
operator|=
name|tp
operator|->
name|next
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Make a handler instantiation of the requested type.  * don't take no for an answer.  * force it to mark it's new territory.  * Must be called from a within a user context.  *   */
end_comment

begin_function
specifier|static
name|int
name|sl_make_handler
parameter_list|(
name|sl_p
name|slice
parameter_list|,
name|char
modifier|*
name|type
parameter_list|)
block|{
name|sh_p
name|handler_up
decl_stmt|;
comment|/* 	 * check that the type makes sense. 	 */
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|handler_up
operator|=
name|sl_findtype
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|handler_up
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * and call the constructor 	 */
name|slice
operator|->
name|flags
operator||=
name|SLF_DONT_ARGUE
expr_stmt|;
return|return
operator|(
call|(
modifier|*
name|handler_up
operator|->
name|claim
call|)
argument_list|(
name|slice
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * lock and unlock Slices while doing operations such as open().  * gets a reference on the slice..  * XXX This doesn't work for SMP.  */
end_comment

begin_function
name|int
name|slice_lock
parameter_list|(
name|struct
name|slice
modifier|*
name|slice
parameter_list|)
block|{
name|int
name|s
init|=
name|SLICESPL
argument_list|()
decl_stmt|;
name|slice
operator|->
name|refs
operator|++
expr_stmt|;
while|while
condition|(
name|slice
operator|->
name|flags
operator|&
operator|(
name|SLF_LOCKED
operator||
name|SLF_INVALID
operator|)
condition|)
block|{
if|if
condition|(
name|slice
operator|->
name|flags
operator|&
name|SLF_INVALID
condition|)
block|{
name|sl_unref
argument_list|(
name|slice
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|slice
operator|->
name|flags
operator||=
name|SLF_WANTED
expr_stmt|;
name|tsleep
argument_list|(
name|slice
argument_list|,
name|PRIBIO
argument_list|,
literal|"slice_lock"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|slice
operator|->
name|flags
operator||=
name|SLF_LOCKED
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Releases a slice  * Assumes that if we had it locked, no-one else could invalidate it.  * We can still hold a reference on it.  */
end_comment

begin_function
name|int
name|slice_unlock
parameter_list|(
name|struct
name|slice
modifier|*
name|slice
parameter_list|)
block|{
name|int
name|s
init|=
name|SLICESPL
argument_list|()
decl_stmt|;
name|slice
operator|->
name|flags
operator|&=
operator|~
name|SLF_LOCKED
expr_stmt|;
if|if
condition|(
name|slice
operator|->
name|flags
operator|&
name|SLF_WANTED
condition|)
block|{
name|slice
operator|->
name|flags
operator|&=
operator|~
name|SLF_WANTED
expr_stmt|;
name|wakeup
argument_list|(
name|slice
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * create a new slice. Link it into the structures.  * As of yet it has no upper handler.  */
end_comment

begin_function
name|int
name|sl_make_slice
parameter_list|(
name|sh_p
name|handler_down
parameter_list|,
name|void
modifier|*
name|private_down
parameter_list|,
name|struct
name|slicelimits
modifier|*
name|limits
parameter_list|,
name|sl_p
modifier|*
name|slicepp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|sl_p
name|slice
decl_stmt|;
comment|/* 	 * Allocate storage for this instance . 	 */
name|slice
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|slice
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|slice
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"slice failed to allocate driver storage\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|slice
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|slice
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|slice
operator|->
name|name
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|slice
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"slice failed name storage\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|slice
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|strcpy
argument_list|(
name|slice
operator|->
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|slice
operator|->
name|handler_down
operator|=
name|handler_down
expr_stmt|;
name|slice
operator|->
name|private_down
operator|=
name|private_down
expr_stmt|;
name|handler_down
operator|->
name|refs
operator|++
expr_stmt|;
name|slice
operator|->
name|limits
operator|=
operator|*
name|limits
expr_stmt|;
name|slice_add_device
argument_list|(
name|slice
argument_list|)
expr_stmt|;
name|slice
operator|->
name|refs
operator|=
literal|1
expr_stmt|;
comment|/* one for our downward creator */
operator|*
name|slicepp
operator|=
name|slice
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Forceably start a shutdown process on a slice. Either call it's shutdown  * method, or do the default shutdown if there is no type-specific method.  * XXX Really should say who called us.  * Should be called at SLICESPL (splbio)  */
end_comment

begin_function
name|void
name|sl_rmslice
parameter_list|(
name|sl_p
name|slice
parameter_list|)
block|{
name|RR
expr_stmt|;
comment|/* 	 * An extra reference so it doesn't go away while we are not looking. 	 */
name|slice
operator|->
name|refs
operator|++
expr_stmt|;
if|if
condition|(
name|slice
operator|->
name|flags
operator|&
name|SLF_INVALID
condition|)
block|{
comment|/* 		 * If it's already shutting down, let it die without further 		 * taunting. "go away or I'll taunt you a second time, you 		 * silly eenglish pig-dog" 		 */
name|sl_unref
argument_list|(
name|slice
argument_list|)
expr_stmt|;
comment|/* possibly the last reference */
return|return;
block|}
comment|/* 	 * Mark it as invalid so any newcomers know not to try use it. 	 * No real need to LOCK it. 	 */
name|slice
operator|->
name|flags
operator|&=
operator|~
name|SLF_OPEN_STATE
expr_stmt|;
name|slice
operator|->
name|flags
operator||=
name|SLF_INVALID
expr_stmt|;
comment|/* 	 * remove the device appendages. 	 * Any open vnodes SHOULD go to deadfs. 	 */
name|slice_remove_device
argument_list|(
name|slice
argument_list|)
expr_stmt|;
comment|/* 	 * Propogate the damage upwards.  	 * Note that the revoke method is not optional. 	 * The upper handler releases it's reference so refs--. 	 */
if|if
condition|(
name|slice
operator|->
name|handler_up
condition|)
block|{
call|(
modifier|*
name|slice
operator|->
name|handler_up
operator|->
name|revoke
call|)
argument_list|(
name|slice
operator|->
name|private_up
argument_list|)
expr_stmt|;
block|}
name|sl_unref
argument_list|(
name|slice
argument_list|)
expr_stmt|;
comment|/* One for the lower handler that called us */
name|sl_unref
argument_list|(
name|slice
argument_list|)
expr_stmt|;
comment|/* possibly the last reference */
block|}
end_function

begin_function
name|void
name|sl_unref
parameter_list|(
name|sl_p
name|slice
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|--
operator|(
name|slice
operator|->
name|refs
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|FREE
argument_list|(
name|slice
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/***********************************************************************  * Handler probing state machine support.  ***********************************************************************/
end_comment

begin_comment
comment|/*  * Ask all known handler types if a given slice is handled by them.  * If the slice specifies a type, then just find that.  * This will be done asynchronously. The claim operation may simply  * queue the work to be done.  When this item has been rejected,   * control will pass to slice_probe_next().   * This  starts up the generic probeing state machine, which  * will start up the probing state machine for each handler in turn,  * until one has claimed the device, or there are no more handlers.  *   */
end_comment

begin_function
name|void
name|slice_start_probe
parameter_list|(
name|sl_p
name|slice
parameter_list|)
block|{
name|sh_p
name|tp
init|=
name|types
decl_stmt|;
if|if
condition|(
name|slice
operator|->
name|probeinfo
operator|.
name|type
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|slice
operator|->
name|handler_up
operator|==
name|NULL
condition|)
block|{
name|slice
operator|->
name|probeinfo
operator|.
name|trial_handler
operator|=
name|tp
expr_stmt|;
name|slice
operator|->
name|flags
operator||=
name|SLF_PROBING
expr_stmt|;
name|printf
argument_list|(
literal|"%s: probing for %s.. "
argument_list|,
name|slice
operator|->
name|name
argument_list|,
name|tp
operator|->
name|name
argument_list|)
expr_stmt|;
call|(
modifier|*
name|tp
operator|->
name|claim
call|)
argument_list|(
name|slice
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* 	 * Null string ("") means "don't even try". Caller probably 	 * should pre-trap such cases but we'll check here too. 	 * Notice that the PROBING bit is not set. 	 * This means that we should not do a full probe, 	 * but just this one handler. 	 */
if|if
condition|(
name|slice
operator|->
name|probeinfo
operator|.
name|type
index|[
literal|0
index|]
condition|)
block|{
name|tp
operator|=
name|sl_findtype
argument_list|(
name|slice
operator|->
name|probeinfo
operator|.
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
condition|)
block|{
name|printf
argument_list|(
literal|"%s: attaching %s..\n"
argument_list|,
name|slice
operator|->
name|name
argument_list|,
name|tp
operator|->
name|name
argument_list|)
expr_stmt|;
call|(
modifier|*
name|tp
operator|->
name|claim
call|)
argument_list|(
name|slice
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Move the slice probe type, on to the next type  * and call that.  Called from failed probes.  * Don't do anything if the PROBING flag has been cleared.  */
end_comment

begin_function
name|void
name|slice_probe_next
parameter_list|(
name|sl_p
name|slice
parameter_list|)
block|{
name|sh_p
name|tp
init|=
name|slice
operator|->
name|probeinfo
operator|.
name|trial_handler
decl_stmt|;
if|if
condition|(
operator|(
name|slice
operator|->
name|flags
operator|&
name|SLF_PROBING
operator|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|tp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|slice
operator|->
name|probeinfo
operator|.
name|trial_handler
operator|=
name|tp
operator|=
name|tp
operator|->
name|next
condition|)
block|{
name|printf
argument_list|(
literal|"%s: probing for %s.. "
argument_list|,
name|slice
operator|->
name|name
argument_list|,
name|tp
operator|->
name|name
argument_list|)
expr_stmt|;
call|(
modifier|*
name|tp
operator|->
name|claim
call|)
argument_list|(
name|slice
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|slice
operator|->
name|flags
operator|&=
operator|~
name|SLF_PROBING
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Given a slice,  launch an IOrequest for information  * This is not a bulk IO routine but meant for probes etc.  * This routine may be called at interrupt time. It schedules an   * IO that will be completed asynchronously. On completion the  * Block IO system will call sl_async_done, which will trigger  * a completion event for the handler's probe state machine.  */
end_comment

begin_function
name|int
name|slice_request_block
parameter_list|(
name|sl_p
name|slice
parameter_list|,
name|int
name|blknum
parameter_list|)
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|RR
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|PARANOID
if|if
condition|(
name|slice
operator|->
name|private_up
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"slice_request_block: no pd"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|slice
operator|->
name|flags
operator|&
name|SLF_PROBE_STATE
condition|)
block|{
name|panic
argument_list|(
literal|"slice_request_block: 2nd IO"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* PARANOID */
name|bp
operator|=
name|geteblk
argument_list|(
operator|(
name|int
operator|)
name|slice
operator|->
name|limits
operator|.
name|blksize
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|slice
operator|->
name|flags
operator||=
name|SLF_WAIT_READ
expr_stmt|;
name|bp
operator|->
name|b_iodone
operator|=
operator|&
name|sl_async_done
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_CALL
expr_stmt|;
name|bp
operator|->
name|b_dev
operator|=
operator|(
name|dev_t
operator|)
name|slice
expr_stmt|;
comment|/* XXX HACK ALERT! */
name|bp
operator|->
name|b_pblkno
operator|=
name|bp
operator|->
name|b_blkno
operator|=
name|blknum
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
name|slice
operator|->
name|limits
operator|.
name|blksize
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_BUSY
operator||
name|B_READ
expr_stmt|;
name|sliceio
argument_list|(
name|slice
argument_list|,
name|bp
argument_list|,
name|SLW_ABOVE
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write a block on behalf of a handler.  * This is not a bulk IO routine but meant for probes etc.  * I think that perhaps it should attempt to do sliceopen()  * calls on the slice first. (XXX?) no, they may block?  */
end_comment

begin_function
name|int
name|slice_writeblock
parameter_list|(
name|struct
name|slice
modifier|*
name|slice
parameter_list|,
name|int
name|blkno
parameter_list|,
name|void
function_decl|(
modifier|*
name|iodone
function_decl|)
parameter_list|(
name|struct
name|buf
modifier|*
parameter_list|)
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|PARANOID
if|if
condition|(
name|slice
operator|->
name|handler_up
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"slice_writeblock: no handler"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|slice
operator|->
name|flags
operator|&
name|SLF_PROBE_STATE
condition|)
block|{
name|panic
argument_list|(
literal|"slice_writeblock: 2nd IO"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* PARANOID */
if|if
condition|(
name|len
operator|>
name|slice
operator|->
name|limits
operator|.
name|blksize
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|bp
operator|=
name|geteblk
argument_list|(
operator|(
name|int
operator|)
name|slice
operator|->
name|limits
operator|.
name|blksize
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|slice
operator|->
name|flags
operator||=
name|SLF_WAIT_WRITE
expr_stmt|;
name|bcopy
argument_list|(
name|data
argument_list|,
name|bp
operator|->
name|b_data
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_iodone
operator|=
name|sl_async_done
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_CALL
expr_stmt|;
name|bp
operator|->
name|b_dev
operator|=
operator|(
name|dev_t
operator|)
name|slice
expr_stmt|;
comment|/* XXX HACK ALERT! */
name|bp
operator|->
name|b_pblkno
operator|=
name|bp
operator|->
name|b_blkno
operator|=
name|blkno
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
name|slice
operator|->
name|limits
operator|.
name|blksize
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_BUSY
operator||
name|B_WRITE
expr_stmt|;
name|sliceio
argument_list|(
name|slice
argument_list|,
name|bp
argument_list|,
name|SLW_ABOVE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   * called with an argument of a bp when it is completed.  * Th eslice is extracted from the operation and the completion event  * is used to trigger that slice's state machine to make the next move.  */
end_comment

begin_function
specifier|static
name|void
name|sl_async_done
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|sl_p
name|slice
decl_stmt|;
name|int
name|error
decl_stmt|;
name|RR
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_dev
operator|<
literal|0xf0000000
condition|)
name|panic
argument_list|(
literal|"b_dev used in SLICE code"
argument_list|)
expr_stmt|;
name|slice
operator|=
operator|(
expr|struct
name|slice
operator|*
operator|)
name|bp
operator|->
name|b_dev
expr_stmt|;
comment|/* XXX HACK! */
ifdef|#
directive|ifdef
name|PARANOID
if|if
condition|(
name|slice
operator|->
name|handler_up
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"sl_async_done: no pd"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
block|{
if|if
condition|(
operator|(
name|slice
operator|->
name|flags
operator|&
name|SLF_PROBE_STATE
operator|)
operator|!=
name|SLF_WAIT_READ
condition|)
name|panic
argument_list|(
literal|"sl_async_done: unexpected read completion"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|slice
operator|->
name|flags
operator|&
name|SLF_PROBE_STATE
operator|)
operator|!=
name|SLF_WAIT_WRITE
condition|)
name|panic
argument_list|(
literal|"sl_async_done: unexpected write completion"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* PARANOID */
comment|/* 	 * if the IO failed, then abandon the probes and  	 * return. Possibly ask the lower layer to try again later? 	 * It's assumed that a a revoke will abort the state machine. 	 * XXX Maybe we should call the done() routine anyhow 	 * and let each handler detect the failure.. 	 */
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ERROR
condition|)
block|{
call|(
modifier|*
name|slice
operator|->
name|handler_up
operator|->
name|revoke
call|)
argument_list|(
name|slice
operator|->
name|private_up
argument_list|)
expr_stmt|;
comment|/* (* slice->handler_down->SOMETHING) (slice->private_down); */
name|bp
operator|->
name|b_flags
operator||=
name|B_INVAL
operator||
name|B_AGE
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|slice
operator|->
name|flags
operator|&=
operator|~
name|SLF_PROBING
expr_stmt|;
return|return;
block|}
comment|/* 	 * Call the handler's done() routine. This will 	 * examine the result of the probe and do whatever is needed. 	 * Check for abnormal error conditions. (return value non 0) 	 * Not claiming the slice is not an error condition. 	 */
if|if
condition|(
call|(
modifier|*
name|slice
operator|->
name|handler_up
operator|->
name|done
call|)
argument_list|(
name|slice
argument_list|,
name|bp
argument_list|)
condition|)
block|{
name|slice
operator|->
name|flags
operator|&=
operator|~
name|SLF_PROBING
expr_stmt|;
return|return;
block|}
comment|/* 	 * If the handler has left itself there, or cleared 	 * the PROBING bit, then consider 	 * probing to have come to a close. So just return. 	 * XXX An IO error would be a great hint to abandon probing as well. 	 * we catch that on the way up but we might want to give 	 * the handler a chance to clean up state? 	 */
if|if
condition|(
name|slice
operator|->
name|handler_up
operator|||
operator|(
operator|(
name|slice
operator|->
name|flags
operator|&
name|SLF_PROBING
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|slice
operator|->
name|flags
operator|&=
operator|~
name|SLF_PROBING
expr_stmt|;
return|return;
block|}
comment|/* 	 * The handler didn't claim it. Nor did it abort the  	 * probing sequence.  	 * Ok, so we should try the next handler to probe. 	 */
name|slice_probe_next
argument_list|(
name|slice
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * functions that are used to call the next level down.  */
end_comment

begin_function
name|void
name|sliceio
parameter_list|(
name|sl_p
name|slice
parameter_list|,
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|enum
name|slc_who
name|who
parameter_list|)
block|{
comment|/* XXX do shortcuts here */
if|if
condition|(
name|slice
operator|->
name|flags
operator|&
name|SLF_INVALID
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * if it's from above, assume it hasn't 	 * broken it's agreement about read/write. 	 * A higher level slice would have caught it. 	 * Make no such assumption if it's this device. 	 */
if|if
condition|(
name|who
operator|==
name|SLW_DEVICE
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|slice
operator|->
name|flags
operator|&
name|SLF_OPEN_DEV_WR
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|==
name|B_WRITE
operator|)
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EROFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
call|(
modifier|*
name|slice
operator|->
name|handler_down
operator|->
name|IOreq
call|)
argument_list|(
name|slice
operator|->
name|private_down
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return;
name|bad
label|:
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
comment|/* toss transfer, we're done early */
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Try open a slice.  * don't forget to say if we are above (1) or the dev (0).  *  * We really need to add a lot of support for CHANGING  * what we have openned.. i.e if we have ABOVE open R/W  * and DEVICE open R/O, then closing the device  * should downgrade our open to those items below us to R/O.  * This would need support in both open and close routines in both  * slice and handler code.  *   * ((*) == Illegal state.. (how did we get here?))  * (must have been in "shoot foot mode").   * A bit already set can be set again. (may represent part of an upgrade)  * This may not hold true if we are in an 'illegal state'.  * Some such opens will fail in an attempt to revert to a legal state.  * success = ((request& allowed[state]) == request)  */
end_comment

begin_define
define|#
directive|define
name|UP_RDWR
value|SLF_OPEN_UP
end_define

begin_define
define|#
directive|define
name|CHR_RDWR
value|SLF_OPEN_CHR
end_define

begin_define
define|#
directive|define
name|CHR_RD
value|SLF_OPEN_CHR_RD
end_define

begin_define
define|#
directive|define
name|BLK_RDWR
value|SLF_OPEN_BLK
end_define

begin_define
define|#
directive|define
name|BLK_RD
value|SLF_OPEN_BLK_RD
end_define

begin_decl_stmt
specifier|static
name|u_char
name|allowed
index|[
literal|64
index|]
init|=
block|{
comment|/* Present state  |  requested states allowed		*/
comment|/* UP  CHR BLK    |      UP    CHR    BLK		*/
comment|/* R W R W R W    |     R W    R W    R W		*/
comment|/* 0 0 0 0 0 0		1 1    1 1    1 1	*/
operator|(
name|UP_RDWR
operator||
name|CHR_RDWR
operator||
name|BLK_RDWR
operator|)
block|,
comment|/* 0 0 0 0 0 1		0 0    1 0    1 1	*/
operator|(
name|CHR_RD
operator||
name|BLK_RDWR
operator|)
block|,
comment|/* 0 0 0 0 1 0		1 1    1 1    1 1	*/
operator|(
name|UP_RDWR
operator||
name|CHR_RDWR
operator||
name|BLK_RDWR
operator|)
block|,
comment|/* 0 0 0 0 1 1		0 0    1 0    1 1	*/
operator|(
name|CHR_RD
operator||
name|BLK_RDWR
operator|)
block|,
comment|/* 0 0 0 1 0 0		0 0    1 1    1 0	*/
operator|(
name|CHR_RDWR
operator||
name|BLK_RD
operator|)
block|,
comment|/* 0 0 0 1 0 1		0 0    1 0    1 0 (*)	*/
operator|(
name|CHR_RD
operator||
name|BLK_RD
operator|)
block|,
comment|/* 0 0 0 1 1 0		0 0    1 1    1 0	*/
operator|(
name|CHR_RDWR
operator||
name|BLK_RD
operator|)
block|,
comment|/* 0 0 0 1 1 1		0 0    1 0    1 0 (*)	*/
operator|(
name|CHR_RD
operator||
name|BLK_RD
operator|)
block|,
comment|/* 0 0 1 0 0 0		1 1    1 1    1 1	*/
operator|(
name|UP_RDWR
operator||
name|CHR_RDWR
operator||
name|BLK_RDWR
operator|)
block|,
comment|/* 0 0 1 0 0 1		0 0    1 0    1 1	*/
operator|(
name|CHR_RD
operator||
name|BLK_RDWR
operator|)
block|,
comment|/* 0 0 1 0 1 0		1 1    1 1    1 1	*/
operator|(
name|UP_RDWR
operator||
name|CHR_RDWR
operator||
name|BLK_RDWR
operator|)
block|,
comment|/* 0 0 1 0 1 1		0 0    1 0    1 1	*/
operator|(
name|CHR_RD
operator||
name|BLK_RDWR
operator|)
block|,
comment|/* 0 0 1 1 0 0		0 0    1 1    1 0	*/
operator|(
name|CHR_RDWR
operator||
name|BLK_RD
operator|)
block|,
comment|/* 0 0 1 1 0 1		0 0    1 0    1 0 (*)	*/
operator|(
name|CHR_RD
operator||
name|BLK_RD
operator|)
block|,
comment|/* 0 0 1 1 1 0		0 0    1 1    1 0	*/
operator|(
name|CHR_RDWR
operator||
name|BLK_RD
operator|)
block|,
comment|/* 0 0 1 1 1 1		0 0    1 0    1 0 (*)	*/
operator|(
name|CHR_RD
operator||
name|BLK_RD
operator|)
block|,
comment|/* 0 1 0 0 0 0		1 1    1 0    1 0	*/
operator|(
name|UP_RDWR
operator||
name|CHR_RD
operator||
name|BLK_RD
operator|)
block|,
comment|/* 0 1 0 0 0 1		0 0    1 0    1 0 (*)	*/
operator|(
name|CHR_RD
operator||
name|BLK_RD
operator|)
block|,
comment|/* 0 1 0 0 1 0		1 1    1 0    1 0	*/
operator|(
name|UP_RDWR
operator||
name|CHR_RD
operator||
name|BLK_RD
operator|)
block|,
comment|/* 0 1 0 0 1 1		0 0    1 0    1 0 (*)	*/
operator|(
name|CHR_RD
operator||
name|BLK_RD
operator|)
block|,
comment|/* 0 1 0 1 0 0		0 0    1 0    1 0 (*)	*/
operator|(
name|CHR_RD
operator||
name|BLK_RD
operator|)
block|,
comment|/* 0 1 0 1 0 1		0 0    1 0    1 0 (*)	*/
operator|(
name|CHR_RD
operator||
name|BLK_RD
operator|)
block|,
comment|/* 0 1 0 1 1 0		0 0    1 0    1 0 (*)	*/
operator|(
name|CHR_RD
operator||
name|BLK_RD
operator|)
block|,
comment|/* 0 1 0 1 1 1		0 0    1 0    1 0 (*)	*/
operator|(
name|CHR_RD
operator||
name|BLK_RD
operator|)
block|,
comment|/* 0 1 1 0 0 0		1 1    1 0    1 0	*/
operator|(
name|UP_RDWR
operator||
name|CHR_RD
operator||
name|BLK_RD
operator|)
block|,
comment|/* 0 1 1 0 0 1		0 0    1 0    1 0 (*)	*/
operator|(
name|CHR_RD
operator||
name|BLK_RD
operator|)
block|,
comment|/* 0 1 1 0 1 0		1 1    1 0    1 0	*/
operator|(
name|UP_RDWR
operator||
name|CHR_RD
operator||
name|BLK_RD
operator|)
block|,
comment|/* 0 1 1 0 1 1		0 0    1 0    1 0 (*)	*/
operator|(
name|CHR_RD
operator||
name|BLK_RD
operator|)
block|,
comment|/* 0 1 1 1 0 0		0 0    1 0    1 0 (*)	*/
operator|(
name|CHR_RD
operator||
name|BLK_RD
operator|)
block|,
comment|/* 0 1 1 1 0 1		0 0    1 0    1 0 (*)	*/
operator|(
name|CHR_RD
operator||
name|BLK_RD
operator|)
block|,
comment|/* 0 1 1 1 1 0		0 0    1 0    1 0 (*)	*/
operator|(
name|CHR_RD
operator||
name|BLK_RD
operator|)
block|,
comment|/* 0 1 1 1 1 1		0 0    1 0    1 0 (*)	*/
operator|(
name|CHR_RD
operator||
name|BLK_RD
operator|)
block|,
comment|/* 1 0 0 0 0 0		1 1    1 0    1 0	*/
operator|(
name|UP_RDWR
operator||
name|CHR_RD
operator||
name|BLK_RD
operator|)
block|,
comment|/* 1 0 0 0 0 1		0 0    1 0    1 0 (*)	*/
operator|(
name|CHR_RD
operator||
name|BLK_RD
operator|)
block|,
comment|/* 1 0 0 0 1 0		1 1    1 0    1 0	*/
operator|(
name|UP_RDWR
operator||
name|CHR_RD
operator||
name|BLK_RD
operator|)
block|,
comment|/* 1 0 0 0 1 1		0 0    1 0    1 0 (*)	*/
operator|(
name|CHR_RD
operator||
name|BLK_RD
operator|)
block|,
comment|/* 1 0 0 1 0 0		0 0    1 0    1 0 (*)	*/
operator|(
name|CHR_RD
operator||
name|BLK_RD
operator|)
block|,
comment|/* 1 0 0 1 0 1		0 0    1 0    1 0 (*)	*/
operator|(
name|CHR_RD
operator||
name|BLK_RD
operator|)
block|,
comment|/* 1 0 0 1 1 0		0 0    1 0    1 0 (*)	*/
operator|(
name|CHR_RD
operator||
name|BLK_RD
operator|)
block|,
comment|/* 1 0 0 1 1 1		0 0    1 0    1 0 (*)	*/
operator|(
name|CHR_RD
operator||
name|BLK_RD
operator|)
block|,
comment|/* 1 0 1 0 0 0		1 1    1 0    1 0	*/
operator|(
name|UP_RDWR
operator||
name|CHR_RD
operator||
name|BLK_RD
operator|)
block|,
comment|/* 1 0 1 0 0 1		0 0    1 0    1 0 (*)	*/
operator|(
name|CHR_RD
operator||
name|BLK_RD
operator|)
block|,
comment|/* 1 0 1 0 1 0		1 1    1 0    1 0	*/
operator|(
name|UP_RDWR
operator||
name|CHR_RD
operator||
name|BLK_RD
operator|)
block|,
comment|/* 1 0 1 0 1 1		0 0    1 0    1 0 (*)	*/
operator|(
name|CHR_RD
operator||
name|BLK_RD
operator|)
block|,
comment|/* 1 0 1 1 0 0		0 0    1 0    1 0 (*)	*/
operator|(
name|CHR_RD
operator||
name|BLK_RD
operator|)
block|,
comment|/* 1 0 1 1 0 1		0 0    1 0    1 0 (*)	*/
operator|(
name|CHR_RD
operator||
name|BLK_RD
operator|)
block|,
comment|/* 1 0 1 1 1 0		0 0    1 0    1 0 (*)	*/
operator|(
name|CHR_RD
operator||
name|BLK_RD
operator|)
block|,
comment|/* 1 0 1 1 1 1		0 0    1 0    1 0 (*)	*/
operator|(
name|CHR_RD
operator||
name|BLK_RD
operator|)
block|,
comment|/* 1 1 0 0 0 0		1 1    1 0    1 0	*/
operator|(
name|UP_RDWR
operator||
name|CHR_RD
operator||
name|BLK_RD
operator|)
block|,
comment|/* 1 1 0 0 0 1		0 0    1 0    1 0 (*)	*/
operator|(
name|CHR_RD
operator||
name|BLK_RD
operator|)
block|,
comment|/* 1 1 0 0 1 0		1 1    1 0    1 0	*/
operator|(
name|UP_RDWR
operator||
name|CHR_RD
operator||
name|BLK_RD
operator|)
block|,
comment|/* 1 1 0 0 1 1		0 0    1 0    1 0 (*)	*/
operator|(
name|CHR_RD
operator||
name|BLK_RD
operator|)
block|,
comment|/* 1 1 0 1 0 0		0 0    1 0    1 0 (*)	*/
operator|(
name|CHR_RD
operator||
name|BLK_RD
operator|)
block|,
comment|/* 1 1 0 1 0 1		0 0    1 0    1 0 (*)	*/
operator|(
name|CHR_RD
operator||
name|BLK_RD
operator|)
block|,
comment|/* 1 1 0 1 1 0		0 0    1 0    1 0 (*)	*/
operator|(
name|CHR_RD
operator||
name|BLK_RD
operator|)
block|,
comment|/* 1 1 0 1 1 1		0 0    1 0    1 0 (*)	*/
operator|(
name|CHR_RD
operator||
name|BLK_RD
operator|)
block|,
comment|/* 1 1 1 0 0 0		1 1    1 0    1 0	*/
operator|(
name|UP_RDWR
operator||
name|CHR_RD
operator||
name|BLK_RD
operator|)
block|,
comment|/* 1 1 1 0 0 1		0 0    1 0    1 0 (*)	*/
operator|(
name|CHR_RD
operator||
name|BLK_RD
operator|)
block|,
comment|/* 1 1 1 0 1 0		1 1    1 0    1 0	*/
operator|(
name|UP_RDWR
operator||
name|CHR_RD
operator||
name|BLK_RD
operator|)
block|,
comment|/* 1 1 1 0 1 1		0 0    1 0    1 0 (*)	*/
operator|(
name|CHR_RD
operator||
name|BLK_RD
operator|)
block|,
comment|/* 1 1 1 1 0 0		0 0    1 0    1 0 (*)	*/
operator|(
name|CHR_RD
operator||
name|BLK_RD
operator|)
block|,
comment|/* 1 1 1 1 0 1		0 0    1 0    1 0 (*)	*/
operator|(
name|CHR_RD
operator||
name|BLK_RD
operator|)
block|,
comment|/* 1 1 1 1 1 0		0 0    1 0    1 0 (*)	*/
operator|(
name|CHR_RD
operator||
name|BLK_RD
operator|)
block|,
comment|/* 1 1 1 1 1 1		0 0    1 0    1 0 (*)	*/
operator|(
name|CHR_RD
operator||
name|BLK_RD
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|sliceopen
parameter_list|(
name|struct
name|slice
modifier|*
name|slice
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|enum
name|slc_who
name|who
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|sl_flags
init|=
name|slice
operator|->
name|flags
operator|&
name|SLF_OPEN_STATE
decl_stmt|;
name|int
name|or_flags
decl_stmt|;
name|int
name|and_flags
decl_stmt|;
name|int
name|dn_flags
decl_stmt|;
name|int
name|odn_flags
decl_stmt|;
if|if
condition|(
name|slice
operator|->
name|flags
operator|&
name|SLF_INVALID
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* 	 * Firstly, don't allow re-opens of what is already open 	 */
if|if
condition|(
name|error
operator|=
name|slice_lock
argument_list|(
name|slice
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|EBUSY
expr_stmt|;
comment|/* default answer */
switch|switch
condition|(
name|who
condition|)
block|{
case|case
name|SLW_ABOVE
case|:
name|or_flags
operator|=
operator|(
operator|(
name|flags
operator|&
name|FREAD
operator|)
condition|?
name|SLF_OPEN_UP_RD
else|:
literal|0
operator|)
expr_stmt|;
name|or_flags
operator||=
operator|(
operator|(
name|flags
operator|&
name|FWRITE
operator|)
condition|?
name|SLF_OPEN_UP_WR
else|:
literal|0
operator|)
expr_stmt|;
name|and_flags
operator|=
operator|~
name|SLF_OPEN_UP
expr_stmt|;
break|break;
case|case
name|SLW_DEVICE
case|:
switch|switch
condition|(
name|mode
operator|&
name|S_IFMT
condition|)
block|{
case|case
name|S_IFCHR
case|:
name|or_flags
operator|=
operator|(
operator|(
name|flags
operator|&
name|FREAD
operator|)
condition|?
name|SLF_OPEN_CHR_RD
else|:
literal|0
operator|)
expr_stmt|;
name|or_flags
operator||=
operator|(
operator|(
name|flags
operator|&
name|FWRITE
operator|)
condition|?
name|SLF_OPEN_CHR_WR
else|:
literal|0
operator|)
expr_stmt|;
name|and_flags
operator|=
operator|~
name|SLF_OPEN_CHR
expr_stmt|;
break|break;
case|case
name|S_IFBLK
case|:
name|or_flags
operator|=
operator|(
operator|(
name|flags
operator|&
name|FREAD
operator|)
condition|?
name|SLF_OPEN_BLK_RD
else|:
literal|0
operator|)
expr_stmt|;
name|or_flags
operator||=
operator|(
operator|(
name|flags
operator|&
name|FWRITE
operator|)
condition|?
name|SLF_OPEN_BLK_WR
else|:
literal|0
operator|)
expr_stmt|;
name|and_flags
operator|=
operator|~
name|SLF_OPEN_BLK
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"slice: bad open type"
argument_list|)
expr_stmt|;
block|}
comment|/* XXX 	only accumulate flags as we don't know about all closes */
comment|/* XXX */
if|if
condition|(
name|or_flags
condition|)
comment|/* XXX */
name|and_flags
operator|=
operator|~
literal|0
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"slice: bad request source"
argument_list|)
expr_stmt|;
block|}
comment|/*  	 * Be appropriatly paranoid depending on the system mode. 	 * This is also probably wrong XXX 	 */
switch|switch
condition|(
name|slicexclusive
condition|)
block|{
case|case
literal|2
case|:
comment|/* 		 * if any one path has it open, we forbid any other 		 * paths. Only allow an upgrade/downgrade from 		 * the same source as the present openner. 		 */
if|if
condition|(
name|sl_flags
operator|&
name|and_flags
condition|)
goto|goto
name|reject
goto|;
case|case
literal|1
case|:
comment|/* 		 * The behaviour is encoded into the state array given above. 	 	 */
if|if
condition|(
operator|(
name|or_flags
operator|&
name|allowed
index|[
name|sl_flags
index|]
operator|)
operator|!=
name|or_flags
condition|)
goto|goto
name|reject
goto|;
break|break;
case|case
literal|0
case|:
comment|/* 		 * Permission is granted to shoot self in foot. 		 * All three of UPPER, CHAR and BLK can be open at once. 		 */
break|break;
block|}
comment|/* 	 * Get the old open mode and the new open mode. 	 * If we already have it open in this way, don't do it again. 	 *  	 * XXX More thought needed for the locking and open-flags. 	 * For now ignore the existance of flags other than FWRITE& FREAD. 	 */
name|odn_flags
operator|=
operator|(
name|sl_flags
operator|&
name|SLF_OPEN_WR
operator|)
condition|?
name|FWRITE
else|:
literal|0
expr_stmt|;
name|odn_flags
operator||=
operator|(
name|sl_flags
operator|&
name|SLF_OPEN_RD
operator|)
condition|?
name|FREAD
else|:
literal|0
expr_stmt|;
name|sl_flags
operator|&=
name|and_flags
expr_stmt|;
name|sl_flags
operator||=
name|or_flags
expr_stmt|;
name|dn_flags
operator|=
operator|(
name|sl_flags
operator|&
name|SLF_OPEN_WR
operator|)
condition|?
name|FWRITE
else|:
literal|0
expr_stmt|;
name|dn_flags
operator||=
operator|(
name|sl_flags
operator|&
name|SLF_OPEN_RD
operator|)
condition|?
name|FREAD
else|:
literal|0
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dn_flags
operator|!=
name|odn_flags
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
call|(
modifier|*
name|slice
operator|->
name|handler_down
operator|->
name|open
call|)
argument_list|(
name|slice
operator|->
name|private_down
argument_list|,
name|dn_flags
argument_list|,
name|mode
argument_list|,
name|p
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|reject
goto|;
block|}
block|}
name|slice
operator|->
name|flags
operator|&=
operator|~
name|SLF_OPEN_STATE
expr_stmt|;
name|slice
operator|->
name|flags
operator||=
name|sl_flags
expr_stmt|;
if|#
directive|if
literal|1
comment|/* it was basically a close */
if|if
condition|(
operator|(
name|slice
operator|->
name|flags
operator|&
name|SLF_OPEN_STATE
operator|)
operator|==
name|SLF_CLOSED
condition|)
block|{
name|sh_p
name|tp
decl_stmt|;
comment|/* 		 * If we had an upper handler, ask it to check if it's still 		 * valid. it may decide to self destruct. 		 */
if|if
condition|(
name|slice
operator|->
name|handler_up
condition|)
block|{
call|(
modifier|*
name|slice
operator|->
name|handler_up
operator|->
name|verify
call|)
argument_list|(
name|slice
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If we don't have an upper handler, check if 		 * maybe there is now a suitable environment for one. 		 * We may end up with a different handler 		 * from what we had above. Maybe we should clear the hint? 		 * Maybe we should ask the lower one to re-issue the request? 		 */
if|if
condition|(
name|slice
operator|->
name|handler_up
operator|==
name|NULL
condition|)
block|{
name|slice_start_probe
argument_list|(
name|slice
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|reject
label|:
name|slice_unlock
argument_list|(
name|slice
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|slice
operator|->
name|flags
operator|&
name|SLF_INVALID
operator|)
operator|==
name|SLF_INVALID
condition|)
name|error
operator|=
name|ENODEV
expr_stmt|;
comment|/* we've been zapped while down there! */
name|sl_unref
argument_list|(
name|slice
argument_list|)
expr_stmt|;
comment|/* slice_lock gave us a ref.*/
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|void sliceclose(struct slice *slice, int flags, int mode, 	struct proc * p, enum slc_who who) { 	sh_p	tp;  	if (slice->flags& SLF_INVALID)  		return ; 	if (slice_lock(slice)) 		return ; 	switch (who) { 	case	SLW_ABOVE: 		slice->flags&= ~SLF_OPEN_UP; 		break; 	case	SLW_DEVICE: 		switch (mode& S_IFMT) { 		case S_IFCHR: 			slice->flags&= ~SLF_OPEN_CHR; 			break; 		case S_IFBLK: 			slice->flags&= ~SLF_OPEN_BLK; 			break; 		default: 			panic("slice: bad open type"); 		}
comment|/* 		 * If we had an upper handler, ask it to check if it's still 		 * valid. it may decide to self destruct. 		 */
end_comment

begin_comment
unit|if (slice->handler_up) { 			(*slice->handler_up->verify)(slice); 		}
comment|/* 		 * If we don't have an upper handler, check if 		 * maybe there is now a suitable environment for one. 		 * We may end up with a different handler 		 * from what we had above. Maybe we should clear the hint? 		 * Maybe we should ask the lower one to re-issue the request? 		 */
end_comment

begin_comment
unit|if (slice->handler_up == NULL) { 			if ((tp = slice_start_probe(slice)) != NULL) { 				(*tp->constructor)(slice); 			} 		} 		break; 	}
comment|/* 	 * Last-close semantics strike again 	 * This may refine to a downgrade if we closed (say) the last writer 	 * but there are still readers. 	 * probably open/close should merge to one 'mode-change' function. 	 * (except for a vnode reference with no mode) 	 */
end_comment

begin_endif
unit|if ( (slice->flags& SLF_OPEN_STATE) == 0) 		(*slice->handler_down->close) (slice->private_down, 				      flags, mode, p); 	slice_unlock(slice); 	sl_unref(slice); 	return ; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_comment
comment|/*  * control behaviour of slices WRT sharing:  * 2 = no sharing  * 1 = read on a device already mounted (or parent of) is ok. No writes.  * 0 = go ahead.. shoot yourself in the foot.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sysctl_kern_slicexclusive
name|SYSCTL_HANDLER_ARGS
block|{
name|int
name|error
decl_stmt|;
name|int
name|new_val
init|=
name|slicexclusive
decl_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|new_val
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|new_val
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|new_val
operator|<
literal|3
operator|)
condition|)
block|{
name|slicexclusive
operator|=
name|new_val
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|slicexclusive
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|slicexclusive
argument_list|,
name|sysctl_kern_slicexclusive
argument_list|,
literal|"I"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

