begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (C) 1997,1998 Julian Elischer.  All rights reserved.  * julian@freebsd.org  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  1. Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  2. Redistributions in binary form must reproduce the above copyright notice,  *     this list of conditions and the following disclaimer in the documentation  *     and/or other materials provided with the distribution.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER ``AS IS'' AND ANY EXPRESS  * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE HOLDER OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *   *	$Id: mbr.c,v 1.7 1998/07/13 08:22:55 julian Exp $  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_include
include|#
directive|include
file|<sys/dkstat.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sliceio.h>
end_include

begin_include
include|#
directive|include
file|<dev/slice/slice.h>
end_include

begin_struct
struct|struct
name|private_data
block|{
name|u_int32_t
name|flags
decl_stmt|;
name|struct
name|slice
modifier|*
name|slice_down
decl_stmt|;
name|int
name|savedoflags
decl_stmt|;
comment|/*	struct buf      *bp;	 */
name|u_int32_t
name|table_offset
decl_stmt|;
name|struct
name|dos_partition
name|dos_table
index|[
name|NDOSPART
index|]
decl_stmt|;
struct|struct
name|subdev
block|{
name|int
name|part
decl_stmt|;
name|struct
name|slice
modifier|*
name|slice
decl_stmt|;
name|struct
name|slicelimits
name|limit
decl_stmt|;
name|struct
name|private_data
modifier|*
name|pd
decl_stmt|;
name|u_int32_t
name|offset
decl_stmt|;
comment|/* Fdisk only has 32 bits */
block|}
name|subdevs
index|[
name|NDOSPART
index|]
struct|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Bits in the mbr private data flag word  */
end_comment

begin_define
define|#
directive|define
name|MBRF_OPEN_RBIT
value|0x01
end_define

begin_define
define|#
directive|define
name|MBRF_S1_OPEN_RD
value|0x01
end_define

begin_define
define|#
directive|define
name|MBRF_S2_OPEN_RD
value|0x02
end_define

begin_define
define|#
directive|define
name|MBRF_S3_OPEN_RD
value|0x04
end_define

begin_define
define|#
directive|define
name|MBRF_S4_OPEN_RD
value|0x08
end_define

begin_define
define|#
directive|define
name|MBRF_MSK_RD
value|0x0F
end_define

begin_define
define|#
directive|define
name|MBRF_OPEN_WBIT
value|0x10
end_define

begin_define
define|#
directive|define
name|MBRF_S1_OPEN_WR
value|0x10
end_define

begin_define
define|#
directive|define
name|MBRF_S2_OPEN_WR
value|0x20
end_define

begin_define
define|#
directive|define
name|MBRF_S3_OPEN_WR
value|0x40
end_define

begin_define
define|#
directive|define
name|MBRF_S4_OPEN_WR
value|0x80
end_define

begin_define
define|#
directive|define
name|MBRF_MSK_WR
value|0xF0
end_define

begin_define
define|#
directive|define
name|MBRF_MSK_OPEN
value|0xFF
end_define

begin_define
define|#
directive|define
name|DOSPTYP_ONTRACK
value|84
end_define

begin_decl_stmt
specifier|static
name|sl_h_IO_req_t
name|mbr_IOreq
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* IO req downward (to device) */
end_comment

begin_decl_stmt
specifier|static
name|sl_h_ioctl_t
name|mbr_ioctl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ioctl req downward (to device) */
end_comment

begin_decl_stmt
specifier|static
name|sl_h_open_t
name|mbr_open
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* downwards travelling open */
end_comment

begin_comment
comment|/*static sl_h_close_t mbr_close; */
end_comment

begin_comment
comment|/* downwards travelling close */
end_comment

begin_decl_stmt
specifier|static
name|sl_h_claim_t
name|mbr_claim
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* upwards travelling claim */
end_comment

begin_decl_stmt
specifier|static
name|sl_h_revoke_t
name|mbr_revoke
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* upwards travelling revokation */
end_comment

begin_decl_stmt
specifier|static
name|sl_h_verify_t
name|mbr_verify
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* things changed, are we stil valid? */
end_comment

begin_decl_stmt
specifier|static
name|sl_h_upconfig_t
name|mbr_upconfig
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* config request from below */
end_comment

begin_decl_stmt
specifier|static
name|sl_h_dump_t
name|mbr_dump
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* core dump req downward */
end_comment

begin_decl_stmt
specifier|static
name|sl_h_done_t
name|mbr_done
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* callback after async request */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|slice_handler
name|slicetype
init|=
block|{
literal|"MBR"
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|,
operator|&
name|mbr_done
block|,
operator|&
name|mbr_IOreq
block|,
operator|&
name|mbr_ioctl
block|,
operator|&
name|mbr_open
block|,
comment|/*&mbr_close*/
name|NULL
block|,
operator|&
name|mbr_revoke
block|,
comment|/* revoke */
operator|&
name|mbr_claim
block|,
comment|/* claim */
operator|&
name|mbr_verify
block|,
comment|/* verify */
operator|&
name|mbr_upconfig
block|,
comment|/* config from below */
operator|&
name|mbr_dump
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|sd_drvinit
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|sl_newtype
argument_list|(
operator|&
name|slicetype
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|sddev
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|,
name|sd_drvinit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Allocate and the private data.  */
end_comment

begin_function
specifier|static
name|int
name|mbrallocprivate
parameter_list|(
name|sl_p
name|slice
parameter_list|)
block|{
specifier|register
name|struct
name|private_data
modifier|*
name|pd
decl_stmt|;
name|pd
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pd
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|pd
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"mbr: failed malloc\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|pd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pd
argument_list|)
argument_list|)
expr_stmt|;
name|pd
operator|->
name|slice_down
operator|=
name|slice
expr_stmt|;
name|slice
operator|->
name|refs
operator|++
expr_stmt|;
name|slice
operator|->
name|handler_up
operator|=
operator|&
name|slicetype
expr_stmt|;
name|slice
operator|->
name|private_up
operator|=
name|pd
expr_stmt|;
name|slicetype
operator|.
name|refs
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mbr_claim
parameter_list|(
name|sl_p
name|slice
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* 	 * Don't even BOTHER if it's not 512 byte sectors 	 */
if|if
condition|(
name|slice
operator|->
name|limits
operator|.
name|blksize
operator|!=
literal|512
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|slice
operator|->
name|private_up
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|mbrallocprivate
argument_list|(
name|slice
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|slice_request_block
argument_list|(
name|slice
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|mbr_revoke
argument_list|(
name|slice
operator|->
name|private_up
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mbr_verify
parameter_list|(
name|sl_p
name|slice
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* 	 * Don't even BOTHER if it's not 512 byte sectors 	 */
if|if
condition|(
name|slice
operator|->
name|limits
operator|.
name|blksize
operator|!=
literal|512
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|slice_request_block
argument_list|(
name|slice
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|mbr_revoke
argument_list|(
name|slice
operator|->
name|private_up
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   * called with an argument of a bp when it is completed  */
end_comment

begin_function
specifier|static
name|int
name|mbr_done
parameter_list|(
name|sl_p
name|slice
parameter_list|,
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|private_data
modifier|*
name|pd
decl_stmt|;
name|struct
name|dos_partition
name|table
index|[
name|NDOSPART
index|]
decl_stmt|;
name|struct
name|dos_partition
modifier|*
name|dp0
decl_stmt|,
modifier|*
name|dp
decl_stmt|,
modifier|*
name|dp2
decl_stmt|;
name|u_int8_t
modifier|*
name|cp
decl_stmt|;
name|int
name|part
decl_stmt|;
name|int
name|numactive
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|name
index|[
literal|64
index|]
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|RR
expr_stmt|;
comment|/* 	 * Discover whether the IO was successful. 	 */
name|pd
operator|=
name|slice
operator|->
name|private_up
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ERROR
condition|)
block|{
name|error
operator|=
name|bp
operator|->
name|b_error
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_INVAL
operator||
name|B_AGE
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
goto|goto
name|nope
goto|;
block|}
name|cp
operator|=
name|bp
operator|->
name|b_data
expr_stmt|;
if|if
condition|(
name|cp
index|[
literal|0x1FE
index|]
operator|!=
literal|0x55
operator|||
name|cp
index|[
literal|0x1FF
index|]
operator|!=
literal|0xAA
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_INVAL
operator||
name|B_AGE
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|nope
goto|;
block|}
name|dp0
operator|=
operator|(
expr|struct
name|dos_partition
operator|*
operator|)
operator|(
name|cp
operator|+
name|DOSPARTOFF
operator|)
expr_stmt|;
comment|/* copy the table out of the buf and release it. */
name|bcopy
argument_list|(
name|dp0
argument_list|,
name|table
argument_list|,
sizeof|sizeof
argument_list|(
name|table
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_INVAL
operator||
name|B_AGE
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * Check for "Ontrack Diskmanager". Note that if the geometry is 	 * still needed then we probably won't be able to read a DiskManager 	 * MBR because we will fail to read sector 63. The very act of 	 * finding a Disk Manager might however have given us the info we 	 * need if the disk manager set's its partition up correctly. 	 * XXX not true with interrupt driven probes. 	 */
if|if
condition|(
name|pd
operator|->
name|table_offset
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|part
operator|=
literal|0
operator|,
name|dp
operator|=
name|table
init|;
name|part
operator|<
name|NDOSPART
condition|;
name|part
operator|++
operator|,
name|dp
operator|++
control|)
block|{
if|if
condition|(
name|dp
operator|->
name|dp_typ
operator|==
name|DOSPTYP_ONTRACK
condition|)
block|{
ifdef|#
directive|ifdef
name|MAYBE
comment|/* 				 * It's not known if this should always 63 or 				 * if this is just the start of the 2nd 				 * track. 				 */
name|pd
operator|->
name|table_offset
operator|=
name|dp
operator|->
name|dp_start
expr_stmt|;
else|#
directive|else
name|pd
operator|->
name|table_offset
operator|=
literal|63
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Found \"Ontrack Disk Manager\"\n"
argument_list|)
expr_stmt|;
name|slice_request_block
argument_list|(
name|slice
argument_list|,
name|pd
operator|->
name|table_offset
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
comment|/* 	 * The first block of the dos code is marked like a valid MBR. 	 * Try to distinguish this case by doing a sanity check on the table. 	 * Check: 	 * Flag byte can only be 0 or 0x80. 	 * At most one active partition. 	 * -Other tests to be added here- 	 */
for|for
control|(
name|part
operator|=
literal|0
operator|,
name|dp
operator|=
name|table
init|;
name|part
operator|<
name|NDOSPART
condition|;
name|part
operator|++
operator|,
name|dp
operator|++
control|)
block|{
if|if
condition|(
name|dp
operator|->
name|dp_flag
operator|&
literal|0x7f
condition|)
block|{
name|printf
argument_list|(
literal|"rejected.. bad flag "
argument_list|)
expr_stmt|;
goto|goto
name|nope
goto|;
block|}
if|if
condition|(
operator|(
name|dp
operator|->
name|dp_typ
operator|)
operator|&&
operator|(
name|dp
operator|->
name|dp_size
operator|)
operator|&&
operator|(
name|dp
operator|->
name|dp_start
operator|==
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"rejected.. Slice includes MBR "
argument_list|)
expr_stmt|;
goto|goto
name|nope
goto|;
block|}
if|if
condition|(
name|dp
operator|->
name|dp_flag
operator|==
literal|0x80
condition|)
name|numactive
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|numactive
operator|>
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"rejected.. multiple active "
argument_list|)
expr_stmt|;
goto|goto
name|nope
goto|;
block|}
comment|/*- 	 * Handle the case when we are being asked to reevaluate 	 * an already loaded mbr table. 	 * We've already handled the case when it's completely vanished. 	 * 	 * Look at a slice that USED to be ours. 	 * Decide if any sub-slices need to be revoked. 	 * For each existing subslice, check that the basic size 	 * and position has not changed. Also check the TYPE. 	 * If not then at least ask them to verify themselves. 	 * It is possible we should allow a slice to grow. 	 */
name|dp
operator|=
name|pd
operator|->
name|dos_table
expr_stmt|;
name|dp0
operator|=
name|pd
operator|->
name|dos_table
expr_stmt|;
name|dp2
operator|=
name|table
expr_stmt|;
for|for
control|(
name|part
operator|=
literal|0
init|;
name|part
operator|<
name|NDOSPART
condition|;
name|part
operator|++
operator|,
name|dp
operator|++
operator|,
name|dp2
operator|++
control|)
block|{
if|if
condition|(
name|pd
operator|->
name|subdevs
index|[
name|part
index|]
operator|.
name|slice
condition|)
block|{
if|if
condition|(
operator|(
name|dp2
operator|->
name|dp_start
operator|!=
name|dp
operator|->
name|dp_start
operator|)
operator|||
operator|(
name|dp2
operator|->
name|dp_size
operator|!=
name|dp
operator|->
name|dp_size
operator|)
operator|||
operator|(
name|dp2
operator|->
name|dp_typ
operator|!=
name|dp
operator|->
name|dp_typ
operator|)
condition|)
block|{
name|sl_rmslice
argument_list|(
name|pd
operator|->
name|subdevs
index|[
name|part
index|]
operator|.
name|slice
argument_list|)
expr_stmt|;
name|pd
operator|->
name|subdevs
index|[
name|part
index|]
operator|.
name|slice
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pd
operator|->
name|subdevs
index|[
name|part
index|]
operator|.
name|slice
operator|->
name|handler_up
condition|)
block|{
operator|(
operator|*
name|pd
operator|->
name|subdevs
index|[
name|part
index|]
operator|.
name|slice
operator|->
name|handler_up
operator|->
name|verify
operator|)
operator|(
name|pd
operator|->
name|subdevs
index|[
name|part
index|]
operator|.
name|slice
operator|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Having got rid of changing slices, replace 	 * the old table with the new one. 	 */
name|bcopy
argument_list|(
name|table
argument_list|,
name|pd
operator|->
name|dos_table
argument_list|,
sizeof|sizeof
argument_list|(
name|table
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Handle each of the partitions.  	 * We should check that each makes sense and is legal. 	 * 1/ it should not already have a slice. 	 * 2/ should not be 0 length. 	 * 3/ should not go past end of our slice. 	 * 4/ should not include sector 0. 	 * 5/ should not overlap other slices. 	 * 	 * Be aware that this may queue up one (or more) IO requests 	 * for each subslice created. 	 */
name|dp
operator|=
name|dp0
expr_stmt|;
for|for
control|(
name|part
operator|=
literal|0
init|;
name|part
operator|<
name|NDOSPART
condition|;
name|part
operator|++
operator|,
name|dp
operator|++
control|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|pd
operator|->
name|subdevs
index|[
name|part
index|]
operator|.
name|slice
operator|!=
name|NULL
condition|)
name|breakout
label|:
continue|continue;
if|if
condition|(
name|dp
operator|->
name|dp_size
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|dp
operator|->
name|dp_start
operator|<
literal|1
condition|)
continue|continue;
name|printf
argument_list|(
literal|" part %d, start=%d, size=%d\n"
argument_list|,
name|part
operator|+
literal|1
argument_list|,
name|dp
operator|->
name|dp_start
argument_list|,
name|dp
operator|->
name|dp_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|->
name|dp_start
operator|+
name|dp
operator|->
name|dp_size
operator|)
operator|>
operator|(
name|slice
operator|->
name|limits
operator|.
name|slicesize
operator|/
name|slice
operator|->
name|limits
operator|.
name|blksize
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"mbr: slice %d too big "
argument_list|,
name|part
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(%x> %x:%x )\n"
argument_list|,
operator|(
name|dp
operator|->
name|dp_start
operator|+
name|dp
operator|->
name|dp_size
operator|)
argument_list|,
operator|(
name|slice
operator|->
name|limits
operator|.
name|slicesize
operator|/
name|slice
operator|->
name|limits
operator|.
name|blksize
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* check for overlaps with existing slices */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDOSPART
condition|;
name|i
operator|++
control|)
block|{
comment|/* skip empty slots (including this one) */
if|if
condition|(
name|pd
operator|->
name|subdevs
index|[
name|i
index|]
operator|.
name|slice
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
name|dp0
index|[
name|i
index|]
operator|.
name|dp_start
operator|<
operator|(
name|dp
operator|->
name|dp_start
operator|+
name|dp
operator|->
name|dp_size
operator|)
operator|)
operator|&&
operator|(
operator|(
name|dp0
index|[
name|i
index|]
operator|.
name|dp_start
operator|+
name|dp0
index|[
name|i
index|]
operator|.
name|dp_size
operator|)
operator|>
name|dp
operator|->
name|dp_start
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"mbr: new slice %d overlaps slice %d\n"
argument_list|,
name|part
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|breakout
goto|;
block|}
block|}
comment|/*  		 * the slice seems to make sense. Use it. 		 */
name|pd
operator|->
name|subdevs
index|[
name|part
index|]
operator|.
name|part
operator|=
name|part
expr_stmt|;
name|pd
operator|->
name|subdevs
index|[
name|part
index|]
operator|.
name|pd
operator|=
name|pd
expr_stmt|;
name|pd
operator|->
name|subdevs
index|[
name|part
index|]
operator|.
name|offset
operator|=
name|dp
operator|->
name|dp_start
expr_stmt|;
name|pd
operator|->
name|subdevs
index|[
name|part
index|]
operator|.
name|limit
operator|.
name|blksize
operator|=
name|slice
operator|->
name|limits
operator|.
name|blksize
expr_stmt|;
name|pd
operator|->
name|subdevs
index|[
name|part
index|]
operator|.
name|limit
operator|.
name|slicesize
operator|=
operator|(
name|slice
operator|->
name|limits
operator|.
name|blksize
operator|*
operator|(
name|u_int64_t
operator|)
name|dp
operator|->
name|dp_size
operator|)
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%ss%d"
argument_list|,
name|slice
operator|->
name|name
argument_list|,
name|part
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sl_make_slice
argument_list|(
operator|&
name|slicetype
argument_list|,
operator|&
name|pd
operator|->
name|subdevs
index|[
name|part
index|]
argument_list|,
operator|&
name|pd
operator|->
name|subdevs
index|[
name|part
index|]
operator|.
name|limit
argument_list|,
operator|&
name|pd
operator|->
name|subdevs
index|[
name|part
index|]
operator|.
name|slice
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|pd
operator|->
name|subdevs
index|[
name|part
index|]
operator|.
name|slice
operator|->
name|probeinfo
operator|.
name|typespecific
operator|=
operator|&
name|dp
operator|->
name|dp_typ
expr_stmt|;
switch|switch
condition|(
name|dp
operator|->
name|dp_typ
condition|)
block|{
comment|/* list stolen from fdisk */
case|case
literal|0x00
case|:
comment|/* "unused" */
case|case
literal|0x01
case|:
comment|/* "Primary DOS with 12 bit FAT" */
case|case
literal|0x02
case|:
comment|/* "XENIX / filesystem" */
case|case
literal|0x03
case|:
comment|/* "XENIX /usr filesystem" */
case|case
literal|0x04
case|:
comment|/* "Primary DOS with 16 bit FAT" */
case|case
literal|0x05
case|:
comment|/* "Extended DOS" */
case|case
literal|0x06
case|:
comment|/* "Primary 'big' DOS (> 32MB)" */
case|case
literal|0x07
case|:
comment|/* "OS/2 HPFS, QNX or Advanced UNIX" */
case|case
literal|0x08
case|:
comment|/* "AIX filesystem" */
case|case
literal|0x09
case|:
comment|/* "AIX boot partition or Coherent" */
case|case
literal|0x0A
case|:
comment|/* "OS/2 Boot Manager or OPUS" */
case|case
literal|0x10
case|:
comment|/* "OPUS" */
case|case
literal|0x40
case|:
comment|/* "VENIX 286" */
case|case
literal|0x50
case|:
comment|/* "DM" */
case|case
literal|0x51
case|:
comment|/* "DM" */
case|case
literal|0x52
case|:
comment|/* "CP/M or Microport SysV/AT" */
case|case
literal|0x56
case|:
comment|/* "GB" */
case|case
literal|0x61
case|:
comment|/* "Speed" */
case|case
literal|0x63
case|:
comment|/* "ISC UNIX, System V/386, GNU HURD or Mach" */
case|case
literal|0x64
case|:
comment|/* "Novell Netware 2.xx" */
case|case
literal|0x65
case|:
comment|/* "Novell Netware 3.xx" */
case|case
literal|0x75
case|:
comment|/* "PCIX" */
case|case
literal|0x80
case|:
comment|/* "Minix 1.1 ... 1.4a" */
case|case
literal|0x81
case|:
comment|/* "Minix 1.4b ... 1.5.10" */
case|case
literal|0x82
case|:
comment|/* "Linux swap" */
case|case
literal|0x83
case|:
comment|/* "Linux filesystem" */
case|case
literal|0x93
case|:
comment|/* "Amoeba filesystem" */
case|case
literal|0x94
case|:
comment|/* "Amoeba bad block table" */
case|case
literal|0xA6
case|:
comment|/* "OpenBSD" */
case|case
literal|0xA7
case|:
comment|/* "NEXTSTEP" */
case|case
literal|0xB7
case|:
comment|/* "BSDI BSD/386 filesystem" */
case|case
literal|0xB8
case|:
comment|/* "BSDI BSD/386 swap" */
case|case
literal|0xDB
case|:
comment|/* "Concurrent CPM or C.DOS or CTOS" */
case|case
literal|0xE1
case|:
comment|/* "Speed" */
case|case
literal|0xE3
case|:
comment|/* "Speed" */
case|case
literal|0xE4
case|:
comment|/* "Speed" */
case|case
literal|0xF1
case|:
comment|/* "Speed" */
case|case
literal|0xF2
case|:
comment|/* "DOS 3.3+ Secondary" */
case|case
literal|0xF4
case|:
comment|/* "Speed" */
case|case
literal|0xFF
case|:
comment|/* "BBT (Bad Blocks Table)" */
name|printf
argument_list|(
literal|"%s: type %d. Leaving\n"
argument_list|,
name|pd
operator|->
name|subdevs
index|[
name|part
index|]
operator|.
name|slice
operator|->
name|name
argument_list|,
operator|(
name|u_int
operator|)
name|dp
operator|->
name|dp_typ
argument_list|)
expr_stmt|;
name|pd
operator|->
name|subdevs
index|[
name|part
index|]
operator|.
name|slice
operator|->
name|probeinfo
operator|.
name|type
operator|=
name|NO_SUBPART
expr_stmt|;
break|break;
case|case
name|DOSPTYP_386BSD
case|:
comment|/* 0xA5 "FreeBSD/NetBSD/386BSD" */
name|pd
operator|->
name|subdevs
index|[
name|part
index|]
operator|.
name|slice
operator|->
name|probeinfo
operator|.
name|type
operator|=
literal|"disklabel"
expr_stmt|;
break|break;
default|default:
name|pd
operator|->
name|subdevs
index|[
name|part
index|]
operator|.
name|slice
operator|->
name|probeinfo
operator|.
name|type
operator|=
name|NULL
expr_stmt|;
block|}
name|slice_start_probe
argument_list|(
name|pd
operator|->
name|subdevs
index|[
name|part
index|]
operator|.
name|slice
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|nope
label|:
name|mbr_revoke
argument_list|(
name|pd
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This routine tries to guess the geometry for  * old disk drivers that need the MBR code to set it. Bits taken from  * diskslice_machdep.c which itself evolved from earlier code.  * This is not part of the SLICE code per-se, but just a convenient place to  * put this HACK because everything is in scope. Only called by the IDE driver.  * At the moment I don't know when it could be called from wd.c  * Possibly it might call the claim function itself so it may be called instead of  * the claim. It would have to inhibit the claim from calling the disklabel  * claim till after the correct values were assigned. possibbly this   * might be broken into two parts, the first of which hangs a struct off the  * private data, and the second of which fills it in after the mbr has been loaded.  */
end_comment

begin_function
name|int
name|mbr_geom_hack
parameter_list|(
name|struct
name|slice
modifier|*
name|slice
parameter_list|,
name|struct
name|ide_geom
modifier|*
name|geom
parameter_list|)
block|{
name|struct
name|dos_partition
name|table
index|[
name|NDOSPART
index|]
decl_stmt|;
name|struct
name|dos_partition
modifier|*
name|dp
decl_stmt|,
modifier|*
name|dp0
decl_stmt|;
name|struct
name|private_data
modifier|*
name|pd
decl_stmt|;
name|int
name|part
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|max_ncyls
decl_stmt|;
name|int
name|max_nsectors
decl_stmt|;
name|int
name|max_ntracks
decl_stmt|;
name|u_int32_t
name|secpercyl
decl_stmt|;
name|RR
expr_stmt|;
if|if
condition|(
name|slice
operator|->
name|handler_up
operator|!=
operator|&
name|slicetype
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|pd
operator|=
name|slice
operator|->
name|private_up
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|pd
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|dp0
operator|=
name|pd
operator|->
name|dos_table
expr_stmt|;
comment|/* 	 * Guess the geometry. For some old drives (ESDI, st506) the 	 * driver below us may not yet know the geometry, but needs 	 * to before it can access blocks out of the first track. 	 * This hack is to use information in the MBR to "deduce" 	 * this information and pass it back. 	 */
name|max_ncyls
operator|=
literal|0
expr_stmt|;
name|max_nsectors
operator|=
literal|0
expr_stmt|;
name|max_ntracks
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|part
operator|=
literal|0
operator|,
name|dp
operator|=
name|dp0
init|;
name|part
operator|<
name|NDOSPART
condition|;
name|part
operator|++
operator|,
name|dp
operator|++
control|)
block|{
name|int
name|ncyls
decl_stmt|;
name|int
name|nsectors
decl_stmt|;
name|int
name|ntracks
decl_stmt|;
if|if
condition|(
name|dp
operator|->
name|dp_size
operator|==
literal|0
condition|)
continue|continue;
name|ncyls
operator|=
name|DPCYL
argument_list|(
name|dp
operator|->
name|dp_ecyl
argument_list|,
name|dp
operator|->
name|dp_esect
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|max_ncyls
operator|<
name|ncyls
condition|)
name|max_ncyls
operator|=
name|ncyls
expr_stmt|;
name|nsectors
operator|=
name|DPSECT
argument_list|(
name|dp
operator|->
name|dp_esect
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_nsectors
operator|<
name|nsectors
condition|)
name|max_nsectors
operator|=
name|nsectors
expr_stmt|;
name|ntracks
operator|=
name|dp
operator|->
name|dp_ehd
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|max_ntracks
operator|<
name|ntracks
condition|)
name|max_ntracks
operator|=
name|ntracks
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|max_ncyls
operator|==
literal|0
operator|)
operator|&&
operator|(
name|max_nsectors
operator|==
literal|0
operator|)
operator|&&
operator|(
name|max_ntracks
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* we've gained nought, so just return */
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|secpercyl
operator|=
operator|(
name|u_long
operator|)
name|max_nsectors
operator|*
name|max_ntracks
expr_stmt|;
name|printf
argument_list|(
literal|"s=%d, h=%d, c=%d\n"
argument_list|,
name|max_nsectors
argument_list|,
name|max_ntracks
argument_list|,
name|max_ncyls
argument_list|)
expr_stmt|;
comment|/* 	 * Check that we have guessed the geometry right by checking 	 * the partition entries. 	 */
name|error
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|part
operator|=
literal|0
operator|,
name|dp
operator|=
name|dp0
init|;
name|part
operator|<
name|NDOSPART
condition|;
name|part
operator|++
operator|,
name|dp
operator|++
control|)
block|{
name|int
name|cyl
decl_stmt|;
name|int
name|sector
decl_stmt|;
name|int
name|track
decl_stmt|;
name|int
name|secpercyl
decl_stmt|;
if|if
condition|(
name|dp
operator|->
name|dp_size
operator|==
literal|0
condition|)
continue|continue;
name|cyl
operator|=
name|DPCYL
argument_list|(
name|dp
operator|->
name|dp_scyl
argument_list|,
name|dp
operator|->
name|dp_ssect
argument_list|)
expr_stmt|;
name|track
operator|=
name|dp
operator|->
name|dp_shd
expr_stmt|;
name|sector
operator|=
name|DPSECT
argument_list|(
name|dp
operator|->
name|dp_ssect
argument_list|)
operator|-
literal|1
expr_stmt|;
name|secpercyl
operator|=
name|max_nsectors
operator|*
name|max_ntracks
expr_stmt|;
comment|/* 		 * If the geometry doesn't work for any partition 		 * start then don't accept it. 		 */
if|if
condition|(
operator|(
operator|(
operator|(
operator|(
name|dp
operator|->
name|dp_start
operator|/
name|secpercyl
operator|)
operator|%
literal|1024
operator|)
operator|!=
name|cyl
operator|)
operator|&&
operator|(
name|cyl
operator|!=
literal|1023
operator|)
operator|)
operator|||
operator|(
operator|(
operator|(
name|dp
operator|->
name|dp_start
operator|%
name|secpercyl
operator|)
operator|/
name|max_nsectors
operator|)
operator|!=
name|track
operator|)
operator|||
operator|(
operator|(
operator|(
name|dp
operator|->
name|dp_start
operator|%
name|secpercyl
operator|)
operator|%
name|max_nsectors
operator|)
operator|!=
name|sector
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Can't get disk geometry from MBR\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|dp
operator|->
name|dp_start
operator|/
name|secpercyl
operator|)
operator|>
literal|1023
condition|)
block|{
name|printf
argument_list|(
literal|"part %d above BIOS reach\n"
argument_list|,
name|part
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Set our newely hypothesised numbers into the geometry 	 * slots in the supplied SLICE. 	 */
name|geom
operator|->
name|secpertrack
operator|=
name|max_nsectors
expr_stmt|;
name|geom
operator|->
name|trackpercyl
operator|=
name|max_ntracks
expr_stmt|;
name|geom
operator|->
name|cyls
operator|=
name|max_ncyls
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Invalidate all subslices, and free resources for this handler instance.  */
end_comment

begin_function
specifier|static
name|int
name|mbr_revoke
parameter_list|(
name|void
modifier|*
name|private
parameter_list|)
block|{
specifier|register
name|struct
name|private_data
modifier|*
name|pd
decl_stmt|;
specifier|register
name|struct
name|slice
modifier|*
name|slice
decl_stmt|;
name|int
name|part
decl_stmt|;
name|RR
expr_stmt|;
name|pd
operator|=
name|private
expr_stmt|;
name|slice
operator|=
name|pd
operator|->
name|slice_down
expr_stmt|;
for|for
control|(
name|part
operator|=
literal|0
init|;
name|part
operator|<
name|NDOSPART
condition|;
name|part
operator|++
control|)
block|{
if|if
condition|(
name|pd
operator|->
name|subdevs
index|[
name|part
index|]
operator|.
name|slice
condition|)
block|{
name|sl_rmslice
argument_list|(
name|pd
operator|->
name|subdevs
index|[
name|part
index|]
operator|.
name|slice
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * remove ourself as a handler 	 */
name|slice
operator|->
name|handler_up
operator|=
name|NULL
expr_stmt|;
name|slice
operator|->
name|private_up
operator|=
name|NULL
expr_stmt|;
name|slicetype
operator|.
name|refs
operator|--
expr_stmt|;
name|free
argument_list|(
name|pd
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|sl_unref
argument_list|(
name|slice
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * shift the appropriate IO by the offset for that slice.  */
end_comment

begin_function
specifier|static
name|void
name|mbr_IOreq
parameter_list|(
name|void
modifier|*
name|private
parameter_list|,
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
specifier|register
name|struct
name|private_data
modifier|*
name|pd
decl_stmt|;
name|struct
name|subdev
modifier|*
name|sdp
decl_stmt|;
specifier|register
name|struct
name|slice
modifier|*
name|slice
decl_stmt|;
name|RR
expr_stmt|;
name|sdp
operator|=
name|private
expr_stmt|;
name|pd
operator|=
name|sdp
operator|->
name|pd
expr_stmt|;
name|slice
operator|=
name|pd
operator|->
name|slice_down
expr_stmt|;
name|bp
operator|->
name|b_pblkno
operator|+=
name|sdp
operator|->
name|offset
expr_stmt|;
comment|/* add the offset for that slice */
name|sliceio
argument_list|(
name|slice
argument_list|,
name|bp
argument_list|,
name|SLW_ABOVE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mbr_open
parameter_list|(
name|void
modifier|*
name|private
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
specifier|register
name|struct
name|private_data
modifier|*
name|pd
decl_stmt|;
name|struct
name|subdev
modifier|*
name|sdp
decl_stmt|;
specifier|register
name|struct
name|slice
modifier|*
name|slice
decl_stmt|;
name|int
name|part
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|newflags
init|=
literal|0
decl_stmt|;
name|int
name|oldoflags
init|=
literal|0
decl_stmt|;
name|int
name|newoflags
init|=
literal|0
decl_stmt|;
name|RR
expr_stmt|;
name|sdp
operator|=
name|private
expr_stmt|;
name|part
operator|=
name|sdp
operator|->
name|part
expr_stmt|;
name|pd
operator|=
name|sdp
operator|->
name|pd
expr_stmt|;
name|slice
operator|=
name|pd
operator|->
name|slice_down
expr_stmt|;
comment|/* 	 * Calculate the change to to over-all picture here. 	 * Notice that this might result in LESS open bits 	 * if that was what was passed from above. 	 * (Prelude to 'mode-change' instead of open/close.) 	 */
comment|/* work out what our stored flags will be if this succeeds */
name|newflags
operator|=
name|pd
operator|->
name|flags
operator|&
operator|~
operator|(
operator|(
name|MBRF_OPEN_WBIT
operator||
name|MBRF_OPEN_RBIT
operator|)
operator|<<
name|part
operator|)
expr_stmt|;
name|newflags
operator||=
operator|(
name|flags
operator|&
name|FWRITE
operator|)
condition|?
operator|(
name|MBRF_OPEN_WBIT
operator|<<
name|part
operator|)
else|:
literal|0
expr_stmt|;
name|newflags
operator||=
operator|(
name|flags
operator|&
name|FREAD
operator|)
condition|?
operator|(
name|MBRF_OPEN_RBIT
operator|<<
name|part
operator|)
else|:
literal|0
expr_stmt|;
comment|/* work out what we want to pass down this time */
name|newoflags
operator|=
operator|(
name|newflags
operator|&
name|MBRF_MSK_WR
operator|)
condition|?
name|FWRITE
else|:
literal|0
expr_stmt|;
name|newoflags
operator||=
operator|(
name|newflags
operator|&
name|MBRF_MSK_RD
operator|)
condition|?
name|FREAD
else|:
literal|0
expr_stmt|;
comment|/* 	 * If the agregate flags we used last time are the same as 	 * the agregate flags we would use this time, then don't 	 * bother re-doing the command. 	 */
if|if
condition|(
name|newoflags
operator|!=
name|pd
operator|->
name|savedoflags
condition|)
block|{
if|if
condition|(
name|error
operator|=
name|sliceopen
argument_list|(
name|slice
argument_list|,
name|newoflags
argument_list|,
name|mode
argument_list|,
name|p
argument_list|,
name|SLW_ABOVE
argument_list|)
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* 	 * Now that we know it succeeded, commit, by replacing the old 	 * flags with the new ones. 	 */
name|pd
operator|->
name|flags
operator|&=
operator|~
name|MBRF_MSK_OPEN
expr_stmt|;
name|pd
operator|->
name|flags
operator||=
name|newflags
expr_stmt|;
name|pd
operator|->
name|savedoflags
operator|=
name|newoflags
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mbr_ioctl
parameter_list|(
name|void
modifier|*
name|private
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
specifier|register
name|struct
name|private_data
modifier|*
name|pd
decl_stmt|;
name|struct
name|subdev
modifier|*
name|sdp
decl_stmt|;
specifier|register
name|struct
name|slice
modifier|*
name|slice
decl_stmt|;
name|int
name|error
decl_stmt|;
name|RR
expr_stmt|;
name|sdp
operator|=
name|private
expr_stmt|;
name|pd
operator|=
name|sdp
operator|->
name|pd
expr_stmt|;
name|slice
operator|=
name|pd
operator|->
name|slice_down
expr_stmt|;
return|return
operator|(
call|(
modifier|*
name|slice
operator|->
name|handler_down
operator|->
name|ioctl
call|)
argument_list|(
name|slice
operator|->
name|private_down
argument_list|,
name|cmd
argument_list|,
name|addr
argument_list|,
name|flag
argument_list|,
name|p
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mbr_upconfig
parameter_list|(
name|struct
name|slice
modifier|*
name|slice
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|RR
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SLCIOCRESET
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|SLCIOCTRANSBAD
case|:
block|{
name|struct
name|private_data
modifier|*
name|pd
decl_stmt|;
name|struct
name|subdev
modifier|*
name|sdp
decl_stmt|;
name|daddr_t
name|blkno
decl_stmt|;
name|int
name|part
decl_stmt|;
if|if
condition|(
operator|!
name|slice
operator|->
name|handler_up
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|blkno
operator|=
operator|*
operator|(
name|daddr_t
operator|*
operator|)
name|addr
expr_stmt|;
name|pd
operator|=
name|slice
operator|->
name|private_up
expr_stmt|;
name|sdp
operator|=
name|pd
operator|->
name|subdevs
expr_stmt|;
for|for
control|(
name|part
operator|=
literal|0
init|;
name|part
operator|<
name|NDOSPART
condition|;
name|part
operator|++
operator|,
name|sdp
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|sdp
operator|->
name|slice
condition|)
continue|continue;
if|if
condition|(
name|blkno
operator|<
name|sdp
operator|->
name|offset
condition|)
continue|continue;
if|if
condition|(
name|blkno
operator|>=
name|sdp
operator|->
name|offset
operator|+
name|sdp
operator|->
name|limit
operator|.
name|slicesize
operator|/
name|sdp
operator|->
name|limit
operator|.
name|blksize
condition|)
continue|continue;
name|blkno
operator|-=
name|sdp
operator|->
name|offset
expr_stmt|;
name|slice
operator|=
name|sdp
operator|->
name|slice
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|slice
operator|->
name|handler_up
operator|->
name|upconf
call|)
argument_list|(
name|slice
argument_list|,
name|cmd
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|blkno
argument_list|,
name|flag
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
operator|*
operator|(
name|daddr_t
operator|*
operator|)
name|addr
operator|=
name|blkno
operator|+
name|sdp
operator|->
name|offset
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* These don't really make sense. keep the headers for a reminder */
default|default:
return|return
operator|(
name|ENOIOCTL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mbr_dump
parameter_list|(
name|void
modifier|*
name|private
parameter_list|,
name|int32_t
name|blkoff
parameter_list|,
name|int32_t
name|blkcnt
parameter_list|)
block|{
name|struct
name|private_data
modifier|*
name|pd
decl_stmt|;
name|struct
name|subdev
modifier|*
name|sdp
decl_stmt|;
specifier|register
name|struct
name|slice
modifier|*
name|slice
decl_stmt|;
name|RR
expr_stmt|;
name|sdp
operator|=
name|private
expr_stmt|;
name|pd
operator|=
name|sdp
operator|->
name|pd
expr_stmt|;
name|slice
operator|=
name|pd
operator|->
name|slice_down
expr_stmt|;
name|blkoff
operator|+=
name|sdp
operator|->
name|offset
expr_stmt|;
if|if
condition|(
name|slice
operator|->
name|handler_down
operator|->
name|dump
condition|)
block|{
return|return
call|(
modifier|*
name|slice
operator|->
name|handler_down
operator|->
name|dump
call|)
argument_list|(
name|slice
operator|->
name|private_down
argument_list|,
name|blkoff
argument_list|,
name|blkcnt
argument_list|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

end_unit

