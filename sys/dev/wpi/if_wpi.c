begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2006,2007  *	Damien Bergamini<damien.bergamini@free.fr>  *	Benjamin Close<Benjamin.Close@clearchain.com>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Driver for Intel PRO/Wireless 3945ABG 802.11 network adapters.  *  * The 3945ABG network adapter doesn't use traditional hardware as  * many other adaptors do. Instead at run time the eeprom is set into a known  * state and told to load boot firmware. The boot firmware loads an init and a  * main  binary firmware image into SRAM on the card via DMA.  * Once the firmware is loaded, the driver/hw then  * communicate by way of circular dma rings via the SRAM to the firmware.  *  * There is 6 memory rings. 1 command ring, 1 rx data ring& 4 tx data rings.  * The 4 tx data rings allow for prioritization QoS.  *  * The rx data ring consists of 32 dma buffers. Two registers are used to  * indicate where in the ring the driver and the firmware are up to. The  * driver sets the initial read index (reg1) and the initial write index (reg2),  * the firmware updates the read index (reg1) on rx of a packet and fires an  * interrupt. The driver then processes the buffers starting at reg1 indicating  * to the firmware which buffers have been accessed by updating reg2. At the  * same time allocating new memory for the processed buffer.  *  * A similar thing happens with the tx rings. The difference is the firmware  * stop processing buffers once the queue is full and until confirmation  * of a successful transmition (tx_intr) has occurred.  *  * The command ring operates in the same manner as the tx queues.  *  * All communication direct to the card (ie eeprom) is classed as Stage1  * communication  *  * All communication via the firmware to the card is classed as State2.  * The firmware consists of 2 parts. A bootstrap firmware and a runtime  * firmware. The bootstrap firmware and runtime firmware are loaded  * from host memory via dma to the card then told to execute. From this point  * on the majority of communications between the driver and the card goes  * via the firmware.  */
end_comment

begin_include
include|#
directive|include
file|"opt_wlan.h"
end_include

begin_include
include|#
directive|include
file|"opt_wpi.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/firmware.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_radiotap.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_regdomain.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_ratectl.h>
end_include

begin_include
include|#
directive|include
file|<dev/wpi/if_wpireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/wpi/if_wpivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/wpi/if_wpi_debug.h>
end_include

begin_struct
struct|struct
name|wpi_ident
block|{
name|uint16_t
name|vendor
decl_stmt|;
name|uint16_t
name|device
decl_stmt|;
name|uint16_t
name|subdevice
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|wpi_ident
name|wpi_ident_table
index|[]
init|=
block|{
comment|/* The below entries support ABG regardless of the subid */
block|{
literal|0x8086
block|,
literal|0x4222
block|,
literal|0x0
block|,
literal|"Intel(R) PRO/Wireless 3945ABG"
block|}
block|,
block|{
literal|0x8086
block|,
literal|0x4227
block|,
literal|0x0
block|,
literal|"Intel(R) PRO/Wireless 3945ABG"
block|}
block|,
comment|/* The below entries only support BG */
block|{
literal|0x8086
block|,
literal|0x4222
block|,
literal|0x1005
block|,
literal|"Intel(R) PRO/Wireless 3945BG"
block|}
block|,
block|{
literal|0x8086
block|,
literal|0x4222
block|,
literal|0x1034
block|,
literal|"Intel(R) PRO/Wireless 3945BG"
block|}
block|,
block|{
literal|0x8086
block|,
literal|0x4227
block|,
literal|0x1014
block|,
literal|"Intel(R) PRO/Wireless 3945BG"
block|}
block|,
block|{
literal|0x8086
block|,
literal|0x4222
block|,
literal|0x1044
block|,
literal|"Intel(R) PRO/Wireless 3945BG"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|wpi_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_radiotap_attach
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_sysctlattach
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ieee80211vap
modifier|*
name|wpi_vap_create
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|,
specifier|const
name|char
index|[
name|IFNAMSIZ
index|]
parameter_list|,
name|int
parameter_list|,
name|enum
name|ieee80211_opmode
parameter_list|,
name|int
parameter_list|,
specifier|const
name|uint8_t
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|uint8_t
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_vap_delete
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_shutdown
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_suspend
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_resume
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_nic_lock
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_read_prom_data
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_dma_map_addr
parameter_list|(
name|void
modifier|*
parameter_list|,
name|bus_dma_segment_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_dma_contig_alloc
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|struct
name|wpi_dma_info
modifier|*
parameter_list|,
name|void
modifier|*
modifier|*
parameter_list|,
name|bus_size_t
parameter_list|,
name|bus_size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_dma_contig_free
parameter_list|(
name|struct
name|wpi_dma_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_alloc_shared
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_free_shared
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_alloc_fwmem
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_free_fwmem
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_alloc_rx_ring
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_update_rx_ring
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_reset_rx_ring
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_free_rx_ring
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_alloc_tx_ring
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|struct
name|wpi_tx_ring
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_update_tx_ring
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|struct
name|wpi_tx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_reset_tx_ring
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|struct
name|wpi_tx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_free_tx_ring
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|struct
name|wpi_tx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_read_eeprom
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|uint8_t
name|macaddr
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|wpi_eeprom_channel_flags
parameter_list|(
name|struct
name|wpi_eeprom_chan
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_read_eeprom_band
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_read_eeprom_channels
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|wpi_eeprom_chan
modifier|*
name|wpi_find_eeprom_channel
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_setregdomain
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|,
name|struct
name|ieee80211_regdomain
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|ieee80211_channel
type|[]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_read_eeprom_group
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_node_free
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ieee80211_node
modifier|*
name|wpi_node_alloc
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
specifier|const
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_newstate
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
name|enum
name|ieee80211_state
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_calib_timeout
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_rx_done
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|struct
name|wpi_rx_desc
modifier|*
parameter_list|,
name|struct
name|wpi_rx_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_rx_statistics
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|struct
name|wpi_rx_desc
modifier|*
parameter_list|,
name|struct
name|wpi_rx_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_tx_done
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|struct
name|wpi_rx_desc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_cmd_done
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|struct
name|wpi_rx_desc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_notif_intr
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_wakeup_intr
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_fatal_intr
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_cmd2
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|struct
name|wpi_buf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_tx_data
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_tx_data_raw
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
specifier|const
name|struct
name|ieee80211_bpf_params
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_raw_xmit
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
specifier|const
name|struct
name|ieee80211_bpf_params
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_watchdog_rfkill
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_watchdog
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_cmd
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_mrr_setup
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_add_node
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_add_broadcast_node
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_add_ibss_node
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_del_node
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_updateedca
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_set_promisc
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_update_promisc
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_update_mcast
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_set_led
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
name|uint8_t
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_set_timing
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_power_calibration
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_set_txpower
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_get_power_index
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|struct
name|wpi_power_group
modifier|*
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_set_pslevel
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_send_btcoex
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_send_rxon
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_config
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint16_t
name|wpi_get_active_dwell_time
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint16_t
name|wpi_limit_dwell
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint16_t
name|wpi_get_passive_dwell_time
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_scan
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_auth
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_update_beacon
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_setup_beacon
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_run
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_key_alloc
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
name|struct
name|ieee80211_key
modifier|*
parameter_list|,
name|ieee80211_keyix
modifier|*
parameter_list|,
name|ieee80211_keyix
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_key_set
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
specifier|const
name|struct
name|ieee80211_key
modifier|*
parameter_list|,
specifier|const
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_key_delete
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
specifier|const
name|struct
name|ieee80211_key
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_post_alive
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_load_bootcode
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
specifier|const
name|uint8_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_load_firmware
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_read_firmware
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_unload_firmware
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_clock_wait
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_apm_init
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_apm_stop_master
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_apm_stop
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_nic_config
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_hw_init
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_hw_stop
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_radio_on
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_radio_off
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_init_locked
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_stop_locked
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_stop
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_scan_start
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_scan_end
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_set_channel
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_scan_curchan
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
parameter_list|,
name|unsigned
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_scan_mindwell
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_hw_reset
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|wpi_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|wpi_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|wpi_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|wpi_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|wpi_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|wpi_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|wpi_resume
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|wpi_driver
init|=
block|{
literal|"wpi"
block|,
name|wpi_methods
block|,
expr|sizeof
operator|(
expr|struct
name|wpi_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|wpi_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|wpi
argument_list|,
name|pci
argument_list|,
name|wpi_driver
argument_list|,
name|wpi_devclass
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|wpi
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|wpi
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|wpi
argument_list|,
name|wlan
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|wpi
argument_list|,
name|firmware
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|wpi_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
specifier|const
name|struct
name|wpi_ident
modifier|*
name|ident
decl_stmt|;
for|for
control|(
name|ident
operator|=
name|wpi_ident_table
init|;
name|ident
operator|->
name|name
operator|!=
name|NULL
condition|;
name|ident
operator|++
control|)
block|{
if|if
condition|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|==
name|ident
operator|->
name|vendor
operator|&&
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|ident
operator|->
name|device
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|ident
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
block|}
return|return
name|ENXIO
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wpi_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|wpi_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|wpi_softc
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|,
name|rid
decl_stmt|,
name|supportsa
init|=
literal|1
decl_stmt|;
specifier|const
name|struct
name|wpi_ident
modifier|*
name|ident
decl_stmt|;
name|uint8_t
name|macaddr
index|[
name|IEEE80211_ADDR_LEN
index|]
decl_stmt|;
name|sc
operator|->
name|sc_dev
operator|=
name|dev
expr_stmt|;
ifdef|#
directive|ifdef
name|WPI_DEBUG
name|error
operator|=
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
literal|"debug"
argument_list|,
operator|&
operator|(
name|sc
operator|->
name|sc_debug
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|sc
operator|->
name|sc_debug
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|sc
operator|->
name|sc_debug
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_BEGIN
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* 	 * Get the offset of the PCI Express Capability Structure in PCI 	 * Configuration Space. 	 */
name|error
operator|=
name|pci_find_cap
argument_list|(
name|dev
argument_list|,
name|PCIY_EXPRESS
argument_list|,
operator|&
name|sc
operator|->
name|sc_cap_off
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"PCIe capability structure not found!\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* 	 * Some card's only support 802.11b/g not a, check to see if 	 * this is one such card. A 0x0 in the subdevice table indicates 	 * the entire subdevice range is to be ignored. 	 */
for|for
control|(
name|ident
operator|=
name|wpi_ident_table
init|;
name|ident
operator|->
name|name
operator|!=
name|NULL
condition|;
name|ident
operator|++
control|)
block|{
if|if
condition|(
name|ident
operator|->
name|subdevice
operator|&&
name|pci_get_subdevice
argument_list|(
name|dev
argument_list|)
operator|==
name|ident
operator|->
name|subdevice
condition|)
block|{
name|supportsa
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
comment|/* Clear device-specific "PCI retry timeout" register (41h). */
name|pci_write_config
argument_list|(
name|dev
argument_list|,
literal|0x41
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Enable bus-mastering. */
name|pci_enable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|rid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mem
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mem
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can't map mem space\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
return|return
name|error
return|;
block|}
name|sc
operator|->
name|sc_st
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|mem
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_sh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|mem
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
name|rid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pci_alloc_msi
argument_list|(
name|dev
argument_list|,
operator|&
name|i
argument_list|)
operator|==
literal|0
condition|)
name|rid
operator|=
literal|1
expr_stmt|;
comment|/* Install interrupt handler. */
name|sc
operator|->
name|irq
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
operator||
operator|(
name|rid
operator|!=
literal|0
condition|?
literal|0
else|:
name|RF_SHAREABLE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irq
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can't map interrupt\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|WPI_LOCK_INIT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_unr
operator|=
name|new_unrhdr
argument_list|(
name|WPI_ID_IBSS_MIN
argument_list|,
name|WPI_ID_IBSS_MAX
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
comment|/* Allocate DMA memory for firmware transfers. */
if|if
condition|(
operator|(
name|error
operator|=
name|wpi_alloc_fwmem
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate memory for firmware, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Allocate shared page. */
if|if
condition|(
operator|(
name|error
operator|=
name|wpi_alloc_shared
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate shared page\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Allocate TX rings - 4 for QoS purposes, 1 for commands. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|WPI_NTXQUEUES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|wpi_alloc_tx_ring
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|txq
index|[
name|i
index|]
argument_list|,
name|i
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate TX ring %d, error %d\n"
argument_list|,
name|i
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
comment|/* Allocate RX ring. */
if|if
condition|(
operator|(
name|error
operator|=
name|wpi_alloc_rx_ring
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate RX ring, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Clear pending interrupts. */
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_INT
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|sc_ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_IEEE80211
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can not allocate ifnet structure\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ic
operator|=
name|ifp
operator|->
name|if_l2com
expr_stmt|;
name|ic
operator|->
name|ic_ifp
operator|=
name|ifp
expr_stmt|;
name|ic
operator|->
name|ic_phytype
operator|=
name|IEEE80211_T_OFDM
expr_stmt|;
comment|/* not only, but not used */
name|ic
operator|->
name|ic_opmode
operator|=
name|IEEE80211_M_STA
expr_stmt|;
comment|/* default to BSS mode */
comment|/* Set device capabilities. */
name|ic
operator|->
name|ic_caps
operator|=
name|IEEE80211_C_STA
comment|/* station mode supported */
operator||
name|IEEE80211_C_IBSS
comment|/* IBSS mode supported */
operator||
name|IEEE80211_C_MONITOR
comment|/* monitor mode supported */
operator||
name|IEEE80211_C_AHDEMO
comment|/* adhoc demo mode */
operator||
name|IEEE80211_C_BGSCAN
comment|/* capable of bg scanning */
operator||
name|IEEE80211_C_TXPMGT
comment|/* tx power management */
operator||
name|IEEE80211_C_SHSLOT
comment|/* short slot time supported */
operator||
name|IEEE80211_C_WPA
comment|/* 802.11i */
operator||
name|IEEE80211_C_SHPREAMBLE
comment|/* short preamble supported */
if|#
directive|if
literal|0
expr|| IEEE80211_C_HOSTAP
comment|/* Host access point mode */
endif|#
directive|endif
operator||
name|IEEE80211_C_WME
comment|/* 802.11e */
operator||
name|IEEE80211_C_PMGT
comment|/* Station-side power mgmt */
expr_stmt|;
name|ic
operator|->
name|ic_cryptocaps
operator|=
name|IEEE80211_CRYPTO_AES_CCM
expr_stmt|;
comment|/* 	 * Read in the eeprom and also setup the channels for 	 * net80211. We don't set the rates as net80211 does this for us 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|wpi_read_eeprom
argument_list|(
name|sc
argument_list|,
name|macaddr
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not read EEPROM, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
ifdef|#
directive|ifdef
name|WPI_DEBUG
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Regulatory Domain: %.4s\n"
argument_list|,
name|sc
operator|->
name|domain
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Hardware Type: %c\n"
argument_list|,
name|sc
operator|->
name|type
operator|>
literal|1
condition|?
literal|'B'
else|:
literal|'?'
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Hardware Revision: %c\n"
argument_list|,
operator|(
operator|(
name|le16toh
argument_list|(
name|sc
operator|->
name|rev
argument_list|)
operator|&
literal|0xf0
operator|)
operator|==
literal|0xd0
operator|)
condition|?
literal|'D'
else|:
literal|'?'
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"SKU %s support 802.11a\n"
argument_list|,
name|supportsa
condition|?
literal|"does"
else|:
literal|"does not"
argument_list|)
expr_stmt|;
comment|/* XXX hw_config uses the PCIDEV for the Hardware rev. Must check 	       what sc->rev really represents - benjsc 20070615 */
block|}
endif|#
directive|endif
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|wpi_init
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|wpi_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|wpi_start
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|ifqmaxlen
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
operator|=
name|ifqmaxlen
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
name|ieee80211_ifattach
argument_list|(
name|ic
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_vap_create
operator|=
name|wpi_vap_create
expr_stmt|;
name|ic
operator|->
name|ic_vap_delete
operator|=
name|wpi_vap_delete
expr_stmt|;
name|ic
operator|->
name|ic_raw_xmit
operator|=
name|wpi_raw_xmit
expr_stmt|;
name|ic
operator|->
name|ic_node_alloc
operator|=
name|wpi_node_alloc
expr_stmt|;
name|sc
operator|->
name|sc_node_free
operator|=
name|ic
operator|->
name|ic_node_free
expr_stmt|;
name|ic
operator|->
name|ic_node_free
operator|=
name|wpi_node_free
expr_stmt|;
name|ic
operator|->
name|ic_wme
operator|.
name|wme_update
operator|=
name|wpi_updateedca
expr_stmt|;
name|ic
operator|->
name|ic_update_promisc
operator|=
name|wpi_update_promisc
expr_stmt|;
name|ic
operator|->
name|ic_update_mcast
operator|=
name|wpi_update_mcast
expr_stmt|;
name|ic
operator|->
name|ic_scan_start
operator|=
name|wpi_scan_start
expr_stmt|;
name|ic
operator|->
name|ic_scan_end
operator|=
name|wpi_scan_end
expr_stmt|;
name|ic
operator|->
name|ic_set_channel
operator|=
name|wpi_set_channel
expr_stmt|;
name|sc
operator|->
name|sc_scan_curchan
operator|=
name|ic
operator|->
name|ic_scan_curchan
expr_stmt|;
name|ic
operator|->
name|ic_scan_curchan
operator|=
name|wpi_scan_curchan
expr_stmt|;
name|ic
operator|->
name|ic_scan_mindwell
operator|=
name|wpi_scan_mindwell
expr_stmt|;
name|ic
operator|->
name|ic_setregdomain
operator|=
name|wpi_setregdomain
expr_stmt|;
name|wpi_radiotap_attach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|calib_to
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|watchdog_to
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|watchdog_rfkill
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_reinittask
argument_list|,
literal|0
argument_list|,
name|wpi_hw_reset
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_radiooff_task
argument_list|,
literal|0
argument_list|,
name|wpi_radio_off
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_radioon_task
argument_list|,
literal|0
argument_list|,
name|wpi_radio_on
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|wpi_sysctlattach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Hook our interrupt after all initialization is complete. 	 */
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|wpi_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_ih
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can't establish interrupt, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|ieee80211_announce
argument_list|(
name|ic
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WPI_DEBUG
if|if
condition|(
name|sc
operator|->
name|sc_debug
operator|&
name|WPI_DEBUG_HW
condition|)
name|ieee80211_announce_channels
argument_list|(
name|ic
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_END
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|fail
label|:
name|wpi_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_END_ERR
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Attach the interface to 802.11 radiotap.  */
end_comment

begin_function
specifier|static
name|void
name|wpi_radiotap_attach
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_BEGIN
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ieee80211_radiotap_attach
argument_list|(
name|ic
argument_list|,
operator|&
name|sc
operator|->
name|sc_txtap
operator|.
name|wt_ihdr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_txtap
argument_list|)
argument_list|,
name|WPI_TX_RADIOTAP_PRESENT
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxtap
operator|.
name|wr_ihdr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_rxtap
argument_list|)
argument_list|,
name|WPI_RX_RADIOTAP_PRESENT
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_END
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_sysctlattach
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|WPI_DEBUG
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
init|=
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|tree
init|=
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
decl_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"debug"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|sc_debug
argument_list|,
name|sc
operator|->
name|sc_debug
argument_list|,
literal|"control debugging printfs"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|struct
name|ieee80211vap
modifier|*
name|wpi_vap_create
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|char
name|name
index|[
name|IFNAMSIZ
index|]
parameter_list|,
name|int
name|unit
parameter_list|,
name|enum
name|ieee80211_opmode
name|opmode
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|uint8_t
name|bssid
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|wpi_vap
modifier|*
name|wvp
decl_stmt|;
name|struct
name|wpi_buf
modifier|*
name|bcn
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
condition|)
comment|/* only one at a time */
return|return
name|NULL
return|;
name|wvp
operator|=
operator|(
expr|struct
name|wpi_vap
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|wpi_vap
argument_list|)
argument_list|,
name|M_80211_VAP
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|wvp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|vap
operator|=
operator|&
name|wvp
operator|->
name|vap
expr_stmt|;
name|ieee80211_vap_setup
argument_list|(
name|ic
argument_list|,
name|vap
argument_list|,
name|name
argument_list|,
name|unit
argument_list|,
name|opmode
argument_list|,
name|flags
argument_list|,
name|bssid
argument_list|,
name|mac
argument_list|)
expr_stmt|;
name|bcn
operator|=
operator|&
name|wvp
operator|->
name|wv_bcbuf
expr_stmt|;
name|bcn
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
comment|/* Override with driver methods. */
name|wvp
operator|->
name|newstate
operator|=
name|vap
operator|->
name|iv_newstate
expr_stmt|;
name|vap
operator|->
name|iv_key_alloc
operator|=
name|wpi_key_alloc
expr_stmt|;
name|vap
operator|->
name|iv_key_set
operator|=
name|wpi_key_set
expr_stmt|;
name|vap
operator|->
name|iv_key_delete
operator|=
name|wpi_key_delete
expr_stmt|;
name|vap
operator|->
name|iv_newstate
operator|=
name|wpi_newstate
expr_stmt|;
name|vap
operator|->
name|iv_update_beacon
operator|=
name|wpi_update_beacon
expr_stmt|;
name|ieee80211_ratectl_init
argument_list|(
name|vap
argument_list|)
expr_stmt|;
comment|/* Complete setup. */
name|ieee80211_vap_attach
argument_list|(
name|vap
argument_list|,
name|ieee80211_media_change
argument_list|,
name|ieee80211_media_status
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_opmode
operator|=
name|opmode
expr_stmt|;
return|return
name|vap
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_vap_delete
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|wpi_vap
modifier|*
name|wvp
init|=
name|WPI_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|struct
name|wpi_buf
modifier|*
name|bcn
init|=
operator|&
name|wvp
operator|->
name|wv_bcbuf
decl_stmt|;
name|ieee80211_ratectl_deinit
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|ieee80211_vap_detach
argument_list|(
name|vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcn
operator|->
name|data
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|bcn
operator|->
name|data
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|wvp
argument_list|,
name|M_80211_VAP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|wpi_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|wpi_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
decl_stmt|;
name|int
name|qid
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_BEGIN
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|!=
name|NULL
condition|)
block|{
name|ic
operator|=
name|ifp
operator|->
name|if_l2com
expr_stmt|;
name|ieee80211_draintask
argument_list|(
name|ic
argument_list|,
operator|&
name|sc
operator|->
name|sc_reinittask
argument_list|)
expr_stmt|;
name|ieee80211_draintask
argument_list|(
name|ic
argument_list|,
operator|&
name|sc
operator|->
name|sc_radiooff_task
argument_list|)
expr_stmt|;
name|wpi_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|watchdog_to
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|watchdog_rfkill
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|calib_to
argument_list|)
expr_stmt|;
name|ieee80211_ifdetach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
comment|/* Uninstall interrupt handler. */
if|if
condition|(
name|sc
operator|->
name|irq
operator|!=
name|NULL
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq
argument_list|,
name|sc
operator|->
name|sc_ih
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rman_get_rid
argument_list|(
name|sc
operator|->
name|irq
argument_list|)
argument_list|,
name|sc
operator|->
name|irq
argument_list|)
expr_stmt|;
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|txq
index|[
literal|0
index|]
operator|.
name|data_dmat
condition|)
block|{
comment|/* Free DMA resources. */
for|for
control|(
name|qid
operator|=
literal|0
init|;
name|qid
operator|<
name|WPI_NTXQUEUES
condition|;
name|qid
operator|++
control|)
name|wpi_free_tx_ring
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|txq
index|[
name|qid
index|]
argument_list|)
expr_stmt|;
name|wpi_free_rx_ring
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|wpi_free_shared
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|fw_dma
operator|.
name|tag
condition|)
name|wpi_free_fwmem
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mem
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|rman_get_rid
argument_list|(
name|sc
operator|->
name|mem
argument_list|)
argument_list|,
name|sc
operator|->
name|mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|!=
name|NULL
condition|)
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|delete_unrhdr
argument_list|(
name|sc
operator|->
name|sc_unr
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_END
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|WPI_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wpi_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|wpi_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|wpi_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wpi_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|wpi_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|sc
operator|->
name|sc_ifp
operator|->
name|if_l2com
decl_stmt|;
name|ieee80211_suspend_all
argument_list|(
name|ic
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wpi_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|wpi_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|sc
operator|->
name|sc_ifp
operator|->
name|if_l2com
decl_stmt|;
comment|/* Clear device-specific "PCI retry timeout" register (41h). */
name|pci_write_config
argument_list|(
name|dev
argument_list|,
literal|0x41
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ieee80211_resume_all
argument_list|(
name|ic
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Grab exclusive access to NIC memory.  */
end_comment

begin_function
specifier|static
name|int
name|wpi_nic_lock
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|ntries
decl_stmt|;
comment|/* Request exclusive access to NIC. */
name|WPI_SETBITS
argument_list|(
name|sc
argument_list|,
name|WPI_GP_CNTRL
argument_list|,
name|WPI_GP_CNTRL_MAC_ACCESS_REQ
argument_list|)
expr_stmt|;
comment|/* Spin until we actually get the lock. */
for|for
control|(
name|ntries
operator|=
literal|0
init|;
name|ntries
operator|<
literal|1000
condition|;
name|ntries
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|WPI_READ
argument_list|(
name|sc
argument_list|,
name|WPI_GP_CNTRL
argument_list|)
operator|&
operator|(
name|WPI_GP_CNTRL_MAC_ACCESS_ENA
operator||
name|WPI_GP_CNTRL_SLEEP
operator|)
operator|)
operator|==
name|WPI_GP_CNTRL_MAC_ACCESS_ENA
condition|)
return|return
literal|0
return|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not lock memory\n"
argument_list|)
expr_stmt|;
return|return
name|ETIMEDOUT
return|;
block|}
end_function

begin_comment
comment|/*  * Release lock on NIC memory.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|wpi_nic_unlock
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|WPI_CLRBITS
argument_list|(
name|sc
argument_list|,
name|WPI_GP_CNTRL
argument_list|,
name|WPI_GP_CNTRL_MAC_ACCESS_REQ
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint32_t
name|wpi_prph_read
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|)
block|{
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_PRPH_RADDR
argument_list|,
name|WPI_PRPH_DWORD
operator||
name|addr
argument_list|)
expr_stmt|;
name|WPI_BARRIER_READ_WRITE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|WPI_READ
argument_list|(
name|sc
argument_list|,
name|WPI_PRPH_RDATA
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|wpi_prph_write
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|uint32_t
name|data
parameter_list|)
block|{
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_PRPH_WADDR
argument_list|,
name|WPI_PRPH_DWORD
operator||
name|addr
argument_list|)
expr_stmt|;
name|WPI_BARRIER_WRITE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_PRPH_WDATA
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|wpi_prph_setbits
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|uint32_t
name|mask
parameter_list|)
block|{
name|wpi_prph_write
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|wpi_prph_read
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|)
operator||
name|mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|wpi_prph_clrbits
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|uint32_t
name|mask
parameter_list|)
block|{
name|wpi_prph_write
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|wpi_prph_read
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|)
operator|&
operator|~
name|mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|wpi_prph_write_region_4
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
specifier|const
name|uint32_t
modifier|*
name|data
parameter_list|,
name|int
name|count
parameter_list|)
block|{
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
operator|,
name|data
operator|++
operator|,
name|addr
operator|+=
literal|4
control|)
name|wpi_prph_write
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
operator|*
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint32_t
name|wpi_mem_read
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|)
block|{
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_MEM_RADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|WPI_BARRIER_READ_WRITE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|WPI_READ
argument_list|(
name|sc
argument_list|,
name|WPI_MEM_RDATA
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|wpi_mem_read_region_4
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|uint32_t
modifier|*
name|data
parameter_list|,
name|int
name|count
parameter_list|)
block|{
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
operator|,
name|addr
operator|+=
literal|4
control|)
operator|*
name|data
operator|++
operator|=
name|wpi_mem_read
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|wpi_read_prom_data
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|uint8_t
modifier|*
name|out
init|=
name|data
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|int
name|error
decl_stmt|,
name|ntries
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_BEGIN
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|wpi_nic_lock
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|-=
literal|2
operator|,
name|addr
operator|++
control|)
block|{
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_EEPROM
argument_list|,
name|addr
operator|<<
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|ntries
operator|=
literal|0
init|;
name|ntries
operator|<
literal|10
condition|;
name|ntries
operator|++
control|)
block|{
name|val
operator|=
name|WPI_READ
argument_list|(
name|sc
argument_list|,
name|WPI_EEPROM
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|WPI_EEPROM_READ_VALID
condition|)
break|break;
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ntries
operator|==
literal|10
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"timeout reading ROM at 0x%x\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
name|ETIMEDOUT
return|;
block|}
operator|*
name|out
operator|++
operator|=
name|val
operator|>>
literal|16
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|1
condition|)
operator|*
name|out
operator|++
operator|=
name|val
operator|>>
literal|24
expr_stmt|;
block|}
name|wpi_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_END
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_dma_map_addr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return;
name|KASSERT
argument_list|(
name|nsegs
operator|==
literal|1
argument_list|,
operator|(
literal|"too many DMA segments, %d should be 1"
operator|,
name|nsegs
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|bus_addr_t
operator|*
operator|)
name|arg
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocates a contiguous block of dma memory of the requested size and  * alignment.  */
end_comment

begin_function
specifier|static
name|int
name|wpi_dma_contig_alloc
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|wpi_dma_info
modifier|*
name|dma
parameter_list|,
name|void
modifier|*
modifier|*
name|kvap
parameter_list|,
name|bus_size_t
name|size
parameter_list|,
name|bus_size_t
name|alignment
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|dma
operator|->
name|tag
operator|=
name|NULL
expr_stmt|;
name|dma
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|alignment
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|size
argument_list|,
literal|1
argument_list|,
name|size
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|dma
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|dma
operator|->
name|vaddr
argument_list|,
name|BUS_DMA_NOWAIT
operator||
name|BUS_DMA_ZERO
operator||
name|BUS_DMA_COHERENT
argument_list|,
operator|&
name|dma
operator|->
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
name|dma
operator|->
name|map
argument_list|,
name|dma
operator|->
name|vaddr
argument_list|,
name|size
argument_list|,
name|wpi_dma_map_addr
argument_list|,
operator|&
name|dma
operator|->
name|paddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|bus_dmamap_sync
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
name|dma
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|kvap
operator|!=
name|NULL
condition|)
operator|*
name|kvap
operator|=
name|dma
operator|->
name|vaddr
expr_stmt|;
return|return
literal|0
return|;
name|fail
label|:
name|wpi_dma_contig_free
argument_list|(
name|dma
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_dma_contig_free
parameter_list|(
name|struct
name|wpi_dma_info
modifier|*
name|dma
parameter_list|)
block|{
if|if
condition|(
name|dma
operator|->
name|vaddr
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
name|dma
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
name|dma
operator|->
name|map
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
name|dma
operator|->
name|vaddr
argument_list|,
name|dma
operator|->
name|map
argument_list|)
expr_stmt|;
name|dma
operator|->
name|vaddr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|dma
operator|->
name|tag
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|dma
operator|->
name|tag
argument_list|)
expr_stmt|;
name|dma
operator|->
name|tag
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Allocate a shared page between host and NIC.  */
end_comment

begin_function
specifier|static
name|int
name|wpi_alloc_shared
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Shared buffer must be aligned on a 4KB boundary. */
return|return
name|wpi_dma_contig_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|shared_dma
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|shared
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|wpi_shared
argument_list|)
argument_list|,
literal|4096
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_free_shared
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|wpi_dma_contig_free
argument_list|(
operator|&
name|sc
operator|->
name|shared_dma
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate DMA-safe memory for firmware transfer.  */
end_comment

begin_function
specifier|static
name|int
name|wpi_alloc_fwmem
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Must be aligned on a 16-byte boundary. */
return|return
name|wpi_dma_contig_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|fw_dma
argument_list|,
name|NULL
argument_list|,
name|WPI_FW_TEXT_MAXSZ
operator|+
name|WPI_FW_DATA_MAXSZ
argument_list|,
literal|16
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_free_fwmem
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|wpi_dma_contig_free
argument_list|(
operator|&
name|sc
operator|->
name|fw_dma
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|wpi_alloc_rx_ring
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|wpi_rx_ring
modifier|*
name|ring
init|=
operator|&
name|sc
operator|->
name|rxq
decl_stmt|;
name|bus_size_t
name|size
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|ring
operator|->
name|cur
operator|=
literal|0
expr_stmt|;
name|ring
operator|->
name|update
operator|=
literal|0
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_BEGIN
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Allocate RX descriptors (16KB aligned.) */
name|size
operator|=
name|WPI_RX_RING_COUNT
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|error
operator|=
name|wpi_dma_contig_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|ring
operator|->
name|desc_dma
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|ring
operator|->
name|desc
argument_list|,
name|size
argument_list|,
name|WPI_RING_DMA_ALIGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not allocate RX ring DMA memory, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Create RX buffer DMA tag. */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|MJUMPAGESIZE
argument_list|,
literal|1
argument_list|,
name|MJUMPAGESIZE
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|ring
operator|->
name|data_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not create RX buf DMA tag, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 	 * Allocate and map RX buffers. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|WPI_RX_RING_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|wpi_rx_data
modifier|*
name|data
init|=
operator|&
name|ring
operator|->
name|data
index|[
name|i
index|]
decl_stmt|;
name|bus_addr_t
name|paddr
decl_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
literal|0
argument_list|,
operator|&
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not create RX buf DMA map, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|data
operator|->
name|m
operator|=
name|m_getjcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|,
name|MJUMPAGESIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|m
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not allocate RX mbuf\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|mtod
argument_list|(
name|data
operator|->
name|m
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
name|MJUMPAGESIZE
argument_list|,
name|wpi_dma_map_addr
argument_list|,
operator|&
name|paddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|EFBIG
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: can't map mbuf (error %d)\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Set physical address of RX buffer. */
name|ring
operator|->
name|desc
index|[
name|i
index|]
operator|=
name|htole32
argument_list|(
name|paddr
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|desc_dma
operator|.
name|tag
argument_list|,
name|ring
operator|->
name|desc_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_END
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|fail
label|:
name|wpi_free_rx_ring
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_END_ERR
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_update_rx_ring
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|wpi_rx_ring
modifier|*
name|ring
init|=
operator|&
name|sc
operator|->
name|rxq
decl_stmt|;
if|if
condition|(
name|WPI_READ
argument_list|(
name|sc
argument_list|,
name|WPI_UCODE_GP1
argument_list|)
operator|&
name|WPI_UCODE_GP1_MAC_SLEEP
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_PWRSAVE
argument_list|,
literal|"%s: wakeup request\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|WPI_SETBITS
argument_list|(
name|sc
argument_list|,
name|WPI_GP_CNTRL
argument_list|,
name|WPI_GP_CNTRL_MAC_ACCESS_REQ
argument_list|)
expr_stmt|;
name|ring
operator|->
name|update
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_FH_RX_WPTR
argument_list|,
name|ring
operator|->
name|cur
operator|&
operator|~
literal|7
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_reset_rx_ring
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|wpi_rx_ring
modifier|*
name|ring
init|=
operator|&
name|sc
operator|->
name|rxq
decl_stmt|;
name|int
name|ntries
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_DOING
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpi_nic_lock
argument_list|(
name|sc
argument_list|)
operator|==
literal|0
condition|)
block|{
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_FH_RX_CONFIG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|ntries
operator|=
literal|0
init|;
name|ntries
operator|<
literal|1000
condition|;
name|ntries
operator|++
control|)
block|{
if|if
condition|(
name|WPI_READ
argument_list|(
name|sc
argument_list|,
name|WPI_FH_RX_STATUS
argument_list|)
operator|&
name|WPI_FH_RX_STATUS_IDLE
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|WPI_DEBUG
if|if
condition|(
name|ntries
operator|==
literal|1000
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"timeout resetting Rx ring\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|wpi_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|ring
operator|->
name|cur
operator|=
literal|0
expr_stmt|;
name|ring
operator|->
name|update
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_free_rx_ring
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|wpi_rx_ring
modifier|*
name|ring
init|=
operator|&
name|sc
operator|->
name|rxq
decl_stmt|;
name|int
name|i
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_DOING
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|wpi_dma_contig_free
argument_list|(
operator|&
name|ring
operator|->
name|desc_dma
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|WPI_RX_RING_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|wpi_rx_data
modifier|*
name|data
init|=
operator|&
name|ring
operator|->
name|data
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|data
operator|->
name|m
argument_list|)
expr_stmt|;
name|data
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|->
name|map
operator|!=
name|NULL
condition|)
name|bus_dmamap_destroy
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ring
operator|->
name|data_dmat
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|)
expr_stmt|;
name|ring
operator|->
name|data_dmat
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|wpi_alloc_tx_ring
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|wpi_tx_ring
modifier|*
name|ring
parameter_list|,
name|int
name|qid
parameter_list|)
block|{
name|bus_addr_t
name|paddr
decl_stmt|;
name|bus_size_t
name|size
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|ring
operator|->
name|qid
operator|=
name|qid
expr_stmt|;
name|ring
operator|->
name|queued
operator|=
literal|0
expr_stmt|;
name|ring
operator|->
name|cur
operator|=
literal|0
expr_stmt|;
name|ring
operator|->
name|update
operator|=
literal|0
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_BEGIN
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Allocate TX descriptors (16KB aligned.) */
name|size
operator|=
name|WPI_TX_RING_COUNT
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|wpi_tx_desc
argument_list|)
expr_stmt|;
name|error
operator|=
name|wpi_dma_contig_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|ring
operator|->
name|desc_dma
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|ring
operator|->
name|desc
argument_list|,
name|size
argument_list|,
name|WPI_RING_DMA_ALIGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not allocate TX ring DMA memory, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Update shared area with ring physical address. */
name|sc
operator|->
name|shared
operator|->
name|txbase
index|[
name|qid
index|]
operator|=
name|htole32
argument_list|(
name|ring
operator|->
name|desc_dma
operator|.
name|paddr
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|shared_dma
operator|.
name|tag
argument_list|,
name|sc
operator|->
name|shared_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* 	 * We only use rings 0 through 4 (4 EDCA + cmd) so there is no need 	 * to allocate commands space for other rings. 	 * XXX Do we really need to allocate descriptors for other rings? 	 */
if|if
condition|(
name|qid
operator|>
literal|4
condition|)
return|return
literal|0
return|;
name|size
operator|=
name|WPI_TX_RING_COUNT
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|wpi_tx_cmd
argument_list|)
expr_stmt|;
name|error
operator|=
name|wpi_dma_contig_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|ring
operator|->
name|cmd_dma
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|ring
operator|->
name|cmd
argument_list|,
name|size
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not allocate TX cmd DMA memory, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|MCLBYTES
argument_list|,
name|WPI_MAX_SCATTER
operator|-
literal|1
argument_list|,
name|MCLBYTES
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|ring
operator|->
name|data_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not create TX buf DMA tag, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|paddr
operator|=
name|ring
operator|->
name|cmd_dma
operator|.
name|paddr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|WPI_TX_RING_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|wpi_tx_data
modifier|*
name|data
init|=
operator|&
name|ring
operator|->
name|data
index|[
name|i
index|]
decl_stmt|;
name|data
operator|->
name|cmd_paddr
operator|=
name|paddr
expr_stmt|;
name|paddr
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|wpi_tx_cmd
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
literal|0
argument_list|,
operator|&
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not create TX buf DMA map, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_END
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|fail
label|:
name|wpi_free_tx_ring
argument_list|(
name|sc
argument_list|,
name|ring
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_END_ERR
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_update_tx_ring
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|wpi_tx_ring
modifier|*
name|ring
parameter_list|)
block|{
if|if
condition|(
name|WPI_READ
argument_list|(
name|sc
argument_list|,
name|WPI_UCODE_GP1
argument_list|)
operator|&
name|WPI_UCODE_GP1_MAC_SLEEP
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_PWRSAVE
argument_list|,
literal|"%s (%d): requesting wakeup\n"
argument_list|,
name|__func__
argument_list|,
name|ring
operator|->
name|qid
argument_list|)
expr_stmt|;
name|WPI_SETBITS
argument_list|(
name|sc
argument_list|,
name|WPI_GP_CNTRL
argument_list|,
name|WPI_GP_CNTRL_MAC_ACCESS_REQ
argument_list|)
expr_stmt|;
name|ring
operator|->
name|update
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_HBUS_TARG_WRPTR
argument_list|,
name|ring
operator|->
name|qid
operator|<<
literal|8
operator||
name|ring
operator|->
name|cur
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_reset_tx_ring
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|wpi_tx_ring
modifier|*
name|ring
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_DOING
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|WPI_TX_RING_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|wpi_tx_data
modifier|*
name|data
init|=
operator|&
name|ring
operator|->
name|data
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|data
operator|->
name|m
argument_list|)
expr_stmt|;
name|data
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Clear TX descriptors. */
name|memset
argument_list|(
name|ring
operator|->
name|desc
argument_list|,
literal|0
argument_list|,
name|ring
operator|->
name|desc_dma
operator|.
name|size
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|desc_dma
operator|.
name|tag
argument_list|,
name|ring
operator|->
name|desc_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|qfullmsk
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|ring
operator|->
name|qid
operator|)
expr_stmt|;
name|ring
operator|->
name|queued
operator|=
literal|0
expr_stmt|;
name|ring
operator|->
name|cur
operator|=
literal|0
expr_stmt|;
name|ring
operator|->
name|update
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_free_tx_ring
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|wpi_tx_ring
modifier|*
name|ring
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_DOING
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|wpi_dma_contig_free
argument_list|(
operator|&
name|ring
operator|->
name|desc_dma
argument_list|)
expr_stmt|;
name|wpi_dma_contig_free
argument_list|(
operator|&
name|ring
operator|->
name|cmd_dma
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|WPI_TX_RING_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|wpi_tx_data
modifier|*
name|data
init|=
operator|&
name|ring
operator|->
name|data
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|data
operator|->
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|->
name|map
operator|!=
name|NULL
condition|)
name|bus_dmamap_destroy
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ring
operator|->
name|data_dmat
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|)
expr_stmt|;
name|ring
operator|->
name|data_dmat
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Extract various information from EEPROM.  */
end_comment

begin_function
specifier|static
name|int
name|wpi_read_eeprom
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|macaddr
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
define|#
directive|define
name|WPI_CHK
parameter_list|(
name|res
parameter_list|)
value|do {		\ 	if ((error = res) != 0)		\ 		goto fail;		\ } while (0)
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_BEGIN
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Adapter has to be powered on for EEPROM access to work. */
if|if
condition|(
operator|(
name|error
operator|=
name|wpi_apm_init
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not power ON adapter, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
operator|(
name|WPI_READ
argument_list|(
name|sc
argument_list|,
name|WPI_EEPROM_GP
argument_list|)
operator|&
literal|0x6
operator|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"bad EEPROM signature\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Clear HW ownership of EEPROM. */
name|WPI_CLRBITS
argument_list|(
name|sc
argument_list|,
name|WPI_EEPROM_GP
argument_list|,
name|WPI_EEPROM_GP_IF_OWNER
argument_list|)
expr_stmt|;
comment|/* Read the hardware capabilities, revision and SKU type. */
name|WPI_CHK
argument_list|(
name|wpi_read_prom_data
argument_list|(
name|sc
argument_list|,
name|WPI_EEPROM_SKU_CAP
argument_list|,
operator|&
name|sc
operator|->
name|cap
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|cap
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|WPI_CHK
argument_list|(
name|wpi_read_prom_data
argument_list|(
name|sc
argument_list|,
name|WPI_EEPROM_REVISION
argument_list|,
operator|&
name|sc
operator|->
name|rev
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|rev
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|WPI_CHK
argument_list|(
name|wpi_read_prom_data
argument_list|(
name|sc
argument_list|,
name|WPI_EEPROM_TYPE
argument_list|,
operator|&
name|sc
operator|->
name|type
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_EEPROM
argument_list|,
literal|"cap=%x rev=%x type=%x\n"
argument_list|,
name|sc
operator|->
name|cap
argument_list|,
name|le16toh
argument_list|(
name|sc
operator|->
name|rev
argument_list|)
argument_list|,
name|sc
operator|->
name|type
argument_list|)
expr_stmt|;
comment|/* Read the regulatory domain (4 ASCII characters.) */
name|WPI_CHK
argument_list|(
name|wpi_read_prom_data
argument_list|(
name|sc
argument_list|,
name|WPI_EEPROM_DOMAIN
argument_list|,
name|sc
operator|->
name|domain
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|domain
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read MAC address. */
name|WPI_CHK
argument_list|(
name|wpi_read_prom_data
argument_list|(
name|sc
argument_list|,
name|WPI_EEPROM_MAC
argument_list|,
name|macaddr
argument_list|,
name|IEEE80211_ADDR_LEN
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read the list of authorized channels. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|WPI_CHAN_BANDS_COUNT
condition|;
name|i
operator|++
control|)
name|WPI_CHK
argument_list|(
name|wpi_read_eeprom_channels
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read the list of TX power groups. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|WPI_POWER_GROUPS_COUNT
condition|;
name|i
operator|++
control|)
name|WPI_CHK
argument_list|(
name|wpi_read_eeprom_group
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|fail
label|:
name|wpi_apm_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Power OFF adapter. */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|error
condition|?
name|TRACE_STR_END_ERR
else|:
name|TRACE_STR_END
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|error
return|;
undef|#
directive|undef
name|WPI_CHK
block|}
end_function

begin_comment
comment|/*  * Translate EEPROM flags to net80211.  */
end_comment

begin_function
specifier|static
name|uint32_t
name|wpi_eeprom_channel_flags
parameter_list|(
name|struct
name|wpi_eeprom_chan
modifier|*
name|channel
parameter_list|)
block|{
name|uint32_t
name|nflags
decl_stmt|;
name|nflags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|channel
operator|->
name|flags
operator|&
name|WPI_EEPROM_CHAN_ACTIVE
operator|)
operator|==
literal|0
condition|)
name|nflags
operator||=
name|IEEE80211_CHAN_PASSIVE
expr_stmt|;
if|if
condition|(
operator|(
name|channel
operator|->
name|flags
operator|&
name|WPI_EEPROM_CHAN_IBSS
operator|)
operator|==
literal|0
condition|)
name|nflags
operator||=
name|IEEE80211_CHAN_NOADHOC
expr_stmt|;
if|if
condition|(
name|channel
operator|->
name|flags
operator|&
name|WPI_EEPROM_CHAN_RADAR
condition|)
block|{
name|nflags
operator||=
name|IEEE80211_CHAN_DFS
expr_stmt|;
comment|/* XXX apparently IBSS may still be marked */
name|nflags
operator||=
name|IEEE80211_CHAN_NOADHOC
expr_stmt|;
block|}
return|return
name|nflags
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_read_eeprom_band
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|wpi_eeprom_chan
modifier|*
name|channels
init|=
name|sc
operator|->
name|eeprom_channels
index|[
name|n
index|]
decl_stmt|;
specifier|const
name|struct
name|wpi_chan_band
modifier|*
name|band
init|=
operator|&
name|wpi_bands
index|[
name|n
index|]
decl_stmt|;
name|struct
name|ieee80211_channel
modifier|*
name|c
decl_stmt|;
name|uint8_t
name|chan
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nflags
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|band
operator|->
name|nchan
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|channels
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|WPI_EEPROM_CHAN_VALID
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_HW
argument_list|,
literal|"Channel Not Valid: %d, band %d\n"
argument_list|,
name|band
operator|->
name|chan
index|[
name|i
index|]
argument_list|,
name|n
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|chan
operator|=
name|band
operator|->
name|chan
index|[
name|i
index|]
expr_stmt|;
name|nflags
operator|=
name|wpi_eeprom_channel_flags
argument_list|(
operator|&
name|channels
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|c
operator|=
operator|&
name|ic
operator|->
name|ic_channels
index|[
name|ic
operator|->
name|ic_nchans
operator|++
index|]
expr_stmt|;
name|c
operator|->
name|ic_ieee
operator|=
name|chan
expr_stmt|;
name|c
operator|->
name|ic_maxregpower
operator|=
name|channels
index|[
name|i
index|]
operator|.
name|maxpwr
expr_stmt|;
name|c
operator|->
name|ic_maxpower
operator|=
literal|2
operator|*
name|c
operator|->
name|ic_maxregpower
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
comment|/* 2GHz band */
name|c
operator|->
name|ic_freq
operator|=
name|ieee80211_ieee2mhz
argument_list|(
name|chan
argument_list|,
name|IEEE80211_CHAN_G
argument_list|)
expr_stmt|;
comment|/* G =>'s B is supported */
name|c
operator|->
name|ic_flags
operator|=
name|IEEE80211_CHAN_B
operator||
name|nflags
expr_stmt|;
name|c
operator|=
operator|&
name|ic
operator|->
name|ic_channels
index|[
name|ic
operator|->
name|ic_nchans
operator|++
index|]
expr_stmt|;
name|c
index|[
literal|0
index|]
operator|=
name|c
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|c
operator|->
name|ic_flags
operator|=
name|IEEE80211_CHAN_G
operator||
name|nflags
expr_stmt|;
block|}
else|else
block|{
comment|/* 5GHz band */
name|c
operator|->
name|ic_freq
operator|=
name|ieee80211_ieee2mhz
argument_list|(
name|chan
argument_list|,
name|IEEE80211_CHAN_A
argument_list|)
expr_stmt|;
name|c
operator|->
name|ic_flags
operator|=
name|IEEE80211_CHAN_A
operator||
name|nflags
expr_stmt|;
block|}
comment|/* Save maximum allowed TX power for this channel. */
name|sc
operator|->
name|maxpwr
index|[
name|chan
index|]
operator|=
name|channels
index|[
name|i
index|]
operator|.
name|maxpwr
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_EEPROM
argument_list|,
literal|"adding chan %d (%dMHz) flags=0x%x maxpwr=%d passive=%d,"
literal|" offset %d\n"
argument_list|,
name|chan
argument_list|,
name|c
operator|->
name|ic_freq
argument_list|,
name|channels
index|[
name|i
index|]
operator|.
name|flags
argument_list|,
name|sc
operator|->
name|maxpwr
index|[
name|chan
index|]
argument_list|,
operator|(
name|c
operator|->
name|ic_flags
operator|&
name|IEEE80211_CHAN_PASSIVE
operator|)
operator|!=
literal|0
argument_list|,
name|ic
operator|->
name|ic_nchans
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Read the eeprom to find out what channels are valid for the given  * band and update net80211 with what we find.  */
end_comment

begin_function
specifier|static
name|int
name|wpi_read_eeprom_channels
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
specifier|const
name|struct
name|wpi_chan_band
modifier|*
name|band
init|=
operator|&
name|wpi_bands
index|[
name|n
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_BEGIN
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|wpi_read_prom_data
argument_list|(
name|sc
argument_list|,
name|band
operator|->
name|addr
argument_list|,
operator|&
name|sc
operator|->
name|eeprom_channels
index|[
name|n
index|]
argument_list|,
name|band
operator|->
name|nchan
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|wpi_eeprom_chan
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_END_ERR
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|wpi_read_eeprom_band
argument_list|(
name|sc
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|ieee80211_sort_channels
argument_list|(
name|ic
operator|->
name|ic_channels
argument_list|,
name|ic
operator|->
name|ic_nchans
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_END
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|wpi_eeprom_chan
modifier|*
name|wpi_find_eeprom_channel
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|c
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|WPI_CHAN_BANDS_COUNT
condition|;
name|j
operator|++
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|wpi_bands
index|[
name|j
index|]
operator|.
name|nchan
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|wpi_bands
index|[
name|j
index|]
operator|.
name|chan
index|[
name|i
index|]
operator|==
name|c
operator|->
name|ic_ieee
condition|)
return|return
operator|&
name|sc
operator|->
name|eeprom_channels
index|[
name|j
index|]
index|[
name|i
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Enforce flags read from EEPROM.  */
end_comment

begin_function
specifier|static
name|int
name|wpi_setregdomain
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_regdomain
modifier|*
name|rd
parameter_list|,
name|int
name|nchan
parameter_list|,
name|struct
name|ieee80211_channel
name|chans
index|[]
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|wpi_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nchan
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ieee80211_channel
modifier|*
name|c
init|=
operator|&
name|chans
index|[
name|i
index|]
decl_stmt|;
name|struct
name|wpi_eeprom_chan
modifier|*
name|channel
decl_stmt|;
name|channel
operator|=
name|wpi_find_eeprom_channel
argument_list|(
name|sc
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel
operator|==
name|NULL
condition|)
block|{
name|if_printf
argument_list|(
name|ic
operator|->
name|ic_ifp
argument_list|,
literal|"%s: invalid channel %u freq %u/0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|c
operator|->
name|ic_ieee
argument_list|,
name|c
operator|->
name|ic_freq
argument_list|,
name|c
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|c
operator|->
name|ic_flags
operator||=
name|wpi_eeprom_channel_flags
argument_list|(
name|channel
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wpi_read_eeprom_group
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|struct
name|wpi_power_group
modifier|*
name|group
init|=
operator|&
name|sc
operator|->
name|groups
index|[
name|n
index|]
decl_stmt|;
name|struct
name|wpi_eeprom_group
name|rgroup
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_BEGIN
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|wpi_read_prom_data
argument_list|(
name|sc
argument_list|,
name|WPI_EEPROM_POWER_GRP
operator|+
name|n
operator|*
literal|32
argument_list|,
operator|&
name|rgroup
argument_list|,
sizeof|sizeof
name|rgroup
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_END_ERR
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Save TX power group information. */
name|group
operator|->
name|chan
operator|=
name|rgroup
operator|.
name|chan
expr_stmt|;
name|group
operator|->
name|maxpwr
operator|=
name|rgroup
operator|.
name|maxpwr
expr_stmt|;
comment|/* Retrieve temperature at which the samples were taken. */
name|group
operator|->
name|temp
operator|=
operator|(
name|int16_t
operator|)
name|le16toh
argument_list|(
name|rgroup
operator|.
name|temp
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_EEPROM
argument_list|,
literal|"power group %d: chan=%d maxpwr=%d temp=%d\n"
argument_list|,
name|n
argument_list|,
name|group
operator|->
name|chan
argument_list|,
name|group
operator|->
name|maxpwr
argument_list|,
name|group
operator|->
name|temp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|WPI_SAMPLES_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|group
operator|->
name|samples
index|[
name|i
index|]
operator|.
name|index
operator|=
name|rgroup
operator|.
name|samples
index|[
name|i
index|]
operator|.
name|index
expr_stmt|;
name|group
operator|->
name|samples
index|[
name|i
index|]
operator|.
name|power
operator|=
name|rgroup
operator|.
name|samples
index|[
name|i
index|]
operator|.
name|power
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_EEPROM
argument_list|,
literal|"\tsample %d: index=%d power=%d\n"
argument_list|,
name|i
argument_list|,
name|group
operator|->
name|samples
index|[
name|i
index|]
operator|.
name|index
argument_list|,
name|group
operator|->
name|samples
index|[
name|i
index|]
operator|.
name|power
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_END
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ieee80211_node
modifier|*
name|wpi_node_alloc
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|wpi_node
modifier|*
name|wn
decl_stmt|;
name|wn
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|wpi_node
argument_list|)
argument_list|,
name|M_80211_NODE
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|wn
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|wn
operator|->
name|id
operator|=
name|WPI_ID_UNDEFINED
expr_stmt|;
return|return
operator|&
name|wn
operator|->
name|ni
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_node_free
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|wpi_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|wpi_node
modifier|*
name|wn
init|=
operator|(
expr|struct
name|wpi_node
operator|*
operator|)
name|ni
decl_stmt|;
if|if
condition|(
name|wn
operator|->
name|id
operator|>=
name|WPI_ID_IBSS_MIN
operator|&&
name|wn
operator|->
name|id
operator|<=
name|WPI_ID_IBSS_MAX
condition|)
block|{
name|free_unr
argument_list|(
name|sc
operator|->
name|sc_unr
argument_list|,
name|wn
operator|->
name|id
argument_list|)
expr_stmt|;
name|WPI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rxon
operator|.
name|filter
operator|&
name|htole32
argument_list|(
name|WPI_FILTER_BSS
argument_list|)
condition|)
name|wpi_del_node
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|)
expr_stmt|;
name|WPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_node_free
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Called by net80211 when ever there is a change to 80211 state machine  */
end_comment

begin_function
specifier|static
name|int
name|wpi_newstate
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|enum
name|ieee80211_state
name|nstate
parameter_list|,
name|int
name|arg
parameter_list|)
block|{
name|struct
name|wpi_vap
modifier|*
name|wvp
init|=
name|WPI_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|wpi_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_BEGIN
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_STATE
argument_list|,
literal|"%s: %s -> %s\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_state_name
index|[
name|vap
operator|->
name|iv_state
index|]
argument_list|,
name|ieee80211_state_name
index|[
name|nstate
index|]
argument_list|)
expr_stmt|;
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|WPI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|nstate
condition|)
block|{
case|case
name|IEEE80211_S_SCAN
case|:
if|if
condition|(
operator|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_IBSS
operator|||
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_AHDEMO
operator|)
operator|&&
operator|(
name|sc
operator|->
name|rxon
operator|.
name|filter
operator|&
name|htole32
argument_list|(
name|WPI_FILTER_BSS
argument_list|)
operator|)
condition|)
block|{
name|sc
operator|->
name|rxon
operator|.
name|filter
operator|&=
operator|~
name|htole32
argument_list|(
name|WPI_FILTER_BSS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|wpi_send_rxon
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not send RXON\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|IEEE80211_S_ASSOC
case|:
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|!=
name|IEEE80211_S_RUN
condition|)
break|break;
comment|/* FALLTHROUGH */
case|case
name|IEEE80211_S_AUTH
case|:
comment|/* 		 * The node must be registered in the firmware before auth. 		 * Also the associd must be cleared on RUN -> ASSOC 		 * transitions. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|wpi_auth
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not move to AUTH state, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IEEE80211_S_RUN
case|:
comment|/* 		 * RUN -> RUN transition; Just restart the timers. 		 */
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_RUN
condition|)
block|{
name|wpi_calib_timeout
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * !RUN -> RUN requires setting the association id 		 * which is done with a firmware cmd.  We also defer 		 * starting the timers until that work is done. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|wpi_run
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not move to RUN state\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
name|WPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_END_ERR
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_END
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|wvp
operator|->
name|newstate
argument_list|(
name|vap
argument_list|,
name|nstate
argument_list|,
name|arg
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_calib_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|wpi_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
decl_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|!=
name|IEEE80211_S_RUN
condition|)
return|return;
name|wpi_power_calibration
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|calib_to
argument_list|,
literal|60
operator|*
name|hz
argument_list|,
name|wpi_calib_timeout
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint8_t
name|rate2plcp
parameter_list|(
specifier|const
name|uint8_t
name|rate
parameter_list|)
block|{
switch|switch
condition|(
name|rate
condition|)
block|{
case|case
literal|12
case|:
return|return
literal|0xd
return|;
case|case
literal|18
case|:
return|return
literal|0xf
return|;
case|case
literal|24
case|:
return|return
literal|0x5
return|;
case|case
literal|36
case|:
return|return
literal|0x7
return|;
case|case
literal|48
case|:
return|return
literal|0x9
return|;
case|case
literal|72
case|:
return|return
literal|0xb
return|;
case|case
literal|96
case|:
return|return
literal|0x1
return|;
case|case
literal|108
case|:
return|return
literal|0x3
return|;
case|case
literal|2
case|:
return|return
literal|10
return|;
case|case
literal|4
case|:
return|return
literal|20
return|;
case|case
literal|11
case|:
return|return
literal|55
return|;
case|case
literal|22
case|:
return|return
literal|110
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint8_t
name|plcp2rate
parameter_list|(
specifier|const
name|uint8_t
name|plcp
parameter_list|)
block|{
switch|switch
condition|(
name|plcp
condition|)
block|{
case|case
literal|0xd
case|:
return|return
literal|12
return|;
case|case
literal|0xf
case|:
return|return
literal|18
return|;
case|case
literal|0x5
case|:
return|return
literal|24
return|;
case|case
literal|0x7
case|:
return|return
literal|36
return|;
case|case
literal|0x9
case|:
return|return
literal|48
return|;
case|case
literal|0xb
case|:
return|return
literal|72
return|;
case|case
literal|0x1
case|:
return|return
literal|96
return|;
case|case
literal|0x3
case|:
return|return
literal|108
return|;
case|case
literal|10
case|:
return|return
literal|2
return|;
case|case
literal|20
case|:
return|return
literal|4
return|;
case|case
literal|55
case|:
return|return
literal|11
return|;
case|case
literal|110
case|:
return|return
literal|22
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Quickly determine if a given rate is CCK or OFDM. */
end_comment

begin_define
define|#
directive|define
name|WPI_RATE_IS_OFDM
parameter_list|(
name|rate
parameter_list|)
value|((rate)>= 12&& (rate) != 22)
end_define

begin_function
specifier|static
name|void
name|wpi_rx_done
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|wpi_rx_desc
modifier|*
name|desc
parameter_list|,
name|struct
name|wpi_rx_data
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
specifier|const
name|struct
name|ieee80211_cipher
modifier|*
name|cip
init|=
name|NULL
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|wpi_rx_ring
modifier|*
name|ring
init|=
operator|&
name|sc
operator|->
name|rxq
decl_stmt|;
name|struct
name|wpi_rx_stat
modifier|*
name|stat
decl_stmt|;
name|struct
name|wpi_rx_head
modifier|*
name|head
decl_stmt|;
name|struct
name|wpi_rx_tail
modifier|*
name|tail
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|m1
decl_stmt|;
name|bus_addr_t
name|paddr
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|uint16_t
name|len
decl_stmt|;
name|int
name|error
decl_stmt|;
name|stat
operator|=
operator|(
expr|struct
name|wpi_rx_stat
operator|*
operator|)
operator|(
name|desc
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|stat
operator|->
name|len
operator|>
name|WPI_STAT_MAXLEN
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"invalid RX statistic header\n"
argument_list|)
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_IERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|head
operator|=
operator|(
expr|struct
name|wpi_rx_head
operator|*
operator|)
operator|(
call|(
name|caddr_t
call|)
argument_list|(
name|stat
operator|+
literal|1
argument_list|)
operator|+
name|stat
operator|->
name|len
operator|)
expr_stmt|;
name|len
operator|=
name|le16toh
argument_list|(
name|head
operator|->
name|len
argument_list|)
expr_stmt|;
name|tail
operator|=
operator|(
expr|struct
name|wpi_rx_tail
operator|*
operator|)
operator|(
call|(
name|caddr_t
call|)
argument_list|(
name|head
operator|+
literal|1
argument_list|)
operator|+
name|len
operator|)
expr_stmt|;
name|flags
operator|=
name|le32toh
argument_list|(
name|tail
operator|->
name|flags
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_RECV
argument_list|,
literal|"%s: idx %d len %d stat len %u rssi %d"
literal|" rate %x chan %d tstamp %ju\n"
argument_list|,
name|__func__
argument_list|,
name|ring
operator|->
name|cur
argument_list|,
name|le32toh
argument_list|(
name|desc
operator|->
name|len
argument_list|)
argument_list|,
name|len
argument_list|,
operator|(
name|int8_t
operator|)
name|stat
operator|->
name|rssi
argument_list|,
name|head
operator|->
name|plcp
argument_list|,
name|head
operator|->
name|chan
argument_list|,
operator|(
name|uintmax_t
operator|)
name|le64toh
argument_list|(
name|tail
operator|->
name|tstamp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Discard frames with a bad FCS early. */
if|if
condition|(
operator|(
name|flags
operator|&
name|WPI_RX_NOERROR
operator|)
operator|!=
name|WPI_RX_NOERROR
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_RECV
argument_list|,
literal|"%s: RX flags error %x\n"
argument_list|,
name|__func__
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_IERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Discard frames that are too short. */
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|wh
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_RECV
argument_list|,
literal|"%s: frame too short: %d\n"
argument_list|,
name|__func__
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_IERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|m1
operator|=
name|m_getjcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|,
name|MJUMPAGESIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|m1
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_ANY
argument_list|,
literal|"%s: no mbuf to restock ring\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_IERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|bus_dmamap_unload
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|mtod
argument_list|(
name|m1
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
name|MJUMPAGESIZE
argument_list|,
name|wpi_dma_map_addr
argument_list|,
operator|&
name|paddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|EFBIG
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: bus_dmamap_load failed, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m1
argument_list|)
expr_stmt|;
comment|/* Try to reload the old mbuf. */
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|mtod
argument_list|(
name|data
operator|->
name|m
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
name|MJUMPAGESIZE
argument_list|,
name|wpi_dma_map_addr
argument_list|,
operator|&
name|paddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|EFBIG
condition|)
block|{
name|panic
argument_list|(
literal|"%s: could not load old RX mbuf"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
comment|/* Physical address may have changed. */
name|ring
operator|->
name|desc
index|[
name|ring
operator|->
name|cur
index|]
operator|=
name|htole32
argument_list|(
name|paddr
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|ring
operator|->
name|desc_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_IERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|m
operator|=
name|data
operator|->
name|m
expr_stmt|;
name|data
operator|->
name|m
operator|=
name|m1
expr_stmt|;
comment|/* Update RX descriptor. */
name|ring
operator|->
name|desc
index|[
name|ring
operator|->
name|cur
index|]
operator|=
name|htole32
argument_list|(
name|paddr
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|desc_dma
operator|.
name|tag
argument_list|,
name|ring
operator|->
name|desc_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* Finalize mbuf. */
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_data
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|head
operator|+
literal|1
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
comment|/* Grab a reference to the source node. */
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|ni
operator|=
name|ieee80211_find_rxnode
argument_list|(
name|ic
argument_list|,
operator|(
expr|struct
name|ieee80211_frame_min
operator|*
operator|)
name|wh
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
name|cip
operator|=
name|ni
operator|->
name|ni_ucastkey
operator|.
name|wk_cipher
expr_stmt|;
if|if
condition|(
operator|(
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_PROTECTED
operator|)
operator|&&
operator|!
name|IEEE80211_IS_MULTICAST
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
operator|&&
name|cip
operator|!=
name|NULL
operator|&&
name|cip
operator|->
name|ic_cipher
operator|==
name|IEEE80211_CIPHER_AES_CCM
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|WPI_RX_CIPHER_MASK
operator|)
operator|!=
name|WPI_RX_CIPHER_CCMP
condition|)
block|{
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_IERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Check whether decryption was successful or not. */
if|if
condition|(
operator|(
name|flags
operator|&
name|WPI_RX_DECRYPT_MASK
operator|)
operator|!=
name|WPI_RX_DECRYPT_OK
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_RECV
argument_list|,
literal|"CCMP decryption failed 0x%x\n"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_IERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|m
operator|->
name|m_flags
operator||=
name|M_WEP
expr_stmt|;
block|}
if|if
condition|(
name|ieee80211_radiotap_active
argument_list|(
name|ic
argument_list|)
condition|)
block|{
name|struct
name|wpi_rx_radiotap_header
modifier|*
name|tap
init|=
operator|&
name|sc
operator|->
name|sc_rxtap
decl_stmt|;
name|tap
operator|->
name|wr_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|head
operator|->
name|flags
operator|&
name|htole16
argument_list|(
name|WPI_STAT_FLAG_SHPREAMBLE
argument_list|)
condition|)
name|tap
operator|->
name|wr_flags
operator||=
name|IEEE80211_RADIOTAP_F_SHORTPRE
expr_stmt|;
name|tap
operator|->
name|wr_dbm_antsignal
operator|=
call|(
name|int8_t
call|)
argument_list|(
name|stat
operator|->
name|rssi
operator|-
name|WPI_RSSI_OFFSET
argument_list|)
expr_stmt|;
name|tap
operator|->
name|wr_dbm_antnoise
operator|=
operator|(
name|int8_t
operator|)
name|le16toh
argument_list|(
name|stat
operator|->
name|noise
argument_list|)
expr_stmt|;
name|tap
operator|->
name|wr_tsft
operator|=
name|tail
operator|->
name|tstamp
expr_stmt|;
name|tap
operator|->
name|wr_antenna
operator|=
operator|(
name|le16toh
argument_list|(
name|head
operator|->
name|flags
argument_list|)
operator|>>
literal|4
operator|)
operator|&
literal|0xf
expr_stmt|;
name|tap
operator|->
name|wr_rate
operator|=
name|plcp2rate
argument_list|(
name|head
operator|->
name|plcp
argument_list|)
expr_stmt|;
block|}
name|WPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Send the frame to the 802.11 layer. */
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|ieee80211_input
argument_list|(
name|ni
argument_list|,
name|m
argument_list|,
name|stat
operator|->
name|rssi
argument_list|,
operator|-
name|WPI_RSSI_OFFSET
argument_list|)
expr_stmt|;
comment|/* Node is no longer needed. */
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|ieee80211_input_all
argument_list|(
name|ic
argument_list|,
name|m
argument_list|,
name|stat
operator|->
name|rssi
argument_list|,
operator|-
name|WPI_RSSI_OFFSET
argument_list|)
expr_stmt|;
name|WPI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_rx_statistics
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|wpi_rx_desc
modifier|*
name|desc
parameter_list|,
name|struct
name|wpi_rx_data
modifier|*
name|data
parameter_list|)
block|{
comment|/* Ignore */
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_tx_done
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|wpi_rx_desc
modifier|*
name|desc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|wpi_tx_ring
modifier|*
name|ring
init|=
operator|&
name|sc
operator|->
name|txq
index|[
name|desc
operator|->
name|qid
operator|&
literal|0x3
index|]
decl_stmt|;
name|struct
name|wpi_tx_data
modifier|*
name|data
init|=
operator|&
name|ring
operator|->
name|data
index|[
name|desc
operator|->
name|idx
index|]
decl_stmt|;
name|struct
name|wpi_tx_stat
modifier|*
name|stat
init|=
operator|(
expr|struct
name|wpi_tx_stat
operator|*
operator|)
operator|(
name|desc
operator|+
literal|1
operator|)
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
name|int
name|status
init|=
name|le32toh
argument_list|(
name|stat
operator|->
name|status
argument_list|)
decl_stmt|;
name|KASSERT
argument_list|(
name|data
operator|->
name|ni
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no node"
operator|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_BEGIN
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_XMIT
argument_list|,
literal|"%s: "
literal|"qid %d idx %d retries %d btkillcnt %d rate %x duration %d "
literal|"status %x\n"
argument_list|,
name|__func__
argument_list|,
name|desc
operator|->
name|qid
argument_list|,
name|desc
operator|->
name|idx
argument_list|,
name|stat
operator|->
name|ackfailcnt
argument_list|,
name|stat
operator|->
name|btkillcnt
argument_list|,
name|stat
operator|->
name|rate
argument_list|,
name|le32toh
argument_list|(
name|stat
operator|->
name|duration
argument_list|)
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* Unmap and free mbuf. */
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
name|m
operator|=
name|data
operator|->
name|m
operator|,
name|data
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
name|ni
operator|=
name|data
operator|->
name|ni
operator|,
name|data
operator|->
name|ni
operator|=
name|NULL
expr_stmt|;
name|vap
operator|=
name|ni
operator|->
name|ni_vap
expr_stmt|;
comment|/* 	 * Update rate control statistics for the node. 	 */
name|WPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
literal|0xff
operator|)
operator|!=
literal|1
condition|)
block|{
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ieee80211_ratectl_tx_complete
argument_list|(
name|vap
argument_list|,
name|ni
argument_list|,
name|IEEE80211_RATECTL_TX_FAILURE
argument_list|,
operator|&
name|stat
operator|->
name|ackfailcnt
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OPACKETS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ieee80211_ratectl_tx_complete
argument_list|(
name|vap
argument_list|,
name|ni
argument_list|,
name|IEEE80211_RATECTL_TX_SUCCESS
argument_list|,
operator|&
name|stat
operator|->
name|ackfailcnt
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|ieee80211_tx_complete
argument_list|(
name|ni
argument_list|,
name|m
argument_list|,
operator|(
name|status
operator|&
literal|0xff
operator|)
operator|!=
literal|1
argument_list|)
expr_stmt|;
name|WPI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tx_timer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|--
name|ring
operator|->
name|queued
operator|<
name|WPI_TX_RING_LOMARK
condition|)
block|{
name|sc
operator|->
name|qfullmsk
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|ring
operator|->
name|qid
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|qfullmsk
operator|==
literal|0
operator|&&
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_OACTIVE
operator|)
condition|)
block|{
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|wpi_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_END
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process a "command done" firmware notification.  This is where we wakeup  * processes waiting for a synchronous command completion.  */
end_comment

begin_function
specifier|static
name|void
name|wpi_cmd_done
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|wpi_rx_desc
modifier|*
name|desc
parameter_list|)
block|{
name|struct
name|wpi_tx_ring
modifier|*
name|ring
init|=
operator|&
name|sc
operator|->
name|txq
index|[
literal|4
index|]
decl_stmt|;
name|struct
name|wpi_tx_data
modifier|*
name|data
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_CMD
argument_list|,
literal|"cmd notification qid=%x idx=%d flags=%x "
literal|"type=%s len=%d\n"
argument_list|,
name|desc
operator|->
name|qid
argument_list|,
name|desc
operator|->
name|idx
argument_list|,
name|desc
operator|->
name|flags
argument_list|,
name|wpi_cmd_str
argument_list|(
name|desc
operator|->
name|type
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|desc
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|desc
operator|->
name|qid
operator|&
literal|7
operator|)
operator|!=
literal|4
condition|)
return|return;
comment|/* Not a command ack. */
name|data
operator|=
operator|&
name|ring
operator|->
name|data
index|[
name|desc
operator|->
name|idx
index|]
expr_stmt|;
comment|/* If the command was mapped in an mbuf, free it. */
if|if
condition|(
name|data
operator|->
name|m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|data
operator|->
name|m
argument_list|)
expr_stmt|;
name|data
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
block|}
name|sc
operator|->
name|flags
operator|&=
operator|~
name|WPI_FLAG_BUSY
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|ring
operator|->
name|cmd
index|[
name|desc
operator|->
name|idx
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_notif_intr
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
decl_stmt|;
name|int
name|hw
decl_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|shared_dma
operator|.
name|tag
argument_list|,
name|sc
operator|->
name|shared_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|hw
operator|=
name|le32toh
argument_list|(
name|sc
operator|->
name|shared
operator|->
name|next
argument_list|)
expr_stmt|;
name|hw
operator|=
operator|(
name|hw
operator|==
literal|0
operator|)
condition|?
name|WPI_RX_RING_COUNT
operator|-
literal|1
else|:
name|hw
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rxq
operator|.
name|cur
operator|==
name|hw
condition|)
return|return;
do|do
block|{
name|sc
operator|->
name|rxq
operator|.
name|cur
operator|=
operator|(
name|sc
operator|->
name|rxq
operator|.
name|cur
operator|+
literal|1
operator|)
operator|%
name|WPI_RX_RING_COUNT
expr_stmt|;
name|struct
name|wpi_rx_data
modifier|*
name|data
init|=
operator|&
name|sc
operator|->
name|rxq
operator|.
name|data
index|[
name|sc
operator|->
name|rxq
operator|.
name|cur
index|]
decl_stmt|;
name|struct
name|wpi_rx_desc
modifier|*
name|desc
decl_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rxq
operator|.
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|desc
operator|=
name|mtod
argument_list|(
name|data
operator|->
name|m
argument_list|,
expr|struct
name|wpi_rx_desc
operator|*
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_NOTIFY
argument_list|,
literal|"%s: cur=%d; qid %x idx %d flags %x type %d(%s) len %d\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|rxq
operator|.
name|cur
argument_list|,
name|desc
operator|->
name|qid
argument_list|,
name|desc
operator|->
name|idx
argument_list|,
name|desc
operator|->
name|flags
argument_list|,
name|desc
operator|->
name|type
argument_list|,
name|wpi_cmd_str
argument_list|(
name|desc
operator|->
name|type
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|desc
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|desc
operator|->
name|qid
operator|&
literal|0x80
operator|)
condition|)
comment|/* Reply to a command. */
name|wpi_cmd_done
argument_list|(
name|sc
argument_list|,
name|desc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|desc
operator|->
name|type
condition|)
block|{
case|case
name|WPI_RX_DONE
case|:
comment|/* An 802.11 frame has been received. */
name|wpi_rx_done
argument_list|(
name|sc
argument_list|,
name|desc
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|WPI_TX_DONE
case|:
comment|/* An 802.11 frame has been transmitted. */
name|wpi_tx_done
argument_list|(
name|sc
argument_list|,
name|desc
argument_list|)
expr_stmt|;
break|break;
case|case
name|WPI_RX_STATISTICS
case|:
case|case
name|WPI_BEACON_STATISTICS
case|:
name|wpi_rx_statistics
argument_list|(
name|sc
argument_list|,
name|desc
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|WPI_BEACON_MISSED
case|:
block|{
name|struct
name|wpi_beacon_missed
modifier|*
name|miss
init|=
operator|(
expr|struct
name|wpi_beacon_missed
operator|*
operator|)
operator|(
name|desc
operator|+
literal|1
operator|)
decl_stmt|;
name|int
name|misses
decl_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rxq
operator|.
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|misses
operator|=
name|le32toh
argument_list|(
name|miss
operator|->
name|consecutive
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_STATE
argument_list|,
literal|"%s: beacons missed %d/%d\n"
argument_list|,
name|__func__
argument_list|,
name|misses
argument_list|,
name|le32toh
argument_list|(
name|miss
operator|->
name|total
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_RUN
operator|&&
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_S_SCAN
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|misses
operator|>=
name|vap
operator|->
name|iv_bmissthreshold
condition|)
block|{
name|WPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ieee80211_beacon_miss
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|WPI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|WPI_UC_READY
case|:
block|{
name|struct
name|wpi_ucode_info
modifier|*
name|uc
init|=
operator|(
expr|struct
name|wpi_ucode_info
operator|*
operator|)
operator|(
name|desc
operator|+
literal|1
operator|)
decl_stmt|;
comment|/* The microcontroller is ready. */
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rxq
operator|.
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_RESET
argument_list|,
literal|"microcode alive notification version=%d.%d "
literal|"subtype=%x alive=%x\n"
argument_list|,
name|uc
operator|->
name|major
argument_list|,
name|uc
operator|->
name|minor
argument_list|,
name|uc
operator|->
name|subtype
argument_list|,
name|le32toh
argument_list|(
name|uc
operator|->
name|valid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|le32toh
argument_list|(
name|uc
operator|->
name|valid
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"microcontroller initialization failed\n"
argument_list|)
expr_stmt|;
name|wpi_stop_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* Save the address of the error log in SRAM. */
name|sc
operator|->
name|errptr
operator|=
name|le32toh
argument_list|(
name|uc
operator|->
name|errptr
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|WPI_STATE_CHANGED
case|:
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rxq
operator|.
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|uint32_t
modifier|*
name|status
init|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|desc
operator|+
literal|1
operator|)
decl_stmt|;
ifdef|#
directive|ifdef
name|WPI_DEBUG
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_STATE
argument_list|,
literal|"state changed to %x\n"
argument_list|,
name|le32toh
argument_list|(
operator|*
name|status
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|le32toh
argument_list|(
operator|*
name|status
argument_list|)
operator|&
literal|1
condition|)
block|{
name|ieee80211_runtask
argument_list|(
name|ic
argument_list|,
operator|&
name|sc
operator|->
name|sc_radiooff_task
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
block|}
case|case
name|WPI_START_SCAN
case|:
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rxq
operator|.
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WPI_DEBUG
name|struct
name|wpi_start_scan
modifier|*
name|scan
init|=
operator|(
expr|struct
name|wpi_start_scan
operator|*
operator|)
operator|(
name|desc
operator|+
literal|1
operator|)
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_SCAN
argument_list|,
literal|"%s: scanning channel %d status %x\n"
argument_list|,
name|__func__
argument_list|,
name|scan
operator|->
name|chan
argument_list|,
name|le32toh
argument_list|(
name|scan
operator|->
name|status
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
case|case
name|WPI_STOP_SCAN
case|:
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rxq
operator|.
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WPI_DEBUG
name|struct
name|wpi_stop_scan
modifier|*
name|scan
init|=
operator|(
expr|struct
name|wpi_stop_scan
operator|*
operator|)
operator|(
name|desc
operator|+
literal|1
operator|)
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_SCAN
argument_list|,
literal|"scan finished nchan=%d status=%d chan=%d\n"
argument_list|,
name|scan
operator|->
name|nchan
argument_list|,
name|scan
operator|->
name|status
argument_list|,
name|scan
operator|->
name|chan
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|sc_scan_timer
operator|=
literal|0
expr_stmt|;
name|WPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ieee80211_scan_next
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|WPI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
do|while
condition|(
name|sc
operator|->
name|rxq
operator|.
name|cur
operator|!=
name|hw
condition|)
do|;
comment|/* Tell the firmware what we have processed. */
name|wpi_update_rx_ring
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process an INT_WAKEUP interrupt raised when the microcontroller wakes up  * from power-down sleep mode.  */
end_comment

begin_function
specifier|static
name|void
name|wpi_wakeup_intr
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|qid
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_PWRSAVE
argument_list|,
literal|"%s: ucode wakeup from power-down sleep\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Wakeup RX and TX rings. */
if|if
condition|(
name|sc
operator|->
name|rxq
operator|.
name|update
condition|)
block|{
name|wpi_update_rx_ring
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rxq
operator|.
name|update
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|qid
operator|=
literal|0
init|;
name|qid
operator|<
name|WPI_NTXQUEUES
condition|;
name|qid
operator|++
control|)
block|{
name|struct
name|wpi_tx_ring
modifier|*
name|ring
init|=
operator|&
name|sc
operator|->
name|txq
index|[
name|qid
index|]
decl_stmt|;
if|if
condition|(
name|ring
operator|->
name|update
condition|)
block|{
name|wpi_update_tx_ring
argument_list|(
name|sc
argument_list|,
name|ring
argument_list|)
expr_stmt|;
name|ring
operator|->
name|update
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|WPI_CLRBITS
argument_list|(
name|sc
argument_list|,
name|WPI_GP_CNTRL
argument_list|,
name|WPI_GP_CNTRL_MAC_ACCESS_REQ
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dump the error log of the firmware when a firmware panic occurs.  Although  * we can't debug the firmware because it is neither open source nor free, it  * can help us to identify certain classes of problems.  */
end_comment

begin_function
specifier|static
name|void
name|wpi_fatal_intr
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|wpi_fw_dump
name|dump
decl_stmt|;
name|uint32_t
name|i
decl_stmt|,
name|offset
decl_stmt|,
name|count
decl_stmt|;
specifier|const
name|uint32_t
name|size_errmsg
init|=
operator|(
sizeof|sizeof
argument_list|(
name|wpi_fw_errmsg
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|(
name|wpi_fw_errmsg
operator|)
index|[
literal|0
index|]
argument_list|)
operator|)
decl_stmt|;
comment|/* Check that the error log address is valid. */
if|if
condition|(
name|sc
operator|->
name|errptr
operator|<
name|WPI_FW_DATA_BASE
operator|||
name|sc
operator|->
name|errptr
operator|+
sizeof|sizeof
argument_list|(
name|dump
argument_list|)
operator|>
name|WPI_FW_DATA_BASE
operator|+
name|WPI_FW_DATA_MAXSZ
condition|)
block|{
name|printf
argument_list|(
literal|"%s: bad firmware error log address 0x%08x\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|errptr
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|wpi_nic_lock
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: could not read firmware error log\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Read number of entries in the log. */
name|count
operator|=
name|wpi_mem_read
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|errptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
operator|||
name|count
operator|*
sizeof|sizeof
argument_list|(
name|dump
argument_list|)
operator|>
name|WPI_FW_DATA_MAXSZ
condition|)
block|{
name|printf
argument_list|(
literal|"%s: invalid count field (count = %u)\n"
argument_list|,
name|__func__
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|wpi_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Skip "count" field. */
name|offset
operator|=
name|sc
operator|->
name|errptr
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"firmware error log (count = %u):\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|wpi_mem_read_region_4
argument_list|(
name|sc
argument_list|,
name|offset
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|dump
argument_list|,
sizeof|sizeof
argument_list|(
name|dump
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  error type = \"%s\" (0x%08X)\n"
argument_list|,
operator|(
name|dump
operator|.
name|desc
operator|<
name|size_errmsg
operator|)
condition|?
name|wpi_fw_errmsg
index|[
name|dump
operator|.
name|desc
index|]
else|:
literal|"UNKNOWN"
argument_list|,
name|dump
operator|.
name|desc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  error data      = 0x%08X\n"
argument_list|,
name|dump
operator|.
name|data
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  branch link     = 0x%08X%08X\n"
argument_list|,
name|dump
operator|.
name|blink
index|[
literal|0
index|]
argument_list|,
name|dump
operator|.
name|blink
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  interrupt link  = 0x%08X%08X\n"
argument_list|,
name|dump
operator|.
name|ilink
index|[
literal|0
index|]
argument_list|,
name|dump
operator|.
name|ilink
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  time            = %u\n"
argument_list|,
name|dump
operator|.
name|time
argument_list|)
expr_stmt|;
name|offset
operator|+=
sizeof|sizeof
argument_list|(
name|dump
argument_list|)
expr_stmt|;
block|}
name|wpi_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Dump driver status (TX and RX rings) while we're here. */
name|printf
argument_list|(
literal|"driver status:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|WPI_NTXQUEUES
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|wpi_tx_ring
modifier|*
name|ring
init|=
operator|&
name|sc
operator|->
name|txq
index|[
name|i
index|]
decl_stmt|;
name|printf
argument_list|(
literal|"  tx ring %2d: qid=%-2d cur=%-3d queued=%-3d\n"
argument_list|,
name|i
argument_list|,
name|ring
operator|->
name|qid
argument_list|,
name|ring
operator|->
name|cur
argument_list|,
name|ring
operator|->
name|queued
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  rx ring: cur=%d\n"
argument_list|,
name|sc
operator|->
name|rxq
operator|.
name|cur
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|wpi_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|uint32_t
name|r1
decl_stmt|,
name|r2
decl_stmt|;
name|WPI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Disable interrupts. */
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_INT_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|r1
operator|=
name|WPI_READ
argument_list|(
name|sc
argument_list|,
name|WPI_INT
argument_list|)
expr_stmt|;
if|if
condition|(
name|r1
operator|==
literal|0xffffffff
operator|||
operator|(
name|r1
operator|&
literal|0xfffffff0
operator|)
operator|==
literal|0xa5a5a5a0
condition|)
block|{
name|WPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
comment|/* Hardware gone! */
block|}
name|r2
operator|=
name|WPI_READ
argument_list|(
name|sc
argument_list|,
name|WPI_FH_INT
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_INTR
argument_list|,
literal|"%s: reg1=0x%08x reg2=0x%08x\n"
argument_list|,
name|__func__
argument_list|,
name|r1
argument_list|,
name|r2
argument_list|)
expr_stmt|;
if|if
condition|(
name|r1
operator|==
literal|0
operator|&&
name|r2
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* Interrupt not for us. */
comment|/* Acknowledge interrupts. */
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_INT
argument_list|,
name|r1
argument_list|)
expr_stmt|;
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_FH_INT
argument_list|,
name|r2
argument_list|)
expr_stmt|;
if|if
condition|(
name|r1
operator|&
operator|(
name|WPI_INT_SW_ERR
operator||
name|WPI_INT_HW_ERR
operator|)
condition|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"fatal firmware error\n"
argument_list|)
expr_stmt|;
name|wpi_fatal_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_HW
argument_list|,
literal|"(%s)\n"
argument_list|,
operator|(
name|r1
operator|&
name|WPI_INT_SW_ERR
operator|)
condition|?
literal|"(Software Error)"
else|:
literal|"(Hardware Error)"
argument_list|)
expr_stmt|;
name|ieee80211_runtask
argument_list|(
name|ic
argument_list|,
operator|&
name|sc
operator|->
name|sc_reinittask
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator|&=
operator|~
name|WPI_FLAG_BUSY
expr_stmt|;
name|WPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|r1
operator|&
operator|(
name|WPI_INT_FH_RX
operator||
name|WPI_INT_SW_RX
operator|)
operator|)
operator|||
operator|(
name|r2
operator|&
name|WPI_FH_INT_RX
operator|)
condition|)
name|wpi_notif_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|r1
operator|&
name|WPI_INT_ALIVE
condition|)
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Firmware is alive. */
if|if
condition|(
name|r1
operator|&
name|WPI_INT_WAKEUP
condition|)
name|wpi_wakeup_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|done
label|:
comment|/* Re-enable interrupts. */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_INT_MASK
argument_list|,
name|WPI_INT_MASK_DEF
argument_list|)
expr_stmt|;
name|WPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|wpi_cmd2
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|wpi_buf
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|struct
name|wpi_tx_cmd
modifier|*
name|cmd
decl_stmt|;
name|struct
name|wpi_tx_data
modifier|*
name|data
decl_stmt|;
name|struct
name|wpi_tx_desc
modifier|*
name|desc
decl_stmt|;
name|struct
name|wpi_tx_ring
modifier|*
name|ring
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m1
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|seg
decl_stmt|,
name|segs
index|[
name|WPI_MAX_SCATTER
index|]
decl_stmt|;
name|u_int
name|hdrlen
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|nsegs
decl_stmt|,
name|pad
decl_stmt|,
name|totlen
decl_stmt|;
name|WPI_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_BEGIN
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|buf
operator|->
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|hdrlen
operator|=
name|ieee80211_anyhdrsize
argument_list|(
name|wh
argument_list|)
expr_stmt|;
name|totlen
operator|=
name|buf
operator|->
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|hdrlen
operator|&
literal|3
condition|)
block|{
comment|/* First segment length must be a multiple of 4. */
name|pad
operator|=
literal|4
operator|-
operator|(
name|hdrlen
operator|&
literal|3
operator|)
expr_stmt|;
block|}
else|else
name|pad
operator|=
literal|0
expr_stmt|;
name|ring
operator|=
operator|&
name|sc
operator|->
name|txq
index|[
name|buf
operator|->
name|ac
index|]
expr_stmt|;
name|desc
operator|=
operator|&
name|ring
operator|->
name|desc
index|[
name|ring
operator|->
name|cur
index|]
expr_stmt|;
name|data
operator|=
operator|&
name|ring
operator|->
name|data
index|[
name|ring
operator|->
name|cur
index|]
expr_stmt|;
comment|/* Prepare TX firmware command. */
name|cmd
operator|=
operator|&
name|ring
operator|->
name|cmd
index|[
name|ring
operator|->
name|cur
index|]
expr_stmt|;
name|cmd
operator|->
name|code
operator|=
name|buf
operator|->
name|code
expr_stmt|;
name|cmd
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|qid
operator|=
name|ring
operator|->
name|qid
expr_stmt|;
name|cmd
operator|->
name|idx
operator|=
name|ring
operator|->
name|cur
expr_stmt|;
name|memcpy
argument_list|(
name|cmd
operator|->
name|data
argument_list|,
name|buf
operator|->
name|data
argument_list|,
name|buf
operator|->
name|size
argument_list|)
expr_stmt|;
comment|/* Save and trim IEEE802.11 header. */
name|memcpy
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|cmd
operator|->
name|data
operator|+
name|buf
operator|->
name|size
operator|)
argument_list|,
name|wh
argument_list|,
name|hdrlen
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|buf
operator|->
name|m
argument_list|,
name|hdrlen
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|buf
operator|->
name|m
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|EFBIG
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: can't map mbuf (error %d)\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|buf
operator|->
name|m
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* Too many DMA segments, linearize mbuf. */
name|m1
operator|=
name|m_collapse
argument_list|(
name|buf
operator|->
name|m
argument_list|,
name|M_NOWAIT
argument_list|,
name|WPI_MAX_SCATTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|m1
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not defrag mbuf\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|buf
operator|->
name|m
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
name|buf
operator|->
name|m
operator|=
name|m1
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|buf
operator|->
name|m
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: can't map mbuf (error %d)\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|buf
operator|->
name|m
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
name|data
operator|->
name|m
operator|=
name|buf
operator|->
name|m
expr_stmt|;
name|data
operator|->
name|ni
operator|=
name|buf
operator|->
name|ni
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_XMIT
argument_list|,
literal|"%s: qid %d idx %d len %d nsegs %d\n"
argument_list|,
name|__func__
argument_list|,
name|ring
operator|->
name|qid
argument_list|,
name|ring
operator|->
name|cur
argument_list|,
name|totlen
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
comment|/* Fill TX descriptor. */
name|desc
operator|->
name|nsegs
operator|=
name|WPI_PAD32
argument_list|(
name|totlen
operator|+
name|pad
argument_list|)
operator|<<
literal|4
operator||
operator|(
literal|1
operator|+
name|nsegs
operator|)
expr_stmt|;
comment|/* First DMA segment is used by the TX command. */
name|desc
operator|->
name|segs
index|[
literal|0
index|]
operator|.
name|addr
operator|=
name|htole32
argument_list|(
name|data
operator|->
name|cmd_paddr
argument_list|)
expr_stmt|;
name|desc
operator|->
name|segs
index|[
literal|0
index|]
operator|.
name|len
operator|=
name|htole32
argument_list|(
literal|4
operator|+
name|buf
operator|->
name|size
operator|+
name|hdrlen
operator|+
name|pad
argument_list|)
expr_stmt|;
comment|/* Other DMA segments are for data payload. */
name|seg
operator|=
operator|&
name|segs
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nsegs
condition|;
name|i
operator|++
control|)
block|{
name|desc
operator|->
name|segs
index|[
name|i
index|]
operator|.
name|addr
operator|=
name|htole32
argument_list|(
name|seg
operator|->
name|ds_addr
argument_list|)
expr_stmt|;
name|desc
operator|->
name|segs
index|[
name|i
index|]
operator|.
name|len
operator|=
name|htole32
argument_list|(
name|seg
operator|->
name|ds_len
argument_list|)
expr_stmt|;
name|seg
operator|++
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|ring
operator|->
name|cmd_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|desc_dma
operator|.
name|tag
argument_list|,
name|ring
operator|->
name|desc_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* Kick TX ring. */
name|ring
operator|->
name|cur
operator|=
operator|(
name|ring
operator|->
name|cur
operator|+
literal|1
operator|)
operator|%
name|WPI_TX_RING_COUNT
expr_stmt|;
name|wpi_update_tx_ring
argument_list|(
name|sc
argument_list|,
name|ring
argument_list|)
expr_stmt|;
comment|/* Mark TX ring as full if we reach a certain threshold. */
if|if
condition|(
operator|++
name|ring
operator|->
name|queued
operator|>
name|WPI_TX_RING_HIMARK
condition|)
name|sc
operator|->
name|qfullmsk
operator||=
literal|1
operator|<<
name|ring
operator|->
name|qid
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_END
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Construct the data packet for a transmit buffer.  */
end_comment

begin_function
specifier|static
name|int
name|wpi_tx_data
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
specifier|const
name|struct
name|ieee80211_txparam
modifier|*
name|tp
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|wpi_node
modifier|*
name|wn
init|=
operator|(
name|void
operator|*
operator|)
name|ni
decl_stmt|;
name|struct
name|ieee80211_channel
modifier|*
name|chan
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|struct
name|ieee80211_key
modifier|*
name|k
init|=
name|NULL
decl_stmt|;
name|struct
name|wpi_cmd_data
name|tx
decl_stmt|;
name|struct
name|wpi_buf
name|tx_data
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|uint16_t
name|qos
decl_stmt|;
name|uint8_t
name|tid
decl_stmt|,
name|type
decl_stmt|;
name|int
name|ac
decl_stmt|,
name|error
decl_stmt|,
name|rate
decl_stmt|,
name|ismcast
decl_stmt|,
name|totlen
decl_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|type
operator|=
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_TYPE_MASK
expr_stmt|;
name|ismcast
operator|=
name|IEEE80211_IS_MULTICAST
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
expr_stmt|;
comment|/* Select EDCA Access Category and TX ring for this frame. */
if|if
condition|(
name|IEEE80211_QOS_HAS_SEQ
argument_list|(
name|wh
argument_list|)
condition|)
block|{
name|qos
operator|=
operator|(
operator|(
specifier|const
expr|struct
name|ieee80211_qosframe
operator|*
operator|)
name|wh
operator|)
operator|->
name|i_qos
index|[
literal|0
index|]
expr_stmt|;
name|tid
operator|=
name|qos
operator|&
name|IEEE80211_QOS_TID
expr_stmt|;
block|}
else|else
block|{
name|qos
operator|=
literal|0
expr_stmt|;
name|tid
operator|=
literal|0
expr_stmt|;
block|}
name|ac
operator|=
name|M_WME_GETAC
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|chan
operator|=
operator|(
name|ni
operator|->
name|ni_chan
operator|!=
name|IEEE80211_CHAN_ANYC
operator|)
condition|?
name|ni
operator|->
name|ni_chan
else|:
name|ic
operator|->
name|ic_curchan
expr_stmt|;
name|tp
operator|=
operator|&
name|vap
operator|->
name|iv_txparms
index|[
name|ieee80211_chan2mode
argument_list|(
name|chan
argument_list|)
index|]
expr_stmt|;
comment|/* Choose a TX rate index. */
if|if
condition|(
name|type
operator|==
name|IEEE80211_FC0_TYPE_MGT
condition|)
name|rate
operator|=
name|tp
operator|->
name|mgmtrate
expr_stmt|;
elseif|else
if|if
condition|(
name|ismcast
condition|)
name|rate
operator|=
name|tp
operator|->
name|mcastrate
expr_stmt|;
elseif|else
if|if
condition|(
name|tp
operator|->
name|ucastrate
operator|!=
name|IEEE80211_FIXED_RATE_NONE
condition|)
name|rate
operator|=
name|tp
operator|->
name|ucastrate
expr_stmt|;
elseif|else
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_EAPOL
condition|)
name|rate
operator|=
name|tp
operator|->
name|mgmtrate
expr_stmt|;
else|else
block|{
comment|/* XXX pass pktlen */
operator|(
name|void
operator|)
name|ieee80211_ratectl_rate
argument_list|(
name|ni
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rate
operator|=
name|ni
operator|->
name|ni_txrate
expr_stmt|;
block|}
comment|/* Encrypt the frame if need be. */
if|if
condition|(
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_PROTECTED
condition|)
block|{
comment|/* Retrieve key for TX. */
name|k
operator|=
name|ieee80211_crypto_encap
argument_list|(
name|ni
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 802.11 header may have moved. */
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
block|}
name|totlen
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|ieee80211_radiotap_active_vap
argument_list|(
name|vap
argument_list|)
condition|)
block|{
name|struct
name|wpi_tx_radiotap_header
modifier|*
name|tap
init|=
operator|&
name|sc
operator|->
name|sc_txtap
decl_stmt|;
name|tap
operator|->
name|wt_flags
operator|=
literal|0
expr_stmt|;
name|tap
operator|->
name|wt_rate
operator|=
name|rate
expr_stmt|;
if|if
condition|(
name|k
operator|!=
name|NULL
condition|)
name|tap
operator|->
name|wt_flags
operator||=
name|IEEE80211_RADIOTAP_F_WEP
expr_stmt|;
name|ieee80211_radiotap_tx
argument_list|(
name|vap
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|ismcast
condition|)
block|{
comment|/* Unicast frame, check if an ACK is expected. */
if|if
condition|(
operator|!
name|qos
operator|||
operator|(
name|qos
operator|&
name|IEEE80211_QOS_ACKPOLICY
operator|)
operator|!=
name|IEEE80211_QOS_ACKPOLICY_NOACK
condition|)
name|flags
operator||=
name|WPI_TX_NEED_ACK
expr_stmt|;
block|}
comment|/* Check if frame must be protected using RTS/CTS or CTS-to-self. */
if|if
condition|(
operator|!
name|ismcast
condition|)
block|{
comment|/* NB: Group frames are sent using CCK in 802.11b/g. */
if|if
condition|(
name|totlen
operator|+
name|IEEE80211_CRC_LEN
operator|>
name|vap
operator|->
name|iv_rtsthreshold
condition|)
block|{
name|flags
operator||=
name|WPI_TX_NEED_RTS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_USEPROT
operator|)
operator|&&
name|WPI_RATE_IS_OFDM
argument_list|(
name|rate
argument_list|)
condition|)
block|{
if|if
condition|(
name|ic
operator|->
name|ic_protmode
operator|==
name|IEEE80211_PROT_CTSONLY
condition|)
name|flags
operator||=
name|WPI_TX_NEED_CTS
expr_stmt|;
elseif|else
if|if
condition|(
name|ic
operator|->
name|ic_protmode
operator|==
name|IEEE80211_PROT_RTSCTS
condition|)
name|flags
operator||=
name|WPI_TX_NEED_RTS
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
operator|(
name|WPI_TX_NEED_RTS
operator||
name|WPI_TX_NEED_CTS
operator|)
condition|)
name|flags
operator||=
name|WPI_TX_FULL_TXOP
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|tx
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|wpi_cmd_data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|IEEE80211_FC0_TYPE_MGT
condition|)
block|{
name|uint8_t
name|subtype
init|=
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
decl_stmt|;
comment|/* Tell HW to set timestamp in probe responses. */
if|if
condition|(
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_PROBE_RESP
condition|)
name|flags
operator||=
name|WPI_TX_INSERT_TSTAMP
expr_stmt|;
if|if
condition|(
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_ASSOC_REQ
operator|||
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_REASSOC_REQ
condition|)
name|tx
operator|.
name|timeout
operator|=
name|htole16
argument_list|(
literal|3
argument_list|)
expr_stmt|;
else|else
name|tx
operator|.
name|timeout
operator|=
name|htole16
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ismcast
operator|||
name|type
operator|!=
name|IEEE80211_FC0_TYPE_DATA
condition|)
name|tx
operator|.
name|id
operator|=
name|WPI_ID_BROADCAST
expr_stmt|;
else|else
block|{
if|if
condition|(
name|wn
operator|->
name|id
operator|==
name|WPI_ID_UNDEFINED
operator|&&
operator|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_IBSS
operator|||
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_AHDEMO
operator|)
condition|)
block|{
name|error
operator|=
name|wpi_add_ibss_node
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not add IBSS node, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
if|if
condition|(
name|wn
operator|->
name|id
operator|==
name|WPI_ID_UNDEFINED
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: undefined node id\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|tx
operator|.
name|id
operator|=
name|wn
operator|->
name|id
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|!=
name|IEEE80211_FC0_TYPE_MGT
condition|)
name|tx
operator|.
name|data_ntries
operator|=
name|tp
operator|->
name|maxretry
expr_stmt|;
name|tx
operator|.
name|len
operator|=
name|htole16
argument_list|(
name|totlen
argument_list|)
expr_stmt|;
name|tx
operator|.
name|flags
operator|=
name|htole32
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|tx
operator|.
name|plcp
operator|=
name|rate2plcp
argument_list|(
name|rate
argument_list|)
expr_stmt|;
name|tx
operator|.
name|tid
operator|=
name|tid
expr_stmt|;
name|tx
operator|.
name|lifetime
operator|=
name|htole32
argument_list|(
name|WPI_LIFETIME_INFINITE
argument_list|)
expr_stmt|;
name|tx
operator|.
name|ofdm_mask
operator|=
literal|0xff
expr_stmt|;
name|tx
operator|.
name|cck_mask
operator|=
literal|0x0f
expr_stmt|;
name|tx
operator|.
name|rts_ntries
operator|=
literal|7
expr_stmt|;
if|if
condition|(
name|k
operator|!=
name|NULL
operator|&&
name|k
operator|->
name|wk_cipher
operator|->
name|ic_cipher
operator|==
name|IEEE80211_CIPHER_AES_CCM
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_SWCRYPT
operator|)
condition|)
block|{
name|tx
operator|.
name|security
operator|=
name|WPI_CIPHER_CCMP
expr_stmt|;
name|memcpy
argument_list|(
name|tx
operator|.
name|key
argument_list|,
name|k
operator|->
name|wk_key
argument_list|,
name|k
operator|->
name|wk_keylen
argument_list|)
expr_stmt|;
block|}
block|}
name|tx_data
operator|.
name|data
operator|=
operator|&
name|tx
expr_stmt|;
name|tx_data
operator|.
name|ni
operator|=
name|ni
expr_stmt|;
name|tx_data
operator|.
name|m
operator|=
name|m
expr_stmt|;
name|tx_data
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|tx_data
operator|.
name|code
operator|=
name|WPI_CMD_TX_DATA
expr_stmt|;
name|tx_data
operator|.
name|ac
operator|=
name|ac
expr_stmt|;
return|return
name|wpi_cmd2
argument_list|(
name|sc
argument_list|,
operator|&
name|tx_data
argument_list|)
return|;
name|fail
label|:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wpi_tx_data_raw
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|struct
name|ieee80211_bpf_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|struct
name|wpi_cmd_data
name|tx
decl_stmt|;
name|struct
name|wpi_buf
name|tx_data
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|uint8_t
name|type
decl_stmt|;
name|int
name|ac
decl_stmt|,
name|rate
decl_stmt|,
name|totlen
decl_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|type
operator|=
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_TYPE_MASK
expr_stmt|;
name|totlen
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|ac
operator|=
name|params
operator|->
name|ibp_pri
operator|&
literal|3
expr_stmt|;
comment|/* Choose a TX rate index. */
name|rate
operator|=
name|params
operator|->
name|ibp_rate0
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|params
operator|->
name|ibp_flags
operator|&
name|IEEE80211_BPF_NOACK
operator|)
operator|==
literal|0
condition|)
name|flags
operator||=
name|WPI_TX_NEED_ACK
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|ibp_flags
operator|&
name|IEEE80211_BPF_RTS
condition|)
name|flags
operator||=
name|WPI_TX_NEED_RTS
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|ibp_flags
operator|&
name|IEEE80211_BPF_CTS
condition|)
name|flags
operator||=
name|WPI_TX_NEED_CTS
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
name|WPI_TX_NEED_RTS
operator||
name|WPI_TX_NEED_CTS
operator|)
condition|)
name|flags
operator||=
name|WPI_TX_FULL_TXOP
expr_stmt|;
if|if
condition|(
name|ieee80211_radiotap_active_vap
argument_list|(
name|vap
argument_list|)
condition|)
block|{
name|struct
name|wpi_tx_radiotap_header
modifier|*
name|tap
init|=
operator|&
name|sc
operator|->
name|sc_txtap
decl_stmt|;
name|tap
operator|->
name|wt_flags
operator|=
literal|0
expr_stmt|;
name|tap
operator|->
name|wt_rate
operator|=
name|rate
expr_stmt|;
name|ieee80211_radiotap_tx
argument_list|(
name|vap
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|tx
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|wpi_cmd_data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|IEEE80211_FC0_TYPE_MGT
condition|)
block|{
name|uint8_t
name|subtype
init|=
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
decl_stmt|;
comment|/* Tell HW to set timestamp in probe responses. */
if|if
condition|(
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_PROBE_RESP
condition|)
name|flags
operator||=
name|WPI_TX_INSERT_TSTAMP
expr_stmt|;
if|if
condition|(
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_ASSOC_REQ
operator|||
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_REASSOC_REQ
condition|)
name|tx
operator|.
name|timeout
operator|=
name|htole16
argument_list|(
literal|3
argument_list|)
expr_stmt|;
else|else
name|tx
operator|.
name|timeout
operator|=
name|htole16
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|tx
operator|.
name|len
operator|=
name|htole16
argument_list|(
name|totlen
argument_list|)
expr_stmt|;
name|tx
operator|.
name|flags
operator|=
name|htole32
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|tx
operator|.
name|plcp
operator|=
name|rate2plcp
argument_list|(
name|rate
argument_list|)
expr_stmt|;
name|tx
operator|.
name|id
operator|=
name|WPI_ID_BROADCAST
expr_stmt|;
name|tx
operator|.
name|lifetime
operator|=
name|htole32
argument_list|(
name|WPI_LIFETIME_INFINITE
argument_list|)
expr_stmt|;
name|tx
operator|.
name|rts_ntries
operator|=
name|params
operator|->
name|ibp_try1
expr_stmt|;
name|tx
operator|.
name|data_ntries
operator|=
name|params
operator|->
name|ibp_try0
expr_stmt|;
name|tx_data
operator|.
name|data
operator|=
operator|&
name|tx
expr_stmt|;
name|tx_data
operator|.
name|ni
operator|=
name|ni
expr_stmt|;
name|tx_data
operator|.
name|m
operator|=
name|m
expr_stmt|;
name|tx_data
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|tx_data
operator|.
name|code
operator|=
name|WPI_CMD_TX_DATA
expr_stmt|;
name|tx_data
operator|.
name|ac
operator|=
name|ac
expr_stmt|;
return|return
name|wpi_cmd2
argument_list|(
name|sc
argument_list|,
operator|&
name|tx_data
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wpi_raw_xmit
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|ieee80211_bpf_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|wpi_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_BEGIN
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|ENETDOWN
return|;
block|}
name|WPI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Legacy path; interpret frame contents to decide 		 * precisely how to send the frame. 		 */
name|error
operator|=
name|wpi_tx_data
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
name|ni
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Caller supplied explicit parameters to use in 		 * sending the frame. 		 */
name|error
operator|=
name|wpi_tx_data_raw
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
name|ni
argument_list|,
name|params
argument_list|)
expr_stmt|;
block|}
name|WPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* NB: m is reclaimed on tx failure */
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_END_ERR
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|sc
operator|->
name|sc_tx_timer
operator|=
literal|5
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_END
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Process data waiting to be sent on the IFNET output queue  */
end_comment

begin_function
specifier|static
name|void
name|wpi_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|wpi_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|WPI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|wpi_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|WPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|wpi_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|WPI_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_XMIT
argument_list|,
literal|"%s: called\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
operator|||
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_OACTIVE
operator|)
condition|)
return|return;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|qfullmsk
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
break|break;
block|}
name|IFQ_DRV_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|ni
operator|=
operator|(
expr|struct
name|ieee80211_node
operator|*
operator|)
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
if|if
condition|(
name|wpi_tx_data
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
name|ni
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|WPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|WPI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|sc_tx_timer
operator|=
literal|5
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_XMIT
argument_list|,
literal|"%s: done\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_watchdog_rfkill
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|wpi_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_WATCHDOG
argument_list|,
literal|"RFkill Watchdog: tick\n"
argument_list|)
expr_stmt|;
comment|/* No need to lock firmware memory. */
if|if
condition|(
operator|(
name|wpi_prph_read
argument_list|(
name|sc
argument_list|,
name|WPI_APMG_RFKILL
argument_list|)
operator|&
literal|0x1
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Radio kill switch is still off. */
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|watchdog_rfkill
argument_list|,
name|hz
argument_list|,
name|wpi_watchdog_rfkill
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
name|ieee80211_runtask
argument_list|(
name|ic
argument_list|,
operator|&
name|sc
operator|->
name|sc_radioon_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Called every second, wpi_watchdog used by the watch dog timer  * to check that the card is still alive  */
end_comment

begin_function
specifier|static
name|void
name|wpi_watchdog
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|wpi_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_WATCHDOG
argument_list|,
literal|"Watchdog: tick\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_tx_timer
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|--
name|sc
operator|->
name|sc_tx_timer
operator|==
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"device timeout\n"
argument_list|)
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ieee80211_runtask
argument_list|(
name|ic
argument_list|,
operator|&
name|sc
operator|->
name|sc_reinittask
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|sc_scan_timer
operator|>
literal|0
condition|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
decl_stmt|;
if|if
condition|(
operator|--
name|sc
operator|->
name|sc_scan_timer
operator|==
literal|0
operator|&&
name|vap
operator|!=
name|NULL
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"scan timeout\n"
argument_list|)
expr_stmt|;
name|ieee80211_cancel_scan
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|ieee80211_runtask
argument_list|(
name|ic
argument_list|,
operator|&
name|sc
operator|->
name|sc_reinittask
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|watchdog_to
argument_list|,
name|hz
argument_list|,
name|wpi_watchdog
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|wpi_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|wpi_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|startall
init|=
literal|0
decl_stmt|,
name|stop
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCGIFADDR
case|:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
name|WPI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
name|wpi_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|WPI_READ
argument_list|(
name|sc
argument_list|,
name|WPI_GP_CNTRL
argument_list|)
operator|&
name|WPI_GP_CNTRL_RFKILL
condition|)
name|startall
operator|=
literal|1
expr_stmt|;
else|else
name|stop
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|wpi_stop_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|WPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|startall
condition|)
name|ieee80211_start_all
argument_list|(
name|ic
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|vap
operator|!=
name|NULL
operator|&&
name|stop
condition|)
name|ieee80211_stop
argument_list|(
name|vap
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCGIFMEDIA
case|:
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|ic
operator|->
name|ic_media
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Send a command to the firmware.  */
end_comment

begin_function
specifier|static
name|int
name|wpi_cmd
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|code
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|int
name|async
parameter_list|)
block|{
name|struct
name|wpi_tx_ring
modifier|*
name|ring
init|=
operator|&
name|sc
operator|->
name|txq
index|[
literal|4
index|]
decl_stmt|;
name|struct
name|wpi_tx_desc
modifier|*
name|desc
decl_stmt|;
name|struct
name|wpi_tx_data
modifier|*
name|data
decl_stmt|;
name|struct
name|wpi_tx_cmd
modifier|*
name|cmd
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|bus_addr_t
name|paddr
decl_stmt|;
name|int
name|totlen
decl_stmt|,
name|error
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_BEGIN
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|async
operator|==
literal|0
condition|)
name|WPI_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_CMD
argument_list|,
literal|"wpi_cmd %s size %zu async %d\n"
argument_list|,
name|wpi_cmd_str
argument_list|(
name|code
argument_list|)
argument_list|,
name|size
argument_list|,
name|async
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|WPI_FLAG_BUSY
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: cmd %d not sent, busy\n"
argument_list|,
name|__func__
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return
name|EAGAIN
return|;
block|}
name|sc
operator|->
name|flags
operator||=
name|WPI_FLAG_BUSY
expr_stmt|;
name|desc
operator|=
operator|&
name|ring
operator|->
name|desc
index|[
name|ring
operator|->
name|cur
index|]
expr_stmt|;
name|data
operator|=
operator|&
name|ring
operator|->
name|data
index|[
name|ring
operator|->
name|cur
index|]
expr_stmt|;
name|totlen
operator|=
literal|4
operator|+
name|size
expr_stmt|;
if|if
condition|(
name|size
operator|>
sizeof|sizeof
name|cmd
operator|->
name|data
condition|)
block|{
comment|/* Command is too large to fit in a descriptor. */
if|if
condition|(
name|totlen
operator|>
name|MCLBYTES
condition|)
return|return
name|EINVAL
return|;
name|m
operator|=
name|m_getjcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|,
name|MJUMPAGESIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|cmd
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|wpi_tx_cmd
operator|*
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|cmd
argument_list|,
name|totlen
argument_list|,
name|wpi_dma_map_addr
argument_list|,
operator|&
name|paddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|data
operator|->
name|m
operator|=
name|m
expr_stmt|;
block|}
else|else
block|{
name|cmd
operator|=
operator|&
name|ring
operator|->
name|cmd
index|[
name|ring
operator|->
name|cur
index|]
expr_stmt|;
name|paddr
operator|=
name|data
operator|->
name|cmd_paddr
expr_stmt|;
block|}
name|cmd
operator|->
name|code
operator|=
name|code
expr_stmt|;
name|cmd
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|qid
operator|=
name|ring
operator|->
name|qid
expr_stmt|;
name|cmd
operator|->
name|idx
operator|=
name|ring
operator|->
name|cur
expr_stmt|;
name|memcpy
argument_list|(
name|cmd
operator|->
name|data
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|desc
operator|->
name|nsegs
operator|=
literal|1
operator|+
operator|(
name|WPI_PAD32
argument_list|(
name|size
argument_list|)
operator|<<
literal|4
operator|)
expr_stmt|;
name|desc
operator|->
name|segs
index|[
literal|0
index|]
operator|.
name|addr
operator|=
name|htole32
argument_list|(
name|paddr
argument_list|)
expr_stmt|;
name|desc
operator|->
name|segs
index|[
literal|0
index|]
operator|.
name|len
operator|=
name|htole32
argument_list|(
name|totlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
sizeof|sizeof
name|cmd
operator|->
name|data
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|ring
operator|->
name|cmd_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|desc_dma
operator|.
name|tag
argument_list|,
name|ring
operator|->
name|desc_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* Kick command ring. */
name|ring
operator|->
name|cur
operator|=
operator|(
name|ring
operator|->
name|cur
operator|+
literal|1
operator|)
operator|%
name|WPI_TX_RING_COUNT
expr_stmt|;
name|wpi_update_tx_ring
argument_list|(
name|sc
argument_list|,
name|ring
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_END
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|async
condition|)
block|{
name|sc
operator|->
name|flags
operator|&=
operator|~
name|WPI_FLAG_BUSY
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|msleep
argument_list|(
name|cmd
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
name|PCATCH
argument_list|,
literal|"wpicmd"
argument_list|,
name|hz
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Configure HW multi-rate retries.  */
end_comment

begin_function
specifier|static
name|int
name|wpi_mrr_setup
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|wpi_mrr_setup
name|mrr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
comment|/* CCK rates (not used with 802.11a). */
for|for
control|(
name|i
operator|=
name|WPI_RIDX_CCK1
init|;
name|i
operator|<=
name|WPI_RIDX_CCK11
condition|;
name|i
operator|++
control|)
block|{
name|mrr
operator|.
name|rates
index|[
name|i
index|]
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|mrr
operator|.
name|rates
index|[
name|i
index|]
operator|.
name|plcp
operator|=
name|wpi_ridx_to_plcp
index|[
name|i
index|]
expr_stmt|;
comment|/* Fallback to the immediate lower CCK rate (if any.) */
name|mrr
operator|.
name|rates
index|[
name|i
index|]
operator|.
name|next
operator|=
operator|(
name|i
operator|==
name|WPI_RIDX_CCK1
operator|)
condition|?
name|WPI_RIDX_CCK1
else|:
name|i
operator|-
literal|1
expr_stmt|;
comment|/* Try one time at this rate before falling back to "next". */
name|mrr
operator|.
name|rates
index|[
name|i
index|]
operator|.
name|ntries
operator|=
literal|1
expr_stmt|;
block|}
comment|/* OFDM rates (not used with 802.11b). */
for|for
control|(
name|i
operator|=
name|WPI_RIDX_OFDM6
init|;
name|i
operator|<=
name|WPI_RIDX_OFDM54
condition|;
name|i
operator|++
control|)
block|{
name|mrr
operator|.
name|rates
index|[
name|i
index|]
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|mrr
operator|.
name|rates
index|[
name|i
index|]
operator|.
name|plcp
operator|=
name|wpi_ridx_to_plcp
index|[
name|i
index|]
expr_stmt|;
comment|/* Fallback to the immediate lower rate (if any.) */
comment|/* We allow fallback from OFDM/6 to CCK/2 in 11b/g mode. */
name|mrr
operator|.
name|rates
index|[
name|i
index|]
operator|.
name|next
operator|=
operator|(
name|i
operator|==
name|WPI_RIDX_OFDM6
operator|)
condition|?
operator|(
operator|(
name|ic
operator|->
name|ic_curmode
operator|==
name|IEEE80211_MODE_11A
operator|)
condition|?
name|WPI_RIDX_OFDM6
else|:
name|WPI_RIDX_CCK2
operator|)
else|:
name|i
operator|-
literal|1
expr_stmt|;
comment|/* Try one time at this rate before falling back to "next". */
name|mrr
operator|.
name|rates
index|[
name|i
index|]
operator|.
name|ntries
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Setup MRR for control frames. */
name|mrr
operator|.
name|which
operator|=
name|htole32
argument_list|(
name|WPI_MRR_CTL
argument_list|)
expr_stmt|;
name|error
operator|=
name|wpi_cmd
argument_list|(
name|sc
argument_list|,
name|WPI_CMD_MRR_SETUP
argument_list|,
operator|&
name|mrr
argument_list|,
sizeof|sizeof
name|mrr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not setup MRR for control frames\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Setup MRR for data frames. */
name|mrr
operator|.
name|which
operator|=
name|htole32
argument_list|(
name|WPI_MRR_DATA
argument_list|)
expr_stmt|;
name|error
operator|=
name|wpi_cmd
argument_list|(
name|sc
argument_list|,
name|WPI_CMD_MRR_SETUP
argument_list|,
operator|&
name|mrr
argument_list|,
sizeof|sizeof
name|mrr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not setup MRR for data frames\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wpi_add_node
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|wpi_node
modifier|*
name|wn
init|=
operator|(
name|void
operator|*
operator|)
name|ni
decl_stmt|;
name|struct
name|wpi_node_info
name|node
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_DOING
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|wn
operator|->
name|id
operator|==
name|WPI_ID_UNDEFINED
condition|)
return|return
name|EINVAL
return|;
name|memset
argument_list|(
operator|&
name|node
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|node
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|node
operator|.
name|macaddr
argument_list|,
name|ni
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
name|node
operator|.
name|id
operator|=
name|wn
operator|->
name|id
expr_stmt|;
name|node
operator|.
name|plcp
operator|=
operator|(
name|ic
operator|->
name|ic_curmode
operator|==
name|IEEE80211_MODE_11A
operator|)
condition|?
name|wpi_ridx_to_plcp
index|[
name|WPI_RIDX_OFDM6
index|]
else|:
name|wpi_ridx_to_plcp
index|[
name|WPI_RIDX_CCK1
index|]
expr_stmt|;
name|node
operator|.
name|action
operator|=
name|htole32
argument_list|(
name|WPI_ACTION_SET_RATE
argument_list|)
expr_stmt|;
name|node
operator|.
name|antenna
operator|=
name|WPI_ANTENNA_BOTH
expr_stmt|;
return|return
name|wpi_cmd
argument_list|(
name|sc
argument_list|,
name|WPI_CMD_ADD_NODE
argument_list|,
operator|&
name|node
argument_list|,
sizeof|sizeof
name|node
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Broadcast node is used to send group-addressed and management frames.  */
end_comment

begin_function
specifier|static
name|int
name|wpi_add_broadcast_node
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|async
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|wpi_node_info
name|node
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_DOING
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|node
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|node
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|node
operator|.
name|macaddr
argument_list|,
name|ifp
operator|->
name|if_broadcastaddr
argument_list|)
expr_stmt|;
name|node
operator|.
name|id
operator|=
name|WPI_ID_BROADCAST
expr_stmt|;
name|node
operator|.
name|plcp
operator|=
operator|(
name|ic
operator|->
name|ic_curmode
operator|==
name|IEEE80211_MODE_11A
operator|)
condition|?
name|wpi_ridx_to_plcp
index|[
name|WPI_RIDX_OFDM6
index|]
else|:
name|wpi_ridx_to_plcp
index|[
name|WPI_RIDX_CCK1
index|]
expr_stmt|;
name|node
operator|.
name|action
operator|=
name|htole32
argument_list|(
name|WPI_ACTION_SET_RATE
argument_list|)
expr_stmt|;
name|node
operator|.
name|antenna
operator|=
name|WPI_ANTENNA_BOTH
expr_stmt|;
return|return
name|wpi_cmd
argument_list|(
name|sc
argument_list|,
name|WPI_CMD_ADD_NODE
argument_list|,
operator|&
name|node
argument_list|,
sizeof|sizeof
name|node
argument_list|,
name|async
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wpi_add_ibss_node
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|wpi_node
modifier|*
name|wn
init|=
operator|(
name|void
operator|*
operator|)
name|ni
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_DOING
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|wn
operator|->
name|id
operator|!=
name|WPI_ID_UNDEFINED
condition|)
return|return
name|EINVAL
return|;
name|wn
operator|->
name|id
operator|=
name|alloc_unrl
argument_list|(
name|sc
operator|->
name|sc_unr
argument_list|)
expr_stmt|;
if|if
condition|(
name|wn
operator|->
name|id
operator|==
operator|(
name|uint8_t
operator|)
operator|-
literal|1
condition|)
return|return
name|ENOBUFS
return|;
return|return
name|wpi_add_node
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_del_node
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|wpi_node
modifier|*
name|wn
init|=
operator|(
name|void
operator|*
operator|)
name|ni
decl_stmt|;
name|struct
name|wpi_cmd_del_node
name|node
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_DOING
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|wn
operator|->
name|id
operator|==
name|WPI_ID_UNDEFINED
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: undefined node id passed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
name|memset
argument_list|(
operator|&
name|node
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|node
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|node
operator|.
name|macaddr
argument_list|,
name|ni
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
name|node
operator|.
name|count
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|wpi_cmd
argument_list|(
name|sc
argument_list|,
name|WPI_CMD_DEL_NODE
argument_list|,
operator|&
name|node
argument_list|,
sizeof|sizeof
name|node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not delete node %u, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|wn
operator|->
name|id
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|wpi_updateedca
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
define|#
directive|define
name|WPI_EXP2
parameter_list|(
name|x
parameter_list|)
value|((1<< (x)) - 1)
comment|/* CWmin = 2^ECWmin - 1 */
name|struct
name|wpi_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|wpi_edca_params
name|cmd
decl_stmt|;
name|int
name|aci
decl_stmt|,
name|error
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_BEGIN
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|flags
operator|=
name|htole32
argument_list|(
name|WPI_EDCA_UPDATE
argument_list|)
expr_stmt|;
for|for
control|(
name|aci
operator|=
literal|0
init|;
name|aci
operator|<
name|WME_NUM_AC
condition|;
name|aci
operator|++
control|)
block|{
specifier|const
name|struct
name|wmeParams
modifier|*
name|ac
init|=
operator|&
name|ic
operator|->
name|ic_wme
operator|.
name|wme_chanParams
operator|.
name|cap_wmeParams
index|[
name|aci
index|]
decl_stmt|;
name|cmd
operator|.
name|ac
index|[
name|aci
index|]
operator|.
name|aifsn
operator|=
name|ac
operator|->
name|wmep_aifsn
expr_stmt|;
name|cmd
operator|.
name|ac
index|[
name|aci
index|]
operator|.
name|cwmin
operator|=
name|htole16
argument_list|(
name|WPI_EXP2
argument_list|(
name|ac
operator|->
name|wmep_logcwmin
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|ac
index|[
name|aci
index|]
operator|.
name|cwmax
operator|=
name|htole16
argument_list|(
name|WPI_EXP2
argument_list|(
name|ac
operator|->
name|wmep_logcwmax
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|ac
index|[
name|aci
index|]
operator|.
name|txoplimit
operator|=
name|htole16
argument_list|(
name|IEEE80211_TXOP_TO_US
argument_list|(
name|ac
operator|->
name|wmep_txopLimit
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_EDCA
argument_list|,
literal|"setting WME for queue %d aifsn=%d cwmin=%d cwmax=%d "
literal|"txoplimit=%d\n"
argument_list|,
name|aci
argument_list|,
name|cmd
operator|.
name|ac
index|[
name|aci
index|]
operator|.
name|aifsn
argument_list|,
name|cmd
operator|.
name|ac
index|[
name|aci
index|]
operator|.
name|cwmin
argument_list|,
name|cmd
operator|.
name|ac
index|[
name|aci
index|]
operator|.
name|cwmax
argument_list|,
name|cmd
operator|.
name|ac
index|[
name|aci
index|]
operator|.
name|txoplimit
argument_list|)
expr_stmt|;
block|}
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|WPI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|wpi_cmd
argument_list|(
name|sc
argument_list|,
name|WPI_CMD_EDCA_PARAMS
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
name|cmd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|WPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_END
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|error
return|;
undef|#
directive|undef
name|WPI_EXP2
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_set_promisc
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|uint32_t
name|promisc_filter
decl_stmt|;
name|promisc_filter
operator|=
name|WPI_FILTER_PROMISC
operator||
name|WPI_FILTER_CTL
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
name|sc
operator|->
name|rxon
operator|.
name|filter
operator||=
name|htole32
argument_list|(
name|promisc_filter
argument_list|)
expr_stmt|;
else|else
name|sc
operator|->
name|rxon
operator|.
name|filter
operator|&=
operator|~
name|htole32
argument_list|(
name|promisc_filter
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_update_promisc
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|wpi_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|wpi_set_promisc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|WPI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpi_send_rxon
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not send RXON\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
name|WPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_update_mcast
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
comment|/* Ignore */
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_set_led
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|which
parameter_list|,
name|uint8_t
name|off
parameter_list|,
name|uint8_t
name|on
parameter_list|)
block|{
name|struct
name|wpi_cmd_led
name|led
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_DOING
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|led
operator|.
name|which
operator|=
name|which
expr_stmt|;
name|led
operator|.
name|unit
operator|=
name|htole32
argument_list|(
literal|100000
argument_list|)
expr_stmt|;
comment|/* on/off in unit of 100ms */
name|led
operator|.
name|off
operator|=
name|off
expr_stmt|;
name|led
operator|.
name|on
operator|=
name|on
expr_stmt|;
operator|(
name|void
operator|)
name|wpi_cmd
argument_list|(
name|sc
argument_list|,
name|WPI_CMD_SET_LED
argument_list|,
operator|&
name|led
argument_list|,
sizeof|sizeof
name|led
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|wpi_set_timing
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|wpi_cmd_timing
name|cmd
decl_stmt|;
name|uint64_t
name|val
decl_stmt|,
name|mod
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_DOING
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|cmd
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|cmd
operator|.
name|tstamp
argument_list|,
name|ni
operator|->
name|ni_tstamp
operator|.
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|bintval
operator|=
name|htole16
argument_list|(
name|ni
operator|->
name|ni_intval
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|lintval
operator|=
name|htole16
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* Compute remaining time until next beacon. */
name|val
operator|=
operator|(
name|uint64_t
operator|)
name|ni
operator|->
name|ni_intval
operator|*
name|IEEE80211_DUR_TU
expr_stmt|;
name|mod
operator|=
name|le64toh
argument_list|(
name|cmd
operator|.
name|tstamp
argument_list|)
operator|%
name|val
expr_stmt|;
name|cmd
operator|.
name|binitval
operator|=
name|htole32
argument_list|(
call|(
name|uint32_t
call|)
argument_list|(
name|val
operator|-
name|mod
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_RESET
argument_list|,
literal|"timing bintval=%u tstamp=%ju, init=%u\n"
argument_list|,
name|ni
operator|->
name|ni_intval
argument_list|,
name|le64toh
argument_list|(
name|cmd
operator|.
name|tstamp
argument_list|)
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|val
operator|-
name|mod
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|wpi_cmd
argument_list|(
name|sc
argument_list|,
name|WPI_CMD_TIMING
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
name|cmd
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function is called periodically (every 60 seconds) to adjust output  * power to temperature changes.  */
end_comment

begin_function
specifier|static
name|void
name|wpi_power_calibration
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|temp
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_DOING
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Update sensor data. */
name|temp
operator|=
operator|(
name|int
operator|)
name|WPI_READ
argument_list|(
name|sc
argument_list|,
name|WPI_UCODE_GP2
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TEMP
argument_list|,
literal|"Temp in calibration is: %d\n"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* Sanity-check read value. */
if|if
condition|(
name|temp
operator|<
operator|-
literal|260
operator|||
name|temp
operator|>
literal|25
condition|)
block|{
comment|/* This can't be correct, ignore. */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TEMP
argument_list|,
literal|"out-of-range temperature reported: %d\n"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
return|return;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TEMP
argument_list|,
literal|"temperature %d->%d\n"
argument_list|,
name|sc
operator|->
name|temp
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* Adjust Tx power if need be. */
if|if
condition|(
name|abs
argument_list|(
name|temp
operator|-
name|sc
operator|->
name|temp
argument_list|)
operator|<=
literal|6
condition|)
return|return;
name|sc
operator|->
name|temp
operator|=
name|temp
expr_stmt|;
if|if
condition|(
name|wpi_set_txpower
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* just warn, too bad for the automatic calibration... */
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not adjust Tx power\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Set TX power for current channel.  */
end_comment

begin_function
specifier|static
name|int
name|wpi_set_txpower
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|async
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ieee80211_channel
modifier|*
name|ch
decl_stmt|;
name|struct
name|wpi_power_group
modifier|*
name|group
decl_stmt|;
name|struct
name|wpi_cmd_txpower
name|cmd
decl_stmt|;
name|uint8_t
name|chan
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|i
decl_stmt|;
comment|/* Retrieve current channel from last RXON. */
name|chan
operator|=
name|sc
operator|->
name|rxon
operator|.
name|chan
expr_stmt|;
name|ch
operator|=
operator|&
name|ic
operator|->
name|ic_channels
index|[
name|chan
index|]
expr_stmt|;
comment|/* Find the TX power group to which this channel belongs. */
if|if
condition|(
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|ch
argument_list|)
condition|)
block|{
for|for
control|(
name|group
operator|=
operator|&
name|sc
operator|->
name|groups
index|[
literal|1
index|]
init|;
name|group
operator|<
operator|&
name|sc
operator|->
name|groups
index|[
literal|4
index|]
condition|;
name|group
operator|++
control|)
if|if
condition|(
name|chan
operator|<=
name|group
operator|->
name|chan
condition|)
break|break;
block|}
else|else
name|group
operator|=
operator|&
name|sc
operator|->
name|groups
index|[
literal|0
index|]
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|band
operator|=
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|ch
argument_list|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|cmd
operator|.
name|chan
operator|=
name|htole16
argument_list|(
name|chan
argument_list|)
expr_stmt|;
comment|/* Set TX power for all OFDM and CCK rates. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|WPI_RIDX_MAX
condition|;
name|i
operator|++
control|)
block|{
comment|/* Retrieve TX power for this channel/rate. */
name|idx
operator|=
name|wpi_get_power_index
argument_list|(
name|sc
argument_list|,
name|group
argument_list|,
name|ch
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|rates
index|[
name|i
index|]
operator|.
name|plcp
operator|=
name|wpi_ridx_to_plcp
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|cmd
operator|.
name|rates
index|[
name|i
index|]
operator|.
name|rf_gain
operator|=
name|wpi_rf_gain_5ghz
index|[
name|idx
index|]
expr_stmt|;
name|cmd
operator|.
name|rates
index|[
name|i
index|]
operator|.
name|dsp_gain
operator|=
name|wpi_dsp_gain_5ghz
index|[
name|idx
index|]
expr_stmt|;
block|}
else|else
block|{
name|cmd
operator|.
name|rates
index|[
name|i
index|]
operator|.
name|rf_gain
operator|=
name|wpi_rf_gain_2ghz
index|[
name|idx
index|]
expr_stmt|;
name|cmd
operator|.
name|rates
index|[
name|i
index|]
operator|.
name|dsp_gain
operator|=
name|wpi_dsp_gain_2ghz
index|[
name|idx
index|]
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TEMP
argument_list|,
literal|"chan %d/ridx %d: power index %d\n"
argument_list|,
name|chan
argument_list|,
name|i
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
return|return
name|wpi_cmd
argument_list|(
name|sc
argument_list|,
name|WPI_CMD_TXPOWER
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
name|cmd
argument_list|,
name|async
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine Tx power index for a given channel/rate combination.  * This takes into account the regulatory information from EEPROM and the  * current temperature.  */
end_comment

begin_function
specifier|static
name|int
name|wpi_get_power_index
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|wpi_power_group
modifier|*
name|group
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|c
parameter_list|,
name|int
name|ridx
parameter_list|)
block|{
comment|/* Fixed-point arithmetic division using a n-bit fractional part. */
define|#
directive|define
name|fdivround
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|n
parameter_list|)
define|\
value|((((1<< n) * (a)) / (b) + (1<< n) / 2) / (1<< n))
comment|/* Linear interpolation. */
define|#
directive|define
name|interpolate
parameter_list|(
name|x
parameter_list|,
name|x1
parameter_list|,
name|y1
parameter_list|,
name|x2
parameter_list|,
name|y2
parameter_list|,
name|n
parameter_list|)
define|\
value|((y1) + fdivround(((x) - (x1)) * ((y2) - (y1)), (x2) - (x1), n))
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|wpi_power_sample
modifier|*
name|sample
decl_stmt|;
name|int
name|pwr
decl_stmt|,
name|idx
decl_stmt|;
name|u_int
name|chan
decl_stmt|;
comment|/* Get channel number. */
name|chan
operator|=
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|/* Default TX power is group maximum TX power minus 3dB. */
name|pwr
operator|=
name|group
operator|->
name|maxpwr
operator|/
literal|2
expr_stmt|;
comment|/* Decrease TX power for highest OFDM rates to reduce distortion. */
switch|switch
condition|(
name|ridx
condition|)
block|{
case|case
name|WPI_RIDX_OFDM36
case|:
name|pwr
operator|-=
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|c
argument_list|)
condition|?
literal|0
else|:
literal|5
expr_stmt|;
break|break;
case|case
name|WPI_RIDX_OFDM48
case|:
name|pwr
operator|-=
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|c
argument_list|)
condition|?
literal|7
else|:
literal|10
expr_stmt|;
break|break;
case|case
name|WPI_RIDX_OFDM54
case|:
name|pwr
operator|-=
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|c
argument_list|)
condition|?
literal|9
else|:
literal|12
expr_stmt|;
break|break;
block|}
comment|/* Never exceed the channel maximum allowed TX power. */
name|pwr
operator|=
name|min
argument_list|(
name|pwr
argument_list|,
name|sc
operator|->
name|maxpwr
index|[
name|chan
index|]
argument_list|)
expr_stmt|;
comment|/* Retrieve TX power index into gain tables from samples. */
for|for
control|(
name|sample
operator|=
name|group
operator|->
name|samples
init|;
name|sample
operator|<
operator|&
name|group
operator|->
name|samples
index|[
literal|3
index|]
condition|;
name|sample
operator|++
control|)
if|if
condition|(
name|pwr
operator|>
name|sample
index|[
literal|1
index|]
operator|.
name|power
condition|)
break|break;
comment|/* Fixed-point linear interpolation using a 19-bit fractional part. */
name|idx
operator|=
name|interpolate
argument_list|(
name|pwr
argument_list|,
name|sample
index|[
literal|0
index|]
operator|.
name|power
argument_list|,
name|sample
index|[
literal|0
index|]
operator|.
name|index
argument_list|,
name|sample
index|[
literal|1
index|]
operator|.
name|power
argument_list|,
name|sample
index|[
literal|1
index|]
operator|.
name|index
argument_list|,
literal|19
argument_list|)
expr_stmt|;
comment|/*- 	 * Adjust power index based on current temperature: 	 * - if cooler than factory-calibrated: decrease output power 	 * - if warmer than factory-calibrated: increase output power 	 */
name|idx
operator|-=
operator|(
name|sc
operator|->
name|temp
operator|-
name|group
operator|->
name|temp
operator|)
operator|*
literal|11
operator|/
literal|100
expr_stmt|;
comment|/* Decrease TX power for CCK rates (-5dB). */
if|if
condition|(
name|ridx
operator|>=
name|WPI_RIDX_CCK1
condition|)
name|idx
operator|+=
literal|10
expr_stmt|;
comment|/* Make sure idx stays in a valid range. */
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|idx
operator|>
name|WPI_MAX_PWR_INDEX
condition|)
return|return
name|WPI_MAX_PWR_INDEX
return|;
return|return
name|idx
return|;
undef|#
directive|undef
name|interpolate
undef|#
directive|undef
name|fdivround
block|}
end_function

begin_comment
comment|/*  * Set STA mode power saving level (between 0 and 5).  * Level 0 is CAM (Continuously Aware Mode), 5 is for maximum power saving.  */
end_comment

begin_function
specifier|static
name|int
name|wpi_set_pslevel
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|dtim
parameter_list|,
name|int
name|level
parameter_list|,
name|int
name|async
parameter_list|)
block|{
name|struct
name|wpi_pmgt_cmd
name|cmd
decl_stmt|;
specifier|const
name|struct
name|wpi_pmgt
modifier|*
name|pmgt
decl_stmt|;
name|uint32_t
name|max
decl_stmt|,
name|skip_dtim
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_PWRSAVE
argument_list|,
literal|"%s: dtim=%d, level=%d, async=%d\n"
argument_list|,
name|__func__
argument_list|,
name|dtim
argument_list|,
name|level
argument_list|,
name|async
argument_list|)
expr_stmt|;
comment|/* Select which PS parameters to use. */
if|if
condition|(
name|dtim
operator|<=
literal|10
condition|)
name|pmgt
operator|=
operator|&
name|wpi_pmgt
index|[
literal|0
index|]
index|[
name|level
index|]
expr_stmt|;
else|else
name|pmgt
operator|=
operator|&
name|wpi_pmgt
index|[
literal|1
index|]
index|[
name|level
index|]
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|!=
literal|0
condition|)
comment|/* not CAM */
name|cmd
operator|.
name|flags
operator||=
name|htole16
argument_list|(
name|WPI_PS_ALLOW_SLEEP
argument_list|)
expr_stmt|;
comment|/* Retrieve PCIe Active State Power Management (ASPM). */
name|reg
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|sc
operator|->
name|sc_cap_off
operator|+
literal|0x10
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|reg
operator|&
literal|0x1
operator|)
condition|)
comment|/* L0s Entry disabled. */
name|cmd
operator|.
name|flags
operator||=
name|htole16
argument_list|(
name|WPI_PS_PCI_PMGT
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|rxtimeout
operator|=
name|htole32
argument_list|(
name|pmgt
operator|->
name|rxtimeout
operator|*
name|IEEE80211_DUR_TU
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|txtimeout
operator|=
name|htole32
argument_list|(
name|pmgt
operator|->
name|txtimeout
operator|*
name|IEEE80211_DUR_TU
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtim
operator|==
literal|0
condition|)
block|{
name|dtim
operator|=
literal|1
expr_stmt|;
name|skip_dtim
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|skip_dtim
operator|=
name|pmgt
operator|->
name|skip_dtim
expr_stmt|;
if|if
condition|(
name|skip_dtim
operator|!=
literal|0
condition|)
block|{
name|cmd
operator|.
name|flags
operator||=
name|htole16
argument_list|(
name|WPI_PS_SLEEP_OVER_DTIM
argument_list|)
expr_stmt|;
name|max
operator|=
name|pmgt
operator|->
name|intval
index|[
literal|4
index|]
expr_stmt|;
if|if
condition|(
name|max
operator|==
operator|(
name|uint32_t
operator|)
operator|-
literal|1
condition|)
name|max
operator|=
name|dtim
operator|*
operator|(
name|skip_dtim
operator|+
literal|1
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|max
operator|>
name|dtim
condition|)
name|max
operator|=
operator|(
name|max
operator|/
name|dtim
operator|)
operator|*
name|dtim
expr_stmt|;
block|}
else|else
name|max
operator|=
name|dtim
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
name|cmd
operator|.
name|intval
index|[
name|i
index|]
operator|=
name|htole32
argument_list|(
name|MIN
argument_list|(
name|max
argument_list|,
name|pmgt
operator|->
name|intval
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|wpi_cmd
argument_list|(
name|sc
argument_list|,
name|WPI_CMD_SET_POWER_MODE
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
name|cmd
argument_list|,
name|async
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wpi_send_btcoex
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|wpi_bluetooth
name|cmd
decl_stmt|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|flags
operator|=
name|WPI_BT_COEX_MODE_4WIRE
expr_stmt|;
name|cmd
operator|.
name|lead_time
operator|=
name|WPI_BT_LEAD_TIME_DEF
expr_stmt|;
name|cmd
operator|.
name|max_kill
operator|=
name|WPI_BT_MAX_KILL_DEF
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_RESET
argument_list|,
literal|"%s: configuring bluetooth coexistence\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|wpi_cmd
argument_list|(
name|sc
argument_list|,
name|WPI_CMD_BT_COEX
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wpi_send_rxon
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|assoc
parameter_list|,
name|int
name|async
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|assoc
operator|&&
operator|(
name|sc
operator|->
name|rxon
operator|.
name|filter
operator|&
name|htole32
argument_list|(
name|WPI_FILTER_BSS
argument_list|)
operator|)
condition|)
block|{
name|struct
name|wpi_assoc
name|rxon_assoc
decl_stmt|;
name|rxon_assoc
operator|.
name|flags
operator|=
name|sc
operator|->
name|rxon
operator|.
name|flags
expr_stmt|;
name|rxon_assoc
operator|.
name|filter
operator|=
name|sc
operator|->
name|rxon
operator|.
name|filter
expr_stmt|;
name|rxon_assoc
operator|.
name|ofdm_mask
operator|=
name|sc
operator|->
name|rxon
operator|.
name|ofdm_mask
expr_stmt|;
name|rxon_assoc
operator|.
name|cck_mask
operator|=
name|sc
operator|->
name|rxon
operator|.
name|cck_mask
expr_stmt|;
name|rxon_assoc
operator|.
name|reserved
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|wpi_cmd
argument_list|(
name|sc
argument_list|,
name|WPI_CMD_RXON_ASSOC
argument_list|,
operator|&
name|rxon_assoc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|wpi_assoc
argument_list|)
argument_list|,
name|async
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|wpi_cmd
argument_list|(
name|sc
argument_list|,
name|WPI_CMD_RXON
argument_list|,
operator|&
name|sc
operator|->
name|rxon
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|wpi_rxon
argument_list|)
argument_list|,
name|async
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"RXON command failed, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Configuration has changed, set Tx power accordingly. */
if|if
condition|(
operator|(
name|error
operator|=
name|wpi_set_txpower
argument_list|(
name|sc
argument_list|,
name|async
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not set TX power, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|rxon
operator|.
name|filter
operator|&
name|htole32
argument_list|(
name|WPI_FILTER_BSS
argument_list|)
operator|)
condition|)
block|{
comment|/* Add broadcast node. */
name|error
operator|=
name|wpi_add_broadcast_node
argument_list|(
name|sc
argument_list|,
name|async
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not add broadcast node, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Configure the card to listen to a particular channel, this transisions the  * card in to being able to receive frames from remote devices.  */
end_comment

begin_function
specifier|static
name|int
name|wpi_config
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_BEGIN
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Set power saving level to CAM during initialization. */
if|if
condition|(
operator|(
name|error
operator|=
name|wpi_set_pslevel
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not set power saving level\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Configure bluetooth coexistence. */
if|if
condition|(
operator|(
name|error
operator|=
name|wpi_send_btcoex
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not configure bluetooth coexistence\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Configure adapter. */
name|memset
argument_list|(
operator|&
name|sc
operator|->
name|rxon
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|wpi_rxon
argument_list|)
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|sc
operator|->
name|rxon
operator|.
name|myaddr
argument_list|,
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set default channel. */
name|sc
operator|->
name|rxon
operator|.
name|chan
operator|=
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rxon
operator|.
name|flags
operator|=
name|htole32
argument_list|(
name|WPI_RXON_TSF
operator||
name|WPI_RXON_CTS_TO_SELF
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
condition|)
name|sc
operator|->
name|rxon
operator|.
name|flags
operator||=
name|htole32
argument_list|(
name|WPI_RXON_AUTO
operator||
name|WPI_RXON_24GHZ
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ic
operator|->
name|ic_opmode
condition|)
block|{
case|case
name|IEEE80211_M_STA
case|:
name|sc
operator|->
name|rxon
operator|.
name|mode
operator|=
name|WPI_MODE_STA
expr_stmt|;
name|sc
operator|->
name|rxon
operator|.
name|filter
operator|=
name|htole32
argument_list|(
name|WPI_FILTER_MULTICAST
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_IBSS
case|:
name|sc
operator|->
name|rxon
operator|.
name|mode
operator|=
name|WPI_MODE_IBSS
expr_stmt|;
name|sc
operator|->
name|rxon
operator|.
name|filter
operator|=
name|htole32
argument_list|(
name|WPI_FILTER_BEACON
operator||
name|WPI_FILTER_MULTICAST
argument_list|)
expr_stmt|;
break|break;
comment|/* XXX workaround for passive channels selection */
case|case
name|IEEE80211_M_AHDEMO
case|:
name|sc
operator|->
name|rxon
operator|.
name|filter
operator|=
name|htole32
argument_list|(
name|WPI_FILTER_MULTICAST
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|IEEE80211_M_HOSTAP
case|:
name|sc
operator|->
name|rxon
operator|.
name|mode
operator|=
name|WPI_MODE_HOSTAP
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_MONITOR
case|:
name|sc
operator|->
name|rxon
operator|.
name|mode
operator|=
name|WPI_MODE_MONITOR
expr_stmt|;
name|sc
operator|->
name|rxon
operator|.
name|filter
operator|=
name|htole32
argument_list|(
name|WPI_FILTER_MULTICAST
argument_list|)
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unknown opmode %d\n"
argument_list|,
name|ic
operator|->
name|ic_opmode
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|wpi_set_promisc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rxon
operator|.
name|cck_mask
operator|=
literal|0x0f
expr_stmt|;
comment|/* not yet negotiated */
name|sc
operator|->
name|rxon
operator|.
name|ofdm_mask
operator|=
literal|0xff
expr_stmt|;
comment|/* not yet negotiated */
if|if
condition|(
operator|(
name|error
operator|=
name|wpi_send_rxon
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not send RXON\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Setup rate scalling. */
if|if
condition|(
operator|(
name|error
operator|=
name|wpi_mrr_setup
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not setup MRR, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Disable beacon notifications (unused). */
name|flags
operator|=
name|WPI_STATISTICS_BEACON_DISABLE
expr_stmt|;
name|error
operator|=
name|wpi_cmd
argument_list|(
name|sc
argument_list|,
name|WPI_CMD_GET_STATISTICS
argument_list|,
operator|&
name|flags
argument_list|,
sizeof|sizeof
name|flags
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not disable beacon statistics, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_END
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|uint16_t
name|wpi_get_active_dwell_time
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|c
parameter_list|,
name|uint8_t
name|n_probes
parameter_list|)
block|{
comment|/* No channel? Default to 2GHz settings. */
if|if
condition|(
name|c
operator|==
name|NULL
operator|||
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|c
argument_list|)
condition|)
block|{
return|return
operator|(
name|WPI_ACTIVE_DWELL_TIME_2GHZ
operator|+
name|WPI_ACTIVE_DWELL_FACTOR_2GHZ
operator|*
operator|(
name|n_probes
operator|+
literal|1
operator|)
operator|)
return|;
block|}
comment|/* 5GHz dwell time. */
return|return
operator|(
name|WPI_ACTIVE_DWELL_TIME_5GHZ
operator|+
name|WPI_ACTIVE_DWELL_FACTOR_5GHZ
operator|*
operator|(
name|n_probes
operator|+
literal|1
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Limit the total dwell time to 85% of the beacon interval.  *  * Returns the dwell time in milliseconds.  */
end_comment

begin_function
specifier|static
name|uint16_t
name|wpi_limit_dwell
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|uint16_t
name|dwell_time
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|sc
operator|->
name|sc_ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|NULL
decl_stmt|;
name|int
name|bintval
init|=
literal|0
decl_stmt|;
comment|/* bintval is in TU (1.024mS) */
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
condition|)
block|{
name|vap
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
expr_stmt|;
name|bintval
operator|=
name|vap
operator|->
name|iv_bss
operator|->
name|ni_intval
expr_stmt|;
block|}
comment|/* 	 * If it's non-zero, we should calculate the minimum of 	 * it and the DWELL_BASE. 	 * 	 * XXX Yes, the math should take into account that bintval 	 * is 1.024mS, not 1mS.. 	 */
if|if
condition|(
name|bintval
operator|>
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_SCAN
argument_list|,
literal|"%s: bintval=%d\n"
argument_list|,
name|__func__
argument_list|,
name|bintval
argument_list|)
expr_stmt|;
return|return
operator|(
name|MIN
argument_list|(
name|WPI_PASSIVE_DWELL_BASE
argument_list|,
operator|(
operator|(
name|bintval
operator|*
literal|85
operator|)
operator|/
literal|100
operator|)
argument_list|)
operator|)
return|;
block|}
comment|/* No association context? Default. */
return|return
operator|(
name|WPI_PASSIVE_DWELL_BASE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint16_t
name|wpi_get_passive_dwell_time
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|c
parameter_list|)
block|{
name|uint16_t
name|passive
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
operator|||
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|c
argument_list|)
condition|)
name|passive
operator|=
name|WPI_PASSIVE_DWELL_BASE
operator|+
name|WPI_PASSIVE_DWELL_TIME_2GHZ
expr_stmt|;
else|else
name|passive
operator|=
name|WPI_PASSIVE_DWELL_BASE
operator|+
name|WPI_PASSIVE_DWELL_TIME_5GHZ
expr_stmt|;
comment|/* Clamp to the beacon interval if we're associated. */
return|return
operator|(
name|wpi_limit_dwell
argument_list|(
name|sc
argument_list|,
name|passive
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send a scan request to the firmware.  */
end_comment

begin_function
specifier|static
name|int
name|wpi_scan
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|c
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
init|=
name|ic
operator|->
name|ic_scan
decl_stmt|;
name|struct
name|wpi_scan_hdr
modifier|*
name|hdr
decl_stmt|;
name|struct
name|wpi_cmd_data
modifier|*
name|tx
decl_stmt|;
name|struct
name|wpi_scan_essid
modifier|*
name|essids
decl_stmt|;
name|struct
name|wpi_scan_chan
modifier|*
name|chan
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|struct
name|ieee80211_rateset
modifier|*
name|rs
decl_stmt|;
name|uint16_t
name|dwell_active
decl_stmt|,
name|dwell_passive
decl_stmt|;
name|uint8_t
modifier|*
name|buf
decl_stmt|,
modifier|*
name|frm
decl_stmt|;
name|int
name|buflen
decl_stmt|,
name|error
decl_stmt|,
name|i
decl_stmt|,
name|nssid
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_BEGIN
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* 	 * We are absolutely not allowed to send a scan command when another 	 * scan command is pending. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_scan_timer
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: called whilst scanning!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAGAIN
operator|)
return|;
block|}
name|buf
operator|=
name|malloc
argument_list|(
name|WPI_SCAN_MAXSZ
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not allocate buffer for scan command\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|hdr
operator|=
operator|(
expr|struct
name|wpi_scan_hdr
operator|*
operator|)
name|buf
expr_stmt|;
comment|/* 	 * Move to the next channel if no packets are received within 10 msecs 	 * after sending the probe request. 	 */
name|hdr
operator|->
name|quiet_time
operator|=
name|htole16
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* timeout in milliseconds */
name|hdr
operator|->
name|quiet_threshold
operator|=
name|htole16
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* min # of packets */
comment|/* 	 * Max needs to be greater than active and passive and quiet! 	 * It's also in microseconds! 	 */
name|hdr
operator|->
name|max_svc
operator|=
name|htole32
argument_list|(
literal|250
operator|*
name|IEEE80211_DUR_TU
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|pause_svc
operator|=
name|htole32
argument_list|(
operator|(
literal|4
operator|<<
literal|24
operator|)
operator||
operator|(
literal|100
operator|*
name|IEEE80211_DUR_TU
operator|)
argument_list|)
expr_stmt|;
comment|/* Hardcode for now */
name|hdr
operator|->
name|filter
operator|=
name|htole32
argument_list|(
name|WPI_FILTER_MULTICAST
operator||
name|WPI_FILTER_BEACON
argument_list|)
expr_stmt|;
name|tx
operator|=
operator|(
expr|struct
name|wpi_cmd_data
operator|*
operator|)
operator|(
name|hdr
operator|+
literal|1
operator|)
expr_stmt|;
name|tx
operator|->
name|flags
operator|=
name|htole32
argument_list|(
name|WPI_TX_AUTO_SEQ
argument_list|)
expr_stmt|;
name|tx
operator|->
name|id
operator|=
name|WPI_ID_BROADCAST
expr_stmt|;
name|tx
operator|->
name|lifetime
operator|=
name|htole32
argument_list|(
name|WPI_LIFETIME_INFINITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* Send probe requests at 6Mbps. */
name|tx
operator|->
name|plcp
operator|=
name|wpi_ridx_to_plcp
index|[
name|WPI_RIDX_OFDM6
index|]
expr_stmt|;
name|rs
operator|=
operator|&
name|ic
operator|->
name|ic_sup_rates
index|[
name|IEEE80211_MODE_11A
index|]
expr_stmt|;
block|}
else|else
block|{
name|hdr
operator|->
name|flags
operator|=
name|htole32
argument_list|(
name|WPI_RXON_24GHZ
operator||
name|WPI_RXON_AUTO
argument_list|)
expr_stmt|;
comment|/* Send probe requests at 1Mbps. */
name|tx
operator|->
name|plcp
operator|=
name|wpi_ridx_to_plcp
index|[
name|WPI_RIDX_CCK1
index|]
expr_stmt|;
name|rs
operator|=
operator|&
name|ic
operator|->
name|ic_sup_rates
index|[
name|IEEE80211_MODE_11G
index|]
expr_stmt|;
block|}
name|essids
operator|=
operator|(
expr|struct
name|wpi_scan_essid
operator|*
operator|)
operator|(
name|tx
operator|+
literal|1
operator|)
expr_stmt|;
name|nssid
operator|=
name|MIN
argument_list|(
name|ss
operator|->
name|ss_nssid
argument_list|,
name|WPI_SCAN_MAX_ESSIDS
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nssid
condition|;
name|i
operator|++
control|)
block|{
name|essids
index|[
name|i
index|]
operator|.
name|id
operator|=
name|IEEE80211_ELEMID_SSID
expr_stmt|;
name|essids
index|[
name|i
index|]
operator|.
name|len
operator|=
name|MIN
argument_list|(
name|ss
operator|->
name|ss_ssid
index|[
name|i
index|]
operator|.
name|len
argument_list|,
name|IEEE80211_NWID_LEN
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|essids
index|[
name|i
index|]
operator|.
name|data
argument_list|,
name|ss
operator|->
name|ss_ssid
index|[
name|i
index|]
operator|.
name|ssid
argument_list|,
name|essids
index|[
name|i
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WPI_DEBUG
if|if
condition|(
name|sc
operator|->
name|sc_debug
operator|&
name|WPI_DEBUG_SCAN
condition|)
block|{
name|printf
argument_list|(
literal|"Scanning Essid: "
argument_list|)
expr_stmt|;
name|ieee80211_print_essid
argument_list|(
name|essids
index|[
name|i
index|]
operator|.
name|data
argument_list|,
name|essids
index|[
name|i
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/* 	 * Build a probe request frame.  Most of the following code is a 	 * copy& paste of what is done in net80211. 	 */
name|wh
operator|=
operator|(
expr|struct
name|ieee80211_frame
operator|*
operator|)
operator|(
name|essids
operator|+
name|WPI_SCAN_MAX_ESSIDS
operator|)
expr_stmt|;
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|=
name|IEEE80211_FC0_VERSION_0
operator||
name|IEEE80211_FC0_TYPE_MGT
operator||
name|IEEE80211_FC0_SUBTYPE_PROBE_REQ
expr_stmt|;
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|=
name|IEEE80211_FC1_DIR_NODS
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|,
name|ifp
operator|->
name|if_broadcastaddr
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|,
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|,
name|ifp
operator|->
name|if_broadcastaddr
argument_list|)
expr_stmt|;
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|&
name|wh
operator|->
name|i_dur
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* filled by h/w */
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|&
name|wh
operator|->
name|i_seq
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* filled by h/w */
name|frm
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|wh
operator|+
literal|1
operator|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_ssid
argument_list|(
name|frm
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_rates
argument_list|(
name|frm
argument_list|,
name|rs
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|rs_nrates
operator|>
name|IEEE80211_RATE_SIZE
condition|)
name|frm
operator|=
name|ieee80211_add_xrates
argument_list|(
name|frm
argument_list|,
name|rs
argument_list|)
expr_stmt|;
comment|/* Set length of probe request. */
name|tx
operator|->
name|len
operator|=
name|htole16
argument_list|(
name|frm
operator|-
operator|(
name|uint8_t
operator|*
operator|)
name|wh
argument_list|)
expr_stmt|;
comment|/* 	 * Construct information about the channel that we 	 * want to scan. The firmware expects this to be directly 	 * after the scan probe request 	 */
name|chan
operator|=
operator|(
expr|struct
name|wpi_scan_chan
operator|*
operator|)
name|frm
expr_stmt|;
name|chan
operator|->
name|chan
operator|=
name|htole16
argument_list|(
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|chan
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nssid
condition|)
block|{
name|hdr
operator|->
name|crc_threshold
operator|=
name|WPI_SCAN_CRC_TH_DEFAULT
expr_stmt|;
name|chan
operator|->
name|flags
operator||=
name|WPI_CHAN_NPBREQS
argument_list|(
name|nssid
argument_list|)
expr_stmt|;
block|}
else|else
name|hdr
operator|->
name|crc_threshold
operator|=
name|WPI_SCAN_CRC_TH_NEVER
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|->
name|ic_flags
operator|&
name|IEEE80211_CHAN_PASSIVE
operator|)
condition|)
name|chan
operator|->
name|flags
operator||=
name|WPI_CHAN_ACTIVE
expr_stmt|;
comment|/* 	 * Calculate the active/passive dwell times. 	 */
name|dwell_active
operator|=
name|wpi_get_active_dwell_time
argument_list|(
name|sc
argument_list|,
name|c
argument_list|,
name|nssid
argument_list|)
expr_stmt|;
name|dwell_passive
operator|=
name|wpi_get_passive_dwell_time
argument_list|(
name|sc
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|/* Make sure they're valid. */
if|if
condition|(
name|dwell_passive
operator|<=
name|dwell_active
condition|)
name|dwell_passive
operator|=
name|dwell_active
operator|+
literal|1
expr_stmt|;
name|chan
operator|->
name|active
operator|=
name|htole16
argument_list|(
name|dwell_active
argument_list|)
expr_stmt|;
name|chan
operator|->
name|passive
operator|=
name|htole16
argument_list|(
name|dwell_passive
argument_list|)
expr_stmt|;
name|chan
operator|->
name|dsp_gain
operator|=
literal|0x6e
expr_stmt|;
comment|/* Default level */
if|if
condition|(
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|c
argument_list|)
condition|)
name|chan
operator|->
name|rf_gain
operator|=
literal|0x3b
expr_stmt|;
else|else
name|chan
operator|->
name|rf_gain
operator|=
literal|0x28
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_SCAN
argument_list|,
literal|"Scanning %u Passive: %d\n"
argument_list|,
name|chan
operator|->
name|chan
argument_list|,
operator|(
name|c
operator|->
name|ic_flags
operator|&
name|IEEE80211_CHAN_PASSIVE
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|nchan
operator|++
expr_stmt|;
name|chan
operator|++
expr_stmt|;
name|buflen
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|chan
operator|-
name|buf
expr_stmt|;
name|hdr
operator|->
name|len
operator|=
name|htole16
argument_list|(
name|buflen
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_CMD
argument_list|,
literal|"sending scan command nchan=%d\n"
argument_list|,
name|hdr
operator|->
name|nchan
argument_list|)
expr_stmt|;
name|error
operator|=
name|wpi_cmd
argument_list|(
name|sc
argument_list|,
name|WPI_CMD_SCAN
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_scan_timer
operator|=
literal|5
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_END
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wpi_auth
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|vap
operator|->
name|iv_bss
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_BEGIN
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Update adapter configuration. */
name|sc
operator|->
name|rxon
operator|.
name|associd
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|rxon
operator|.
name|filter
operator|&=
operator|~
name|htole32
argument_list|(
name|WPI_FILTER_BSS
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|sc
operator|->
name|rxon
operator|.
name|bssid
argument_list|,
name|ni
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rxon
operator|.
name|chan
operator|=
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ni
operator|->
name|ni_chan
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rxon
operator|.
name|flags
operator|=
name|htole32
argument_list|(
name|WPI_RXON_TSF
operator||
name|WPI_RXON_CTS_TO_SELF
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|)
name|sc
operator|->
name|rxon
operator|.
name|flags
operator||=
name|htole32
argument_list|(
name|WPI_RXON_AUTO
operator||
name|WPI_RXON_24GHZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHSLOT
condition|)
name|sc
operator|->
name|rxon
operator|.
name|flags
operator||=
name|htole32
argument_list|(
name|WPI_RXON_SHSLOT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHPREAMBLE
condition|)
name|sc
operator|->
name|rxon
operator|.
name|flags
operator||=
name|htole32
argument_list|(
name|WPI_RXON_SHPREAMBLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_A
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|)
block|{
name|sc
operator|->
name|rxon
operator|.
name|cck_mask
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|rxon
operator|.
name|ofdm_mask
operator|=
literal|0x15
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_B
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|)
block|{
name|sc
operator|->
name|rxon
operator|.
name|cck_mask
operator|=
literal|0x03
expr_stmt|;
name|sc
operator|->
name|rxon
operator|.
name|ofdm_mask
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Assume 802.11b/g. */
name|sc
operator|->
name|rxon
operator|.
name|cck_mask
operator|=
literal|0x0f
expr_stmt|;
name|sc
operator|->
name|rxon
operator|.
name|ofdm_mask
operator|=
literal|0x15
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_STATE
argument_list|,
literal|"rxon chan %d flags %x cck %x ofdm %x\n"
argument_list|,
name|sc
operator|->
name|rxon
operator|.
name|chan
argument_list|,
name|sc
operator|->
name|rxon
operator|.
name|flags
argument_list|,
name|sc
operator|->
name|rxon
operator|.
name|cck_mask
argument_list|,
name|sc
operator|->
name|rxon
operator|.
name|ofdm_mask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|wpi_send_rxon
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not send RXON\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_END
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wpi_setup_beacon
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|wpi_vap
modifier|*
name|wvp
init|=
name|WPI_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|struct
name|wpi_buf
modifier|*
name|bcn
init|=
operator|&
name|wvp
operator|->
name|wv_bcbuf
decl_stmt|;
name|struct
name|ieee80211_beacon_offsets
name|bo
decl_stmt|;
name|struct
name|wpi_cmd_beacon
modifier|*
name|cmd
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|totlen
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_DOING
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|->
name|ni_chan
operator|==
name|IEEE80211_CHAN_ANYC
condition|)
return|return
name|EINVAL
return|;
name|m
operator|=
name|ieee80211_beacon_alloc
argument_list|(
name|ni
argument_list|,
operator|&
name|bo
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not allocate beacon frame\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|totlen
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|bcn
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
name|cmd
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|wpi_cmd_beacon
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not allocate buffer for beacon command\n"
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|cmd
operator|->
name|id
operator|=
name|WPI_ID_BROADCAST
expr_stmt|;
name|cmd
operator|->
name|ofdm_mask
operator|=
literal|0xff
expr_stmt|;
name|cmd
operator|->
name|cck_mask
operator|=
literal|0x0f
expr_stmt|;
name|cmd
operator|->
name|lifetime
operator|=
name|htole32
argument_list|(
name|WPI_LIFETIME_INFINITE
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|flags
operator|=
name|htole32
argument_list|(
name|WPI_TX_AUTO_SEQ
operator||
name|WPI_TX_INSERT_TSTAMP
argument_list|)
expr_stmt|;
name|bcn
operator|->
name|data
operator|=
name|cmd
expr_stmt|;
name|bcn
operator|->
name|ni
operator|=
name|NULL
expr_stmt|;
name|bcn
operator|->
name|code
operator|=
name|WPI_CMD_SET_BEACON
expr_stmt|;
name|bcn
operator|->
name|ac
operator|=
literal|4
expr_stmt|;
name|bcn
operator|->
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|wpi_cmd_beacon
argument_list|)
expr_stmt|;
block|}
else|else
name|cmd
operator|=
name|bcn
operator|->
name|data
expr_stmt|;
name|cmd
operator|->
name|len
operator|=
name|htole16
argument_list|(
name|totlen
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|plcp
operator|=
operator|(
name|ic
operator|->
name|ic_curmode
operator|==
name|IEEE80211_MODE_11A
operator|)
condition|?
name|wpi_ridx_to_plcp
index|[
name|WPI_RIDX_OFDM6
index|]
else|:
name|wpi_ridx_to_plcp
index|[
name|WPI_RIDX_CCK1
index|]
expr_stmt|;
comment|/* NB: m will be freed in wpi_cmd_done() */
name|bcn
operator|->
name|m
operator|=
name|m
expr_stmt|;
return|return
name|wpi_cmd2
argument_list|(
name|sc
argument_list|,
name|bcn
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_update_beacon
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|int
name|item
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|vap
operator|->
name|iv_bss
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vap
operator|->
name|iv_ifp
decl_stmt|;
name|struct
name|wpi_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|wpi_setup_beacon
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not update beacon frame, error %d"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|wpi_run
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|vap
operator|->
name|iv_bss
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_BEGIN
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_MONITOR
condition|)
block|{
comment|/* Link LED blinks while monitoring. */
name|wpi_set_led
argument_list|(
name|sc
argument_list|,
name|WPI_LED_LINK
argument_list|,
literal|5
argument_list|,
literal|5
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* XXX kernel panic workaround */
if|if
condition|(
name|ni
operator|->
name|ni_chan
operator|==
name|IEEE80211_CHAN_ANYC
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: incomplete configuration\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|wpi_set_timing
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not set timing, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Update adapter configuration. */
name|IEEE80211_ADDR_COPY
argument_list|(
name|sc
operator|->
name|rxon
operator|.
name|bssid
argument_list|,
name|ni
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rxon
operator|.
name|associd
operator|=
name|htole16
argument_list|(
name|IEEE80211_NODE_AID
argument_list|(
name|ni
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rxon
operator|.
name|chan
operator|=
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ni
operator|->
name|ni_chan
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rxon
operator|.
name|flags
operator|=
name|htole32
argument_list|(
name|WPI_RXON_TSF
operator||
name|WPI_RXON_CTS_TO_SELF
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|)
name|sc
operator|->
name|rxon
operator|.
name|flags
operator||=
name|htole32
argument_list|(
name|WPI_RXON_AUTO
operator||
name|WPI_RXON_24GHZ
argument_list|)
expr_stmt|;
comment|/* Short preamble and slot time are negotiated when associating. */
name|sc
operator|->
name|rxon
operator|.
name|flags
operator|&=
operator|~
name|htole32
argument_list|(
name|WPI_RXON_SHPREAMBLE
operator||
name|WPI_RXON_SHSLOT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHSLOT
condition|)
name|sc
operator|->
name|rxon
operator|.
name|flags
operator||=
name|htole32
argument_list|(
name|WPI_RXON_SHSLOT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHPREAMBLE
condition|)
name|sc
operator|->
name|rxon
operator|.
name|flags
operator||=
name|htole32
argument_list|(
name|WPI_RXON_SHPREAMBLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_A
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|)
block|{
name|sc
operator|->
name|rxon
operator|.
name|cck_mask
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|rxon
operator|.
name|ofdm_mask
operator|=
literal|0x15
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_B
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|)
block|{
name|sc
operator|->
name|rxon
operator|.
name|cck_mask
operator|=
literal|0x03
expr_stmt|;
name|sc
operator|->
name|rxon
operator|.
name|ofdm_mask
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Assume 802.11b/g. */
name|sc
operator|->
name|rxon
operator|.
name|cck_mask
operator|=
literal|0x0f
expr_stmt|;
name|sc
operator|->
name|rxon
operator|.
name|ofdm_mask
operator|=
literal|0x15
expr_stmt|;
block|}
name|sc
operator|->
name|rxon
operator|.
name|filter
operator||=
name|htole32
argument_list|(
name|WPI_FILTER_BSS
argument_list|)
expr_stmt|;
comment|/* XXX put somewhere HC_QOS_SUPPORT_ASSOC + HC_IBSS_START */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_STATE
argument_list|,
literal|"rxon chan %d flags %x\n"
argument_list|,
name|sc
operator|->
name|rxon
operator|.
name|chan
argument_list|,
name|sc
operator|->
name|rxon
operator|.
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|wpi_send_rxon
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not send RXON\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_IBSS
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|wpi_setup_beacon
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not setup beacon, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_STA
condition|)
block|{
comment|/* Add BSS node. */
operator|(
operator|(
expr|struct
name|wpi_node
operator|*
operator|)
name|ni
operator|)
operator|->
name|id
operator|=
name|WPI_ID_BSS
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|wpi_add_node
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not add BSS node, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
comment|/* Link LED always on while associated. */
name|wpi_set_led
argument_list|(
name|sc
argument_list|,
name|WPI_LED_LINK
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Start periodic calibration timer. */
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|calib_to
argument_list|,
literal|60
operator|*
name|hz
argument_list|,
name|wpi_calib_timeout
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* Enable power-saving mode if requested by user. */
if|if
condition|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_PMGTON
condition|)
operator|(
name|void
operator|)
name|wpi_set_pslevel
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_END
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wpi_key_alloc
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|struct
name|ieee80211_key
modifier|*
name|k
parameter_list|,
name|ieee80211_keyix
modifier|*
name|keyix
parameter_list|,
name|ieee80211_keyix
modifier|*
name|rxkeyix
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vap
operator|->
name|iv_ifp
decl_stmt|;
name|struct
name|wpi_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|&
name|vap
operator|->
name|iv_nw_keys
index|[
literal|0
index|]
operator|<=
name|k
operator|&&
name|k
operator|<
operator|&
name|vap
operator|->
name|iv_nw_keys
index|[
name|IEEE80211_WEP_NKID
index|]
operator|)
condition|)
block|{
if|if
condition|(
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_GROUP
condition|)
block|{
comment|/* should not happen */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_KEY
argument_list|,
literal|"%s: bogus group key\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|keyix
operator|=
literal|0
expr_stmt|;
comment|/* NB: use key index 0 for ucast key */
block|}
else|else
block|{
operator|*
name|keyix
operator|=
operator|*
name|rxkeyix
operator|=
name|k
operator|-
name|vap
operator|->
name|iv_nw_keys
expr_stmt|;
if|if
condition|(
name|k
operator|->
name|wk_cipher
operator|->
name|ic_cipher
operator|==
name|IEEE80211_CIPHER_AES_CCM
condition|)
name|k
operator|->
name|wk_flags
operator||=
name|IEEE80211_KEY_SWCRYPT
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wpi_key_set
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|struct
name|ieee80211_key
modifier|*
name|k
parameter_list|,
specifier|const
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
specifier|const
name|struct
name|ieee80211_cipher
modifier|*
name|cip
init|=
name|k
operator|->
name|wk_cipher
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|vap
operator|->
name|iv_bss
decl_stmt|;
name|struct
name|wpi_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|wpi_node
modifier|*
name|wn
init|=
operator|(
name|void
operator|*
operator|)
name|ni
decl_stmt|;
name|struct
name|wpi_node_info
name|node
decl_stmt|;
name|uint16_t
name|kflags
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_DOING
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cip
operator|->
name|ic_cipher
condition|)
block|{
case|case
name|IEEE80211_CIPHER_AES_CCM
case|:
if|if
condition|(
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_GROUP
condition|)
return|return
literal|1
return|;
name|kflags
operator|=
name|WPI_KFLAG_CCMP
expr_stmt|;
break|break;
default|default:
comment|/* null_key_set() */
return|return
literal|1
return|;
block|}
if|if
condition|(
name|wn
operator|->
name|id
operator|==
name|WPI_ID_UNDEFINED
condition|)
return|return
literal|0
return|;
name|kflags
operator||=
name|WPI_KFLAG_KID
argument_list|(
name|k
operator|->
name|wk_keyix
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_GROUP
condition|)
name|kflags
operator||=
name|WPI_KFLAG_MULTICAST
expr_stmt|;
name|memset
argument_list|(
operator|&
name|node
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|node
argument_list|)
expr_stmt|;
name|node
operator|.
name|id
operator|=
name|wn
operator|->
name|id
expr_stmt|;
name|node
operator|.
name|control
operator|=
name|WPI_NODE_UPDATE
expr_stmt|;
name|node
operator|.
name|flags
operator|=
name|WPI_FLAG_KEY_SET
expr_stmt|;
name|node
operator|.
name|kflags
operator|=
name|htole16
argument_list|(
name|kflags
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|node
operator|.
name|key
argument_list|,
name|k
operator|->
name|wk_key
argument_list|,
name|k
operator|->
name|wk_keylen
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_KEY
argument_list|,
literal|"set key id=%d for node %d\n"
argument_list|,
name|k
operator|->
name|wk_keyix
argument_list|,
name|node
operator|.
name|id
argument_list|)
expr_stmt|;
name|error
operator|=
name|wpi_cmd
argument_list|(
name|sc
argument_list|,
name|WPI_CMD_ADD_NODE
argument_list|,
operator|&
name|node
argument_list|,
sizeof|sizeof
name|node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"can't update node info, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wpi_key_delete
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|struct
name|ieee80211_key
modifier|*
name|k
parameter_list|)
block|{
specifier|const
name|struct
name|ieee80211_cipher
modifier|*
name|cip
init|=
name|k
operator|->
name|wk_cipher
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|vap
operator|->
name|iv_bss
decl_stmt|;
name|struct
name|wpi_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|wpi_node
modifier|*
name|wn
init|=
operator|(
name|void
operator|*
operator|)
name|ni
decl_stmt|;
name|struct
name|wpi_node_info
name|node
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_DOING
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cip
operator|->
name|ic_cipher
condition|)
block|{
case|case
name|IEEE80211_CIPHER_AES_CCM
case|:
break|break;
default|default:
comment|/* null_key_delete() */
return|return
literal|1
return|;
block|}
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|!=
name|IEEE80211_S_RUN
operator|||
operator|(
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_GROUP
operator|)
condition|)
return|return
literal|1
return|;
comment|/* Nothing to do. */
name|memset
argument_list|(
operator|&
name|node
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|node
argument_list|)
expr_stmt|;
name|node
operator|.
name|id
operator|=
name|wn
operator|->
name|id
expr_stmt|;
name|node
operator|.
name|control
operator|=
name|WPI_NODE_UPDATE
expr_stmt|;
name|node
operator|.
name|flags
operator|=
name|WPI_FLAG_KEY_SET
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_KEY
argument_list|,
literal|"delete keys for node %d\n"
argument_list|,
name|node
operator|.
name|id
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wpi_cmd
argument_list|(
name|sc
argument_list|,
name|WPI_CMD_ADD_NODE
argument_list|,
operator|&
name|node
argument_list|,
sizeof|sizeof
name|node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * This function is called after the runtime firmware notifies us of its  * readiness (called in a process context).  */
end_comment

begin_function
specifier|static
name|int
name|wpi_post_alive
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|ntries
decl_stmt|,
name|error
decl_stmt|;
comment|/* Check (again) that the radio is not disabled. */
if|if
condition|(
operator|(
name|error
operator|=
name|wpi_nic_lock
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_DOING
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* NB: Runtime firmware must be up and running. */
if|if
condition|(
operator|!
operator|(
name|wpi_prph_read
argument_list|(
name|sc
argument_list|,
name|WPI_APMG_RFKILL
argument_list|)
operator|&
literal|1
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"RF switch: radio disabled (%s)\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|wpi_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|EPERM
return|;
comment|/* :-) */
block|}
name|wpi_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Wait for thermal sensor to calibrate. */
for|for
control|(
name|ntries
operator|=
literal|0
init|;
name|ntries
operator|<
literal|1000
condition|;
name|ntries
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|temp
operator|=
operator|(
name|int
operator|)
name|WPI_READ
argument_list|(
name|sc
argument_list|,
name|WPI_UCODE_GP2
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ntries
operator|==
literal|1000
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"timeout waiting for thermal sensor calibration\n"
argument_list|)
expr_stmt|;
return|return
name|ETIMEDOUT
return|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TEMP
argument_list|,
literal|"temperature %d\n"
argument_list|,
name|sc
operator|->
name|temp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * The firmware boot code is small and is intended to be copied directly into  * the NIC internal memory (no DMA transfer).  */
end_comment

begin_function
specifier|static
name|int
name|wpi_load_bootcode
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|ucode
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|ntries
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_HW
argument_list|,
literal|"Loading microcode size 0x%x\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|size
operator|/=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|wpi_nic_lock
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
comment|/* Copy microcode image into NIC memory. */
name|wpi_prph_write_region_4
argument_list|(
name|sc
argument_list|,
name|WPI_BSM_SRAM_BASE
argument_list|,
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|ucode
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|wpi_prph_write
argument_list|(
name|sc
argument_list|,
name|WPI_BSM_WR_MEM_SRC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wpi_prph_write
argument_list|(
name|sc
argument_list|,
name|WPI_BSM_WR_MEM_DST
argument_list|,
name|WPI_FW_TEXT_BASE
argument_list|)
expr_stmt|;
name|wpi_prph_write
argument_list|(
name|sc
argument_list|,
name|WPI_BSM_WR_DWCOUNT
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* Start boot load now. */
name|wpi_prph_write
argument_list|(
name|sc
argument_list|,
name|WPI_BSM_WR_CTRL
argument_list|,
name|WPI_BSM_WR_CTRL_START
argument_list|)
expr_stmt|;
comment|/* Wait for transfer to complete. */
for|for
control|(
name|ntries
operator|=
literal|0
init|;
name|ntries
operator|<
literal|1000
condition|;
name|ntries
operator|++
control|)
block|{
name|uint32_t
name|status
init|=
name|WPI_READ
argument_list|(
name|sc
argument_list|,
name|WPI_FH_TX_STATUS
argument_list|)
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_HW
argument_list|,
literal|"firmware status=0x%x, val=0x%x, result=0x%x\n"
argument_list|,
name|status
argument_list|,
name|WPI_FH_TX_STATUS_IDLE
argument_list|(
literal|6
argument_list|)
argument_list|,
name|status
operator|&
name|WPI_FH_TX_STATUS_IDLE
argument_list|(
literal|6
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|WPI_FH_TX_STATUS_IDLE
argument_list|(
literal|6
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_HW
argument_list|,
literal|"Status Match! - ntries = %d\n"
argument_list|,
name|ntries
argument_list|)
expr_stmt|;
break|break;
block|}
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ntries
operator|==
literal|1000
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not load boot firmware\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|wpi_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|ETIMEDOUT
return|;
block|}
comment|/* Enable boot after power up. */
name|wpi_prph_write
argument_list|(
name|sc
argument_list|,
name|WPI_BSM_WR_CTRL
argument_list|,
name|WPI_BSM_WR_CTRL_START_EN
argument_list|)
expr_stmt|;
name|wpi_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wpi_load_firmware
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|wpi_fw_info
modifier|*
name|fw
init|=
operator|&
name|sc
operator|->
name|fw
decl_stmt|;
name|struct
name|wpi_dma_info
modifier|*
name|dma
init|=
operator|&
name|sc
operator|->
name|fw_dma
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_DOING
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Copy initialization sections into pre-allocated DMA-safe memory. */
name|memcpy
argument_list|(
name|dma
operator|->
name|vaddr
argument_list|,
name|fw
operator|->
name|init
operator|.
name|data
argument_list|,
name|fw
operator|->
name|init
operator|.
name|datasz
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
name|dma
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dma
operator|->
name|vaddr
operator|+
name|WPI_FW_DATA_MAXSZ
argument_list|,
name|fw
operator|->
name|init
operator|.
name|text
argument_list|,
name|fw
operator|->
name|init
operator|.
name|textsz
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
name|dma
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* Tell adapter where to find initialization sections. */
if|if
condition|(
operator|(
name|error
operator|=
name|wpi_nic_lock
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|wpi_prph_write
argument_list|(
name|sc
argument_list|,
name|WPI_BSM_DRAM_DATA_ADDR
argument_list|,
name|dma
operator|->
name|paddr
argument_list|)
expr_stmt|;
name|wpi_prph_write
argument_list|(
name|sc
argument_list|,
name|WPI_BSM_DRAM_DATA_SIZE
argument_list|,
name|fw
operator|->
name|init
operator|.
name|datasz
argument_list|)
expr_stmt|;
name|wpi_prph_write
argument_list|(
name|sc
argument_list|,
name|WPI_BSM_DRAM_TEXT_ADDR
argument_list|,
name|dma
operator|->
name|paddr
operator|+
name|WPI_FW_DATA_MAXSZ
argument_list|)
expr_stmt|;
name|wpi_prph_write
argument_list|(
name|sc
argument_list|,
name|WPI_BSM_DRAM_TEXT_SIZE
argument_list|,
name|fw
operator|->
name|init
operator|.
name|textsz
argument_list|)
expr_stmt|;
name|wpi_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Load firmware boot code. */
name|error
operator|=
name|wpi_load_bootcode
argument_list|(
name|sc
argument_list|,
name|fw
operator|->
name|boot
operator|.
name|text
argument_list|,
name|fw
operator|->
name|boot
operator|.
name|textsz
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not load boot firmware\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Now press "execute". */
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_RESET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Wait at most one second for first alive notification. */
if|if
condition|(
operator|(
name|error
operator|=
name|msleep
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
name|PCATCH
argument_list|,
literal|"wpiinit"
argument_list|,
name|hz
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: timeout waiting for adapter to initialize, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Copy runtime sections into pre-allocated DMA-safe memory. */
name|memcpy
argument_list|(
name|dma
operator|->
name|vaddr
argument_list|,
name|fw
operator|->
expr|main
operator|.
name|data
argument_list|,
name|fw
operator|->
expr|main
operator|.
name|datasz
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
name|dma
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dma
operator|->
name|vaddr
operator|+
name|WPI_FW_DATA_MAXSZ
argument_list|,
name|fw
operator|->
expr|main
operator|.
name|text
argument_list|,
name|fw
operator|->
expr|main
operator|.
name|textsz
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
name|dma
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* Tell adapter where to find runtime sections. */
if|if
condition|(
operator|(
name|error
operator|=
name|wpi_nic_lock
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|wpi_prph_write
argument_list|(
name|sc
argument_list|,
name|WPI_BSM_DRAM_DATA_ADDR
argument_list|,
name|dma
operator|->
name|paddr
argument_list|)
expr_stmt|;
name|wpi_prph_write
argument_list|(
name|sc
argument_list|,
name|WPI_BSM_DRAM_DATA_SIZE
argument_list|,
name|fw
operator|->
expr|main
operator|.
name|datasz
argument_list|)
expr_stmt|;
name|wpi_prph_write
argument_list|(
name|sc
argument_list|,
name|WPI_BSM_DRAM_TEXT_ADDR
argument_list|,
name|dma
operator|->
name|paddr
operator|+
name|WPI_FW_DATA_MAXSZ
argument_list|)
expr_stmt|;
name|wpi_prph_write
argument_list|(
name|sc
argument_list|,
name|WPI_BSM_DRAM_TEXT_SIZE
argument_list|,
name|WPI_FW_UPDATED
operator||
name|fw
operator|->
expr|main
operator|.
name|textsz
argument_list|)
expr_stmt|;
name|wpi_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wpi_read_firmware
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|const
name|struct
name|firmware
modifier|*
name|fp
decl_stmt|;
name|struct
name|wpi_fw_info
modifier|*
name|fw
init|=
operator|&
name|sc
operator|->
name|fw
decl_stmt|;
specifier|const
name|struct
name|wpi_firmware_hdr
modifier|*
name|hdr
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_DOING
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_FIRMWARE
argument_list|,
literal|"Attempting Loading Firmware from %s module\n"
argument_list|,
name|WPI_FW_NAME
argument_list|)
expr_stmt|;
name|WPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|fp
operator|=
name|firmware_get
argument_list|(
name|WPI_FW_NAME
argument_list|)
expr_stmt|;
name|WPI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not load firmware image '%s'\n"
argument_list|,
name|WPI_FW_NAME
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|sc
operator|->
name|fw_fp
operator|=
name|fp
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|datasize
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|wpi_firmware_hdr
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"firmware file too short: %zu bytes\n"
argument_list|,
name|fp
operator|->
name|datasize
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|fw
operator|->
name|size
operator|=
name|fp
operator|->
name|datasize
expr_stmt|;
name|fw
operator|->
name|data
operator|=
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
name|fp
operator|->
name|data
expr_stmt|;
comment|/* Extract firmware header information. */
name|hdr
operator|=
operator|(
specifier|const
expr|struct
name|wpi_firmware_hdr
operator|*
operator|)
name|fw
operator|->
name|data
expr_stmt|;
comment|/*     |  RUNTIME FIRMWARE   |    INIT FIRMWARE    | BOOT FW  | 	   |HDR|<--TEXT-->|<--DATA-->|<--TEXT-->|<--DATA-->|<--TEXT-->| */
name|fw
operator|->
expr|main
operator|.
name|textsz
operator|=
name|le32toh
argument_list|(
name|hdr
operator|->
name|rtextsz
argument_list|)
expr_stmt|;
name|fw
operator|->
expr|main
operator|.
name|datasz
operator|=
name|le32toh
argument_list|(
name|hdr
operator|->
name|rdatasz
argument_list|)
expr_stmt|;
name|fw
operator|->
name|init
operator|.
name|textsz
operator|=
name|le32toh
argument_list|(
name|hdr
operator|->
name|itextsz
argument_list|)
expr_stmt|;
name|fw
operator|->
name|init
operator|.
name|datasz
operator|=
name|le32toh
argument_list|(
name|hdr
operator|->
name|idatasz
argument_list|)
expr_stmt|;
name|fw
operator|->
name|boot
operator|.
name|textsz
operator|=
name|le32toh
argument_list|(
name|hdr
operator|->
name|btextsz
argument_list|)
expr_stmt|;
name|fw
operator|->
name|boot
operator|.
name|datasz
operator|=
literal|0
expr_stmt|;
comment|/* Sanity-check firmware header. */
if|if
condition|(
name|fw
operator|->
expr|main
operator|.
name|textsz
operator|>
name|WPI_FW_TEXT_MAXSZ
operator|||
name|fw
operator|->
expr|main
operator|.
name|datasz
operator|>
name|WPI_FW_DATA_MAXSZ
operator|||
name|fw
operator|->
name|init
operator|.
name|textsz
operator|>
name|WPI_FW_TEXT_MAXSZ
operator|||
name|fw
operator|->
name|init
operator|.
name|datasz
operator|>
name|WPI_FW_DATA_MAXSZ
operator|||
name|fw
operator|->
name|boot
operator|.
name|textsz
operator|>
name|WPI_FW_BOOT_TEXT_MAXSZ
operator|||
operator|(
name|fw
operator|->
name|boot
operator|.
name|textsz
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"invalid firmware header\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Check that all firmware sections fit. */
if|if
condition|(
name|fw
operator|->
name|size
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|+
name|fw
operator|->
expr|main
operator|.
name|textsz
operator|+
name|fw
operator|->
expr|main
operator|.
name|datasz
operator|+
name|fw
operator|->
name|init
operator|.
name|textsz
operator|+
name|fw
operator|->
name|init
operator|.
name|datasz
operator|+
name|fw
operator|->
name|boot
operator|.
name|textsz
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"firmware file too short: %zu bytes\n"
argument_list|,
name|fw
operator|->
name|size
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Get pointers to firmware sections. */
name|fw
operator|->
expr|main
operator|.
name|text
operator|=
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
operator|(
name|hdr
operator|+
literal|1
operator|)
expr_stmt|;
name|fw
operator|->
expr|main
operator|.
name|data
operator|=
name|fw
operator|->
expr|main
operator|.
name|text
operator|+
name|fw
operator|->
expr|main
operator|.
name|textsz
expr_stmt|;
name|fw
operator|->
name|init
operator|.
name|text
operator|=
name|fw
operator|->
expr|main
operator|.
name|data
operator|+
name|fw
operator|->
expr|main
operator|.
name|datasz
expr_stmt|;
name|fw
operator|->
name|init
operator|.
name|data
operator|=
name|fw
operator|->
name|init
operator|.
name|text
operator|+
name|fw
operator|->
name|init
operator|.
name|textsz
expr_stmt|;
name|fw
operator|->
name|boot
operator|.
name|text
operator|=
name|fw
operator|->
name|init
operator|.
name|data
operator|+
name|fw
operator|->
name|init
operator|.
name|datasz
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_FIRMWARE
argument_list|,
literal|"Firmware Version: Major %d, Minor %d, Driver %d, \n"
literal|"runtime (text: %u, data: %u) init (text: %u, data %u) boot (text %u)\n"
argument_list|,
name|hdr
operator|->
name|major
argument_list|,
name|hdr
operator|->
name|minor
argument_list|,
name|le32toh
argument_list|(
name|hdr
operator|->
name|driver
argument_list|)
argument_list|,
name|fw
operator|->
expr|main
operator|.
name|textsz
argument_list|,
name|fw
operator|->
expr|main
operator|.
name|datasz
argument_list|,
name|fw
operator|->
name|init
operator|.
name|textsz
argument_list|,
name|fw
operator|->
name|init
operator|.
name|datasz
argument_list|,
name|fw
operator|->
name|boot
operator|.
name|textsz
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_FIRMWARE
argument_list|,
literal|"fw->main.text %p\n"
argument_list|,
name|fw
operator|->
expr|main
operator|.
name|text
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_FIRMWARE
argument_list|,
literal|"fw->main.data %p\n"
argument_list|,
name|fw
operator|->
expr|main
operator|.
name|data
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_FIRMWARE
argument_list|,
literal|"fw->init.text %p\n"
argument_list|,
name|fw
operator|->
name|init
operator|.
name|text
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_FIRMWARE
argument_list|,
literal|"fw->init.data %p\n"
argument_list|,
name|fw
operator|->
name|init
operator|.
name|data
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_FIRMWARE
argument_list|,
literal|"fw->boot.text %p\n"
argument_list|,
name|fw
operator|->
name|boot
operator|.
name|text
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|fail
label|:
name|wpi_unload_firmware
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/**  * Free the referenced firmware image  */
end_comment

begin_function
specifier|static
name|void
name|wpi_unload_firmware
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|fw_fp
operator|!=
name|NULL
condition|)
block|{
name|firmware_put
argument_list|(
name|sc
operator|->
name|fw_fp
argument_list|,
name|FIRMWARE_UNLOAD
argument_list|)
expr_stmt|;
name|sc
operator|->
name|fw_fp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|wpi_clock_wait
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|ntries
decl_stmt|;
comment|/* Set "initialization complete" bit. */
name|WPI_SETBITS
argument_list|(
name|sc
argument_list|,
name|WPI_GP_CNTRL
argument_list|,
name|WPI_GP_CNTRL_INIT_DONE
argument_list|)
expr_stmt|;
comment|/* Wait for clock stabilization. */
for|for
control|(
name|ntries
operator|=
literal|0
init|;
name|ntries
operator|<
literal|2500
condition|;
name|ntries
operator|++
control|)
block|{
if|if
condition|(
name|WPI_READ
argument_list|(
name|sc
argument_list|,
name|WPI_GP_CNTRL
argument_list|)
operator|&
name|WPI_GP_CNTRL_MAC_CLOCK_READY
condition|)
return|return
literal|0
return|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: timeout waiting for clock stabilization\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|ETIMEDOUT
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wpi_apm_init
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_DOING
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Disable L0s exit timer (NMI bug workaround). */
name|WPI_SETBITS
argument_list|(
name|sc
argument_list|,
name|WPI_GIO_CHICKEN
argument_list|,
name|WPI_GIO_CHICKEN_DIS_L0S_TIMER
argument_list|)
expr_stmt|;
comment|/* Don't wait for ICH L0s (ICH bug workaround). */
name|WPI_SETBITS
argument_list|(
name|sc
argument_list|,
name|WPI_GIO_CHICKEN
argument_list|,
name|WPI_GIO_CHICKEN_L1A_NO_L0S_RX
argument_list|)
expr_stmt|;
comment|/* Set FH wait threshold to max (HW bug under stress workaround). */
name|WPI_SETBITS
argument_list|(
name|sc
argument_list|,
name|WPI_DBG_HPET_MEM
argument_list|,
literal|0xffff0000
argument_list|)
expr_stmt|;
comment|/* Retrieve PCIe Active State Power Management (ASPM). */
name|reg
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|sc
operator|->
name|sc_cap_off
operator|+
literal|0x10
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Workaround for HW instability in PCIe L0->L0s->L1 transition. */
if|if
condition|(
name|reg
operator|&
literal|0x02
condition|)
comment|/* L1 Entry enabled. */
name|WPI_SETBITS
argument_list|(
name|sc
argument_list|,
name|WPI_GIO
argument_list|,
name|WPI_GIO_L0S_ENA
argument_list|)
expr_stmt|;
else|else
name|WPI_CLRBITS
argument_list|(
name|sc
argument_list|,
name|WPI_GIO
argument_list|,
name|WPI_GIO_L0S_ENA
argument_list|)
expr_stmt|;
name|WPI_SETBITS
argument_list|(
name|sc
argument_list|,
name|WPI_ANA_PLL
argument_list|,
name|WPI_ANA_PLL_INIT
argument_list|)
expr_stmt|;
comment|/* Wait for clock stabilization before accessing prph. */
if|if
condition|(
operator|(
name|error
operator|=
name|wpi_clock_wait
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|wpi_nic_lock
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
comment|/* Enable DMA and BSM (Bootstrap State Machine). */
name|wpi_prph_write
argument_list|(
name|sc
argument_list|,
name|WPI_APMG_CLK_EN
argument_list|,
name|WPI_APMG_CLK_CTRL_DMA_CLK_RQT
operator||
name|WPI_APMG_CLK_CTRL_BSM_CLK_RQT
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|20
argument_list|)
expr_stmt|;
comment|/* Disable L1-Active. */
name|wpi_prph_setbits
argument_list|(
name|sc
argument_list|,
name|WPI_APMG_PCI_STT
argument_list|,
name|WPI_APMG_PCI_STT_L1A_DIS
argument_list|)
expr_stmt|;
name|wpi_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_apm_stop_master
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|ntries
decl_stmt|;
comment|/* Stop busmaster DMA activity. */
name|WPI_SETBITS
argument_list|(
name|sc
argument_list|,
name|WPI_RESET
argument_list|,
name|WPI_RESET_STOP_MASTER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|WPI_READ
argument_list|(
name|sc
argument_list|,
name|WPI_GP_CNTRL
argument_list|)
operator|&
name|WPI_GP_CNTRL_PS_MASK
operator|)
operator|==
name|WPI_GP_CNTRL_MAC_PS
condition|)
return|return;
comment|/* Already asleep. */
for|for
control|(
name|ntries
operator|=
literal|0
init|;
name|ntries
operator|<
literal|100
condition|;
name|ntries
operator|++
control|)
block|{
if|if
condition|(
name|WPI_READ
argument_list|(
name|sc
argument_list|,
name|WPI_RESET
argument_list|)
operator|&
name|WPI_RESET_MASTER_DISABLED
condition|)
return|return;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: timeout waiting for master\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_apm_stop
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|wpi_apm_stop_master
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Reset the entire device. */
name|WPI_SETBITS
argument_list|(
name|sc
argument_list|,
name|WPI_RESET
argument_list|,
name|WPI_RESET_SW
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* Clear "initialization complete" bit. */
name|WPI_CLRBITS
argument_list|(
name|sc
argument_list|,
name|WPI_GP_CNTRL
argument_list|,
name|WPI_GP_CNTRL_INIT_DONE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_nic_config
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|rev
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_DOING
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* voodoo from the Linux "driver".. */
name|rev
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|PCIR_REVID
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rev
operator|&
literal|0xc0
operator|)
operator|==
literal|0x40
condition|)
name|WPI_SETBITS
argument_list|(
name|sc
argument_list|,
name|WPI_HW_IF_CONFIG
argument_list|,
name|WPI_HW_IF_CONFIG_ALM_MB
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|rev
operator|&
literal|0x80
operator|)
condition|)
name|WPI_SETBITS
argument_list|(
name|sc
argument_list|,
name|WPI_HW_IF_CONFIG
argument_list|,
name|WPI_HW_IF_CONFIG_ALM_MM
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|cap
operator|==
literal|0x80
condition|)
name|WPI_SETBITS
argument_list|(
name|sc
argument_list|,
name|WPI_HW_IF_CONFIG
argument_list|,
name|WPI_HW_IF_CONFIG_SKU_MRC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|le16toh
argument_list|(
name|sc
operator|->
name|rev
argument_list|)
operator|&
literal|0xf0
operator|)
operator|==
literal|0xd0
condition|)
name|WPI_SETBITS
argument_list|(
name|sc
argument_list|,
name|WPI_HW_IF_CONFIG
argument_list|,
name|WPI_HW_IF_CONFIG_REV_D
argument_list|)
expr_stmt|;
else|else
name|WPI_CLRBITS
argument_list|(
name|sc
argument_list|,
name|WPI_HW_IF_CONFIG
argument_list|,
name|WPI_HW_IF_CONFIG_REV_D
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|type
operator|>
literal|1
condition|)
name|WPI_SETBITS
argument_list|(
name|sc
argument_list|,
name|WPI_HW_IF_CONFIG
argument_list|,
name|WPI_HW_IF_CONFIG_TYPE_B
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|wpi_hw_init
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|chnl
decl_stmt|,
name|ntries
decl_stmt|,
name|error
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_BEGIN
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Clear pending interrupts. */
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_INT
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|wpi_apm_init
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not power ON adapter, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Select VMAIN power source. */
if|if
condition|(
operator|(
name|error
operator|=
name|wpi_nic_lock
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|wpi_prph_clrbits
argument_list|(
name|sc
argument_list|,
name|WPI_APMG_PS
argument_list|,
name|WPI_APMG_PS_PWR_SRC_MASK
argument_list|)
expr_stmt|;
name|wpi_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Spin until VMAIN gets selected. */
for|for
control|(
name|ntries
operator|=
literal|0
init|;
name|ntries
operator|<
literal|5000
condition|;
name|ntries
operator|++
control|)
block|{
if|if
condition|(
name|WPI_READ
argument_list|(
name|sc
argument_list|,
name|WPI_GPIO_IN
argument_list|)
operator|&
name|WPI_GPIO_IN_VMAIN
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ntries
operator|==
literal|5000
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"timeout selecting power source\n"
argument_list|)
expr_stmt|;
return|return
name|ETIMEDOUT
return|;
block|}
comment|/* Perform adapter initialization. */
name|wpi_nic_config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Initialize RX ring. */
if|if
condition|(
operator|(
name|error
operator|=
name|wpi_nic_lock
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
comment|/* Set physical address of RX ring. */
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_FH_RX_BASE
argument_list|,
name|sc
operator|->
name|rxq
operator|.
name|desc_dma
operator|.
name|paddr
argument_list|)
expr_stmt|;
comment|/* Set physical address of RX read pointer. */
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_FH_RX_RPTR_ADDR
argument_list|,
name|sc
operator|->
name|shared_dma
operator|.
name|paddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|wpi_shared
argument_list|,
name|next
argument_list|)
argument_list|)
expr_stmt|;
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_FH_RX_WPTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Enable RX. */
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_FH_RX_CONFIG
argument_list|,
name|WPI_FH_RX_CONFIG_DMA_ENA
operator||
name|WPI_FH_RX_CONFIG_RDRBD_ENA
operator||
name|WPI_FH_RX_CONFIG_WRSTATUS_ENA
operator||
name|WPI_FH_RX_CONFIG_MAXFRAG
operator||
name|WPI_FH_RX_CONFIG_NRBD
argument_list|(
name|WPI_RX_RING_COUNT_LOG
argument_list|)
operator||
name|WPI_FH_RX_CONFIG_IRQ_DST_HOST
operator||
name|WPI_FH_RX_CONFIG_IRQ_TIMEOUT
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|WPI_READ
argument_list|(
name|sc
argument_list|,
name|WPI_FH_RSSR_TBL
argument_list|)
expr_stmt|;
comment|/* barrier */
name|wpi_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_FH_RX_WPTR
argument_list|,
operator|(
name|WPI_RX_RING_COUNT
operator|-
literal|1
operator|)
operator|&
operator|~
literal|7
argument_list|)
expr_stmt|;
comment|/* Initialize TX rings. */
if|if
condition|(
operator|(
name|error
operator|=
name|wpi_nic_lock
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|wpi_prph_write
argument_list|(
name|sc
argument_list|,
name|WPI_ALM_SCHED_MODE
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* bypass mode */
name|wpi_prph_write
argument_list|(
name|sc
argument_list|,
name|WPI_ALM_SCHED_ARASTAT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* enable RA0 */
comment|/* Enable all 6 TX rings. */
name|wpi_prph_write
argument_list|(
name|sc
argument_list|,
name|WPI_ALM_SCHED_TXFACT
argument_list|,
literal|0x3f
argument_list|)
expr_stmt|;
name|wpi_prph_write
argument_list|(
name|sc
argument_list|,
name|WPI_ALM_SCHED_SBYPASS_MODE1
argument_list|,
literal|0x10000
argument_list|)
expr_stmt|;
name|wpi_prph_write
argument_list|(
name|sc
argument_list|,
name|WPI_ALM_SCHED_SBYPASS_MODE2
argument_list|,
literal|0x30002
argument_list|)
expr_stmt|;
name|wpi_prph_write
argument_list|(
name|sc
argument_list|,
name|WPI_ALM_SCHED_TXF4MF
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|wpi_prph_write
argument_list|(
name|sc
argument_list|,
name|WPI_ALM_SCHED_TXF5MF
argument_list|,
literal|5
argument_list|)
expr_stmt|;
comment|/* Set physical address of TX rings. */
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_FH_TX_BASE
argument_list|,
name|sc
operator|->
name|shared_dma
operator|.
name|paddr
argument_list|)
expr_stmt|;
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_FH_MSG_CONFIG
argument_list|,
literal|0xffff05a5
argument_list|)
expr_stmt|;
comment|/* Enable all DMA channels. */
for|for
control|(
name|chnl
operator|=
literal|0
init|;
name|chnl
operator|<
name|WPI_NDMACHNLS
condition|;
name|chnl
operator|++
control|)
block|{
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_FH_CBBC_CTRL
argument_list|(
name|chnl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_FH_CBBC_BASE
argument_list|(
name|chnl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_FH_TX_CONFIG
argument_list|(
name|chnl
argument_list|)
argument_list|,
literal|0x80200008
argument_list|)
expr_stmt|;
block|}
name|wpi_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|WPI_READ
argument_list|(
name|sc
argument_list|,
name|WPI_FH_TX_BASE
argument_list|)
expr_stmt|;
comment|/* barrier */
comment|/* Clear "radio off" and "commands blocked" bits. */
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_UCODE_GP1_CLR
argument_list|,
name|WPI_UCODE_GP1_RFKILL
argument_list|)
expr_stmt|;
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_UCODE_GP1_CLR
argument_list|,
name|WPI_UCODE_GP1_CMD_BLOCKED
argument_list|)
expr_stmt|;
comment|/* Clear pending interrupts. */
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_INT
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
comment|/* Enable interrupts. */
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_INT_MASK
argument_list|,
name|WPI_INT_MASK_DEF
argument_list|)
expr_stmt|;
comment|/* _Really_ make sure "radio off" bit is cleared! */
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_UCODE_GP1_CLR
argument_list|,
name|WPI_UCODE_GP1_RFKILL
argument_list|)
expr_stmt|;
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_UCODE_GP1_CLR
argument_list|,
name|WPI_UCODE_GP1_RFKILL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|wpi_load_firmware
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not load firmware, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Wait at most one second for firmware alive notification. */
if|if
condition|(
operator|(
name|error
operator|=
name|msleep
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
name|PCATCH
argument_list|,
literal|"wpiinit"
argument_list|,
name|hz
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: timeout waiting for adapter to initialize, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_END
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Do post-firmware initialization. */
return|return
name|wpi_post_alive
argument_list|(
name|sc
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_hw_stop
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|chnl
decl_stmt|,
name|qid
decl_stmt|,
name|ntries
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_DOING
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|WPI_READ
argument_list|(
name|sc
argument_list|,
name|WPI_UCODE_GP1
argument_list|)
operator|&
name|WPI_UCODE_GP1_MAC_SLEEP
condition|)
name|wpi_nic_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_RESET
argument_list|,
name|WPI_RESET_NEVO
argument_list|)
expr_stmt|;
comment|/* Disable interrupts. */
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_INT_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_INT
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_FH_INT
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
comment|/* Make sure we no longer hold the NIC lock. */
name|wpi_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpi_nic_lock
argument_list|(
name|sc
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Stop TX scheduler. */
name|wpi_prph_write
argument_list|(
name|sc
argument_list|,
name|WPI_ALM_SCHED_MODE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wpi_prph_write
argument_list|(
name|sc
argument_list|,
name|WPI_ALM_SCHED_TXFACT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Stop all DMA channels. */
for|for
control|(
name|chnl
operator|=
literal|0
init|;
name|chnl
operator|<
name|WPI_NDMACHNLS
condition|;
name|chnl
operator|++
control|)
block|{
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_FH_TX_CONFIG
argument_list|(
name|chnl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|ntries
operator|=
literal|0
init|;
name|ntries
operator|<
literal|200
condition|;
name|ntries
operator|++
control|)
block|{
if|if
condition|(
name|WPI_READ
argument_list|(
name|sc
argument_list|,
name|WPI_FH_TX_STATUS
argument_list|)
operator|&
name|WPI_FH_TX_STATUS_IDLE
argument_list|(
name|chnl
argument_list|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
block|}
name|wpi_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* Stop RX ring. */
name|wpi_reset_rx_ring
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Reset all TX rings. */
for|for
control|(
name|qid
operator|=
literal|0
init|;
name|qid
operator|<
name|WPI_NTXQUEUES
condition|;
name|qid
operator|++
control|)
name|wpi_reset_tx_ring
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|txq
index|[
name|qid
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpi_nic_lock
argument_list|(
name|sc
argument_list|)
operator|==
literal|0
condition|)
block|{
name|wpi_prph_write
argument_list|(
name|sc
argument_list|,
name|WPI_APMG_CLK_DIS
argument_list|,
name|WPI_APMG_CLK_CTRL_DMA_CLK_RQT
argument_list|)
expr_stmt|;
name|wpi_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
comment|/* Power OFF adapter. */
name|wpi_apm_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_radio_on
parameter_list|(
name|void
modifier|*
name|arg0
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|wpi_softc
modifier|*
name|sc
init|=
name|arg0
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
decl_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"RF switch: radio enabled\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|!=
name|NULL
condition|)
block|{
name|wpi_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ieee80211_init
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|WPI_READ
argument_list|(
name|sc
argument_list|,
name|WPI_GP_CNTRL
argument_list|)
operator|&
name|WPI_GP_CNTRL_RFKILL
condition|)
block|{
name|WPI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|watchdog_rfkill
argument_list|)
expr_stmt|;
name|WPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_radio_off
parameter_list|(
name|void
modifier|*
name|arg0
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|wpi_softc
modifier|*
name|sc
init|=
name|arg0
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
decl_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"RF switch: radio disabled\n"
argument_list|)
expr_stmt|;
name|wpi_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|!=
name|NULL
condition|)
name|ieee80211_stop
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|watchdog_rfkill
argument_list|,
name|hz
argument_list|,
name|wpi_watchdog_rfkill
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_init_locked
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_BEGIN
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|WPI_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Check that the radio is not disabled by hardware switch. */
if|if
condition|(
operator|!
operator|(
name|WPI_READ
argument_list|(
name|sc
argument_list|,
name|WPI_GP_CNTRL
argument_list|)
operator|&
name|WPI_GP_CNTRL_RFKILL
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"RF switch: radio disabled (%s)\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|watchdog_rfkill
argument_list|,
name|hz
argument_list|,
name|wpi_watchdog_rfkill
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Read firmware images from the filesystem. */
if|if
condition|(
operator|(
name|error
operator|=
name|wpi_read_firmware
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not read firmware, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Initialize hardware and upload firmware. */
name|error
operator|=
name|wpi_hw_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|wpi_unload_firmware
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not initialize hardware, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Configure adapter now that it is ready. */
if|if
condition|(
operator|(
name|error
operator|=
name|wpi_config
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not configure device, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|watchdog_to
argument_list|,
name|hz
argument_list|,
name|wpi_watchdog
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_END
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
name|fail
label|:
name|wpi_stop_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_END_ERR
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|wpi_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|WPI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|wpi_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|WPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|ieee80211_start_all
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_stop_locked
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|WPI_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_scan_timer
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_tx_timer
operator|=
literal|0
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|watchdog_to
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|calib_to
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
comment|/* Power OFF hardware. */
name|wpi_hw_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_stop
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|WPI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|wpi_stop_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|WPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Callback from net80211 to start a scan.  */
end_comment

begin_function
specifier|static
name|void
name|wpi_scan_start
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|wpi_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|WPI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|wpi_set_led
argument_list|(
name|sc
argument_list|,
name|WPI_LED_LINK
argument_list|,
literal|20
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|WPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Callback from net80211 to terminate a scan.  */
end_comment

begin_function
specifier|static
name|void
name|wpi_scan_end
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|wpi_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
decl_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_RUN
condition|)
block|{
name|WPI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|wpi_set_led
argument_list|(
name|sc
argument_list|,
name|WPI_LED_LINK
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|WPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Called by the net80211 framework to indicate to the driver  * that the channel should be changed  */
end_comment

begin_function
specifier|static
name|void
name|wpi_set_channel
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|c
init|=
name|ic
operator|->
name|ic_curchan
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|wpi_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_DOING
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|WPI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rxtap
operator|.
name|wr_chan_freq
operator|=
name|htole16
argument_list|(
name|c
operator|->
name|ic_freq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rxtap
operator|.
name|wr_chan_flags
operator|=
name|htole16
argument_list|(
name|c
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txtap
operator|.
name|wt_chan_freq
operator|=
name|htole16
argument_list|(
name|c
operator|->
name|ic_freq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txtap
operator|.
name|wt_chan_flags
operator|=
name|htole16
argument_list|(
name|c
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
comment|/* 	 * Only need to set the channel in Monitor mode. AP scanning and auth 	 * are already taken care of by their respective firmware commands. 	 */
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_MONITOR
condition|)
block|{
name|sc
operator|->
name|rxon
operator|.
name|chan
operator|=
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|sc
operator|->
name|rxon
operator|.
name|flags
operator||=
name|htole32
argument_list|(
name|WPI_RXON_AUTO
operator||
name|WPI_RXON_24GHZ
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|rxon
operator|.
name|flags
operator|&=
operator|~
name|htole32
argument_list|(
name|WPI_RXON_AUTO
operator||
name|WPI_RXON_24GHZ
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|wpi_send_rxon
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: error %d settting channel\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|WPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Called by net80211 to indicate that we need to scan the current  * channel. The channel is previously be set via the wpi_set_channel  * callback.  */
end_comment

begin_function
specifier|static
name|void
name|wpi_scan_curchan
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|,
name|unsigned
name|long
name|maxdwell
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ss
operator|->
name|ss_vap
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|wpi_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|rxon
operator|.
name|chan
operator|!=
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
condition|)
block|{
name|WPI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|wpi_scan
argument_list|(
name|sc
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
name|WPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|ieee80211_cancel_scan
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Send probe request when associated. */
name|sc
operator|->
name|sc_scan_curchan
argument_list|(
name|ss
argument_list|,
name|maxdwell
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Called by the net80211 framework to indicate  * the minimum dwell time has been met, terminate the scan.  * We don't actually terminate the scan as the firmware will notify  * us when it's finished and we have no way to interrupt it.  */
end_comment

begin_function
specifier|static
name|void
name|wpi_scan_mindwell
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|)
block|{
comment|/* NB: don't try to abort scan; wait for firmware to finish */
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_hw_reset
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|wpi_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|WPI_DEBUG_TRACE
argument_list|,
name|TRACE_STR_DOING
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|wpi_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|!=
name|NULL
condition|)
name|ieee80211_stop
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|wpi_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|!=
name|NULL
condition|)
name|ieee80211_init
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

