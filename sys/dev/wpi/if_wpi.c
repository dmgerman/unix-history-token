begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2006,2007  *	Damien Bergamini<damien.bergamini@free.fr>  *	Benjamin Close<Benjamin.Close@clearchain.com>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_define
define|#
directive|define
name|VERSION
value|"20071127"
end_define

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Driver for Intel PRO/Wireless 3945ABG 802.11 network adapters.  *  * The 3945ABG network adapter doesn't use traditional hardware as  * many other adaptors do. Instead at run time the eeprom is set into a known  * state and told to load boot firmware. The boot firmware loads an init and a  * main  binary firmware image into SRAM on the card via DMA.  * Once the firmware is loaded, the driver/hw then  * communicate by way of circular dma rings via the SRAM to the firmware.  *  * There is 6 memory rings. 1 command ring, 1 rx data ring& 4 tx data rings.  * The 4 tx data rings allow for prioritization QoS.  *  * The rx data ring consists of 32 dma buffers. Two registers are used to  * indicate where in the ring the driver and the firmware are up to. The  * driver sets the initial read index (reg1) and the initial write index (reg2),  * the firmware updates the read index (reg1) on rx of a packet and fires an  * interrupt. The driver then processes the buffers starting at reg1 indicating  * to the firmware which buffers have been accessed by updating reg2. At the  * same time allocating new memory for the processed buffer.  *  * A similar thing happens with the tx rings. The difference is the firmware  * stop processing buffers once the queue is full and until confirmation  * of a successful transmition (tx_intr) has occurred.  *  * The command ring operates in the same manner as the tx queues.  *  * All communication direct to the card (ie eeprom) is classed as Stage1  * communication  *  * All communication via the firmware to the card is classed as State2.  * The firmware consists of 2 parts. A bootstrap firmware and a runtime  * firmware. The bootstrap firmware and runtime firmware are loaded  * from host memory via dma to the card then told to execute. From this point  * on the majority of communications between the driver and the card goes  * via the firmware.  */
end_comment

begin_include
include|#
directive|include
file|"opt_wlan.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/firmware.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_radiotap.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_regdomain.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_ratectl.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<dev/wpi/if_wpireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/wpi/if_wpivar.h>
end_include

begin_define
define|#
directive|define
name|WPI_DEBUG
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|WPI_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|x
parameter_list|)
value|do { if (wpi_debug != 0) printf x; } while (0)
end_define

begin_define
define|#
directive|define
name|DPRINTFN
parameter_list|(
name|n
parameter_list|,
name|x
parameter_list|)
value|do { if (wpi_debug& n) printf x; } while (0)
end_define

begin_define
define|#
directive|define
name|WPI_DEBUG_SET
value|(wpi_debug != 0)
end_define

begin_enum
enum|enum
block|{
name|WPI_DEBUG_UNUSED
init|=
literal|0x00000001
block|,
comment|/* Unused */
name|WPI_DEBUG_HW
init|=
literal|0x00000002
block|,
comment|/* Stage 1 (eeprom) debugging */
name|WPI_DEBUG_TX
init|=
literal|0x00000004
block|,
comment|/* Stage 2 TX intrp debugging*/
name|WPI_DEBUG_RX
init|=
literal|0x00000008
block|,
comment|/* Stage 2 RX intrp debugging */
name|WPI_DEBUG_CMD
init|=
literal|0x00000010
block|,
comment|/* Stage 2 CMD intrp debugging*/
name|WPI_DEBUG_FIRMWARE
init|=
literal|0x00000020
block|,
comment|/* firmware(9) loading debug  */
name|WPI_DEBUG_DMA
init|=
literal|0x00000040
block|,
comment|/* DMA (de)allocations/syncs  */
name|WPI_DEBUG_SCANNING
init|=
literal|0x00000080
block|,
comment|/* Stage 2 Scanning debugging */
name|WPI_DEBUG_NOTIFY
init|=
literal|0x00000100
block|,
comment|/* State 2 Noftif intr debug */
name|WPI_DEBUG_TEMP
init|=
literal|0x00000200
block|,
comment|/* TXPower/Temp Calibration */
name|WPI_DEBUG_OPS
init|=
literal|0x00000400
block|,
comment|/* wpi_ops taskq debug */
name|WPI_DEBUG_WATCHDOG
init|=
literal|0x00000800
block|,
comment|/* Watch dog debug */
name|WPI_DEBUG_ANY
init|=
literal|0xffffffff
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|int
name|wpi_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|wpi
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|wpi_debug
argument_list|,
literal|0
argument_list|,
literal|"wpi debug level"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"debug.wpi"
argument_list|,
operator|&
name|wpi_debug
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|x
parameter_list|)
end_define

begin_define
define|#
directive|define
name|DPRINTFN
parameter_list|(
name|n
parameter_list|,
name|x
parameter_list|)
end_define

begin_define
define|#
directive|define
name|WPI_DEBUG_SET
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|wpi_ident
block|{
name|uint16_t
name|vendor
decl_stmt|;
name|uint16_t
name|device
decl_stmt|;
name|uint16_t
name|subdevice
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|wpi_ident
name|wpi_ident_table
index|[]
init|=
block|{
comment|/* The below entries support ABG regardless of the subid */
block|{
literal|0x8086
block|,
literal|0x4222
block|,
literal|0x0
block|,
literal|"Intel(R) PRO/Wireless 3945ABG"
block|}
block|,
block|{
literal|0x8086
block|,
literal|0x4227
block|,
literal|0x0
block|,
literal|"Intel(R) PRO/Wireless 3945ABG"
block|}
block|,
comment|/* The below entries only support BG */
block|{
literal|0x8086
block|,
literal|0x4222
block|,
literal|0x1005
block|,
literal|"Intel(R) PRO/Wireless 3945BG"
block|}
block|,
block|{
literal|0x8086
block|,
literal|0x4222
block|,
literal|0x1034
block|,
literal|"Intel(R) PRO/Wireless 3945BG"
block|}
block|,
block|{
literal|0x8086
block|,
literal|0x4227
block|,
literal|0x1014
block|,
literal|"Intel(R) PRO/Wireless 3945BG"
block|}
block|,
block|{
literal|0x8086
block|,
literal|0x4222
block|,
literal|0x1044
block|,
literal|"Intel(R) PRO/Wireless 3945BG"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|struct
name|ieee80211vap
modifier|*
name|wpi_vap_create
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|,
specifier|const
name|char
index|[
name|IFNAMSIZ
index|]
parameter_list|,
name|int
parameter_list|,
name|enum
name|ieee80211_opmode
parameter_list|,
name|int
parameter_list|,
specifier|const
name|uint8_t
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|uint8_t
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_vap_delete
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_dma_contig_alloc
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|struct
name|wpi_dma_info
modifier|*
parameter_list|,
name|void
modifier|*
modifier|*
parameter_list|,
name|bus_size_t
parameter_list|,
name|bus_size_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_dma_contig_free
parameter_list|(
name|struct
name|wpi_dma_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_dma_map_addr
parameter_list|(
name|void
modifier|*
parameter_list|,
name|bus_dma_segment_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_alloc_shared
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_free_shared
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_alloc_rx_ring
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|struct
name|wpi_rx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_reset_rx_ring
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|struct
name|wpi_rx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_free_rx_ring
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|struct
name|wpi_rx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_alloc_tx_ring
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|struct
name|wpi_tx_ring
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_reset_tx_ring
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|struct
name|wpi_tx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_free_tx_ring
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|struct
name|wpi_tx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_newstate
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
name|enum
name|ieee80211_state
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_mem_lock
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_mem_unlock
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|wpi_mem_read
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_mem_write
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|uint16_t
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_mem_write_region_4
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|uint16_t
parameter_list|,
specifier|const
name|uint32_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint16_t
name|wpi_read_prom_data
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_alloc_fwmem
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_free_fwmem
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_load_firmware
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_unload_firmware
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_load_microcode
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
specifier|const
name|uint8_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_rx_intr
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|struct
name|wpi_rx_desc
modifier|*
parameter_list|,
name|struct
name|wpi_rx_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_tx_intr
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|struct
name|wpi_rx_desc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_cmd_intr
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|struct
name|wpi_rx_desc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_notif_intr
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|wpi_plcp_signal
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_watchdog
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_tx_data
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_raw_xmit
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
specifier|const
name|struct
name|ieee80211_bpf_params
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_scan_start
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_scan_end
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_set_channel
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_scan_curchan
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
parameter_list|,
name|unsigned
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_scan_mindwell
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_read_eeprom
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|uint8_t
name|macaddr
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_read_eeprom_channels
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_read_eeprom_group
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_cmd
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_wme_update
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_mrr_setup
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_set_led
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
name|uint8_t
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_enable_tsf
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int	wpi_setup_beacon(struct wpi_softc *, struct ieee80211_node *);
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|wpi_auth
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_run
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_scan
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_config
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_stop_master
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_power_up
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_reset
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_hwreset
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_rfreset
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_hw_config
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_init_locked
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_stop
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_stop_locked
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_set_txpower
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_calib_timeout
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpi_power_calibration
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_get_power_index
parameter_list|(
name|struct
name|wpi_softc
modifier|*
parameter_list|,
name|struct
name|wpi_power_group
modifier|*
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|WPI_DEBUG
end_ifdef

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|wpi_cmd_str
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|wpi_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_shutdown
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_suspend
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wpi_resume
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|wpi_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|wpi_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|wpi_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|wpi_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|wpi_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|wpi_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|wpi_resume
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|wpi_driver
init|=
block|{
literal|"wpi"
block|,
name|wpi_methods
block|,
expr|sizeof
operator|(
expr|struct
name|wpi_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|wpi_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|wpi
argument_list|,
name|pci
argument_list|,
name|wpi_driver
argument_list|,
name|wpi_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|wpi
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint8_t
name|wpi_ridx_to_plcp
index|[]
init|=
block|{
comment|/* OFDM: IEEE Std 802.11a-1999, pp. 14 Table 80 */
comment|/* R1-R4 (ral/ural is R4-R1) */
literal|0xd
block|,
literal|0xf
block|,
literal|0x5
block|,
literal|0x7
block|,
literal|0x9
block|,
literal|0xb
block|,
literal|0x1
block|,
literal|0x3
block|,
comment|/* CCK: device-dependent */
literal|10
block|,
literal|20
block|,
literal|55
block|,
literal|110
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint8_t
name|wpi_ridx_to_rate
index|[]
init|=
block|{
literal|12
block|,
literal|18
block|,
literal|24
block|,
literal|36
block|,
literal|48
block|,
literal|72
block|,
literal|96
block|,
literal|108
block|,
comment|/* OFDM */
literal|2
block|,
literal|4
block|,
literal|11
block|,
literal|22
comment|/*CCK */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|wpi_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
specifier|const
name|struct
name|wpi_ident
modifier|*
name|ident
decl_stmt|;
for|for
control|(
name|ident
operator|=
name|wpi_ident_table
init|;
name|ident
operator|->
name|name
operator|!=
name|NULL
condition|;
name|ident
operator|++
control|)
block|{
if|if
condition|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|==
name|ident
operator|->
name|vendor
operator|&&
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|ident
operator|->
name|device
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|ident
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
name|ENXIO
return|;
block|}
end_function

begin_comment
comment|/**  * Load the firmare image from disk to the allocated dma buffer.  * we also maintain the reference to the firmware pointer as there  * is times where we may need to reload the firmware but we are not  * in a context that can access the filesystem (ie taskq cause by restart)  *  * @return 0 on success, an errno on failure  */
end_comment

begin_function
specifier|static
name|int
name|wpi_load_firmware
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|const
name|struct
name|firmware
modifier|*
name|fp
decl_stmt|;
name|struct
name|wpi_dma_info
modifier|*
name|dma
init|=
operator|&
name|sc
operator|->
name|fw_dma
decl_stmt|;
specifier|const
name|struct
name|wpi_firmware_hdr
modifier|*
name|hdr
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|itext
decl_stmt|,
modifier|*
name|idata
decl_stmt|,
modifier|*
name|rtext
decl_stmt|,
modifier|*
name|rdata
decl_stmt|,
modifier|*
name|btext
decl_stmt|;
name|uint32_t
name|itextsz
decl_stmt|,
name|idatasz
decl_stmt|,
name|rtextsz
decl_stmt|,
name|rdatasz
decl_stmt|,
name|btextsz
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DPRINTFN
argument_list|(
name|WPI_DEBUG_FIRMWARE
argument_list|,
operator|(
literal|"Attempting Loading Firmware from wpi_fw module\n"
operator|)
argument_list|)
expr_stmt|;
name|WPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|fw_fp
operator|==
name|NULL
operator|&&
operator|(
name|sc
operator|->
name|fw_fp
operator|=
name|firmware_get
argument_list|(
literal|"wpifw"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not load firmware image 'wpifw'\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOENT
expr_stmt|;
name|WPI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|fp
operator|=
name|sc
operator|->
name|fw_fp
expr_stmt|;
name|WPI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Validate the firmware is minimum a particular version */
if|if
condition|(
name|fp
operator|->
name|version
operator|<
name|WPI_FW_MINVERSION
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"firmware version is too old. Need %d, got %d\n"
argument_list|,
name|WPI_FW_MINVERSION
argument_list|,
name|fp
operator|->
name|version
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|fp
operator|->
name|datasize
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|wpi_firmware_hdr
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"firmware file too short: %zu bytes\n"
argument_list|,
name|fp
operator|->
name|datasize
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|hdr
operator|=
operator|(
specifier|const
expr|struct
name|wpi_firmware_hdr
operator|*
operator|)
name|fp
operator|->
name|data
expr_stmt|;
comment|/*     |  RUNTIME FIRMWARE   |    INIT FIRMWARE    | BOOT FW  | 	   |HDR|<--TEXT-->|<--DATA-->|<--TEXT-->|<--DATA-->|<--TEXT-->| */
name|rtextsz
operator|=
name|le32toh
argument_list|(
name|hdr
operator|->
name|rtextsz
argument_list|)
expr_stmt|;
name|rdatasz
operator|=
name|le32toh
argument_list|(
name|hdr
operator|->
name|rdatasz
argument_list|)
expr_stmt|;
name|itextsz
operator|=
name|le32toh
argument_list|(
name|hdr
operator|->
name|itextsz
argument_list|)
expr_stmt|;
name|idatasz
operator|=
name|le32toh
argument_list|(
name|hdr
operator|->
name|idatasz
argument_list|)
expr_stmt|;
name|btextsz
operator|=
name|le32toh
argument_list|(
name|hdr
operator|->
name|btextsz
argument_list|)
expr_stmt|;
comment|/* check that all firmware segments are present */
if|if
condition|(
name|fp
operator|->
name|datasize
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|wpi_firmware_hdr
argument_list|)
operator|+
name|rtextsz
operator|+
name|rdatasz
operator|+
name|itextsz
operator|+
name|idatasz
operator|+
name|btextsz
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"firmware file too short: %zu bytes\n"
argument_list|,
name|fp
operator|->
name|datasize
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
comment|/* XXX appropriate error code? */
goto|goto
name|fail
goto|;
block|}
comment|/* get pointers to firmware segments */
name|rtext
operator|=
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
operator|(
name|hdr
operator|+
literal|1
operator|)
expr_stmt|;
name|rdata
operator|=
name|rtext
operator|+
name|rtextsz
expr_stmt|;
name|itext
operator|=
name|rdata
operator|+
name|rdatasz
expr_stmt|;
name|idata
operator|=
name|itext
operator|+
name|itextsz
expr_stmt|;
name|btext
operator|=
name|idata
operator|+
name|idatasz
expr_stmt|;
name|DPRINTFN
argument_list|(
name|WPI_DEBUG_FIRMWARE
argument_list|,
operator|(
literal|"Firmware Version: Major %d, Minor %d, Driver %d, \n"
literal|"runtime (text: %u, data: %u) init (text: %u, data %u) boot (text %u)\n"
operator|,
operator|(
name|le32toh
argument_list|(
name|hdr
operator|->
name|version
argument_list|)
operator|&
literal|0xff000000
operator|)
operator|>>
literal|24
operator|,
operator|(
name|le32toh
argument_list|(
name|hdr
operator|->
name|version
argument_list|)
operator|&
literal|0x00ff0000
operator|)
operator|>>
literal|16
operator|,
operator|(
name|le32toh
argument_list|(
name|hdr
operator|->
name|version
argument_list|)
operator|&
literal|0x0000ffff
operator|)
operator|,
name|rtextsz
operator|,
name|rdatasz
operator|,
name|itextsz
operator|,
name|idatasz
operator|,
name|btextsz
operator|)
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
name|WPI_DEBUG_FIRMWARE
argument_list|,
operator|(
literal|"rtext 0x%x\n"
operator|,
operator|*
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|rtext
operator|)
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
name|WPI_DEBUG_FIRMWARE
argument_list|,
operator|(
literal|"rdata 0x%x\n"
operator|,
operator|*
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|rdata
operator|)
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
name|WPI_DEBUG_FIRMWARE
argument_list|,
operator|(
literal|"itext 0x%x\n"
operator|,
operator|*
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|itext
operator|)
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
name|WPI_DEBUG_FIRMWARE
argument_list|,
operator|(
literal|"idata 0x%x\n"
operator|,
operator|*
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|idata
operator|)
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
name|WPI_DEBUG_FIRMWARE
argument_list|,
operator|(
literal|"btext 0x%x\n"
operator|,
operator|*
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|btext
operator|)
argument_list|)
expr_stmt|;
comment|/* sanity checks */
if|if
condition|(
name|rtextsz
operator|>
name|WPI_FW_MAIN_TEXT_MAXSZ
operator|||
name|rdatasz
operator|>
name|WPI_FW_MAIN_DATA_MAXSZ
operator|||
name|itextsz
operator|>
name|WPI_FW_INIT_TEXT_MAXSZ
operator|||
name|idatasz
operator|>
name|WPI_FW_INIT_DATA_MAXSZ
operator|||
name|btextsz
operator|>
name|WPI_FW_BOOT_TEXT_MAXSZ
operator|||
operator|(
name|btextsz
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"firmware invalid\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* copy initialization images into pre-allocated DMA-safe memory */
name|memcpy
argument_list|(
name|dma
operator|->
name|vaddr
argument_list|,
name|idata
argument_list|,
name|idatasz
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dma
operator|->
name|vaddr
operator|+
name|WPI_FW_INIT_DATA_MAXSZ
argument_list|,
name|itext
argument_list|,
name|itextsz
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
name|dma
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* tell adapter where to find initialization images */
name|wpi_mem_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|wpi_mem_write
argument_list|(
name|sc
argument_list|,
name|WPI_MEM_DATA_BASE
argument_list|,
name|dma
operator|->
name|paddr
argument_list|)
expr_stmt|;
name|wpi_mem_write
argument_list|(
name|sc
argument_list|,
name|WPI_MEM_DATA_SIZE
argument_list|,
name|idatasz
argument_list|)
expr_stmt|;
name|wpi_mem_write
argument_list|(
name|sc
argument_list|,
name|WPI_MEM_TEXT_BASE
argument_list|,
name|dma
operator|->
name|paddr
operator|+
name|WPI_FW_INIT_DATA_MAXSZ
argument_list|)
expr_stmt|;
name|wpi_mem_write
argument_list|(
name|sc
argument_list|,
name|WPI_MEM_TEXT_SIZE
argument_list|,
name|itextsz
argument_list|)
expr_stmt|;
name|wpi_mem_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* load firmware boot code */
if|if
condition|(
operator|(
name|error
operator|=
name|wpi_load_microcode
argument_list|(
name|sc
argument_list|,
name|btext
argument_list|,
name|btextsz
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Failed to load microcode\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* now press "execute" */
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_RESET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* wait at most one second for the first alive notification */
if|if
condition|(
operator|(
name|error
operator|=
name|msleep
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
name|PCATCH
argument_list|,
literal|"wpiinit"
argument_list|,
name|hz
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"timeout waiting for adapter to initialize\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* copy runtime images into pre-allocated DMA-sage memory */
name|memcpy
argument_list|(
name|dma
operator|->
name|vaddr
argument_list|,
name|rdata
argument_list|,
name|rdatasz
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dma
operator|->
name|vaddr
operator|+
name|WPI_FW_MAIN_DATA_MAXSZ
argument_list|,
name|rtext
argument_list|,
name|rtextsz
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
name|dma
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* tell adapter where to find runtime images */
name|wpi_mem_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|wpi_mem_write
argument_list|(
name|sc
argument_list|,
name|WPI_MEM_DATA_BASE
argument_list|,
name|dma
operator|->
name|paddr
argument_list|)
expr_stmt|;
name|wpi_mem_write
argument_list|(
name|sc
argument_list|,
name|WPI_MEM_DATA_SIZE
argument_list|,
name|rdatasz
argument_list|)
expr_stmt|;
name|wpi_mem_write
argument_list|(
name|sc
argument_list|,
name|WPI_MEM_TEXT_BASE
argument_list|,
name|dma
operator|->
name|paddr
operator|+
name|WPI_FW_MAIN_DATA_MAXSZ
argument_list|)
expr_stmt|;
name|wpi_mem_write
argument_list|(
name|sc
argument_list|,
name|WPI_MEM_TEXT_SIZE
argument_list|,
name|WPI_FW_UPDATED
operator||
name|rtextsz
argument_list|)
expr_stmt|;
name|wpi_mem_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* wait at most one second for the first alive notification */
if|if
condition|(
operator|(
name|error
operator|=
name|msleep
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
name|PCATCH
argument_list|,
literal|"wpiinit"
argument_list|,
name|hz
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"timeout waiting for adapter to initialize2\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|DPRINTFN
argument_list|(
name|WPI_DEBUG_FIRMWARE
argument_list|,
operator|(
literal|"Firmware loaded to driver successfully\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
name|fail
label|:
name|wpi_unload_firmware
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/**  * Free the referenced firmware image  */
end_comment

begin_function
specifier|static
name|void
name|wpi_unload_firmware
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|fw_fp
condition|)
block|{
name|WPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|firmware_put
argument_list|(
name|sc
operator|->
name|fw_fp
argument_list|,
name|FIRMWARE_UNLOAD
argument_list|)
expr_stmt|;
name|WPI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|fw_fp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|wpi_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|wpi_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
decl_stmt|;
name|int
name|ac
decl_stmt|,
name|error
decl_stmt|,
name|supportsa
init|=
literal|1
decl_stmt|;
name|uint32_t
name|tmp
decl_stmt|;
specifier|const
name|struct
name|wpi_ident
modifier|*
name|ident
decl_stmt|;
name|uint8_t
name|macaddr
index|[
name|IEEE80211_ADDR_LEN
index|]
decl_stmt|;
name|sc
operator|->
name|sc_dev
operator|=
name|dev
expr_stmt|;
if|if
condition|(
name|bootverbose
operator|||
name|WPI_DEBUG_SET
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Driver Revision %s\n"
argument_list|,
name|VERSION
argument_list|)
expr_stmt|;
comment|/* 	 * Some card's only support 802.11b/g not a, check to see if 	 * this is one such card. A 0x0 in the subdevice table indicates 	 * the entire subdevice range is to be ignored. 	 */
for|for
control|(
name|ident
operator|=
name|wpi_ident_table
init|;
name|ident
operator|->
name|name
operator|!=
name|NULL
condition|;
name|ident
operator|++
control|)
block|{
if|if
condition|(
name|ident
operator|->
name|subdevice
operator|&&
name|pci_get_subdevice
argument_list|(
name|dev
argument_list|)
operator|==
name|ident
operator|->
name|subdevice
condition|)
block|{
name|supportsa
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
comment|/* Create the tasks that can be queued */
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_restarttask
argument_list|,
literal|0
argument_list|,
name|wpi_hwreset
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_radiotask
argument_list|,
literal|0
argument_list|,
name|wpi_rfreset
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|WPI_LOCK_INIT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|calib_to
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|watchdog_to
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_get_powerstate
argument_list|(
name|dev
argument_list|)
operator|!=
name|PCI_POWERSTATE_D0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"chip is in D%d power mode "
literal|"-- setting to D0\n"
argument_list|,
name|pci_get_powerstate
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|pci_set_powerstate
argument_list|(
name|dev
argument_list|,
name|PCI_POWERSTATE_D0
argument_list|)
expr_stmt|;
block|}
comment|/* disable the retry timeout register */
name|pci_write_config
argument_list|(
name|dev
argument_list|,
literal|0x41
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* enable bus-mastering */
name|pci_enable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mem_rid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mem
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|sc
operator|->
name|mem_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mem
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate memory resource\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sc
operator|->
name|sc_st
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|mem
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_sh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|mem
argument_list|)
expr_stmt|;
name|sc
operator|->
name|irq_rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|irq
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|irq_rid
argument_list|,
name|RF_ACTIVE
operator||
name|RF_SHAREABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irq
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate interrupt resource\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 	 * Allocate DMA memory for firmware transfers. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|wpi_alloc_fwmem
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|": could not allocate firmware memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 	 * Put adapter into a known state. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|wpi_reset
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not reset adapter\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|wpi_mem_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|wpi_mem_read
argument_list|(
name|sc
argument_list|,
name|WPI_MEM_PCIDEV
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
operator|||
name|WPI_DEBUG_SET
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Hardware Revision (0x%X)\n"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|wpi_mem_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Allocate shared page */
if|if
condition|(
operator|(
name|error
operator|=
name|wpi_alloc_shared
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate shared page\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* tx data queues  - 4 for QoS purposes */
for|for
control|(
name|ac
operator|=
literal|0
init|;
name|ac
operator|<
name|WME_NUM_AC
condition|;
name|ac
operator|++
control|)
block|{
name|error
operator|=
name|wpi_alloc_tx_ring
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|txq
index|[
name|ac
index|]
argument_list|,
name|WPI_TX_RING_COUNT
argument_list|,
name|ac
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate Tx ring %d\n"
argument_list|,
name|ac
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
comment|/* command queue to talk to the card's firmware */
name|error
operator|=
name|wpi_alloc_tx_ring
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|cmdq
argument_list|,
name|WPI_CMD_RING_COUNT
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate command ring\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* receive data queue */
name|error
operator|=
name|wpi_alloc_rx_ring
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rxq
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate Rx ring\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ifp
operator|=
name|sc
operator|->
name|sc_ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_IEEE80211
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can not if_alloc()\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ic
operator|=
name|ifp
operator|->
name|if_l2com
expr_stmt|;
name|ic
operator|->
name|ic_ifp
operator|=
name|ifp
expr_stmt|;
name|ic
operator|->
name|ic_phytype
operator|=
name|IEEE80211_T_OFDM
expr_stmt|;
comment|/* not only, but not used */
name|ic
operator|->
name|ic_opmode
operator|=
name|IEEE80211_M_STA
expr_stmt|;
comment|/* default to BSS mode */
comment|/* set device capabilities */
name|ic
operator|->
name|ic_caps
operator|=
name|IEEE80211_C_STA
comment|/* station mode supported */
operator||
name|IEEE80211_C_MONITOR
comment|/* monitor mode supported */
operator||
name|IEEE80211_C_TXPMGT
comment|/* tx power management */
operator||
name|IEEE80211_C_SHSLOT
comment|/* short slot time supported */
operator||
name|IEEE80211_C_SHPREAMBLE
comment|/* short preamble supported */
operator||
name|IEEE80211_C_WPA
comment|/* 802.11i */
comment|/* XXX looks like WME is partly supported? */
if|#
directive|if
literal|0
expr_stmt|| IEEE80211_C_IBSS
comment|/* IBSS mode support */
expr_stmt|| IEEE80211_C_BGSCAN
comment|/* capable of bg scanning */
expr_stmt|| IEEE80211_C_WME
comment|/* 802.11e */
expr_stmt|| IEEE80211_C_HOSTAP
comment|/* Host access point mode */
endif|#
directive|endif
expr_stmt|;
comment|/* 	 * Read in the eeprom and also setup the channels for 	 * net80211. We don't set the rates as net80211 does this for us 	 */
name|wpi_read_eeprom
argument_list|(
name|sc
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
operator|||
name|WPI_DEBUG_SET
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Regulatory Domain: %.4s\n"
argument_list|,
name|sc
operator|->
name|domain
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Hardware Type: %c\n"
argument_list|,
name|sc
operator|->
name|type
operator|>
literal|1
condition|?
literal|'B'
else|:
literal|'?'
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Hardware Revision: %c\n"
argument_list|,
operator|(
operator|(
name|le16toh
argument_list|(
name|sc
operator|->
name|rev
argument_list|)
operator|&
literal|0xf0
operator|)
operator|==
literal|0xd0
operator|)
condition|?
literal|'D'
else|:
literal|'?'
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"SKU %s support 802.11a\n"
argument_list|,
name|supportsa
condition|?
literal|"does"
else|:
literal|"does not"
argument_list|)
expr_stmt|;
comment|/* XXX hw_config uses the PCIDEV for the Hardware rev. Must check 	       what sc->rev really represents - benjsc 20070615 */
block|}
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|wpi_init
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|wpi_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|wpi_start
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|ifqmaxlen
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
operator|=
name|ifqmaxlen
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
name|ieee80211_ifattach
argument_list|(
name|ic
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
comment|/* override default methods */
name|ic
operator|->
name|ic_raw_xmit
operator|=
name|wpi_raw_xmit
expr_stmt|;
name|ic
operator|->
name|ic_wme
operator|.
name|wme_update
operator|=
name|wpi_wme_update
expr_stmt|;
name|ic
operator|->
name|ic_scan_start
operator|=
name|wpi_scan_start
expr_stmt|;
name|ic
operator|->
name|ic_scan_end
operator|=
name|wpi_scan_end
expr_stmt|;
name|ic
operator|->
name|ic_set_channel
operator|=
name|wpi_set_channel
expr_stmt|;
name|ic
operator|->
name|ic_scan_curchan
operator|=
name|wpi_scan_curchan
expr_stmt|;
name|ic
operator|->
name|ic_scan_mindwell
operator|=
name|wpi_scan_mindwell
expr_stmt|;
name|ic
operator|->
name|ic_vap_create
operator|=
name|wpi_vap_create
expr_stmt|;
name|ic
operator|->
name|ic_vap_delete
operator|=
name|wpi_vap_delete
expr_stmt|;
name|ieee80211_radiotap_attach
argument_list|(
name|ic
argument_list|,
operator|&
name|sc
operator|->
name|sc_txtap
operator|.
name|wt_ihdr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_txtap
argument_list|)
argument_list|,
name|WPI_TX_RADIOTAP_PRESENT
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxtap
operator|.
name|wr_ihdr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_rxtap
argument_list|)
argument_list|,
name|WPI_RX_RADIOTAP_PRESENT
argument_list|)
expr_stmt|;
comment|/* 	 * Hook our interrupt after all initialization is complete. 	 */
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|wpi_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_ih
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not set up interrupt\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|ieee80211_announce
argument_list|(
name|ic
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XXX_DEBUG
name|ieee80211_announce_channels
argument_list|(
name|ic
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
name|fail
label|:
name|wpi_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wpi_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|wpi_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
decl_stmt|;
name|int
name|ac
decl_stmt|;
if|if
condition|(
name|ifp
operator|!=
name|NULL
condition|)
block|{
name|ic
operator|=
name|ifp
operator|->
name|if_l2com
expr_stmt|;
name|ieee80211_draintask
argument_list|(
name|ic
argument_list|,
operator|&
name|sc
operator|->
name|sc_restarttask
argument_list|)
expr_stmt|;
name|ieee80211_draintask
argument_list|(
name|ic
argument_list|,
operator|&
name|sc
operator|->
name|sc_radiotask
argument_list|)
expr_stmt|;
name|wpi_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|watchdog_to
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|calib_to
argument_list|)
expr_stmt|;
name|ieee80211_ifdetach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
name|WPI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|txq
index|[
literal|0
index|]
operator|.
name|data_dmat
condition|)
block|{
for|for
control|(
name|ac
operator|=
literal|0
init|;
name|ac
operator|<
name|WME_NUM_AC
condition|;
name|ac
operator|++
control|)
name|wpi_free_tx_ring
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|txq
index|[
name|ac
index|]
argument_list|)
expr_stmt|;
name|wpi_free_tx_ring
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|cmdq
argument_list|)
expr_stmt|;
name|wpi_free_rx_ring
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rxq
argument_list|)
expr_stmt|;
name|wpi_free_shared
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|fw_fp
operator|!=
name|NULL
condition|)
block|{
name|wpi_unload_firmware
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|fw_dma
operator|.
name|tag
condition|)
name|wpi_free_fwmem
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|WPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irq
operator|!=
name|NULL
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq
argument_list|,
name|sc
operator|->
name|sc_ih
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|irq_rid
argument_list|,
name|sc
operator|->
name|irq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|mem
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|mem_rid
argument_list|,
name|sc
operator|->
name|mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|!=
name|NULL
condition|)
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|WPI_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ieee80211vap
modifier|*
name|wpi_vap_create
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|char
name|name
index|[
name|IFNAMSIZ
index|]
parameter_list|,
name|int
name|unit
parameter_list|,
name|enum
name|ieee80211_opmode
name|opmode
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|uint8_t
name|bssid
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|wpi_vap
modifier|*
name|wvp
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
condition|)
comment|/* only one at a time */
return|return
name|NULL
return|;
name|wvp
operator|=
operator|(
expr|struct
name|wpi_vap
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|wpi_vap
argument_list|)
argument_list|,
name|M_80211_VAP
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|wvp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|vap
operator|=
operator|&
name|wvp
operator|->
name|vap
expr_stmt|;
name|ieee80211_vap_setup
argument_list|(
name|ic
argument_list|,
name|vap
argument_list|,
name|name
argument_list|,
name|unit
argument_list|,
name|opmode
argument_list|,
name|flags
argument_list|,
name|bssid
argument_list|,
name|mac
argument_list|)
expr_stmt|;
comment|/* override with driver methods */
name|wvp
operator|->
name|newstate
operator|=
name|vap
operator|->
name|iv_newstate
expr_stmt|;
name|vap
operator|->
name|iv_newstate
operator|=
name|wpi_newstate
expr_stmt|;
name|ieee80211_ratectl_init
argument_list|(
name|vap
argument_list|)
expr_stmt|;
comment|/* complete setup */
name|ieee80211_vap_attach
argument_list|(
name|vap
argument_list|,
name|ieee80211_media_change
argument_list|,
name|ieee80211_media_status
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_opmode
operator|=
name|opmode
expr_stmt|;
return|return
name|vap
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_vap_delete
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|wpi_vap
modifier|*
name|wvp
init|=
name|WPI_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|ieee80211_ratectl_deinit
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|ieee80211_vap_detach
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|wvp
argument_list|,
name|M_80211_VAP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_dma_map_addr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return;
name|KASSERT
argument_list|(
name|nsegs
operator|==
literal|1
argument_list|,
operator|(
literal|"too many DMA segments, %d should be 1"
operator|,
name|nsegs
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|bus_addr_t
operator|*
operator|)
name|arg
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocates a contiguous block of dma memory of the requested size and  * alignment. Due to limitations of the FreeBSD dma subsystem as of 20071217,  * allocations greater than 4096 may fail. Hence if the requested alignment is  * greater we allocate 'alignment' size extra memory and shift the vaddr and  * paddr after the dma load. This bypasses the problem at the cost of a little  * more memory.  */
end_comment

begin_function
specifier|static
name|int
name|wpi_dma_contig_alloc
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|wpi_dma_info
modifier|*
name|dma
parameter_list|,
name|void
modifier|*
modifier|*
name|kvap
parameter_list|,
name|bus_size_t
name|size
parameter_list|,
name|bus_size_t
name|alignment
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|bus_size_t
name|align
decl_stmt|;
name|bus_size_t
name|reqsize
decl_stmt|;
name|DPRINTFN
argument_list|(
name|WPI_DEBUG_DMA
argument_list|,
operator|(
literal|"Size: %zd - alignment %zd\n"
operator|,
name|size
operator|,
name|alignment
operator|)
argument_list|)
expr_stmt|;
name|dma
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|dma
operator|->
name|tag
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|alignment
operator|>
literal|4096
condition|)
block|{
name|align
operator|=
name|PAGE_SIZE
expr_stmt|;
name|reqsize
operator|=
name|size
operator|+
name|alignment
expr_stmt|;
block|}
else|else
block|{
name|align
operator|=
name|alignment
expr_stmt|;
name|reqsize
operator|=
name|size
expr_stmt|;
block|}
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|align
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|reqsize
argument_list|,
literal|1
argument_list|,
name|reqsize
argument_list|,
name|flags
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|dma
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not create shared page DMA tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|dma
operator|->
name|vaddr_start
argument_list|,
name|flags
operator||
name|BUS_DMA_ZERO
argument_list|,
operator|&
name|dma
operator|->
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not allocate shared page DMA memory\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
name|dma
operator|->
name|map
argument_list|,
name|dma
operator|->
name|vaddr_start
argument_list|,
name|reqsize
argument_list|,
name|wpi_dma_map_addr
argument_list|,
operator|&
name|dma
operator|->
name|paddr_start
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* Save the original pointers so we can free all the memory */
name|dma
operator|->
name|paddr
operator|=
name|dma
operator|->
name|paddr_start
expr_stmt|;
name|dma
operator|->
name|vaddr
operator|=
name|dma
operator|->
name|vaddr_start
expr_stmt|;
comment|/* 	 * Check the alignment and increment by 4096 until we get the 	 * requested alignment. Fail if can't obtain the alignment 	 * we requested. 	 */
if|if
condition|(
operator|(
name|dma
operator|->
name|paddr
operator|&
operator|(
name|alignment
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|alignment
operator|/
literal|4096
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|dma
operator|->
name|paddr
operator|&
operator|(
name|alignment
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
break|break;
name|dma
operator|->
name|paddr
operator|+=
literal|4096
expr_stmt|;
name|dma
operator|->
name|vaddr
operator|+=
literal|4096
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|alignment
operator|/
literal|4096
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"alignment requirement was not satisfied\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not load shared page DMA map\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|kvap
operator|!=
name|NULL
condition|)
operator|*
name|kvap
operator|=
name|dma
operator|->
name|vaddr
expr_stmt|;
return|return
literal|0
return|;
name|fail
label|:
name|wpi_dma_contig_free
argument_list|(
name|dma
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_dma_contig_free
parameter_list|(
name|struct
name|wpi_dma_info
modifier|*
name|dma
parameter_list|)
block|{
if|if
condition|(
name|dma
operator|->
name|tag
condition|)
block|{
if|if
condition|(
name|dma
operator|->
name|map
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dma
operator|->
name|paddr_start
operator|!=
literal|0
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
name|dma
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
name|dma
operator|->
name|map
argument_list|)
expr_stmt|;
block|}
name|bus_dmamem_free
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
operator|&
name|dma
operator|->
name|vaddr_start
argument_list|,
name|dma
operator|->
name|map
argument_list|)
expr_stmt|;
block|}
name|bus_dma_tag_destroy
argument_list|(
name|dma
operator|->
name|tag
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Allocate a shared page between host and NIC.  */
end_comment

begin_function
specifier|static
name|int
name|wpi_alloc_shared
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|wpi_dma_contig_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|shared_dma
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|shared
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|wpi_shared
argument_list|)
argument_list|,
name|PAGE_SIZE
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not allocate shared area DMA memory\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_free_shared
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|wpi_dma_contig_free
argument_list|(
operator|&
name|sc
operator|->
name|shared_dma
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|wpi_alloc_rx_ring
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|wpi_rx_ring
modifier|*
name|ring
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|ring
operator|->
name|cur
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|wpi_dma_contig_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|ring
operator|->
name|desc_dma
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|ring
operator|->
name|desc
argument_list|,
name|WPI_RX_RING_COUNT
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|WPI_RING_DMA_ALIGN
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not allocate rx ring DMA memory, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|MJUMPAGESIZE
argument_list|,
literal|1
argument_list|,
name|MJUMPAGESIZE
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|ring
operator|->
name|data_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: bus_dma_tag_create_failed, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 	 * Setup Rx buffers. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|WPI_RX_RING_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|wpi_rx_data
modifier|*
name|data
init|=
operator|&
name|ring
operator|->
name|data
index|[
name|i
index|]
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|bus_addr_t
name|paddr
decl_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
literal|0
argument_list|,
operator|&
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: bus_dmamap_create failed, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|m
operator|=
name|m_getjcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|,
name|MJUMPAGESIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not allocate rx mbuf\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* map page */
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|MJUMPAGESIZE
argument_list|,
name|wpi_dma_map_addr
argument_list|,
operator|&
name|paddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|EFBIG
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: bus_dmamap_load failed, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
comment|/* XXX unique code */
goto|goto
name|fail
goto|;
block|}
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|data
operator|->
name|m
operator|=
name|m
expr_stmt|;
name|ring
operator|->
name|desc
index|[
name|i
index|]
operator|=
name|htole32
argument_list|(
name|paddr
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|desc_dma
operator|.
name|tag
argument_list|,
name|ring
operator|->
name|desc_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|fail
label|:
name|wpi_free_rx_ring
argument_list|(
name|sc
argument_list|,
name|ring
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_reset_rx_ring
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|wpi_rx_ring
modifier|*
name|ring
parameter_list|)
block|{
name|int
name|ntries
decl_stmt|;
name|wpi_mem_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_RX_CONFIG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|ntries
operator|=
literal|0
init|;
name|ntries
operator|<
literal|100
condition|;
name|ntries
operator|++
control|)
block|{
if|if
condition|(
name|WPI_READ
argument_list|(
name|sc
argument_list|,
name|WPI_RX_STATUS
argument_list|)
operator|&
name|WPI_RX_IDLE
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
name|wpi_mem_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WPI_DEBUG
if|if
condition|(
name|ntries
operator|==
literal|100
operator|&&
name|wpi_debug
operator|>
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"timeout resetting Rx ring\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ring
operator|->
name|cur
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_free_rx_ring
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|wpi_rx_ring
modifier|*
name|ring
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|wpi_dma_contig_free
argument_list|(
operator|&
name|ring
operator|->
name|desc_dma
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|WPI_RX_RING_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|wpi_rx_data
modifier|*
name|data
init|=
operator|&
name|ring
operator|->
name|data
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|data
operator|->
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|->
name|map
operator|!=
name|NULL
condition|)
name|bus_dmamap_destroy
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|wpi_alloc_tx_ring
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|wpi_tx_ring
modifier|*
name|ring
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|qid
parameter_list|)
block|{
name|struct
name|wpi_tx_data
modifier|*
name|data
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|ring
operator|->
name|qid
operator|=
name|qid
expr_stmt|;
name|ring
operator|->
name|count
operator|=
name|count
expr_stmt|;
name|ring
operator|->
name|queued
operator|=
literal|0
expr_stmt|;
name|ring
operator|->
name|cur
operator|=
literal|0
expr_stmt|;
name|ring
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|wpi_dma_contig_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|ring
operator|->
name|desc_dma
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|ring
operator|->
name|desc
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|wpi_tx_desc
argument_list|)
argument_list|,
name|WPI_RING_DMA_ALIGN
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not allocate tx dma memory\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* update shared page with ring's base address */
name|sc
operator|->
name|shared
operator|->
name|txbase
index|[
name|qid
index|]
operator|=
name|htole32
argument_list|(
name|ring
operator|->
name|desc_dma
operator|.
name|paddr
argument_list|)
expr_stmt|;
name|error
operator|=
name|wpi_dma_contig_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|ring
operator|->
name|cmd_dma
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|ring
operator|->
name|cmd
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|wpi_tx_cmd
argument_list|)
argument_list|,
name|WPI_RING_DMA_ALIGN
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not allocate tx command DMA memory\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ring
operator|->
name|data
operator|=
name|malloc
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|wpi_tx_data
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|ring
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not allocate tx data slots\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|MCLBYTES
argument_list|,
name|WPI_MAX_SCATTER
operator|-
literal|1
argument_list|,
name|MCLBYTES
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|ring
operator|->
name|data_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not create data DMA tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|data
operator|=
operator|&
name|ring
operator|->
name|data
index|[
name|i
index|]
expr_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
literal|0
argument_list|,
operator|&
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not create tx buf DMA map\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
name|fail
label|:
name|wpi_free_tx_ring
argument_list|(
name|sc
argument_list|,
name|ring
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_reset_tx_ring
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|wpi_tx_ring
modifier|*
name|ring
parameter_list|)
block|{
name|struct
name|wpi_tx_data
modifier|*
name|data
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ntries
decl_stmt|;
name|wpi_mem_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_TX_CONFIG
argument_list|(
name|ring
operator|->
name|qid
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|ntries
operator|=
literal|0
init|;
name|ntries
operator|<
literal|100
condition|;
name|ntries
operator|++
control|)
block|{
if|if
condition|(
name|WPI_READ
argument_list|(
name|sc
argument_list|,
name|WPI_TX_STATUS
argument_list|)
operator|&
name|WPI_TX_IDLE
argument_list|(
name|ring
operator|->
name|qid
argument_list|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|WPI_DEBUG
if|if
condition|(
name|ntries
operator|==
literal|100
operator|&&
name|wpi_debug
operator|>
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"timeout resetting Tx ring %d\n"
argument_list|,
name|ring
operator|->
name|qid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|wpi_mem_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ring
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
name|data
operator|=
operator|&
name|ring
operator|->
name|data
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|data
operator|->
name|m
argument_list|)
expr_stmt|;
name|data
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|ring
operator|->
name|queued
operator|=
literal|0
expr_stmt|;
name|ring
operator|->
name|cur
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_free_tx_ring
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|wpi_tx_ring
modifier|*
name|ring
parameter_list|)
block|{
name|struct
name|wpi_tx_data
modifier|*
name|data
decl_stmt|;
name|int
name|i
decl_stmt|;
name|wpi_dma_contig_free
argument_list|(
operator|&
name|ring
operator|->
name|desc_dma
argument_list|)
expr_stmt|;
name|wpi_dma_contig_free
argument_list|(
operator|&
name|ring
operator|->
name|cmd_dma
argument_list|)
expr_stmt|;
if|if
condition|(
name|ring
operator|->
name|data
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ring
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
name|data
operator|=
operator|&
name|ring
operator|->
name|data
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|data
operator|->
name|m
argument_list|)
expr_stmt|;
name|data
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|ring
operator|->
name|data
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ring
operator|->
name|data_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|wpi_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|wpi_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|WPI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|wpi_stop_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|wpi_unload_firmware
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|WPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wpi_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|wpi_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|sc
operator|->
name|sc_ifp
operator|->
name|if_l2com
decl_stmt|;
name|ieee80211_suspend_all
argument_list|(
name|ic
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wpi_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|wpi_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|sc
operator|->
name|sc_ifp
operator|->
name|if_l2com
decl_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
literal|0x41
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ieee80211_resume_all
argument_list|(
name|ic
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Called by net80211 when ever there is a change to 80211 state machine  */
end_comment

begin_function
specifier|static
name|int
name|wpi_newstate
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|enum
name|ieee80211_state
name|nstate
parameter_list|,
name|int
name|arg
parameter_list|)
block|{
name|struct
name|wpi_vap
modifier|*
name|wvp
init|=
name|WPI_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|wpi_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: %s -> %s flags 0x%x\n"
operator|,
name|__func__
operator|,
name|ieee80211_state_name
index|[
name|vap
operator|->
name|iv_state
index|]
operator|,
name|ieee80211_state_name
index|[
name|nstate
index|]
operator|,
name|sc
operator|->
name|flags
operator|)
argument_list|)
expr_stmt|;
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|WPI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|nstate
operator|==
name|IEEE80211_S_SCAN
operator|&&
name|vap
operator|->
name|iv_state
operator|!=
name|IEEE80211_S_INIT
condition|)
block|{
comment|/* 		 * On !INIT -> SCAN transitions, we need to clear any possible 		 * knowledge about associations. 		 */
name|error
operator|=
name|wpi_config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: device config failed, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nstate
operator|==
name|IEEE80211_S_AUTH
operator|||
operator|(
name|nstate
operator|==
name|IEEE80211_S_ASSOC
operator|&&
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_RUN
operator|)
condition|)
block|{
comment|/* 		 * The node must be registered in the firmware before auth. 		 * Also the associd must be cleared on RUN -> ASSOC 		 * transitions. 		 */
name|error
operator|=
name|wpi_auth
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not move to auth state, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nstate
operator|==
name|IEEE80211_S_RUN
operator|&&
name|vap
operator|->
name|iv_state
operator|!=
name|IEEE80211_S_RUN
condition|)
block|{
name|error
operator|=
name|wpi_run
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not move to run state, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nstate
operator|==
name|IEEE80211_S_RUN
condition|)
block|{
comment|/* RUN -> RUN transition; just restart the timers */
name|wpi_calib_timeout
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* XXX split out rate control timer */
block|}
name|WPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
return|return
name|wvp
operator|->
name|newstate
argument_list|(
name|vap
argument_list|,
name|nstate
argument_list|,
name|arg
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Grab exclusive access to NIC memory.  */
end_comment

begin_function
specifier|static
name|void
name|wpi_mem_lock
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|ntries
decl_stmt|;
name|uint32_t
name|tmp
decl_stmt|;
name|tmp
operator|=
name|WPI_READ
argument_list|(
name|sc
argument_list|,
name|WPI_GPIO_CTL
argument_list|)
expr_stmt|;
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_GPIO_CTL
argument_list|,
name|tmp
operator||
name|WPI_GPIO_MAC
argument_list|)
expr_stmt|;
comment|/* spin until we actually get the lock */
for|for
control|(
name|ntries
operator|=
literal|0
init|;
name|ntries
operator|<
literal|100
condition|;
name|ntries
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|WPI_READ
argument_list|(
name|sc
argument_list|,
name|WPI_GPIO_CTL
argument_list|)
operator|&
operator|(
name|WPI_GPIO_CLOCK
operator||
name|WPI_GPIO_SLEEP
operator|)
operator|)
operator|==
name|WPI_GPIO_CLOCK
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ntries
operator|==
literal|100
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not lock memory\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Release lock on NIC memory.  */
end_comment

begin_function
specifier|static
name|void
name|wpi_mem_unlock
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|tmp
init|=
name|WPI_READ
argument_list|(
name|sc
argument_list|,
name|WPI_GPIO_CTL
argument_list|)
decl_stmt|;
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_GPIO_CTL
argument_list|,
name|tmp
operator|&
operator|~
name|WPI_GPIO_MAC
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|wpi_mem_read
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|uint16_t
name|addr
parameter_list|)
block|{
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_READ_MEM_ADDR
argument_list|,
name|WPI_MEM_4
operator||
name|addr
argument_list|)
expr_stmt|;
return|return
name|WPI_READ
argument_list|(
name|sc
argument_list|,
name|WPI_READ_MEM_DATA
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_mem_write
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|uint16_t
name|addr
parameter_list|,
name|uint32_t
name|data
parameter_list|)
block|{
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_WRITE_MEM_ADDR
argument_list|,
name|WPI_MEM_4
operator||
name|addr
argument_list|)
expr_stmt|;
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_WRITE_MEM_DATA
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_mem_write_region_4
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|uint16_t
name|addr
parameter_list|,
specifier|const
name|uint32_t
modifier|*
name|data
parameter_list|,
name|int
name|wlen
parameter_list|)
block|{
for|for
control|(
init|;
name|wlen
operator|>
literal|0
condition|;
name|wlen
operator|--
operator|,
name|data
operator|++
operator|,
name|addr
operator|+=
literal|4
control|)
name|wpi_mem_write
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
operator|*
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read data from the EEPROM.  We access EEPROM through the MAC instead of  * using the traditional bit-bang method. Data is read up until len bytes have  * been obtained.  */
end_comment

begin_function
specifier|static
name|uint16_t
name|wpi_read_prom_data
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|ntries
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|uint8_t
modifier|*
name|out
init|=
name|data
decl_stmt|;
name|wpi_mem_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|len
operator|>
literal|0
condition|;
name|len
operator|-=
literal|2
operator|,
name|addr
operator|++
control|)
block|{
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_EEPROM_CTL
argument_list|,
name|addr
operator|<<
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|ntries
operator|=
literal|0
init|;
name|ntries
operator|<
literal|10
condition|;
name|ntries
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|val
operator|=
name|WPI_READ
argument_list|(
name|sc
argument_list|,
name|WPI_EEPROM_CTL
argument_list|)
operator|)
operator|&
name|WPI_EEPROM_READY
condition|)
break|break;
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ntries
operator|==
literal|10
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not read EEPROM\n"
argument_list|)
expr_stmt|;
return|return
name|ETIMEDOUT
return|;
block|}
operator|*
name|out
operator|++
operator|=
name|val
operator|>>
literal|16
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|1
condition|)
operator|*
name|out
operator|++
operator|=
name|val
operator|>>
literal|24
expr_stmt|;
block|}
name|wpi_mem_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * The firmware text and data segments are transferred to the NIC using DMA.  * The driver just copies the firmware into DMA-safe memory and tells the NIC  * where to find it.  Once the NIC has copied the firmware into its internal  * memory, we can free our local copy in the driver.  */
end_comment

begin_function
specifier|static
name|int
name|wpi_load_microcode
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|fw
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|ntries
decl_stmt|;
name|DPRINTFN
argument_list|(
name|WPI_DEBUG_HW
argument_list|,
operator|(
literal|"Loading microcode  size 0x%x\n"
operator|,
name|size
operator|)
argument_list|)
expr_stmt|;
name|size
operator|/=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|wpi_mem_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|wpi_mem_write_region_4
argument_list|(
name|sc
argument_list|,
name|WPI_MEM_UCODE_BASE
argument_list|,
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|fw
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|wpi_mem_write
argument_list|(
name|sc
argument_list|,
name|WPI_MEM_UCODE_SRC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wpi_mem_write
argument_list|(
name|sc
argument_list|,
name|WPI_MEM_UCODE_DST
argument_list|,
name|WPI_FW_TEXT
argument_list|)
expr_stmt|;
name|wpi_mem_write
argument_list|(
name|sc
argument_list|,
name|WPI_MEM_UCODE_SIZE
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* run microcode */
name|wpi_mem_write
argument_list|(
name|sc
argument_list|,
name|WPI_MEM_UCODE_CTL
argument_list|,
name|WPI_UC_RUN
argument_list|)
expr_stmt|;
comment|/* wait while the adapter is busy copying the firmware */
for|for
control|(
name|error
operator|=
literal|0
operator|,
name|ntries
operator|=
literal|0
init|;
name|ntries
operator|<
literal|1000
condition|;
name|ntries
operator|++
control|)
block|{
name|uint32_t
name|status
init|=
name|WPI_READ
argument_list|(
name|sc
argument_list|,
name|WPI_TX_STATUS
argument_list|)
decl_stmt|;
name|DPRINTFN
argument_list|(
name|WPI_DEBUG_HW
argument_list|,
operator|(
literal|"firmware status=0x%x, val=0x%x, result=0x%x\n"
operator|,
name|status
operator|,
name|WPI_TX_IDLE
argument_list|(
literal|6
argument_list|)
operator|,
name|status
operator|&
name|WPI_TX_IDLE
argument_list|(
literal|6
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|WPI_TX_IDLE
argument_list|(
literal|6
argument_list|)
condition|)
block|{
name|DPRINTFN
argument_list|(
name|WPI_DEBUG_HW
argument_list|,
operator|(
literal|"Status Match! - ntries = %d\n"
operator|,
name|ntries
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ntries
operator|==
literal|1000
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"timeout transferring firmware\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
block|}
comment|/* start the microcode executing */
name|wpi_mem_write
argument_list|(
name|sc
argument_list|,
name|WPI_MEM_UCODE_CTL
argument_list|,
name|WPI_UC_ENABLE
argument_list|)
expr_stmt|;
name|wpi_mem_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_rx_intr
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|wpi_rx_desc
modifier|*
name|desc
parameter_list|,
name|struct
name|wpi_rx_data
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|wpi_rx_ring
modifier|*
name|ring
init|=
operator|&
name|sc
operator|->
name|rxq
decl_stmt|;
name|struct
name|wpi_rx_stat
modifier|*
name|stat
decl_stmt|;
name|struct
name|wpi_rx_head
modifier|*
name|head
decl_stmt|;
name|struct
name|wpi_rx_tail
modifier|*
name|tail
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|mnew
decl_stmt|;
name|bus_addr_t
name|paddr
decl_stmt|;
name|int
name|error
decl_stmt|;
name|stat
operator|=
operator|(
expr|struct
name|wpi_rx_stat
operator|*
operator|)
operator|(
name|desc
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|stat
operator|->
name|len
operator|>
name|WPI_STAT_MAXLEN
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"invalid rx statistic header\n"
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|head
operator|=
operator|(
expr|struct
name|wpi_rx_head
operator|*
operator|)
operator|(
call|(
name|caddr_t
call|)
argument_list|(
name|stat
operator|+
literal|1
argument_list|)
operator|+
name|stat
operator|->
name|len
operator|)
expr_stmt|;
name|tail
operator|=
operator|(
expr|struct
name|wpi_rx_tail
operator|*
operator|)
operator|(
call|(
name|caddr_t
call|)
argument_list|(
name|head
operator|+
literal|1
argument_list|)
operator|+
name|le16toh
argument_list|(
name|head
operator|->
name|len
argument_list|)
operator|)
expr_stmt|;
name|DPRINTFN
argument_list|(
name|WPI_DEBUG_RX
argument_list|,
operator|(
literal|"rx intr: idx=%d len=%d stat len=%d rssi=%d "
literal|"rate=%x chan=%d tstamp=%ju\n"
operator|,
name|ring
operator|->
name|cur
operator|,
name|le32toh
argument_list|(
name|desc
operator|->
name|len
argument_list|)
operator|,
name|le16toh
argument_list|(
name|head
operator|->
name|len
argument_list|)
operator|,
operator|(
name|int8_t
operator|)
name|stat
operator|->
name|rssi
operator|,
name|head
operator|->
name|rate
operator|,
name|head
operator|->
name|chan
operator|,
operator|(
name|uintmax_t
operator|)
name|le64toh
argument_list|(
name|tail
operator|->
name|tstamp
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* discard Rx frames with bad CRC early */
if|if
condition|(
operator|(
name|le32toh
argument_list|(
name|tail
operator|->
name|flags
argument_list|)
operator|&
name|WPI_RX_NOERROR
operator|)
operator|!=
name|WPI_RX_NOERROR
condition|)
block|{
name|DPRINTFN
argument_list|(
name|WPI_DEBUG_RX
argument_list|,
operator|(
literal|"%s: rx flags error %x\n"
operator|,
name|__func__
operator|,
name|le32toh
argument_list|(
name|tail
operator|->
name|flags
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|le16toh
argument_list|(
name|head
operator|->
name|len
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
condition|)
block|{
name|DPRINTFN
argument_list|(
name|WPI_DEBUG_RX
argument_list|,
operator|(
literal|"%s: frame too short: %d\n"
operator|,
name|__func__
operator|,
name|le16toh
argument_list|(
name|head
operator|->
name|len
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
comment|/* XXX don't need mbuf, just dma buffer */
name|mnew
operator|=
name|m_getjcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|,
name|MJUMPAGESIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mnew
operator|==
name|NULL
condition|)
block|{
name|DPRINTFN
argument_list|(
name|WPI_DEBUG_RX
argument_list|,
operator|(
literal|"%s: no mbuf to restock ring\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
name|bus_dmamap_unload
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|mtod
argument_list|(
name|mnew
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|MJUMPAGESIZE
argument_list|,
name|wpi_dma_map_addr
argument_list|,
operator|&
name|paddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|EFBIG
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: bus_dmamap_load failed, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mnew
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* finalize mbuf and swap in new one */
name|m
operator|=
name|data
operator|->
name|m
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_data
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|head
operator|+
literal|1
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|le16toh
argument_list|(
name|head
operator|->
name|len
argument_list|)
expr_stmt|;
name|data
operator|->
name|m
operator|=
name|mnew
expr_stmt|;
comment|/* update Rx descriptor */
name|ring
operator|->
name|desc
index|[
name|ring
operator|->
name|cur
index|]
operator|=
name|htole32
argument_list|(
name|paddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ieee80211_radiotap_active
argument_list|(
name|ic
argument_list|)
condition|)
block|{
name|struct
name|wpi_rx_radiotap_header
modifier|*
name|tap
init|=
operator|&
name|sc
operator|->
name|sc_rxtap
decl_stmt|;
name|tap
operator|->
name|wr_flags
operator|=
literal|0
expr_stmt|;
name|tap
operator|->
name|wr_chan_freq
operator|=
name|htole16
argument_list|(
name|ic
operator|->
name|ic_channels
index|[
name|head
operator|->
name|chan
index|]
operator|.
name|ic_freq
argument_list|)
expr_stmt|;
name|tap
operator|->
name|wr_chan_flags
operator|=
name|htole16
argument_list|(
name|ic
operator|->
name|ic_channels
index|[
name|head
operator|->
name|chan
index|]
operator|.
name|ic_flags
argument_list|)
expr_stmt|;
name|tap
operator|->
name|wr_dbm_antsignal
operator|=
call|(
name|int8_t
call|)
argument_list|(
name|stat
operator|->
name|rssi
operator|-
name|WPI_RSSI_OFFSET
argument_list|)
expr_stmt|;
name|tap
operator|->
name|wr_dbm_antnoise
operator|=
operator|(
name|int8_t
operator|)
name|le16toh
argument_list|(
name|stat
operator|->
name|noise
argument_list|)
expr_stmt|;
name|tap
operator|->
name|wr_tsft
operator|=
name|tail
operator|->
name|tstamp
expr_stmt|;
name|tap
operator|->
name|wr_antenna
operator|=
operator|(
name|le16toh
argument_list|(
name|head
operator|->
name|flags
argument_list|)
operator|>>
literal|4
operator|)
operator|&
literal|0xf
expr_stmt|;
switch|switch
condition|(
name|head
operator|->
name|rate
condition|)
block|{
comment|/* CCK rates */
case|case
literal|10
case|:
name|tap
operator|->
name|wr_rate
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|20
case|:
name|tap
operator|->
name|wr_rate
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|55
case|:
name|tap
operator|->
name|wr_rate
operator|=
literal|11
expr_stmt|;
break|break;
case|case
literal|110
case|:
name|tap
operator|->
name|wr_rate
operator|=
literal|22
expr_stmt|;
break|break;
comment|/* OFDM rates */
case|case
literal|0xd
case|:
name|tap
operator|->
name|wr_rate
operator|=
literal|12
expr_stmt|;
break|break;
case|case
literal|0xf
case|:
name|tap
operator|->
name|wr_rate
operator|=
literal|18
expr_stmt|;
break|break;
case|case
literal|0x5
case|:
name|tap
operator|->
name|wr_rate
operator|=
literal|24
expr_stmt|;
break|break;
case|case
literal|0x7
case|:
name|tap
operator|->
name|wr_rate
operator|=
literal|36
expr_stmt|;
break|break;
case|case
literal|0x9
case|:
name|tap
operator|->
name|wr_rate
operator|=
literal|48
expr_stmt|;
break|break;
case|case
literal|0xb
case|:
name|tap
operator|->
name|wr_rate
operator|=
literal|72
expr_stmt|;
break|break;
case|case
literal|0x1
case|:
name|tap
operator|->
name|wr_rate
operator|=
literal|96
expr_stmt|;
break|break;
case|case
literal|0x3
case|:
name|tap
operator|->
name|wr_rate
operator|=
literal|108
expr_stmt|;
break|break;
comment|/* unknown rate: should not happen */
default|default:
name|tap
operator|->
name|wr_rate
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|le16toh
argument_list|(
name|head
operator|->
name|flags
argument_list|)
operator|&
literal|0x4
condition|)
name|tap
operator|->
name|wr_flags
operator||=
name|IEEE80211_RADIOTAP_F_SHORTPRE
expr_stmt|;
block|}
name|WPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ni
operator|=
name|ieee80211_find_rxnode
argument_list|(
name|ic
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame_min
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|ieee80211_input
argument_list|(
name|ni
argument_list|,
name|m
argument_list|,
name|stat
operator|->
name|rssi
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|ieee80211_input_all
argument_list|(
name|ic
argument_list|,
name|m
argument_list|,
name|stat
operator|->
name|rssi
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WPI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_tx_intr
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|wpi_rx_desc
modifier|*
name|desc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|wpi_tx_ring
modifier|*
name|ring
init|=
operator|&
name|sc
operator|->
name|txq
index|[
name|desc
operator|->
name|qid
operator|&
literal|0x3
index|]
decl_stmt|;
name|struct
name|wpi_tx_data
modifier|*
name|txdata
init|=
operator|&
name|ring
operator|->
name|data
index|[
name|desc
operator|->
name|idx
index|]
decl_stmt|;
name|struct
name|wpi_tx_stat
modifier|*
name|stat
init|=
operator|(
expr|struct
name|wpi_tx_stat
operator|*
operator|)
operator|(
name|desc
operator|+
literal|1
operator|)
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|txdata
operator|->
name|ni
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|int
name|retrycnt
init|=
literal|0
decl_stmt|;
name|DPRINTFN
argument_list|(
name|WPI_DEBUG_TX
argument_list|,
operator|(
literal|"tx done: qid=%d idx=%d retries=%d nkill=%d "
literal|"rate=%x duration=%d status=%x\n"
operator|,
name|desc
operator|->
name|qid
operator|,
name|desc
operator|->
name|idx
operator|,
name|stat
operator|->
name|ntries
operator|,
name|stat
operator|->
name|nkill
operator|,
name|stat
operator|->
name|rate
operator|,
name|le32toh
argument_list|(
name|stat
operator|->
name|duration
argument_list|)
operator|,
name|le32toh
argument_list|(
name|stat
operator|->
name|status
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Update rate control statistics for the node. 	 * XXX we should not count mgmt frames since they're always sent at 	 * the lowest available bit-rate. 	 * XXX frames w/o ACK shouldn't be used either 	 */
if|if
condition|(
name|stat
operator|->
name|ntries
operator|>
literal|0
condition|)
block|{
name|DPRINTFN
argument_list|(
name|WPI_DEBUG_TX
argument_list|,
operator|(
literal|"%d retries\n"
operator|,
name|stat
operator|->
name|ntries
operator|)
argument_list|)
expr_stmt|;
name|retrycnt
operator|=
literal|1
expr_stmt|;
block|}
name|ieee80211_ratectl_tx_complete
argument_list|(
name|vap
argument_list|,
name|ni
argument_list|,
name|IEEE80211_RATECTL_TX_SUCCESS
argument_list|,
operator|&
name|retrycnt
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* XXX oerrors should only count errors !maxtries */
if|if
condition|(
operator|(
name|le32toh
argument_list|(
name|stat
operator|->
name|status
argument_list|)
operator|&
literal|0xff
operator|)
operator|!=
literal|1
condition|)
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
else|else
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|txdata
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|txdata
operator|->
name|map
argument_list|)
expr_stmt|;
comment|/* XXX handle M_TXCB? */
name|m_freem
argument_list|(
name|txdata
operator|->
name|m
argument_list|)
expr_stmt|;
name|txdata
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|txdata
operator|->
name|ni
argument_list|)
expr_stmt|;
name|txdata
operator|->
name|ni
operator|=
name|NULL
expr_stmt|;
name|ring
operator|->
name|queued
operator|--
expr_stmt|;
name|sc
operator|->
name|sc_tx_timer
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|wpi_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_cmd_intr
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|wpi_rx_desc
modifier|*
name|desc
parameter_list|)
block|{
name|struct
name|wpi_tx_ring
modifier|*
name|ring
init|=
operator|&
name|sc
operator|->
name|cmdq
decl_stmt|;
name|struct
name|wpi_tx_data
modifier|*
name|data
decl_stmt|;
name|DPRINTFN
argument_list|(
name|WPI_DEBUG_CMD
argument_list|,
operator|(
literal|"cmd notification qid=%x idx=%d flags=%x "
literal|"type=%s len=%d\n"
operator|,
name|desc
operator|->
name|qid
operator|,
name|desc
operator|->
name|idx
operator|,
name|desc
operator|->
name|flags
operator|,
name|wpi_cmd_str
argument_list|(
name|desc
operator|->
name|type
argument_list|)
operator|,
name|le32toh
argument_list|(
name|desc
operator|->
name|len
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|desc
operator|->
name|qid
operator|&
literal|7
operator|)
operator|!=
literal|4
condition|)
return|return;
comment|/* not a command ack */
name|data
operator|=
operator|&
name|ring
operator|->
name|data
index|[
name|desc
operator|->
name|idx
index|]
expr_stmt|;
comment|/* if the command was mapped in a mbuf, free it */
if|if
condition|(
name|data
operator|->
name|m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|data
operator|->
name|m
argument_list|)
expr_stmt|;
name|data
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
block|}
name|sc
operator|->
name|flags
operator|&=
operator|~
name|WPI_FLAG_BUSY
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|ring
operator|->
name|cmd
index|[
name|desc
operator|->
name|idx
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_notif_intr
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|wpi_rx_desc
modifier|*
name|desc
decl_stmt|;
name|struct
name|wpi_rx_data
modifier|*
name|data
decl_stmt|;
name|uint32_t
name|hw
decl_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|shared_dma
operator|.
name|tag
argument_list|,
name|sc
operator|->
name|shared_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|hw
operator|=
name|le32toh
argument_list|(
name|sc
operator|->
name|shared
operator|->
name|next
argument_list|)
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|rxq
operator|.
name|cur
operator|!=
name|hw
condition|)
block|{
name|data
operator|=
operator|&
name|sc
operator|->
name|rxq
operator|.
name|data
index|[
name|sc
operator|->
name|rxq
operator|.
name|cur
index|]
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rxq
operator|.
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|desc
operator|=
operator|(
name|void
operator|*
operator|)
name|data
operator|->
name|m
operator|->
name|m_ext
operator|.
name|ext_buf
expr_stmt|;
name|DPRINTFN
argument_list|(
name|WPI_DEBUG_NOTIFY
argument_list|,
operator|(
literal|"notify qid=%x idx=%d flags=%x type=%d len=%d\n"
operator|,
name|desc
operator|->
name|qid
operator|,
name|desc
operator|->
name|idx
operator|,
name|desc
operator|->
name|flags
operator|,
name|desc
operator|->
name|type
operator|,
name|le32toh
argument_list|(
name|desc
operator|->
name|len
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|desc
operator|->
name|qid
operator|&
literal|0x80
operator|)
condition|)
comment|/* reply to a command */
name|wpi_cmd_intr
argument_list|(
name|sc
argument_list|,
name|desc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|desc
operator|->
name|type
condition|)
block|{
case|case
name|WPI_RX_DONE
case|:
comment|/* a 802.11 frame was received */
name|wpi_rx_intr
argument_list|(
name|sc
argument_list|,
name|desc
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|WPI_TX_DONE
case|:
comment|/* a 802.11 frame has been transmitted */
name|wpi_tx_intr
argument_list|(
name|sc
argument_list|,
name|desc
argument_list|)
expr_stmt|;
break|break;
case|case
name|WPI_UC_READY
case|:
block|{
name|struct
name|wpi_ucode_info
modifier|*
name|uc
init|=
operator|(
expr|struct
name|wpi_ucode_info
operator|*
operator|)
operator|(
name|desc
operator|+
literal|1
operator|)
decl_stmt|;
comment|/* the microcontroller is ready */
name|DPRINTF
argument_list|(
operator|(
literal|"microcode alive notification version %x "
literal|"alive %x\n"
operator|,
name|le32toh
argument_list|(
name|uc
operator|->
name|version
argument_list|)
operator|,
name|le32toh
argument_list|(
name|uc
operator|->
name|valid
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|le32toh
argument_list|(
name|uc
operator|->
name|valid
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"microcontroller initialization failed\n"
argument_list|)
expr_stmt|;
name|wpi_stop_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|WPI_STATE_CHANGED
case|:
block|{
name|uint32_t
modifier|*
name|status
init|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|desc
operator|+
literal|1
operator|)
decl_stmt|;
comment|/* enabled/disabled notification */
name|DPRINTF
argument_list|(
operator|(
literal|"state changed to %x\n"
operator|,
name|le32toh
argument_list|(
operator|*
name|status
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|le32toh
argument_list|(
operator|*
name|status
argument_list|)
operator|&
literal|1
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Radio transmitter is switched off\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator||=
name|WPI_FLAG_HW_RADIO_OFF
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
comment|/* Disable firmware commands */
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_UCODE_SET
argument_list|,
name|WPI_DISABLE_CMD
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|WPI_START_SCAN
case|:
block|{
ifdef|#
directive|ifdef
name|WPI_DEBUG
name|struct
name|wpi_start_scan
modifier|*
name|scan
init|=
operator|(
expr|struct
name|wpi_start_scan
operator|*
operator|)
operator|(
name|desc
operator|+
literal|1
operator|)
decl_stmt|;
endif|#
directive|endif
name|DPRINTFN
argument_list|(
name|WPI_DEBUG_SCANNING
argument_list|,
operator|(
literal|"scanning channel %d status %x\n"
operator|,
name|scan
operator|->
name|chan
operator|,
name|le32toh
argument_list|(
name|scan
operator|->
name|status
argument_list|)
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|WPI_STOP_SCAN
case|:
block|{
ifdef|#
directive|ifdef
name|WPI_DEBUG
name|struct
name|wpi_stop_scan
modifier|*
name|scan
init|=
operator|(
expr|struct
name|wpi_stop_scan
operator|*
operator|)
operator|(
name|desc
operator|+
literal|1
operator|)
decl_stmt|;
endif|#
directive|endif
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
decl_stmt|;
name|DPRINTFN
argument_list|(
name|WPI_DEBUG_SCANNING
argument_list|,
operator|(
literal|"scan finished nchan=%d status=%d chan=%d\n"
operator|,
name|scan
operator|->
name|nchan
operator|,
name|scan
operator|->
name|status
operator|,
name|scan
operator|->
name|chan
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_scan_timer
operator|=
literal|0
expr_stmt|;
name|ieee80211_scan_next
argument_list|(
name|vap
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|WPI_MISSED_BEACON
case|:
block|{
name|struct
name|wpi_missed_beacon
modifier|*
name|beacon
init|=
operator|(
expr|struct
name|wpi_missed_beacon
operator|*
operator|)
operator|(
name|desc
operator|+
literal|1
operator|)
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
decl_stmt|;
if|if
condition|(
name|le32toh
argument_list|(
name|beacon
operator|->
name|consecutive
argument_list|)
operator|>=
name|vap
operator|->
name|iv_bmissthreshold
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"Beacon miss: %u>= %u\n"
operator|,
name|le32toh
argument_list|(
name|beacon
operator|->
name|consecutive
argument_list|)
operator|,
name|vap
operator|->
name|iv_bmissthreshold
operator|)
argument_list|)
expr_stmt|;
name|ieee80211_beacon_miss
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
name|sc
operator|->
name|rxq
operator|.
name|cur
operator|=
operator|(
name|sc
operator|->
name|rxq
operator|.
name|cur
operator|+
literal|1
operator|)
operator|%
name|WPI_RX_RING_COUNT
expr_stmt|;
block|}
comment|/* tell the firmware what we have processed */
name|hw
operator|=
operator|(
name|hw
operator|==
literal|0
operator|)
condition|?
name|WPI_RX_RING_COUNT
operator|-
literal|1
else|:
name|hw
operator|-
literal|1
expr_stmt|;
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_RX_WIDX
argument_list|,
name|hw
operator|&
operator|~
literal|7
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|wpi_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|uint32_t
name|r
decl_stmt|;
name|WPI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|r
operator|=
name|WPI_READ
argument_list|(
name|sc
argument_list|,
name|WPI_INTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
operator|||
name|r
operator|==
literal|0xffffffff
condition|)
block|{
name|WPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* disable interrupts */
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ack interrupts */
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_INTR
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|&
operator|(
name|WPI_SW_ERROR
operator||
name|WPI_HW_ERROR
operator|)
condition|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
decl_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"fatal firmware error\n"
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|6
argument_list|,
operator|(
literal|"(%s)\n"
operator|,
operator|(
name|r
operator|&
name|WPI_SW_ERROR
operator|)
condition|?
literal|"(Software Error)"
else|:
literal|"(Hardware Error)"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|!=
name|NULL
condition|)
name|ieee80211_cancel_scan
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|ieee80211_runtask
argument_list|(
name|ic
argument_list|,
operator|&
name|sc
operator|->
name|sc_restarttask
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator|&=
operator|~
name|WPI_FLAG_BUSY
expr_stmt|;
name|WPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|r
operator|&
name|WPI_RX_INTR
condition|)
name|wpi_notif_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|&
name|WPI_ALIVE_INTR
condition|)
comment|/* firmware initialized */
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* re-enable interrupts */
if|if
condition|(
name|sc
operator|->
name|sc_ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_MASK
argument_list|,
name|WPI_INTR_MASK
argument_list|)
expr_stmt|;
name|WPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|wpi_plcp_signal
parameter_list|(
name|int
name|rate
parameter_list|)
block|{
switch|switch
condition|(
name|rate
condition|)
block|{
comment|/* CCK rates (returned values are device-dependent) */
case|case
literal|2
case|:
return|return
literal|10
return|;
case|case
literal|4
case|:
return|return
literal|20
return|;
case|case
literal|11
case|:
return|return
literal|55
return|;
case|case
literal|22
case|:
return|return
literal|110
return|;
comment|/* OFDM rates (cf IEEE Std 802.11a-1999, pp. 14 Table 80) */
comment|/* R1-R4 (ral/ural is R4-R1) */
case|case
literal|12
case|:
return|return
literal|0xd
return|;
case|case
literal|18
case|:
return|return
literal|0xf
return|;
case|case
literal|24
case|:
return|return
literal|0x5
return|;
case|case
literal|36
case|:
return|return
literal|0x7
return|;
case|case
literal|48
case|:
return|return
literal|0x9
return|;
case|case
literal|72
case|:
return|return
literal|0xb
return|;
case|case
literal|96
case|:
return|return
literal|0x1
return|;
case|case
literal|108
case|:
return|return
literal|0x3
return|;
comment|/* unsupported rates (should not get there) */
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* quickly determine if a given rate is CCK or OFDM */
end_comment

begin_define
define|#
directive|define
name|WPI_RATE_IS_OFDM
parameter_list|(
name|rate
parameter_list|)
value|((rate)>= 12&& (rate) != 22)
end_define

begin_comment
comment|/*  * Construct the data packet for a transmit buffer and acutally put  * the buffer onto the transmit ring, kicking the card to process the  * the buffer.  */
end_comment

begin_function
specifier|static
name|int
name|wpi_tx_data
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int
name|ac
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
specifier|const
name|struct
name|chanAccParams
modifier|*
name|cap
init|=
operator|&
name|ic
operator|->
name|ic_wme
operator|.
name|wme_chanParams
decl_stmt|;
name|struct
name|wpi_tx_ring
modifier|*
name|ring
init|=
operator|&
name|sc
operator|->
name|txq
index|[
name|ac
index|]
decl_stmt|;
name|struct
name|wpi_tx_desc
modifier|*
name|desc
decl_stmt|;
name|struct
name|wpi_tx_data
modifier|*
name|data
decl_stmt|;
name|struct
name|wpi_tx_cmd
modifier|*
name|cmd
decl_stmt|;
name|struct
name|wpi_cmd_data
modifier|*
name|tx
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
specifier|const
name|struct
name|ieee80211_txparam
modifier|*
name|tp
decl_stmt|;
name|struct
name|ieee80211_key
modifier|*
name|k
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mnew
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|,
name|nsegs
decl_stmt|,
name|rate
decl_stmt|,
name|hdrlen
decl_stmt|,
name|ismcast
decl_stmt|;
name|bus_dma_segment_t
name|segs
index|[
name|WPI_MAX_SCATTER
index|]
decl_stmt|;
name|desc
operator|=
operator|&
name|ring
operator|->
name|desc
index|[
name|ring
operator|->
name|cur
index|]
expr_stmt|;
name|data
operator|=
operator|&
name|ring
operator|->
name|data
index|[
name|ring
operator|->
name|cur
index|]
expr_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|hdrlen
operator|=
name|ieee80211_hdrsize
argument_list|(
name|wh
argument_list|)
expr_stmt|;
name|ismcast
operator|=
name|IEEE80211_IS_MULTICAST
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
expr_stmt|;
if|if
condition|(
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_WEP
condition|)
block|{
name|k
operator|=
name|ieee80211_crypto_encap
argument_list|(
name|ni
argument_list|,
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
comment|/* packet header may have moved, reset our local pointer */
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
block|}
name|cmd
operator|=
operator|&
name|ring
operator|->
name|cmd
index|[
name|ring
operator|->
name|cur
index|]
expr_stmt|;
name|cmd
operator|->
name|code
operator|=
name|WPI_CMD_TX_DATA
expr_stmt|;
name|cmd
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|qid
operator|=
name|ring
operator|->
name|qid
expr_stmt|;
name|cmd
operator|->
name|idx
operator|=
name|ring
operator|->
name|cur
expr_stmt|;
name|tx
operator|=
operator|(
expr|struct
name|wpi_cmd_data
operator|*
operator|)
name|cmd
operator|->
name|data
expr_stmt|;
name|tx
operator|->
name|flags
operator|=
name|htole32
argument_list|(
name|WPI_TX_AUTO_SEQ
argument_list|)
expr_stmt|;
name|tx
operator|->
name|timeout
operator|=
name|htole16
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|tx
operator|->
name|ofdm_mask
operator|=
literal|0xff
expr_stmt|;
name|tx
operator|->
name|cck_mask
operator|=
literal|0x0f
expr_stmt|;
name|tx
operator|->
name|lifetime
operator|=
name|htole32
argument_list|(
name|WPI_LIFETIME_INFINITE
argument_list|)
expr_stmt|;
name|tx
operator|->
name|id
operator|=
name|ismcast
condition|?
name|WPI_ID_BROADCAST
else|:
name|WPI_ID_BSS
expr_stmt|;
name|tx
operator|->
name|len
operator|=
name|htole16
argument_list|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ismcast
condition|)
block|{
if|if
condition|(
operator|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_QOS
operator|)
operator|==
literal|0
operator|||
operator|!
name|cap
operator|->
name|cap_wmeParams
index|[
name|ac
index|]
operator|.
name|wmep_noackPolicy
condition|)
name|tx
operator|->
name|flags
operator||=
name|htole32
argument_list|(
name|WPI_TX_NEED_ACK
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|+
name|IEEE80211_CRC_LEN
operator|>
name|vap
operator|->
name|iv_rtsthreshold
condition|)
block|{
name|tx
operator|->
name|flags
operator||=
name|htole32
argument_list|(
name|WPI_TX_NEED_RTS
operator||
name|WPI_TX_FULL_TXOP
argument_list|)
expr_stmt|;
name|tx
operator|->
name|rts_ntries
operator|=
literal|7
expr_stmt|;
block|}
block|}
comment|/* pick a rate */
name|tp
operator|=
operator|&
name|vap
operator|->
name|iv_txparms
index|[
name|ieee80211_chan2mode
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_TYPE_MASK
operator|)
operator|==
name|IEEE80211_FC0_TYPE_MGT
condition|)
block|{
name|uint8_t
name|subtype
init|=
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
decl_stmt|;
comment|/* tell h/w to set timestamp in probe responses */
if|if
condition|(
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_PROBE_RESP
condition|)
name|tx
operator|->
name|flags
operator||=
name|htole32
argument_list|(
name|WPI_TX_INSERT_TSTAMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_ASSOC_REQ
operator|||
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_REASSOC_REQ
condition|)
name|tx
operator|->
name|timeout
operator|=
name|htole16
argument_list|(
literal|3
argument_list|)
expr_stmt|;
else|else
name|tx
operator|->
name|timeout
operator|=
name|htole16
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|rate
operator|=
name|tp
operator|->
name|mgmtrate
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ismcast
condition|)
block|{
name|rate
operator|=
name|tp
operator|->
name|mcastrate
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tp
operator|->
name|ucastrate
operator|!=
name|IEEE80211_FIXED_RATE_NONE
condition|)
block|{
name|rate
operator|=
name|tp
operator|->
name|ucastrate
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|ieee80211_ratectl_rate
argument_list|(
name|ni
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rate
operator|=
name|ni
operator|->
name|ni_txrate
expr_stmt|;
block|}
name|tx
operator|->
name|rate
operator|=
name|wpi_plcp_signal
argument_list|(
name|rate
argument_list|)
expr_stmt|;
comment|/* be very persistant at sending frames out */
if|#
directive|if
literal|0
block|tx->data_ntries = tp->maxretry;
else|#
directive|else
name|tx
operator|->
name|data_ntries
operator|=
literal|15
expr_stmt|;
comment|/* XXX way too high */
endif|#
directive|endif
if|if
condition|(
name|ieee80211_radiotap_active_vap
argument_list|(
name|vap
argument_list|)
condition|)
block|{
name|struct
name|wpi_tx_radiotap_header
modifier|*
name|tap
init|=
operator|&
name|sc
operator|->
name|sc_txtap
decl_stmt|;
name|tap
operator|->
name|wt_flags
operator|=
literal|0
expr_stmt|;
name|tap
operator|->
name|wt_rate
operator|=
name|rate
expr_stmt|;
name|tap
operator|->
name|wt_hwqueue
operator|=
name|ac
expr_stmt|;
if|if
condition|(
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_WEP
condition|)
name|tap
operator|->
name|wt_flags
operator||=
name|IEEE80211_RADIOTAP_F_WEP
expr_stmt|;
name|ieee80211_radiotap_tx
argument_list|(
name|vap
argument_list|,
name|m0
argument_list|)
expr_stmt|;
block|}
comment|/* save and trim IEEE802.11 header */
name|m_copydata
argument_list|(
name|m0
argument_list|,
literal|0
argument_list|,
name|hdrlen
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|tx
operator|->
name|wh
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m0
argument_list|,
name|hdrlen
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|m0
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|EFBIG
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not map mbuf (error %d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* XXX use m_collapse */
name|mnew
operator|=
name|m_defrag
argument_list|(
name|m0
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mnew
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not defragment mbuf\n"
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
name|m0
operator|=
name|mnew
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|m0
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not map mbuf (error %d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
name|data
operator|->
name|m
operator|=
name|m0
expr_stmt|;
name|data
operator|->
name|ni
operator|=
name|ni
expr_stmt|;
name|DPRINTFN
argument_list|(
name|WPI_DEBUG_TX
argument_list|,
operator|(
literal|"sending data: qid=%d idx=%d len=%d nsegs=%d\n"
operator|,
name|ring
operator|->
name|qid
operator|,
name|ring
operator|->
name|cur
operator|,
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|,
name|nsegs
operator|)
argument_list|)
expr_stmt|;
comment|/* first scatter/gather segment is used by the tx data command */
name|desc
operator|->
name|flags
operator|=
name|htole32
argument_list|(
name|WPI_PAD32
argument_list|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
operator|<<
literal|28
operator||
operator|(
literal|1
operator|+
name|nsegs
operator|)
operator|<<
literal|24
argument_list|)
expr_stmt|;
name|desc
operator|->
name|segs
index|[
literal|0
index|]
operator|.
name|addr
operator|=
name|htole32
argument_list|(
name|ring
operator|->
name|cmd_dma
operator|.
name|paddr
operator|+
name|ring
operator|->
name|cur
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|wpi_tx_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|desc
operator|->
name|segs
index|[
literal|0
index|]
operator|.
name|len
operator|=
name|htole32
argument_list|(
literal|4
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|wpi_cmd_data
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nsegs
condition|;
name|i
operator|++
control|)
block|{
name|desc
operator|->
name|segs
index|[
name|i
index|]
operator|.
name|addr
operator|=
name|htole32
argument_list|(
name|segs
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|desc
operator|->
name|segs
index|[
name|i
index|]
operator|.
name|len
operator|=
name|htole32
argument_list|(
name|segs
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|ds_len
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|desc_dma
operator|.
name|tag
argument_list|,
name|ring
operator|->
name|desc_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|ring
operator|->
name|queued
operator|++
expr_stmt|;
comment|/* kick ring */
name|ring
operator|->
name|cur
operator|=
operator|(
name|ring
operator|->
name|cur
operator|+
literal|1
operator|)
operator|%
name|WPI_TX_RING_COUNT
expr_stmt|;
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_TX_WIDX
argument_list|,
name|ring
operator|->
name|qid
operator|<<
literal|8
operator||
name|ring
operator|->
name|cur
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Process data waiting to be sent on the IFNET output queue  */
end_comment

begin_function
specifier|static
name|void
name|wpi_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|wpi_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|WPI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|wpi_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|WPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|wpi_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|ac
decl_stmt|;
name|WPI_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return;
for|for
control|(
init|;
condition|;
control|)
block|{
name|IFQ_DRV_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|ac
operator|=
name|M_WME_GETAC
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|txq
index|[
name|ac
index|]
operator|.
name|queued
operator|>
name|sc
operator|->
name|txq
index|[
name|ac
index|]
operator|.
name|count
operator|-
literal|8
condition|)
block|{
comment|/* there is no place left in this ring */
name|IFQ_DRV_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
break|break;
block|}
name|ni
operator|=
operator|(
expr|struct
name|ieee80211_node
operator|*
operator|)
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
if|if
condition|(
name|wpi_tx_data
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
name|ni
argument_list|,
name|ac
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|sc_tx_timer
operator|=
literal|5
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|wpi_raw_xmit
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|ieee80211_bpf_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|wpi_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
comment|/* prevent management frames from being sent if we're not ready */
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
return|return
name|ENETDOWN
return|;
block|}
name|WPI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* management frames go into ring 0 */
if|if
condition|(
name|sc
operator|->
name|txq
index|[
literal|0
index|]
operator|.
name|queued
operator|>
name|sc
operator|->
name|txq
index|[
literal|0
index|]
operator|.
name|count
operator|-
literal|8
condition|)
block|{
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|WPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
comment|/* XXX */
block|}
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
if|if
condition|(
name|wpi_tx_data
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
name|ni
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
name|sc
operator|->
name|sc_tx_timer
operator|=
literal|5
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|watchdog_to
argument_list|,
name|hz
argument_list|,
name|wpi_watchdog
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|WPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|bad
label|:
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|WPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
comment|/* XXX */
block|}
end_function

begin_function
specifier|static
name|int
name|wpi_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|wpi_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|startall
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFFLAGS
case|:
name|WPI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
name|wpi_init_locked
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|startall
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|||
operator|(
name|sc
operator|->
name|flags
operator|&
name|WPI_FLAG_HW_RADIO_OFF
operator|)
condition|)
name|wpi_stop_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|WPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|startall
condition|)
name|ieee80211_start_all
argument_list|(
name|ic
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCGIFMEDIA
case|:
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|ic
operator|->
name|ic_media
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCGIFADDR
case|:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Extract various information from EEPROM.  */
end_comment

begin_function
specifier|static
name|void
name|wpi_read_eeprom
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|macaddr
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* read the hardware capabilities, revision and SKU type */
name|wpi_read_prom_data
argument_list|(
name|sc
argument_list|,
name|WPI_EEPROM_CAPABILITIES
argument_list|,
operator|&
name|sc
operator|->
name|cap
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|wpi_read_prom_data
argument_list|(
name|sc
argument_list|,
name|WPI_EEPROM_REVISION
argument_list|,
operator|&
name|sc
operator|->
name|rev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|wpi_read_prom_data
argument_list|(
name|sc
argument_list|,
name|WPI_EEPROM_TYPE
argument_list|,
operator|&
name|sc
operator|->
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* read the regulatory domain */
name|wpi_read_prom_data
argument_list|(
name|sc
argument_list|,
name|WPI_EEPROM_DOMAIN
argument_list|,
name|sc
operator|->
name|domain
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* read in the hw MAC address */
name|wpi_read_prom_data
argument_list|(
name|sc
argument_list|,
name|WPI_EEPROM_MAC
argument_list|,
name|macaddr
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* read the list of authorized channels */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|WPI_CHAN_BANDS_COUNT
condition|;
name|i
operator|++
control|)
name|wpi_read_eeprom_channels
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* read the power level calibration info for each group */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|WPI_POWER_GROUPS_COUNT
condition|;
name|i
operator|++
control|)
name|wpi_read_eeprom_group
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send a command to the firmware.  */
end_comment

begin_function
specifier|static
name|int
name|wpi_cmd
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|code
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|async
parameter_list|)
block|{
name|struct
name|wpi_tx_ring
modifier|*
name|ring
init|=
operator|&
name|sc
operator|->
name|cmdq
decl_stmt|;
name|struct
name|wpi_tx_desc
modifier|*
name|desc
decl_stmt|;
name|struct
name|wpi_tx_cmd
modifier|*
name|cmd
decl_stmt|;
ifdef|#
directive|ifdef
name|WPI_DEBUG
if|if
condition|(
operator|!
name|async
condition|)
block|{
name|WPI_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|DPRINTFN
argument_list|(
name|WPI_DEBUG_CMD
argument_list|,
operator|(
literal|"wpi_cmd %d size %d async %d\n"
operator|,
name|code
operator|,
name|size
operator|,
name|async
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|WPI_FLAG_BUSY
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: cmd %d not sent, busy\n"
argument_list|,
name|__func__
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return
name|EAGAIN
return|;
block|}
name|sc
operator|->
name|flags
operator||=
name|WPI_FLAG_BUSY
expr_stmt|;
name|KASSERT
argument_list|(
name|size
operator|<=
sizeof|sizeof
name|cmd
operator|->
name|data
argument_list|,
operator|(
literal|"command %d too large: %d bytes"
operator|,
name|code
operator|,
name|size
operator|)
argument_list|)
expr_stmt|;
name|desc
operator|=
operator|&
name|ring
operator|->
name|desc
index|[
name|ring
operator|->
name|cur
index|]
expr_stmt|;
name|cmd
operator|=
operator|&
name|ring
operator|->
name|cmd
index|[
name|ring
operator|->
name|cur
index|]
expr_stmt|;
name|cmd
operator|->
name|code
operator|=
name|code
expr_stmt|;
name|cmd
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|qid
operator|=
name|ring
operator|->
name|qid
expr_stmt|;
name|cmd
operator|->
name|idx
operator|=
name|ring
operator|->
name|cur
expr_stmt|;
name|memcpy
argument_list|(
name|cmd
operator|->
name|data
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|desc
operator|->
name|flags
operator|=
name|htole32
argument_list|(
name|WPI_PAD32
argument_list|(
name|size
argument_list|)
operator|<<
literal|28
operator||
literal|1
operator|<<
literal|24
argument_list|)
expr_stmt|;
name|desc
operator|->
name|segs
index|[
literal|0
index|]
operator|.
name|addr
operator|=
name|htole32
argument_list|(
name|ring
operator|->
name|cmd_dma
operator|.
name|paddr
operator|+
name|ring
operator|->
name|cur
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|wpi_tx_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|desc
operator|->
name|segs
index|[
literal|0
index|]
operator|.
name|len
operator|=
name|htole32
argument_list|(
literal|4
operator|+
name|size
argument_list|)
expr_stmt|;
comment|/* kick cmd ring */
name|ring
operator|->
name|cur
operator|=
operator|(
name|ring
operator|->
name|cur
operator|+
literal|1
operator|)
operator|%
name|WPI_CMD_RING_COUNT
expr_stmt|;
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_TX_WIDX
argument_list|,
name|ring
operator|->
name|qid
operator|<<
literal|8
operator||
name|ring
operator|->
name|cur
argument_list|)
expr_stmt|;
if|if
condition|(
name|async
condition|)
block|{
name|sc
operator|->
name|flags
operator|&=
operator|~
name|WPI_FLAG_BUSY
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|msleep
argument_list|(
name|cmd
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
name|PCATCH
argument_list|,
literal|"wpicmd"
argument_list|,
name|hz
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wpi_wme_update
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
define|#
directive|define
name|WPI_EXP2
parameter_list|(
name|v
parameter_list|)
value|htole16((1<< (v)) - 1)
define|#
directive|define
name|WPI_USEC
parameter_list|(
name|v
parameter_list|)
value|htole16(IEEE80211_TXOP_TO_US(v))
name|struct
name|wpi_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
specifier|const
name|struct
name|wmeParams
modifier|*
name|wmep
decl_stmt|;
name|struct
name|wpi_wme_setup
name|wme
decl_stmt|;
name|int
name|ac
decl_stmt|;
comment|/* don't override default WME values if WME is not actually enabled */
if|if
condition|(
operator|!
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_WME
operator|)
condition|)
return|return
literal|0
return|;
name|wme
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ac
operator|=
literal|0
init|;
name|ac
operator|<
name|WME_NUM_AC
condition|;
name|ac
operator|++
control|)
block|{
name|wmep
operator|=
operator|&
name|ic
operator|->
name|ic_wme
operator|.
name|wme_chanParams
operator|.
name|cap_wmeParams
index|[
name|ac
index|]
expr_stmt|;
name|wme
operator|.
name|ac
index|[
name|ac
index|]
operator|.
name|aifsn
operator|=
name|wmep
operator|->
name|wmep_aifsn
expr_stmt|;
name|wme
operator|.
name|ac
index|[
name|ac
index|]
operator|.
name|cwmin
operator|=
name|WPI_EXP2
argument_list|(
name|wmep
operator|->
name|wmep_logcwmin
argument_list|)
expr_stmt|;
name|wme
operator|.
name|ac
index|[
name|ac
index|]
operator|.
name|cwmax
operator|=
name|WPI_EXP2
argument_list|(
name|wmep
operator|->
name|wmep_logcwmax
argument_list|)
expr_stmt|;
name|wme
operator|.
name|ac
index|[
name|ac
index|]
operator|.
name|txop
operator|=
name|WPI_USEC
argument_list|(
name|wmep
operator|->
name|wmep_txopLimit
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"setting WME for queue %d aifsn=%d cwmin=%d cwmax=%d "
literal|"txop=%d\n"
operator|,
name|ac
operator|,
name|wme
operator|.
name|ac
index|[
name|ac
index|]
operator|.
name|aifsn
operator|,
name|wme
operator|.
name|ac
index|[
name|ac
index|]
operator|.
name|cwmin
operator|,
name|wme
operator|.
name|ac
index|[
name|ac
index|]
operator|.
name|cwmax
operator|,
name|wme
operator|.
name|ac
index|[
name|ac
index|]
operator|.
name|txop
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|wpi_cmd
argument_list|(
name|sc
argument_list|,
name|WPI_CMD_SET_WME
argument_list|,
operator|&
name|wme
argument_list|,
sizeof|sizeof
name|wme
argument_list|,
literal|1
argument_list|)
return|;
undef|#
directive|undef
name|WPI_USEC
undef|#
directive|undef
name|WPI_EXP2
block|}
end_function

begin_comment
comment|/*  * Configure h/w multi-rate retries.  */
end_comment

begin_function
specifier|static
name|int
name|wpi_mrr_setup
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|wpi_mrr_setup
name|mrr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|memset
argument_list|(
operator|&
name|mrr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|wpi_mrr_setup
argument_list|)
argument_list|)
expr_stmt|;
comment|/* CCK rates (not used with 802.11a) */
for|for
control|(
name|i
operator|=
name|WPI_CCK1
init|;
name|i
operator|<=
name|WPI_CCK11
condition|;
name|i
operator|++
control|)
block|{
name|mrr
operator|.
name|rates
index|[
name|i
index|]
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|mrr
operator|.
name|rates
index|[
name|i
index|]
operator|.
name|signal
operator|=
name|wpi_ridx_to_plcp
index|[
name|i
index|]
expr_stmt|;
comment|/* fallback to the immediate lower CCK rate (if any) */
name|mrr
operator|.
name|rates
index|[
name|i
index|]
operator|.
name|next
operator|=
operator|(
name|i
operator|==
name|WPI_CCK1
operator|)
condition|?
name|WPI_CCK1
else|:
name|i
operator|-
literal|1
expr_stmt|;
comment|/* try one time at this rate before falling back to "next" */
name|mrr
operator|.
name|rates
index|[
name|i
index|]
operator|.
name|ntries
operator|=
literal|1
expr_stmt|;
block|}
comment|/* OFDM rates (not used with 802.11b) */
for|for
control|(
name|i
operator|=
name|WPI_OFDM6
init|;
name|i
operator|<=
name|WPI_OFDM54
condition|;
name|i
operator|++
control|)
block|{
name|mrr
operator|.
name|rates
index|[
name|i
index|]
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|mrr
operator|.
name|rates
index|[
name|i
index|]
operator|.
name|signal
operator|=
name|wpi_ridx_to_plcp
index|[
name|i
index|]
expr_stmt|;
comment|/* fallback to the immediate lower OFDM rate (if any) */
comment|/* we allow fallback from OFDM/6 to CCK/2 in 11b/g mode */
name|mrr
operator|.
name|rates
index|[
name|i
index|]
operator|.
name|next
operator|=
operator|(
name|i
operator|==
name|WPI_OFDM6
operator|)
condition|?
operator|(
operator|(
name|ic
operator|->
name|ic_curmode
operator|==
name|IEEE80211_MODE_11A
operator|)
condition|?
name|WPI_OFDM6
else|:
name|WPI_CCK2
operator|)
else|:
name|i
operator|-
literal|1
expr_stmt|;
comment|/* try one time at this rate before falling back to "next" */
name|mrr
operator|.
name|rates
index|[
name|i
index|]
operator|.
name|ntries
operator|=
literal|1
expr_stmt|;
block|}
comment|/* setup MRR for control frames */
name|mrr
operator|.
name|which
operator|=
name|WPI_MRR_CTL
expr_stmt|;
name|error
operator|=
name|wpi_cmd
argument_list|(
name|sc
argument_list|,
name|WPI_CMD_MRR_SETUP
argument_list|,
operator|&
name|mrr
argument_list|,
sizeof|sizeof
name|mrr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not setup MRR for control frames\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* setup MRR for data frames */
name|mrr
operator|.
name|which
operator|=
name|WPI_MRR_DATA
expr_stmt|;
name|error
operator|=
name|wpi_cmd
argument_list|(
name|sc
argument_list|,
name|WPI_CMD_MRR_SETUP
argument_list|,
operator|&
name|mrr
argument_list|,
sizeof|sizeof
name|mrr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not setup MRR for data frames\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_set_led
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|which
parameter_list|,
name|uint8_t
name|off
parameter_list|,
name|uint8_t
name|on
parameter_list|)
block|{
name|struct
name|wpi_cmd_led
name|led
decl_stmt|;
name|led
operator|.
name|which
operator|=
name|which
expr_stmt|;
name|led
operator|.
name|unit
operator|=
name|htole32
argument_list|(
literal|100000
argument_list|)
expr_stmt|;
comment|/* on/off in unit of 100ms */
name|led
operator|.
name|off
operator|=
name|off
expr_stmt|;
name|led
operator|.
name|on
operator|=
name|on
expr_stmt|;
operator|(
name|void
operator|)
name|wpi_cmd
argument_list|(
name|sc
argument_list|,
name|WPI_CMD_SET_LED
argument_list|,
operator|&
name|led
argument_list|,
sizeof|sizeof
name|led
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_enable_tsf
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|wpi_cmd_tsf
name|tsf
decl_stmt|;
name|uint64_t
name|val
decl_stmt|,
name|mod
decl_stmt|;
name|memset
argument_list|(
operator|&
name|tsf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|tsf
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|tsf
operator|.
name|tstamp
argument_list|,
name|ni
operator|->
name|ni_tstamp
operator|.
name|data
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|tsf
operator|.
name|bintval
operator|=
name|htole16
argument_list|(
name|ni
operator|->
name|ni_intval
argument_list|)
expr_stmt|;
name|tsf
operator|.
name|lintval
operator|=
name|htole16
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* compute remaining time until next beacon */
name|val
operator|=
operator|(
name|uint64_t
operator|)
name|ni
operator|->
name|ni_intval
operator|*
literal|1024
expr_stmt|;
comment|/* msec -> usec */
name|mod
operator|=
name|le64toh
argument_list|(
name|tsf
operator|.
name|tstamp
argument_list|)
operator|%
name|val
expr_stmt|;
name|tsf
operator|.
name|binitval
operator|=
name|htole32
argument_list|(
call|(
name|uint32_t
call|)
argument_list|(
name|val
operator|-
name|mod
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpi_cmd
argument_list|(
name|sc
argument_list|,
name|WPI_CMD_TSF
argument_list|,
operator|&
name|tsf
argument_list|,
sizeof|sizeof
name|tsf
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not enable TSF\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * Build a beacon frame that the firmware will broadcast periodically in  * IBSS or HostAP modes.  */
end_comment

begin_comment
unit|static int wpi_setup_beacon(struct wpi_softc *sc, struct ieee80211_node *ni) { 	struct ifnet *ifp = sc->sc_ifp; 	struct ieee80211com *ic = ifp->if_l2com; 	struct wpi_tx_ring *ring =&sc->cmdq; 	struct wpi_tx_desc *desc; 	struct wpi_tx_data *data; 	struct wpi_tx_cmd *cmd; 	struct wpi_cmd_beacon *bcn; 	struct ieee80211_beacon_offsets bo; 	struct mbuf *m0; 	bus_addr_t physaddr; 	int error;  	desc =&ring->desc[ring->cur]; 	data =&ring->data[ring->cur];  	m0 = ieee80211_beacon_alloc(ic, ni,&bo); 	if (m0 == NULL) { 		device_printf(sc->sc_dev, "could not allocate beacon frame\n"); 		return ENOMEM; 	}  	cmd =&ring->cmd[ring->cur]; 	cmd->code = WPI_CMD_SET_BEACON; 	cmd->flags = 0; 	cmd->qid = ring->qid; 	cmd->idx = ring->cur;  	bcn = (struct wpi_cmd_beacon *)cmd->data; 	memset(bcn, 0, sizeof (struct wpi_cmd_beacon)); 	bcn->id = WPI_ID_BROADCAST; 	bcn->ofdm_mask = 0xff; 	bcn->cck_mask = 0x0f; 	bcn->lifetime = htole32(WPI_LIFETIME_INFINITE); 	bcn->len = htole16(m0->m_pkthdr.len); 	bcn->rate = (ic->ic_curmode == IEEE80211_MODE_11A) ? 		wpi_plcp_signal(12) : wpi_plcp_signal(2); 	bcn->flags = htole32(WPI_TX_AUTO_SEQ | WPI_TX_INSERT_TSTAMP);
comment|/* save and trim IEEE802.11 header */
end_comment

begin_comment
unit|m_copydata(m0, 0, sizeof (struct ieee80211_frame), (caddr_t)&bcn->wh); 	m_adj(m0, sizeof (struct ieee80211_frame));
comment|/* assume beacon frame is contiguous */
end_comment

begin_comment
unit|error = bus_dmamap_load(ring->data_dmat, data->map, mtod(m0, void *), 	    m0->m_pkthdr.len, wpi_dma_map_addr,&physaddr, 0); 	if (error != 0) { 		device_printf(sc->sc_dev, "could not map beacon\n"); 		m_freem(m0); 		return error; 	}  	data->m = m0;
comment|/* first scatter/gather segment is used by the beacon command */
end_comment

begin_comment
unit|desc->flags = htole32(WPI_PAD32(m0->m_pkthdr.len)<< 28 | 2<< 24); 	desc->segs[0].addr = htole32(ring->cmd_dma.paddr + 		ring->cur * sizeof (struct wpi_tx_cmd)); 	desc->segs[0].len  = htole32(4 + sizeof (struct wpi_cmd_beacon)); 	desc->segs[1].addr = htole32(physaddr); 	desc->segs[1].len  = htole32(m0->m_pkthdr.len);
comment|/* kick cmd ring */
end_comment

begin_endif
unit|ring->cur = (ring->cur + 1) % WPI_CMD_RING_COUNT; 	WPI_WRITE(sc, WPI_TX_WIDX, ring->qid<< 8 | ring->cur);  	return 0; }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|wpi_auth
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|vap
operator|->
name|iv_bss
decl_stmt|;
name|struct
name|wpi_node_info
name|node
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* update adapter's configuration */
name|sc
operator|->
name|config
operator|.
name|associd
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|filter
operator|&=
operator|~
name|htole32
argument_list|(
name|WPI_FILTER_BSS
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|sc
operator|->
name|config
operator|.
name|bssid
argument_list|,
name|ni
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|chan
operator|=
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ni
operator|->
name|ni_chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|)
block|{
name|sc
operator|->
name|config
operator|.
name|flags
operator||=
name|htole32
argument_list|(
name|WPI_CONFIG_AUTO
operator||
name|WPI_CONFIG_24GHZ
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|config
operator|.
name|flags
operator|&=
operator|~
name|htole32
argument_list|(
name|WPI_CONFIG_AUTO
operator||
name|WPI_CONFIG_24GHZ
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IEEE80211_IS_CHAN_A
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|)
block|{
name|sc
operator|->
name|config
operator|.
name|cck_mask
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|ofdm_mask
operator|=
literal|0x15
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_B
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|)
block|{
name|sc
operator|->
name|config
operator|.
name|cck_mask
operator|=
literal|0x03
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|ofdm_mask
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX assume 802.11b/g */
name|sc
operator|->
name|config
operator|.
name|cck_mask
operator|=
literal|0x0f
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|ofdm_mask
operator|=
literal|0x15
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
operator|(
literal|"config chan %d flags %x cck %x ofdm %x\n"
operator|,
name|sc
operator|->
name|config
operator|.
name|chan
operator|,
name|sc
operator|->
name|config
operator|.
name|flags
operator|,
name|sc
operator|->
name|config
operator|.
name|cck_mask
operator|,
name|sc
operator|->
name|config
operator|.
name|ofdm_mask
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|wpi_cmd
argument_list|(
name|sc
argument_list|,
name|WPI_CMD_CONFIGURE
argument_list|,
operator|&
name|sc
operator|->
name|config
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|wpi_config
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not configure\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* configuration has changed, set Tx power accordingly */
if|if
condition|(
operator|(
name|error
operator|=
name|wpi_set_txpower
argument_list|(
name|sc
argument_list|,
name|ni
operator|->
name|ni_chan
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not set Tx power\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* add default node */
name|memset
argument_list|(
operator|&
name|node
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|node
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|node
operator|.
name|bssid
argument_list|,
name|ni
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
name|node
operator|.
name|id
operator|=
name|WPI_ID_BSS
expr_stmt|;
name|node
operator|.
name|rate
operator|=
operator|(
name|ic
operator|->
name|ic_curmode
operator|==
name|IEEE80211_MODE_11A
operator|)
condition|?
name|wpi_plcp_signal
argument_list|(
literal|12
argument_list|)
else|:
name|wpi_plcp_signal
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|node
operator|.
name|action
operator|=
name|htole32
argument_list|(
name|WPI_ACTION_SET_RATE
argument_list|)
expr_stmt|;
name|node
operator|.
name|antenna
operator|=
name|WPI_ANTENNA_BOTH
expr_stmt|;
name|error
operator|=
name|wpi_cmd
argument_list|(
name|sc
argument_list|,
name|WPI_CMD_ADD_NODE
argument_list|,
operator|&
name|node
argument_list|,
sizeof|sizeof
name|node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not add BSS node\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wpi_run
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|vap
operator|->
name|iv_bss
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_MONITOR
condition|)
block|{
comment|/* link LED blinks while monitoring */
name|wpi_set_led
argument_list|(
name|sc
argument_list|,
name|WPI_LED_LINK
argument_list|,
literal|5
argument_list|,
literal|5
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|wpi_enable_tsf
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|)
expr_stmt|;
comment|/* update adapter's configuration */
name|sc
operator|->
name|config
operator|.
name|associd
operator|=
name|htole16
argument_list|(
name|ni
operator|->
name|ni_associd
operator|&
operator|~
literal|0xc000
argument_list|)
expr_stmt|;
comment|/* short preamble/slot time are negotiated when associating */
name|sc
operator|->
name|config
operator|.
name|flags
operator|&=
operator|~
name|htole32
argument_list|(
name|WPI_CONFIG_SHPREAMBLE
operator||
name|WPI_CONFIG_SHSLOT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHSLOT
condition|)
name|sc
operator|->
name|config
operator|.
name|flags
operator||=
name|htole32
argument_list|(
name|WPI_CONFIG_SHSLOT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHPREAMBLE
condition|)
name|sc
operator|->
name|config
operator|.
name|flags
operator||=
name|htole32
argument_list|(
name|WPI_CONFIG_SHPREAMBLE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|filter
operator||=
name|htole32
argument_list|(
name|WPI_FILTER_BSS
argument_list|)
expr_stmt|;
comment|/* XXX put somewhere HC_QOS_SUPPORT_ASSOC + HC_IBSS_START */
name|DPRINTF
argument_list|(
operator|(
literal|"config chan %d flags %x\n"
operator|,
name|sc
operator|->
name|config
operator|.
name|chan
operator|,
name|sc
operator|->
name|config
operator|.
name|flags
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|wpi_cmd
argument_list|(
name|sc
argument_list|,
name|WPI_CMD_CONFIGURE
argument_list|,
operator|&
name|sc
operator|->
name|config
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|wpi_config
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not update configuration\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|error
operator|=
name|wpi_set_txpower
argument_list|(
name|sc
argument_list|,
name|ni
operator|->
name|ni_chan
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could set txpower\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* link LED always on while associated */
name|wpi_set_led
argument_list|(
name|sc
argument_list|,
name|WPI_LED_LINK
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* start automatic rate control timer */
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|calib_to
argument_list|,
literal|60
operator|*
name|hz
argument_list|,
name|wpi_calib_timeout
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send a scan request to the firmware.  Since this command is huge, we map it  * into a mbufcluster instead of using the pre-allocated set of commands. Note,  * much of this code is similar to that in wpi_cmd but because we must manually  * construct the probe& channels, we duplicate what's needed here. XXX In the  * future, this function should be modified to use wpi_cmd to help cleanup the  * code base.  */
end_comment

begin_function
specifier|static
name|int
name|wpi_scan
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
init|=
name|ic
operator|->
name|ic_scan
decl_stmt|;
name|struct
name|wpi_tx_ring
modifier|*
name|ring
init|=
operator|&
name|sc
operator|->
name|cmdq
decl_stmt|;
name|struct
name|wpi_tx_desc
modifier|*
name|desc
decl_stmt|;
name|struct
name|wpi_tx_data
modifier|*
name|data
decl_stmt|;
name|struct
name|wpi_tx_cmd
modifier|*
name|cmd
decl_stmt|;
name|struct
name|wpi_scan_hdr
modifier|*
name|hdr
decl_stmt|;
name|struct
name|wpi_scan_chan
modifier|*
name|chan
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|struct
name|ieee80211_rateset
modifier|*
name|rs
decl_stmt|;
name|struct
name|ieee80211_channel
modifier|*
name|c
decl_stmt|;
name|enum
name|ieee80211_phymode
name|mode
decl_stmt|;
name|uint8_t
modifier|*
name|frm
decl_stmt|;
name|int
name|nrates
decl_stmt|,
name|pktlen
decl_stmt|,
name|error
decl_stmt|,
name|i
decl_stmt|,
name|nssid
decl_stmt|;
name|bus_addr_t
name|physaddr
decl_stmt|;
name|desc
operator|=
operator|&
name|ring
operator|->
name|desc
index|[
name|ring
operator|->
name|cur
index|]
expr_stmt|;
name|data
operator|=
operator|&
name|ring
operator|->
name|data
index|[
name|ring
operator|->
name|cur
index|]
expr_stmt|;
name|data
operator|->
name|m
operator|=
name|m_getcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|m
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not allocate mbuf for scan command\n"
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|cmd
operator|=
name|mtod
argument_list|(
name|data
operator|->
name|m
argument_list|,
expr|struct
name|wpi_tx_cmd
operator|*
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|code
operator|=
name|WPI_CMD_SCAN
expr_stmt|;
name|cmd
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|qid
operator|=
name|ring
operator|->
name|qid
expr_stmt|;
name|cmd
operator|->
name|idx
operator|=
name|ring
operator|->
name|cur
expr_stmt|;
name|hdr
operator|=
operator|(
expr|struct
name|wpi_scan_hdr
operator|*
operator|)
name|cmd
operator|->
name|data
expr_stmt|;
name|memset
argument_list|(
name|hdr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|wpi_scan_hdr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Move to the next channel if no packets are received within 5 msecs 	 * after sending the probe request (this helps to reduce the duration 	 * of active scans). 	 */
name|hdr
operator|->
name|quiet
operator|=
name|htole16
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|threshold
operator|=
name|htole16
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_A
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
condition|)
block|{
comment|/* send probe requests at 6Mbps */
name|hdr
operator|->
name|tx
operator|.
name|rate
operator|=
name|wpi_ridx_to_plcp
index|[
name|WPI_OFDM6
index|]
expr_stmt|;
comment|/* Enable crc checking */
name|hdr
operator|->
name|promotion
operator|=
name|htole16
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hdr
operator|->
name|flags
operator|=
name|htole32
argument_list|(
name|WPI_CONFIG_24GHZ
operator||
name|WPI_CONFIG_AUTO
argument_list|)
expr_stmt|;
comment|/* send probe requests at 1Mbps */
name|hdr
operator|->
name|tx
operator|.
name|rate
operator|=
name|wpi_ridx_to_plcp
index|[
name|WPI_CCK1
index|]
expr_stmt|;
block|}
name|hdr
operator|->
name|tx
operator|.
name|id
operator|=
name|WPI_ID_BROADCAST
expr_stmt|;
name|hdr
operator|->
name|tx
operator|.
name|lifetime
operator|=
name|htole32
argument_list|(
name|WPI_LIFETIME_INFINITE
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|tx
operator|.
name|flags
operator|=
name|htole32
argument_list|(
name|WPI_TX_AUTO_SEQ
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|hdr
operator|->
name|scan_essids
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
operator|->
name|scan_essids
argument_list|)
argument_list|)
expr_stmt|;
name|nssid
operator|=
name|MIN
argument_list|(
name|ss
operator|->
name|ss_nssid
argument_list|,
name|WPI_SCAN_MAX_ESSIDS
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nssid
condition|;
name|i
operator|++
control|)
block|{
name|hdr
operator|->
name|scan_essids
index|[
name|i
index|]
operator|.
name|id
operator|=
name|IEEE80211_ELEMID_SSID
expr_stmt|;
name|hdr
operator|->
name|scan_essids
index|[
name|i
index|]
operator|.
name|esslen
operator|=
name|MIN
argument_list|(
name|ss
operator|->
name|ss_ssid
index|[
name|i
index|]
operator|.
name|len
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|hdr
operator|->
name|scan_essids
index|[
name|i
index|]
operator|.
name|essid
argument_list|,
name|ss
operator|->
name|ss_ssid
index|[
name|i
index|]
operator|.
name|ssid
argument_list|,
name|hdr
operator|->
name|scan_essids
index|[
name|i
index|]
operator|.
name|esslen
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WPI_DEBUG
if|if
condition|(
name|wpi_debug
operator|&
name|WPI_DEBUG_SCANNING
condition|)
block|{
name|printf
argument_list|(
literal|"Scanning Essid: "
argument_list|)
expr_stmt|;
name|ieee80211_print_essid
argument_list|(
name|hdr
operator|->
name|scan_essids
index|[
name|i
index|]
operator|.
name|essid
argument_list|,
name|hdr
operator|->
name|scan_essids
index|[
name|i
index|]
operator|.
name|esslen
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/* 	 * Build a probe request frame.  Most of the following code is a 	 * copy& paste of what is done in net80211. 	 */
name|wh
operator|=
operator|(
expr|struct
name|ieee80211_frame
operator|*
operator|)
operator|&
name|hdr
operator|->
name|scan_essids
index|[
literal|4
index|]
expr_stmt|;
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|=
name|IEEE80211_FC0_VERSION_0
operator||
name|IEEE80211_FC0_TYPE_MGT
operator||
name|IEEE80211_FC0_SUBTYPE_PROBE_REQ
expr_stmt|;
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|=
name|IEEE80211_FC1_DIR_NODS
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|,
name|ifp
operator|->
name|if_broadcastaddr
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|,
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|,
name|ifp
operator|->
name|if_broadcastaddr
argument_list|)
expr_stmt|;
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
operator|&
name|wh
operator|->
name|i_dur
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* filled by h/w */
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
operator|&
name|wh
operator|->
name|i_seq
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* filled by h/w */
name|frm
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|wh
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* add essid IE, the hardware will fill this in for us */
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_SSID
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
literal|0
expr_stmt|;
name|mode
operator|=
name|ieee80211_chan2mode
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
name|rs
operator|=
operator|&
name|ic
operator|->
name|ic_sup_rates
index|[
name|mode
index|]
expr_stmt|;
comment|/* add supported rates IE */
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_RATES
expr_stmt|;
name|nrates
operator|=
name|rs
operator|->
name|rs_nrates
expr_stmt|;
if|if
condition|(
name|nrates
operator|>
name|IEEE80211_RATE_SIZE
condition|)
name|nrates
operator|=
name|IEEE80211_RATE_SIZE
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|nrates
expr_stmt|;
name|memcpy
argument_list|(
name|frm
argument_list|,
name|rs
operator|->
name|rs_rates
argument_list|,
name|nrates
argument_list|)
expr_stmt|;
name|frm
operator|+=
name|nrates
expr_stmt|;
comment|/* add supported xrates IE */
if|if
condition|(
name|rs
operator|->
name|rs_nrates
operator|>
name|IEEE80211_RATE_SIZE
condition|)
block|{
name|nrates
operator|=
name|rs
operator|->
name|rs_nrates
operator|-
name|IEEE80211_RATE_SIZE
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_XRATES
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|nrates
expr_stmt|;
name|memcpy
argument_list|(
name|frm
argument_list|,
name|rs
operator|->
name|rs_rates
operator|+
name|IEEE80211_RATE_SIZE
argument_list|,
name|nrates
argument_list|)
expr_stmt|;
name|frm
operator|+=
name|nrates
expr_stmt|;
block|}
comment|/* setup length of probe request */
name|hdr
operator|->
name|tx
operator|.
name|len
operator|=
name|htole16
argument_list|(
name|frm
operator|-
operator|(
name|uint8_t
operator|*
operator|)
name|wh
argument_list|)
expr_stmt|;
comment|/* 	 * Construct information about the channel that we 	 * want to scan. The firmware expects this to be directly 	 * after the scan probe request 	 */
name|c
operator|=
name|ic
operator|->
name|ic_curchan
expr_stmt|;
name|chan
operator|=
operator|(
expr|struct
name|wpi_scan_chan
operator|*
operator|)
name|frm
expr_stmt|;
name|chan
operator|->
name|chan
operator|=
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|chan
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|->
name|ic_flags
operator|&
name|IEEE80211_CHAN_PASSIVE
operator|)
condition|)
block|{
name|chan
operator|->
name|flags
operator||=
name|WPI_CHAN_ACTIVE
expr_stmt|;
if|if
condition|(
name|nssid
operator|!=
literal|0
condition|)
name|chan
operator|->
name|flags
operator||=
name|WPI_CHAN_DIRECT
expr_stmt|;
block|}
name|chan
operator|->
name|gain_dsp
operator|=
literal|0x6e
expr_stmt|;
comment|/* Default level */
if|if
condition|(
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|chan
operator|->
name|active
operator|=
name|htole16
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|chan
operator|->
name|passive
operator|=
name|htole16
argument_list|(
name|ss
operator|->
name|ss_maxdwell
argument_list|)
expr_stmt|;
name|chan
operator|->
name|gain_radio
operator|=
literal|0x3b
expr_stmt|;
block|}
else|else
block|{
name|chan
operator|->
name|active
operator|=
name|htole16
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|chan
operator|->
name|passive
operator|=
name|htole16
argument_list|(
name|ss
operator|->
name|ss_maxdwell
argument_list|)
expr_stmt|;
name|chan
operator|->
name|gain_radio
operator|=
literal|0x28
expr_stmt|;
block|}
name|DPRINTFN
argument_list|(
name|WPI_DEBUG_SCANNING
argument_list|,
operator|(
literal|"Scanning %u Passive: %d\n"
operator|,
name|chan
operator|->
name|chan
operator|,
name|c
operator|->
name|ic_flags
operator|&
name|IEEE80211_CHAN_PASSIVE
operator|)
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|nchan
operator|++
expr_stmt|;
name|chan
operator|++
expr_stmt|;
name|frm
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|wpi_scan_chan
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|// XXX All Channels....
block|for (c  =&ic->ic_channels[1]; 	     c<=&ic->ic_channels[IEEE80211_CHAN_MAX]; c++) { 		if ((c->ic_flags& ic->ic_curchan->ic_flags) != ic->ic_curchan->ic_flags) 			continue;  		chan->chan = ieee80211_chan2ieee(ic, c); 		chan->flags = 0; 		if (!(c->ic_flags& IEEE80211_CHAN_PASSIVE)) { 		    chan->flags |= WPI_CHAN_ACTIVE; 		    if (ic->ic_des_ssid[0].len != 0) 			chan->flags |= WPI_CHAN_DIRECT; 		} 		chan->gain_dsp = 0x6e;
comment|/* Default level */
block|if (IEEE80211_IS_CHAN_5GHZ(c)) { 			chan->active = htole16(10); 			chan->passive = htole16(110); 			chan->gain_radio = 0x3b; 		} else { 			chan->active = htole16(20); 			chan->passive = htole16(120); 			chan->gain_radio = 0x28; 		}  		DPRINTFN(WPI_DEBUG_SCANNING, 			 ("Scanning %u Passive: %d\n", 			  chan->chan, 			  c->ic_flags& IEEE80211_CHAN_PASSIVE));  		hdr->nchan++; 		chan++;  		frm += sizeof (struct wpi_scan_chan); 	}
endif|#
directive|endif
name|hdr
operator|->
name|len
operator|=
name|htole16
argument_list|(
name|frm
operator|-
operator|(
name|uint8_t
operator|*
operator|)
name|hdr
argument_list|)
expr_stmt|;
name|pktlen
operator|=
name|frm
operator|-
operator|(
name|uint8_t
operator|*
operator|)
name|cmd
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|cmd
argument_list|,
name|pktlen
argument_list|,
name|wpi_dma_map_addr
argument_list|,
operator|&
name|physaddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not map scan command\n"
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|data
operator|->
name|m
argument_list|)
expr_stmt|;
name|data
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
return|return
name|error
return|;
block|}
name|desc
operator|->
name|flags
operator|=
name|htole32
argument_list|(
name|WPI_PAD32
argument_list|(
name|pktlen
argument_list|)
operator|<<
literal|28
operator||
literal|1
operator|<<
literal|24
argument_list|)
expr_stmt|;
name|desc
operator|->
name|segs
index|[
literal|0
index|]
operator|.
name|addr
operator|=
name|htole32
argument_list|(
name|physaddr
argument_list|)
expr_stmt|;
name|desc
operator|->
name|segs
index|[
literal|0
index|]
operator|.
name|len
operator|=
name|htole32
argument_list|(
name|pktlen
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|desc_dma
operator|.
name|tag
argument_list|,
name|ring
operator|->
name|desc_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* kick cmd ring */
name|ring
operator|->
name|cur
operator|=
operator|(
name|ring
operator|->
name|cur
operator|+
literal|1
operator|)
operator|%
name|WPI_CMD_RING_COUNT
expr_stmt|;
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_TX_WIDX
argument_list|,
name|ring
operator|->
name|qid
operator|<<
literal|8
operator||
name|ring
operator|->
name|cur
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_scan_timer
operator|=
literal|5
expr_stmt|;
return|return
literal|0
return|;
comment|/* will be notified async. of failure/success */
block|}
end_function

begin_comment
comment|/**  * Configure the card to listen to a particular channel, this transisions the  * card in to being able to receive frames from remote devices.  */
end_comment

begin_function
specifier|static
name|int
name|wpi_config
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|wpi_power
name|power
decl_stmt|;
name|struct
name|wpi_bluetooth
name|bluetooth
decl_stmt|;
name|struct
name|wpi_node_info
name|node
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* set power mode */
name|memset
argument_list|(
operator|&
name|power
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|power
argument_list|)
expr_stmt|;
name|power
operator|.
name|flags
operator|=
name|htole32
argument_list|(
name|WPI_POWER_CAM
operator||
literal|0x8
argument_list|)
expr_stmt|;
name|error
operator|=
name|wpi_cmd
argument_list|(
name|sc
argument_list|,
name|WPI_CMD_SET_POWER_MODE
argument_list|,
operator|&
name|power
argument_list|,
sizeof|sizeof
name|power
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not set power mode\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* configure bluetooth coexistence */
name|memset
argument_list|(
operator|&
name|bluetooth
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|bluetooth
argument_list|)
expr_stmt|;
name|bluetooth
operator|.
name|flags
operator|=
literal|3
expr_stmt|;
name|bluetooth
operator|.
name|lead
operator|=
literal|0xaa
expr_stmt|;
name|bluetooth
operator|.
name|kill
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|wpi_cmd
argument_list|(
name|sc
argument_list|,
name|WPI_CMD_BLUETOOTH
argument_list|,
operator|&
name|bluetooth
argument_list|,
sizeof|sizeof
name|bluetooth
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not configure bluetooth coexistence\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* configure adapter */
name|memset
argument_list|(
operator|&
name|sc
operator|->
name|config
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|wpi_config
argument_list|)
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|sc
operator|->
name|config
operator|.
name|myaddr
argument_list|,
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
comment|/*set default channel*/
name|sc
operator|->
name|config
operator|.
name|chan
operator|=
name|htole16
argument_list|(
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|flags
operator|=
name|htole32
argument_list|(
name|WPI_CONFIG_TSF
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
condition|)
block|{
name|sc
operator|->
name|config
operator|.
name|flags
operator||=
name|htole32
argument_list|(
name|WPI_CONFIG_AUTO
operator||
name|WPI_CONFIG_24GHZ
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|config
operator|.
name|filter
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|ic
operator|->
name|ic_opmode
condition|)
block|{
case|case
name|IEEE80211_M_STA
case|:
case|case
name|IEEE80211_M_WDS
case|:
comment|/* No know setup, use STA for now */
name|sc
operator|->
name|config
operator|.
name|mode
operator|=
name|WPI_MODE_STA
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|filter
operator||=
name|htole32
argument_list|(
name|WPI_FILTER_MULTICAST
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_IBSS
case|:
case|case
name|IEEE80211_M_AHDEMO
case|:
name|sc
operator|->
name|config
operator|.
name|mode
operator|=
name|WPI_MODE_IBSS
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|filter
operator||=
name|htole32
argument_list|(
name|WPI_FILTER_BEACON
operator||
name|WPI_FILTER_MULTICAST
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_HOSTAP
case|:
name|sc
operator|->
name|config
operator|.
name|mode
operator|=
name|WPI_MODE_HOSTAP
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_MONITOR
case|:
name|sc
operator|->
name|config
operator|.
name|mode
operator|=
name|WPI_MODE_MONITOR
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|filter
operator||=
name|htole32
argument_list|(
name|WPI_FILTER_MULTICAST
operator||
name|WPI_FILTER_CTL
operator||
name|WPI_FILTER_PROMISC
argument_list|)
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unknown opmode %d\n"
argument_list|,
name|ic
operator|->
name|ic_opmode
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|sc
operator|->
name|config
operator|.
name|cck_mask
operator|=
literal|0x0f
expr_stmt|;
comment|/* not yet negotiated */
name|sc
operator|->
name|config
operator|.
name|ofdm_mask
operator|=
literal|0xff
expr_stmt|;
comment|/* not yet negotiated */
name|error
operator|=
name|wpi_cmd
argument_list|(
name|sc
argument_list|,
name|WPI_CMD_CONFIGURE
argument_list|,
operator|&
name|sc
operator|->
name|config
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|wpi_config
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"configure command failed\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* configuration has changed, set Tx power accordingly */
if|if
condition|(
operator|(
name|error
operator|=
name|wpi_set_txpower
argument_list|(
name|sc
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not set Tx power\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* add broadcast node */
name|memset
argument_list|(
operator|&
name|node
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|node
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|node
operator|.
name|bssid
argument_list|,
name|ifp
operator|->
name|if_broadcastaddr
argument_list|)
expr_stmt|;
name|node
operator|.
name|id
operator|=
name|WPI_ID_BROADCAST
expr_stmt|;
name|node
operator|.
name|rate
operator|=
name|wpi_plcp_signal
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|error
operator|=
name|wpi_cmd
argument_list|(
name|sc
argument_list|,
name|WPI_CMD_ADD_NODE
argument_list|,
operator|&
name|node
argument_list|,
sizeof|sizeof
name|node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not add broadcast node\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Setup rate scalling */
name|error
operator|=
name|wpi_mrr_setup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not setup MRR\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_stop_master
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|tmp
decl_stmt|;
name|int
name|ntries
decl_stmt|;
name|DPRINTFN
argument_list|(
name|WPI_DEBUG_HW
argument_list|,
operator|(
literal|"Disabling Firmware execution\n"
operator|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|WPI_READ
argument_list|(
name|sc
argument_list|,
name|WPI_RESET
argument_list|)
expr_stmt|;
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_RESET
argument_list|,
name|tmp
operator||
name|WPI_STOP_MASTER
operator||
name|WPI_NEVO_RESET
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|WPI_READ
argument_list|(
name|sc
argument_list|,
name|WPI_GPIO_CTL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|&
name|WPI_GPIO_PWR_STATUS
operator|)
operator|==
name|WPI_GPIO_PWR_SLEEP
condition|)
return|return;
comment|/* already asleep */
for|for
control|(
name|ntries
operator|=
literal|0
init|;
name|ntries
operator|<
literal|100
condition|;
name|ntries
operator|++
control|)
block|{
if|if
condition|(
name|WPI_READ
argument_list|(
name|sc
argument_list|,
name|WPI_RESET
argument_list|)
operator|&
name|WPI_MASTER_DISABLED
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ntries
operator|==
literal|100
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"timeout waiting for master\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|wpi_power_up
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|tmp
decl_stmt|;
name|int
name|ntries
decl_stmt|;
name|wpi_mem_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|wpi_mem_read
argument_list|(
name|sc
argument_list|,
name|WPI_MEM_POWER
argument_list|)
expr_stmt|;
name|wpi_mem_write
argument_list|(
name|sc
argument_list|,
name|WPI_MEM_POWER
argument_list|,
name|tmp
operator|&
operator|~
literal|0x03000000
argument_list|)
expr_stmt|;
name|wpi_mem_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|ntries
operator|=
literal|0
init|;
name|ntries
operator|<
literal|5000
condition|;
name|ntries
operator|++
control|)
block|{
if|if
condition|(
name|WPI_READ
argument_list|(
name|sc
argument_list|,
name|WPI_GPIO_STATUS
argument_list|)
operator|&
name|WPI_POWERED
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ntries
operator|==
literal|5000
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"timeout waiting for NIC to power up\n"
argument_list|)
expr_stmt|;
return|return
name|ETIMEDOUT
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wpi_reset
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|tmp
decl_stmt|;
name|int
name|ntries
decl_stmt|;
name|DPRINTFN
argument_list|(
name|WPI_DEBUG_HW
argument_list|,
operator|(
literal|"Resetting the card - clearing any uploaded firmware\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* clear any pending interrupts */
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_INTR
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|WPI_READ
argument_list|(
name|sc
argument_list|,
name|WPI_PLL_CTL
argument_list|)
expr_stmt|;
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_PLL_CTL
argument_list|,
name|tmp
operator||
name|WPI_PLL_INIT
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|WPI_READ
argument_list|(
name|sc
argument_list|,
name|WPI_CHICKEN
argument_list|)
expr_stmt|;
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_CHICKEN
argument_list|,
name|tmp
operator||
name|WPI_CHICKEN_RXNOLOS
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|WPI_READ
argument_list|(
name|sc
argument_list|,
name|WPI_GPIO_CTL
argument_list|)
expr_stmt|;
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_GPIO_CTL
argument_list|,
name|tmp
operator||
name|WPI_GPIO_INIT
argument_list|)
expr_stmt|;
comment|/* wait for clock stabilization */
for|for
control|(
name|ntries
operator|=
literal|0
init|;
name|ntries
operator|<
literal|25000
condition|;
name|ntries
operator|++
control|)
block|{
if|if
condition|(
name|WPI_READ
argument_list|(
name|sc
argument_list|,
name|WPI_GPIO_CTL
argument_list|)
operator|&
name|WPI_GPIO_CLOCK
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ntries
operator|==
literal|25000
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"timeout waiting for clock stabilization\n"
argument_list|)
expr_stmt|;
return|return
name|ETIMEDOUT
return|;
block|}
comment|/* initialize EEPROM */
name|tmp
operator|=
name|WPI_READ
argument_list|(
name|sc
argument_list|,
name|WPI_EEPROM_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|&
name|WPI_EEPROM_VERSION
operator|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"EEPROM not found\n"
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_EEPROM_STATUS
argument_list|,
name|tmp
operator|&
operator|~
name|WPI_EEPROM_LOCKED
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_hw_config
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|rev
decl_stmt|,
name|hw
decl_stmt|;
comment|/* voodoo from the Linux "driver".. */
name|hw
operator|=
name|WPI_READ
argument_list|(
name|sc
argument_list|,
name|WPI_HWCONFIG
argument_list|)
expr_stmt|;
name|rev
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|PCIR_REVID
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rev
operator|&
literal|0xc0
operator|)
operator|==
literal|0x40
condition|)
name|hw
operator||=
name|WPI_HW_ALM_MB
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|rev
operator|&
literal|0x80
operator|)
condition|)
name|hw
operator||=
name|WPI_HW_ALM_MM
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|cap
operator|==
literal|0x80
condition|)
name|hw
operator||=
name|WPI_HW_SKU_MRC
expr_stmt|;
name|hw
operator|&=
operator|~
name|WPI_HW_REV_D
expr_stmt|;
if|if
condition|(
operator|(
name|le16toh
argument_list|(
name|sc
operator|->
name|rev
argument_list|)
operator|&
literal|0xf0
operator|)
operator|==
literal|0xd0
condition|)
name|hw
operator||=
name|WPI_HW_REV_D
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|type
operator|>
literal|1
condition|)
name|hw
operator||=
name|WPI_HW_TYPE_B
expr_stmt|;
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_HWCONFIG
argument_list|,
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_rfkill_resume
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
decl_stmt|;
name|int
name|ntries
decl_stmt|;
comment|/* enable firmware again */
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_UCODE_CLR
argument_list|,
name|WPI_RADIO_OFF
argument_list|)
expr_stmt|;
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_UCODE_CLR
argument_list|,
name|WPI_DISABLE_CMD
argument_list|)
expr_stmt|;
comment|/* wait for thermal sensors to calibrate */
for|for
control|(
name|ntries
operator|=
literal|0
init|;
name|ntries
operator|<
literal|1000
condition|;
name|ntries
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|temp
operator|=
operator|(
name|int
operator|)
name|WPI_READ
argument_list|(
name|sc
argument_list|,
name|WPI_TEMPERATURE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ntries
operator|==
literal|1000
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"timeout waiting for thermal calibration\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|DPRINTFN
argument_list|(
name|WPI_DEBUG_TEMP
argument_list|,
operator|(
literal|"temperature %d\n"
operator|,
name|sc
operator|->
name|temp
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpi_config
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"device config failed\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|sc
operator|->
name|flags
operator|&=
operator|~
name|WPI_FLAG_HW_RADIO_OFF
expr_stmt|;
if|if
condition|(
name|vap
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SCAN
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|!=
name|IEEE80211_M_MONITOR
condition|)
block|{
name|ieee80211_beacon_miss
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|wpi_set_led
argument_list|(
name|sc
argument_list|,
name|WPI_LED_LINK
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|wpi_set_led
argument_list|(
name|sc
argument_list|,
name|WPI_LED_LINK
argument_list|,
literal|5
argument_list|,
literal|5
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ieee80211_scan_next
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|wpi_set_led
argument_list|(
name|sc
argument_list|,
name|WPI_LED_LINK
argument_list|,
literal|20
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|watchdog_to
argument_list|,
name|hz
argument_list|,
name|wpi_watchdog
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_init_locked
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|force
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|uint32_t
name|tmp
decl_stmt|;
name|int
name|ntries
decl_stmt|,
name|qid
decl_stmt|;
name|wpi_stop_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wpi_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|wpi_mem_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|wpi_mem_write
argument_list|(
name|sc
argument_list|,
name|WPI_MEM_CLOCK1
argument_list|,
literal|0xa00
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|wpi_mem_read
argument_list|(
name|sc
argument_list|,
name|WPI_MEM_PCIDEV
argument_list|)
expr_stmt|;
name|wpi_mem_write
argument_list|(
name|sc
argument_list|,
name|WPI_MEM_PCIDEV
argument_list|,
name|tmp
operator||
literal|0x800
argument_list|)
expr_stmt|;
name|wpi_mem_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wpi_power_up
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|wpi_hw_config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* init Rx ring */
name|wpi_mem_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_RX_BASE
argument_list|,
name|sc
operator|->
name|rxq
operator|.
name|desc_dma
operator|.
name|paddr
argument_list|)
expr_stmt|;
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_RX_RIDX_PTR
argument_list|,
name|sc
operator|->
name|shared_dma
operator|.
name|paddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|wpi_shared
argument_list|,
name|next
argument_list|)
argument_list|)
expr_stmt|;
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_RX_WIDX
argument_list|,
operator|(
name|WPI_RX_RING_COUNT
operator|-
literal|1
operator|)
operator|&
operator|~
literal|7
argument_list|)
expr_stmt|;
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_RX_CONFIG
argument_list|,
literal|0xa9601010
argument_list|)
expr_stmt|;
name|wpi_mem_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* init Tx rings */
name|wpi_mem_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|wpi_mem_write
argument_list|(
name|sc
argument_list|,
name|WPI_MEM_MODE
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* bypass mode */
name|wpi_mem_write
argument_list|(
name|sc
argument_list|,
name|WPI_MEM_RA
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* enable RA0 */
name|wpi_mem_write
argument_list|(
name|sc
argument_list|,
name|WPI_MEM_TXCFG
argument_list|,
literal|0x3f
argument_list|)
expr_stmt|;
comment|/* enable all 6 Tx rings */
name|wpi_mem_write
argument_list|(
name|sc
argument_list|,
name|WPI_MEM_BYPASS1
argument_list|,
literal|0x10000
argument_list|)
expr_stmt|;
name|wpi_mem_write
argument_list|(
name|sc
argument_list|,
name|WPI_MEM_BYPASS2
argument_list|,
literal|0x30002
argument_list|)
expr_stmt|;
name|wpi_mem_write
argument_list|(
name|sc
argument_list|,
name|WPI_MEM_MAGIC4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|wpi_mem_write
argument_list|(
name|sc
argument_list|,
name|WPI_MEM_MAGIC5
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_TX_BASE_PTR
argument_list|,
name|sc
operator|->
name|shared_dma
operator|.
name|paddr
argument_list|)
expr_stmt|;
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_MSG_CONFIG
argument_list|,
literal|0xffff05a5
argument_list|)
expr_stmt|;
for|for
control|(
name|qid
operator|=
literal|0
init|;
name|qid
operator|<
literal|6
condition|;
name|qid
operator|++
control|)
block|{
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_TX_CTL
argument_list|(
name|qid
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_TX_BASE
argument_list|(
name|qid
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_TX_CONFIG
argument_list|(
name|qid
argument_list|)
argument_list|,
literal|0x80200008
argument_list|)
expr_stmt|;
block|}
name|wpi_mem_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* clear "radio off" and "disable command" bits (reversed logic) */
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_UCODE_CLR
argument_list|,
name|WPI_RADIO_OFF
argument_list|)
expr_stmt|;
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_UCODE_CLR
argument_list|,
name|WPI_DISABLE_CMD
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator|&=
operator|~
name|WPI_FLAG_HW_RADIO_OFF
expr_stmt|;
comment|/* clear any pending interrupts */
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_INTR
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
comment|/* enable interrupts */
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_MASK
argument_list|,
name|WPI_INTR_MASK
argument_list|)
expr_stmt|;
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_UCODE_CLR
argument_list|,
name|WPI_RADIO_OFF
argument_list|)
expr_stmt|;
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_UCODE_CLR
argument_list|,
name|WPI_RADIO_OFF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|wpi_load_firmware
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"A problem occurred loading the firmware to the driver\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* At this point the firmware is up and running. If the hardware 	 * RF switch is turned off thermal calibration will fail, though 	 * the card is still happy to continue to accept commands, catch 	 * this case and schedule a task to watch for it to be turned on. 	 */
name|wpi_mem_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|wpi_mem_read
argument_list|(
name|sc
argument_list|,
name|WPI_MEM_HW_RADIO_OFF
argument_list|)
expr_stmt|;
name|wpi_mem_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tmp
operator|&
literal|0x1
operator|)
condition|)
block|{
name|sc
operator|->
name|flags
operator||=
name|WPI_FLAG_HW_RADIO_OFF
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Radio Transmitter is switched off\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* wait for thermal sensors to calibrate */
for|for
control|(
name|ntries
operator|=
literal|0
init|;
name|ntries
operator|<
literal|1000
condition|;
name|ntries
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|temp
operator|=
operator|(
name|int
operator|)
name|WPI_READ
argument_list|(
name|sc
argument_list|,
name|WPI_TEMPERATURE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ntries
operator|==
literal|1000
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"timeout waiting for thermal sensors calibration\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|DPRINTFN
argument_list|(
name|WPI_DEBUG_TEMP
argument_list|,
operator|(
literal|"temperature %d\n"
operator|,
name|sc
operator|->
name|temp
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpi_config
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"device config failed\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|out
label|:
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|watchdog_to
argument_list|,
name|hz
argument_list|,
name|wpi_watchdog
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|wpi_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|WPI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|wpi_init_locked
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|ieee80211_start_all
argument_list|(
name|ic
argument_list|)
expr_stmt|;
comment|/* start all vaps */
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_stop_locked
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|uint32_t
name|tmp
decl_stmt|;
name|int
name|ac
decl_stmt|;
name|sc
operator|->
name|sc_tx_timer
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_scan_timer
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
name|sc
operator|->
name|flags
operator|&=
operator|~
name|WPI_FLAG_HW_RADIO_OFF
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|watchdog_to
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|calib_to
argument_list|)
expr_stmt|;
comment|/* disable interrupts */
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_INTR
argument_list|,
name|WPI_INTR_MASK
argument_list|)
expr_stmt|;
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_INTR_STATUS
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_INTR_STATUS
argument_list|,
literal|0x00070000
argument_list|)
expr_stmt|;
name|wpi_mem_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|wpi_mem_write
argument_list|(
name|sc
argument_list|,
name|WPI_MEM_MODE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wpi_mem_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* reset all Tx rings */
for|for
control|(
name|ac
operator|=
literal|0
init|;
name|ac
operator|<
literal|4
condition|;
name|ac
operator|++
control|)
name|wpi_reset_tx_ring
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|txq
index|[
name|ac
index|]
argument_list|)
expr_stmt|;
name|wpi_reset_tx_ring
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|cmdq
argument_list|)
expr_stmt|;
comment|/* reset Rx ring */
name|wpi_reset_rx_ring
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rxq
argument_list|)
expr_stmt|;
name|wpi_mem_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|wpi_mem_write
argument_list|(
name|sc
argument_list|,
name|WPI_MEM_CLOCK2
argument_list|,
literal|0x200
argument_list|)
expr_stmt|;
name|wpi_mem_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|wpi_stop_master
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|WPI_READ
argument_list|(
name|sc
argument_list|,
name|WPI_RESET
argument_list|)
expr_stmt|;
name|WPI_WRITE
argument_list|(
name|sc
argument_list|,
name|WPI_RESET
argument_list|,
name|tmp
operator||
name|WPI_SW_RESET
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator|&=
operator|~
name|WPI_FLAG_BUSY
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_stop
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|WPI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|wpi_stop_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|WPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_calib_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|wpi_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
decl_stmt|;
name|int
name|temp
decl_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|!=
name|IEEE80211_S_RUN
condition|)
return|return;
comment|/* update sensor data */
name|temp
operator|=
operator|(
name|int
operator|)
name|WPI_READ
argument_list|(
name|sc
argument_list|,
name|WPI_TEMPERATURE
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
name|WPI_DEBUG_TEMP
argument_list|,
operator|(
literal|"Temp in calibration is: %d\n"
operator|,
name|temp
operator|)
argument_list|)
expr_stmt|;
name|wpi_power_calibration
argument_list|(
name|sc
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|calib_to
argument_list|,
literal|60
operator|*
name|hz
argument_list|,
name|wpi_calib_timeout
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function is called periodically (every 60 seconds) to adjust output  * power to temperature changes.  */
end_comment

begin_function
specifier|static
name|void
name|wpi_power_calibration
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|temp
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
decl_stmt|;
comment|/* sanity-check read value */
if|if
condition|(
name|temp
operator|<
operator|-
literal|260
operator|||
name|temp
operator|>
literal|25
condition|)
block|{
comment|/* this can't be correct, ignore */
name|DPRINTFN
argument_list|(
name|WPI_DEBUG_TEMP
argument_list|,
operator|(
literal|"out-of-range temperature reported: %d\n"
operator|,
name|temp
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|DPRINTFN
argument_list|(
name|WPI_DEBUG_TEMP
argument_list|,
operator|(
literal|"temperature %d->%d\n"
operator|,
name|sc
operator|->
name|temp
operator|,
name|temp
operator|)
argument_list|)
expr_stmt|;
comment|/* adjust Tx power if need be */
if|if
condition|(
name|abs
argument_list|(
name|temp
operator|-
name|sc
operator|->
name|temp
argument_list|)
operator|<=
literal|6
condition|)
return|return;
name|sc
operator|->
name|temp
operator|=
name|temp
expr_stmt|;
if|if
condition|(
name|wpi_set_txpower
argument_list|(
name|sc
argument_list|,
name|vap
operator|->
name|iv_bss
operator|->
name|ni_chan
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* just warn, too bad for the automatic calibration... */
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not adjust Tx power\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Read the eeprom to find out what channels are valid for the given  * band and update net80211 with what we find.  */
end_comment

begin_function
specifier|static
name|void
name|wpi_read_eeprom_channels
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
specifier|const
name|struct
name|wpi_chan_band
modifier|*
name|band
init|=
operator|&
name|wpi_bands
index|[
name|n
index|]
decl_stmt|;
name|struct
name|wpi_eeprom_chan
name|channels
index|[
name|WPI_MAX_CHAN_PER_BAND
index|]
decl_stmt|;
name|struct
name|ieee80211_channel
modifier|*
name|c
decl_stmt|;
name|int
name|chan
decl_stmt|,
name|i
decl_stmt|,
name|passive
decl_stmt|;
name|wpi_read_prom_data
argument_list|(
name|sc
argument_list|,
name|band
operator|->
name|addr
argument_list|,
name|channels
argument_list|,
name|band
operator|->
name|nchan
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|wpi_eeprom_chan
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|band
operator|->
name|nchan
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|channels
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|WPI_EEPROM_CHAN_VALID
operator|)
condition|)
block|{
name|DPRINTFN
argument_list|(
name|WPI_DEBUG_HW
argument_list|,
operator|(
literal|"Channel Not Valid: %d, band %d\n"
operator|,
name|band
operator|->
name|chan
index|[
name|i
index|]
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|passive
operator|=
literal|0
expr_stmt|;
name|chan
operator|=
name|band
operator|->
name|chan
index|[
name|i
index|]
expr_stmt|;
name|c
operator|=
operator|&
name|ic
operator|->
name|ic_channels
index|[
name|ic
operator|->
name|ic_nchans
operator|++
index|]
expr_stmt|;
comment|/* is active scan allowed on this channel? */
if|if
condition|(
operator|!
operator|(
name|channels
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|WPI_EEPROM_CHAN_ACTIVE
operator|)
condition|)
block|{
name|passive
operator|=
name|IEEE80211_CHAN_PASSIVE
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
comment|/* 2GHz band */
name|c
operator|->
name|ic_ieee
operator|=
name|chan
expr_stmt|;
name|c
operator|->
name|ic_freq
operator|=
name|ieee80211_ieee2mhz
argument_list|(
name|chan
argument_list|,
name|IEEE80211_CHAN_2GHZ
argument_list|)
expr_stmt|;
name|c
operator|->
name|ic_flags
operator|=
name|IEEE80211_CHAN_B
operator||
name|passive
expr_stmt|;
name|c
operator|=
operator|&
name|ic
operator|->
name|ic_channels
index|[
name|ic
operator|->
name|ic_nchans
operator|++
index|]
expr_stmt|;
name|c
operator|->
name|ic_ieee
operator|=
name|chan
expr_stmt|;
name|c
operator|->
name|ic_freq
operator|=
name|ieee80211_ieee2mhz
argument_list|(
name|chan
argument_list|,
name|IEEE80211_CHAN_2GHZ
argument_list|)
expr_stmt|;
name|c
operator|->
name|ic_flags
operator|=
name|IEEE80211_CHAN_G
operator||
name|passive
expr_stmt|;
block|}
else|else
block|{
comment|/* 5GHz band */
comment|/* 			 * Some 3945ABG adapters support channels 7, 8, 11 			 * and 12 in the 2GHz *and* 5GHz bands. 			 * Because of limitations in our net80211(9) stack, 			 * we can't support these channels in 5GHz band. 			 * XXX not true; just need to map to proper frequency 			 */
if|if
condition|(
name|chan
operator|<=
literal|14
condition|)
continue|continue;
name|c
operator|->
name|ic_ieee
operator|=
name|chan
expr_stmt|;
name|c
operator|->
name|ic_freq
operator|=
name|ieee80211_ieee2mhz
argument_list|(
name|chan
argument_list|,
name|IEEE80211_CHAN_5GHZ
argument_list|)
expr_stmt|;
name|c
operator|->
name|ic_flags
operator|=
name|IEEE80211_CHAN_A
operator||
name|passive
expr_stmt|;
block|}
comment|/* save maximum allowed power for this channel */
name|sc
operator|->
name|maxpwr
index|[
name|chan
index|]
operator|=
name|channels
index|[
name|i
index|]
operator|.
name|maxpwr
expr_stmt|;
if|#
directive|if
literal|0
comment|// XXX We can probably use this an get rid of maxpwr - ben 20070617
block|ic->ic_channels[chan].ic_maxpower = channels[i].maxpwr;
comment|//ic->ic_channels[chan].ic_minpower...
comment|//ic->ic_channels[chan].ic_maxregtxpower...
endif|#
directive|endif
name|DPRINTF
argument_list|(
operator|(
literal|"adding chan %d (%dMHz) flags=0x%x maxpwr=%d"
literal|" passive=%d, offset %d\n"
operator|,
name|chan
operator|,
name|c
operator|->
name|ic_freq
operator|,
name|channels
index|[
name|i
index|]
operator|.
name|flags
operator|,
name|sc
operator|->
name|maxpwr
index|[
name|chan
index|]
operator|,
operator|(
name|c
operator|->
name|ic_flags
operator|&
name|IEEE80211_CHAN_PASSIVE
operator|)
operator|!=
literal|0
operator|,
name|ic
operator|->
name|ic_nchans
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_read_eeprom_group
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|struct
name|wpi_power_group
modifier|*
name|group
init|=
operator|&
name|sc
operator|->
name|groups
index|[
name|n
index|]
decl_stmt|;
name|struct
name|wpi_eeprom_group
name|rgroup
decl_stmt|;
name|int
name|i
decl_stmt|;
name|wpi_read_prom_data
argument_list|(
name|sc
argument_list|,
name|WPI_EEPROM_POWER_GRP
operator|+
name|n
operator|*
literal|32
argument_list|,
operator|&
name|rgroup
argument_list|,
sizeof|sizeof
name|rgroup
argument_list|)
expr_stmt|;
comment|/* save power group information */
name|group
operator|->
name|chan
operator|=
name|rgroup
operator|.
name|chan
expr_stmt|;
name|group
operator|->
name|maxpwr
operator|=
name|rgroup
operator|.
name|maxpwr
expr_stmt|;
comment|/* temperature at which the samples were taken */
name|group
operator|->
name|temp
operator|=
operator|(
name|int16_t
operator|)
name|le16toh
argument_list|(
name|rgroup
operator|.
name|temp
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"power group %d: chan=%d maxpwr=%d temp=%d\n"
operator|,
name|n
operator|,
name|group
operator|->
name|chan
operator|,
name|group
operator|->
name|maxpwr
operator|,
name|group
operator|->
name|temp
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|WPI_SAMPLES_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|group
operator|->
name|samples
index|[
name|i
index|]
operator|.
name|index
operator|=
name|rgroup
operator|.
name|samples
index|[
name|i
index|]
operator|.
name|index
expr_stmt|;
name|group
operator|->
name|samples
index|[
name|i
index|]
operator|.
name|power
operator|=
name|rgroup
operator|.
name|samples
index|[
name|i
index|]
operator|.
name|power
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"\tsample %d: index=%d power=%d\n"
operator|,
name|i
operator|,
name|group
operator|->
name|samples
index|[
name|i
index|]
operator|.
name|index
operator|,
name|group
operator|->
name|samples
index|[
name|i
index|]
operator|.
name|power
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Update Tx power to match what is defined for channel `c'.  */
end_comment

begin_function
specifier|static
name|int
name|wpi_set_txpower
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|c
parameter_list|,
name|int
name|async
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|wpi_power_group
modifier|*
name|group
decl_stmt|;
name|struct
name|wpi_cmd_txpower
name|txpower
decl_stmt|;
name|u_int
name|chan
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* get channel number */
name|chan
operator|=
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|/* find the power group to which this channel belongs */
if|if
condition|(
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|c
argument_list|)
condition|)
block|{
for|for
control|(
name|group
operator|=
operator|&
name|sc
operator|->
name|groups
index|[
literal|1
index|]
init|;
name|group
operator|<
operator|&
name|sc
operator|->
name|groups
index|[
literal|4
index|]
condition|;
name|group
operator|++
control|)
if|if
condition|(
name|chan
operator|<=
name|group
operator|->
name|chan
condition|)
break|break;
block|}
else|else
name|group
operator|=
operator|&
name|sc
operator|->
name|groups
index|[
literal|0
index|]
expr_stmt|;
name|memset
argument_list|(
operator|&
name|txpower
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|txpower
argument_list|)
expr_stmt|;
name|txpower
operator|.
name|band
operator|=
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|c
argument_list|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|txpower
operator|.
name|channel
operator|=
name|htole16
argument_list|(
name|chan
argument_list|)
expr_stmt|;
comment|/* set Tx power for all OFDM and CCK rates */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|11
condition|;
name|i
operator|++
control|)
block|{
comment|/* retrieve Tx power for this channel/rate combination */
name|int
name|idx
init|=
name|wpi_get_power_index
argument_list|(
name|sc
argument_list|,
name|group
argument_list|,
name|c
argument_list|,
name|wpi_ridx_to_rate
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|txpower
operator|.
name|rates
index|[
name|i
index|]
operator|.
name|rate
operator|=
name|wpi_ridx_to_plcp
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|txpower
operator|.
name|rates
index|[
name|i
index|]
operator|.
name|gain_radio
operator|=
name|wpi_rf_gain_5ghz
index|[
name|idx
index|]
expr_stmt|;
name|txpower
operator|.
name|rates
index|[
name|i
index|]
operator|.
name|gain_dsp
operator|=
name|wpi_dsp_gain_5ghz
index|[
name|idx
index|]
expr_stmt|;
block|}
else|else
block|{
name|txpower
operator|.
name|rates
index|[
name|i
index|]
operator|.
name|gain_radio
operator|=
name|wpi_rf_gain_2ghz
index|[
name|idx
index|]
expr_stmt|;
name|txpower
operator|.
name|rates
index|[
name|i
index|]
operator|.
name|gain_dsp
operator|=
name|wpi_dsp_gain_2ghz
index|[
name|idx
index|]
expr_stmt|;
block|}
name|DPRINTFN
argument_list|(
name|WPI_DEBUG_TEMP
argument_list|,
operator|(
literal|"chan %d/rate %d: power index %d\n"
operator|,
name|chan
operator|,
name|wpi_ridx_to_rate
index|[
name|i
index|]
operator|,
name|idx
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|wpi_cmd
argument_list|(
name|sc
argument_list|,
name|WPI_CMD_TXPOWER
argument_list|,
operator|&
name|txpower
argument_list|,
sizeof|sizeof
name|txpower
argument_list|,
name|async
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine Tx power index for a given channel/rate combination.  * This takes into account the regulatory information from EEPROM and the  * current temperature.  */
end_comment

begin_function
specifier|static
name|int
name|wpi_get_power_index
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|wpi_power_group
modifier|*
name|group
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|c
parameter_list|,
name|int
name|rate
parameter_list|)
block|{
comment|/* fixed-point arithmetic division using a n-bit fractional part */
define|#
directive|define
name|fdivround
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|n
parameter_list|)
define|\
value|((((1<< n) * (a)) / (b) + (1<< n) / 2) / (1<< n))
comment|/* linear interpolation */
define|#
directive|define
name|interpolate
parameter_list|(
name|x
parameter_list|,
name|x1
parameter_list|,
name|y1
parameter_list|,
name|x2
parameter_list|,
name|y2
parameter_list|,
name|n
parameter_list|)
define|\
value|((y1) + fdivround(((x) - (x1)) * ((y2) - (y1)), (x2) - (x1), n))
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|wpi_power_sample
modifier|*
name|sample
decl_stmt|;
name|int
name|pwr
decl_stmt|,
name|idx
decl_stmt|;
name|u_int
name|chan
decl_stmt|;
comment|/* get channel number */
name|chan
operator|=
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|/* default power is group's maximum power - 3dB */
name|pwr
operator|=
name|group
operator|->
name|maxpwr
operator|/
literal|2
expr_stmt|;
comment|/* decrease power for highest OFDM rates to reduce distortion */
switch|switch
condition|(
name|rate
condition|)
block|{
case|case
literal|72
case|:
comment|/* 36Mb/s */
name|pwr
operator|-=
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|c
argument_list|)
condition|?
literal|0
else|:
literal|5
expr_stmt|;
break|break;
case|case
literal|96
case|:
comment|/* 48Mb/s */
name|pwr
operator|-=
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|c
argument_list|)
condition|?
literal|7
else|:
literal|10
expr_stmt|;
break|break;
case|case
literal|108
case|:
comment|/* 54Mb/s */
name|pwr
operator|-=
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|c
argument_list|)
condition|?
literal|9
else|:
literal|12
expr_stmt|;
break|break;
block|}
comment|/* never exceed channel's maximum allowed Tx power */
name|pwr
operator|=
name|min
argument_list|(
name|pwr
argument_list|,
name|sc
operator|->
name|maxpwr
index|[
name|chan
index|]
argument_list|)
expr_stmt|;
comment|/* retrieve power index into gain tables from samples */
for|for
control|(
name|sample
operator|=
name|group
operator|->
name|samples
init|;
name|sample
operator|<
operator|&
name|group
operator|->
name|samples
index|[
literal|3
index|]
condition|;
name|sample
operator|++
control|)
if|if
condition|(
name|pwr
operator|>
name|sample
index|[
literal|1
index|]
operator|.
name|power
condition|)
break|break;
comment|/* fixed-point linear interpolation using a 19-bit fractional part */
name|idx
operator|=
name|interpolate
argument_list|(
name|pwr
argument_list|,
name|sample
index|[
literal|0
index|]
operator|.
name|power
argument_list|,
name|sample
index|[
literal|0
index|]
operator|.
name|index
argument_list|,
name|sample
index|[
literal|1
index|]
operator|.
name|power
argument_list|,
name|sample
index|[
literal|1
index|]
operator|.
name|index
argument_list|,
literal|19
argument_list|)
expr_stmt|;
comment|/* 	 *  Adjust power index based on current temperature 	 *	- if colder than factory-calibrated: decreate output power 	 *	- if warmer than factory-calibrated: increase output power 	 */
name|idx
operator|-=
operator|(
name|sc
operator|->
name|temp
operator|-
name|group
operator|->
name|temp
operator|)
operator|*
literal|11
operator|/
literal|100
expr_stmt|;
comment|/* decrease power for CCK rates (-5dB) */
if|if
condition|(
operator|!
name|WPI_RATE_IS_OFDM
argument_list|(
name|rate
argument_list|)
condition|)
name|idx
operator|+=
literal|10
expr_stmt|;
comment|/* keep power index in a valid range */
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|idx
operator|>
name|WPI_MAX_PWR_INDEX
condition|)
return|return
name|WPI_MAX_PWR_INDEX
return|;
return|return
name|idx
return|;
undef|#
directive|undef
name|interpolate
undef|#
directive|undef
name|fdivround
block|}
end_function

begin_comment
comment|/**  * Called by net80211 framework to indicate that a scan  * is starting. This function doesn't actually do the scan,  * wpi_scan_curchan starts things off. This function is more  * of an early warning from the framework we should get ready  * for the scan.  */
end_comment

begin_function
specifier|static
name|void
name|wpi_scan_start
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|wpi_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|WPI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|wpi_set_led
argument_list|(
name|sc
argument_list|,
name|WPI_LED_LINK
argument_list|,
literal|20
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|WPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Called by the net80211 framework, indicates that the  * scan has ended. If there is a scan in progress on the card  * then it should be aborted.  */
end_comment

begin_function
specifier|static
name|void
name|wpi_scan_end
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
comment|/* XXX ignore */
block|}
end_function

begin_comment
comment|/**  * Called by the net80211 framework to indicate to the driver  * that the channel should be changed  */
end_comment

begin_function
specifier|static
name|void
name|wpi_set_channel
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|wpi_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Only need to set the channel in Monitor mode. AP scanning and auth 	 * are already taken care of by their respective firmware commands. 	 */
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_MONITOR
condition|)
block|{
name|WPI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|wpi_config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|WPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"error %d settting channel\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Called by net80211 to indicate that we need to scan the current  * channel. The channel is previously be set via the wpi_set_channel  * callback.  */
end_comment

begin_function
specifier|static
name|void
name|wpi_scan_curchan
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|,
name|unsigned
name|long
name|maxdwell
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ss
operator|->
name|ss_vap
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vap
operator|->
name|iv_ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|wpi_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|WPI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpi_scan
argument_list|(
name|sc
argument_list|)
condition|)
name|ieee80211_cancel_scan
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|WPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Called by the net80211 framework to indicate  * the minimum dwell time has been met, terminate the scan.  * We don't actually terminate the scan as the firmware will notify  * us when it's finished and we have no way to interrupt it.  */
end_comment

begin_function
specifier|static
name|void
name|wpi_scan_mindwell
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|)
block|{
comment|/* NB: don't try to abort scan; wait for firmware to finish */
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_hwreset
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|wpi_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|WPI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|wpi_init_locked
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_rfreset
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|wpi_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|WPI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|wpi_rfkill_resume
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|WPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate DMA-safe memory for firmware transfer.  */
end_comment

begin_function
specifier|static
name|int
name|wpi_alloc_fwmem
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* allocate enough contiguous space to store text and data */
return|return
name|wpi_dma_contig_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|fw_dma
argument_list|,
name|NULL
argument_list|,
name|WPI_FW_MAIN_TEXT_MAXSZ
operator|+
name|WPI_FW_MAIN_DATA_MAXSZ
argument_list|,
literal|1
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpi_free_fwmem
parameter_list|(
name|struct
name|wpi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|wpi_dma_contig_free
argument_list|(
operator|&
name|sc
operator|->
name|fw_dma
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Called every second, wpi_watchdog used by the watch dog timer  * to check that the card is still alive  */
end_comment

begin_function
specifier|static
name|void
name|wpi_watchdog
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|wpi_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|uint32_t
name|tmp
decl_stmt|;
name|DPRINTFN
argument_list|(
name|WPI_DEBUG_WATCHDOG
argument_list|,
operator|(
literal|"Watchdog: tick\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|WPI_FLAG_HW_RADIO_OFF
condition|)
block|{
comment|/* No need to lock firmware memory */
name|tmp
operator|=
name|wpi_mem_read
argument_list|(
name|sc
argument_list|,
name|WPI_MEM_HW_RADIO_OFF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|&
literal|0x1
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Radio kill switch is still off */
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|watchdog_to
argument_list|,
name|hz
argument_list|,
name|wpi_watchdog
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Hardware Switch Enabled\n"
argument_list|)
expr_stmt|;
name|ieee80211_runtask
argument_list|(
name|ic
argument_list|,
operator|&
name|sc
operator|->
name|sc_radiotask
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_tx_timer
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|--
name|sc
operator|->
name|sc_tx_timer
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"device timeout\n"
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|ieee80211_runtask
argument_list|(
name|ic
argument_list|,
operator|&
name|sc
operator|->
name|sc_restarttask
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|sc_scan_timer
operator|>
literal|0
condition|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
decl_stmt|;
if|if
condition|(
operator|--
name|sc
operator|->
name|sc_scan_timer
operator|==
literal|0
operator|&&
name|vap
operator|!=
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"scan timeout\n"
argument_list|)
expr_stmt|;
name|ieee80211_cancel_scan
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|ieee80211_runtask
argument_list|(
name|ic
argument_list|,
operator|&
name|sc
operator|->
name|sc_restarttask
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|watchdog_to
argument_list|,
name|hz
argument_list|,
name|wpi_watchdog
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|WPI_DEBUG
end_ifdef

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|wpi_cmd_str
parameter_list|(
name|int
name|cmd
parameter_list|)
block|{
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|WPI_DISABLE_CMD
case|:
return|return
literal|"WPI_DISABLE_CMD"
return|;
case|case
name|WPI_CMD_CONFIGURE
case|:
return|return
literal|"WPI_CMD_CONFIGURE"
return|;
case|case
name|WPI_CMD_ASSOCIATE
case|:
return|return
literal|"WPI_CMD_ASSOCIATE"
return|;
case|case
name|WPI_CMD_SET_WME
case|:
return|return
literal|"WPI_CMD_SET_WME"
return|;
case|case
name|WPI_CMD_TSF
case|:
return|return
literal|"WPI_CMD_TSF"
return|;
case|case
name|WPI_CMD_ADD_NODE
case|:
return|return
literal|"WPI_CMD_ADD_NODE"
return|;
case|case
name|WPI_CMD_TX_DATA
case|:
return|return
literal|"WPI_CMD_TX_DATA"
return|;
case|case
name|WPI_CMD_MRR_SETUP
case|:
return|return
literal|"WPI_CMD_MRR_SETUP"
return|;
case|case
name|WPI_CMD_SET_LED
case|:
return|return
literal|"WPI_CMD_SET_LED"
return|;
case|case
name|WPI_CMD_SET_POWER_MODE
case|:
return|return
literal|"WPI_CMD_SET_POWER_MODE"
return|;
case|case
name|WPI_CMD_SCAN
case|:
return|return
literal|"WPI_CMD_SCAN"
return|;
case|case
name|WPI_CMD_SET_BEACON
case|:
return|return
literal|"WPI_CMD_SET_BEACON"
return|;
case|case
name|WPI_CMD_TXPOWER
case|:
return|return
literal|"WPI_CMD_TXPOWER"
return|;
case|case
name|WPI_CMD_BLUETOOTH
case|:
return|return
literal|"WPI_CMD_BLUETOOTH"
return|;
default|default:
name|KASSERT
argument_list|(
literal|1
argument_list|,
operator|(
literal|"Unknown Command: %d\n"
operator|,
name|cmd
operator|)
argument_list|)
expr_stmt|;
return|return
literal|"UNKNOWN CMD"
return|;
comment|/* Make the compiler happy */
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|wpi
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|wpi
argument_list|,
name|wlan
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|wpi
argument_list|,
name|firmware
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

