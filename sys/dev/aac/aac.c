begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2000 Michael Smith  * Copyright (c) 2001 Scott Long  * Copyright (c) 2000 BSDi  * Copyright (c) 2001 Adaptec, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Driver for the Adaptec 'FSA' family of PCI/SCSI RAID adapters.  */
end_comment

begin_define
define|#
directive|define
name|AAC_DRIVER_VERSION
value|0x02000000
end_define

begin_define
define|#
directive|define
name|AAC_DRIVERNAME
value|"aac"
end_define

begin_include
include|#
directive|include
file|"opt_aac.h"
end_include

begin_comment
comment|/* #include<stddef.h> */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus_dma.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/aac/aacreg.h>
end_include

begin_include
include|#
directive|include
file|<sys/aac_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<dev/aac/aacvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/aac/aac_tables.h>
end_include

begin_function_decl
specifier|static
name|void
name|aac_startup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_add_container
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|aac_mntinforesp
modifier|*
name|mir
parameter_list|,
name|int
name|f
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_get_bus_info
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Command Processing */
end_comment

begin_function_decl
specifier|static
name|void
name|aac_timeout
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_complete
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_bio_command
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|aac_command
modifier|*
modifier|*
name|cmp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_bio_complete
parameter_list|(
name|struct
name|aac_command
modifier|*
name|cm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_wait_command
parameter_list|(
name|struct
name|aac_command
modifier|*
name|cm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_command_thread
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Command Buffer Management */
end_comment

begin_function_decl
specifier|static
name|void
name|aac_map_command_sg
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_map_command_helper
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_alloc_commands
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_free_commands
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_unmap_command
parameter_list|(
name|struct
name|aac_command
modifier|*
name|cm
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Hardware Interface */
end_comment

begin_function_decl
specifier|static
name|void
name|aac_common_map
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_check_firmware
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_init
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_sync_command
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|command
parameter_list|,
name|u_int32_t
name|arg0
parameter_list|,
name|u_int32_t
name|arg1
parameter_list|,
name|u_int32_t
name|arg2
parameter_list|,
name|u_int32_t
name|arg3
parameter_list|,
name|u_int32_t
modifier|*
name|sp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_enqueue_fib
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|queue
parameter_list|,
name|struct
name|aac_command
modifier|*
name|cm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_dequeue_fib
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|queue
parameter_list|,
name|u_int32_t
modifier|*
name|fib_size
parameter_list|,
name|struct
name|aac_fib
modifier|*
modifier|*
name|fib_addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_enqueue_response
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|queue
parameter_list|,
name|struct
name|aac_fib
modifier|*
name|fib
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Falcon/PPC interface */
end_comment

begin_function_decl
specifier|static
name|int
name|aac_fa_get_fwstatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_fa_qnotify
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|qbit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_fa_get_istatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_fa_clear_istatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|mask
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_fa_set_mailbox
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|command
parameter_list|,
name|u_int32_t
name|arg0
parameter_list|,
name|u_int32_t
name|arg1
parameter_list|,
name|u_int32_t
name|arg2
parameter_list|,
name|u_int32_t
name|arg3
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_fa_get_mailbox
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|mb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_fa_set_interrupts
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|enable
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|aac_interface
name|aac_fa_interface
init|=
block|{
name|aac_fa_get_fwstatus
block|,
name|aac_fa_qnotify
block|,
name|aac_fa_get_istatus
block|,
name|aac_fa_clear_istatus
block|,
name|aac_fa_set_mailbox
block|,
name|aac_fa_get_mailbox
block|,
name|aac_fa_set_interrupts
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* StrongARM interface */
end_comment

begin_function_decl
specifier|static
name|int
name|aac_sa_get_fwstatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_sa_qnotify
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|qbit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_sa_get_istatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_sa_clear_istatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|mask
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_sa_set_mailbox
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|command
parameter_list|,
name|u_int32_t
name|arg0
parameter_list|,
name|u_int32_t
name|arg1
parameter_list|,
name|u_int32_t
name|arg2
parameter_list|,
name|u_int32_t
name|arg3
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_sa_get_mailbox
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|mb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_sa_set_interrupts
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|enable
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|aac_interface
name|aac_sa_interface
init|=
block|{
name|aac_sa_get_fwstatus
block|,
name|aac_sa_qnotify
block|,
name|aac_sa_get_istatus
block|,
name|aac_sa_clear_istatus
block|,
name|aac_sa_set_mailbox
block|,
name|aac_sa_get_mailbox
block|,
name|aac_sa_set_interrupts
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* i960Rx interface */
end_comment

begin_function_decl
specifier|static
name|int
name|aac_rx_get_fwstatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_rx_qnotify
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|qbit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_rx_get_istatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_rx_clear_istatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|mask
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_rx_set_mailbox
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|command
parameter_list|,
name|u_int32_t
name|arg0
parameter_list|,
name|u_int32_t
name|arg1
parameter_list|,
name|u_int32_t
name|arg2
parameter_list|,
name|u_int32_t
name|arg3
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_rx_get_mailbox
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|mb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_rx_set_interrupts
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|enable
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_rx_send_command
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|aac_command
modifier|*
name|cm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_rx_get_outb_queue
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_rx_set_outb_queue
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|aac_interface
name|aac_rx_interface
init|=
block|{
name|aac_rx_get_fwstatus
block|,
name|aac_rx_qnotify
block|,
name|aac_rx_get_istatus
block|,
name|aac_rx_clear_istatus
block|,
name|aac_rx_set_mailbox
block|,
name|aac_rx_get_mailbox
block|,
name|aac_rx_set_interrupts
block|,
name|aac_rx_send_command
block|,
name|aac_rx_get_outb_queue
block|,
name|aac_rx_set_outb_queue
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Rocket/MIPS interface */
end_comment

begin_function_decl
specifier|static
name|int
name|aac_rkt_get_fwstatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_rkt_qnotify
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|qbit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_rkt_get_istatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_rkt_clear_istatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|mask
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_rkt_set_mailbox
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|command
parameter_list|,
name|u_int32_t
name|arg0
parameter_list|,
name|u_int32_t
name|arg1
parameter_list|,
name|u_int32_t
name|arg2
parameter_list|,
name|u_int32_t
name|arg3
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_rkt_get_mailbox
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|mb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_rkt_set_interrupts
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|enable
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_rkt_send_command
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|aac_command
modifier|*
name|cm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_rkt_get_outb_queue
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_rkt_set_outb_queue
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|aac_interface
name|aac_rkt_interface
init|=
block|{
name|aac_rkt_get_fwstatus
block|,
name|aac_rkt_qnotify
block|,
name|aac_rkt_get_istatus
block|,
name|aac_rkt_clear_istatus
block|,
name|aac_rkt_set_mailbox
block|,
name|aac_rkt_get_mailbox
block|,
name|aac_rkt_set_interrupts
block|,
name|aac_rkt_send_command
block|,
name|aac_rkt_get_outb_queue
block|,
name|aac_rkt_set_outb_queue
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Debugging and Diagnostics */
end_comment

begin_function_decl
specifier|static
name|void
name|aac_describe_controller
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|aac_describe_code
parameter_list|(
name|struct
name|aac_code_lookup
modifier|*
name|table
parameter_list|,
name|u_int32_t
name|code
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Management Interface */
end_comment

begin_decl_stmt
specifier|static
name|d_open_t
name|aac_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|aac_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|aac_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_poll_t
name|aac_poll
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|aac_ioctl_sendfib
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|caddr_t
name|ufib
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_handle_aif
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|aac_fib
modifier|*
name|fib
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_rev_check
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|caddr_t
name|udata
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_open_aif
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|caddr_t
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_close_aif
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|caddr_t
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_getnext_aif
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|caddr_t
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_return_aif
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|aac_fib_context
modifier|*
name|ctx
parameter_list|,
name|caddr_t
name|uptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_query_disk
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|caddr_t
name|uptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_get_pci_info
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|caddr_t
name|uptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_ioctl_event
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|aac_event
modifier|*
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|aac_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_flags
operator|=
name|D_NEEDGIANT
block|,
operator|.
name|d_open
operator|=
name|aac_open
block|,
operator|.
name|d_close
operator|=
name|aac_close
block|,
operator|.
name|d_ioctl
operator|=
name|aac_ioctl
block|,
operator|.
name|d_poll
operator|=
name|aac_poll
block|,
operator|.
name|d_name
operator|=
literal|"aac"
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_AACBUF
argument_list|,
literal|"aacbuf"
argument_list|,
literal|"Buffers for the AAC driver"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* sysctl node */
end_comment

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|aac
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"AAC driver parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Device Interface  */
end_comment

begin_comment
comment|/*  * Initialise the controller and softc  */
end_comment

begin_function
name|int
name|aac_attach
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|unit
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Initialise per-controller queues. 	 */
name|aac_initq_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|aac_initq_ready
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|aac_initq_busy
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|aac_initq_bio
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Initialise command-completion task. 	 */
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|aac_task_complete
argument_list|,
literal|0
argument_list|,
name|aac_complete
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* mark controller as suspended until we get ourselves organised */
name|sc
operator|->
name|aac_state
operator||=
name|AAC_STATE_SUSPEND
expr_stmt|;
comment|/* 	 * Check that the firmware on the card is supported. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|aac_check_firmware
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Initialize locks 	 */
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|aac_aifq_lock
argument_list|,
literal|"AAC AIF lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|,
literal|"AAC I/O lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|aac_container_lock
argument_list|,
literal|"AAC container lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|aac_container_tqh
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|aac_ev_cmfree
argument_list|)
expr_stmt|;
comment|/* 	 * Initialise the adapter. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|aac_init
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Allocate and connect our interrupt. 	 */
name|sc
operator|->
name|aac_irq_rid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|aac_irq
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|aac_irq_rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"can't allocate interrupt\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|AAC_FLAGS_NEW_COMM
condition|)
block|{
if|if
condition|(
name|bus_setup_intr
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
name|sc
operator|->
name|aac_irq
argument_list|,
name|INTR_MPSAFE
operator||
name|INTR_TYPE_BIO
argument_list|,
name|NULL
argument_list|,
name|aac_new_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|aac_intr
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"can't set up interrupt\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|bus_setup_intr
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
name|sc
operator|->
name|aac_irq
argument_list|,
name|INTR_TYPE_BIO
argument_list|,
name|aac_fast_intr
argument_list|,
name|NULL
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|aac_intr
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"can't set up FAST interrupt\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_setup_intr
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
name|sc
operator|->
name|aac_irq
argument_list|,
name|INTR_MPSAFE
operator||
name|INTR_TYPE_BIO
argument_list|,
name|NULL
argument_list|,
operator|(
name|driver_intr_t
operator|*
operator|)
name|aac_fast_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|aac_intr
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"can't set up MPSAFE interrupt\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
block|}
comment|/* 	 * Print a little information about the controller. 	 */
name|aac_describe_controller
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Register to probe our containers later. 	 */
name|sc
operator|->
name|aac_ich
operator|.
name|ich_func
operator|=
name|aac_startup
expr_stmt|;
name|sc
operator|->
name|aac_ich
operator|.
name|ich_arg
operator|=
name|sc
expr_stmt|;
if|if
condition|(
name|config_intrhook_establish
argument_list|(
operator|&
name|sc
operator|->
name|aac_ich
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"can't establish configuration hook\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * Make the control device. 	 */
name|unit
operator|=
name|device_get_unit
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|aac_dev_t
operator|=
name|make_dev
argument_list|(
operator|&
name|aac_cdevsw
argument_list|,
name|unit
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0640
argument_list|,
literal|"aac%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|make_dev_alias
argument_list|(
name|sc
operator|->
name|aac_dev_t
argument_list|,
literal|"afa%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|make_dev_alias
argument_list|(
name|sc
operator|->
name|aac_dev_t
argument_list|,
literal|"hpn%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|aac_dev_t
operator|->
name|si_drv1
operator|=
name|sc
expr_stmt|;
comment|/* Create the AIF thread */
if|if
condition|(
name|kthread_create
argument_list|(
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|aac_command_thread
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|aifthread
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"aac%daif"
argument_list|,
name|unit
argument_list|)
condition|)
name|panic
argument_list|(
literal|"Could not create AIF thread\n"
argument_list|)
expr_stmt|;
comment|/* Register the shutdown method to only be called post-dump */
if|if
condition|(
operator|(
name|sc
operator|->
name|eh
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|shutdown_final
argument_list|,
name|aac_shutdown
argument_list|,
name|sc
operator|->
name|aac_dev
argument_list|,
name|SHUTDOWN_PRI_DEFAULT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"shutdown event registration failed\n"
argument_list|)
expr_stmt|;
comment|/* Register with CAM for the non-DASD devices */
if|if
condition|(
operator|(
name|sc
operator|->
name|flags
operator|&
name|AAC_FLAGS_ENABLE_CAM
operator|)
operator|!=
literal|0
condition|)
block|{
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|aac_sim_tqh
argument_list|)
expr_stmt|;
name|aac_get_bus_info
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|aac_add_event
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|aac_event
modifier|*
name|event
parameter_list|)
block|{
switch|switch
condition|(
name|event
operator|->
name|ev_type
operator|&
name|AAC_EVENT_MASK
condition|)
block|{
case|case
name|AAC_EVENT_CMFREE
case|:
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|aac_ev_cmfree
argument_list|,
name|event
argument_list|,
name|ev_links
argument_list|)
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"aac_add event: unknown event %d\n"
argument_list|,
name|event
operator|->
name|ev_type
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * Probe for containers, create disks.  */
end_comment

begin_function
specifier|static
name|void
name|aac_startup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|aac_fib
modifier|*
name|fib
decl_stmt|;
name|struct
name|aac_mntinfo
modifier|*
name|mi
decl_stmt|;
name|struct
name|aac_mntinforesp
modifier|*
name|mir
init|=
name|NULL
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|,
name|i
init|=
literal|0
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|aac_softc
operator|*
operator|)
name|arg
expr_stmt|;
comment|/* disconnect ourselves from the intrhook chain */
name|config_intrhook_disestablish
argument_list|(
operator|&
name|sc
operator|->
name|aac_ich
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
name|aac_alloc_sync_fib
argument_list|(
name|sc
argument_list|,
operator|&
name|fib
argument_list|)
expr_stmt|;
name|mi
operator|=
operator|(
expr|struct
name|aac_mntinfo
operator|*
operator|)
operator|&
name|fib
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
comment|/* loop over possible containers */
do|do
block|{
comment|/* request information on this container */
name|bzero
argument_list|(
name|mi
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_mntinfo
argument_list|)
argument_list|)
expr_stmt|;
name|mi
operator|->
name|Command
operator|=
name|VM_NameServe
expr_stmt|;
name|mi
operator|->
name|MntType
operator|=
name|FT_FILESYS
expr_stmt|;
name|mi
operator|->
name|MntCount
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|aac_sync_fib
argument_list|(
name|sc
argument_list|,
name|ContainerCommand
argument_list|,
literal|0
argument_list|,
name|fib
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_mntinfo
argument_list|)
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"error probing container %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|mir
operator|=
operator|(
expr|struct
name|aac_mntinforesp
operator|*
operator|)
operator|&
name|fib
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
comment|/* XXX Need to check if count changed */
name|count
operator|=
name|mir
operator|->
name|MntRespCount
expr_stmt|;
name|aac_add_container
argument_list|(
name|sc
argument_list|,
name|mir
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|i
operator|<
name|count
operator|)
operator|&&
operator|(
name|i
operator|<
name|AAC_MAX_CONTAINERS
operator|)
condition|)
do|;
name|aac_release_sync_fib
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
comment|/* poke the bus to actually attach the child devices */
if|if
condition|(
name|bus_generic_attach
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"bus_generic_attach failed\n"
argument_list|)
expr_stmt|;
comment|/* mark the controller up */
name|sc
operator|->
name|aac_state
operator|&=
operator|~
name|AAC_STATE_SUSPEND
expr_stmt|;
comment|/* enable interrupts now */
name|AAC_UNMASK_INTERRUPTS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Create a device to respresent a new container  */
end_comment

begin_function
specifier|static
name|void
name|aac_add_container
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|aac_mntinforesp
modifier|*
name|mir
parameter_list|,
name|int
name|f
parameter_list|)
block|{
name|struct
name|aac_container
modifier|*
name|co
decl_stmt|;
name|device_t
name|child
decl_stmt|;
comment|/* 	 * Check container volume type for validity.  Note that many of 	 * the possible types may never show up. 	 */
if|if
condition|(
operator|(
name|mir
operator|->
name|Status
operator|==
name|ST_OK
operator|)
operator|&&
operator|(
name|mir
operator|->
name|MntTable
index|[
literal|0
index|]
operator|.
name|VolType
operator|!=
name|CT_NONE
operator|)
condition|)
block|{
name|co
operator|=
operator|(
expr|struct
name|aac_container
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|co
argument_list|,
name|M_AACBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|co
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"Out of memory?!\n"
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|1
argument_list|,
literal|"id %x  name '%.16s'  size %u  type %d"
argument_list|,
name|mir
operator|->
name|MntTable
index|[
literal|0
index|]
operator|.
name|ObjectId
argument_list|,
name|mir
operator|->
name|MntTable
index|[
literal|0
index|]
operator|.
name|FileSystemName
argument_list|,
name|mir
operator|->
name|MntTable
index|[
literal|0
index|]
operator|.
name|Capacity
argument_list|,
name|mir
operator|->
name|MntTable
index|[
literal|0
index|]
operator|.
name|VolType
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|child
operator|=
name|device_add_child
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"aacd"
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"device_add_child failed\n"
argument_list|)
expr_stmt|;
else|else
name|device_set_ivars
argument_list|(
name|child
argument_list|,
name|co
argument_list|)
expr_stmt|;
name|device_set_desc
argument_list|(
name|child
argument_list|,
name|aac_describe_code
argument_list|(
name|aac_container_types
argument_list|,
name|mir
operator|->
name|MntTable
index|[
literal|0
index|]
operator|.
name|VolType
argument_list|)
argument_list|)
expr_stmt|;
name|co
operator|->
name|co_disk
operator|=
name|child
expr_stmt|;
name|co
operator|->
name|co_found
operator|=
name|f
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|mir
operator|->
name|MntTable
index|[
literal|0
index|]
argument_list|,
operator|&
name|co
operator|->
name|co_mntobj
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_mntobj
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|aac_container_lock
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|aac_container_tqh
argument_list|,
name|co
argument_list|,
name|co_link
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_container_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Free all of the resources associated with (sc)  *  * Should not be called if the controller is active.  */
end_comment

begin_function
name|void
name|aac_free
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* remove the control device */
if|if
condition|(
name|sc
operator|->
name|aac_dev_t
operator|!=
name|NULL
condition|)
name|destroy_dev
argument_list|(
name|sc
operator|->
name|aac_dev_t
argument_list|)
expr_stmt|;
comment|/* throw away any FIB buffers, discard the FIB DMA tag */
name|aac_free_commands
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|aac_fib_dmat
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|aac_fib_dmat
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|aac_commands
argument_list|,
name|M_AACBUF
argument_list|)
expr_stmt|;
comment|/* destroy the common area */
if|if
condition|(
name|sc
operator|->
name|aac_common
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|aac_common_dmat
argument_list|,
name|sc
operator|->
name|aac_common_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|aac_common_dmat
argument_list|,
name|sc
operator|->
name|aac_common
argument_list|,
name|sc
operator|->
name|aac_common_dmamap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|aac_common_dmat
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|aac_common_dmat
argument_list|)
expr_stmt|;
comment|/* disconnect the interrupt handler */
if|if
condition|(
name|sc
operator|->
name|aac_intr
condition|)
name|bus_teardown_intr
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
name|sc
operator|->
name|aac_irq
argument_list|,
name|sc
operator|->
name|aac_intr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|aac_irq
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|aac_irq_rid
argument_list|,
name|sc
operator|->
name|aac_irq
argument_list|)
expr_stmt|;
comment|/* destroy data-transfer DMA tag */
if|if
condition|(
name|sc
operator|->
name|aac_buffer_dmat
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|aac_buffer_dmat
argument_list|)
expr_stmt|;
comment|/* destroy the parent DMA tag */
if|if
condition|(
name|sc
operator|->
name|aac_parent_dmat
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|aac_parent_dmat
argument_list|)
expr_stmt|;
comment|/* release the register window mapping */
if|if
condition|(
name|sc
operator|->
name|aac_regs_resource
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|aac_regs_rid
argument_list|,
name|sc
operator|->
name|aac_regs_resource
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Disconnect from the controller completely, in preparation for unload.  */
end_comment

begin_function
name|int
name|aac_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|aac_container
modifier|*
name|co
decl_stmt|;
name|struct
name|aac_sim
modifier|*
name|sim
decl_stmt|;
name|int
name|error
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|aac_state
operator|&
name|AAC_STATE_OPEN
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* Remove the child containers */
while|while
condition|(
operator|(
name|co
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|aac_container_tqh
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|device_delete_child
argument_list|(
name|dev
argument_list|,
name|co
operator|->
name|co_disk
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|aac_container_tqh
argument_list|,
name|co
argument_list|,
name|co_link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|co
argument_list|,
name|M_AACBUF
argument_list|)
expr_stmt|;
block|}
comment|/* Remove the CAM SIMs */
while|while
condition|(
operator|(
name|sim
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|aac_sim_tqh
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|aac_sim_tqh
argument_list|,
name|sim
argument_list|,
name|sim_link
argument_list|)
expr_stmt|;
name|error
operator|=
name|device_delete_child
argument_list|(
name|dev
argument_list|,
name|sim
operator|->
name|sim_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|free
argument_list|(
name|sim
argument_list|,
name|M_AACBUF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|aifflags
operator|&
name|AAC_AIFFLAGS_RUNNING
condition|)
block|{
name|sc
operator|->
name|aifflags
operator||=
name|AAC_AIFFLAGS_EXIT
expr_stmt|;
name|wakeup
argument_list|(
name|sc
operator|->
name|aifthread
argument_list|)
expr_stmt|;
name|tsleep
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
name|PUSER
operator||
name|PCATCH
argument_list|,
literal|"aacdch"
argument_list|,
literal|30
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|aifflags
operator|&
name|AAC_AIFFLAGS_RUNNING
condition|)
name|panic
argument_list|(
literal|"Cannot shutdown AIF thread\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|aac_shutdown
argument_list|(
name|dev
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|shutdown_final
argument_list|,
name|sc
operator|->
name|eh
argument_list|)
expr_stmt|;
name|aac_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|aac_aifq_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|aac_container_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Bring the controller down to a dormant state and detach all child devices.  *  * This function is called before detach or system shutdown.  *  * Note that we can assume that the bioq on the controller is empty, as we won't  * allow shutdown if any device is open.  */
end_comment

begin_function
name|int
name|aac_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|aac_fib
modifier|*
name|fib
decl_stmt|;
name|struct
name|aac_close_command
modifier|*
name|cc
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|aac_state
operator||=
name|AAC_STATE_SUSPEND
expr_stmt|;
comment|/* 	 * Send a Container shutdown followed by a HostShutdown FIB to the 	 * controller to convince it that we don't want to talk to it anymore. 	 * We've been closed and all I/O completed already 	 */
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"shutting down controller..."
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
name|aac_alloc_sync_fib
argument_list|(
name|sc
argument_list|,
operator|&
name|fib
argument_list|)
expr_stmt|;
name|cc
operator|=
operator|(
expr|struct
name|aac_close_command
operator|*
operator|)
operator|&
name|fib
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
name|bzero
argument_list|(
name|cc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_close_command
argument_list|)
argument_list|)
expr_stmt|;
name|cc
operator|->
name|Command
operator|=
name|VM_CloseAll
expr_stmt|;
name|cc
operator|->
name|ContainerId
operator|=
literal|0xffffffff
expr_stmt|;
if|if
condition|(
name|aac_sync_fib
argument_list|(
name|sc
argument_list|,
name|ContainerCommand
argument_list|,
literal|0
argument_list|,
name|fib
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_close_command
argument_list|)
argument_list|)
condition|)
name|printf
argument_list|(
literal|"FAILED.\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"done\n"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|else { 		fib->data[0] = 0;
comment|/* 		 * XXX Issuing this command to the controller makes it shut down 		 * but also keeps it from coming back up without a reset of the 		 * PCI bus.  This is not desirable if you are just unloading the 		 * driver module with the intent to reload it later. 		 */
block|if (aac_sync_fib(sc, FsaHostShutdown, AAC_FIBSTATE_SHUTDOWN, 		    fib, 1)) { 			printf("FAILED.\n"); 		} else { 			printf("done.\n"); 		} 	}
endif|#
directive|endif
name|AAC_MASK_INTERRUPTS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|aac_release_sync_fib
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Bring the controller to a quiescent state, ready for system suspend.  */
end_comment

begin_function
name|int
name|aac_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|aac_state
operator||=
name|AAC_STATE_SUSPEND
expr_stmt|;
name|AAC_MASK_INTERRUPTS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Bring the controller back to a state ready for operation.  */
end_comment

begin_function
name|int
name|aac_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|aac_state
operator|&=
operator|~
name|AAC_STATE_SUSPEND
expr_stmt|;
name|AAC_UNMASK_INTERRUPTS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Interrupt handler for NEW_COMM interface.  */
end_comment

begin_function
name|void
name|aac_new_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
decl_stmt|;
name|u_int32_t
name|index
decl_stmt|,
name|fast
decl_stmt|;
name|struct
name|aac_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|aac_fib
modifier|*
name|fib
decl_stmt|;
name|int
name|i
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|aac_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|index
operator|=
name|AAC_GET_OUTB_QUEUE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
literal|0xffffffff
condition|)
name|index
operator|=
name|AAC_GET_OUTB_QUEUE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
literal|0xffffffff
condition|)
break|break;
if|if
condition|(
name|index
operator|&
literal|2
condition|)
block|{
if|if
condition|(
name|index
operator|==
literal|0xfffffffe
condition|)
block|{
comment|/* XXX This means that the controller wants 				 * more work.  Ignore it for now. 				 */
continue|continue;
block|}
comment|/* AIF */
name|fib
operator|=
operator|(
expr|struct
name|aac_fib
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|fib
argument_list|,
name|M_AACBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|fib
operator|==
name|NULL
condition|)
block|{
comment|/* If we're really this short on memory, 				 * hopefully breaking out of the handler will 				 * allow something to get freed.  This 				 * actually sucks a whole lot. 				 */
break|break;
block|}
name|index
operator|&=
operator|~
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
operator|/
literal|4
condition|;
operator|++
name|i
control|)
operator|(
operator|(
name|u_int32_t
operator|*
operator|)
name|fib
operator|)
index|[
name|i
index|]
operator|=
name|AAC_GETREG4
argument_list|(
name|sc
argument_list|,
name|index
operator|+
name|i
operator|*
literal|4
argument_list|)
expr_stmt|;
name|aac_handle_aif
argument_list|(
name|sc
argument_list|,
name|fib
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fib
argument_list|,
name|M_AACBUF
argument_list|)
expr_stmt|;
comment|/* 			 * AIF memory is owned by the adapter, so let it 			 * know that we are done with it. 			 */
name|AAC_SET_OUTB_QUEUE
argument_list|(
name|sc
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|AAC_CLEAR_ISTATUS
argument_list|(
name|sc
argument_list|,
name|AAC_DB_RESPONSE_READY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fast
operator|=
name|index
operator|&
literal|1
expr_stmt|;
name|cm
operator|=
name|sc
operator|->
name|aac_commands
operator|+
operator|(
name|index
operator|>>
literal|2
operator|)
expr_stmt|;
name|fib
operator|=
name|cm
operator|->
name|cm_fib
expr_stmt|;
if|if
condition|(
name|fast
condition|)
block|{
name|fib
operator|->
name|Header
operator|.
name|XferState
operator||=
name|AAC_FIBSTATE_DONEADAP
expr_stmt|;
operator|*
operator|(
operator|(
name|u_int32_t
operator|*
operator|)
operator|(
name|fib
operator|->
name|data
operator|)
operator|)
operator|=
name|AAC_ERROR_NORMAL
expr_stmt|;
block|}
name|aac_remove_busy
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|aac_unmap_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator||=
name|AAC_CMD_COMPLETED
expr_stmt|;
comment|/* is there a completion handler? */
if|if
condition|(
name|cm
operator|->
name|cm_complete
operator|!=
name|NULL
condition|)
block|{
name|cm
operator|->
name|cm_complete
argument_list|(
name|cm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* assume that someone is sleeping on this 				 * command 				 */
name|wakeup
argument_list|(
name|cm
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|flags
operator|&=
operator|~
name|AAC_QUEUE_FRZN
expr_stmt|;
block|}
block|}
comment|/* see if we can start some more I/O */
if|if
condition|(
operator|(
name|sc
operator|->
name|flags
operator|&
name|AAC_QUEUE_FRZN
operator|)
operator|==
literal|0
condition|)
name|aac_startio
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|aac_fast_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
decl_stmt|;
name|u_int16_t
name|reason
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|aac_softc
operator|*
operator|)
name|arg
expr_stmt|;
comment|/* 	 * Read the status register directly.  This is faster than taking the 	 * driver lock and reading the queues directly.  It also saves having 	 * to turn parts of the driver lock into a spin mutex, which would be 	 * ugly. 	 */
name|reason
operator|=
name|AAC_GET_ISTATUS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|AAC_CLEAR_ISTATUS
argument_list|(
name|sc
argument_list|,
name|reason
argument_list|)
expr_stmt|;
comment|/* handle completion processing */
if|if
condition|(
name|reason
operator|&
name|AAC_DB_RESPONSE_READY
condition|)
name|taskqueue_enqueue_fast
argument_list|(
name|taskqueue_fast
argument_list|,
operator|&
name|sc
operator|->
name|aac_task_complete
argument_list|)
expr_stmt|;
comment|/* controller wants to talk to us */
if|if
condition|(
name|reason
operator|&
operator|(
name|AAC_DB_PRINTF
operator||
name|AAC_DB_COMMAND_READY
operator|)
condition|)
block|{
comment|/* 		 * XXX Make sure that we don't get fooled by strange messages 		 * that start with a NULL. 		 */
if|if
condition|(
operator|(
name|reason
operator|&
name|AAC_DB_PRINTF
operator|)
operator|&&
operator|(
name|sc
operator|->
name|aac_common
operator|->
name|ac_printf
index|[
literal|0
index|]
operator|==
literal|0
operator|)
condition|)
name|sc
operator|->
name|aac_common
operator|->
name|ac_printf
index|[
literal|0
index|]
operator|=
literal|32
expr_stmt|;
comment|/* 		 * This might miss doing the actual wakeup.  However, the 		 * msleep that this is waking up has a timeout, so it will 		 * wake up eventually.  AIFs and printfs are low enough 		 * priority that they can handle hanging out for a few seconds 		 * if needed. 		 */
name|wakeup
argument_list|(
name|sc
operator|->
name|aifthread
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|FILTER_HANDLED
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Command Processing  */
end_comment

begin_comment
comment|/*  * Start as much queued I/O as possible on the controller  */
end_comment

begin_function
name|void
name|aac_startio
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|aac_command
modifier|*
name|cm
decl_stmt|;
name|int
name|error
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * This flag might be set if the card is out of resources. 		 * Checking it here prevents an infinite loop of deferrals. 		 */
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|AAC_QUEUE_FRZN
condition|)
break|break;
comment|/* 		 * Try to get a command that's been put off for lack of 		 * resources 		 */
name|cm
operator|=
name|aac_dequeue_ready
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 		 * Try to build a command off the bio queue (ignore error 		 * return) 		 */
if|if
condition|(
name|cm
operator|==
name|NULL
condition|)
name|aac_bio_command
argument_list|(
name|sc
argument_list|,
operator|&
name|cm
argument_list|)
expr_stmt|;
comment|/* nothing to do? */
if|if
condition|(
name|cm
operator|==
name|NULL
condition|)
break|break;
comment|/* don't map more than once */
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|AAC_CMD_MAPPED
condition|)
name|panic
argument_list|(
literal|"aac: command %p already mapped"
argument_list|,
name|cm
argument_list|)
expr_stmt|;
comment|/* 		 * Set up the command to go to the controller.  If there are no 		 * data buffers associated with the command then it can bypass 		 * busdma. 		 */
if|if
condition|(
name|cm
operator|->
name|cm_datalen
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|aac_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_datamap
argument_list|,
name|cm
operator|->
name|cm_data
argument_list|,
name|cm
operator|->
name|cm_datalen
argument_list|,
name|aac_map_command_sg
argument_list|,
name|cm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINPROGRESS
condition|)
block|{
name|debug
argument_list|(
literal|1
argument_list|,
literal|"freezing queue\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator||=
name|AAC_QUEUE_FRZN
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"aac_startio: unexpected error %d from "
literal|"busdma\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
else|else
name|aac_map_command_sg
argument_list|(
name|cm
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Handle notification of one or more FIBs coming from the controller.  */
end_comment

begin_function
specifier|static
name|void
name|aac_command_thread
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|aac_fib
modifier|*
name|fib
decl_stmt|;
name|u_int32_t
name|fib_size
decl_stmt|;
name|int
name|size
decl_stmt|,
name|retval
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
name|sc
operator|->
name|aifflags
operator|=
name|AAC_AIFFLAGS_RUNNING
expr_stmt|;
while|while
condition|(
operator|(
name|sc
operator|->
name|aifflags
operator|&
name|AAC_AIFFLAGS_EXIT
operator|)
operator|==
literal|0
condition|)
block|{
name|retval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|aifflags
operator|&
name|AAC_AIFFLAGS_PENDING
operator|)
operator|==
literal|0
condition|)
name|retval
operator|=
name|msleep
argument_list|(
name|sc
operator|->
name|aifthread
argument_list|,
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|,
name|PRIBIO
argument_list|,
literal|"aifthd"
argument_list|,
name|AAC_PERIODIC_INTERVAL
operator|*
name|hz
argument_list|)
expr_stmt|;
comment|/* 		 * First see if any FIBs need to be allocated.  This needs 		 * to be called without the driver lock because contigmalloc 		 * will grab Giant, and would result in an LOR. 		 */
if|if
condition|(
operator|(
name|sc
operator|->
name|aifflags
operator|&
name|AAC_AIFFLAGS_ALLOCFIBS
operator|)
operator|!=
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
name|aac_alloc_commands
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
name|sc
operator|->
name|aifflags
operator|&=
operator|~
name|AAC_AIFFLAGS_ALLOCFIBS
expr_stmt|;
name|aac_startio
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * While we're here, check to see if any commands are stuck. 		 * This is pretty low-priority, so it's ok if it doesn't 		 * always fire. 		 */
if|if
condition|(
name|retval
operator|==
name|EWOULDBLOCK
condition|)
name|aac_timeout
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Check the hardware printf message buffer */
if|if
condition|(
name|sc
operator|->
name|aac_common
operator|->
name|ac_printf
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
name|aac_print_printf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Also check to see if the adapter has a command for us. */
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|AAC_FLAGS_NEW_COMM
condition|)
continue|continue;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|aac_dequeue_fib
argument_list|(
name|sc
argument_list|,
name|AAC_HOST_NORM_CMD_QUEUE
argument_list|,
operator|&
name|fib_size
argument_list|,
operator|&
name|fib
argument_list|)
condition|)
break|break;
name|AAC_PRINT_FIB
argument_list|(
name|sc
argument_list|,
name|fib
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fib
operator|->
name|Header
operator|.
name|Command
condition|)
block|{
case|case
name|AifRequest
case|:
name|aac_handle_aif
argument_list|(
name|sc
argument_list|,
name|fib
argument_list|)
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"unknown command "
literal|"from controller\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|fib
operator|->
name|Header
operator|.
name|XferState
operator|==
literal|0
operator|)
operator|||
operator|(
name|fib
operator|->
name|Header
operator|.
name|StructType
operator|!=
name|AAC_FIBTYPE_TFIB
operator|)
condition|)
block|{
break|break;
block|}
comment|/* Return the AIF to the controller. */
if|if
condition|(
name|fib
operator|->
name|Header
operator|.
name|XferState
operator|&
name|AAC_FIBSTATE_FROMADAP
condition|)
block|{
name|fib
operator|->
name|Header
operator|.
name|XferState
operator||=
name|AAC_FIBSTATE_DONEHOST
expr_stmt|;
operator|*
operator|(
name|AAC_FSAStatus
operator|*
operator|)
name|fib
operator|->
name|data
operator|=
name|ST_OK
expr_stmt|;
comment|/* XXX Compute the Size field? */
name|size
operator|=
name|fib
operator|->
name|Header
operator|.
name|Size
expr_stmt|;
if|if
condition|(
name|size
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
condition|)
block|{
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|Size
operator|=
name|size
expr_stmt|;
block|}
comment|/* 				 * Since we did not generate this command, it 				 * cannot go through the normal 				 * enqueue->startio chain. 				 */
name|aac_enqueue_response
argument_list|(
name|sc
argument_list|,
name|AAC_ADAP_NORM_RESP_QUEUE
argument_list|,
name|fib
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|sc
operator|->
name|aifflags
operator|&=
operator|~
name|AAC_AIFFLAGS_RUNNING
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|)
expr_stmt|;
name|kthread_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process completed commands.  */
end_comment

begin_function
specifier|static
name|void
name|aac_complete
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|aac_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|aac_fib
modifier|*
name|fib
decl_stmt|;
name|u_int32_t
name|fib_size
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|aac_softc
operator|*
operator|)
name|context
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
comment|/* pull completed commands off the queue */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* look for completed FIBs on our queue */
if|if
condition|(
name|aac_dequeue_fib
argument_list|(
name|sc
argument_list|,
name|AAC_HOST_NORM_RESP_QUEUE
argument_list|,
operator|&
name|fib_size
argument_list|,
operator|&
name|fib
argument_list|)
condition|)
break|break;
comment|/* nothing to do */
comment|/* get the command, unmap and hand off for processing */
name|cm
operator|=
name|sc
operator|->
name|aac_commands
operator|+
name|fib
operator|->
name|Header
operator|.
name|SenderData
expr_stmt|;
if|if
condition|(
name|cm
operator|==
name|NULL
condition|)
block|{
name|AAC_PRINT_FIB
argument_list|(
name|sc
argument_list|,
name|fib
argument_list|)
expr_stmt|;
break|break;
block|}
name|aac_remove_busy
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|aac_unmap_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator||=
name|AAC_CMD_COMPLETED
expr_stmt|;
comment|/* is there a completion handler? */
if|if
condition|(
name|cm
operator|->
name|cm_complete
operator|!=
name|NULL
condition|)
block|{
name|cm
operator|->
name|cm_complete
argument_list|(
name|cm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* assume that someone is sleeping on this command */
name|wakeup
argument_list|(
name|cm
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* see if we can start some more I/O */
name|sc
operator|->
name|flags
operator|&=
operator|~
name|AAC_QUEUE_FRZN
expr_stmt|;
name|aac_startio
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle a bio submitted from a disk device.  */
end_comment

begin_function
name|void
name|aac_submit_bio
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|aac_disk
modifier|*
name|ad
decl_stmt|;
name|struct
name|aac_softc
modifier|*
name|sc
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|ad
operator|=
operator|(
expr|struct
name|aac_disk
operator|*
operator|)
name|bp
operator|->
name|bio_disk
operator|->
name|d_drv1
expr_stmt|;
name|sc
operator|=
name|ad
operator|->
name|ad_controller
expr_stmt|;
comment|/* queue the BIO and try to get some work done */
name|aac_enqueue_bio
argument_list|(
name|sc
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|aac_startio
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get a bio and build a command to go with it.  */
end_comment

begin_function
specifier|static
name|int
name|aac_bio_command
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|aac_command
modifier|*
modifier|*
name|cmp
parameter_list|)
block|{
name|struct
name|aac_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|aac_fib
modifier|*
name|fib
decl_stmt|;
name|struct
name|aac_disk
modifier|*
name|ad
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* get the resources we will need */
name|cm
operator|=
name|NULL
expr_stmt|;
name|bp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|aac_alloc_command
argument_list|(
name|sc
argument_list|,
operator|&
name|cm
argument_list|)
condition|)
comment|/* get a command */
goto|goto
name|fail
goto|;
if|if
condition|(
operator|(
name|bp
operator|=
name|aac_dequeue_bio
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
comment|/* fill out the command */
name|cm
operator|->
name|cm_data
operator|=
operator|(
name|void
operator|*
operator|)
name|bp
operator|->
name|bio_data
expr_stmt|;
name|cm
operator|->
name|cm_datalen
operator|=
name|bp
operator|->
name|bio_bcount
expr_stmt|;
name|cm
operator|->
name|cm_complete
operator|=
name|aac_bio_complete
expr_stmt|;
name|cm
operator|->
name|cm_private
operator|=
name|bp
expr_stmt|;
name|cm
operator|->
name|cm_timestamp
operator|=
name|time_uptime
expr_stmt|;
name|cm
operator|->
name|cm_queue
operator|=
name|AAC_ADAP_NORM_CMD_QUEUE
expr_stmt|;
comment|/* build the FIB */
name|fib
operator|=
name|cm
operator|->
name|cm_fib
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|Size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib_header
argument_list|)
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|XferState
operator|=
name|AAC_FIBSTATE_HOSTOWNED
operator||
name|AAC_FIBSTATE_INITIALISED
operator||
name|AAC_FIBSTATE_EMPTY
operator||
name|AAC_FIBSTATE_FROMHOST
operator||
name|AAC_FIBSTATE_REXPECTED
operator||
name|AAC_FIBSTATE_NORM
operator||
name|AAC_FIBSTATE_ASYNC
operator||
name|AAC_FIBSTATE_FAST_RESPONSE
expr_stmt|;
comment|/* build the read/write request */
name|ad
operator|=
operator|(
expr|struct
name|aac_disk
operator|*
operator|)
name|bp
operator|->
name|bio_disk
operator|->
name|d_drv1
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|AAC_FLAGS_RAW_IO
condition|)
block|{
name|struct
name|aac_raw_io
modifier|*
name|raw
decl_stmt|;
name|raw
operator|=
operator|(
expr|struct
name|aac_raw_io
operator|*
operator|)
operator|&
name|fib
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|Command
operator|=
name|RawIo
expr_stmt|;
name|raw
operator|->
name|BlockNumber
operator|=
operator|(
name|u_int64_t
operator|)
name|bp
operator|->
name|bio_pblkno
expr_stmt|;
name|raw
operator|->
name|ByteCount
operator|=
name|bp
operator|->
name|bio_bcount
expr_stmt|;
name|raw
operator|->
name|ContainerId
operator|=
name|ad
operator|->
name|ad_container
operator|->
name|co_mntobj
operator|.
name|ObjectId
expr_stmt|;
name|raw
operator|->
name|BpTotal
operator|=
literal|0
expr_stmt|;
name|raw
operator|->
name|BpComplete
operator|=
literal|0
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|Size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|aac_raw_io
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_sgtable
operator|=
operator|(
expr|struct
name|aac_sg_table
operator|*
operator|)
operator|&
name|raw
operator|->
name|SgMapRaw
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_READ
condition|)
block|{
name|raw
operator|->
name|Flags
operator|=
literal|1
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator||=
name|AAC_CMD_DATAIN
expr_stmt|;
block|}
else|else
block|{
name|raw
operator|->
name|Flags
operator|=
literal|0
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator||=
name|AAC_CMD_DATAOUT
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|sc
operator|->
name|flags
operator|&
name|AAC_FLAGS_SG_64BIT
operator|)
operator|==
literal|0
condition|)
block|{
name|fib
operator|->
name|Header
operator|.
name|Command
operator|=
name|ContainerCommand
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_READ
condition|)
block|{
name|struct
name|aac_blockread
modifier|*
name|br
decl_stmt|;
name|br
operator|=
operator|(
expr|struct
name|aac_blockread
operator|*
operator|)
operator|&
name|fib
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
name|br
operator|->
name|Command
operator|=
name|VM_CtBlockRead
expr_stmt|;
name|br
operator|->
name|ContainerId
operator|=
name|ad
operator|->
name|ad_container
operator|->
name|co_mntobj
operator|.
name|ObjectId
expr_stmt|;
name|br
operator|->
name|BlockNumber
operator|=
name|bp
operator|->
name|bio_pblkno
expr_stmt|;
name|br
operator|->
name|ByteCount
operator|=
name|bp
operator|->
name|bio_bcount
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|Size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|aac_blockread
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_sgtable
operator|=
operator|&
name|br
operator|->
name|SgMap
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator||=
name|AAC_CMD_DATAIN
expr_stmt|;
block|}
else|else
block|{
name|struct
name|aac_blockwrite
modifier|*
name|bw
decl_stmt|;
name|bw
operator|=
operator|(
expr|struct
name|aac_blockwrite
operator|*
operator|)
operator|&
name|fib
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
name|bw
operator|->
name|Command
operator|=
name|VM_CtBlockWrite
expr_stmt|;
name|bw
operator|->
name|ContainerId
operator|=
name|ad
operator|->
name|ad_container
operator|->
name|co_mntobj
operator|.
name|ObjectId
expr_stmt|;
name|bw
operator|->
name|BlockNumber
operator|=
name|bp
operator|->
name|bio_pblkno
expr_stmt|;
name|bw
operator|->
name|ByteCount
operator|=
name|bp
operator|->
name|bio_bcount
expr_stmt|;
name|bw
operator|->
name|Stable
operator|=
name|CUNSTABLE
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|Size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|aac_blockwrite
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator||=
name|AAC_CMD_DATAOUT
expr_stmt|;
name|cm
operator|->
name|cm_sgtable
operator|=
operator|&
name|bw
operator|->
name|SgMap
expr_stmt|;
block|}
block|}
else|else
block|{
name|fib
operator|->
name|Header
operator|.
name|Command
operator|=
name|ContainerCommand64
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_READ
condition|)
block|{
name|struct
name|aac_blockread64
modifier|*
name|br
decl_stmt|;
name|br
operator|=
operator|(
expr|struct
name|aac_blockread64
operator|*
operator|)
operator|&
name|fib
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
name|br
operator|->
name|Command
operator|=
name|VM_CtHostRead64
expr_stmt|;
name|br
operator|->
name|ContainerId
operator|=
name|ad
operator|->
name|ad_container
operator|->
name|co_mntobj
operator|.
name|ObjectId
expr_stmt|;
name|br
operator|->
name|SectorCount
operator|=
name|bp
operator|->
name|bio_bcount
operator|/
name|AAC_BLOCK_SIZE
expr_stmt|;
name|br
operator|->
name|BlockNumber
operator|=
name|bp
operator|->
name|bio_pblkno
expr_stmt|;
name|br
operator|->
name|Pad
operator|=
literal|0
expr_stmt|;
name|br
operator|->
name|Flags
operator|=
literal|0
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|Size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|aac_blockread64
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator||=
name|AAC_CMD_DATAOUT
expr_stmt|;
name|cm
operator|->
name|cm_sgtable
operator|=
operator|(
expr|struct
name|aac_sg_table
operator|*
operator|)
operator|&
name|br
operator|->
name|SgMap64
expr_stmt|;
block|}
else|else
block|{
name|struct
name|aac_blockwrite64
modifier|*
name|bw
decl_stmt|;
name|bw
operator|=
operator|(
expr|struct
name|aac_blockwrite64
operator|*
operator|)
operator|&
name|fib
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
name|bw
operator|->
name|Command
operator|=
name|VM_CtHostWrite64
expr_stmt|;
name|bw
operator|->
name|ContainerId
operator|=
name|ad
operator|->
name|ad_container
operator|->
name|co_mntobj
operator|.
name|ObjectId
expr_stmt|;
name|bw
operator|->
name|SectorCount
operator|=
name|bp
operator|->
name|bio_bcount
operator|/
name|AAC_BLOCK_SIZE
expr_stmt|;
name|bw
operator|->
name|BlockNumber
operator|=
name|bp
operator|->
name|bio_pblkno
expr_stmt|;
name|bw
operator|->
name|Pad
operator|=
literal|0
expr_stmt|;
name|bw
operator|->
name|Flags
operator|=
literal|0
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|Size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|aac_blockwrite64
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator||=
name|AAC_CMD_DATAIN
expr_stmt|;
name|cm
operator|->
name|cm_sgtable
operator|=
operator|(
expr|struct
name|aac_sg_table
operator|*
operator|)
operator|&
name|bw
operator|->
name|SgMap64
expr_stmt|;
block|}
block|}
operator|*
name|cmp
operator|=
name|cm
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
name|aac_enqueue_bio
argument_list|(
name|sc
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|!=
name|NULL
condition|)
name|aac_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle a bio-instigated command that has been completed.  */
end_comment

begin_function
specifier|static
name|void
name|aac_bio_complete
parameter_list|(
name|struct
name|aac_command
modifier|*
name|cm
parameter_list|)
block|{
name|struct
name|aac_blockread_response
modifier|*
name|brr
decl_stmt|;
name|struct
name|aac_blockwrite_response
modifier|*
name|bwr
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|AAC_FSAStatus
name|status
decl_stmt|;
comment|/* fetch relevant status and then release the command */
name|bp
operator|=
operator|(
expr|struct
name|bio
operator|*
operator|)
name|cm
operator|->
name|cm_private
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_READ
condition|)
block|{
name|brr
operator|=
operator|(
expr|struct
name|aac_blockread_response
operator|*
operator|)
operator|&
name|cm
operator|->
name|cm_fib
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
name|status
operator|=
name|brr
operator|->
name|Status
expr_stmt|;
block|}
else|else
block|{
name|bwr
operator|=
operator|(
expr|struct
name|aac_blockwrite_response
operator|*
operator|)
operator|&
name|cm
operator|->
name|cm_fib
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
name|status
operator|=
name|bwr
operator|->
name|Status
expr_stmt|;
block|}
name|aac_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
comment|/* fix up the bio based on status */
if|if
condition|(
name|status
operator|==
name|ST_OK
condition|)
block|{
name|bp
operator|->
name|bio_resid
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|bp
operator|->
name|bio_error
operator|=
name|EIO
expr_stmt|;
name|bp
operator|->
name|bio_flags
operator||=
name|BIO_ERROR
expr_stmt|;
comment|/* pass an error string out to the disk layer */
name|bp
operator|->
name|bio_driver1
operator|=
name|aac_describe_code
argument_list|(
name|aac_command_status_table
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
name|aac_biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Submit a command to the controller, return when it completes.  * XXX This is very dangerous!  If the card has gone out to lunch, we could  *     be stuck here forever.  At the same time, signals are not caught  *     because there is a risk that a signal could wakeup the sleep before  *     the card has a chance to complete the command.  Since there is no way  *     to cancel a command that is in progress, we can't protect against the  *     card completing a command late and spamming the command and data  *     memory.  So, we are held hostage until the command completes.  */
end_comment

begin_function
specifier|static
name|int
name|aac_wait_command
parameter_list|(
name|struct
name|aac_command
modifier|*
name|cm
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|=
name|cm
operator|->
name|cm_sc
expr_stmt|;
comment|/* Put the command on the ready queue and get things going */
name|cm
operator|->
name|cm_queue
operator|=
name|AAC_ADAP_NORM_CMD_QUEUE
expr_stmt|;
name|aac_enqueue_ready
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|aac_startio
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|msleep
argument_list|(
name|cm
argument_list|,
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|,
name|PRIBIO
argument_list|,
literal|"aacwait"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *Command Buffer Management  */
end_comment

begin_comment
comment|/*  * Allocate a command.  */
end_comment

begin_function
name|int
name|aac_alloc_command
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|aac_command
modifier|*
modifier|*
name|cmp
parameter_list|)
block|{
name|struct
name|aac_command
modifier|*
name|cm
decl_stmt|;
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|=
name|aac_dequeue_free
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|total_fibs
operator|<
name|sc
operator|->
name|aac_max_fibs
condition|)
block|{
name|sc
operator|->
name|aifflags
operator||=
name|AAC_AIFFLAGS_ALLOCFIBS
expr_stmt|;
name|wakeup
argument_list|(
name|sc
operator|->
name|aifthread
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
operator|*
name|cmp
operator|=
name|cm
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Release a command back to the freelist.  */
end_comment

begin_function
name|void
name|aac_release_command
parameter_list|(
name|struct
name|aac_command
modifier|*
name|cm
parameter_list|)
block|{
name|struct
name|aac_event
modifier|*
name|event
decl_stmt|;
name|struct
name|aac_softc
modifier|*
name|sc
decl_stmt|;
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
comment|/* (re)initialise the command/FIB */
name|cm
operator|->
name|cm_sgtable
operator|=
name|NULL
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator|=
literal|0
expr_stmt|;
name|cm
operator|->
name|cm_complete
operator|=
name|NULL
expr_stmt|;
name|cm
operator|->
name|cm_private
operator|=
name|NULL
expr_stmt|;
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|XferState
operator|=
name|AAC_FIBSTATE_EMPTY
expr_stmt|;
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|StructType
operator|=
name|AAC_FIBTYPE_TFIB
expr_stmt|;
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|Flags
operator|=
literal|0
expr_stmt|;
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|SenderSize
operator|=
name|cm
operator|->
name|cm_sc
operator|->
name|aac_max_fib_size
expr_stmt|;
comment|/* 	 * These are duplicated in aac_start to cover the case where an 	 * intermediate stage may have destroyed them.  They're left 	 * initialised here for debugging purposes only. 	 */
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|ReceiverFibAddress
operator|=
operator|(
name|u_int32_t
operator|)
name|cm
operator|->
name|cm_fibphys
expr_stmt|;
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|SenderData
operator|=
literal|0
expr_stmt|;
name|aac_enqueue_free
argument_list|(
name|cm
argument_list|)
expr_stmt|;
comment|/* 	 * Dequeue all events so that there's no risk of events getting 	 * stranded. 	 */
name|sc
operator|=
name|cm
operator|->
name|cm_sc
expr_stmt|;
while|while
condition|(
operator|(
name|event
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|aac_ev_cmfree
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|aac_ev_cmfree
argument_list|,
name|event
argument_list|,
name|ev_links
argument_list|)
expr_stmt|;
name|event
operator|->
name|ev_callback
argument_list|(
name|sc
argument_list|,
name|event
argument_list|,
name|event
operator|->
name|ev_arg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Map helper for command/FIB allocation.  */
end_comment

begin_function
specifier|static
name|void
name|aac_map_command_helper
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|uint64_t
modifier|*
name|fibphys
decl_stmt|;
name|fibphys
operator|=
operator|(
name|uint64_t
operator|*
operator|)
name|arg
expr_stmt|;
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
operator|*
name|fibphys
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate and initialise commands/FIBs for this adapter.  */
end_comment

begin_function
specifier|static
name|int
name|aac_alloc_commands
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|aac_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|aac_fibmap
modifier|*
name|fm
decl_stmt|;
name|uint64_t
name|fibphys
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|total_fibs
operator|+
name|sc
operator|->
name|aac_max_fibs_alloc
operator|>
name|sc
operator|->
name|aac_max_fibs
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|fm
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fibmap
argument_list|)
argument_list|,
name|M_AACBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|fm
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* allocate the FIBs in DMAable memory and load them */
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|aac_fib_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|fm
operator|->
name|aac_fibs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|fm
operator|->
name|aac_fibmap
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"Not enough contiguous memory available.\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fm
argument_list|,
name|M_AACBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* Ignore errors since this doesn't bounce */
operator|(
name|void
operator|)
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|aac_fib_dmat
argument_list|,
name|fm
operator|->
name|aac_fibmap
argument_list|,
name|fm
operator|->
name|aac_fibs
argument_list|,
name|sc
operator|->
name|aac_max_fibs_alloc
operator|*
name|sc
operator|->
name|aac_max_fib_size
argument_list|,
name|aac_map_command_helper
argument_list|,
operator|&
name|fibphys
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* initialise constant fields in the command structure */
name|bzero
argument_list|(
name|fm
operator|->
name|aac_fibs
argument_list|,
name|sc
operator|->
name|aac_max_fibs_alloc
operator|*
name|sc
operator|->
name|aac_max_fib_size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|aac_max_fibs_alloc
condition|;
name|i
operator|++
control|)
block|{
name|cm
operator|=
name|sc
operator|->
name|aac_commands
operator|+
name|sc
operator|->
name|total_fibs
expr_stmt|;
name|fm
operator|->
name|aac_commands
operator|=
name|cm
expr_stmt|;
name|cm
operator|->
name|cm_sc
operator|=
name|sc
expr_stmt|;
name|cm
operator|->
name|cm_fib
operator|=
operator|(
expr|struct
name|aac_fib
operator|*
operator|)
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
name|fm
operator|->
name|aac_fibs
operator|+
name|i
operator|*
name|sc
operator|->
name|aac_max_fib_size
operator|)
expr_stmt|;
name|cm
operator|->
name|cm_fibphys
operator|=
name|fibphys
operator|+
name|i
operator|*
name|sc
operator|->
name|aac_max_fib_size
expr_stmt|;
name|cm
operator|->
name|cm_index
operator|=
name|sc
operator|->
name|total_fibs
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|aac_buffer_dmat
argument_list|,
literal|0
argument_list|,
operator|&
name|cm
operator|->
name|cm_datamap
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
name|aac_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|sc
operator|->
name|total_fibs
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|aac_fibmap_tqh
argument_list|,
name|fm
argument_list|,
name|fm_link
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|1
argument_list|,
literal|"total_fibs= %d\n"
argument_list|,
name|sc
operator|->
name|total_fibs
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|aac_fib_dmat
argument_list|,
name|fm
operator|->
name|aac_fibmap
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|aac_fib_dmat
argument_list|,
name|fm
operator|->
name|aac_fibs
argument_list|,
name|fm
operator|->
name|aac_fibmap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fm
argument_list|,
name|M_AACBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free FIBs owned by this adapter.  */
end_comment

begin_function
specifier|static
name|void
name|aac_free_commands
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|aac_fibmap
modifier|*
name|fm
decl_stmt|;
name|struct
name|aac_command
modifier|*
name|cm
decl_stmt|;
name|int
name|i
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|fm
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|aac_fibmap_tqh
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|aac_fibmap_tqh
argument_list|,
name|fm
argument_list|,
name|fm_link
argument_list|)
expr_stmt|;
comment|/* 		 * We check against total_fibs to handle partially 		 * allocated blocks. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|aac_max_fibs_alloc
operator|&&
name|sc
operator|->
name|total_fibs
operator|--
condition|;
name|i
operator|++
control|)
block|{
name|cm
operator|=
name|fm
operator|->
name|aac_commands
operator|+
name|i
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|aac_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_datamap
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|aac_fib_dmat
argument_list|,
name|fm
operator|->
name|aac_fibmap
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|aac_fib_dmat
argument_list|,
name|fm
operator|->
name|aac_fibs
argument_list|,
name|fm
operator|->
name|aac_fibmap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fm
argument_list|,
name|M_AACBUF
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Command-mapping helper function - populate this command's s/g table.  */
end_comment

begin_function
specifier|static
name|void
name|aac_map_command_sg
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|aac_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|aac_fib
modifier|*
name|fib
decl_stmt|;
name|int
name|i
decl_stmt|;
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|cm
operator|=
operator|(
expr|struct
name|aac_command
operator|*
operator|)
name|arg
expr_stmt|;
name|sc
operator|=
name|cm
operator|->
name|cm_sc
expr_stmt|;
name|fib
operator|=
name|cm
operator|->
name|cm_fib
expr_stmt|;
comment|/* copy into the FIB */
if|if
condition|(
name|cm
operator|->
name|cm_sgtable
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fib
operator|->
name|Header
operator|.
name|Command
operator|==
name|RawIo
condition|)
block|{
name|struct
name|aac_sg_tableraw
modifier|*
name|sg
decl_stmt|;
name|sg
operator|=
operator|(
expr|struct
name|aac_sg_tableraw
operator|*
operator|)
name|cm
operator|->
name|cm_sgtable
expr_stmt|;
name|sg
operator|->
name|SgCount
operator|=
name|nseg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nseg
condition|;
name|i
operator|++
control|)
block|{
name|sg
operator|->
name|SgEntryRaw
index|[
name|i
index|]
operator|.
name|SgAddress
operator|=
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
expr_stmt|;
name|sg
operator|->
name|SgEntryRaw
index|[
name|i
index|]
operator|.
name|SgByteCount
operator|=
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
expr_stmt|;
name|sg
operator|->
name|SgEntryRaw
index|[
name|i
index|]
operator|.
name|Next
operator|=
literal|0
expr_stmt|;
name|sg
operator|->
name|SgEntryRaw
index|[
name|i
index|]
operator|.
name|Prev
operator|=
literal|0
expr_stmt|;
name|sg
operator|->
name|SgEntryRaw
index|[
name|i
index|]
operator|.
name|Flags
operator|=
literal|0
expr_stmt|;
block|}
comment|/* update the FIB size for the s/g count */
name|fib
operator|->
name|Header
operator|.
name|Size
operator|+=
name|nseg
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|aac_sg_entryraw
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|cm
operator|->
name|cm_sc
operator|->
name|flags
operator|&
name|AAC_FLAGS_SG_64BIT
operator|)
operator|==
literal|0
condition|)
block|{
name|struct
name|aac_sg_table
modifier|*
name|sg
decl_stmt|;
name|sg
operator|=
name|cm
operator|->
name|cm_sgtable
expr_stmt|;
name|sg
operator|->
name|SgCount
operator|=
name|nseg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nseg
condition|;
name|i
operator|++
control|)
block|{
name|sg
operator|->
name|SgEntry
index|[
name|i
index|]
operator|.
name|SgAddress
operator|=
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
expr_stmt|;
name|sg
operator|->
name|SgEntry
index|[
name|i
index|]
operator|.
name|SgByteCount
operator|=
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
expr_stmt|;
block|}
comment|/* update the FIB size for the s/g count */
name|fib
operator|->
name|Header
operator|.
name|Size
operator|+=
name|nseg
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|aac_sg_entry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|aac_sg_table64
modifier|*
name|sg
decl_stmt|;
name|sg
operator|=
operator|(
expr|struct
name|aac_sg_table64
operator|*
operator|)
name|cm
operator|->
name|cm_sgtable
expr_stmt|;
name|sg
operator|->
name|SgCount
operator|=
name|nseg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nseg
condition|;
name|i
operator|++
control|)
block|{
name|sg
operator|->
name|SgEntry64
index|[
name|i
index|]
operator|.
name|SgAddress
operator|=
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
expr_stmt|;
name|sg
operator|->
name|SgEntry64
index|[
name|i
index|]
operator|.
name|SgByteCount
operator|=
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
expr_stmt|;
block|}
comment|/* update the FIB size for the s/g count */
name|fib
operator|->
name|Header
operator|.
name|Size
operator|+=
name|nseg
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|aac_sg_entry64
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Fix up the address values in the FIB.  Use the command array index 	 * instead of a pointer since these fields are only 32 bits.  Shift 	 * the SenderFibAddress over to make room for the fast response bit 	 * and for the AIF bit 	 */
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|SenderFibAddress
operator|=
operator|(
name|cm
operator|->
name|cm_index
operator|<<
literal|2
operator|)
expr_stmt|;
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|ReceiverFibAddress
operator|=
operator|(
name|u_int32_t
operator|)
name|cm
operator|->
name|cm_fibphys
expr_stmt|;
comment|/* save a pointer to the command for speedy reverse-lookup */
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|SenderData
operator|=
name|cm
operator|->
name|cm_index
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|AAC_CMD_DATAIN
condition|)
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|aac_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_datamap
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|AAC_CMD_DATAOUT
condition|)
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|aac_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_datamap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator||=
name|AAC_CMD_MAPPED
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|AAC_FLAGS_NEW_COMM
condition|)
block|{
name|int
name|count
init|=
literal|10000000L
decl_stmt|;
while|while
condition|(
name|AAC_SEND_COMMAND
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|--
name|count
operator|==
literal|0
condition|)
block|{
name|aac_unmap_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator||=
name|AAC_QUEUE_FRZN
expr_stmt|;
name|aac_requeue_ready
argument_list|(
name|cm
argument_list|)
expr_stmt|;
block|}
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
comment|/* wait 5 usec. */
block|}
block|}
else|else
block|{
comment|/* Put the FIB on the outbound queue */
if|if
condition|(
name|aac_enqueue_fib
argument_list|(
name|sc
argument_list|,
name|cm
operator|->
name|cm_queue
argument_list|,
name|cm
argument_list|)
operator|==
name|EBUSY
condition|)
block|{
name|aac_unmap_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator||=
name|AAC_QUEUE_FRZN
expr_stmt|;
name|aac_requeue_ready
argument_list|(
name|cm
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * Unmap a command from controller-visible space.  */
end_comment

begin_function
specifier|static
name|void
name|aac_unmap_command
parameter_list|(
name|struct
name|aac_command
modifier|*
name|cm
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|=
name|cm
operator|->
name|cm_sc
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cm
operator|->
name|cm_flags
operator|&
name|AAC_CMD_MAPPED
operator|)
condition|)
return|return;
if|if
condition|(
name|cm
operator|->
name|cm_datalen
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|AAC_CMD_DATAIN
condition|)
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|aac_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_datamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|AAC_CMD_DATAOUT
condition|)
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|aac_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_datamap
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|aac_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_datamap
argument_list|)
expr_stmt|;
block|}
name|cm
operator|->
name|cm_flags
operator|&=
operator|~
name|AAC_CMD_MAPPED
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Hardware Interface  */
end_comment

begin_comment
comment|/*  * Initialise the adapter.  */
end_comment

begin_function
specifier|static
name|void
name|aac_common_map
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|aac_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|sc
operator|->
name|aac_common_busaddr
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|aac_check_firmware
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int32_t
name|major
decl_stmt|,
name|minor
decl_stmt|,
name|options
init|=
literal|0
decl_stmt|,
name|atu_size
init|=
literal|0
decl_stmt|;
name|int
name|status
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Retrieve the firmware version numbers.  Dell PERC2/QC cards with 	 * firmware version 1.x are not compatible with this driver. 	 */
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|AAC_FLAGS_PERC2QC
condition|)
block|{
if|if
condition|(
name|aac_sync_command
argument_list|(
name|sc
argument_list|,
name|AAC_MONKER_GETKERNVER
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"Error reading firmware version\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* These numbers are stored as ASCII! */
name|major
operator|=
operator|(
name|AAC_GET_MAILBOX
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
operator|&
literal|0xff
operator|)
operator|-
literal|0x30
expr_stmt|;
name|minor
operator|=
operator|(
name|AAC_GET_MAILBOX
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|)
operator|&
literal|0xff
operator|)
operator|-
literal|0x30
expr_stmt|;
if|if
condition|(
name|major
operator|==
literal|1
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"Firmware version %d.%d is not supported.\n"
argument_list|,
name|major
argument_list|,
name|minor
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
comment|/* 	 * Retrieve the capabilities/supported options word so we know what 	 * work-arounds to enable.  Some firmware revs don't support this 	 * command. 	 */
if|if
condition|(
name|aac_sync_command
argument_list|(
name|sc
argument_list|,
name|AAC_MONKER_GETINFO
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|status
argument_list|)
condition|)
block|{
if|if
condition|(
name|status
operator|!=
name|AAC_SRB_STS_INVALID_REQUEST
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"RequestAdapterInfo failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
else|else
block|{
name|options
operator|=
name|AAC_GET_MAILBOX
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|atu_size
operator|=
name|AAC_GET_MAILBOX
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|->
name|supported_options
operator|=
name|options
expr_stmt|;
if|if
condition|(
operator|(
name|options
operator|&
name|AAC_SUPPORTED_4GB_WINDOW
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|sc
operator|->
name|flags
operator|&
name|AAC_FLAGS_NO4GB
operator|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|flags
operator||=
name|AAC_FLAGS_4GB_WINDOW
expr_stmt|;
if|if
condition|(
name|options
operator|&
name|AAC_SUPPORTED_NONDASD
condition|)
name|sc
operator|->
name|flags
operator||=
name|AAC_FLAGS_ENABLE_CAM
expr_stmt|;
if|if
condition|(
operator|(
name|options
operator|&
name|AAC_SUPPORTED_SGMAP_HOST64
operator|)
operator|!=
literal|0
operator|&&
operator|(
sizeof|sizeof
argument_list|(
name|bus_addr_t
argument_list|)
operator|>
literal|4
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"Enabling 64-bit address support\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator||=
name|AAC_FLAGS_SG_64BIT
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|options
operator|&
name|AAC_SUPPORTED_NEW_COMM
operator|)
operator|&&
name|sc
operator|->
name|aac_if
operator|.
name|aif_send_command
condition|)
name|sc
operator|->
name|flags
operator||=
name|AAC_FLAGS_NEW_COMM
expr_stmt|;
if|if
condition|(
name|options
operator|&
name|AAC_SUPPORTED_64BIT_ARRAYSIZE
condition|)
name|sc
operator|->
name|flags
operator||=
name|AAC_FLAGS_ARRAY_64BIT
expr_stmt|;
block|}
comment|/* Check for broken hardware that does a lower number of commands */
name|sc
operator|->
name|aac_max_fibs
operator|=
operator|(
name|sc
operator|->
name|flags
operator|&
name|AAC_FLAGS_256FIBS
condition|?
literal|256
else|:
literal|512
operator|)
expr_stmt|;
comment|/* Remap mem. resource, if required */
if|if
condition|(
operator|(
name|sc
operator|->
name|flags
operator|&
name|AAC_FLAGS_NEW_COMM
operator|)
operator|&&
name|atu_size
operator|>
name|rman_get_size
argument_list|(
name|sc
operator|->
name|aac_regs_resource
argument_list|)
condition|)
block|{
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|aac_regs_rid
argument_list|,
name|sc
operator|->
name|aac_regs_resource
argument_list|)
expr_stmt|;
name|sc
operator|->
name|aac_regs_resource
operator|=
name|bus_alloc_resource
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|sc
operator|->
name|aac_regs_rid
argument_list|,
literal|0ul
argument_list|,
operator|~
literal|0ul
argument_list|,
name|atu_size
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|aac_regs_resource
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|aac_regs_resource
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|sc
operator|->
name|aac_regs_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|aac_regs_resource
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"couldn't allocate register window\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|flags
operator|&=
operator|~
name|AAC_FLAGS_NEW_COMM
expr_stmt|;
block|}
name|sc
operator|->
name|aac_btag
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|aac_regs_resource
argument_list|)
expr_stmt|;
name|sc
operator|->
name|aac_bhandle
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|aac_regs_resource
argument_list|)
expr_stmt|;
block|}
comment|/* Read preferred settings */
name|sc
operator|->
name|aac_max_fib_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
expr_stmt|;
name|sc
operator|->
name|aac_max_sectors
operator|=
literal|128
expr_stmt|;
comment|/* 64KB */
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|AAC_FLAGS_SG_64BIT
condition|)
name|sc
operator|->
name|aac_sg_tablesize
operator|=
operator|(
name|AAC_FIB_DATASIZE
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|aac_blockwrite64
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|aac_sg_entry64
argument_list|)
expr_stmt|;
else|else
name|sc
operator|->
name|aac_sg_tablesize
operator|=
operator|(
name|AAC_FIB_DATASIZE
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|aac_blockwrite
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|aac_sg_entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aac_sync_command
argument_list|(
name|sc
argument_list|,
name|AAC_MONKER_GETCOMMPREF
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|options
operator|=
name|AAC_GET_MAILBOX
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|aac_max_fib_size
operator|=
operator|(
name|options
operator|&
literal|0xFFFF
operator|)
expr_stmt|;
name|sc
operator|->
name|aac_max_sectors
operator|=
operator|(
name|options
operator|>>
literal|16
operator|)
operator|<<
literal|1
expr_stmt|;
name|options
operator|=
name|AAC_GET_MAILBOX
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|->
name|aac_sg_tablesize
operator|=
operator|(
name|options
operator|>>
literal|16
operator|)
expr_stmt|;
name|options
operator|=
name|AAC_GET_MAILBOX
argument_list|(
name|sc
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|sc
operator|->
name|aac_max_fibs
operator|=
operator|(
name|options
operator|&
literal|0xFFFF
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|aac_max_fib_size
operator|>
name|PAGE_SIZE
condition|)
name|sc
operator|->
name|aac_max_fib_size
operator|=
name|PAGE_SIZE
expr_stmt|;
name|sc
operator|->
name|aac_max_fibs_alloc
operator|=
name|PAGE_SIZE
operator|/
name|sc
operator|->
name|aac_max_fib_size
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aac_init
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|aac_adapter_init
modifier|*
name|ip
decl_stmt|;
name|time_t
name|then
decl_stmt|;
name|u_int32_t
name|code
decl_stmt|,
name|qoffset
decl_stmt|;
name|int
name|error
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * First wait for the adapter to come ready. 	 */
name|then
operator|=
name|time_uptime
expr_stmt|;
do|do
block|{
name|code
operator|=
name|AAC_GET_FWSTATUS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|&
name|AAC_SELF_TEST_FAILED
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"FATAL: selftest failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|code
operator|&
name|AAC_KERNEL_PANIC
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"FATAL: controller kernel panic\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|time_uptime
operator|>
operator|(
name|then
operator|+
name|AAC_BOOT_TIMEOUT
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"FATAL: controller not coming ready, "
literal|"status %x\n"
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
do|while
condition|(
operator|!
operator|(
name|code
operator|&
name|AAC_UP_AND_RUNNING
operator|)
condition|)
do|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
comment|/* 	 * Create DMA tag for mapping buffers into controller-addressable space. 	 */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|aac_parent_dmat
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
operator|(
name|sc
operator|->
name|flags
operator|&
name|AAC_FLAGS_SG_64BIT
operator|)
condition|?
name|BUS_SPACE_MAXADDR
else|:
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|MAXBSIZE
argument_list|,
comment|/* maxsize */
name|sc
operator|->
name|aac_sg_tablesize
argument_list|,
comment|/* nsegments */
name|MAXBSIZE
argument_list|,
comment|/* maxsegsize */
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/* flags */
name|busdma_lock_mutex
argument_list|,
comment|/* lockfunc */
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|,
comment|/* lockfuncarg */
operator|&
name|sc
operator|->
name|aac_buffer_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"can't allocate buffer DMA tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Create DMA tag for mapping FIBs into controller-addressable space.. 	 */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|aac_parent_dmat
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
operator|(
name|sc
operator|->
name|flags
operator|&
name|AAC_FLAGS_4GB_WINDOW
operator|)
condition|?
name|BUS_SPACE_MAXADDR_32BIT
else|:
literal|0x7fffffff
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|sc
operator|->
name|aac_max_fibs_alloc
operator|*
name|sc
operator|->
name|aac_max_fib_size
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|sc
operator|->
name|aac_max_fibs_alloc
operator|*
name|sc
operator|->
name|aac_max_fib_size
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* No locking needed */
operator|&
name|sc
operator|->
name|aac_fib_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"can't allocate FIB DMA tag\n"
argument_list|)
expr_stmt|;
empty_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Create DMA tag for the common structure and allocate it. 	 */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|aac_parent_dmat
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
operator|(
name|sc
operator|->
name|flags
operator|&
name|AAC_FLAGS_4GB_WINDOW
operator|)
condition|?
name|BUS_SPACE_MAXADDR_32BIT
else|:
literal|0x7fffffff
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
literal|8192
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|aac_common
argument_list|)
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* No locking needed */
operator|&
name|sc
operator|->
name|aac_common_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"can't allocate common structure DMA tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|aac_common_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|aac_common
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|aac_common_dmamap
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"can't allocate common structure\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Work around a bug in the 2120 and 2200 that cannot DMA commands 	 * below address 8192 in physical memory. 	 * XXX If the padding is not needed, can it be put to use instead 	 * of ignored? 	 */
operator|(
name|void
operator|)
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|aac_common_dmat
argument_list|,
name|sc
operator|->
name|aac_common_dmamap
argument_list|,
name|sc
operator|->
name|aac_common
argument_list|,
literal|8192
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|sc
operator|->
name|aac_common
argument_list|)
argument_list|,
name|aac_common_map
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|aac_common_busaddr
operator|<
literal|8192
condition|)
block|{
name|sc
operator|->
name|aac_common
operator|=
operator|(
expr|struct
name|aac_common
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|sc
operator|->
name|aac_common
operator|+
literal|8192
operator|)
expr_stmt|;
name|sc
operator|->
name|aac_common_busaddr
operator|+=
literal|8192
expr_stmt|;
block|}
name|bzero
argument_list|(
name|sc
operator|->
name|aac_common
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
operator|->
name|aac_common
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allocate some FIBs and associated command structs */
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|aac_fibmap_tqh
argument_list|)
expr_stmt|;
name|sc
operator|->
name|aac_commands
operator|=
name|malloc
argument_list|(
name|sc
operator|->
name|aac_max_fibs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|aac_command
argument_list|)
argument_list|,
name|M_AACBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|total_fibs
operator|<
name|AAC_PREALLOCATE_FIBS
condition|)
block|{
if|if
condition|(
name|aac_alloc_commands
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|sc
operator|->
name|total_fibs
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Fill in the init structure.  This tells the adapter about the 	 * physical location of various important shared data structures. 	 */
name|ip
operator|=
operator|&
name|sc
operator|->
name|aac_common
operator|->
name|ac_init
expr_stmt|;
name|ip
operator|->
name|InitStructRevision
operator|=
name|AAC_INIT_STRUCT_REVISION
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|aac_max_fib_size
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
condition|)
block|{
name|ip
operator|->
name|InitStructRevision
operator|=
name|AAC_INIT_STRUCT_REVISION_4
expr_stmt|;
name|sc
operator|->
name|flags
operator||=
name|AAC_FLAGS_RAW_IO
expr_stmt|;
block|}
name|ip
operator|->
name|MiniPortRevision
operator|=
name|AAC_INIT_STRUCT_MINIPORT_REVISION
expr_stmt|;
name|ip
operator|->
name|AdapterFibsPhysicalAddress
operator|=
name|sc
operator|->
name|aac_common_busaddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|aac_common
argument_list|,
name|ac_fibs
argument_list|)
expr_stmt|;
name|ip
operator|->
name|AdapterFibsVirtualAddress
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|AdapterFibsSize
operator|=
name|AAC_ADAPTER_FIBS
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
expr_stmt|;
name|ip
operator|->
name|AdapterFibAlign
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
expr_stmt|;
name|ip
operator|->
name|PrintfBufferAddress
operator|=
name|sc
operator|->
name|aac_common_busaddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|aac_common
argument_list|,
name|ac_printf
argument_list|)
expr_stmt|;
name|ip
operator|->
name|PrintfBufferSize
operator|=
name|AAC_PRINTF_BUFSIZE
expr_stmt|;
comment|/* 	 * The adapter assumes that pages are 4K in size, except on some  	 * broken firmware versions that do the page->byte conversion twice, 	 * therefore 'assuming' that this value is in 16MB units (2^24). 	 * Round up since the granularity is so high. 	 */
name|ip
operator|->
name|HostPhysMemPages
operator|=
name|ctob
argument_list|(
name|physmem
argument_list|)
operator|/
name|AAC_PAGE_SIZE
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|AAC_FLAGS_BROKEN_MEMMAP
condition|)
block|{
name|ip
operator|->
name|HostPhysMemPages
operator|=
operator|(
name|ip
operator|->
name|HostPhysMemPages
operator|+
name|AAC_PAGE_SIZE
operator|)
operator|/
name|AAC_PAGE_SIZE
expr_stmt|;
block|}
name|ip
operator|->
name|HostElapsedSeconds
operator|=
name|time_uptime
expr_stmt|;
comment|/* reset later if invalid */
name|ip
operator|->
name|InitFlags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|AAC_FLAGS_NEW_COMM
condition|)
block|{
name|ip
operator|->
name|InitFlags
operator|=
name|INITFLAGS_NEW_COMM_SUPPORTED
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"New comm. interface enabled\n"
argument_list|)
expr_stmt|;
block|}
name|ip
operator|->
name|MaxIoCommands
operator|=
name|sc
operator|->
name|aac_max_fibs
expr_stmt|;
name|ip
operator|->
name|MaxIoSize
operator|=
name|sc
operator|->
name|aac_max_sectors
operator|<<
literal|9
expr_stmt|;
name|ip
operator|->
name|MaxFibSize
operator|=
name|sc
operator|->
name|aac_max_fib_size
expr_stmt|;
comment|/* 	 * Initialise FIB queues.  Note that it appears that the layout of the 	 * indexes and the segmentation of the entries may be mandated by the 	 * adapter, which is only told about the base of the queue index fields. 	 * 	 * The initial values of the indices are assumed to inform the adapter 	 * of the sizes of the respective queues, and theoretically it could 	 * work out the entire layout of the queue structures from this.  We 	 * take the easy route and just lay this area out like everyone else 	 * does. 	 * 	 * The Linux driver uses a much more complex scheme whereby several 	 * header records are kept for each queue.  We use a couple of generic 	 * list manipulation functions which 'know' the size of each list by 	 * virtue of a table. 	 */
name|qoffset
operator|=
name|offsetof
argument_list|(
expr|struct
name|aac_common
argument_list|,
name|ac_qbuf
argument_list|)
operator|+
name|AAC_QUEUE_ALIGN
expr_stmt|;
name|qoffset
operator|&=
operator|~
operator|(
name|AAC_QUEUE_ALIGN
operator|-
literal|1
operator|)
expr_stmt|;
name|sc
operator|->
name|aac_queues
operator|=
operator|(
expr|struct
name|aac_queue_table
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|sc
operator|->
name|aac_common
operator|+
name|qoffset
operator|)
expr_stmt|;
name|ip
operator|->
name|CommHeaderAddress
operator|=
name|sc
operator|->
name|aac_common_busaddr
operator|+
name|qoffset
expr_stmt|;
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|AAC_HOST_NORM_CMD_QUEUE
index|]
index|[
name|AAC_PRODUCER_INDEX
index|]
operator|=
name|AAC_HOST_NORM_CMD_ENTRIES
expr_stmt|;
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|AAC_HOST_NORM_CMD_QUEUE
index|]
index|[
name|AAC_CONSUMER_INDEX
index|]
operator|=
name|AAC_HOST_NORM_CMD_ENTRIES
expr_stmt|;
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|AAC_HOST_HIGH_CMD_QUEUE
index|]
index|[
name|AAC_PRODUCER_INDEX
index|]
operator|=
name|AAC_HOST_HIGH_CMD_ENTRIES
expr_stmt|;
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|AAC_HOST_HIGH_CMD_QUEUE
index|]
index|[
name|AAC_CONSUMER_INDEX
index|]
operator|=
name|AAC_HOST_HIGH_CMD_ENTRIES
expr_stmt|;
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|AAC_ADAP_NORM_CMD_QUEUE
index|]
index|[
name|AAC_PRODUCER_INDEX
index|]
operator|=
name|AAC_ADAP_NORM_CMD_ENTRIES
expr_stmt|;
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|AAC_ADAP_NORM_CMD_QUEUE
index|]
index|[
name|AAC_CONSUMER_INDEX
index|]
operator|=
name|AAC_ADAP_NORM_CMD_ENTRIES
expr_stmt|;
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|AAC_ADAP_HIGH_CMD_QUEUE
index|]
index|[
name|AAC_PRODUCER_INDEX
index|]
operator|=
name|AAC_ADAP_HIGH_CMD_ENTRIES
expr_stmt|;
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|AAC_ADAP_HIGH_CMD_QUEUE
index|]
index|[
name|AAC_CONSUMER_INDEX
index|]
operator|=
name|AAC_ADAP_HIGH_CMD_ENTRIES
expr_stmt|;
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|AAC_HOST_NORM_RESP_QUEUE
index|]
index|[
name|AAC_PRODUCER_INDEX
index|]
operator|=
name|AAC_HOST_NORM_RESP_ENTRIES
expr_stmt|;
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|AAC_HOST_NORM_RESP_QUEUE
index|]
index|[
name|AAC_CONSUMER_INDEX
index|]
operator|=
name|AAC_HOST_NORM_RESP_ENTRIES
expr_stmt|;
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|AAC_HOST_HIGH_RESP_QUEUE
index|]
index|[
name|AAC_PRODUCER_INDEX
index|]
operator|=
name|AAC_HOST_HIGH_RESP_ENTRIES
expr_stmt|;
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|AAC_HOST_HIGH_RESP_QUEUE
index|]
index|[
name|AAC_CONSUMER_INDEX
index|]
operator|=
name|AAC_HOST_HIGH_RESP_ENTRIES
expr_stmt|;
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|AAC_ADAP_NORM_RESP_QUEUE
index|]
index|[
name|AAC_PRODUCER_INDEX
index|]
operator|=
name|AAC_ADAP_NORM_RESP_ENTRIES
expr_stmt|;
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|AAC_ADAP_NORM_RESP_QUEUE
index|]
index|[
name|AAC_CONSUMER_INDEX
index|]
operator|=
name|AAC_ADAP_NORM_RESP_ENTRIES
expr_stmt|;
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|AAC_ADAP_HIGH_RESP_QUEUE
index|]
index|[
name|AAC_PRODUCER_INDEX
index|]
operator|=
name|AAC_ADAP_HIGH_RESP_ENTRIES
expr_stmt|;
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|AAC_ADAP_HIGH_RESP_QUEUE
index|]
index|[
name|AAC_CONSUMER_INDEX
index|]
operator|=
name|AAC_ADAP_HIGH_RESP_ENTRIES
expr_stmt|;
name|sc
operator|->
name|aac_qentries
index|[
name|AAC_HOST_NORM_CMD_QUEUE
index|]
operator|=
operator|&
name|sc
operator|->
name|aac_queues
operator|->
name|qt_HostNormCmdQueue
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|aac_qentries
index|[
name|AAC_HOST_HIGH_CMD_QUEUE
index|]
operator|=
operator|&
name|sc
operator|->
name|aac_queues
operator|->
name|qt_HostHighCmdQueue
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|aac_qentries
index|[
name|AAC_ADAP_NORM_CMD_QUEUE
index|]
operator|=
operator|&
name|sc
operator|->
name|aac_queues
operator|->
name|qt_AdapNormCmdQueue
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|aac_qentries
index|[
name|AAC_ADAP_HIGH_CMD_QUEUE
index|]
operator|=
operator|&
name|sc
operator|->
name|aac_queues
operator|->
name|qt_AdapHighCmdQueue
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|aac_qentries
index|[
name|AAC_HOST_NORM_RESP_QUEUE
index|]
operator|=
operator|&
name|sc
operator|->
name|aac_queues
operator|->
name|qt_HostNormRespQueue
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|aac_qentries
index|[
name|AAC_HOST_HIGH_RESP_QUEUE
index|]
operator|=
operator|&
name|sc
operator|->
name|aac_queues
operator|->
name|qt_HostHighRespQueue
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|aac_qentries
index|[
name|AAC_ADAP_NORM_RESP_QUEUE
index|]
operator|=
operator|&
name|sc
operator|->
name|aac_queues
operator|->
name|qt_AdapNormRespQueue
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|aac_qentries
index|[
name|AAC_ADAP_HIGH_RESP_QUEUE
index|]
operator|=
operator|&
name|sc
operator|->
name|aac_queues
operator|->
name|qt_AdapHighRespQueue
index|[
literal|0
index|]
expr_stmt|;
comment|/* 	 * Do controller-type-specific initialisation 	 */
switch|switch
condition|(
name|sc
operator|->
name|aac_hwif
condition|)
block|{
case|case
name|AAC_HWIF_I960RX
case|:
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RX_ODBR
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|AAC_HWIF_RKT
case|:
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RKT_ODBR
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* 	 * Give the init structure to the controller. 	 */
if|if
condition|(
name|aac_sync_command
argument_list|(
name|sc
argument_list|,
name|AAC_MONKER_INITSTRUCT
argument_list|,
name|sc
operator|->
name|aac_common_busaddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|aac_common
argument_list|,
name|ac_init
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"error establishing init structure\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
name|out
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send a synchronous command to the controller and wait for a result.  * Indicate if the controller completed the command with an error status.  */
end_comment

begin_function
specifier|static
name|int
name|aac_sync_command
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|command
parameter_list|,
name|u_int32_t
name|arg0
parameter_list|,
name|u_int32_t
name|arg1
parameter_list|,
name|u_int32_t
name|arg2
parameter_list|,
name|u_int32_t
name|arg3
parameter_list|,
name|u_int32_t
modifier|*
name|sp
parameter_list|)
block|{
name|time_t
name|then
decl_stmt|;
name|u_int32_t
name|status
decl_stmt|;
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
comment|/* populate the mailbox */
name|AAC_SET_MAILBOX
argument_list|(
name|sc
argument_list|,
name|command
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
comment|/* ensure the sync command doorbell flag is cleared */
name|AAC_CLEAR_ISTATUS
argument_list|(
name|sc
argument_list|,
name|AAC_DB_SYNC_COMMAND
argument_list|)
expr_stmt|;
comment|/* then set it to signal the adapter */
name|AAC_QNOTIFY
argument_list|(
name|sc
argument_list|,
name|AAC_DB_SYNC_COMMAND
argument_list|)
expr_stmt|;
comment|/* spin waiting for the command to complete */
name|then
operator|=
name|time_uptime
expr_stmt|;
do|do
block|{
if|if
condition|(
name|time_uptime
operator|>
operator|(
name|then
operator|+
name|AAC_IMMEDIATE_TIMEOUT
operator|)
condition|)
block|{
name|debug
argument_list|(
literal|1
argument_list|,
literal|"timed out"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
do|while
condition|(
operator|!
operator|(
name|AAC_GET_ISTATUS
argument_list|(
name|sc
argument_list|)
operator|&
name|AAC_DB_SYNC_COMMAND
operator|)
condition|)
do|;
comment|/* clear the completion flag */
name|AAC_CLEAR_ISTATUS
argument_list|(
name|sc
argument_list|,
name|AAC_DB_SYNC_COMMAND
argument_list|)
expr_stmt|;
comment|/* get the command status */
name|status
operator|=
name|AAC_GET_MAILBOX
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|!=
name|NULL
condition|)
operator|*
name|sp
operator|=
name|status
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|AAC_SRB_STS_SUCCESS
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|aac_sync_fib
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|command
parameter_list|,
name|u_int32_t
name|xferstate
parameter_list|,
name|struct
name|aac_fib
modifier|*
name|fib
parameter_list|,
name|u_int16_t
name|datasize
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|datasize
operator|>
name|AAC_FIB_DATASIZE
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Set up the sync FIB 	 */
name|fib
operator|->
name|Header
operator|.
name|XferState
operator|=
name|AAC_FIBSTATE_HOSTOWNED
operator||
name|AAC_FIBSTATE_INITIALISED
operator||
name|AAC_FIBSTATE_EMPTY
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|XferState
operator||=
name|xferstate
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|Command
operator|=
name|command
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|StructType
operator|=
name|AAC_FIBTYPE_TFIB
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|Size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
operator|+
name|datasize
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|SenderSize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|SenderFibAddress
operator|=
literal|0
expr_stmt|;
comment|/* Not needed */
name|fib
operator|->
name|Header
operator|.
name|ReceiverFibAddress
operator|=
name|sc
operator|->
name|aac_common_busaddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|aac_common
argument_list|,
name|ac_sync_fib
argument_list|)
expr_stmt|;
comment|/* 	 * Give the FIB to the controller, wait for a response. 	 */
if|if
condition|(
name|aac_sync_command
argument_list|(
name|sc
argument_list|,
name|AAC_MONKER_SYNCFIB
argument_list|,
name|fib
operator|->
name|Header
operator|.
name|ReceiverFibAddress
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|debug
argument_list|(
literal|2
argument_list|,
literal|"IO error"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Adapter-space FIB queue manipulation  *  * Note that the queue implementation here is a little funky; neither the PI or  * CI will ever be zero.  This behaviour is a controller feature.  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|int
name|size
decl_stmt|;
name|int
name|notify
decl_stmt|;
block|}
name|aac_qinfo
index|[]
init|=
block|{
block|{
name|AAC_HOST_NORM_CMD_ENTRIES
block|,
name|AAC_DB_COMMAND_NOT_FULL
block|}
block|,
block|{
name|AAC_HOST_HIGH_CMD_ENTRIES
block|,
literal|0
block|}
block|,
block|{
name|AAC_ADAP_NORM_CMD_ENTRIES
block|,
name|AAC_DB_COMMAND_READY
block|}
block|,
block|{
name|AAC_ADAP_HIGH_CMD_ENTRIES
block|,
literal|0
block|}
block|,
block|{
name|AAC_HOST_NORM_RESP_ENTRIES
block|,
name|AAC_DB_RESPONSE_NOT_FULL
block|}
block|,
block|{
name|AAC_HOST_HIGH_RESP_ENTRIES
block|,
literal|0
block|}
block|,
block|{
name|AAC_ADAP_NORM_RESP_ENTRIES
block|,
name|AAC_DB_RESPONSE_READY
block|}
block|,
block|{
name|AAC_ADAP_HIGH_RESP_ENTRIES
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_comment
comment|/*  * Atomically insert an entry into the nominated queue, returns 0 on success or  * EBUSY if the queue is full.  *  * Note: it would be more efficient to defer notifying the controller in  *	 the case where we may be inserting several entries in rapid succession,  *	 but implementing this usefully may be difficult (it would involve a  *	 separate queue/notify interface).  */
end_comment

begin_function
specifier|static
name|int
name|aac_enqueue_fib
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|queue
parameter_list|,
name|struct
name|aac_command
modifier|*
name|cm
parameter_list|)
block|{
name|u_int32_t
name|pi
decl_stmt|,
name|ci
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_int32_t
name|fib_size
decl_stmt|;
name|u_int32_t
name|fib_addr
decl_stmt|;
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|fib_size
operator|=
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|Size
expr_stmt|;
name|fib_addr
operator|=
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|ReceiverFibAddress
expr_stmt|;
comment|/* get the producer/consumer indices */
name|pi
operator|=
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|queue
index|]
index|[
name|AAC_PRODUCER_INDEX
index|]
expr_stmt|;
name|ci
operator|=
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|queue
index|]
index|[
name|AAC_CONSUMER_INDEX
index|]
expr_stmt|;
comment|/* wrap the queue? */
if|if
condition|(
name|pi
operator|>=
name|aac_qinfo
index|[
name|queue
index|]
operator|.
name|size
condition|)
name|pi
operator|=
literal|0
expr_stmt|;
comment|/* check for queue full */
if|if
condition|(
operator|(
name|pi
operator|+
literal|1
operator|)
operator|==
name|ci
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * To avoid a race with its completion interrupt, place this command on 	 * the busy queue prior to advertising it to the controller. 	 */
name|aac_enqueue_busy
argument_list|(
name|cm
argument_list|)
expr_stmt|;
comment|/* populate queue entry */
operator|(
name|sc
operator|->
name|aac_qentries
index|[
name|queue
index|]
operator|+
name|pi
operator|)
operator|->
name|aq_fib_size
operator|=
name|fib_size
expr_stmt|;
operator|(
name|sc
operator|->
name|aac_qentries
index|[
name|queue
index|]
operator|+
name|pi
operator|)
operator|->
name|aq_fib_addr
operator|=
name|fib_addr
expr_stmt|;
comment|/* update producer index */
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|queue
index|]
index|[
name|AAC_PRODUCER_INDEX
index|]
operator|=
name|pi
operator|+
literal|1
expr_stmt|;
comment|/* notify the adapter if we know how */
if|if
condition|(
name|aac_qinfo
index|[
name|queue
index|]
operator|.
name|notify
operator|!=
literal|0
condition|)
name|AAC_QNOTIFY
argument_list|(
name|sc
argument_list|,
name|aac_qinfo
index|[
name|queue
index|]
operator|.
name|notify
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|out
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Atomically remove one entry from the nominated queue, returns 0 on  * success or ENOENT if the queue is empty.  */
end_comment

begin_function
specifier|static
name|int
name|aac_dequeue_fib
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|queue
parameter_list|,
name|u_int32_t
modifier|*
name|fib_size
parameter_list|,
name|struct
name|aac_fib
modifier|*
modifier|*
name|fib_addr
parameter_list|)
block|{
name|u_int32_t
name|pi
decl_stmt|,
name|ci
decl_stmt|;
name|u_int32_t
name|fib_index
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|notify
decl_stmt|;
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
comment|/* get the producer/consumer indices */
name|pi
operator|=
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|queue
index|]
index|[
name|AAC_PRODUCER_INDEX
index|]
expr_stmt|;
name|ci
operator|=
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|queue
index|]
index|[
name|AAC_CONSUMER_INDEX
index|]
expr_stmt|;
comment|/* check for queue empty */
if|if
condition|(
name|ci
operator|==
name|pi
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* wrap the pi so the following test works */
if|if
condition|(
name|pi
operator|>=
name|aac_qinfo
index|[
name|queue
index|]
operator|.
name|size
condition|)
name|pi
operator|=
literal|0
expr_stmt|;
name|notify
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ci
operator|==
name|pi
operator|+
literal|1
condition|)
name|notify
operator|++
expr_stmt|;
comment|/* wrap the queue? */
if|if
condition|(
name|ci
operator|>=
name|aac_qinfo
index|[
name|queue
index|]
operator|.
name|size
condition|)
name|ci
operator|=
literal|0
expr_stmt|;
comment|/* fetch the entry */
operator|*
name|fib_size
operator|=
operator|(
name|sc
operator|->
name|aac_qentries
index|[
name|queue
index|]
operator|+
name|ci
operator|)
operator|->
name|aq_fib_size
expr_stmt|;
switch|switch
condition|(
name|queue
condition|)
block|{
case|case
name|AAC_HOST_NORM_CMD_QUEUE
case|:
case|case
name|AAC_HOST_HIGH_CMD_QUEUE
case|:
comment|/* 		 * The aq_fib_addr is only 32 bits wide so it can't be counted 		 * on to hold an address.  For AIF's, the adapter assumes 		 * that it's giving us an address into the array of AIF fibs. 		 * Therefore, we have to convert it to an index. 		 */
name|fib_index
operator|=
operator|(
name|sc
operator|->
name|aac_qentries
index|[
name|queue
index|]
operator|+
name|ci
operator|)
operator|->
name|aq_fib_addr
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
expr_stmt|;
operator|*
name|fib_addr
operator|=
operator|&
name|sc
operator|->
name|aac_common
operator|->
name|ac_fibs
index|[
name|fib_index
index|]
expr_stmt|;
break|break;
case|case
name|AAC_HOST_NORM_RESP_QUEUE
case|:
case|case
name|AAC_HOST_HIGH_RESP_QUEUE
case|:
block|{
name|struct
name|aac_command
modifier|*
name|cm
decl_stmt|;
comment|/* 		 * As above, an index is used instead of an actual address. 		 * Gotta shift the index to account for the fast response 		 * bit.  No other correction is needed since this value was 		 * originally provided by the driver via the SenderFibAddress 		 * field. 		 */
name|fib_index
operator|=
operator|(
name|sc
operator|->
name|aac_qentries
index|[
name|queue
index|]
operator|+
name|ci
operator|)
operator|->
name|aq_fib_addr
expr_stmt|;
name|cm
operator|=
name|sc
operator|->
name|aac_commands
operator|+
operator|(
name|fib_index
operator|>>
literal|2
operator|)
expr_stmt|;
operator|*
name|fib_addr
operator|=
name|cm
operator|->
name|cm_fib
expr_stmt|;
comment|/* 		 * Is this a fast response? If it is, update the fib fields in 		 * local memory since the whole fib isn't DMA'd back up. 		 */
if|if
condition|(
name|fib_index
operator|&
literal|0x01
condition|)
block|{
operator|(
operator|*
name|fib_addr
operator|)
operator|->
name|Header
operator|.
name|XferState
operator||=
name|AAC_FIBSTATE_DONEADAP
expr_stmt|;
operator|*
operator|(
operator|(
name|u_int32_t
operator|*
operator|)
operator|(
operator|(
operator|*
name|fib_addr
operator|)
operator|->
name|data
operator|)
operator|)
operator|=
name|AAC_ERROR_NORMAL
expr_stmt|;
block|}
break|break;
block|}
default|default:
name|panic
argument_list|(
literal|"Invalid queue in aac_dequeue_fib()"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* update consumer index */
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|queue
index|]
index|[
name|AAC_CONSUMER_INDEX
index|]
operator|=
name|ci
operator|+
literal|1
expr_stmt|;
comment|/* if we have made the queue un-full, notify the adapter */
if|if
condition|(
name|notify
operator|&&
operator|(
name|aac_qinfo
index|[
name|queue
index|]
operator|.
name|notify
operator|!=
literal|0
operator|)
condition|)
name|AAC_QNOTIFY
argument_list|(
name|sc
argument_list|,
name|aac_qinfo
index|[
name|queue
index|]
operator|.
name|notify
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|out
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Put our response to an Adapter Initialed Fib on the response queue  */
end_comment

begin_function
specifier|static
name|int
name|aac_enqueue_response
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|queue
parameter_list|,
name|struct
name|aac_fib
modifier|*
name|fib
parameter_list|)
block|{
name|u_int32_t
name|pi
decl_stmt|,
name|ci
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_int32_t
name|fib_size
decl_stmt|;
name|u_int32_t
name|fib_addr
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Tell the adapter where the FIB is */
name|fib_size
operator|=
name|fib
operator|->
name|Header
operator|.
name|Size
expr_stmt|;
name|fib_addr
operator|=
name|fib
operator|->
name|Header
operator|.
name|SenderFibAddress
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|ReceiverFibAddress
operator|=
name|fib_addr
expr_stmt|;
comment|/* get the producer/consumer indices */
name|pi
operator|=
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|queue
index|]
index|[
name|AAC_PRODUCER_INDEX
index|]
expr_stmt|;
name|ci
operator|=
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|queue
index|]
index|[
name|AAC_CONSUMER_INDEX
index|]
expr_stmt|;
comment|/* wrap the queue? */
if|if
condition|(
name|pi
operator|>=
name|aac_qinfo
index|[
name|queue
index|]
operator|.
name|size
condition|)
name|pi
operator|=
literal|0
expr_stmt|;
comment|/* check for queue full */
if|if
condition|(
operator|(
name|pi
operator|+
literal|1
operator|)
operator|==
name|ci
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* populate queue entry */
operator|(
name|sc
operator|->
name|aac_qentries
index|[
name|queue
index|]
operator|+
name|pi
operator|)
operator|->
name|aq_fib_size
operator|=
name|fib_size
expr_stmt|;
operator|(
name|sc
operator|->
name|aac_qentries
index|[
name|queue
index|]
operator|+
name|pi
operator|)
operator|->
name|aq_fib_addr
operator|=
name|fib_addr
expr_stmt|;
comment|/* update producer index */
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|queue
index|]
index|[
name|AAC_PRODUCER_INDEX
index|]
operator|=
name|pi
operator|+
literal|1
expr_stmt|;
comment|/* notify the adapter if we know how */
if|if
condition|(
name|aac_qinfo
index|[
name|queue
index|]
operator|.
name|notify
operator|!=
literal|0
condition|)
name|AAC_QNOTIFY
argument_list|(
name|sc
argument_list|,
name|aac_qinfo
index|[
name|queue
index|]
operator|.
name|notify
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|out
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check for commands that have been outstanding for a suspiciously long time,  * and complain about them.  */
end_comment

begin_function
specifier|static
name|void
name|aac_timeout
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|aac_command
modifier|*
name|cm
decl_stmt|;
name|time_t
name|deadline
decl_stmt|;
name|int
name|timedout
decl_stmt|,
name|code
decl_stmt|;
comment|/* 	 * Traverse the busy command list, bitch about late commands once 	 * only. 	 */
name|timedout
operator|=
literal|0
expr_stmt|;
name|deadline
operator|=
name|time_uptime
operator|-
name|AAC_CMD_TIMEOUT
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|cm
argument_list|,
argument|&sc->aac_busy
argument_list|,
argument|cm_link
argument_list|)
block|{
if|if
condition|(
operator|(
name|cm
operator|->
name|cm_timestamp
operator|<
name|deadline
operator|)
comment|/*&& !(cm->cm_flags& AAC_CMD_TIMEDOUT) */
condition|)
block|{
name|cm
operator|->
name|cm_flags
operator||=
name|AAC_CMD_TIMEDOUT
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"COMMAND %p TIMEOUT AFTER %d SECONDS\n"
argument_list|,
name|cm
argument_list|,
call|(
name|int
call|)
argument_list|(
name|time_uptime
operator|-
name|cm
operator|->
name|cm_timestamp
argument_list|)
argument_list|)
expr_stmt|;
name|AAC_PRINT_FIB
argument_list|(
name|sc
argument_list|,
name|cm
operator|->
name|cm_fib
argument_list|)
expr_stmt|;
name|timedout
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|timedout
condition|)
block|{
name|code
operator|=
name|AAC_GET_FWSTATUS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|AAC_UP_AND_RUNNING
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"WARNING! Controller is no "
literal|"longer running! code= 0x%x\n"
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * Interface Function Vectors  */
end_comment

begin_comment
comment|/*  * Read the current firmware status word.  */
end_comment

begin_function
specifier|static
name|int
name|aac_sa_get_fwstatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
return|return
operator|(
name|AAC_GETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SA_FWSTATUS
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aac_rx_get_fwstatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
return|return
operator|(
name|AAC_GETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RX_FWSTATUS
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aac_fa_get_fwstatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|val
operator|=
name|AAC_GETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_FA_FWSTATUS
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aac_rkt_get_fwstatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
return|return
operator|(
name|AAC_GETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RKT_FWSTATUS
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Notify the controller of a change in a given queue  */
end_comment

begin_function
specifier|static
name|void
name|aac_sa_qnotify
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|qbit
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|AAC_SETREG2
argument_list|(
name|sc
argument_list|,
name|AAC_SA_DOORBELL1_SET
argument_list|,
name|qbit
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|aac_rx_qnotify
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|qbit
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RX_IDBR
argument_list|,
name|qbit
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|aac_fa_qnotify
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|qbit
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|AAC_SETREG2
argument_list|(
name|sc
argument_list|,
name|AAC_FA_DOORBELL1
argument_list|,
name|qbit
argument_list|)
expr_stmt|;
name|AAC_FA_HACK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|aac_rkt_qnotify
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|qbit
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RKT_IDBR
argument_list|,
name|qbit
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get the interrupt reason bits  */
end_comment

begin_function
specifier|static
name|int
name|aac_sa_get_istatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
return|return
operator|(
name|AAC_GETREG2
argument_list|(
name|sc
argument_list|,
name|AAC_SA_DOORBELL0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aac_rx_get_istatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
return|return
operator|(
name|AAC_GETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RX_ODBR
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aac_fa_get_istatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|val
operator|=
name|AAC_GETREG2
argument_list|(
name|sc
argument_list|,
name|AAC_FA_DOORBELL0
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aac_rkt_get_istatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
return|return
operator|(
name|AAC_GETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RKT_ODBR
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Clear some interrupt reason bits  */
end_comment

begin_function
specifier|static
name|void
name|aac_sa_clear_istatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|mask
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|AAC_SETREG2
argument_list|(
name|sc
argument_list|,
name|AAC_SA_DOORBELL0_CLEAR
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|aac_rx_clear_istatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|mask
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RX_ODBR
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|aac_fa_clear_istatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|mask
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|AAC_SETREG2
argument_list|(
name|sc
argument_list|,
name|AAC_FA_DOORBELL0_CLEAR
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|AAC_FA_HACK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|aac_rkt_clear_istatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|mask
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RKT_ODBR
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Populate the mailbox and set the command word  */
end_comment

begin_function
specifier|static
name|void
name|aac_sa_set_mailbox
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|command
parameter_list|,
name|u_int32_t
name|arg0
parameter_list|,
name|u_int32_t
name|arg1
parameter_list|,
name|u_int32_t
name|arg2
parameter_list|,
name|u_int32_t
name|arg3
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SA_MAILBOX
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SA_MAILBOX
operator|+
literal|4
argument_list|,
name|arg0
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SA_MAILBOX
operator|+
literal|8
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SA_MAILBOX
operator|+
literal|12
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SA_MAILBOX
operator|+
literal|16
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|aac_rx_set_mailbox
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|command
parameter_list|,
name|u_int32_t
name|arg0
parameter_list|,
name|u_int32_t
name|arg1
parameter_list|,
name|u_int32_t
name|arg2
parameter_list|,
name|u_int32_t
name|arg3
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RX_MAILBOX
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RX_MAILBOX
operator|+
literal|4
argument_list|,
name|arg0
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RX_MAILBOX
operator|+
literal|8
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RX_MAILBOX
operator|+
literal|12
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RX_MAILBOX
operator|+
literal|16
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|aac_fa_set_mailbox
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|command
parameter_list|,
name|u_int32_t
name|arg0
parameter_list|,
name|u_int32_t
name|arg1
parameter_list|,
name|u_int32_t
name|arg2
parameter_list|,
name|u_int32_t
name|arg3
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_FA_MAILBOX
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|AAC_FA_HACK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_FA_MAILBOX
operator|+
literal|4
argument_list|,
name|arg0
argument_list|)
expr_stmt|;
name|AAC_FA_HACK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_FA_MAILBOX
operator|+
literal|8
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
name|AAC_FA_HACK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_FA_MAILBOX
operator|+
literal|12
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|AAC_FA_HACK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_FA_MAILBOX
operator|+
literal|16
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
name|AAC_FA_HACK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|aac_rkt_set_mailbox
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|command
parameter_list|,
name|u_int32_t
name|arg0
parameter_list|,
name|u_int32_t
name|arg1
parameter_list|,
name|u_int32_t
name|arg2
parameter_list|,
name|u_int32_t
name|arg3
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RKT_MAILBOX
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RKT_MAILBOX
operator|+
literal|4
argument_list|,
name|arg0
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RKT_MAILBOX
operator|+
literal|8
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RKT_MAILBOX
operator|+
literal|12
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RKT_MAILBOX
operator|+
literal|16
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Fetch the immediate command status word  */
end_comment

begin_function
specifier|static
name|int
name|aac_sa_get_mailbox
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|mb
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|4
argument_list|)
expr_stmt|;
return|return
operator|(
name|AAC_GETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SA_MAILBOX
operator|+
operator|(
name|mb
operator|*
literal|4
operator|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aac_rx_get_mailbox
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|mb
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|4
argument_list|)
expr_stmt|;
return|return
operator|(
name|AAC_GETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RX_MAILBOX
operator|+
operator|(
name|mb
operator|*
literal|4
operator|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aac_fa_get_mailbox
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|mb
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
name|debug_called
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|val
operator|=
name|AAC_GETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_FA_MAILBOX
operator|+
operator|(
name|mb
operator|*
literal|4
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aac_rkt_get_mailbox
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|mb
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|4
argument_list|)
expr_stmt|;
return|return
operator|(
name|AAC_GETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RKT_MAILBOX
operator|+
operator|(
name|mb
operator|*
literal|4
operator|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set/clear interrupt masks  */
end_comment

begin_function
specifier|static
name|void
name|aac_sa_set_interrupts
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
name|debug
argument_list|(
literal|2
argument_list|,
literal|"%sable interrupts"
argument_list|,
name|enable
condition|?
literal|"en"
else|:
literal|"dis"
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
block|{
name|AAC_SETREG2
argument_list|(
operator|(
name|sc
operator|)
argument_list|,
name|AAC_SA_MASK0_CLEAR
argument_list|,
name|AAC_DB_INTERRUPTS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AAC_SETREG2
argument_list|(
operator|(
name|sc
operator|)
argument_list|,
name|AAC_SA_MASK0_SET
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|aac_rx_set_interrupts
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
name|debug
argument_list|(
literal|2
argument_list|,
literal|"%sable interrupts"
argument_list|,
name|enable
condition|?
literal|"en"
else|:
literal|"dis"
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|AAC_FLAGS_NEW_COMM
condition|)
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RX_OIMR
argument_list|,
operator|~
name|AAC_DB_INT_NEW_COMM
argument_list|)
expr_stmt|;
else|else
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RX_OIMR
argument_list|,
operator|~
name|AAC_DB_INTERRUPTS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RX_OIMR
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|aac_fa_set_interrupts
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
name|debug
argument_list|(
literal|2
argument_list|,
literal|"%sable interrupts"
argument_list|,
name|enable
condition|?
literal|"en"
else|:
literal|"dis"
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
block|{
name|AAC_SETREG2
argument_list|(
operator|(
name|sc
operator|)
argument_list|,
name|AAC_FA_MASK0_CLEAR
argument_list|,
name|AAC_DB_INTERRUPTS
argument_list|)
expr_stmt|;
name|AAC_FA_HACK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AAC_SETREG2
argument_list|(
operator|(
name|sc
operator|)
argument_list|,
name|AAC_FA_MASK0
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
name|AAC_FA_HACK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|aac_rkt_set_interrupts
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
name|debug
argument_list|(
literal|2
argument_list|,
literal|"%sable interrupts"
argument_list|,
name|enable
condition|?
literal|"en"
else|:
literal|"dis"
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|AAC_FLAGS_NEW_COMM
condition|)
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RKT_OIMR
argument_list|,
operator|~
name|AAC_DB_INT_NEW_COMM
argument_list|)
expr_stmt|;
else|else
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RKT_OIMR
argument_list|,
operator|~
name|AAC_DB_INTERRUPTS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RKT_OIMR
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * New comm. interface: Send command functions  */
end_comment

begin_function
specifier|static
name|int
name|aac_rx_send_command
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|aac_command
modifier|*
name|cm
parameter_list|)
block|{
name|u_int32_t
name|index
decl_stmt|,
name|device
decl_stmt|;
name|debug
argument_list|(
literal|2
argument_list|,
literal|"send command (new comm.)"
argument_list|)
expr_stmt|;
name|index
operator|=
name|AAC_GETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RX_IQUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
literal|0xffffffffL
condition|)
name|index
operator|=
name|AAC_GETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RX_IQUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
literal|0xffffffffL
condition|)
return|return
name|index
return|;
name|aac_enqueue_busy
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|device
operator|=
name|index
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|device
argument_list|,
call|(
name|u_int32_t
call|)
argument_list|(
name|cm
operator|->
name|cm_fibphys
operator|&
literal|0xffffffffUL
argument_list|)
argument_list|)
expr_stmt|;
name|device
operator|+=
literal|4
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|device
argument_list|,
call|(
name|u_int32_t
call|)
argument_list|(
name|cm
operator|->
name|cm_fibphys
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
name|device
operator|+=
literal|4
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|device
argument_list|,
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|Size
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RX_IQUE
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aac_rkt_send_command
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|aac_command
modifier|*
name|cm
parameter_list|)
block|{
name|u_int32_t
name|index
decl_stmt|,
name|device
decl_stmt|;
name|debug
argument_list|(
literal|2
argument_list|,
literal|"send command (new comm.)"
argument_list|)
expr_stmt|;
name|index
operator|=
name|AAC_GETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RKT_IQUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
literal|0xffffffffL
condition|)
name|index
operator|=
name|AAC_GETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RKT_IQUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
literal|0xffffffffL
condition|)
return|return
name|index
return|;
name|aac_enqueue_busy
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|device
operator|=
name|index
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|device
argument_list|,
call|(
name|u_int32_t
call|)
argument_list|(
name|cm
operator|->
name|cm_fibphys
operator|&
literal|0xffffffffUL
argument_list|)
argument_list|)
expr_stmt|;
name|device
operator|+=
literal|4
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|device
argument_list|,
call|(
name|u_int32_t
call|)
argument_list|(
name|cm
operator|->
name|cm_fibphys
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
name|device
operator|+=
literal|4
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|device
argument_list|,
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|Size
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RKT_IQUE
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * New comm. interface: get, set outbound queue index  */
end_comment

begin_function
specifier|static
name|int
name|aac_rx_get_outb_queue
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
return|return
operator|(
name|AAC_GETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RX_OQUE
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aac_rkt_get_outb_queue
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
return|return
operator|(
name|AAC_GETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RKT_OQUE
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|aac_rx_set_outb_queue
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RX_OQUE
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|aac_rkt_set_outb_queue
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RKT_OQUE
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Debugging and Diagnostics  */
end_comment

begin_comment
comment|/*  * Print some information about the controller.  */
end_comment

begin_function
specifier|static
name|void
name|aac_describe_controller
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|aac_fib
modifier|*
name|fib
decl_stmt|;
name|struct
name|aac_adapter_info
modifier|*
name|info
decl_stmt|;
name|char
modifier|*
name|adapter_type
init|=
literal|"Adaptec RAID controller"
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
name|aac_alloc_sync_fib
argument_list|(
name|sc
argument_list|,
operator|&
name|fib
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|supported_options
operator|&
name|AAC_SUPPORTED_SUPPLEMENT_ADAPTER_INFO
condition|)
block|{
name|fib
operator|->
name|data
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|aac_sync_fib
argument_list|(
name|sc
argument_list|,
name|RequestSupplementAdapterInfo
argument_list|,
literal|0
argument_list|,
name|fib
argument_list|,
literal|1
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"RequestSupplementAdapterInfo failed\n"
argument_list|)
expr_stmt|;
else|else
name|adapter_type
operator|=
operator|(
operator|(
expr|struct
name|aac_supplement_adapter_info
operator|*
operator|)
operator|&
name|fib
operator|->
name|data
index|[
literal|0
index|]
operator|)
operator|->
name|AdapterTypeText
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"%s, aac driver %d.%d.%d-%d\n"
argument_list|,
name|adapter_type
argument_list|,
name|AAC_DRIVER_VERSION
operator|>>
literal|24
argument_list|,
operator|(
name|AAC_DRIVER_VERSION
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
argument_list|,
name|AAC_DRIVER_VERSION
operator|&
literal|0xFF
argument_list|,
name|AAC_DRIVER_BUILD
argument_list|)
expr_stmt|;
name|fib
operator|->
name|data
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|aac_sync_fib
argument_list|(
name|sc
argument_list|,
name|RequestAdapterInfo
argument_list|,
literal|0
argument_list|,
name|fib
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"RequestAdapterInfo failed\n"
argument_list|)
expr_stmt|;
name|aac_release_sync_fib
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* save the kernel revision structure for later use */
name|info
operator|=
operator|(
expr|struct
name|aac_adapter_info
operator|*
operator|)
operator|&
name|fib
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|aac_revision
operator|=
name|info
operator|->
name|KernelRevision
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"%s %dMHz, %dMB memory "
literal|"(%dMB cache, %dMB execution), %s\n"
argument_list|,
name|aac_describe_code
argument_list|(
name|aac_cpu_variant
argument_list|,
name|info
operator|->
name|CpuVariant
argument_list|)
argument_list|,
name|info
operator|->
name|ClockSpeed
argument_list|,
name|info
operator|->
name|TotalMem
operator|/
operator|(
literal|1024
operator|*
literal|1024
operator|)
argument_list|,
name|info
operator|->
name|BufferMem
operator|/
operator|(
literal|1024
operator|*
literal|1024
operator|)
argument_list|,
name|info
operator|->
name|ExecutionMem
operator|/
operator|(
literal|1024
operator|*
literal|1024
operator|)
argument_list|,
name|aac_describe_code
argument_list|(
name|aac_battery_platform
argument_list|,
name|info
operator|->
name|batteryPlatform
argument_list|)
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"Kernel %d.%d-%d, Build %d, S/N %6X\n"
argument_list|,
name|info
operator|->
name|KernelRevision
operator|.
name|external
operator|.
name|comp
operator|.
name|major
argument_list|,
name|info
operator|->
name|KernelRevision
operator|.
name|external
operator|.
name|comp
operator|.
name|minor
argument_list|,
name|info
operator|->
name|KernelRevision
operator|.
name|external
operator|.
name|comp
operator|.
name|dash
argument_list|,
name|info
operator|->
name|KernelRevision
operator|.
name|buildNumber
argument_list|,
call|(
name|u_int32_t
call|)
argument_list|(
name|info
operator|->
name|SerialNumber
operator|&
literal|0xffffff
argument_list|)
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"Supported Options=%b\n"
argument_list|,
name|sc
operator|->
name|supported_options
argument_list|,
literal|"\20"
literal|"\1SNAPSHOT"
literal|"\2CLUSTERS"
literal|"\3WCACHE"
literal|"\4DATA64"
literal|"\5HOSTTIME"
literal|"\6RAID50"
literal|"\7WINDOW4GB"
literal|"\10SCSIUPGD"
literal|"\11SOFTERR"
literal|"\12NORECOND"
literal|"\13SGMAP64"
literal|"\14ALARM"
literal|"\15NONDASD"
literal|"\16SCSIMGT"
literal|"\17RAIDSCSI"
literal|"\21ADPTINFO"
literal|"\22NEWCOMM"
literal|"\23ARRAY64BIT"
literal|"\24HEATSENSOR"
argument_list|)
expr_stmt|;
block|}
name|aac_release_sync_fib
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Look up a text description of a numeric error code and return a pointer to  * same.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|aac_describe_code
parameter_list|(
name|struct
name|aac_code_lookup
modifier|*
name|table
parameter_list|,
name|u_int32_t
name|code
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|table
index|[
name|i
index|]
operator|.
name|string
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|table
index|[
name|i
index|]
operator|.
name|code
operator|==
name|code
condition|)
return|return
operator|(
name|table
index|[
name|i
index|]
operator|.
name|string
operator|)
return|;
return|return
operator|(
name|table
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|string
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Management Interface  */
end_comment

begin_function
specifier|static
name|int
name|aac_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|d_thread_t
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|sc
operator|->
name|aac_open_cnt
operator|++
expr_stmt|;
name|sc
operator|->
name|aac_state
operator||=
name|AAC_STATE_OPEN
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aac_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|d_thread_t
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|sc
operator|->
name|aac_open_cnt
operator|--
expr_stmt|;
comment|/* Mark this unit as no longer open  */
if|if
condition|(
name|sc
operator|->
name|aac_open_cnt
operator|==
literal|0
condition|)
name|sc
operator|->
name|aac_state
operator|&=
operator|~
name|AAC_STATE_OPEN
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aac_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|int
name|flag
parameter_list|,
name|d_thread_t
modifier|*
name|td
parameter_list|)
block|{
name|union
name|aac_statrequest
modifier|*
name|as
decl_stmt|;
name|struct
name|aac_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|as
operator|=
operator|(
expr|union
name|aac_statrequest
operator|*
operator|)
name|arg
expr_stmt|;
name|sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|AACIO_STATS
case|:
switch|switch
condition|(
name|as
operator|->
name|as_item
condition|)
block|{
case|case
name|AACQ_FREE
case|:
case|case
name|AACQ_BIO
case|:
case|case
name|AACQ_READY
case|:
case|case
name|AACQ_BUSY
case|:
name|bcopy
argument_list|(
operator|&
name|sc
operator|->
name|aac_qstat
index|[
name|as
operator|->
name|as_item
index|]
argument_list|,
operator|&
name|as
operator|->
name|as_qstat
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_qstat
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FSACTL_SENDFIB
case|:
name|arg
operator|=
operator|*
operator|(
name|caddr_t
operator|*
operator|)
name|arg
expr_stmt|;
case|case
name|FSACTL_LNX_SENDFIB
case|:
name|debug
argument_list|(
literal|1
argument_list|,
literal|"FSACTL_SENDFIB"
argument_list|)
expr_stmt|;
name|error
operator|=
name|aac_ioctl_sendfib
argument_list|(
name|sc
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|FSACTL_AIF_THREAD
case|:
case|case
name|FSACTL_LNX_AIF_THREAD
case|:
name|debug
argument_list|(
literal|1
argument_list|,
literal|"FSACTL_AIF_THREAD"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|FSACTL_OPEN_GET_ADAPTER_FIB
case|:
name|arg
operator|=
operator|*
operator|(
name|caddr_t
operator|*
operator|)
name|arg
expr_stmt|;
case|case
name|FSACTL_LNX_OPEN_GET_ADAPTER_FIB
case|:
name|debug
argument_list|(
literal|1
argument_list|,
literal|"FSACTL_OPEN_GET_ADAPTER_FIB"
argument_list|)
expr_stmt|;
name|error
operator|=
name|aac_open_aif
argument_list|(
name|sc
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|FSACTL_GET_NEXT_ADAPTER_FIB
case|:
name|arg
operator|=
operator|*
operator|(
name|caddr_t
operator|*
operator|)
name|arg
expr_stmt|;
case|case
name|FSACTL_LNX_GET_NEXT_ADAPTER_FIB
case|:
name|debug
argument_list|(
literal|1
argument_list|,
literal|"FSACTL_GET_NEXT_ADAPTER_FIB"
argument_list|)
expr_stmt|;
name|error
operator|=
name|aac_getnext_aif
argument_list|(
name|sc
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|FSACTL_CLOSE_GET_ADAPTER_FIB
case|:
name|arg
operator|=
operator|*
operator|(
name|caddr_t
operator|*
operator|)
name|arg
expr_stmt|;
case|case
name|FSACTL_LNX_CLOSE_GET_ADAPTER_FIB
case|:
name|debug
argument_list|(
literal|1
argument_list|,
literal|"FSACTL_CLOSE_GET_ADAPTER_FIB"
argument_list|)
expr_stmt|;
name|error
operator|=
name|aac_close_aif
argument_list|(
name|sc
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|FSACTL_MINIPORT_REV_CHECK
case|:
name|arg
operator|=
operator|*
operator|(
name|caddr_t
operator|*
operator|)
name|arg
expr_stmt|;
case|case
name|FSACTL_LNX_MINIPORT_REV_CHECK
case|:
name|debug
argument_list|(
literal|1
argument_list|,
literal|"FSACTL_MINIPORT_REV_CHECK"
argument_list|)
expr_stmt|;
name|error
operator|=
name|aac_rev_check
argument_list|(
name|sc
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|FSACTL_QUERY_DISK
case|:
name|arg
operator|=
operator|*
operator|(
name|caddr_t
operator|*
operator|)
name|arg
expr_stmt|;
case|case
name|FSACTL_LNX_QUERY_DISK
case|:
name|debug
argument_list|(
literal|1
argument_list|,
literal|"FSACTL_QUERY_DISK"
argument_list|)
expr_stmt|;
name|error
operator|=
name|aac_query_disk
argument_list|(
name|sc
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|FSACTL_DELETE_DISK
case|:
case|case
name|FSACTL_LNX_DELETE_DISK
case|:
comment|/* 		 * We don't trust the underland to tell us when to delete a 		 * container, rather we rely on an AIF coming from the 		 * controller 		 */
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|FSACTL_GET_PCI_INFO
case|:
name|arg
operator|=
operator|*
operator|(
name|caddr_t
operator|*
operator|)
name|arg
expr_stmt|;
case|case
name|FSACTL_LNX_GET_PCI_INFO
case|:
name|debug
argument_list|(
literal|1
argument_list|,
literal|"FSACTL_GET_PCI_INFO"
argument_list|)
expr_stmt|;
name|error
operator|=
name|aac_get_pci_info
argument_list|(
name|sc
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|debug
argument_list|(
literal|1
argument_list|,
literal|"unsupported cmd 0x%lx\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aac_poll
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|poll_events
parameter_list|,
name|d_thread_t
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|revents
decl_stmt|;
name|sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|revents
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|aac_aifq_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|poll_events
operator|&
operator|(
name|POLLRDNORM
operator||
name|POLLIN
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|aifq_idx
operator|!=
literal|0
operator|||
name|sc
operator|->
name|aifq_filled
condition|)
name|revents
operator||=
name|poll_events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_aifq_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|revents
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|poll_events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
condition|)
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|sc
operator|->
name|rcv_select
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|revents
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|aac_ioctl_event
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|aac_event
modifier|*
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
switch|switch
condition|(
name|event
operator|->
name|ev_type
condition|)
block|{
case|case
name|AAC_EVENT_CMFREE
case|:
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|aac_alloc_command
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|aac_command
operator|*
operator|*
operator|)
name|arg
argument_list|)
condition|)
block|{
name|aac_add_event
argument_list|(
name|sc
argument_list|,
name|event
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|free
argument_list|(
name|event
argument_list|,
name|M_AACBUF
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Send a FIB supplied from userspace  */
end_comment

begin_function
specifier|static
name|int
name|aac_ioctl_sendfib
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|caddr_t
name|ufib
parameter_list|)
block|{
name|struct
name|aac_command
modifier|*
name|cm
decl_stmt|;
name|int
name|size
decl_stmt|,
name|error
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|cm
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Get a command 	 */
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|aac_alloc_command
argument_list|(
name|sc
argument_list|,
operator|&
name|cm
argument_list|)
condition|)
block|{
name|struct
name|aac_event
modifier|*
name|event
decl_stmt|;
name|event
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|aac_event
argument_list|)
argument_list|,
name|M_AACBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|event
operator|->
name|ev_type
operator|=
name|AAC_EVENT_CMFREE
expr_stmt|;
name|event
operator|->
name|ev_callback
operator|=
name|aac_ioctl_event
expr_stmt|;
name|event
operator|->
name|ev_arg
operator|=
operator|&
name|cm
expr_stmt|;
name|aac_add_event
argument_list|(
name|sc
argument_list|,
name|event
argument_list|)
expr_stmt|;
name|msleep
argument_list|(
operator|&
name|cm
argument_list|,
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|,
literal|0
argument_list|,
literal|"sendfib"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Fetch the FIB header, then re-copy to get data as well. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|ufib
argument_list|,
name|cm
operator|->
name|cm_fib
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib_header
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|size
operator|=
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|Size
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"incoming FIB oversized (%d> %zd)\n"
argument_list|,
name|size
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|ufib
argument_list|,
name|cm
operator|->
name|cm_fib
argument_list|,
name|size
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|Size
operator|=
name|size
expr_stmt|;
name|cm
operator|->
name|cm_timestamp
operator|=
name|time_uptime
expr_stmt|;
comment|/* 	 * Pass the FIB to the controller, wait for it to complete. 	 */
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|aac_wait_command
argument_list|(
name|cm
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"aac_wait_command return %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Copy the FIB and data back out to the caller. 	 */
name|size
operator|=
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|Size
expr_stmt|;
if|if
condition|(
name|size
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"outbound FIB oversized (%d> %zd)\n"
argument_list|,
name|size
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|copyout
argument_list|(
name|cm
operator|->
name|cm_fib
argument_list|,
name|ufib
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|cm
operator|!=
name|NULL
condition|)
block|{
name|aac_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle an AIF sent to us by the controller; queue it for later reference.  * If the queue fills up, then drop the older entries.  */
end_comment

begin_function
specifier|static
name|void
name|aac_handle_aif
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|aac_fib
modifier|*
name|fib
parameter_list|)
block|{
name|struct
name|aac_aif_command
modifier|*
name|aif
decl_stmt|;
name|struct
name|aac_container
modifier|*
name|co
decl_stmt|,
modifier|*
name|co_next
decl_stmt|;
name|struct
name|aac_fib_context
modifier|*
name|ctx
decl_stmt|;
name|struct
name|aac_mntinfo
modifier|*
name|mi
decl_stmt|;
name|struct
name|aac_mntinforesp
modifier|*
name|mir
init|=
name|NULL
decl_stmt|;
name|u_int16_t
name|rsize
decl_stmt|;
name|int
name|next
decl_stmt|,
name|current
decl_stmt|,
name|found
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|,
name|added
init|=
literal|0
decl_stmt|,
name|i
init|=
literal|0
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|aif
operator|=
operator|(
expr|struct
name|aac_aif_command
operator|*
operator|)
operator|&
name|fib
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
name|aac_print_aif
argument_list|(
name|sc
argument_list|,
name|aif
argument_list|)
expr_stmt|;
comment|/* Is it an event that we should care about? */
switch|switch
condition|(
name|aif
operator|->
name|command
condition|)
block|{
case|case
name|AifCmdEventNotify
case|:
switch|switch
condition|(
name|aif
operator|->
name|data
operator|.
name|EN
operator|.
name|type
condition|)
block|{
case|case
name|AifEnAddContainer
case|:
case|case
name|AifEnDeleteContainer
case|:
comment|/* 			 * A container was added or deleted, but the message 			 * doesn't tell us anything else!  Re-enumerate the 			 * containers and sort things out. 			 */
name|aac_alloc_sync_fib
argument_list|(
name|sc
argument_list|,
operator|&
name|fib
argument_list|)
expr_stmt|;
name|mi
operator|=
operator|(
expr|struct
name|aac_mntinfo
operator|*
operator|)
operator|&
name|fib
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
do|do
block|{
comment|/* 				 * Ask the controller for its containers one at 				 * a time. 				 * XXX What if the controller's list changes 				 * midway through this enumaration? 				 * XXX This should be done async. 				 */
name|bzero
argument_list|(
name|mi
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_mntinfo
argument_list|)
argument_list|)
expr_stmt|;
name|mi
operator|->
name|Command
operator|=
name|VM_NameServe
expr_stmt|;
name|mi
operator|->
name|MntType
operator|=
name|FT_FILESYS
expr_stmt|;
name|mi
operator|->
name|MntCount
operator|=
name|i
expr_stmt|;
name|rsize
operator|=
sizeof|sizeof
argument_list|(
name|mir
argument_list|)
expr_stmt|;
if|if
condition|(
name|aac_sync_fib
argument_list|(
name|sc
argument_list|,
name|ContainerCommand
argument_list|,
literal|0
argument_list|,
name|fib
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_mntinfo
argument_list|)
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Error probing container %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|mir
operator|=
operator|(
expr|struct
name|aac_mntinforesp
operator|*
operator|)
operator|&
name|fib
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
comment|/* XXX Need to check if count changed */
name|count
operator|=
name|mir
operator|->
name|MntRespCount
expr_stmt|;
comment|/* 				 * Check the container against our list. 				 * co->co_found was already set to 0 in a 				 * previous run. 				 */
if|if
condition|(
operator|(
name|mir
operator|->
name|Status
operator|==
name|ST_OK
operator|)
operator|&&
operator|(
name|mir
operator|->
name|MntTable
index|[
literal|0
index|]
operator|.
name|VolType
operator|!=
name|CT_NONE
operator|)
condition|)
block|{
name|found
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|co
argument_list|,
argument|&sc->aac_container_tqh
argument_list|,
argument|co_link
argument_list|)
block|{
if|if
condition|(
name|co
operator|->
name|co_mntobj
operator|.
name|ObjectId
operator|==
name|mir
operator|->
name|MntTable
index|[
literal|0
index|]
operator|.
name|ObjectId
condition|)
block|{
name|co
operator|->
name|co_found
operator|=
literal|1
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* 					 * If the container matched, continue 					 * in the list. 					 */
if|if
condition|(
name|found
condition|)
block|{
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* 					 * This is a new container.  Do all the 					 * appropriate things to set it up. 					 */
name|aac_add_container
argument_list|(
name|sc
argument_list|,
name|mir
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|added
operator|=
literal|1
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|i
operator|<
name|count
operator|)
operator|&&
operator|(
name|i
operator|<
name|AAC_MAX_CONTAINERS
operator|)
condition|)
do|;
name|aac_release_sync_fib
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 			 * Go through our list of containers and see which ones 			 * were not marked 'found'.  Since the controller didn't 			 * list them they must have been deleted.  Do the 			 * appropriate steps to destroy the device.  Also reset 			 * the co->co_found field. 			 */
name|co
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|aac_container_tqh
argument_list|)
expr_stmt|;
while|while
condition|(
name|co
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|co
operator|->
name|co_found
operator|==
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|device_delete_child
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
name|co
operator|->
name|co_disk
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
name|co_next
operator|=
name|TAILQ_NEXT
argument_list|(
name|co
argument_list|,
name|co_link
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|aac_container_lock
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|aac_container_tqh
argument_list|,
name|co
argument_list|,
name|co_link
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_container_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|co
argument_list|,
name|M_AACBUF
argument_list|)
expr_stmt|;
name|co
operator|=
name|co_next
expr_stmt|;
block|}
else|else
block|{
name|co
operator|->
name|co_found
operator|=
literal|0
expr_stmt|;
name|co
operator|=
name|TAILQ_NEXT
argument_list|(
name|co
argument_list|,
name|co_link
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Attach the newly created containers */
if|if
condition|(
name|added
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|bus_generic_attach
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
default|default:
break|break;
block|}
comment|/* Copy the AIF data to the AIF queue for ioctl retrieval */
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|aac_aifq_lock
argument_list|)
expr_stmt|;
name|current
operator|=
name|sc
operator|->
name|aifq_idx
expr_stmt|;
name|next
operator|=
operator|(
name|current
operator|+
literal|1
operator|)
operator|%
name|AAC_AIFQ_LENGTH
expr_stmt|;
if|if
condition|(
name|next
operator|==
literal|0
condition|)
name|sc
operator|->
name|aifq_filled
operator|=
literal|1
expr_stmt|;
name|bcopy
argument_list|(
name|fib
argument_list|,
operator|&
name|sc
operator|->
name|aac_aifq
index|[
name|current
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
argument_list|)
expr_stmt|;
comment|/* modify AIF contexts */
if|if
condition|(
name|sc
operator|->
name|aifq_filled
condition|)
block|{
for|for
control|(
name|ctx
operator|=
name|sc
operator|->
name|fibctx
init|;
name|ctx
condition|;
name|ctx
operator|=
name|ctx
operator|->
name|next
control|)
block|{
if|if
condition|(
name|next
operator|==
name|ctx
operator|->
name|ctx_idx
condition|)
name|ctx
operator|->
name|ctx_wrap
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|current
operator|==
name|ctx
operator|->
name|ctx_idx
operator|&&
name|ctx
operator|->
name|ctx_wrap
condition|)
name|ctx
operator|->
name|ctx_idx
operator|=
name|next
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|aifq_idx
operator|=
name|next
expr_stmt|;
comment|/* On the off chance that someone is sleeping for an aif... */
if|if
condition|(
name|sc
operator|->
name|aac_state
operator|&
name|AAC_STATE_AIF_SLEEPER
condition|)
name|wakeup
argument_list|(
name|sc
operator|->
name|aac_aifq
argument_list|)
expr_stmt|;
comment|/* Wakeup any poll()ers */
name|selwakeuppri
argument_list|(
operator|&
name|sc
operator|->
name|rcv_select
argument_list|,
name|PRIBIO
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_aifq_lock
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Return the Revision of the driver to userspace and check to see if the  * userspace app is possibly compatible.  This is extremely bogus since  * our driver doesn't follow Adaptec's versioning system.  Cheat by just  * returning what the card reported.  */
end_comment

begin_function
specifier|static
name|int
name|aac_rev_check
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|caddr_t
name|udata
parameter_list|)
block|{
name|struct
name|aac_rev_check
name|rev_check
decl_stmt|;
name|struct
name|aac_rev_check_resp
name|rev_check_resp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* 	 * Copyin the revision struct from userspace 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|udata
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|rev_check
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_rev_check
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
name|error
return|;
block|}
name|debug
argument_list|(
literal|2
argument_list|,
literal|"Userland revision= %d\n"
argument_list|,
name|rev_check
operator|.
name|callingRevision
operator|.
name|buildNumber
argument_list|)
expr_stmt|;
comment|/* 	 * Doctor up the response struct. 	 */
name|rev_check_resp
operator|.
name|possiblyCompatible
operator|=
literal|1
expr_stmt|;
name|rev_check_resp
operator|.
name|adapterSWRevision
operator|.
name|external
operator|.
name|ul
operator|=
name|sc
operator|->
name|aac_revision
operator|.
name|external
operator|.
name|ul
expr_stmt|;
name|rev_check_resp
operator|.
name|adapterSWRevision
operator|.
name|buildNumber
operator|=
name|sc
operator|->
name|aac_revision
operator|.
name|buildNumber
expr_stmt|;
return|return
operator|(
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|rev_check_resp
argument_list|,
name|udata
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_rev_check_resp
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Pass the fib context to the caller  */
end_comment

begin_function
specifier|static
name|int
name|aac_open_aif
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|caddr_t
name|arg
parameter_list|)
block|{
name|struct
name|aac_fib_context
modifier|*
name|fibctx
decl_stmt|,
modifier|*
name|ctx
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|fibctx
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib_context
argument_list|)
argument_list|,
name|M_AACBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|fibctx
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|aac_aifq_lock
argument_list|)
expr_stmt|;
comment|/* all elements are already 0, add to queue */
if|if
condition|(
name|sc
operator|->
name|fibctx
operator|==
name|NULL
condition|)
name|sc
operator|->
name|fibctx
operator|=
name|fibctx
expr_stmt|;
else|else
block|{
for|for
control|(
name|ctx
operator|=
name|sc
operator|->
name|fibctx
init|;
name|ctx
operator|->
name|next
condition|;
name|ctx
operator|=
name|ctx
operator|->
name|next
control|)
empty_stmt|;
name|ctx
operator|->
name|next
operator|=
name|fibctx
expr_stmt|;
name|fibctx
operator|->
name|prev
operator|=
name|ctx
expr_stmt|;
block|}
comment|/* evaluate unique value */
name|fibctx
operator|->
name|unique
operator|=
operator|(
operator|*
operator|(
name|u_int32_t
operator|*
operator|)
operator|&
name|fibctx
operator|&
literal|0xffffffff
operator|)
expr_stmt|;
name|ctx
operator|=
name|sc
operator|->
name|fibctx
expr_stmt|;
while|while
condition|(
name|ctx
operator|!=
name|fibctx
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|unique
operator|==
name|fibctx
operator|->
name|unique
condition|)
block|{
name|fibctx
operator|->
name|unique
operator|++
expr_stmt|;
name|ctx
operator|=
name|sc
operator|->
name|fibctx
expr_stmt|;
block|}
else|else
block|{
name|ctx
operator|=
name|ctx
operator|->
name|next
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_aifq_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|fibctx
operator|->
name|unique
argument_list|,
operator|(
name|void
operator|*
operator|)
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|aac_close_aif
argument_list|(
name|sc
argument_list|,
operator|(
name|caddr_t
operator|)
name|ctx
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Close the caller's fib context  */
end_comment

begin_function
specifier|static
name|int
name|aac_close_aif
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|caddr_t
name|arg
parameter_list|)
block|{
name|struct
name|aac_fib_context
modifier|*
name|ctx
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|aac_aifq_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|ctx
operator|=
name|sc
operator|->
name|fibctx
init|;
name|ctx
condition|;
name|ctx
operator|=
name|ctx
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ctx
operator|->
name|unique
operator|==
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|arg
condition|)
block|{
if|if
condition|(
name|ctx
operator|==
name|sc
operator|->
name|fibctx
condition|)
name|sc
operator|->
name|fibctx
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|ctx
operator|->
name|prev
operator|->
name|next
operator|=
name|ctx
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|next
condition|)
name|ctx
operator|->
name|next
operator|->
name|prev
operator|=
name|ctx
operator|->
name|prev
expr_stmt|;
block|}
break|break;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_aifq_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
condition|)
name|free
argument_list|(
name|ctx
argument_list|,
name|M_AACBUF
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Pass the caller the next AIF in their queue  */
end_comment

begin_function
specifier|static
name|int
name|aac_getnext_aif
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|caddr_t
name|arg
parameter_list|)
block|{
name|struct
name|get_adapter_fib_ioctl
name|agf
decl_stmt|;
name|struct
name|aac_fib_context
modifier|*
name|ctx
decl_stmt|;
name|int
name|error
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|agf
argument_list|,
sizeof|sizeof
argument_list|(
name|agf
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|ctx
operator|=
name|sc
operator|->
name|fibctx
init|;
name|ctx
condition|;
name|ctx
operator|=
name|ctx
operator|->
name|next
control|)
block|{
if|if
condition|(
name|agf
operator|.
name|AdapterFibContext
operator|==
name|ctx
operator|->
name|unique
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|ctx
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|error
operator|=
name|aac_return_aif
argument_list|(
name|sc
argument_list|,
name|ctx
argument_list|,
name|agf
operator|.
name|AifFib
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EAGAIN
operator|&&
name|agf
operator|.
name|Wait
condition|)
block|{
name|debug
argument_list|(
literal|2
argument_list|,
literal|"aac_getnext_aif(): waiting for AIF"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|aac_state
operator||=
name|AAC_STATE_AIF_SLEEPER
expr_stmt|;
while|while
condition|(
name|error
operator|==
name|EAGAIN
condition|)
block|{
name|error
operator|=
name|tsleep
argument_list|(
name|sc
operator|->
name|aac_aifq
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"aacaif"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|aac_return_aif
argument_list|(
name|sc
argument_list|,
name|ctx
argument_list|,
name|agf
operator|.
name|AifFib
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|aac_state
operator|&=
operator|~
name|AAC_STATE_AIF_SLEEPER
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Hand the next AIF off the top of the queue out to userspace.  */
end_comment

begin_function
specifier|static
name|int
name|aac_return_aif
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|aac_fib_context
modifier|*
name|ctx
parameter_list|,
name|caddr_t
name|uptr
parameter_list|)
block|{
name|int
name|current
decl_stmt|,
name|error
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|aac_aifq_lock
argument_list|)
expr_stmt|;
name|current
operator|=
name|ctx
operator|->
name|ctx_idx
expr_stmt|;
if|if
condition|(
name|current
operator|==
name|sc
operator|->
name|aifq_idx
operator|&&
operator|!
name|ctx
operator|->
name|ctx_wrap
condition|)
block|{
comment|/* empty */
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_aifq_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAGAIN
operator|)
return|;
block|}
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|sc
operator|->
name|aac_aifq
index|[
name|current
index|]
argument_list|,
operator|(
name|void
operator|*
operator|)
name|uptr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"aac_return_aif: copyout returned %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
else|else
block|{
name|ctx
operator|->
name|ctx_wrap
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|ctx_idx
operator|=
operator|(
name|current
operator|+
literal|1
operator|)
operator|%
name|AAC_AIFQ_LENGTH
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_aifq_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aac_get_pci_info
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|caddr_t
name|uptr
parameter_list|)
block|{
struct|struct
name|aac_pci_info
block|{
name|u_int32_t
name|bus
decl_stmt|;
name|u_int32_t
name|slot
decl_stmt|;
block|}
name|pciinf
struct|;
name|int
name|error
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|pciinf
operator|.
name|bus
operator|=
name|pci_get_bus
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|)
expr_stmt|;
name|pciinf
operator|.
name|slot
operator|=
name|pci_get_slot
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|pciinf
argument_list|,
name|uptr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_pci_info
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Give the userland some information about the container.  The AAC arch  * expects the driver to be a SCSI passthrough type driver, so it expects  * the containers to have b:t:l numbers.  Fake it.  */
end_comment

begin_function
specifier|static
name|int
name|aac_query_disk
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|caddr_t
name|uptr
parameter_list|)
block|{
name|struct
name|aac_query_disk
name|query_disk
decl_stmt|;
name|struct
name|aac_container
modifier|*
name|co
decl_stmt|;
name|struct
name|aac_disk
modifier|*
name|disk
decl_stmt|;
name|int
name|error
decl_stmt|,
name|id
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|disk
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|uptr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|query_disk
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_query_disk
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|id
operator|=
name|query_disk
operator|.
name|ContainerNumber
expr_stmt|;
if|if
condition|(
name|id
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|aac_container_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|co
argument_list|,
argument|&sc->aac_container_tqh
argument_list|,
argument|co_link
argument_list|)
block|{
if|if
condition|(
name|co
operator|->
name|co_mntobj
operator|.
name|ObjectId
operator|==
name|id
condition|)
break|break;
block|}
if|if
condition|(
name|co
operator|==
name|NULL
condition|)
block|{
name|query_disk
operator|.
name|Valid
operator|=
literal|0
expr_stmt|;
name|query_disk
operator|.
name|Locked
operator|=
literal|0
expr_stmt|;
name|query_disk
operator|.
name|Deleted
operator|=
literal|1
expr_stmt|;
comment|/* XXX is this right? */
block|}
else|else
block|{
name|disk
operator|=
name|device_get_softc
argument_list|(
name|co
operator|->
name|co_disk
argument_list|)
expr_stmt|;
name|query_disk
operator|.
name|Valid
operator|=
literal|1
expr_stmt|;
name|query_disk
operator|.
name|Locked
operator|=
operator|(
name|disk
operator|->
name|ad_flags
operator|&
name|AAC_DISK_OPEN
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|query_disk
operator|.
name|Deleted
operator|=
literal|0
expr_stmt|;
name|query_disk
operator|.
name|Bus
operator|=
name|device_get_unit
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|)
expr_stmt|;
name|query_disk
operator|.
name|Target
operator|=
name|disk
operator|->
name|unit
expr_stmt|;
name|query_disk
operator|.
name|Lun
operator|=
literal|0
expr_stmt|;
name|query_disk
operator|.
name|UnMapped
operator|=
literal|0
expr_stmt|;
name|sprintf
argument_list|(
operator|&
name|query_disk
operator|.
name|diskDeviceName
index|[
literal|0
index|]
argument_list|,
literal|"%s%d"
argument_list|,
name|disk
operator|->
name|ad_disk
operator|->
name|d_name
argument_list|,
name|disk
operator|->
name|ad_disk
operator|->
name|d_unit
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_container_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|query_disk
argument_list|,
name|uptr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_query_disk
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|aac_get_bus_info
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|aac_fib
modifier|*
name|fib
decl_stmt|;
name|struct
name|aac_ctcfg
modifier|*
name|c_cmd
decl_stmt|;
name|struct
name|aac_ctcfg_resp
modifier|*
name|c_resp
decl_stmt|;
name|struct
name|aac_vmioctl
modifier|*
name|vmi
decl_stmt|;
name|struct
name|aac_vmi_businf_resp
modifier|*
name|vmi_resp
decl_stmt|;
name|struct
name|aac_getbusinf
name|businfo
decl_stmt|;
name|struct
name|aac_sim
modifier|*
name|caminf
decl_stmt|;
name|device_t
name|child
decl_stmt|;
name|int
name|i
decl_stmt|,
name|found
decl_stmt|,
name|error
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
name|aac_alloc_sync_fib
argument_list|(
name|sc
argument_list|,
operator|&
name|fib
argument_list|)
expr_stmt|;
name|c_cmd
operator|=
operator|(
expr|struct
name|aac_ctcfg
operator|*
operator|)
operator|&
name|fib
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
name|bzero
argument_list|(
name|c_cmd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_ctcfg
argument_list|)
argument_list|)
expr_stmt|;
name|c_cmd
operator|->
name|Command
operator|=
name|VM_ContainerConfig
expr_stmt|;
name|c_cmd
operator|->
name|cmd
operator|=
name|CT_GET_SCSI_METHOD
expr_stmt|;
name|c_cmd
operator|->
name|param
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|aac_sync_fib
argument_list|(
name|sc
argument_list|,
name|ContainerCommand
argument_list|,
literal|0
argument_list|,
name|fib
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_ctcfg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"Error %d sending "
literal|"VM_ContainerConfig command\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|aac_release_sync_fib
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|c_resp
operator|=
operator|(
expr|struct
name|aac_ctcfg_resp
operator|*
operator|)
operator|&
name|fib
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|c_resp
operator|->
name|Status
operator|!=
name|ST_OK
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"VM_ContainerConfig returned 0x%x\n"
argument_list|,
name|c_resp
operator|->
name|Status
argument_list|)
expr_stmt|;
name|aac_release_sync_fib
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc
operator|->
name|scsi_method_id
operator|=
name|c_resp
operator|->
name|param
expr_stmt|;
name|vmi
operator|=
operator|(
expr|struct
name|aac_vmioctl
operator|*
operator|)
operator|&
name|fib
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
name|bzero
argument_list|(
name|vmi
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_vmioctl
argument_list|)
argument_list|)
expr_stmt|;
name|vmi
operator|->
name|Command
operator|=
name|VM_Ioctl
expr_stmt|;
name|vmi
operator|->
name|ObjType
operator|=
name|FT_DRIVE
expr_stmt|;
name|vmi
operator|->
name|MethId
operator|=
name|sc
operator|->
name|scsi_method_id
expr_stmt|;
name|vmi
operator|->
name|ObjId
operator|=
literal|0
expr_stmt|;
name|vmi
operator|->
name|IoctlCmd
operator|=
name|GetBusInfo
expr_stmt|;
name|error
operator|=
name|aac_sync_fib
argument_list|(
name|sc
argument_list|,
name|ContainerCommand
argument_list|,
literal|0
argument_list|,
name|fib
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_vmioctl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"Error %d sending VMIoctl command\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|aac_release_sync_fib
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|vmi_resp
operator|=
operator|(
expr|struct
name|aac_vmi_businf_resp
operator|*
operator|)
operator|&
name|fib
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|vmi_resp
operator|->
name|Status
operator|!=
name|ST_OK
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"VM_Ioctl returned %d\n"
argument_list|,
name|vmi_resp
operator|->
name|Status
argument_list|)
expr_stmt|;
name|aac_release_sync_fib
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|bcopy
argument_list|(
operator|&
name|vmi_resp
operator|->
name|BusInf
argument_list|,
operator|&
name|businfo
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_getbusinf
argument_list|)
argument_list|)
expr_stmt|;
name|aac_release_sync_fib
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|aac_io_lock
argument_list|)
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|businfo
operator|.
name|BusCount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|businfo
operator|.
name|BusValid
index|[
name|i
index|]
operator|!=
name|AAC_BUS_VALID
condition|)
continue|continue;
name|caminf
operator|=
operator|(
expr|struct
name|aac_sim
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|aac_sim
argument_list|)
argument_list|,
name|M_AACBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|caminf
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"No memory to add passthrough bus %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
empty_stmt|;
name|child
operator|=
name|device_add_child
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"aacp"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"device_add_child failed for passthrough bus %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|caminf
argument_list|,
name|M_AACBUF
argument_list|)
expr_stmt|;
break|break;
block|}
name|caminf
operator|->
name|TargetsPerBus
operator|=
name|businfo
operator|.
name|TargetsPerBus
expr_stmt|;
name|caminf
operator|->
name|BusNumber
operator|=
name|i
expr_stmt|;
name|caminf
operator|->
name|InitiatorBusId
operator|=
name|businfo
operator|.
name|InitiatorBusId
index|[
name|i
index|]
expr_stmt|;
name|caminf
operator|->
name|aac_sc
operator|=
name|sc
expr_stmt|;
name|caminf
operator|->
name|sim_dev
operator|=
name|child
expr_stmt|;
name|device_set_ivars
argument_list|(
name|child
argument_list|,
name|caminf
argument_list|)
expr_stmt|;
name|device_set_desc
argument_list|(
name|child
argument_list|,
literal|"SCSI Passthrough Bus"
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|aac_sim_tqh
argument_list|,
name|caminf
argument_list|,
name|sim_link
argument_list|)
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|found
condition|)
name|bus_generic_attach
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

end_unit

