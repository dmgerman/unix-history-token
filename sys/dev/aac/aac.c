begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2000 Michael Smith  * Copyright (c) 2001 Scott Long  * Copyright (c) 2000 BSDi  * Copyright (c) 2001 Adaptec, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$FreeBSD$  */
end_comment

begin_comment
comment|/*  * Driver for the Adaptec 'FSA' family of PCI/SCSI RAID adapters.  */
end_comment

begin_include
include|#
directive|include
file|"opt_aac.h"
end_include

begin_comment
comment|/* #include<stddef.h> */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500005
end_if

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/aac/aac_compat.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/devicestat.h>
end_include

begin_include
include|#
directive|include
file|<sys/disk.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus_memio.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<dev/aac/aacreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/aac/aac_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<dev/aac/aacvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/aac/aac_tables.h>
end_include

begin_function_decl
specifier|static
name|void
name|aac_startup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_add_container
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|aac_mntinforesp
modifier|*
name|mir
parameter_list|,
name|int
name|f
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_get_bus_info
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Command Processing */
end_comment

begin_function_decl
specifier|static
name|void
name|aac_timeout
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_start
parameter_list|(
name|struct
name|aac_command
modifier|*
name|cm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_complete
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_bio_command
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|aac_command
modifier|*
modifier|*
name|cmp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_bio_complete
parameter_list|(
name|struct
name|aac_command
modifier|*
name|cm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_wait_command
parameter_list|(
name|struct
name|aac_command
modifier|*
name|cm
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_command_thread
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Command Buffer Management */
end_comment

begin_function_decl
specifier|static
name|void
name|aac_map_command_helper
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_alloc_commands
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_free_commands
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_map_command
parameter_list|(
name|struct
name|aac_command
modifier|*
name|cm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_unmap_command
parameter_list|(
name|struct
name|aac_command
modifier|*
name|cm
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Hardware Interface */
end_comment

begin_function_decl
specifier|static
name|void
name|aac_common_map
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_check_firmware
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_init
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_sync_command
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|command
parameter_list|,
name|u_int32_t
name|arg0
parameter_list|,
name|u_int32_t
name|arg1
parameter_list|,
name|u_int32_t
name|arg2
parameter_list|,
name|u_int32_t
name|arg3
parameter_list|,
name|u_int32_t
modifier|*
name|sp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_enqueue_fib
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|queue
parameter_list|,
name|struct
name|aac_command
modifier|*
name|cm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_dequeue_fib
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|queue
parameter_list|,
name|u_int32_t
modifier|*
name|fib_size
parameter_list|,
name|struct
name|aac_fib
modifier|*
modifier|*
name|fib_addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_enqueue_response
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|queue
parameter_list|,
name|struct
name|aac_fib
modifier|*
name|fib
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Falcon/PPC interface */
end_comment

begin_function_decl
specifier|static
name|int
name|aac_fa_get_fwstatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_fa_qnotify
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|qbit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_fa_get_istatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_fa_clear_istatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|mask
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_fa_set_mailbox
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|command
parameter_list|,
name|u_int32_t
name|arg0
parameter_list|,
name|u_int32_t
name|arg1
parameter_list|,
name|u_int32_t
name|arg2
parameter_list|,
name|u_int32_t
name|arg3
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_fa_get_mailboxstatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_fa_set_interrupts
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|enable
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|aac_interface
name|aac_fa_interface
init|=
block|{
name|aac_fa_get_fwstatus
block|,
name|aac_fa_qnotify
block|,
name|aac_fa_get_istatus
block|,
name|aac_fa_clear_istatus
block|,
name|aac_fa_set_mailbox
block|,
name|aac_fa_get_mailboxstatus
block|,
name|aac_fa_set_interrupts
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* StrongARM interface */
end_comment

begin_function_decl
specifier|static
name|int
name|aac_sa_get_fwstatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_sa_qnotify
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|qbit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_sa_get_istatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_sa_clear_istatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|mask
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_sa_set_mailbox
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|command
parameter_list|,
name|u_int32_t
name|arg0
parameter_list|,
name|u_int32_t
name|arg1
parameter_list|,
name|u_int32_t
name|arg2
parameter_list|,
name|u_int32_t
name|arg3
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_sa_get_mailboxstatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_sa_set_interrupts
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|enable
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|aac_interface
name|aac_sa_interface
init|=
block|{
name|aac_sa_get_fwstatus
block|,
name|aac_sa_qnotify
block|,
name|aac_sa_get_istatus
block|,
name|aac_sa_clear_istatus
block|,
name|aac_sa_set_mailbox
block|,
name|aac_sa_get_mailboxstatus
block|,
name|aac_sa_set_interrupts
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* i960Rx interface */
end_comment

begin_function_decl
specifier|static
name|int
name|aac_rx_get_fwstatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_rx_qnotify
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|qbit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_rx_get_istatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_rx_clear_istatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|mask
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_rx_set_mailbox
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|command
parameter_list|,
name|u_int32_t
name|arg0
parameter_list|,
name|u_int32_t
name|arg1
parameter_list|,
name|u_int32_t
name|arg2
parameter_list|,
name|u_int32_t
name|arg3
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_rx_get_mailboxstatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_rx_set_interrupts
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|enable
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|aac_interface
name|aac_rx_interface
init|=
block|{
name|aac_rx_get_fwstatus
block|,
name|aac_rx_qnotify
block|,
name|aac_rx_get_istatus
block|,
name|aac_rx_clear_istatus
block|,
name|aac_rx_set_mailbox
block|,
name|aac_rx_get_mailboxstatus
block|,
name|aac_rx_set_interrupts
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Debugging and Diagnostics */
end_comment

begin_function_decl
specifier|static
name|void
name|aac_describe_controller
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|aac_describe_code
parameter_list|(
name|struct
name|aac_code_lookup
modifier|*
name|table
parameter_list|,
name|u_int32_t
name|code
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Management Interface */
end_comment

begin_decl_stmt
specifier|static
name|d_open_t
name|aac_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|aac_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|aac_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_poll_t
name|aac_poll
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|aac_ioctl_sendfib
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|caddr_t
name|ufib
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_handle_aif
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|aac_fib
modifier|*
name|fib
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_rev_check
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|caddr_t
name|udata
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_getnext_aif
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|caddr_t
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_return_aif
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|caddr_t
name|uptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_query_disk
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|caddr_t
name|uptr
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|AAC_CDEV_MAJOR
value|150
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|aac_cdevsw
init|=
block|{
name|aac_open
block|,
comment|/* open */
name|aac_close
block|,
comment|/* close */
name|noread
block|,
comment|/* read */
name|nowrite
block|,
comment|/* write */
name|aac_ioctl
block|,
comment|/* ioctl */
name|aac_poll
block|,
comment|/* poll */
name|nommap
block|,
comment|/* mmap */
name|nostrategy
block|,
comment|/* strategy */
literal|"aac"
block|,
comment|/* name */
name|AAC_CDEV_MAJOR
block|,
comment|/* major */
name|nodump
block|,
comment|/* dump */
name|nopsize
block|,
comment|/* psize */
literal|0
block|,
comment|/* flags */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500005
operator|-
literal|1
block|,
comment|/* bmaj */
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_AACBUF
argument_list|,
literal|"aacbuf"
argument_list|,
literal|"Buffers for the AAC driver"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* sysctl node */
end_comment

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|aac
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"AAC driver parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Device Interface  */
end_comment

begin_comment
comment|/*  * Initialise the controller and softc  */
end_comment

begin_function
name|int
name|aac_attach
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|unit
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Initialise per-controller queues. 	 */
name|aac_initq_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|aac_initq_ready
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|aac_initq_busy
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|aac_initq_complete
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|aac_initq_bio
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500005
comment|/* 	 * Initialise command-completion task. 	 */
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|aac_task_complete
argument_list|,
literal|0
argument_list|,
name|aac_complete
argument_list|,
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* disable interrupts before we enable anything */
name|AAC_MASK_INTERRUPTS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* mark controller as suspended until we get ourselves organised */
name|sc
operator|->
name|aac_state
operator||=
name|AAC_STATE_SUSPEND
expr_stmt|;
comment|/* 	 * Check that the firmware on the card is supported. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|aac_check_firmware
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Init the sync fib lock */
name|AAC_LOCK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|aac_sync_lock
argument_list|,
literal|"AAC sync FIB lock"
argument_list|)
expr_stmt|;
comment|/* 	 * Initialise the adapter. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|aac_init
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/*  	 * Print a little information about the controller. 	 */
name|aac_describe_controller
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Register to probe our containers later. 	 */
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|aac_container_tqh
argument_list|)
expr_stmt|;
name|AAC_LOCK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|aac_container_lock
argument_list|,
literal|"AAC container lock"
argument_list|)
expr_stmt|;
comment|/* 	 * Lock for the AIF queue 	 */
name|AAC_LOCK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|aac_aifq_lock
argument_list|,
literal|"AAC AIF lock"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|aac_ich
operator|.
name|ich_func
operator|=
name|aac_startup
expr_stmt|;
name|sc
operator|->
name|aac_ich
operator|.
name|ich_arg
operator|=
name|sc
expr_stmt|;
if|if
condition|(
name|config_intrhook_establish
argument_list|(
operator|&
name|sc
operator|->
name|aac_ich
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"can't establish configuration hook\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * Make the control device. 	 */
name|unit
operator|=
name|device_get_unit
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|aac_dev_t
operator|=
name|make_dev
argument_list|(
operator|&
name|aac_cdevsw
argument_list|,
name|unit
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0640
argument_list|,
literal|"aac%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>
literal|500005
operator|(
name|void
operator|)
name|make_dev_alias
argument_list|(
name|sc
operator|->
name|aac_dev_t
argument_list|,
literal|"afa%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|make_dev_alias
argument_list|(
name|sc
operator|->
name|aac_dev_t
argument_list|,
literal|"hpn%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|aac_dev_t
operator|->
name|si_drv1
operator|=
name|sc
expr_stmt|;
comment|/* Create the AIF thread */
if|#
directive|if
name|__FreeBSD_version
operator|>
literal|500005
if|if
condition|(
name|kthread_create
argument_list|(
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|aac_command_thread
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|aifthread
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"aac%daif"
argument_list|,
name|unit
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
name|kthread_create
argument_list|(
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|aac_command_thread
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|aifthread
argument_list|,
literal|"aac%daif"
argument_list|,
name|unit
argument_list|)
condition|)
endif|#
directive|endif
name|panic
argument_list|(
literal|"Could not create AIF thread\n"
argument_list|)
expr_stmt|;
comment|/* Register the shutdown method to only be called post-dump */
if|if
condition|(
operator|(
name|sc
operator|->
name|eh
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|shutdown_final
argument_list|,
name|aac_shutdown
argument_list|,
name|sc
operator|->
name|aac_dev
argument_list|,
name|SHUTDOWN_PRI_DEFAULT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"shutdown event registration failed\n"
argument_list|)
expr_stmt|;
comment|/* Register with CAM for the non-DASD devices */
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|quirks
operator|&
name|AAC_QUIRK_NOCAM
operator|)
condition|)
block|{
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|aac_sim_tqh
argument_list|)
expr_stmt|;
name|aac_get_bus_info
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Probe for containers, create disks.  */
end_comment

begin_function
specifier|static
name|void
name|aac_startup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|aac_fib
modifier|*
name|fib
decl_stmt|;
name|struct
name|aac_mntinfo
modifier|*
name|mi
decl_stmt|;
name|struct
name|aac_mntinforesp
modifier|*
name|mir
init|=
name|NULL
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|aac_softc
operator|*
operator|)
name|arg
expr_stmt|;
comment|/* disconnect ourselves from the intrhook chain */
name|config_intrhook_disestablish
argument_list|(
operator|&
name|sc
operator|->
name|aac_ich
argument_list|)
expr_stmt|;
name|aac_alloc_sync_fib
argument_list|(
name|sc
argument_list|,
operator|&
name|fib
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mi
operator|=
operator|(
expr|struct
name|aac_mntinfo
operator|*
operator|)
operator|&
name|fib
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
comment|/* loop over possible containers */
do|do
block|{
comment|/* request information on this container */
name|bzero
argument_list|(
name|mi
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_mntinfo
argument_list|)
argument_list|)
expr_stmt|;
name|mi
operator|->
name|Command
operator|=
name|VM_NameServe
expr_stmt|;
name|mi
operator|->
name|MntType
operator|=
name|FT_FILESYS
expr_stmt|;
name|mi
operator|->
name|MntCount
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|aac_sync_fib
argument_list|(
name|sc
argument_list|,
name|ContainerCommand
argument_list|,
literal|0
argument_list|,
name|fib
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_mntinfo
argument_list|)
argument_list|)
condition|)
block|{
name|debug
argument_list|(
literal|2
argument_list|,
literal|"error probing container %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|mir
operator|=
operator|(
expr|struct
name|aac_mntinforesp
operator|*
operator|)
operator|&
name|fib
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
name|aac_add_container
argument_list|(
name|sc
argument_list|,
name|mir
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|i
operator|<
name|mir
operator|->
name|MntRespCount
operator|)
operator|&&
operator|(
name|i
operator|<
name|AAC_MAX_CONTAINERS
operator|)
condition|)
do|;
name|aac_release_sync_fib
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* poke the bus to actually attach the child devices */
if|if
condition|(
name|bus_generic_attach
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"bus_generic_attach failed\n"
argument_list|)
expr_stmt|;
comment|/* mark the controller up */
name|sc
operator|->
name|aac_state
operator|&=
operator|~
name|AAC_STATE_SUSPEND
expr_stmt|;
comment|/* enable interrupts now */
name|AAC_UNMASK_INTERRUPTS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Create a device to respresent a new container  */
end_comment

begin_function
specifier|static
name|void
name|aac_add_container
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|aac_mntinforesp
modifier|*
name|mir
parameter_list|,
name|int
name|f
parameter_list|)
block|{
name|struct
name|aac_container
modifier|*
name|co
decl_stmt|;
name|device_t
name|child
decl_stmt|;
comment|/*  	 * Check container volume type for validity.  Note that many of 	 * the possible types may never show up. 	 */
if|if
condition|(
operator|(
name|mir
operator|->
name|Status
operator|==
name|ST_OK
operator|)
operator|&&
operator|(
name|mir
operator|->
name|MntTable
index|[
literal|0
index|]
operator|.
name|VolType
operator|!=
name|CT_NONE
operator|)
condition|)
block|{
name|co
operator|=
operator|(
expr|struct
name|aac_container
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|co
argument_list|,
name|M_AACBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|co
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"Out of memory?!\n"
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|1
argument_list|,
literal|"id %x  name '%.16s'  size %u  type %d"
argument_list|,
name|mir
operator|->
name|MntTable
index|[
literal|0
index|]
operator|.
name|ObjectId
argument_list|,
name|mir
operator|->
name|MntTable
index|[
literal|0
index|]
operator|.
name|FileSystemName
argument_list|,
name|mir
operator|->
name|MntTable
index|[
literal|0
index|]
operator|.
name|Capacity
argument_list|,
name|mir
operator|->
name|MntTable
index|[
literal|0
index|]
operator|.
name|VolType
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|child
operator|=
name|device_add_child
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"aacd"
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"device_add_child failed\n"
argument_list|)
expr_stmt|;
else|else
name|device_set_ivars
argument_list|(
name|child
argument_list|,
name|co
argument_list|)
expr_stmt|;
name|device_set_desc
argument_list|(
name|child
argument_list|,
name|aac_describe_code
argument_list|(
name|aac_container_types
argument_list|,
name|mir
operator|->
name|MntTable
index|[
literal|0
index|]
operator|.
name|VolType
argument_list|)
argument_list|)
expr_stmt|;
name|co
operator|->
name|co_disk
operator|=
name|child
expr_stmt|;
name|co
operator|->
name|co_found
operator|=
name|f
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|mir
operator|->
name|MntTable
index|[
literal|0
index|]
argument_list|,
operator|&
name|co
operator|->
name|co_mntobj
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_mntobj
argument_list|)
argument_list|)
expr_stmt|;
name|AAC_LOCK_ACQUIRE
argument_list|(
operator|&
name|sc
operator|->
name|aac_container_lock
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|aac_container_tqh
argument_list|,
name|co
argument_list|,
name|co_link
argument_list|)
expr_stmt|;
name|AAC_LOCK_RELEASE
argument_list|(
operator|&
name|sc
operator|->
name|aac_container_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Free all of the resources associated with (sc)  *  * Should not be called if the controller is active.  */
end_comment

begin_function
name|void
name|aac_free
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* remove the control device */
if|if
condition|(
name|sc
operator|->
name|aac_dev_t
operator|!=
name|NULL
condition|)
name|destroy_dev
argument_list|(
name|sc
operator|->
name|aac_dev_t
argument_list|)
expr_stmt|;
comment|/* throw away any FIB buffers, discard the FIB DMA tag */
name|aac_free_commands
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|aac_fib_dmat
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|aac_fib_dmat
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|aac_commands
argument_list|,
name|M_AACBUF
argument_list|)
expr_stmt|;
comment|/* destroy the common area */
if|if
condition|(
name|sc
operator|->
name|aac_common
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|aac_common_dmat
argument_list|,
name|sc
operator|->
name|aac_common_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|aac_common_dmat
argument_list|,
name|sc
operator|->
name|aac_common
argument_list|,
name|sc
operator|->
name|aac_common_dmamap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|aac_common_dmat
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|aac_common_dmat
argument_list|)
expr_stmt|;
comment|/* disconnect the interrupt handler */
if|if
condition|(
name|sc
operator|->
name|aac_intr
condition|)
name|bus_teardown_intr
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
name|sc
operator|->
name|aac_irq
argument_list|,
name|sc
operator|->
name|aac_intr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|aac_irq
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|aac_irq_rid
argument_list|,
name|sc
operator|->
name|aac_irq
argument_list|)
expr_stmt|;
comment|/* destroy data-transfer DMA tag */
if|if
condition|(
name|sc
operator|->
name|aac_buffer_dmat
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|aac_buffer_dmat
argument_list|)
expr_stmt|;
comment|/* destroy the parent DMA tag */
if|if
condition|(
name|sc
operator|->
name|aac_parent_dmat
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|aac_parent_dmat
argument_list|)
expr_stmt|;
comment|/* release the register window mapping */
if|if
condition|(
name|sc
operator|->
name|aac_regs_resource
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|aac_regs_rid
argument_list|,
name|sc
operator|->
name|aac_regs_resource
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Disconnect from the controller completely, in preparation for unload.  */
end_comment

begin_function
name|int
name|aac_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|aac_container
modifier|*
name|co
decl_stmt|;
name|struct
name|aac_sim
modifier|*
name|sim
decl_stmt|;
name|int
name|error
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|aac_state
operator|&
name|AAC_STATE_OPEN
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* Remove the child containers */
while|while
condition|(
operator|(
name|co
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|aac_container_tqh
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|aac_container_tqh
argument_list|,
name|co
argument_list|,
name|co_link
argument_list|)
expr_stmt|;
name|error
operator|=
name|device_delete_child
argument_list|(
name|dev
argument_list|,
name|co
operator|->
name|co_disk
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|free
argument_list|(
name|co
argument_list|,
name|M_AACBUF
argument_list|)
expr_stmt|;
block|}
comment|/* Remove the CAM SIMs */
while|while
condition|(
operator|(
name|sim
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|aac_sim_tqh
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|aac_sim_tqh
argument_list|,
name|sim
argument_list|,
name|sim_link
argument_list|)
expr_stmt|;
name|error
operator|=
name|device_delete_child
argument_list|(
name|dev
argument_list|,
name|sim
operator|->
name|sim_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|free
argument_list|(
name|sim
argument_list|,
name|M_AACBUF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|aifflags
operator|&
name|AAC_AIFFLAGS_RUNNING
condition|)
block|{
name|sc
operator|->
name|aifflags
operator||=
name|AAC_AIFFLAGS_EXIT
expr_stmt|;
name|wakeup
argument_list|(
name|sc
operator|->
name|aifthread
argument_list|)
expr_stmt|;
name|tsleep
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
name|PUSER
operator||
name|PCATCH
argument_list|,
literal|"aacdch"
argument_list|,
literal|30
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|aifflags
operator|&
name|AAC_AIFFLAGS_RUNNING
condition|)
name|panic
argument_list|(
literal|"Cannot shutdown AIF thread\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|aac_shutdown
argument_list|(
name|dev
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|shutdown_final
argument_list|,
name|sc
operator|->
name|eh
argument_list|)
expr_stmt|;
name|aac_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Bring the controller down to a dormant state and detach all child devices.  *  * This function is called before detach or system shutdown.  *  * Note that we can assume that the bioq on the controller is empty, as we won't  * allow shutdown if any device is open.  */
end_comment

begin_function
name|int
name|aac_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|aac_fib
modifier|*
name|fib
decl_stmt|;
name|struct
name|aac_close_command
modifier|*
name|cc
decl_stmt|;
name|int
name|s
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|sc
operator|->
name|aac_state
operator||=
name|AAC_STATE_SUSPEND
expr_stmt|;
comment|/*  	 * Send a Container shutdown followed by a HostShutdown FIB to the 	 * controller to convince it that we don't want to talk to it anymore. 	 * We've been closed and all I/O completed already 	 */
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"shutting down controller..."
argument_list|)
expr_stmt|;
name|aac_alloc_sync_fib
argument_list|(
name|sc
argument_list|,
operator|&
name|fib
argument_list|,
name|AAC_SYNC_LOCK_FORCE
argument_list|)
expr_stmt|;
name|cc
operator|=
operator|(
expr|struct
name|aac_close_command
operator|*
operator|)
operator|&
name|fib
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
name|bzero
argument_list|(
name|cc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_close_command
argument_list|)
argument_list|)
expr_stmt|;
name|cc
operator|->
name|Command
operator|=
name|VM_CloseAll
expr_stmt|;
name|cc
operator|->
name|ContainerId
operator|=
literal|0xffffffff
expr_stmt|;
if|if
condition|(
name|aac_sync_fib
argument_list|(
name|sc
argument_list|,
name|ContainerCommand
argument_list|,
literal|0
argument_list|,
name|fib
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_close_command
argument_list|)
argument_list|)
condition|)
name|printf
argument_list|(
literal|"FAILED.\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"done\n"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|else { 		fib->data[0] = 0;
comment|/* 		 * XXX Issuing this command to the controller makes it shut down 		 * but also keeps it from coming back up without a reset of the 		 * PCI bus.  This is not desirable if you are just unloading the 		 * driver module with the intent to reload it later. 		 */
block|if (aac_sync_fib(sc, FsaHostShutdown, AAC_FIBSTATE_SHUTDOWN, 		    fib, 1)) { 			printf("FAILED.\n"); 		} else { 			printf("done.\n"); 		} 	}
endif|#
directive|endif
name|AAC_MASK_INTERRUPTS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Bring the controller to a quiescent state, ready for system suspend.  */
end_comment

begin_function
name|int
name|aac_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|s
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|sc
operator|->
name|aac_state
operator||=
name|AAC_STATE_SUSPEND
expr_stmt|;
name|AAC_MASK_INTERRUPTS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Bring the controller back to a state ready for operation.  */
end_comment

begin_function
name|int
name|aac_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|aac_state
operator|&=
operator|~
name|AAC_STATE_SUSPEND
expr_stmt|;
name|AAC_UNMASK_INTERRUPTS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Take an interrupt.  */
end_comment

begin_function
name|void
name|aac_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
decl_stmt|;
name|u_int32_t
modifier|*
name|resp_queue
decl_stmt|;
name|u_int16_t
name|reason
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|aac_softc
operator|*
operator|)
name|arg
expr_stmt|;
comment|/* 	 * Optimize the common case of adapter response interrupts. 	 * We must read from the card prior to processing the responses 	 * to ensure the clear is flushed prior to accessing the queues. 	 * Reading the queues from local memory might save us a PCI read. 	 */
name|resp_queue
operator|=
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|AAC_HOST_NORM_RESP_QUEUE
index|]
expr_stmt|;
if|if
condition|(
name|resp_queue
index|[
name|AAC_PRODUCER_INDEX
index|]
operator|!=
name|resp_queue
index|[
name|AAC_CONSUMER_INDEX
index|]
condition|)
name|reason
operator|=
name|AAC_DB_RESPONSE_READY
expr_stmt|;
else|else
name|reason
operator|=
name|AAC_GET_ISTATUS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|AAC_CLEAR_ISTATUS
argument_list|(
name|sc
argument_list|,
name|reason
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|AAC_GET_ISTATUS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* It's not ok to return here because of races with the previous step */
if|if
condition|(
name|reason
operator|&
name|AAC_DB_RESPONSE_READY
condition|)
comment|/* handle completion processing */
name|taskqueue_enqueue
argument_list|(
name|taskqueue_swi
argument_list|,
operator|&
name|sc
operator|->
name|aac_task_complete
argument_list|)
expr_stmt|;
comment|/* controller wants to talk to the log */
if|if
condition|(
name|reason
operator|&
name|AAC_DB_PRINTF
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|aifflags
operator|&
name|AAC_AIFFLAGS_RUNNING
condition|)
block|{
name|sc
operator|->
name|aifflags
operator||=
name|AAC_AIFFLAGS_PRINTF
expr_stmt|;
block|}
else|else
name|aac_print_printf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* controller has a message for us? */
if|if
condition|(
name|reason
operator|&
name|AAC_DB_COMMAND_READY
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|aifflags
operator|&
name|AAC_AIFFLAGS_RUNNING
condition|)
block|{
name|sc
operator|->
name|aifflags
operator||=
name|AAC_AIFFLAGS_AIF
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * XXX If the kthread is dead and we're at this point, 			 * there are bigger problems than just figuring out 			 * what to do with an AIF. 			 */
block|}
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|aifflags
operator|&
name|AAC_AIFFLAGS_PENDING
operator|)
operator|!=
literal|0
condition|)
comment|/* XXX Should this be done with cv_signal? */
name|wakeup
argument_list|(
name|sc
operator|->
name|aifthread
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Command Processing  */
end_comment

begin_comment
comment|/*  * Start as much queued I/O as possible on the controller  */
end_comment

begin_function
name|void
name|aac_startio
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|aac_command
modifier|*
name|cm
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Try to get a command that's been put off for lack of  		 * resources 		 */
name|cm
operator|=
name|aac_dequeue_ready
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 		 * Try to build a command off the bio queue (ignore error  		 * return) 		 */
if|if
condition|(
name|cm
operator|==
name|NULL
condition|)
name|aac_bio_command
argument_list|(
name|sc
argument_list|,
operator|&
name|cm
argument_list|)
expr_stmt|;
comment|/* nothing to do? */
if|if
condition|(
name|cm
operator|==
name|NULL
condition|)
break|break;
comment|/* try to give the command to the controller */
if|if
condition|(
name|aac_start
argument_list|(
name|cm
argument_list|)
operator|==
name|EBUSY
condition|)
block|{
comment|/* put it on the ready queue for later */
name|aac_requeue_ready
argument_list|(
name|cm
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Deliver a command to the controller; allocate controller resources at the  * last moment when possible.  */
end_comment

begin_function
specifier|static
name|int
name|aac_start
parameter_list|(
name|struct
name|aac_command
modifier|*
name|cm
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|=
name|cm
operator|->
name|cm_sc
expr_stmt|;
comment|/* get the command mapped */
name|aac_map_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
comment|/* fix up the address values in the FIB */
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|SenderFibAddress
operator|=
operator|(
name|u_int32_t
operator|)
name|cm
operator|->
name|cm_fib
expr_stmt|;
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|ReceiverFibAddress
operator|=
name|cm
operator|->
name|cm_fibphys
expr_stmt|;
comment|/* save a pointer to the command for speedy reverse-lookup */
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|SenderData
operator|=
operator|(
name|u_int32_t
operator|)
name|cm
expr_stmt|;
comment|/* XXX 64-bit physical 							 * address issue */
comment|/* put the FIB on the outbound queue */
name|error
operator|=
name|aac_enqueue_fib
argument_list|(
name|sc
argument_list|,
name|cm
operator|->
name|cm_queue
argument_list|,
name|cm
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle notification of one or more FIBs coming from the controller.  */
end_comment

begin_function
specifier|static
name|void
name|aac_command_thread
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|aac_fib
modifier|*
name|fib
decl_stmt|;
name|u_int32_t
name|fib_size
decl_stmt|;
name|int
name|size
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|->
name|aifflags
operator||=
name|AAC_AIFFLAGS_RUNNING
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|sc
operator|->
name|aifflags
operator|&
name|AAC_AIFFLAGS_EXIT
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|aifflags
operator|&
name|AAC_AIFFLAGS_PENDING
operator|)
operator|==
literal|0
condition|)
name|tsleep
argument_list|(
name|sc
operator|->
name|aifthread
argument_list|,
name|PRIBIO
argument_list|,
literal|"aifthd"
argument_list|,
name|AAC_PERIODIC_INTERVAL
operator|*
name|hz
argument_list|)
expr_stmt|;
comment|/* While we're here, check to see if any commands are stuck */
if|if
condition|(
operator|(
name|sc
operator|->
name|aifflags
operator|&
name|AAC_AIFFLAGS_PENDING
operator|)
operator|==
literal|0
condition|)
name|aac_timeout
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Check the hardware printf message buffer */
if|if
condition|(
operator|(
name|sc
operator|->
name|aifflags
operator|&
name|AAC_AIFFLAGS_PRINTF
operator|)
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|aifflags
operator|&=
operator|~
name|AAC_AIFFLAGS_PRINTF
expr_stmt|;
name|aac_print_printf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|sc
operator|->
name|aifflags
operator|&
name|AAC_AIFFLAGS_AIF
condition|)
block|{
if|if
condition|(
name|aac_dequeue_fib
argument_list|(
name|sc
argument_list|,
name|AAC_HOST_NORM_CMD_QUEUE
argument_list|,
operator|&
name|fib_size
argument_list|,
operator|&
name|fib
argument_list|)
condition|)
block|{
name|sc
operator|->
name|aifflags
operator|&=
operator|~
name|AAC_AIFFLAGS_AIF
expr_stmt|;
break|break;
comment|/* nothing to do */
block|}
name|AAC_PRINT_FIB
argument_list|(
name|sc
argument_list|,
name|fib
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fib
operator|->
name|Header
operator|.
name|Command
condition|)
block|{
case|case
name|AifRequest
case|:
name|aac_handle_aif
argument_list|(
name|sc
argument_list|,
name|fib
argument_list|)
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"unknown command "
literal|"from controller\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|fib
operator|->
name|Header
operator|.
name|XferState
operator|==
literal|0
operator|)
operator|||
operator|(
name|fib
operator|->
name|Header
operator|.
name|StructType
operator|!=
name|AAC_FIBTYPE_TFIB
operator|)
condition|)
break|break;
comment|/* Return the AIF to the controller. */
if|if
condition|(
name|fib
operator|->
name|Header
operator|.
name|XferState
operator|&
name|AAC_FIBSTATE_FROMADAP
condition|)
block|{
name|fib
operator|->
name|Header
operator|.
name|XferState
operator||=
name|AAC_FIBSTATE_DONEHOST
expr_stmt|;
operator|*
operator|(
name|AAC_FSAStatus
operator|*
operator|)
name|fib
operator|->
name|data
operator|=
name|ST_OK
expr_stmt|;
comment|/* XXX Compute the Size field? */
name|size
operator|=
name|fib
operator|->
name|Header
operator|.
name|Size
expr_stmt|;
if|if
condition|(
name|size
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
condition|)
block|{
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|Size
operator|=
name|size
expr_stmt|;
block|}
comment|/* 				 * Since we did not generate this command, it 				 * cannot go through the normal 				 * enqueue->startio chain. 				 */
name|aac_enqueue_response
argument_list|(
name|sc
argument_list|,
name|AAC_ADAP_NORM_RESP_QUEUE
argument_list|,
name|fib
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|sc
operator|->
name|aifflags
operator|&=
operator|~
name|AAC_AIFFLAGS_RUNNING
expr_stmt|;
name|wakeup
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>
literal|500005
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|kthread_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process completed commands.  */
end_comment

begin_function
specifier|static
name|void
name|aac_complete
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|aac_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|aac_fib
modifier|*
name|fib
decl_stmt|;
name|u_int32_t
name|fib_size
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|aac_softc
operator|*
operator|)
name|context
expr_stmt|;
comment|/* pull completed commands off the queue */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* look for completed FIBs on our queue */
if|if
condition|(
name|aac_dequeue_fib
argument_list|(
name|sc
argument_list|,
name|AAC_HOST_NORM_RESP_QUEUE
argument_list|,
operator|&
name|fib_size
argument_list|,
operator|&
name|fib
argument_list|)
condition|)
break|break;
comment|/* nothing to do */
comment|/* get the command, unmap and queue for later processing */
name|cm
operator|=
operator|(
expr|struct
name|aac_command
operator|*
operator|)
name|fib
operator|->
name|Header
operator|.
name|SenderData
expr_stmt|;
if|if
condition|(
name|cm
operator|==
name|NULL
condition|)
block|{
name|AAC_PRINT_FIB
argument_list|(
name|sc
argument_list|,
name|fib
argument_list|)
expr_stmt|;
break|break;
block|}
name|aac_remove_busy
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|aac_unmap_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
comment|/* XXX defer? */
name|cm
operator|->
name|cm_flags
operator||=
name|AAC_CMD_COMPLETED
expr_stmt|;
comment|/* is there a completion handler? */
if|if
condition|(
name|cm
operator|->
name|cm_complete
operator|!=
name|NULL
condition|)
block|{
name|cm
operator|->
name|cm_complete
argument_list|(
name|cm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* assume that someone is sleeping on this command */
name|wakeup
argument_list|(
name|cm
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* see if we can start some more I/O */
name|aac_startio
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle a bio submitted from a disk device.  */
end_comment

begin_function
name|void
name|aac_submit_bio
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|aac_disk
modifier|*
name|ad
decl_stmt|;
name|struct
name|aac_softc
modifier|*
name|sc
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|ad
operator|=
operator|(
expr|struct
name|aac_disk
operator|*
operator|)
name|bp
operator|->
name|bio_dev
operator|->
name|si_drv1
expr_stmt|;
name|sc
operator|=
name|ad
operator|->
name|ad_controller
expr_stmt|;
comment|/* queue the BIO and try to get some work done */
name|aac_enqueue_bio
argument_list|(
name|sc
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|aac_startio
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get a bio and build a command to go with it.  */
end_comment

begin_function
specifier|static
name|int
name|aac_bio_command
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|aac_command
modifier|*
modifier|*
name|cmp
parameter_list|)
block|{
name|struct
name|aac_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|aac_fib
modifier|*
name|fib
decl_stmt|;
name|struct
name|aac_blockread
modifier|*
name|br
decl_stmt|;
name|struct
name|aac_blockwrite
modifier|*
name|bw
decl_stmt|;
name|struct
name|aac_disk
modifier|*
name|ad
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* get the resources we will need */
name|cm
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|=
name|aac_dequeue_bio
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|aac_alloc_command
argument_list|(
name|sc
argument_list|,
operator|&
name|cm
argument_list|)
condition|)
comment|/* get a command */
goto|goto
name|fail
goto|;
comment|/* fill out the command */
name|cm
operator|->
name|cm_data
operator|=
operator|(
name|void
operator|*
operator|)
name|bp
operator|->
name|bio_data
expr_stmt|;
name|cm
operator|->
name|cm_datalen
operator|=
name|bp
operator|->
name|bio_bcount
expr_stmt|;
name|cm
operator|->
name|cm_complete
operator|=
name|aac_bio_complete
expr_stmt|;
name|cm
operator|->
name|cm_private
operator|=
name|bp
expr_stmt|;
name|cm
operator|->
name|cm_timestamp
operator|=
name|time_second
expr_stmt|;
name|cm
operator|->
name|cm_queue
operator|=
name|AAC_ADAP_NORM_CMD_QUEUE
expr_stmt|;
comment|/* build the FIB */
name|fib
operator|=
name|cm
operator|->
name|cm_fib
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|XferState
operator|=
name|AAC_FIBSTATE_HOSTOWNED
operator||
name|AAC_FIBSTATE_INITIALISED
operator||
name|AAC_FIBSTATE_EMPTY
operator||
name|AAC_FIBSTATE_FROMHOST
operator||
name|AAC_FIBSTATE_REXPECTED
operator||
name|AAC_FIBSTATE_NORM
operator||
name|AAC_FIBSTATE_ASYNC
operator||
name|AAC_FIBSTATE_FAST_RESPONSE
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|Command
operator|=
name|ContainerCommand
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|Size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib_header
argument_list|)
expr_stmt|;
comment|/* build the read/write request */
name|ad
operator|=
operator|(
expr|struct
name|aac_disk
operator|*
operator|)
name|bp
operator|->
name|bio_dev
operator|->
name|si_drv1
expr_stmt|;
if|if
condition|(
name|BIO_IS_READ
argument_list|(
name|bp
argument_list|)
condition|)
block|{
name|br
operator|=
operator|(
expr|struct
name|aac_blockread
operator|*
operator|)
operator|&
name|fib
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
name|br
operator|->
name|Command
operator|=
name|VM_CtBlockRead
expr_stmt|;
name|br
operator|->
name|ContainerId
operator|=
name|ad
operator|->
name|ad_container
operator|->
name|co_mntobj
operator|.
name|ObjectId
expr_stmt|;
name|br
operator|->
name|BlockNumber
operator|=
name|bp
operator|->
name|bio_pblkno
expr_stmt|;
name|br
operator|->
name|ByteCount
operator|=
name|bp
operator|->
name|bio_bcount
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|Size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|aac_blockread
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_sgtable
operator|=
operator|&
name|br
operator|->
name|SgMap
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator||=
name|AAC_CMD_DATAIN
expr_stmt|;
block|}
else|else
block|{
name|bw
operator|=
operator|(
expr|struct
name|aac_blockwrite
operator|*
operator|)
operator|&
name|fib
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
name|bw
operator|->
name|Command
operator|=
name|VM_CtBlockWrite
expr_stmt|;
name|bw
operator|->
name|ContainerId
operator|=
name|ad
operator|->
name|ad_container
operator|->
name|co_mntobj
operator|.
name|ObjectId
expr_stmt|;
name|bw
operator|->
name|BlockNumber
operator|=
name|bp
operator|->
name|bio_pblkno
expr_stmt|;
name|bw
operator|->
name|ByteCount
operator|=
name|bp
operator|->
name|bio_bcount
expr_stmt|;
name|bw
operator|->
name|Stable
operator|=
name|CUNSTABLE
expr_stmt|;
comment|/* XXX what's appropriate here? */
name|fib
operator|->
name|Header
operator|.
name|Size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|aac_blockwrite
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator||=
name|AAC_CMD_DATAOUT
expr_stmt|;
name|cm
operator|->
name|cm_sgtable
operator|=
operator|&
name|bw
operator|->
name|SgMap
expr_stmt|;
block|}
operator|*
name|cmp
operator|=
name|cm
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
name|aac_enqueue_bio
argument_list|(
name|sc
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|!=
name|NULL
condition|)
name|aac_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle a bio-instigated command that has been completed.  */
end_comment

begin_function
specifier|static
name|void
name|aac_bio_complete
parameter_list|(
name|struct
name|aac_command
modifier|*
name|cm
parameter_list|)
block|{
name|struct
name|aac_blockread_response
modifier|*
name|brr
decl_stmt|;
name|struct
name|aac_blockwrite_response
modifier|*
name|bwr
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|AAC_FSAStatus
name|status
decl_stmt|;
comment|/* fetch relevant status and then release the command */
name|bp
operator|=
operator|(
expr|struct
name|bio
operator|*
operator|)
name|cm
operator|->
name|cm_private
expr_stmt|;
if|if
condition|(
name|BIO_IS_READ
argument_list|(
name|bp
argument_list|)
condition|)
block|{
name|brr
operator|=
operator|(
expr|struct
name|aac_blockread_response
operator|*
operator|)
operator|&
name|cm
operator|->
name|cm_fib
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
name|status
operator|=
name|brr
operator|->
name|Status
expr_stmt|;
block|}
else|else
block|{
name|bwr
operator|=
operator|(
expr|struct
name|aac_blockwrite_response
operator|*
operator|)
operator|&
name|cm
operator|->
name|cm_fib
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
name|status
operator|=
name|bwr
operator|->
name|Status
expr_stmt|;
block|}
name|aac_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
comment|/* fix up the bio based on status */
if|if
condition|(
name|status
operator|==
name|ST_OK
condition|)
block|{
name|bp
operator|->
name|bio_resid
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|bp
operator|->
name|bio_error
operator|=
name|EIO
expr_stmt|;
name|bp
operator|->
name|bio_flags
operator||=
name|BIO_ERROR
expr_stmt|;
comment|/* pass an error string out to the disk layer */
name|bp
operator|->
name|bio_driver1
operator|=
name|aac_describe_code
argument_list|(
name|aac_command_status_table
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
name|aac_biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Submit a command to the controller, return when it completes.  * XXX This is very dangerous!  If the card has gone out to lunch, we could  *     be stuck here forever.  At the same time, signals are not caught  *     because there is a risk that a signal could wakeup the tsleep before  *     the card has a chance to complete the command.  The passed in timeout  *     is ignored for the same reason.  Since there is no way to cancel a  *     command in progress, we should probably create a 'dead' queue where  *     commands go that have been interrupted/timed-out/etc, that keeps them  *     out of the free pool.  That way, if the card is just slow, it won't  *     spam the memory of a command that has been recycled.  */
end_comment

begin_function
specifier|static
name|int
name|aac_wait_command
parameter_list|(
name|struct
name|aac_command
modifier|*
name|cm
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* Put the command on the ready queue and get things going */
name|cm
operator|->
name|cm_queue
operator|=
name|AAC_ADAP_NORM_CMD_QUEUE
expr_stmt|;
name|aac_enqueue_ready
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|aac_startio
argument_list|(
name|cm
operator|->
name|cm_sc
argument_list|)
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|cm
operator|->
name|cm_flags
operator|&
name|AAC_CMD_COMPLETED
operator|)
operator|&&
operator|(
name|error
operator|!=
name|EWOULDBLOCK
operator|)
condition|)
block|{
name|error
operator|=
name|tsleep
argument_list|(
name|cm
argument_list|,
name|PRIBIO
argument_list|,
literal|"aacwait"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *Command Buffer Management  */
end_comment

begin_comment
comment|/*  * Allocate a command.  */
end_comment

begin_function
name|int
name|aac_alloc_command
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|aac_command
modifier|*
modifier|*
name|cmp
parameter_list|)
block|{
name|struct
name|aac_command
modifier|*
name|cm
decl_stmt|;
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|=
name|aac_dequeue_free
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|aac_alloc_commands
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|cm
operator|=
name|aac_dequeue_free
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
operator|*
name|cmp
operator|=
name|cm
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Release a command back to the freelist.  */
end_comment

begin_function
name|void
name|aac_release_command
parameter_list|(
name|struct
name|aac_command
modifier|*
name|cm
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
comment|/* (re)initialise the command/FIB */
name|cm
operator|->
name|cm_sgtable
operator|=
name|NULL
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator|=
literal|0
expr_stmt|;
name|cm
operator|->
name|cm_complete
operator|=
name|NULL
expr_stmt|;
name|cm
operator|->
name|cm_private
operator|=
name|NULL
expr_stmt|;
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|XferState
operator|=
name|AAC_FIBSTATE_EMPTY
expr_stmt|;
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|StructType
operator|=
name|AAC_FIBTYPE_TFIB
expr_stmt|;
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|Flags
operator|=
literal|0
expr_stmt|;
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|SenderSize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
expr_stmt|;
comment|/*  	 * These are duplicated in aac_start to cover the case where an 	 * intermediate stage may have destroyed them.  They're left 	 * initialised here for debugging purposes only. 	 */
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|SenderFibAddress
operator|=
operator|(
name|u_int32_t
operator|)
name|cm
operator|->
name|cm_fib
expr_stmt|;
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|ReceiverFibAddress
operator|=
operator|(
name|u_int32_t
operator|)
name|cm
operator|->
name|cm_fibphys
expr_stmt|;
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|SenderData
operator|=
literal|0
expr_stmt|;
name|aac_enqueue_free
argument_list|(
name|cm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Map helper for command/FIB allocation.  */
end_comment

begin_function
specifier|static
name|void
name|aac_map_command_helper
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|uint32_t
modifier|*
name|fibphys
decl_stmt|;
name|fibphys
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|arg
expr_stmt|;
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
operator|*
name|fibphys
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate and initialise commands/FIBs for this adapter.  */
end_comment

begin_function
specifier|static
name|int
name|aac_alloc_commands
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|aac_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|aac_fibmap
modifier|*
name|fm
decl_stmt|;
name|uint32_t
name|fibphys
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|total_fibs
operator|+
name|AAC_FIB_COUNT
operator|>
name|AAC_MAX_FIBS
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|fm
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fibmap
argument_list|)
argument_list|,
name|M_AACBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
comment|/* allocate the FIBs in DMAable memory and load them */
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|aac_fib_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|fm
operator|->
name|aac_fibs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|fm
operator|->
name|aac_fibmap
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"Not enough contiguous memory available.\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fm
argument_list|,
name|M_AACBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|aac_fib_dmat
argument_list|,
name|fm
operator|->
name|aac_fibmap
argument_list|,
name|fm
operator|->
name|aac_fibs
argument_list|,
name|AAC_FIB_COUNT
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
argument_list|,
name|aac_map_command_helper
argument_list|,
operator|&
name|fibphys
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* initialise constant fields in the command structure */
name|bzero
argument_list|(
name|fm
operator|->
name|aac_fibs
argument_list|,
name|AAC_FIB_COUNT
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AAC_FIB_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|cm
operator|=
name|sc
operator|->
name|aac_commands
operator|+
name|sc
operator|->
name|total_fibs
expr_stmt|;
name|fm
operator|->
name|aac_commands
operator|=
name|cm
expr_stmt|;
name|cm
operator|->
name|cm_sc
operator|=
name|sc
expr_stmt|;
name|cm
operator|->
name|cm_fib
operator|=
name|fm
operator|->
name|aac_fibs
operator|+
name|i
expr_stmt|;
name|cm
operator|->
name|cm_fibphys
operator|=
name|fibphys
operator|+
operator|(
name|i
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|aac_buffer_dmat
argument_list|,
literal|0
argument_list|,
operator|&
name|cm
operator|->
name|cm_datamap
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|aac_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
else|else
break|break;
name|sc
operator|->
name|total_fibs
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|aac_fibmap_tqh
argument_list|,
name|fm
argument_list|,
name|fm_link
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|aac_fib_dmat
argument_list|,
name|fm
operator|->
name|aac_fibmap
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|aac_fib_dmat
argument_list|,
name|fm
operator|->
name|aac_fibs
argument_list|,
name|fm
operator|->
name|aac_fibmap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fm
argument_list|,
name|M_AACBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free FIBs owned by this adapter.  */
end_comment

begin_function
specifier|static
name|void
name|aac_free_commands
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|aac_fibmap
modifier|*
name|fm
decl_stmt|;
name|struct
name|aac_command
modifier|*
name|cm
decl_stmt|;
name|int
name|i
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|fm
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|aac_fibmap_tqh
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|aac_fibmap_tqh
argument_list|,
name|fm
argument_list|,
name|fm_link
argument_list|)
expr_stmt|;
comment|/* 		 * We check against total_fibs to handle partially 		 * allocated blocks. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AAC_FIB_COUNT
operator|&&
name|sc
operator|->
name|total_fibs
operator|--
condition|;
name|i
operator|++
control|)
block|{
name|cm
operator|=
name|fm
operator|->
name|aac_commands
operator|+
name|i
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|aac_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_datamap
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|aac_fib_dmat
argument_list|,
name|fm
operator|->
name|aac_fibmap
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|aac_fib_dmat
argument_list|,
name|fm
operator|->
name|aac_fibs
argument_list|,
name|fm
operator|->
name|aac_fibmap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fm
argument_list|,
name|M_AACBUF
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Command-mapping helper function - populate this command's s/g table.  */
end_comment

begin_function
specifier|static
name|void
name|aac_map_command_sg
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|aac_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|aac_fib
modifier|*
name|fib
decl_stmt|;
name|struct
name|aac_sg_table
modifier|*
name|sg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|cm
operator|=
operator|(
expr|struct
name|aac_command
operator|*
operator|)
name|arg
expr_stmt|;
name|fib
operator|=
name|cm
operator|->
name|cm_fib
expr_stmt|;
comment|/* find the s/g table */
name|sg
operator|=
name|cm
operator|->
name|cm_sgtable
expr_stmt|;
comment|/* copy into the FIB */
if|if
condition|(
name|sg
operator|!=
name|NULL
condition|)
block|{
name|sg
operator|->
name|SgCount
operator|=
name|nseg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nseg
condition|;
name|i
operator|++
control|)
block|{
name|sg
operator|->
name|SgEntry
index|[
name|i
index|]
operator|.
name|SgAddress
operator|=
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
expr_stmt|;
name|sg
operator|->
name|SgEntry
index|[
name|i
index|]
operator|.
name|SgByteCount
operator|=
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
expr_stmt|;
block|}
comment|/* update the FIB size for the s/g count */
name|fib
operator|->
name|Header
operator|.
name|Size
operator|+=
name|nseg
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|aac_sg_entry
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Map a command into controller-visible space.  */
end_comment

begin_function
specifier|static
name|void
name|aac_map_command
parameter_list|(
name|struct
name|aac_command
modifier|*
name|cm
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|=
name|cm
operator|->
name|cm_sc
expr_stmt|;
comment|/* don't map more than once */
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|AAC_CMD_MAPPED
condition|)
return|return;
if|if
condition|(
name|cm
operator|->
name|cm_datalen
operator|!=
literal|0
condition|)
block|{
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|aac_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_datamap
argument_list|,
name|cm
operator|->
name|cm_data
argument_list|,
name|cm
operator|->
name|cm_datalen
argument_list|,
name|aac_map_command_sg
argument_list|,
name|cm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|AAC_CMD_DATAIN
condition|)
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|aac_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_datamap
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|AAC_CMD_DATAOUT
condition|)
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|aac_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_datamap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
name|cm
operator|->
name|cm_flags
operator||=
name|AAC_CMD_MAPPED
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Unmap a command from controller-visible space.  */
end_comment

begin_function
specifier|static
name|void
name|aac_unmap_command
parameter_list|(
name|struct
name|aac_command
modifier|*
name|cm
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|=
name|cm
operator|->
name|cm_sc
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cm
operator|->
name|cm_flags
operator|&
name|AAC_CMD_MAPPED
operator|)
condition|)
return|return;
if|if
condition|(
name|cm
operator|->
name|cm_datalen
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|AAC_CMD_DATAIN
condition|)
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|aac_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_datamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|AAC_CMD_DATAOUT
condition|)
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|aac_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_datamap
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|aac_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_datamap
argument_list|)
expr_stmt|;
block|}
name|cm
operator|->
name|cm_flags
operator|&=
operator|~
name|AAC_CMD_MAPPED
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Hardware Interface  */
end_comment

begin_comment
comment|/*  * Initialise the adapter.  */
end_comment

begin_function
specifier|static
name|void
name|aac_common_map
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|aac_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|sc
operator|->
name|aac_common_busaddr
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Retrieve the firmware version numbers.  Dell PERC2/QC cards with  * firmware version 1.x are not compatible with this driver.  */
end_comment

begin_function
specifier|static
name|int
name|aac_check_firmware
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int32_t
name|major
decl_stmt|,
name|minor
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|quirks
operator|&
name|AAC_QUIRK_PERC2QC
condition|)
block|{
if|if
condition|(
name|aac_sync_command
argument_list|(
name|sc
argument_list|,
name|AAC_MONKER_GETKERNVER
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"Error reading firmware version\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* These numbers are stored as ASCII! */
name|major
operator|=
operator|(
name|AAC_GETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SA_MAILBOX
operator|+
literal|4
argument_list|)
operator|&
literal|0xff
operator|)
operator|-
literal|0x30
expr_stmt|;
name|minor
operator|=
operator|(
name|AAC_GETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SA_MAILBOX
operator|+
literal|8
argument_list|)
operator|&
literal|0xff
operator|)
operator|-
literal|0x30
expr_stmt|;
if|if
condition|(
name|major
operator|==
literal|1
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"Firmware version %d.%d is not supported.\n"
argument_list|,
name|major
argument_list|,
name|minor
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aac_init
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|aac_adapter_init
modifier|*
name|ip
decl_stmt|;
name|time_t
name|then
decl_stmt|;
name|u_int32_t
name|code
decl_stmt|;
name|u_int8_t
modifier|*
name|qaddr
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * First wait for the adapter to come ready. 	 */
name|then
operator|=
name|time_second
expr_stmt|;
do|do
block|{
name|code
operator|=
name|AAC_GET_FWSTATUS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|&
name|AAC_SELF_TEST_FAILED
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"FATAL: selftest failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|code
operator|&
name|AAC_KERNEL_PANIC
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"FATAL: controller kernel panic\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|time_second
operator|>
operator|(
name|then
operator|+
name|AAC_BOOT_TIMEOUT
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"FATAL: controller not coming ready, "
literal|"status %x\n"
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
do|while
condition|(
operator|!
operator|(
name|code
operator|&
name|AAC_UP_AND_RUNNING
operator|)
condition|)
do|;
comment|/* 	 * Create DMA tag for the common structure and allocate it. 	 */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|aac_parent_dmat
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
literal|8192
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|aac_common
argument_list|)
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
operator|&
name|sc
operator|->
name|aac_common_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"can't allocate common structure DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|aac_common_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|aac_common
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|aac_common_dmamap
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"can't allocate common structure\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* 	 * Work around a bug in the 2120 and 2200 that cannot DMA commands 	 * below address 8192 in physical memory. 	 * XXX If the padding is not needed, can it be put to use instead 	 * of ignored? 	 */
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|aac_common_dmat
argument_list|,
name|sc
operator|->
name|aac_common_dmamap
argument_list|,
name|sc
operator|->
name|aac_common
argument_list|,
literal|8192
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|sc
operator|->
name|aac_common
argument_list|)
argument_list|,
name|aac_common_map
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|aac_common_busaddr
operator|<
literal|8192
condition|)
block|{
operator|(
name|uint8_t
operator|*
operator|)
name|sc
operator|->
name|aac_common
operator|+=
literal|8192
expr_stmt|;
name|sc
operator|->
name|aac_common_busaddr
operator|+=
literal|8192
expr_stmt|;
block|}
name|bzero
argument_list|(
name|sc
operator|->
name|aac_common
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
operator|->
name|aac_common
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allocate some FIBs and associated command structs */
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|aac_fibmap_tqh
argument_list|)
expr_stmt|;
name|sc
operator|->
name|aac_commands
operator|=
name|malloc
argument_list|(
name|AAC_MAX_FIBS
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|aac_command
argument_list|)
argument_list|,
name|M_AACBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|total_fibs
operator|<
name|AAC_PREALLOCATE_FIBS
condition|)
block|{
if|if
condition|(
name|aac_alloc_commands
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|sc
operator|->
name|total_fibs
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* 	 * Fill in the init structure.  This tells the adapter about the 	 * physical location of various important shared data structures. 	 */
name|ip
operator|=
operator|&
name|sc
operator|->
name|aac_common
operator|->
name|ac_init
expr_stmt|;
name|ip
operator|->
name|InitStructRevision
operator|=
name|AAC_INIT_STRUCT_REVISION
expr_stmt|;
name|ip
operator|->
name|MiniPortRevision
operator|=
name|AAC_INIT_STRUCT_MINIPORT_REVISION
expr_stmt|;
name|ip
operator|->
name|AdapterFibsPhysicalAddress
operator|=
name|sc
operator|->
name|aac_common_busaddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|aac_common
argument_list|,
name|ac_fibs
argument_list|)
expr_stmt|;
name|ip
operator|->
name|AdapterFibsVirtualAddress
operator|=
operator|(
name|u_int32_t
operator|)
operator|&
name|sc
operator|->
name|aac_common
operator|->
name|ac_fibs
index|[
literal|0
index|]
expr_stmt|;
name|ip
operator|->
name|AdapterFibsSize
operator|=
name|AAC_ADAPTER_FIBS
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
expr_stmt|;
name|ip
operator|->
name|AdapterFibAlign
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
expr_stmt|;
name|ip
operator|->
name|PrintfBufferAddress
operator|=
name|sc
operator|->
name|aac_common_busaddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|aac_common
argument_list|,
name|ac_printf
argument_list|)
expr_stmt|;
name|ip
operator|->
name|PrintfBufferSize
operator|=
name|AAC_PRINTF_BUFSIZE
expr_stmt|;
comment|/* The adapter assumes that pages are 4K in size */
name|ip
operator|->
name|HostPhysMemPages
operator|=
name|ctob
argument_list|(
name|physmem
argument_list|)
operator|/
name|AAC_PAGE_SIZE
expr_stmt|;
name|ip
operator|->
name|HostElapsedSeconds
operator|=
name|time_second
expr_stmt|;
comment|/* reset later if invalid */
comment|/* 	 * Initialise FIB queues.  Note that it appears that the layout of the 	 * indexes and the segmentation of the entries may be mandated by the 	 * adapter, which is only told about the base of the queue index fields. 	 * 	 * The initial values of the indices are assumed to inform the adapter 	 * of the sizes of the respective queues, and theoretically it could  	 * work out the entire layout of the queue structures from this.  We 	 * take the easy route and just lay this area out like everyone else 	 * does. 	 * 	 * The Linux driver uses a much more complex scheme whereby several  	 * header records are kept for each queue.  We use a couple of generic  	 * list manipulation functions which 'know' the size of each list by 	 * virtue of a table. 	 */
name|qaddr
operator|=
operator|&
name|sc
operator|->
name|aac_common
operator|->
name|ac_qbuf
index|[
literal|0
index|]
operator|+
name|AAC_QUEUE_ALIGN
expr_stmt|;
name|qaddr
operator|-=
operator|(
name|u_int32_t
operator|)
name|qaddr
operator|%
name|AAC_QUEUE_ALIGN
expr_stmt|;
name|sc
operator|->
name|aac_queues
operator|=
operator|(
expr|struct
name|aac_queue_table
operator|*
operator|)
name|qaddr
expr_stmt|;
name|ip
operator|->
name|CommHeaderAddress
operator|=
name|sc
operator|->
name|aac_common_busaddr
operator|+
operator|(
operator|(
name|u_int32_t
operator|)
name|sc
operator|->
name|aac_queues
operator|-
operator|(
name|u_int32_t
operator|)
name|sc
operator|->
name|aac_common
operator|)
expr_stmt|;
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|AAC_HOST_NORM_CMD_QUEUE
index|]
index|[
name|AAC_PRODUCER_INDEX
index|]
operator|=
name|AAC_HOST_NORM_CMD_ENTRIES
expr_stmt|;
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|AAC_HOST_NORM_CMD_QUEUE
index|]
index|[
name|AAC_CONSUMER_INDEX
index|]
operator|=
name|AAC_HOST_NORM_CMD_ENTRIES
expr_stmt|;
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|AAC_HOST_HIGH_CMD_QUEUE
index|]
index|[
name|AAC_PRODUCER_INDEX
index|]
operator|=
name|AAC_HOST_HIGH_CMD_ENTRIES
expr_stmt|;
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|AAC_HOST_HIGH_CMD_QUEUE
index|]
index|[
name|AAC_CONSUMER_INDEX
index|]
operator|=
name|AAC_HOST_HIGH_CMD_ENTRIES
expr_stmt|;
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|AAC_ADAP_NORM_CMD_QUEUE
index|]
index|[
name|AAC_PRODUCER_INDEX
index|]
operator|=
name|AAC_ADAP_NORM_CMD_ENTRIES
expr_stmt|;
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|AAC_ADAP_NORM_CMD_QUEUE
index|]
index|[
name|AAC_CONSUMER_INDEX
index|]
operator|=
name|AAC_ADAP_NORM_CMD_ENTRIES
expr_stmt|;
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|AAC_ADAP_HIGH_CMD_QUEUE
index|]
index|[
name|AAC_PRODUCER_INDEX
index|]
operator|=
name|AAC_ADAP_HIGH_CMD_ENTRIES
expr_stmt|;
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|AAC_ADAP_HIGH_CMD_QUEUE
index|]
index|[
name|AAC_CONSUMER_INDEX
index|]
operator|=
name|AAC_ADAP_HIGH_CMD_ENTRIES
expr_stmt|;
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|AAC_HOST_NORM_RESP_QUEUE
index|]
index|[
name|AAC_PRODUCER_INDEX
index|]
operator|=
name|AAC_HOST_NORM_RESP_ENTRIES
expr_stmt|;
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|AAC_HOST_NORM_RESP_QUEUE
index|]
index|[
name|AAC_CONSUMER_INDEX
index|]
operator|=
name|AAC_HOST_NORM_RESP_ENTRIES
expr_stmt|;
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|AAC_HOST_HIGH_RESP_QUEUE
index|]
index|[
name|AAC_PRODUCER_INDEX
index|]
operator|=
name|AAC_HOST_HIGH_RESP_ENTRIES
expr_stmt|;
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|AAC_HOST_HIGH_RESP_QUEUE
index|]
index|[
name|AAC_CONSUMER_INDEX
index|]
operator|=
name|AAC_HOST_HIGH_RESP_ENTRIES
expr_stmt|;
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|AAC_ADAP_NORM_RESP_QUEUE
index|]
index|[
name|AAC_PRODUCER_INDEX
index|]
operator|=
name|AAC_ADAP_NORM_RESP_ENTRIES
expr_stmt|;
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|AAC_ADAP_NORM_RESP_QUEUE
index|]
index|[
name|AAC_CONSUMER_INDEX
index|]
operator|=
name|AAC_ADAP_NORM_RESP_ENTRIES
expr_stmt|;
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|AAC_ADAP_HIGH_RESP_QUEUE
index|]
index|[
name|AAC_PRODUCER_INDEX
index|]
operator|=
name|AAC_ADAP_HIGH_RESP_ENTRIES
expr_stmt|;
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|AAC_ADAP_HIGH_RESP_QUEUE
index|]
index|[
name|AAC_CONSUMER_INDEX
index|]
operator|=
name|AAC_ADAP_HIGH_RESP_ENTRIES
expr_stmt|;
name|sc
operator|->
name|aac_qentries
index|[
name|AAC_HOST_NORM_CMD_QUEUE
index|]
operator|=
operator|&
name|sc
operator|->
name|aac_queues
operator|->
name|qt_HostNormCmdQueue
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|aac_qentries
index|[
name|AAC_HOST_HIGH_CMD_QUEUE
index|]
operator|=
operator|&
name|sc
operator|->
name|aac_queues
operator|->
name|qt_HostHighCmdQueue
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|aac_qentries
index|[
name|AAC_ADAP_NORM_CMD_QUEUE
index|]
operator|=
operator|&
name|sc
operator|->
name|aac_queues
operator|->
name|qt_AdapNormCmdQueue
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|aac_qentries
index|[
name|AAC_ADAP_HIGH_CMD_QUEUE
index|]
operator|=
operator|&
name|sc
operator|->
name|aac_queues
operator|->
name|qt_AdapHighCmdQueue
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|aac_qentries
index|[
name|AAC_HOST_NORM_RESP_QUEUE
index|]
operator|=
operator|&
name|sc
operator|->
name|aac_queues
operator|->
name|qt_HostNormRespQueue
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|aac_qentries
index|[
name|AAC_HOST_HIGH_RESP_QUEUE
index|]
operator|=
operator|&
name|sc
operator|->
name|aac_queues
operator|->
name|qt_HostHighRespQueue
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|aac_qentries
index|[
name|AAC_ADAP_NORM_RESP_QUEUE
index|]
operator|=
operator|&
name|sc
operator|->
name|aac_queues
operator|->
name|qt_AdapNormRespQueue
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|aac_qentries
index|[
name|AAC_ADAP_HIGH_RESP_QUEUE
index|]
operator|=
operator|&
name|sc
operator|->
name|aac_queues
operator|->
name|qt_AdapHighRespQueue
index|[
literal|0
index|]
expr_stmt|;
comment|/* 	 * Do controller-type-specific initialisation 	 */
switch|switch
condition|(
name|sc
operator|->
name|aac_hwif
condition|)
block|{
case|case
name|AAC_HWIF_I960RX
case|:
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RX_ODBR
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	 * Give the init structure to the controller. 	 */
if|if
condition|(
name|aac_sync_command
argument_list|(
name|sc
argument_list|,
name|AAC_MONKER_INITSTRUCT
argument_list|,
name|sc
operator|->
name|aac_common_busaddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|aac_common
argument_list|,
name|ac_init
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"error establishing init structure\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send a synchronous command to the controller and wait for a result.  */
end_comment

begin_function
specifier|static
name|int
name|aac_sync_command
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|command
parameter_list|,
name|u_int32_t
name|arg0
parameter_list|,
name|u_int32_t
name|arg1
parameter_list|,
name|u_int32_t
name|arg2
parameter_list|,
name|u_int32_t
name|arg3
parameter_list|,
name|u_int32_t
modifier|*
name|sp
parameter_list|)
block|{
name|time_t
name|then
decl_stmt|;
name|u_int32_t
name|status
decl_stmt|;
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
comment|/* populate the mailbox */
name|AAC_SET_MAILBOX
argument_list|(
name|sc
argument_list|,
name|command
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
comment|/* ensure the sync command doorbell flag is cleared */
name|AAC_CLEAR_ISTATUS
argument_list|(
name|sc
argument_list|,
name|AAC_DB_SYNC_COMMAND
argument_list|)
expr_stmt|;
comment|/* then set it to signal the adapter */
name|AAC_QNOTIFY
argument_list|(
name|sc
argument_list|,
name|AAC_DB_SYNC_COMMAND
argument_list|)
expr_stmt|;
comment|/* spin waiting for the command to complete */
name|then
operator|=
name|time_second
expr_stmt|;
do|do
block|{
if|if
condition|(
name|time_second
operator|>
operator|(
name|then
operator|+
name|AAC_IMMEDIATE_TIMEOUT
operator|)
condition|)
block|{
name|debug
argument_list|(
literal|2
argument_list|,
literal|"timed out"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
do|while
condition|(
operator|!
operator|(
name|AAC_GET_ISTATUS
argument_list|(
name|sc
argument_list|)
operator|&
name|AAC_DB_SYNC_COMMAND
operator|)
condition|)
do|;
comment|/* clear the completion flag */
name|AAC_CLEAR_ISTATUS
argument_list|(
name|sc
argument_list|,
name|AAC_DB_SYNC_COMMAND
argument_list|)
expr_stmt|;
comment|/* get the command status */
name|status
operator|=
name|AAC_GET_MAILBOXSTATUS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|!=
name|NULL
condition|)
operator|*
name|sp
operator|=
name|status
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Grab the sync fib area.  */
end_comment

begin_function
name|int
name|aac_alloc_sync_fib
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|aac_fib
modifier|*
modifier|*
name|fib
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
comment|/* 	 * If the force flag is set, the system is shutting down, or in 	 * trouble.  Ignore the mutex. 	 */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|AAC_SYNC_LOCK_FORCE
operator|)
condition|)
name|AAC_LOCK_ACQUIRE
argument_list|(
operator|&
name|sc
operator|->
name|aac_sync_lock
argument_list|)
expr_stmt|;
operator|*
name|fib
operator|=
operator|&
name|sc
operator|->
name|aac_common
operator|->
name|ac_sync_fib
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Release the sync fib area.  */
end_comment

begin_function
name|void
name|aac_release_sync_fib
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|AAC_LOCK_RELEASE
argument_list|(
operator|&
name|sc
operator|->
name|aac_sync_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send a synchronous FIB to the controller and wait for a result.  */
end_comment

begin_function
name|int
name|aac_sync_fib
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|command
parameter_list|,
name|u_int32_t
name|xferstate
parameter_list|,
name|struct
name|aac_fib
modifier|*
name|fib
parameter_list|,
name|u_int16_t
name|datasize
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|datasize
operator|>
name|AAC_FIB_DATASIZE
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Set up the sync FIB 	 */
name|fib
operator|->
name|Header
operator|.
name|XferState
operator|=
name|AAC_FIBSTATE_HOSTOWNED
operator||
name|AAC_FIBSTATE_INITIALISED
operator||
name|AAC_FIBSTATE_EMPTY
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|XferState
operator||=
name|xferstate
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|Command
operator|=
name|command
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|StructType
operator|=
name|AAC_FIBTYPE_TFIB
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|Size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
operator|+
name|datasize
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|SenderSize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|SenderFibAddress
operator|=
operator|(
name|u_int32_t
operator|)
name|fib
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|ReceiverFibAddress
operator|=
name|sc
operator|->
name|aac_common_busaddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|aac_common
argument_list|,
name|ac_sync_fib
argument_list|)
expr_stmt|;
comment|/* 	 * Give the FIB to the controller, wait for a response. 	 */
if|if
condition|(
name|aac_sync_command
argument_list|(
name|sc
argument_list|,
name|AAC_MONKER_SYNCFIB
argument_list|,
name|fib
operator|->
name|Header
operator|.
name|ReceiverFibAddress
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|debug
argument_list|(
literal|2
argument_list|,
literal|"IO error"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Adapter-space FIB queue manipulation  *  * Note that the queue implementation here is a little funky; neither the PI or  * CI will ever be zero.  This behaviour is a controller feature.  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|int
name|size
decl_stmt|;
name|int
name|notify
decl_stmt|;
block|}
name|aac_qinfo
index|[]
init|=
block|{
block|{
name|AAC_HOST_NORM_CMD_ENTRIES
block|,
name|AAC_DB_COMMAND_NOT_FULL
block|}
block|,
block|{
name|AAC_HOST_HIGH_CMD_ENTRIES
block|,
literal|0
block|}
block|,
block|{
name|AAC_ADAP_NORM_CMD_ENTRIES
block|,
name|AAC_DB_COMMAND_READY
block|}
block|,
block|{
name|AAC_ADAP_HIGH_CMD_ENTRIES
block|,
literal|0
block|}
block|,
block|{
name|AAC_HOST_NORM_RESP_ENTRIES
block|,
name|AAC_DB_RESPONSE_NOT_FULL
block|}
block|,
block|{
name|AAC_HOST_HIGH_RESP_ENTRIES
block|,
literal|0
block|}
block|,
block|{
name|AAC_ADAP_NORM_RESP_ENTRIES
block|,
name|AAC_DB_RESPONSE_READY
block|}
block|,
block|{
name|AAC_ADAP_HIGH_RESP_ENTRIES
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_comment
comment|/*  * Atomically insert an entry into the nominated queue, returns 0 on success or  * EBUSY if the queue is full.  *  * Note: it would be more efficient to defer notifying the controller in  *	 the case where we may be inserting several entries in rapid succession,  *	 but implementing this usefully may be difficult (it would involve a  *	 separate queue/notify interface).  */
end_comment

begin_function
specifier|static
name|int
name|aac_enqueue_fib
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|queue
parameter_list|,
name|struct
name|aac_command
modifier|*
name|cm
parameter_list|)
block|{
name|u_int32_t
name|pi
decl_stmt|,
name|ci
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
decl_stmt|;
name|u_int32_t
name|fib_size
decl_stmt|;
name|u_int32_t
name|fib_addr
decl_stmt|;
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|fib_size
operator|=
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|Size
expr_stmt|;
name|fib_addr
operator|=
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|ReceiverFibAddress
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* get the producer/consumer indices */
name|pi
operator|=
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|queue
index|]
index|[
name|AAC_PRODUCER_INDEX
index|]
expr_stmt|;
name|ci
operator|=
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|queue
index|]
index|[
name|AAC_CONSUMER_INDEX
index|]
expr_stmt|;
comment|/* wrap the queue? */
if|if
condition|(
name|pi
operator|>=
name|aac_qinfo
index|[
name|queue
index|]
operator|.
name|size
condition|)
name|pi
operator|=
literal|0
expr_stmt|;
comment|/* check for queue full */
if|if
condition|(
operator|(
name|pi
operator|+
literal|1
operator|)
operator|==
name|ci
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* populate queue entry */
operator|(
name|sc
operator|->
name|aac_qentries
index|[
name|queue
index|]
operator|+
name|pi
operator|)
operator|->
name|aq_fib_size
operator|=
name|fib_size
expr_stmt|;
operator|(
name|sc
operator|->
name|aac_qentries
index|[
name|queue
index|]
operator|+
name|pi
operator|)
operator|->
name|aq_fib_addr
operator|=
name|fib_addr
expr_stmt|;
comment|/* update producer index */
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|queue
index|]
index|[
name|AAC_PRODUCER_INDEX
index|]
operator|=
name|pi
operator|+
literal|1
expr_stmt|;
comment|/* 	 * To avoid a race with its completion interrupt, place this command on 	 * the busy queue prior to advertising it to the controller. 	 */
name|aac_enqueue_busy
argument_list|(
name|cm
argument_list|)
expr_stmt|;
comment|/* notify the adapter if we know how */
if|if
condition|(
name|aac_qinfo
index|[
name|queue
index|]
operator|.
name|notify
operator|!=
literal|0
condition|)
name|AAC_QNOTIFY
argument_list|(
name|sc
argument_list|,
name|aac_qinfo
index|[
name|queue
index|]
operator|.
name|notify
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Atomically remove one entry from the nominated queue, returns 0 on  * success or ENOENT if the queue is empty.  */
end_comment

begin_function
specifier|static
name|int
name|aac_dequeue_fib
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|queue
parameter_list|,
name|u_int32_t
modifier|*
name|fib_size
parameter_list|,
name|struct
name|aac_fib
modifier|*
modifier|*
name|fib_addr
parameter_list|)
block|{
name|u_int32_t
name|pi
decl_stmt|,
name|ci
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
decl_stmt|;
name|int
name|notify
decl_stmt|;
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* get the producer/consumer indices */
name|pi
operator|=
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|queue
index|]
index|[
name|AAC_PRODUCER_INDEX
index|]
expr_stmt|;
name|ci
operator|=
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|queue
index|]
index|[
name|AAC_CONSUMER_INDEX
index|]
expr_stmt|;
comment|/* check for queue empty */
if|if
condition|(
name|ci
operator|==
name|pi
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|notify
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ci
operator|==
name|pi
operator|+
literal|1
condition|)
name|notify
operator|++
expr_stmt|;
comment|/* wrap the queue? */
if|if
condition|(
name|ci
operator|>=
name|aac_qinfo
index|[
name|queue
index|]
operator|.
name|size
condition|)
name|ci
operator|=
literal|0
expr_stmt|;
comment|/* fetch the entry */
operator|*
name|fib_size
operator|=
operator|(
name|sc
operator|->
name|aac_qentries
index|[
name|queue
index|]
operator|+
name|ci
operator|)
operator|->
name|aq_fib_size
expr_stmt|;
operator|*
name|fib_addr
operator|=
operator|(
expr|struct
name|aac_fib
operator|*
operator|)
operator|(
name|sc
operator|->
name|aac_qentries
index|[
name|queue
index|]
operator|+
name|ci
operator|)
operator|->
name|aq_fib_addr
expr_stmt|;
comment|/* 	 * Is this a fast response? If it is, update the fib fields in 	 * local memory so the whole fib doesn't have to be DMA'd back up. 	 */
if|if
condition|(
operator|*
operator|(
name|uintptr_t
operator|*
operator|)
name|fib_addr
operator|&
literal|0x01
condition|)
block|{
operator|*
operator|(
name|uintptr_t
operator|*
operator|)
name|fib_addr
operator|&=
operator|~
literal|0x01
expr_stmt|;
operator|(
operator|*
name|fib_addr
operator|)
operator|->
name|Header
operator|.
name|XferState
operator||=
name|AAC_FIBSTATE_DONEADAP
expr_stmt|;
operator|*
operator|(
operator|(
name|u_int32_t
operator|*
operator|)
operator|(
operator|(
operator|*
name|fib_addr
operator|)
operator|->
name|data
operator|)
operator|)
operator|=
name|AAC_ERROR_NORMAL
expr_stmt|;
block|}
comment|/* update consumer index */
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|queue
index|]
index|[
name|AAC_CONSUMER_INDEX
index|]
operator|=
name|ci
operator|+
literal|1
expr_stmt|;
comment|/* if we have made the queue un-full, notify the adapter */
if|if
condition|(
name|notify
operator|&&
operator|(
name|aac_qinfo
index|[
name|queue
index|]
operator|.
name|notify
operator|!=
literal|0
operator|)
condition|)
name|AAC_QNOTIFY
argument_list|(
name|sc
argument_list|,
name|aac_qinfo
index|[
name|queue
index|]
operator|.
name|notify
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Put our response to an Adapter Initialed Fib on the response queue  */
end_comment

begin_function
specifier|static
name|int
name|aac_enqueue_response
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|queue
parameter_list|,
name|struct
name|aac_fib
modifier|*
name|fib
parameter_list|)
block|{
name|u_int32_t
name|pi
decl_stmt|,
name|ci
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
decl_stmt|;
name|u_int32_t
name|fib_size
decl_stmt|;
name|u_int32_t
name|fib_addr
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Tell the adapter where the FIB is */
name|fib_size
operator|=
name|fib
operator|->
name|Header
operator|.
name|Size
expr_stmt|;
name|fib_addr
operator|=
name|fib
operator|->
name|Header
operator|.
name|SenderFibAddress
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|ReceiverFibAddress
operator|=
name|fib_addr
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* get the producer/consumer indices */
name|pi
operator|=
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|queue
index|]
index|[
name|AAC_PRODUCER_INDEX
index|]
expr_stmt|;
name|ci
operator|=
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|queue
index|]
index|[
name|AAC_CONSUMER_INDEX
index|]
expr_stmt|;
comment|/* wrap the queue? */
if|if
condition|(
name|pi
operator|>=
name|aac_qinfo
index|[
name|queue
index|]
operator|.
name|size
condition|)
name|pi
operator|=
literal|0
expr_stmt|;
comment|/* check for queue full */
if|if
condition|(
operator|(
name|pi
operator|+
literal|1
operator|)
operator|==
name|ci
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* populate queue entry */
operator|(
name|sc
operator|->
name|aac_qentries
index|[
name|queue
index|]
operator|+
name|pi
operator|)
operator|->
name|aq_fib_size
operator|=
name|fib_size
expr_stmt|;
operator|(
name|sc
operator|->
name|aac_qentries
index|[
name|queue
index|]
operator|+
name|pi
operator|)
operator|->
name|aq_fib_addr
operator|=
name|fib_addr
expr_stmt|;
comment|/* update producer index */
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|queue
index|]
index|[
name|AAC_PRODUCER_INDEX
index|]
operator|=
name|pi
operator|+
literal|1
expr_stmt|;
comment|/* notify the adapter if we know how */
if|if
condition|(
name|aac_qinfo
index|[
name|queue
index|]
operator|.
name|notify
operator|!=
literal|0
condition|)
name|AAC_QNOTIFY
argument_list|(
name|sc
argument_list|,
name|aac_qinfo
index|[
name|queue
index|]
operator|.
name|notify
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check for commands that have been outstanding for a suspiciously long time,  * and complain about them.  */
end_comment

begin_function
specifier|static
name|void
name|aac_timeout
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|struct
name|aac_command
modifier|*
name|cm
decl_stmt|;
name|time_t
name|deadline
decl_stmt|;
comment|/* 	 * Traverse the busy command list, bitch about late commands once 	 * only. 	 */
name|deadline
operator|=
name|time_second
operator|-
name|AAC_CMD_TIMEOUT
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|cm
argument_list|,
argument|&sc->aac_busy
argument_list|,
argument|cm_link
argument_list|)
block|{
if|if
condition|(
operator|(
name|cm
operator|->
name|cm_timestamp
operator|<
name|deadline
operator|)
comment|/*&& !(cm->cm_flags& AAC_CMD_TIMEDOUT) */
condition|)
block|{
name|cm
operator|->
name|cm_flags
operator||=
name|AAC_CMD_TIMEDOUT
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"COMMAND %p TIMEOUT AFTER %d SECONDS\n"
argument_list|,
name|cm
argument_list|,
call|(
name|int
call|)
argument_list|(
name|time_second
operator|-
name|cm
operator|->
name|cm_timestamp
argument_list|)
argument_list|)
expr_stmt|;
name|AAC_PRINT_FIB
argument_list|(
name|sc
argument_list|,
name|cm
operator|->
name|cm_fib
argument_list|)
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Interface Function Vectors  */
end_comment

begin_comment
comment|/*  * Read the current firmware status word.  */
end_comment

begin_function
specifier|static
name|int
name|aac_sa_get_fwstatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
return|return
operator|(
name|AAC_GETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SA_FWSTATUS
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aac_rx_get_fwstatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
return|return
operator|(
name|AAC_GETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RX_FWSTATUS
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aac_fa_get_fwstatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|val
operator|=
name|AAC_GETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_FA_FWSTATUS
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Notify the controller of a change in a given queue  */
end_comment

begin_function
specifier|static
name|void
name|aac_sa_qnotify
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|qbit
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|AAC_SETREG2
argument_list|(
name|sc
argument_list|,
name|AAC_SA_DOORBELL1_SET
argument_list|,
name|qbit
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|aac_rx_qnotify
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|qbit
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RX_IDBR
argument_list|,
name|qbit
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|aac_fa_qnotify
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|qbit
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|AAC_SETREG2
argument_list|(
name|sc
argument_list|,
name|AAC_FA_DOORBELL1
argument_list|,
name|qbit
argument_list|)
expr_stmt|;
name|AAC_FA_HACK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get the interrupt reason bits  */
end_comment

begin_function
specifier|static
name|int
name|aac_sa_get_istatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
return|return
operator|(
name|AAC_GETREG2
argument_list|(
name|sc
argument_list|,
name|AAC_SA_DOORBELL0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aac_rx_get_istatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
return|return
operator|(
name|AAC_GETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RX_ODBR
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aac_fa_get_istatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|val
operator|=
name|AAC_GETREG2
argument_list|(
name|sc
argument_list|,
name|AAC_FA_DOORBELL0
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Clear some interrupt reason bits  */
end_comment

begin_function
specifier|static
name|void
name|aac_sa_clear_istatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|mask
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|AAC_SETREG2
argument_list|(
name|sc
argument_list|,
name|AAC_SA_DOORBELL0_CLEAR
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|aac_rx_clear_istatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|mask
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RX_ODBR
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|aac_fa_clear_istatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|mask
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|AAC_SETREG2
argument_list|(
name|sc
argument_list|,
name|AAC_FA_DOORBELL0_CLEAR
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|AAC_FA_HACK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Populate the mailbox and set the command word  */
end_comment

begin_function
specifier|static
name|void
name|aac_sa_set_mailbox
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|command
parameter_list|,
name|u_int32_t
name|arg0
parameter_list|,
name|u_int32_t
name|arg1
parameter_list|,
name|u_int32_t
name|arg2
parameter_list|,
name|u_int32_t
name|arg3
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SA_MAILBOX
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SA_MAILBOX
operator|+
literal|4
argument_list|,
name|arg0
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SA_MAILBOX
operator|+
literal|8
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SA_MAILBOX
operator|+
literal|12
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SA_MAILBOX
operator|+
literal|16
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|aac_rx_set_mailbox
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|command
parameter_list|,
name|u_int32_t
name|arg0
parameter_list|,
name|u_int32_t
name|arg1
parameter_list|,
name|u_int32_t
name|arg2
parameter_list|,
name|u_int32_t
name|arg3
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RX_MAILBOX
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RX_MAILBOX
operator|+
literal|4
argument_list|,
name|arg0
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RX_MAILBOX
operator|+
literal|8
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RX_MAILBOX
operator|+
literal|12
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RX_MAILBOX
operator|+
literal|16
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|aac_fa_set_mailbox
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|command
parameter_list|,
name|u_int32_t
name|arg0
parameter_list|,
name|u_int32_t
name|arg1
parameter_list|,
name|u_int32_t
name|arg2
parameter_list|,
name|u_int32_t
name|arg3
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_FA_MAILBOX
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|AAC_FA_HACK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_FA_MAILBOX
operator|+
literal|4
argument_list|,
name|arg0
argument_list|)
expr_stmt|;
name|AAC_FA_HACK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_FA_MAILBOX
operator|+
literal|8
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
name|AAC_FA_HACK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_FA_MAILBOX
operator|+
literal|12
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|AAC_FA_HACK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_FA_MAILBOX
operator|+
literal|16
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
name|AAC_FA_HACK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Fetch the immediate command status word  */
end_comment

begin_function
specifier|static
name|int
name|aac_sa_get_mailboxstatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|4
argument_list|)
expr_stmt|;
return|return
operator|(
name|AAC_GETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SA_MAILBOX
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aac_rx_get_mailboxstatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|4
argument_list|)
expr_stmt|;
return|return
operator|(
name|AAC_GETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RX_MAILBOX
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aac_fa_get_mailboxstatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
name|debug_called
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|val
operator|=
name|AAC_GETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_FA_MAILBOX
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set/clear interrupt masks  */
end_comment

begin_function
specifier|static
name|void
name|aac_sa_set_interrupts
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
name|debug
argument_list|(
literal|2
argument_list|,
literal|"%sable interrupts"
argument_list|,
name|enable
condition|?
literal|"en"
else|:
literal|"dis"
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
block|{
name|AAC_SETREG2
argument_list|(
operator|(
name|sc
operator|)
argument_list|,
name|AAC_SA_MASK0_CLEAR
argument_list|,
name|AAC_DB_INTERRUPTS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AAC_SETREG2
argument_list|(
operator|(
name|sc
operator|)
argument_list|,
name|AAC_SA_MASK0_SET
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|aac_rx_set_interrupts
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
name|debug
argument_list|(
literal|2
argument_list|,
literal|"%sable interrupts"
argument_list|,
name|enable
condition|?
literal|"en"
else|:
literal|"dis"
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
block|{
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RX_OIMR
argument_list|,
operator|~
name|AAC_DB_INTERRUPTS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RX_OIMR
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|aac_fa_set_interrupts
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
name|debug
argument_list|(
literal|2
argument_list|,
literal|"%sable interrupts"
argument_list|,
name|enable
condition|?
literal|"en"
else|:
literal|"dis"
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
block|{
name|AAC_SETREG2
argument_list|(
operator|(
name|sc
operator|)
argument_list|,
name|AAC_FA_MASK0_CLEAR
argument_list|,
name|AAC_DB_INTERRUPTS
argument_list|)
expr_stmt|;
name|AAC_FA_HACK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AAC_SETREG2
argument_list|(
operator|(
name|sc
operator|)
argument_list|,
name|AAC_FA_MASK0
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
name|AAC_FA_HACK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Debugging and Diagnostics  */
end_comment

begin_comment
comment|/*  * Print some information about the controller.  */
end_comment

begin_function
specifier|static
name|void
name|aac_describe_controller
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|aac_fib
modifier|*
name|fib
decl_stmt|;
name|struct
name|aac_adapter_info
modifier|*
name|info
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|aac_alloc_sync_fib
argument_list|(
name|sc
argument_list|,
operator|&
name|fib
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fib
operator|->
name|data
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|aac_sync_fib
argument_list|(
name|sc
argument_list|,
name|RequestAdapterInfo
argument_list|,
literal|0
argument_list|,
name|fib
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"RequestAdapterInfo failed\n"
argument_list|)
expr_stmt|;
name|aac_release_sync_fib
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|info
operator|=
operator|(
expr|struct
name|aac_adapter_info
operator|*
operator|)
operator|&
name|fib
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"%s %dMHz, %dMB cache memory, %s\n"
argument_list|,
name|aac_describe_code
argument_list|(
name|aac_cpu_variant
argument_list|,
name|info
operator|->
name|CpuVariant
argument_list|)
argument_list|,
name|info
operator|->
name|ClockSpeed
argument_list|,
name|info
operator|->
name|BufferMem
operator|/
operator|(
literal|1024
operator|*
literal|1024
operator|)
argument_list|,
name|aac_describe_code
argument_list|(
name|aac_battery_platform
argument_list|,
name|info
operator|->
name|batteryPlatform
argument_list|)
argument_list|)
expr_stmt|;
comment|/* save the kernel revision structure for later use */
name|sc
operator|->
name|aac_revision
operator|=
name|info
operator|->
name|KernelRevision
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"Kernel %d.%d-%d, Build %d, S/N %6X\n"
argument_list|,
name|info
operator|->
name|KernelRevision
operator|.
name|external
operator|.
name|comp
operator|.
name|major
argument_list|,
name|info
operator|->
name|KernelRevision
operator|.
name|external
operator|.
name|comp
operator|.
name|minor
argument_list|,
name|info
operator|->
name|KernelRevision
operator|.
name|external
operator|.
name|comp
operator|.
name|dash
argument_list|,
name|info
operator|->
name|KernelRevision
operator|.
name|buildNumber
argument_list|,
call|(
name|u_int32_t
call|)
argument_list|(
name|info
operator|->
name|SerialNumber
operator|&
literal|0xffffff
argument_list|)
argument_list|)
expr_stmt|;
name|aac_release_sync_fib
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Look up a text description of a numeric error code and return a pointer to  * same.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|aac_describe_code
parameter_list|(
name|struct
name|aac_code_lookup
modifier|*
name|table
parameter_list|,
name|u_int32_t
name|code
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|table
index|[
name|i
index|]
operator|.
name|string
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|table
index|[
name|i
index|]
operator|.
name|code
operator|==
name|code
condition|)
return|return
operator|(
name|table
index|[
name|i
index|]
operator|.
name|string
operator|)
return|;
return|return
operator|(
name|table
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|string
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Management Interface  */
end_comment

begin_function
specifier|static
name|int
name|aac_open
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|d_thread_t
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
comment|/* Check to make sure the device isn't already open */
if|if
condition|(
name|sc
operator|->
name|aac_state
operator|&
name|AAC_STATE_OPEN
condition|)
block|{
return|return
name|EBUSY
return|;
block|}
name|sc
operator|->
name|aac_state
operator||=
name|AAC_STATE_OPEN
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aac_close
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|d_thread_t
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
comment|/* Mark this unit as no longer open  */
name|sc
operator|->
name|aac_state
operator|&=
operator|~
name|AAC_STATE_OPEN
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aac_ioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|int
name|flag
parameter_list|,
name|d_thread_t
modifier|*
name|td
parameter_list|)
block|{
name|union
name|aac_statrequest
modifier|*
name|as
decl_stmt|;
name|struct
name|aac_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|as
operator|=
operator|(
expr|union
name|aac_statrequest
operator|*
operator|)
name|arg
expr_stmt|;
name|sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|AACIO_STATS
case|:
switch|switch
condition|(
name|as
operator|->
name|as_item
condition|)
block|{
case|case
name|AACQ_FREE
case|:
case|case
name|AACQ_BIO
case|:
case|case
name|AACQ_READY
case|:
case|case
name|AACQ_BUSY
case|:
case|case
name|AACQ_COMPLETE
case|:
name|bcopy
argument_list|(
operator|&
name|sc
operator|->
name|aac_qstat
index|[
name|as
operator|->
name|as_item
index|]
argument_list|,
operator|&
name|as
operator|->
name|as_qstat
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_qstat
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FSACTL_SENDFIB
case|:
name|arg
operator|=
operator|*
operator|(
name|caddr_t
operator|*
operator|)
name|arg
expr_stmt|;
case|case
name|FSACTL_LNX_SENDFIB
case|:
name|debug
argument_list|(
literal|1
argument_list|,
literal|"FSACTL_SENDFIB"
argument_list|)
expr_stmt|;
name|error
operator|=
name|aac_ioctl_sendfib
argument_list|(
name|sc
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|FSACTL_AIF_THREAD
case|:
case|case
name|FSACTL_LNX_AIF_THREAD
case|:
name|debug
argument_list|(
literal|1
argument_list|,
literal|"FSACTL_AIF_THREAD"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|FSACTL_OPEN_GET_ADAPTER_FIB
case|:
name|arg
operator|=
operator|*
operator|(
name|caddr_t
operator|*
operator|)
name|arg
expr_stmt|;
case|case
name|FSACTL_LNX_OPEN_GET_ADAPTER_FIB
case|:
name|debug
argument_list|(
literal|1
argument_list|,
literal|"FSACTL_OPEN_GET_ADAPTER_FIB"
argument_list|)
expr_stmt|;
comment|/* 		 * Pass the caller out an AdapterFibContext. 		 * 		 * Note that because we only support one opener, we 		 * basically ignore this.  Set the caller's context to a magic 		 * number just in case. 		 * 		 * The Linux code hands the driver a pointer into kernel space, 		 * and then trusts it when the caller hands it back.  Aiee! 		 * Here, we give it the proc pointer of the per-adapter aif  		 * thread. It's only used as a sanity check in other calls. 		 */
name|i
operator|=
operator|(
name|int
operator|)
name|sc
operator|->
name|aifthread
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|i
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FSACTL_GET_NEXT_ADAPTER_FIB
case|:
name|arg
operator|=
operator|*
operator|(
name|caddr_t
operator|*
operator|)
name|arg
expr_stmt|;
case|case
name|FSACTL_LNX_GET_NEXT_ADAPTER_FIB
case|:
name|debug
argument_list|(
literal|1
argument_list|,
literal|"FSACTL_GET_NEXT_ADAPTER_FIB"
argument_list|)
expr_stmt|;
name|error
operator|=
name|aac_getnext_aif
argument_list|(
name|sc
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|FSACTL_CLOSE_GET_ADAPTER_FIB
case|:
case|case
name|FSACTL_LNX_CLOSE_GET_ADAPTER_FIB
case|:
name|debug
argument_list|(
literal|1
argument_list|,
literal|"FSACTL_CLOSE_GET_ADAPTER_FIB"
argument_list|)
expr_stmt|;
comment|/* don't do anything here */
break|break;
case|case
name|FSACTL_MINIPORT_REV_CHECK
case|:
name|arg
operator|=
operator|*
operator|(
name|caddr_t
operator|*
operator|)
name|arg
expr_stmt|;
case|case
name|FSACTL_LNX_MINIPORT_REV_CHECK
case|:
name|debug
argument_list|(
literal|1
argument_list|,
literal|"FSACTL_MINIPORT_REV_CHECK"
argument_list|)
expr_stmt|;
name|error
operator|=
name|aac_rev_check
argument_list|(
name|sc
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|FSACTL_QUERY_DISK
case|:
name|arg
operator|=
operator|*
operator|(
name|caddr_t
operator|*
operator|)
name|arg
expr_stmt|;
case|case
name|FSACTL_LNX_QUERY_DISK
case|:
name|debug
argument_list|(
literal|1
argument_list|,
literal|"FSACTL_QUERY_DISK"
argument_list|)
expr_stmt|;
name|error
operator|=
name|aac_query_disk
argument_list|(
name|sc
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|FSACTL_DELETE_DISK
case|:
case|case
name|FSACTL_LNX_DELETE_DISK
case|:
comment|/* 		 * We don't trust the underland to tell us when to delete a 		 * container, rather we rely on an AIF coming from the  		 * controller 		 */
name|error
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|debug
argument_list|(
literal|1
argument_list|,
literal|"unsupported cmd 0x%lx\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aac_poll
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|poll_events
parameter_list|,
name|d_thread_t
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|revents
decl_stmt|;
name|sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|revents
operator|=
literal|0
expr_stmt|;
name|AAC_LOCK_ACQUIRE
argument_list|(
operator|&
name|sc
operator|->
name|aac_aifq_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|poll_events
operator|&
operator|(
name|POLLRDNORM
operator||
name|POLLIN
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|aac_aifq_tail
operator|!=
name|sc
operator|->
name|aac_aifq_head
condition|)
name|revents
operator||=
name|poll_events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
block|}
name|AAC_LOCK_RELEASE
argument_list|(
operator|&
name|sc
operator|->
name|aac_aifq_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|revents
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|poll_events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
condition|)
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|sc
operator|->
name|rcv_select
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|revents
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send a FIB supplied from userspace  */
end_comment

begin_function
specifier|static
name|int
name|aac_ioctl_sendfib
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|caddr_t
name|ufib
parameter_list|)
block|{
name|struct
name|aac_command
modifier|*
name|cm
decl_stmt|;
name|int
name|size
decl_stmt|,
name|error
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|cm
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Get a command 	 */
if|if
condition|(
name|aac_alloc_command
argument_list|(
name|sc
argument_list|,
operator|&
name|cm
argument_list|)
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Fetch the FIB header, then re-copy to get data as well. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|ufib
argument_list|,
name|cm
operator|->
name|cm_fib
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib_header
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|size
operator|=
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|Size
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"incoming FIB oversized (%d> %d)\n"
argument_list|,
name|size
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|ufib
argument_list|,
name|cm
operator|->
name|cm_fib
argument_list|,
name|size
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|Size
operator|=
name|size
expr_stmt|;
name|cm
operator|->
name|cm_timestamp
operator|=
name|time_second
expr_stmt|;
comment|/* 	 * Pass the FIB to the controller, wait for it to complete. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|aac_wait_command
argument_list|(
name|cm
argument_list|,
literal|30
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* XXX user timeout? */
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"aac_wait_command return %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Copy the FIB and data back out to the caller. 	 */
name|size
operator|=
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|Size
expr_stmt|;
if|if
condition|(
name|size
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"outbound FIB oversized (%d> %d)\n"
argument_list|,
name|size
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|copyout
argument_list|(
name|cm
operator|->
name|cm_fib
argument_list|,
name|ufib
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|cm
operator|!=
name|NULL
condition|)
block|{
name|aac_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle an AIF sent to us by the controller; queue it for later reference.  * If the queue fills up, then drop the older entries.  */
end_comment

begin_function
specifier|static
name|void
name|aac_handle_aif
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|aac_fib
modifier|*
name|fib
parameter_list|)
block|{
name|struct
name|aac_aif_command
modifier|*
name|aif
decl_stmt|;
name|struct
name|aac_container
modifier|*
name|co
decl_stmt|,
modifier|*
name|co_next
decl_stmt|;
name|struct
name|aac_mntinfo
modifier|*
name|mi
decl_stmt|;
name|struct
name|aac_mntinforesp
modifier|*
name|mir
init|=
name|NULL
decl_stmt|;
name|u_int16_t
name|rsize
decl_stmt|;
name|int
name|next
decl_stmt|,
name|found
decl_stmt|;
name|int
name|added
init|=
literal|0
decl_stmt|,
name|i
init|=
literal|0
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|aif
operator|=
operator|(
expr|struct
name|aac_aif_command
operator|*
operator|)
operator|&
name|fib
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
name|aac_print_aif
argument_list|(
name|sc
argument_list|,
name|aif
argument_list|)
expr_stmt|;
comment|/* Is it an event that we should care about? */
switch|switch
condition|(
name|aif
operator|->
name|command
condition|)
block|{
case|case
name|AifCmdEventNotify
case|:
switch|switch
condition|(
name|aif
operator|->
name|data
operator|.
name|EN
operator|.
name|type
condition|)
block|{
case|case
name|AifEnAddContainer
case|:
case|case
name|AifEnDeleteContainer
case|:
comment|/* 			 * A container was added or deleted, but the message  			 * doesn't tell us anything else!  Re-enumerate the 			 * containers and sort things out. 			 */
name|aac_alloc_sync_fib
argument_list|(
name|sc
argument_list|,
operator|&
name|fib
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mi
operator|=
operator|(
expr|struct
name|aac_mntinfo
operator|*
operator|)
operator|&
name|fib
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
do|do
block|{
comment|/* 				 * Ask the controller for its containers one at 				 * a time. 				 * XXX What if the controller's list changes 				 * midway through this enumaration? 				 * XXX This should be done async. 				 */
name|bzero
argument_list|(
name|mi
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_mntinfo
argument_list|)
argument_list|)
expr_stmt|;
name|mi
operator|->
name|Command
operator|=
name|VM_NameServe
expr_stmt|;
name|mi
operator|->
name|MntType
operator|=
name|FT_FILESYS
expr_stmt|;
name|mi
operator|->
name|MntCount
operator|=
name|i
expr_stmt|;
name|rsize
operator|=
sizeof|sizeof
argument_list|(
name|mir
argument_list|)
expr_stmt|;
if|if
condition|(
name|aac_sync_fib
argument_list|(
name|sc
argument_list|,
name|ContainerCommand
argument_list|,
literal|0
argument_list|,
name|fib
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_mntinfo
argument_list|)
argument_list|)
condition|)
block|{
name|debug
argument_list|(
literal|2
argument_list|,
literal|"Error probing container %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|mir
operator|=
operator|(
expr|struct
name|aac_mntinforesp
operator|*
operator|)
operator|&
name|fib
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
comment|/* 				 * Check the container against our list. 				 * co->co_found was already set to 0 in a 				 * previous run. 				 */
if|if
condition|(
operator|(
name|mir
operator|->
name|Status
operator|==
name|ST_OK
operator|)
operator|&&
operator|(
name|mir
operator|->
name|MntTable
index|[
literal|0
index|]
operator|.
name|VolType
operator|!=
name|CT_NONE
operator|)
condition|)
block|{
name|found
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|co
argument_list|,
argument|&sc->aac_container_tqh
argument_list|,
argument|co_link
argument_list|)
block|{
if|if
condition|(
name|co
operator|->
name|co_mntobj
operator|.
name|ObjectId
operator|==
name|mir
operator|->
name|MntTable
index|[
literal|0
index|]
operator|.
name|ObjectId
condition|)
block|{
name|co
operator|->
name|co_found
operator|=
literal|1
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* 					 * If the container matched, continue 					 * in the list. 					 */
if|if
condition|(
name|found
condition|)
block|{
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* 					 * This is a new container.  Do all the 					 * appropriate things to set it up. 					 */
name|aac_add_container
argument_list|(
name|sc
argument_list|,
name|mir
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|added
operator|=
literal|1
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|i
operator|<
name|mir
operator|->
name|MntRespCount
operator|)
operator|&&
operator|(
name|i
operator|<
name|AAC_MAX_CONTAINERS
operator|)
condition|)
do|;
name|aac_release_sync_fib
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 			 * Go through our list of containers and see which ones 			 * were not marked 'found'.  Since the controller didn't 			 * list them they must have been deleted.  Do the 			 * appropriate steps to destroy the device.  Also reset 			 * the co->co_found field. 			 */
name|co
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|aac_container_tqh
argument_list|)
expr_stmt|;
while|while
condition|(
name|co
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|co
operator|->
name|co_found
operator|==
literal|0
condition|)
block|{
name|device_delete_child
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
name|co
operator|->
name|co_disk
argument_list|)
expr_stmt|;
name|co_next
operator|=
name|TAILQ_NEXT
argument_list|(
name|co
argument_list|,
name|co_link
argument_list|)
expr_stmt|;
name|AAC_LOCK_ACQUIRE
argument_list|(
operator|&
name|sc
operator|->
name|aac_container_lock
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|aac_container_tqh
argument_list|,
name|co
argument_list|,
name|co_link
argument_list|)
expr_stmt|;
name|AAC_LOCK_RELEASE
argument_list|(
operator|&
name|sc
operator|->
name|aac_container_lock
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|co
argument_list|,
name|M_AACBUF
argument_list|)
expr_stmt|;
name|co
operator|=
name|co_next
expr_stmt|;
block|}
else|else
block|{
name|co
operator|->
name|co_found
operator|=
literal|0
expr_stmt|;
name|co
operator|=
name|TAILQ_NEXT
argument_list|(
name|co
argument_list|,
name|co_link
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Attach the newly created containers */
if|if
condition|(
name|added
condition|)
name|bus_generic_attach
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
default|default:
break|break;
block|}
comment|/* Copy the AIF data to the AIF queue for ioctl retrieval */
name|AAC_LOCK_ACQUIRE
argument_list|(
operator|&
name|sc
operator|->
name|aac_aifq_lock
argument_list|)
expr_stmt|;
name|next
operator|=
operator|(
name|sc
operator|->
name|aac_aifq_head
operator|+
literal|1
operator|)
operator|%
name|AAC_AIFQ_LENGTH
expr_stmt|;
if|if
condition|(
name|next
operator|!=
name|sc
operator|->
name|aac_aifq_tail
condition|)
block|{
name|bcopy
argument_list|(
name|aif
argument_list|,
operator|&
name|sc
operator|->
name|aac_aifq
index|[
name|next
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_aif_command
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|aac_aifq_head
operator|=
name|next
expr_stmt|;
comment|/* On the off chance that someone is sleeping for an aif... */
if|if
condition|(
name|sc
operator|->
name|aac_state
operator|&
name|AAC_STATE_AIF_SLEEPER
condition|)
name|wakeup
argument_list|(
name|sc
operator|->
name|aac_aifq
argument_list|)
expr_stmt|;
comment|/* Wakeup any poll()ers */
name|selwakeup
argument_list|(
operator|&
name|sc
operator|->
name|rcv_select
argument_list|)
expr_stmt|;
block|}
name|AAC_LOCK_RELEASE
argument_list|(
operator|&
name|sc
operator|->
name|aac_aifq_lock
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Return the Revision of the driver to userspace and check to see if the  * userspace app is possibly compatible.  This is extremely bogus since  * our driver doesn't follow Adaptec's versioning system.  Cheat by just  * returning what the card reported.  */
end_comment

begin_function
specifier|static
name|int
name|aac_rev_check
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|caddr_t
name|udata
parameter_list|)
block|{
name|struct
name|aac_rev_check
name|rev_check
decl_stmt|;
name|struct
name|aac_rev_check_resp
name|rev_check_resp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* 	 * Copyin the revision struct from userspace 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|udata
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|rev_check
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_rev_check
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
name|error
return|;
block|}
name|debug
argument_list|(
literal|2
argument_list|,
literal|"Userland revision= %d\n"
argument_list|,
name|rev_check
operator|.
name|callingRevision
operator|.
name|buildNumber
argument_list|)
expr_stmt|;
comment|/* 	 * Doctor up the response struct. 	 */
name|rev_check_resp
operator|.
name|possiblyCompatible
operator|=
literal|1
expr_stmt|;
name|rev_check_resp
operator|.
name|adapterSWRevision
operator|.
name|external
operator|.
name|ul
operator|=
name|sc
operator|->
name|aac_revision
operator|.
name|external
operator|.
name|ul
expr_stmt|;
name|rev_check_resp
operator|.
name|adapterSWRevision
operator|.
name|buildNumber
operator|=
name|sc
operator|->
name|aac_revision
operator|.
name|buildNumber
expr_stmt|;
return|return
operator|(
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|rev_check_resp
argument_list|,
name|udata
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_rev_check_resp
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Pass the caller the next AIF in their queue  */
end_comment

begin_function
specifier|static
name|int
name|aac_getnext_aif
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|caddr_t
name|arg
parameter_list|)
block|{
name|struct
name|get_adapter_fib_ioctl
name|agf
decl_stmt|;
name|int
name|error
decl_stmt|,
name|s
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|agf
argument_list|,
sizeof|sizeof
argument_list|(
name|agf
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Check the magic number that we gave the caller. 		 */
if|if
condition|(
name|agf
operator|.
name|AdapterFibContext
operator|!=
operator|(
name|int
operator|)
name|sc
operator|->
name|aifthread
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|error
operator|=
name|aac_return_aif
argument_list|(
name|sc
argument_list|,
name|agf
operator|.
name|AifFib
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|==
name|EAGAIN
operator|)
operator|&&
operator|(
name|agf
operator|.
name|Wait
operator|)
condition|)
block|{
name|sc
operator|->
name|aac_state
operator||=
name|AAC_STATE_AIF_SLEEPER
expr_stmt|;
while|while
condition|(
name|error
operator|==
name|EAGAIN
condition|)
block|{
name|error
operator|=
name|tsleep
argument_list|(
name|sc
operator|->
name|aac_aifq
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"aacaif"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|aac_return_aif
argument_list|(
name|sc
argument_list|,
name|agf
operator|.
name|AifFib
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|aac_state
operator|&=
operator|~
name|AAC_STATE_AIF_SLEEPER
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Hand the next AIF off the top of the queue out to userspace.  */
end_comment

begin_function
specifier|static
name|int
name|aac_return_aif
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|caddr_t
name|uptr
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|AAC_LOCK_ACQUIRE
argument_list|(
operator|&
name|sc
operator|->
name|aac_aifq_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|aac_aifq_tail
operator|==
name|sc
operator|->
name|aac_aifq_head
condition|)
block|{
name|error
operator|=
name|EAGAIN
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|sc
operator|->
name|aac_aifq
index|[
name|sc
operator|->
name|aac_aifq_tail
index|]
argument_list|,
name|uptr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_aif_command
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"aac_return_aif: copyout returned %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|sc
operator|->
name|aac_aifq_tail
operator|=
operator|(
name|sc
operator|->
name|aac_aifq_tail
operator|+
literal|1
operator|)
operator|%
name|AAC_AIFQ_LENGTH
expr_stmt|;
block|}
name|AAC_LOCK_RELEASE
argument_list|(
operator|&
name|sc
operator|->
name|aac_aifq_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Give the userland some information about the container.  The AAC arch  * expects the driver to be a SCSI passthrough type driver, so it expects  * the containers to have b:t:l numbers.  Fake it.  */
end_comment

begin_function
specifier|static
name|int
name|aac_query_disk
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|caddr_t
name|uptr
parameter_list|)
block|{
name|struct
name|aac_query_disk
name|query_disk
decl_stmt|;
name|struct
name|aac_container
modifier|*
name|co
decl_stmt|;
name|struct
name|aac_disk
modifier|*
name|disk
decl_stmt|;
name|int
name|error
decl_stmt|,
name|id
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|disk
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|uptr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|query_disk
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_query_disk
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|id
operator|=
name|query_disk
operator|.
name|ContainerNumber
expr_stmt|;
if|if
condition|(
name|id
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|AAC_LOCK_ACQUIRE
argument_list|(
operator|&
name|sc
operator|->
name|aac_container_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|co
argument_list|,
argument|&sc->aac_container_tqh
argument_list|,
argument|co_link
argument_list|)
block|{
if|if
condition|(
name|co
operator|->
name|co_mntobj
operator|.
name|ObjectId
operator|==
name|id
condition|)
break|break;
block|}
if|if
condition|(
name|co
operator|==
name|NULL
condition|)
block|{
name|query_disk
operator|.
name|Valid
operator|=
literal|0
expr_stmt|;
name|query_disk
operator|.
name|Locked
operator|=
literal|0
expr_stmt|;
name|query_disk
operator|.
name|Deleted
operator|=
literal|1
expr_stmt|;
comment|/* XXX is this right? */
block|}
else|else
block|{
name|disk
operator|=
name|device_get_softc
argument_list|(
name|co
operator|->
name|co_disk
argument_list|)
expr_stmt|;
name|query_disk
operator|.
name|Valid
operator|=
literal|1
expr_stmt|;
name|query_disk
operator|.
name|Locked
operator|=
operator|(
name|disk
operator|->
name|ad_flags
operator|&
name|AAC_DISK_OPEN
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|query_disk
operator|.
name|Deleted
operator|=
literal|0
expr_stmt|;
name|query_disk
operator|.
name|Bus
operator|=
name|device_get_unit
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|)
expr_stmt|;
name|query_disk
operator|.
name|Target
operator|=
name|disk
operator|->
name|unit
expr_stmt|;
name|query_disk
operator|.
name|Lun
operator|=
literal|0
expr_stmt|;
name|query_disk
operator|.
name|UnMapped
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
name|disk
operator|->
name|ad_dev_t
operator|->
name|si_name
argument_list|,
operator|&
name|query_disk
operator|.
name|diskDeviceName
index|[
literal|0
index|]
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
name|AAC_LOCK_RELEASE
argument_list|(
operator|&
name|sc
operator|->
name|aac_container_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|query_disk
argument_list|,
name|uptr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_query_disk
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|aac_get_bus_info
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|aac_fib
modifier|*
name|fib
decl_stmt|;
name|struct
name|aac_ctcfg
modifier|*
name|c_cmd
decl_stmt|;
name|struct
name|aac_ctcfg_resp
modifier|*
name|c_resp
decl_stmt|;
name|struct
name|aac_vmioctl
modifier|*
name|vmi
decl_stmt|;
name|struct
name|aac_vmi_businf_resp
modifier|*
name|vmi_resp
decl_stmt|;
name|struct
name|aac_getbusinf
name|businfo
decl_stmt|;
name|struct
name|aac_sim
modifier|*
name|caminf
decl_stmt|;
name|device_t
name|child
decl_stmt|;
name|int
name|i
decl_stmt|,
name|found
decl_stmt|,
name|error
decl_stmt|;
name|aac_alloc_sync_fib
argument_list|(
name|sc
argument_list|,
operator|&
name|fib
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|c_cmd
operator|=
operator|(
expr|struct
name|aac_ctcfg
operator|*
operator|)
operator|&
name|fib
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
name|bzero
argument_list|(
name|c_cmd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_ctcfg
argument_list|)
argument_list|)
expr_stmt|;
name|c_cmd
operator|->
name|Command
operator|=
name|VM_ContainerConfig
expr_stmt|;
name|c_cmd
operator|->
name|cmd
operator|=
name|CT_GET_SCSI_METHOD
expr_stmt|;
name|c_cmd
operator|->
name|param
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|aac_sync_fib
argument_list|(
name|sc
argument_list|,
name|ContainerCommand
argument_list|,
literal|0
argument_list|,
name|fib
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_ctcfg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"Error %d sending "
literal|"VM_ContainerConfig command\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|aac_release_sync_fib
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|c_resp
operator|=
operator|(
expr|struct
name|aac_ctcfg_resp
operator|*
operator|)
operator|&
name|fib
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|c_resp
operator|->
name|Status
operator|!=
name|ST_OK
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"VM_ContainerConfig returned 0x%x\n"
argument_list|,
name|c_resp
operator|->
name|Status
argument_list|)
expr_stmt|;
name|aac_release_sync_fib
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc
operator|->
name|scsi_method_id
operator|=
name|c_resp
operator|->
name|param
expr_stmt|;
name|vmi
operator|=
operator|(
expr|struct
name|aac_vmioctl
operator|*
operator|)
operator|&
name|fib
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
name|bzero
argument_list|(
name|vmi
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_vmioctl
argument_list|)
argument_list|)
expr_stmt|;
name|vmi
operator|->
name|Command
operator|=
name|VM_Ioctl
expr_stmt|;
name|vmi
operator|->
name|ObjType
operator|=
name|FT_DRIVE
expr_stmt|;
name|vmi
operator|->
name|MethId
operator|=
name|sc
operator|->
name|scsi_method_id
expr_stmt|;
name|vmi
operator|->
name|ObjId
operator|=
literal|0
expr_stmt|;
name|vmi
operator|->
name|IoctlCmd
operator|=
name|GetBusInfo
expr_stmt|;
name|error
operator|=
name|aac_sync_fib
argument_list|(
name|sc
argument_list|,
name|ContainerCommand
argument_list|,
literal|0
argument_list|,
name|fib
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_vmioctl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"Error %d sending VMIoctl command\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|aac_release_sync_fib
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|vmi_resp
operator|=
operator|(
expr|struct
name|aac_vmi_businf_resp
operator|*
operator|)
operator|&
name|fib
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|vmi_resp
operator|->
name|Status
operator|!=
name|ST_OK
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"VM_Ioctl returned %d\n"
argument_list|,
name|vmi_resp
operator|->
name|Status
argument_list|)
expr_stmt|;
name|aac_release_sync_fib
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|bcopy
argument_list|(
operator|&
name|vmi_resp
operator|->
name|BusInf
argument_list|,
operator|&
name|businfo
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_getbusinf
argument_list|)
argument_list|)
expr_stmt|;
name|aac_release_sync_fib
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|businfo
operator|.
name|BusCount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|businfo
operator|.
name|BusValid
index|[
name|i
index|]
operator|!=
name|AAC_BUS_VALID
condition|)
continue|continue;
name|caminf
operator|=
operator|(
expr|struct
name|aac_sim
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|aac_sim
argument_list|)
argument_list|,
name|M_AACBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|caminf
operator|==
name|NULL
condition|)
continue|continue;
name|child
operator|=
name|device_add_child
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"aacp"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"device_add_child failed\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|caminf
operator|->
name|TargetsPerBus
operator|=
name|businfo
operator|.
name|TargetsPerBus
expr_stmt|;
name|caminf
operator|->
name|BusNumber
operator|=
name|i
expr_stmt|;
name|caminf
operator|->
name|InitiatorBusId
operator|=
name|businfo
operator|.
name|InitiatorBusId
index|[
name|i
index|]
expr_stmt|;
name|caminf
operator|->
name|aac_sc
operator|=
name|sc
expr_stmt|;
name|caminf
operator|->
name|sim_dev
operator|=
name|child
expr_stmt|;
name|device_set_ivars
argument_list|(
name|child
argument_list|,
name|caminf
argument_list|)
expr_stmt|;
name|device_set_desc
argument_list|(
name|child
argument_list|,
literal|"SCSI Passthrough Bus"
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|aac_sim_tqh
argument_list|,
name|caminf
argument_list|,
name|sim_link
argument_list|)
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|found
condition|)
name|bus_generic_attach
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

end_unit

