begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2000 Michael Smith  * Copyright (c) 2000 BSDi  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$FreeBSD$  */
end_comment

begin_comment
comment|/*  * Driver for the Adaptec 'FSA' family of PCI/SCSI RAID adapters.  */
end_comment

begin_include
include|#
directive|include
file|<struct.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<dev/aac/aac_compat.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/devicestat.h>
end_include

begin_include
include|#
directive|include
file|<sys/disk.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus_memio.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<dev/aac/aacreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/aac/aac_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<dev/aac/aacvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/aac/aac_tables.h>
end_include

begin_decl_stmt
name|devclass_t
name|aac_devclass
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|aac_startup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Command Processing */
end_comment

begin_function_decl
specifier|static
name|void
name|aac_startio
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_timeout
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_start
parameter_list|(
name|struct
name|aac_command
modifier|*
name|cm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_complete
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_bio_command
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|aac_command
modifier|*
modifier|*
name|cmp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_bio_complete
parameter_list|(
name|struct
name|aac_command
modifier|*
name|cm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_wait_command
parameter_list|(
name|struct
name|aac_command
modifier|*
name|cm
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_host_command
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_host_response
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Command Buffer Management */
end_comment

begin_function_decl
specifier|static
name|int
name|aac_alloc_command
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|aac_command
modifier|*
modifier|*
name|cmp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_release_command
parameter_list|(
name|struct
name|aac_command
modifier|*
name|cm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_map_command_helper
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_alloc_commands
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_free_commands
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_map_command
parameter_list|(
name|struct
name|aac_command
modifier|*
name|cm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_unmap_command
parameter_list|(
name|struct
name|aac_command
modifier|*
name|cm
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Hardware Interface */
end_comment

begin_function_decl
specifier|static
name|void
name|aac_common_map
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_init
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_sync_command
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|command
parameter_list|,
name|u_int32_t
name|arg0
parameter_list|,
name|u_int32_t
name|arg1
parameter_list|,
name|u_int32_t
name|arg2
parameter_list|,
name|u_int32_t
name|arg3
parameter_list|,
name|u_int32_t
modifier|*
name|sp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_sync_fib
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|command
parameter_list|,
name|u_int32_t
name|xferstate
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|u_int16_t
name|datasize
parameter_list|,
name|void
modifier|*
name|result
parameter_list|,
name|u_int16_t
modifier|*
name|resultsize
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_enqueue_fib
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|queue
parameter_list|,
name|u_int32_t
name|fib_size
parameter_list|,
name|u_int32_t
name|fib_addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_dequeue_fib
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|queue
parameter_list|,
name|u_int32_t
modifier|*
name|fib_size
parameter_list|,
name|struct
name|aac_fib
modifier|*
modifier|*
name|fib_addr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* StrongARM interface */
end_comment

begin_function_decl
specifier|static
name|int
name|aac_sa_get_fwstatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_sa_qnotify
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|qbit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_sa_get_istatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_sa_clear_istatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|mask
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_sa_set_mailbox
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|command
parameter_list|,
name|u_int32_t
name|arg0
parameter_list|,
name|u_int32_t
name|arg1
parameter_list|,
name|u_int32_t
name|arg2
parameter_list|,
name|u_int32_t
name|arg3
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_sa_get_mailboxstatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_sa_set_interrupts
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|enable
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|aac_interface
name|aac_sa_interface
init|=
block|{
name|aac_sa_get_fwstatus
block|,
name|aac_sa_qnotify
block|,
name|aac_sa_get_istatus
block|,
name|aac_sa_clear_istatus
block|,
name|aac_sa_set_mailbox
block|,
name|aac_sa_get_mailboxstatus
block|,
name|aac_sa_set_interrupts
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* i960Rx interface */
end_comment

begin_function_decl
specifier|static
name|int
name|aac_rx_get_fwstatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_rx_qnotify
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|qbit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_rx_get_istatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_rx_clear_istatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|mask
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_rx_set_mailbox
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|command
parameter_list|,
name|u_int32_t
name|arg0
parameter_list|,
name|u_int32_t
name|arg1
parameter_list|,
name|u_int32_t
name|arg2
parameter_list|,
name|u_int32_t
name|arg3
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_rx_get_mailboxstatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_rx_set_interrupts
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|enable
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|aac_interface
name|aac_rx_interface
init|=
block|{
name|aac_rx_get_fwstatus
block|,
name|aac_rx_qnotify
block|,
name|aac_rx_get_istatus
block|,
name|aac_rx_clear_istatus
block|,
name|aac_rx_set_mailbox
block|,
name|aac_rx_get_mailboxstatus
block|,
name|aac_rx_set_interrupts
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Debugging and Diagnostics */
end_comment

begin_function_decl
specifier|static
name|void
name|aac_describe_controller
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|aac_describe_code
parameter_list|(
name|struct
name|aac_code_lookup
modifier|*
name|table
parameter_list|,
name|u_int32_t
name|code
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Management Interface */
end_comment

begin_decl_stmt
specifier|static
name|d_open_t
name|aac_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|aac_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|aac_ioctl
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|aac_ioctl_sendfib
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|caddr_t
name|ufib
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aac_handle_aif
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|aac_aif_command
modifier|*
name|aif
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|AAC_COMPAT_LINUX
end_ifdef

begin_function_decl
specifier|static
name|int
name|aac_linux_rev_check
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|caddr_t
name|udata
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_linux_getnext_aif
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|caddr_t
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aac_linux_return_aif
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|caddr_t
name|uptr
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|AAC_CDEV_MAJOR
value|150
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|aac_cdevsw
init|=
block|{
name|aac_open
block|,
comment|/* open */
name|aac_close
block|,
comment|/* close */
name|noread
block|,
comment|/* read */
name|nowrite
block|,
comment|/* write */
name|aac_ioctl
block|,
comment|/* ioctl */
name|nopoll
block|,
comment|/* poll */
name|nommap
block|,
comment|/* mmap */
name|nostrategy
block|,
comment|/* strategy */
literal|"aac"
block|,
comment|/* name */
name|AAC_CDEV_MAJOR
block|,
comment|/* major */
name|nodump
block|,
comment|/* dump */
name|nopsize
block|,
comment|/* psize */
literal|0
block|,
comment|/* flags */
operator|-
literal|1
block|,
comment|/* bmaj */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/********************************************************************************  ********************************************************************************                                                                  Device Interface  ********************************************************************************  ********************************************************************************/
end_comment

begin_comment
comment|/********************************************************************************  * Initialise the controller and softc  */
end_comment

begin_function
name|int
name|aac_attach
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|unit
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*      * Initialise per-controller queues.      */
name|aac_initq_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|aac_initq_ready
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|aac_initq_busy
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|aac_initq_complete
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|aac_initq_bio
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500005
comment|/*      * Initialise command-completion task.      */
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|aac_task_complete
argument_list|,
literal|0
argument_list|,
name|aac_complete
argument_list|,
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* disable interrupts before we enable anything */
name|AAC_MASK_INTERRUPTS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* mark controller as suspended until we get ourselves organised */
name|sc
operator|->
name|aac_state
operator||=
name|AAC_STATE_SUSPEND
expr_stmt|;
comment|/*      * Allocate command structures.      */
if|if
condition|(
operator|(
name|error
operator|=
name|aac_alloc_commands
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/*      * Initialise the adapter.      */
if|if
condition|(
operator|(
name|error
operator|=
name|aac_init
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/*       * Print a little information about the controller.      */
name|aac_describe_controller
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*      * Register to probe our containers later.      */
name|sc
operator|->
name|aac_ich
operator|.
name|ich_func
operator|=
name|aac_startup
expr_stmt|;
name|sc
operator|->
name|aac_ich
operator|.
name|ich_arg
operator|=
name|sc
expr_stmt|;
if|if
condition|(
name|config_intrhook_establish
argument_list|(
operator|&
name|sc
operator|->
name|aac_ich
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"can't establish configuration hook\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/*      * Make the control device.      */
name|unit
operator|=
name|device_get_unit
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|aac_dev_t
operator|=
name|make_dev
argument_list|(
operator|&
name|aac_cdevsw
argument_list|,
name|unit
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0644
argument_list|,
literal|"aac%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|aac_dev_t
operator|->
name|si_drv1
operator|=
name|sc
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Probe for containers, create disks.  */
end_comment

begin_function
specifier|static
name|void
name|aac_startup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|aac_softc
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|aac_mntinfo
name|mi
decl_stmt|;
name|struct
name|aac_mntinforesponse
name|mir
decl_stmt|;
name|device_t
name|child
decl_stmt|;
name|u_int16_t
name|rsize
decl_stmt|;
name|int
name|i
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* disconnect ourselves from the intrhook chain */
name|config_intrhook_disestablish
argument_list|(
operator|&
name|sc
operator|->
name|aac_ich
argument_list|)
expr_stmt|;
comment|/* loop over possible containers */
name|mi
operator|.
name|Command
operator|=
name|VM_NameServe
expr_stmt|;
name|mi
operator|.
name|MntType
operator|=
name|FT_FILESYS
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AAC_MAX_CONTAINERS
condition|;
name|i
operator|++
control|)
block|{
comment|/* request information on this container */
name|mi
operator|.
name|MntCount
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|aac_sync_fib
argument_list|(
name|sc
argument_list|,
name|ContainerCommand
argument_list|,
literal|0
argument_list|,
operator|&
name|mi
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_mntinfo
argument_list|)
argument_list|,
operator|&
name|mir
argument_list|,
operator|&
name|rsize
argument_list|)
condition|)
block|{
name|debug
argument_list|(
literal|2
argument_list|,
literal|"error probing container %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* check response size */
if|if
condition|(
name|rsize
operator|!=
sizeof|sizeof
argument_list|(
name|mir
argument_list|)
condition|)
block|{
name|debug
argument_list|(
literal|2
argument_list|,
literal|"container info response wrong size (%d should be %d)"
argument_list|,
name|rsize
argument_list|,
sizeof|sizeof
argument_list|(
name|mir
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/*  	 * Check container volume type for validity.  Note that many of the possible types 	 * may never show up. 	 */
if|if
condition|(
operator|(
name|mir
operator|.
name|Status
operator|==
name|ST_OK
operator|)
operator|&&
operator|(
name|mir
operator|.
name|MntTable
index|[
literal|0
index|]
operator|.
name|VolType
operator|!=
name|CT_NONE
operator|)
condition|)
block|{
name|debug
argument_list|(
literal|1
argument_list|,
literal|"%d: id %x  name '%.16s'  size %u  type %d"
argument_list|,
name|i
argument_list|,
name|mir
operator|.
name|MntTable
index|[
literal|0
index|]
operator|.
name|ObjectId
argument_list|,
name|mir
operator|.
name|MntTable
index|[
literal|0
index|]
operator|.
name|FileSystemName
argument_list|,
name|mir
operator|.
name|MntTable
index|[
literal|0
index|]
operator|.
name|Capacity
argument_list|,
name|mir
operator|.
name|MntTable
index|[
literal|0
index|]
operator|.
name|VolType
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|child
operator|=
name|device_add_child
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"device_add_child failed\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_set_ivars
argument_list|(
name|child
argument_list|,
operator|&
name|sc
operator|->
name|aac_container
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|device_set_desc
argument_list|(
name|child
argument_list|,
name|aac_describe_code
argument_list|(
name|aac_container_types
argument_list|,
name|mir
operator|.
name|MntTable
index|[
literal|0
index|]
operator|.
name|VolType
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|aac_container
index|[
name|i
index|]
operator|.
name|co_disk
operator|=
name|child
expr_stmt|;
name|sc
operator|->
name|aac_container
index|[
name|i
index|]
operator|.
name|co_mntobj
operator|=
name|mir
operator|.
name|MntTable
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
comment|/* poke the bus to actually attach the child devices */
if|if
condition|(
name|bus_generic_attach
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"bus_generic_attach failed\n"
argument_list|)
expr_stmt|;
comment|/* mark the controller up */
name|sc
operator|->
name|aac_state
operator|&=
operator|~
name|AAC_STATE_SUSPEND
expr_stmt|;
comment|/* enable interrupts now */
name|AAC_UNMASK_INTERRUPTS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* enable the timeout watchdog */
name|timeout
argument_list|(
operator|(
name|timeout_t
operator|*
operator|)
name|aac_timeout
argument_list|,
name|sc
argument_list|,
name|AAC_PERIODIC_INTERVAL
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Free all of the resources associated with (sc)  *  * Should not be called if the controller is active.  */
end_comment

begin_function
name|void
name|aac_free
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* remove the control device */
if|if
condition|(
name|sc
operator|->
name|aac_dev_t
operator|!=
name|NULL
condition|)
name|destroy_dev
argument_list|(
name|sc
operator|->
name|aac_dev_t
argument_list|)
expr_stmt|;
comment|/* throw away any FIB buffers, discard the FIB DMA tag */
if|if
condition|(
name|sc
operator|->
name|aac_fibs
operator|!=
name|NULL
condition|)
name|aac_free_commands
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|aac_fib_dmat
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|aac_fib_dmat
argument_list|)
expr_stmt|;
comment|/* destroy the common area */
if|if
condition|(
name|sc
operator|->
name|aac_common
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|aac_common_dmat
argument_list|,
name|sc
operator|->
name|aac_common_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|aac_common_dmat
argument_list|,
name|sc
operator|->
name|aac_common
argument_list|,
name|sc
operator|->
name|aac_common_dmamap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|aac_common_dmat
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|aac_common_dmat
argument_list|)
expr_stmt|;
comment|/* disconnect the interrupt handler */
if|if
condition|(
name|sc
operator|->
name|aac_intr
condition|)
name|bus_teardown_intr
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
name|sc
operator|->
name|aac_irq
argument_list|,
name|sc
operator|->
name|aac_intr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|aac_irq
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|aac_irq_rid
argument_list|,
name|sc
operator|->
name|aac_irq
argument_list|)
expr_stmt|;
comment|/* destroy data-transfer DMA tag */
if|if
condition|(
name|sc
operator|->
name|aac_buffer_dmat
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|aac_buffer_dmat
argument_list|)
expr_stmt|;
comment|/* destroy the parent DMA tag */
if|if
condition|(
name|sc
operator|->
name|aac_parent_dmat
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|aac_parent_dmat
argument_list|)
expr_stmt|;
comment|/* release the register window mapping */
if|if
condition|(
name|sc
operator|->
name|aac_regs_resource
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|aac_regs_rid
argument_list|,
name|sc
operator|->
name|aac_regs_resource
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Disconnect from the controller completely, in preparation for unload.  */
end_comment

begin_function
name|int
name|aac_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|aac_state
operator|&
name|AAC_STATE_OPEN
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|aac_shutdown
argument_list|(
name|dev
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|aac_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Bring the controller down to a dormant state and detach all child devices.  *  * This function is called before detach or system shutdown.  *  * Note that we can assume that the bioq on the controller is empty, as we won't  * allow shutdown if any device is open.  */
end_comment

begin_function
name|int
name|aac_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|aac_close_command
name|cc
decl_stmt|;
name|int
name|s
decl_stmt|,
name|i
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|sc
operator|->
name|aac_state
operator||=
name|AAC_STATE_SUSPEND
expr_stmt|;
comment|/*       * Send a Container shutdown followed by a HostShutdown FIB to the      * controller to convince it that we don't want to talk to it anymore.      * We've been closed and all I/O completed already      */
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"shutting down controller..."
argument_list|)
expr_stmt|;
name|cc
operator|.
name|Command
operator|=
name|VM_CloseAll
expr_stmt|;
name|cc
operator|.
name|ContainerId
operator|=
literal|0xffffffff
expr_stmt|;
if|if
condition|(
name|aac_sync_fib
argument_list|(
name|sc
argument_list|,
name|ContainerCommand
argument_list|,
literal|0
argument_list|,
operator|&
name|cc
argument_list|,
sizeof|sizeof
argument_list|(
name|cc
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"FAILED.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|aac_sync_fib
argument_list|(
name|sc
argument_list|,
name|FsaHostShutdown
argument_list|,
name|AAC_FIBSTATE_SHUTDOWN
argument_list|,
operator|&
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|i
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"FAILED.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"done.\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|AAC_MASK_INTERRUPTS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Bring the controller to a quiescent state, ready for system suspend.  */
end_comment

begin_function
name|int
name|aac_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|s
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|sc
operator|->
name|aac_state
operator||=
name|AAC_STATE_SUSPEND
expr_stmt|;
name|AAC_MASK_INTERRUPTS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Bring the controller back to a state ready for operation.  */
end_comment

begin_function
name|int
name|aac_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|aac_state
operator|&=
operator|~
name|AAC_STATE_SUSPEND
expr_stmt|;
name|AAC_UNMASK_INTERRUPTS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  * Take an interrupt.  */
end_comment

begin_function
name|void
name|aac_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|aac_softc
operator|*
operator|)
name|arg
decl_stmt|;
name|u_int16_t
name|reason
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|reason
operator|=
name|AAC_GET_ISTATUS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* controller wants to talk to the log?  XXX should we defer this? */
if|if
condition|(
name|reason
operator|&
name|AAC_DB_PRINTF
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|aac_common
operator|->
name|ac_printf
index|[
literal|0
index|]
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"** %.*s"
argument_list|,
name|AAC_PRINTF_BUFSIZE
argument_list|,
name|sc
operator|->
name|aac_common
operator|->
name|ac_printf
argument_list|)
expr_stmt|;
name|sc
operator|->
name|aac_common
operator|->
name|ac_printf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|AAC_CLEAR_ISTATUS
argument_list|(
name|sc
argument_list|,
name|AAC_DB_PRINTF
argument_list|)
expr_stmt|;
name|AAC_QNOTIFY
argument_list|(
name|sc
argument_list|,
name|AAC_DB_PRINTF
argument_list|)
expr_stmt|;
block|}
comment|/* controller has a message for us? */
if|if
condition|(
name|reason
operator|&
name|AAC_DB_COMMAND_READY
condition|)
block|{
name|aac_host_command
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|AAC_CLEAR_ISTATUS
argument_list|(
name|sc
argument_list|,
name|AAC_DB_COMMAND_READY
argument_list|)
expr_stmt|;
block|}
comment|/* controller has a response for us? */
if|if
condition|(
name|reason
operator|&
name|AAC_DB_RESPONSE_READY
condition|)
block|{
name|aac_host_response
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|AAC_CLEAR_ISTATUS
argument_list|(
name|sc
argument_list|,
name|AAC_DB_RESPONSE_READY
argument_list|)
expr_stmt|;
block|}
comment|/* spurious interrupts that we don't use - reset the mask and clear the interrupts */
if|if
condition|(
name|reason
operator|&
operator|(
name|AAC_DB_COMMAND_NOT_FULL
operator||
name|AAC_DB_RESPONSE_NOT_FULL
operator|)
condition|)
block|{
name|AAC_UNMASK_INTERRUPTS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|AAC_CLEAR_ISTATUS
argument_list|(
name|sc
argument_list|,
name|AAC_DB_COMMAND_NOT_FULL
operator||
name|AAC_DB_RESPONSE_NOT_FULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/********************************************************************************  ********************************************************************************                                                                Command Processing  ********************************************************************************  ********************************************************************************/
end_comment

begin_comment
comment|/********************************************************************************  * Start as much queued I/O as possible on the controller  */
end_comment

begin_function
specifier|static
name|void
name|aac_startio
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|aac_command
modifier|*
name|cm
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* try to get a command that's been put off for lack of resources */
name|cm
operator|=
name|aac_dequeue_ready
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* try to build a command off the bio queue (ignore error return) */
if|if
condition|(
name|cm
operator|==
name|NULL
condition|)
name|aac_bio_command
argument_list|(
name|sc
argument_list|,
operator|&
name|cm
argument_list|)
expr_stmt|;
comment|/* nothing to do? */
if|if
condition|(
name|cm
operator|==
name|NULL
condition|)
break|break;
comment|/* try to give the command to the controller */
if|if
condition|(
name|aac_start
argument_list|(
name|cm
argument_list|)
operator|==
name|EBUSY
condition|)
block|{
comment|/* put it on the ready queue for later */
name|aac_requeue_ready
argument_list|(
name|cm
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/********************************************************************************  * Deliver a command to the controller; allocate controller resources at the  * last moment when possible.  */
end_comment

begin_function
specifier|static
name|int
name|aac_start
parameter_list|(
name|struct
name|aac_command
modifier|*
name|cm
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
init|=
name|cm
operator|->
name|cm_sc
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* get the command mapped */
name|aac_map_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
comment|/* fix up the address values in the FIB */
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|SenderFibAddress
operator|=
operator|(
name|u_int32_t
operator|)
name|cm
operator|->
name|cm_fib
expr_stmt|;
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|ReceiverFibAddress
operator|=
name|cm
operator|->
name|cm_fibphys
expr_stmt|;
comment|/* save a pointer to the command for speedy reverse-lookup */
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|SenderData
operator|=
operator|(
name|u_int32_t
operator|)
name|cm
expr_stmt|;
comment|/* XXX 64-bit physical address issue */
comment|/* put the FIB on the outbound queue */
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
name|aac_enqueue_fib
argument_list|(
name|sc
argument_list|,
name|AAC_ADAP_NORM_CMD_QUEUE
argument_list|,
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|Size
argument_list|,
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|ReceiverFibAddress
argument_list|)
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
block|}
else|else
block|{
name|aac_enqueue_busy
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Handle notification of one or more FIBs coming from the controller.  */
end_comment

begin_function
specifier|static
name|void
name|aac_host_command
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|aac_fib
modifier|*
name|fib
decl_stmt|;
name|u_int32_t
name|fib_size
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|aac_dequeue_fib
argument_list|(
name|sc
argument_list|,
name|AAC_HOST_NORM_CMD_QUEUE
argument_list|,
operator|&
name|fib_size
argument_list|,
operator|&
name|fib
argument_list|)
condition|)
break|break;
comment|/* nothing to do */
switch|switch
condition|(
name|fib
operator|->
name|Header
operator|.
name|Command
condition|)
block|{
case|case
name|AifRequest
case|:
name|aac_handle_aif
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|aac_aif_command
operator|*
operator|)
operator|&
name|fib
operator|->
name|data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"unknown command from controller\n"
argument_list|)
expr_stmt|;
name|AAC_PRINT_FIB
argument_list|(
name|sc
argument_list|,
name|fib
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* XXX reply to FIBs requesting responses ?? */
comment|/* XXX how do we return these FIBs to the controller? */
block|}
block|}
end_function

begin_comment
comment|/********************************************************************************  * Handle notification of one or more FIBs completed by the controller  */
end_comment

begin_function
specifier|static
name|void
name|aac_host_response
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|aac_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|aac_fib
modifier|*
name|fib
decl_stmt|;
name|u_int32_t
name|fib_size
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* look for completed FIBs on our queue */
if|if
condition|(
name|aac_dequeue_fib
argument_list|(
name|sc
argument_list|,
name|AAC_HOST_NORM_RESP_QUEUE
argument_list|,
operator|&
name|fib_size
argument_list|,
operator|&
name|fib
argument_list|)
condition|)
break|break;
comment|/* nothing to do */
comment|/* get the command, unmap and queue for later processing */
name|cm
operator|=
operator|(
expr|struct
name|aac_command
operator|*
operator|)
name|fib
operator|->
name|Header
operator|.
name|SenderData
expr_stmt|;
if|if
condition|(
name|cm
operator|==
name|NULL
condition|)
block|{
name|AAC_PRINT_FIB
argument_list|(
name|sc
argument_list|,
name|fib
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|aac_remove_busy
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|aac_unmap_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
comment|/* XXX defer? */
name|aac_enqueue_complete
argument_list|(
name|cm
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* handle completion processing */
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500005
name|taskqueue_enqueue
argument_list|(
name|taskqueue_swi
argument_list|,
operator|&
name|sc
operator|->
name|aac_task_complete
argument_list|)
expr_stmt|;
else|#
directive|else
name|aac_complete
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/********************************************************************************  * Process completed commands.  */
end_comment

begin_function
specifier|static
name|void
name|aac_complete
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|aac_softc
operator|*
operator|)
name|context
decl_stmt|;
name|struct
name|aac_command
modifier|*
name|cm
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* pull completed commands off the queue */
for|for
control|(
init|;
condition|;
control|)
block|{
name|cm
operator|=
name|aac_dequeue_complete
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|==
name|NULL
condition|)
break|break;
name|cm
operator|->
name|cm_flags
operator||=
name|AAC_CMD_COMPLETED
expr_stmt|;
comment|/* is there a completion handler? */
if|if
condition|(
name|cm
operator|->
name|cm_complete
operator|!=
name|NULL
condition|)
block|{
name|cm
operator|->
name|cm_complete
argument_list|(
name|cm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* assume that someone is sleeping on this command */
name|wakeup
argument_list|(
name|cm
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* see if we can start some more I/O */
name|aac_startio
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Handle a bio submitted from a disk device.  */
end_comment

begin_function
name|void
name|aac_submit_bio
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|aac_disk
modifier|*
name|ad
init|=
operator|(
expr|struct
name|aac_disk
operator|*
operator|)
name|bp
operator|->
name|bio_dev
operator|->
name|si_drv1
decl_stmt|;
name|struct
name|aac_softc
modifier|*
name|sc
init|=
name|ad
operator|->
name|ad_controller
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* queue the BIO and try to get some work done */
name|aac_enqueue_bio
argument_list|(
name|sc
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|aac_startio
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Get a bio and build a command to go with it.  */
end_comment

begin_function
specifier|static
name|int
name|aac_bio_command
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|aac_command
modifier|*
modifier|*
name|cmp
parameter_list|)
block|{
name|struct
name|aac_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|aac_fib
modifier|*
name|fib
decl_stmt|;
name|struct
name|aac_blockread
modifier|*
name|br
decl_stmt|;
name|struct
name|aac_blockwrite
modifier|*
name|bw
decl_stmt|;
name|struct
name|aac_disk
modifier|*
name|ad
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* get the resources we will need */
name|cm
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|=
name|aac_dequeue_bio
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|aac_alloc_command
argument_list|(
name|sc
argument_list|,
operator|&
name|cm
argument_list|)
condition|)
comment|/* get a command */
goto|goto
name|fail
goto|;
comment|/* fill out the command */
name|cm
operator|->
name|cm_data
operator|=
operator|(
name|void
operator|*
operator|)
name|bp
operator|->
name|bio_data
expr_stmt|;
name|cm
operator|->
name|cm_datalen
operator|=
name|bp
operator|->
name|bio_bcount
expr_stmt|;
name|cm
operator|->
name|cm_complete
operator|=
name|aac_bio_complete
expr_stmt|;
name|cm
operator|->
name|cm_private
operator|=
name|bp
expr_stmt|;
name|cm
operator|->
name|cm_timestamp
operator|=
name|time_second
expr_stmt|;
comment|/* build the FIB */
name|fib
operator|=
name|cm
operator|->
name|cm_fib
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|XferState
operator|=
name|AAC_FIBSTATE_HOSTOWNED
operator||
name|AAC_FIBSTATE_INITIALISED
operator||
name|AAC_FIBSTATE_FROMHOST
operator||
name|AAC_FIBSTATE_REXPECTED
operator||
name|AAC_FIBSTATE_NORM
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|Command
operator|=
name|ContainerCommand
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|Size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib_header
argument_list|)
expr_stmt|;
comment|/* build the read/write request */
name|ad
operator|=
operator|(
expr|struct
name|aac_disk
operator|*
operator|)
name|bp
operator|->
name|bio_dev
operator|->
name|si_drv1
expr_stmt|;
if|if
condition|(
name|BIO_IS_READ
argument_list|(
name|bp
argument_list|)
condition|)
block|{
name|br
operator|=
operator|(
expr|struct
name|aac_blockread
operator|*
operator|)
operator|&
name|fib
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
name|br
operator|->
name|Command
operator|=
name|VM_CtBlockRead
expr_stmt|;
name|br
operator|->
name|ContainerId
operator|=
name|ad
operator|->
name|ad_container
operator|->
name|co_mntobj
operator|.
name|ObjectId
expr_stmt|;
name|br
operator|->
name|BlockNumber
operator|=
name|bp
operator|->
name|bio_pblkno
expr_stmt|;
name|br
operator|->
name|ByteCount
operator|=
name|bp
operator|->
name|bio_bcount
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|Size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|aac_blockread
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_sgtable
operator|=
operator|&
name|br
operator|->
name|SgMap
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator||=
name|AAC_CMD_DATAIN
expr_stmt|;
block|}
else|else
block|{
name|bw
operator|=
operator|(
expr|struct
name|aac_blockwrite
operator|*
operator|)
operator|&
name|fib
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
name|bw
operator|->
name|Command
operator|=
name|VM_CtBlockWrite
expr_stmt|;
name|bw
operator|->
name|ContainerId
operator|=
name|ad
operator|->
name|ad_container
operator|->
name|co_mntobj
operator|.
name|ObjectId
expr_stmt|;
name|bw
operator|->
name|BlockNumber
operator|=
name|bp
operator|->
name|bio_pblkno
expr_stmt|;
name|bw
operator|->
name|ByteCount
operator|=
name|bp
operator|->
name|bio_bcount
expr_stmt|;
name|bw
operator|->
name|Stable
operator|=
name|CUNSTABLE
expr_stmt|;
comment|/* XXX what's appropriate here? */
name|fib
operator|->
name|Header
operator|.
name|Size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|aac_blockwrite
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator||=
name|AAC_CMD_DATAOUT
expr_stmt|;
name|cm
operator|->
name|cm_sgtable
operator|=
operator|&
name|bw
operator|->
name|SgMap
expr_stmt|;
block|}
operator|*
name|cmp
operator|=
name|cm
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
name|aac_enqueue_bio
argument_list|(
name|sc
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|!=
name|NULL
condition|)
name|aac_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Handle a bio-instigated command that has been completed.  */
end_comment

begin_function
specifier|static
name|void
name|aac_bio_complete
parameter_list|(
name|struct
name|aac_command
modifier|*
name|cm
parameter_list|)
block|{
name|struct
name|aac_blockread_response
modifier|*
name|brr
decl_stmt|;
name|struct
name|aac_blockwrite_response
modifier|*
name|bwr
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|AAC_FSAStatus
name|status
decl_stmt|;
comment|/* fetch relevant status and then release the command */
name|bp
operator|=
operator|(
expr|struct
name|bio
operator|*
operator|)
name|cm
operator|->
name|cm_private
expr_stmt|;
if|if
condition|(
name|BIO_IS_READ
argument_list|(
name|bp
argument_list|)
condition|)
block|{
name|brr
operator|=
operator|(
expr|struct
name|aac_blockread_response
operator|*
operator|)
operator|&
name|cm
operator|->
name|cm_fib
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
name|status
operator|=
name|brr
operator|->
name|Status
expr_stmt|;
block|}
else|else
block|{
name|bwr
operator|=
operator|(
expr|struct
name|aac_blockwrite_response
operator|*
operator|)
operator|&
name|cm
operator|->
name|cm_fib
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
name|status
operator|=
name|bwr
operator|->
name|Status
expr_stmt|;
block|}
name|aac_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
comment|/* fix up the bio based on status */
if|if
condition|(
name|status
operator|==
name|ST_OK
condition|)
block|{
name|bp
operator|->
name|bio_resid
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|bp
operator|->
name|bio_error
operator|=
name|EIO
expr_stmt|;
name|bp
operator|->
name|bio_flags
operator||=
name|BIO_ERROR
expr_stmt|;
comment|/* pass an error string out to the disk layer */
name|bp
operator|->
name|bio_driver1
operator|=
name|aac_describe_code
argument_list|(
name|aac_command_status_table
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
name|aac_biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Submit a command to the controller, return when it completes.  */
end_comment

begin_function
specifier|static
name|int
name|aac_wait_command
parameter_list|(
name|struct
name|aac_command
modifier|*
name|cm
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* Put the command on the ready queue and get things going */
name|aac_enqueue_ready
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|aac_startio
argument_list|(
name|cm
operator|->
name|cm_sc
argument_list|)
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|cm
operator|->
name|cm_flags
operator|&
name|AAC_CMD_COMPLETED
operator|)
operator|&&
operator|(
name|error
operator|!=
name|EWOULDBLOCK
operator|)
condition|)
block|{
name|error
operator|=
name|tsleep
argument_list|(
name|cm
argument_list|,
name|PRIBIO
argument_list|,
literal|"aacwait"
argument_list|,
name|timeout
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/********************************************************************************  ********************************************************************************                                                         Command Buffer Management  ********************************************************************************  ********************************************************************************/
end_comment

begin_comment
comment|/********************************************************************************  * Allocate a command.  */
end_comment

begin_function
specifier|static
name|int
name|aac_alloc_command
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|aac_command
modifier|*
modifier|*
name|cmp
parameter_list|)
block|{
name|struct
name|aac_command
modifier|*
name|cm
decl_stmt|;
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|=
name|aac_dequeue_free
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
operator|*
name|cmp
operator|=
name|cm
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Release a command back to the freelist.  */
end_comment

begin_function
specifier|static
name|void
name|aac_release_command
parameter_list|(
name|struct
name|aac_command
modifier|*
name|cm
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
comment|/* (re)initialise the command/FIB */
name|cm
operator|->
name|cm_sgtable
operator|=
name|NULL
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator|=
literal|0
expr_stmt|;
name|cm
operator|->
name|cm_complete
operator|=
name|NULL
expr_stmt|;
name|cm
operator|->
name|cm_private
operator|=
name|NULL
expr_stmt|;
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|XferState
operator|=
name|AAC_FIBSTATE_EMPTY
expr_stmt|;
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|StructType
operator|=
name|AAC_FIBTYPE_TFIB
expr_stmt|;
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|Flags
operator|=
literal|0
expr_stmt|;
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|SenderSize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
expr_stmt|;
comment|/*       * These are duplicated in aac_start to cover the case where an      * intermediate stage may have destroyed them.  They're left      * initialised here for debugging purposes only.      */
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|SenderFibAddress
operator|=
operator|(
name|u_int32_t
operator|)
name|cm
operator|->
name|cm_fib
expr_stmt|;
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|ReceiverFibAddress
operator|=
name|cm
operator|->
name|cm_fibphys
expr_stmt|;
name|aac_enqueue_free
argument_list|(
name|cm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Map helper for command/FIB allocation.  */
end_comment

begin_function
specifier|static
name|void
name|aac_map_command_helper
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|aac_softc
operator|*
operator|)
name|arg
decl_stmt|;
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|sc
operator|->
name|aac_fibphys
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Allocate and initialise commands/FIBs for this adapter.  */
end_comment

begin_function
specifier|static
name|int
name|aac_alloc_commands
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|aac_command
modifier|*
name|cm
decl_stmt|;
name|int
name|i
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* allocate the FIBs in DMAable memory and load them */
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|aac_fib_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|aac_fibs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|aac_fibmap
argument_list|)
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|aac_fib_dmat
argument_list|,
name|sc
operator|->
name|aac_fibmap
argument_list|,
name|sc
operator|->
name|aac_fibs
argument_list|,
name|AAC_FIB_COUNT
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
argument_list|,
name|aac_map_command_helper
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* initialise constant fields in the command structure */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AAC_FIB_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|cm
operator|=
operator|&
name|sc
operator|->
name|aac_command
index|[
name|i
index|]
expr_stmt|;
name|cm
operator|->
name|cm_sc
operator|=
name|sc
expr_stmt|;
name|cm
operator|->
name|cm_fib
operator|=
name|sc
operator|->
name|aac_fibs
operator|+
name|i
expr_stmt|;
name|cm
operator|->
name|cm_fibphys
operator|=
name|sc
operator|->
name|aac_fibphys
operator|+
operator|(
name|i
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|aac_buffer_dmat
argument_list|,
literal|0
argument_list|,
operator|&
name|cm
operator|->
name|cm_datamap
argument_list|)
condition|)
name|aac_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Free FIBs owned by this adapter.  */
end_comment

begin_function
specifier|static
name|void
name|aac_free_commands
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AAC_FIB_COUNT
condition|;
name|i
operator|++
control|)
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|aac_buffer_dmat
argument_list|,
name|sc
operator|->
name|aac_command
index|[
name|i
index|]
operator|.
name|cm_datamap
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|aac_fib_dmat
argument_list|,
name|sc
operator|->
name|aac_fibmap
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|aac_fib_dmat
argument_list|,
name|sc
operator|->
name|aac_fibs
argument_list|,
name|sc
operator|->
name|aac_fibmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Command-mapping helper function - populate this command's s/g table.  */
end_comment

begin_function
specifier|static
name|void
name|aac_map_command_sg
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|aac_command
modifier|*
name|cm
init|=
operator|(
expr|struct
name|aac_command
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|aac_fib
modifier|*
name|fib
init|=
name|cm
operator|->
name|cm_fib
decl_stmt|;
name|struct
name|aac_sg_table
modifier|*
name|sg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
comment|/* find the s/g table */
name|sg
operator|=
name|cm
operator|->
name|cm_sgtable
expr_stmt|;
comment|/* copy into the FIB */
if|if
condition|(
name|sg
operator|!=
name|NULL
condition|)
block|{
name|sg
operator|->
name|SgCount
operator|=
name|nseg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nseg
condition|;
name|i
operator|++
control|)
block|{
name|sg
operator|->
name|SgEntry
index|[
name|i
index|]
operator|.
name|SgAddress
operator|=
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
expr_stmt|;
name|sg
operator|->
name|SgEntry
index|[
name|i
index|]
operator|.
name|SgByteCount
operator|=
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
expr_stmt|;
block|}
comment|/* update the FIB size for the s/g count */
name|fib
operator|->
name|Header
operator|.
name|Size
operator|+=
name|nseg
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|aac_sg_entry
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/********************************************************************************  * Map a command into controller-visible space.  */
end_comment

begin_function
specifier|static
name|void
name|aac_map_command
parameter_list|(
name|struct
name|aac_command
modifier|*
name|cm
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
init|=
name|cm
operator|->
name|cm_sc
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* don't map more than once */
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|AAC_CMD_MAPPED
condition|)
return|return;
if|if
condition|(
name|cm
operator|->
name|cm_datalen
operator|!=
literal|0
condition|)
block|{
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|aac_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_datamap
argument_list|,
name|cm
operator|->
name|cm_data
argument_list|,
name|cm
operator|->
name|cm_datalen
argument_list|,
name|aac_map_command_sg
argument_list|,
name|cm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|AAC_CMD_DATAIN
condition|)
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|aac_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_datamap
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|AAC_CMD_DATAOUT
condition|)
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|aac_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_datamap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
name|cm
operator|->
name|cm_flags
operator||=
name|AAC_CMD_MAPPED
expr_stmt|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Unmap a command from controller-visible space.  */
end_comment

begin_function
specifier|static
name|void
name|aac_unmap_command
parameter_list|(
name|struct
name|aac_command
modifier|*
name|cm
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
init|=
name|cm
operator|->
name|cm_sc
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cm
operator|->
name|cm_flags
operator|&
name|AAC_CMD_MAPPED
operator|)
condition|)
return|return;
if|if
condition|(
name|cm
operator|->
name|cm_datalen
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|AAC_CMD_DATAIN
condition|)
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|aac_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_datamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|AAC_CMD_DATAOUT
condition|)
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|aac_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_datamap
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|aac_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_datamap
argument_list|)
expr_stmt|;
block|}
name|cm
operator|->
name|cm_flags
operator|&=
operator|~
name|AAC_CMD_MAPPED
expr_stmt|;
block|}
end_function

begin_comment
comment|/********************************************************************************  ********************************************************************************                                                                Hardware Interface  ********************************************************************************  ********************************************************************************/
end_comment

begin_comment
comment|/********************************************************************************  * Initialise the adapter.  */
end_comment

begin_function
specifier|static
name|void
name|aac_common_map
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|aac_softc
operator|*
operator|)
name|arg
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|aac_common_busaddr
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|aac_init
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|aac_adapter_init
modifier|*
name|ip
decl_stmt|;
name|time_t
name|then
decl_stmt|;
name|u_int32_t
name|code
decl_stmt|;
name|u_int8_t
modifier|*
name|qaddr
decl_stmt|;
name|debug_called
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*      * First wait for the adapter to come ready.      */
name|then
operator|=
name|time_second
expr_stmt|;
do|do
block|{
name|code
operator|=
name|AAC_GET_FWSTATUS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|&
name|AAC_SELF_TEST_FAILED
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"FATAL: selftest failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|code
operator|&
name|AAC_KERNEL_PANIC
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"FATAL: controller kernel panic\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|time_second
operator|>
operator|(
name|then
operator|+
name|AAC_BOOT_TIMEOUT
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"FATAL: controller not coming ready, status %x\n"
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
do|while
condition|(
operator|!
operator|(
name|code
operator|&
name|AAC_UP_AND_RUNNING
operator|)
condition|)
do|;
comment|/*      * Create DMA tag for the common structure and allocate it.      */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|aac_parent_dmat
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* alignment, boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
sizeof|sizeof
argument_list|(
expr|struct
name|aac_common
argument_list|)
argument_list|,
literal|1
argument_list|,
comment|/* maxsize, nsegments */
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
operator|&
name|sc
operator|->
name|aac_common_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"can't allocate common structure DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|aac_common_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|aac_common
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|aac_common_dmamap
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"can't allocate common structure\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|aac_common_dmat
argument_list|,
name|sc
operator|->
name|aac_common_dmamap
argument_list|,
name|sc
operator|->
name|aac_common
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
operator|->
name|aac_common
argument_list|)
argument_list|,
name|aac_common_map
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|aac_common
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
operator|->
name|aac_common
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * Fill in the init structure.  This tells the adapter about the physical location      * of various important shared data structures.      */
name|ip
operator|=
operator|&
name|sc
operator|->
name|aac_common
operator|->
name|ac_init
expr_stmt|;
name|ip
operator|->
name|InitStructRevision
operator|=
name|AAC_INIT_STRUCT_REVISION
expr_stmt|;
name|ip
operator|->
name|AdapterFibsPhysicalAddress
operator|=
name|sc
operator|->
name|aac_common_busaddr
operator|+
name|fldoff
argument_list|(
name|aac_common
argument_list|,
name|ac_fibs
argument_list|)
expr_stmt|;
name|ip
operator|->
name|AdapterFibsVirtualAddress
operator|=
operator|&
name|sc
operator|->
name|aac_common
operator|->
name|ac_fibs
index|[
literal|0
index|]
expr_stmt|;
name|ip
operator|->
name|AdapterFibsSize
operator|=
name|AAC_ADAPTER_FIBS
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
expr_stmt|;
name|ip
operator|->
name|AdapterFibAlign
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
expr_stmt|;
name|ip
operator|->
name|PrintfBufferAddress
operator|=
name|sc
operator|->
name|aac_common_busaddr
operator|+
name|fldoff
argument_list|(
name|aac_common
argument_list|,
name|ac_printf
argument_list|)
expr_stmt|;
name|ip
operator|->
name|PrintfBufferSize
operator|=
name|AAC_PRINTF_BUFSIZE
expr_stmt|;
name|ip
operator|->
name|HostPhysMemPages
operator|=
literal|0
expr_stmt|;
comment|/* not used? */
name|ip
operator|->
name|HostElapsedSeconds
operator|=
name|time_second
expr_stmt|;
comment|/* reset later if invalid */
comment|/*      * Initialise FIB queues.  Note that it appears that the layout of the indexes      * and the segmentation of the entries may be mandated by the adapter, which is       * only told about the base of the queue index fields.      *      * The initial values of the indices are assumed to inform the adapter      * of the sizes of the respective queues, and theoretically it could work out      * the entire layout of the queue structures from this.  We take the easy      * route and just lay this area out like everyone else does.      *      * The Linux driver uses a much more complex scheme whereby several header      * records are kept for each queue.  We use a couple of generic list manipulation      * functions which 'know' the size of each list by virtue of a table.      */
name|qaddr
operator|=
operator|&
name|sc
operator|->
name|aac_common
operator|->
name|ac_qbuf
index|[
literal|0
index|]
operator|+
name|AAC_QUEUE_ALIGN
expr_stmt|;
name|qaddr
operator|-=
operator|(
name|u_int32_t
operator|)
name|qaddr
operator|%
name|AAC_QUEUE_ALIGN
expr_stmt|;
name|sc
operator|->
name|aac_queues
operator|=
operator|(
expr|struct
name|aac_queue_table
operator|*
operator|)
name|qaddr
expr_stmt|;
name|ip
operator|->
name|CommHeaderAddress
operator|=
name|sc
operator|->
name|aac_common_busaddr
operator|+
operator|(
operator|(
name|u_int32_t
operator|)
name|sc
operator|->
name|aac_queues
operator|-
operator|(
name|u_int32_t
operator|)
name|sc
operator|->
name|aac_common
operator|)
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|aac_queues
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_queue_table
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|AAC_HOST_NORM_CMD_QUEUE
index|]
index|[
name|AAC_PRODUCER_INDEX
index|]
operator|=
name|AAC_HOST_NORM_CMD_ENTRIES
expr_stmt|;
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|AAC_HOST_NORM_CMD_QUEUE
index|]
index|[
name|AAC_CONSUMER_INDEX
index|]
operator|=
name|AAC_HOST_NORM_CMD_ENTRIES
expr_stmt|;
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|AAC_HOST_HIGH_CMD_QUEUE
index|]
index|[
name|AAC_PRODUCER_INDEX
index|]
operator|=
name|AAC_HOST_HIGH_CMD_ENTRIES
expr_stmt|;
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|AAC_HOST_HIGH_CMD_QUEUE
index|]
index|[
name|AAC_CONSUMER_INDEX
index|]
operator|=
name|AAC_HOST_HIGH_CMD_ENTRIES
expr_stmt|;
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|AAC_ADAP_NORM_CMD_QUEUE
index|]
index|[
name|AAC_PRODUCER_INDEX
index|]
operator|=
name|AAC_ADAP_NORM_CMD_ENTRIES
expr_stmt|;
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|AAC_ADAP_NORM_CMD_QUEUE
index|]
index|[
name|AAC_CONSUMER_INDEX
index|]
operator|=
name|AAC_ADAP_NORM_CMD_ENTRIES
expr_stmt|;
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|AAC_ADAP_HIGH_CMD_QUEUE
index|]
index|[
name|AAC_PRODUCER_INDEX
index|]
operator|=
name|AAC_ADAP_HIGH_CMD_ENTRIES
expr_stmt|;
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|AAC_ADAP_HIGH_CMD_QUEUE
index|]
index|[
name|AAC_CONSUMER_INDEX
index|]
operator|=
name|AAC_ADAP_HIGH_CMD_ENTRIES
expr_stmt|;
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|AAC_HOST_NORM_RESP_QUEUE
index|]
index|[
name|AAC_PRODUCER_INDEX
index|]
operator|=
name|AAC_HOST_NORM_RESP_ENTRIES
expr_stmt|;
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|AAC_HOST_NORM_RESP_QUEUE
index|]
index|[
name|AAC_CONSUMER_INDEX
index|]
operator|=
name|AAC_HOST_NORM_RESP_ENTRIES
expr_stmt|;
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|AAC_HOST_HIGH_RESP_QUEUE
index|]
index|[
name|AAC_PRODUCER_INDEX
index|]
operator|=
name|AAC_HOST_HIGH_RESP_ENTRIES
expr_stmt|;
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|AAC_HOST_HIGH_RESP_QUEUE
index|]
index|[
name|AAC_CONSUMER_INDEX
index|]
operator|=
name|AAC_HOST_HIGH_RESP_ENTRIES
expr_stmt|;
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|AAC_ADAP_NORM_RESP_QUEUE
index|]
index|[
name|AAC_PRODUCER_INDEX
index|]
operator|=
name|AAC_ADAP_NORM_RESP_ENTRIES
expr_stmt|;
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|AAC_ADAP_NORM_RESP_QUEUE
index|]
index|[
name|AAC_CONSUMER_INDEX
index|]
operator|=
name|AAC_ADAP_NORM_RESP_ENTRIES
expr_stmt|;
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|AAC_ADAP_HIGH_RESP_QUEUE
index|]
index|[
name|AAC_PRODUCER_INDEX
index|]
operator|=
name|AAC_ADAP_HIGH_RESP_ENTRIES
expr_stmt|;
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|AAC_ADAP_HIGH_RESP_QUEUE
index|]
index|[
name|AAC_CONSUMER_INDEX
index|]
operator|=
name|AAC_ADAP_HIGH_RESP_ENTRIES
expr_stmt|;
name|sc
operator|->
name|aac_qentries
index|[
name|AAC_HOST_NORM_CMD_QUEUE
index|]
operator|=
operator|&
name|sc
operator|->
name|aac_queues
operator|->
name|qt_HostNormCmdQueue
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|aac_qentries
index|[
name|AAC_HOST_HIGH_CMD_QUEUE
index|]
operator|=
operator|&
name|sc
operator|->
name|aac_queues
operator|->
name|qt_HostHighCmdQueue
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|aac_qentries
index|[
name|AAC_ADAP_NORM_CMD_QUEUE
index|]
operator|=
operator|&
name|sc
operator|->
name|aac_queues
operator|->
name|qt_AdapNormCmdQueue
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|aac_qentries
index|[
name|AAC_ADAP_HIGH_CMD_QUEUE
index|]
operator|=
operator|&
name|sc
operator|->
name|aac_queues
operator|->
name|qt_AdapHighCmdQueue
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|aac_qentries
index|[
name|AAC_HOST_NORM_RESP_QUEUE
index|]
operator|=
operator|&
name|sc
operator|->
name|aac_queues
operator|->
name|qt_HostNormRespQueue
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|aac_qentries
index|[
name|AAC_HOST_HIGH_RESP_QUEUE
index|]
operator|=
operator|&
name|sc
operator|->
name|aac_queues
operator|->
name|qt_HostHighRespQueue
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|aac_qentries
index|[
name|AAC_ADAP_NORM_RESP_QUEUE
index|]
operator|=
operator|&
name|sc
operator|->
name|aac_queues
operator|->
name|qt_AdapNormRespQueue
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|aac_qentries
index|[
name|AAC_ADAP_HIGH_RESP_QUEUE
index|]
operator|=
operator|&
name|sc
operator|->
name|aac_queues
operator|->
name|qt_AdapHighRespQueue
index|[
literal|0
index|]
expr_stmt|;
comment|/*      * Do controller-type-specific initialisation      */
switch|switch
condition|(
name|sc
operator|->
name|aac_hwif
condition|)
block|{
case|case
name|AAC_HWIF_I960RX
case|:
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RX_ODBR
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*      * Give the init structure to the controller.      */
if|if
condition|(
name|aac_sync_command
argument_list|(
name|sc
argument_list|,
name|AAC_MONKER_INITSTRUCT
argument_list|,
name|sc
operator|->
name|aac_common_busaddr
operator|+
name|fldoff
argument_list|(
name|aac_common
argument_list|,
name|ac_init
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"error establishing init structure\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Send a synchronous command to the controller and wait for a result.  */
end_comment

begin_function
specifier|static
name|int
name|aac_sync_command
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|command
parameter_list|,
name|u_int32_t
name|arg0
parameter_list|,
name|u_int32_t
name|arg1
parameter_list|,
name|u_int32_t
name|arg2
parameter_list|,
name|u_int32_t
name|arg3
parameter_list|,
name|u_int32_t
modifier|*
name|sp
parameter_list|)
block|{
name|time_t
name|then
decl_stmt|;
name|u_int32_t
name|status
decl_stmt|;
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
comment|/* populate the mailbox */
name|AAC_SET_MAILBOX
argument_list|(
name|sc
argument_list|,
name|command
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
comment|/* ensure the sync command doorbell flag is cleared */
name|AAC_CLEAR_ISTATUS
argument_list|(
name|sc
argument_list|,
name|AAC_DB_SYNC_COMMAND
argument_list|)
expr_stmt|;
comment|/* then set it to signal the adapter */
name|AAC_QNOTIFY
argument_list|(
name|sc
argument_list|,
name|AAC_DB_SYNC_COMMAND
argument_list|)
expr_stmt|;
comment|/* spin waiting for the command to complete */
name|then
operator|=
name|time_second
expr_stmt|;
do|do
block|{
if|if
condition|(
name|time_second
operator|>
operator|(
name|then
operator|+
name|AAC_IMMEDIATE_TIMEOUT
operator|)
condition|)
block|{
name|debug
argument_list|(
literal|2
argument_list|,
literal|"timed out"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
do|while
condition|(
operator|!
operator|(
name|AAC_GET_ISTATUS
argument_list|(
name|sc
argument_list|)
operator|&
name|AAC_DB_SYNC_COMMAND
operator|)
condition|)
do|;
comment|/* clear the completion flag */
name|AAC_CLEAR_ISTATUS
argument_list|(
name|sc
argument_list|,
name|AAC_DB_SYNC_COMMAND
argument_list|)
expr_stmt|;
comment|/* get the command status */
name|status
operator|=
name|AAC_GET_MAILBOXSTATUS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|!=
name|NULL
condition|)
operator|*
name|sp
operator|=
name|status
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Send a synchronous FIB to the controller and wait for a result.  */
end_comment

begin_function
specifier|static
name|int
name|aac_sync_fib
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|command
parameter_list|,
name|u_int32_t
name|xferstate
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|u_int16_t
name|datasize
parameter_list|,
name|void
modifier|*
name|result
parameter_list|,
name|u_int16_t
modifier|*
name|resultsize
parameter_list|)
block|{
name|struct
name|aac_fib
modifier|*
name|fib
init|=
operator|&
name|sc
operator|->
name|aac_common
operator|->
name|ac_sync_fib
decl_stmt|;
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|datasize
operator|>
name|AAC_FIB_DATASIZE
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/*      * Set up the sync FIB      */
name|fib
operator|->
name|Header
operator|.
name|XferState
operator|=
name|AAC_FIBSTATE_HOSTOWNED
operator||
name|AAC_FIBSTATE_INITIALISED
operator||
name|AAC_FIBSTATE_EMPTY
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|XferState
operator||=
name|xferstate
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|Command
operator|=
name|command
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|StructType
operator|=
name|AAC_FIBTYPE_TFIB
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|Size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
operator|+
name|datasize
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|SenderSize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|SenderFibAddress
operator|=
operator|(
name|u_int32_t
operator|)
name|fib
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|ReceiverFibAddress
operator|=
name|sc
operator|->
name|aac_common_busaddr
operator|+
name|fldoff
argument_list|(
name|aac_common
argument_list|,
name|ac_sync_fib
argument_list|)
expr_stmt|;
comment|/*      * Copy in data.      */
if|if
condition|(
name|data
operator|!=
name|NULL
condition|)
block|{
name|bcopy
argument_list|(
name|data
argument_list|,
name|fib
operator|->
name|data
argument_list|,
name|datasize
argument_list|)
expr_stmt|;
name|fib
operator|->
name|Header
operator|.
name|XferState
operator||=
name|AAC_FIBSTATE_FROMHOST
operator||
name|AAC_FIBSTATE_NORM
expr_stmt|;
block|}
comment|/*      * Give the FIB to the controller, wait for a response.      */
if|if
condition|(
name|aac_sync_command
argument_list|(
name|sc
argument_list|,
name|AAC_MONKER_SYNCFIB
argument_list|,
name|fib
operator|->
name|Header
operator|.
name|ReceiverFibAddress
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|debug
argument_list|(
literal|2
argument_list|,
literal|"IO error"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/*       * Copy out the result      */
if|if
condition|(
name|result
operator|!=
name|NULL
condition|)
block|{
operator|*
name|resultsize
operator|=
name|fib
operator|->
name|Header
operator|.
name|Size
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib_header
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|fib
operator|->
name|data
argument_list|,
name|result
argument_list|,
operator|*
name|resultsize
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Adapter-space FIB queue manipulation  *  * Note that the queue implementation here is a little funky; neither the PI or  * CI will ever be zero.  This behaviour is a controller feature.  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|int
name|size
decl_stmt|;
name|int
name|notify
decl_stmt|;
block|}
name|aac_qinfo
index|[]
init|=
block|{
block|{
name|AAC_HOST_NORM_CMD_ENTRIES
block|,
name|AAC_DB_COMMAND_NOT_FULL
block|}
block|,
block|{
name|AAC_HOST_HIGH_CMD_ENTRIES
block|,
literal|0
block|}
block|,
block|{
name|AAC_ADAP_NORM_CMD_ENTRIES
block|,
name|AAC_DB_COMMAND_READY
block|}
block|,
block|{
name|AAC_ADAP_HIGH_CMD_ENTRIES
block|,
literal|0
block|}
block|,
block|{
name|AAC_HOST_NORM_RESP_ENTRIES
block|,
name|AAC_DB_RESPONSE_NOT_FULL
block|}
block|,
block|{
name|AAC_HOST_HIGH_RESP_ENTRIES
block|,
literal|0
block|}
block|,
block|{
name|AAC_ADAP_NORM_RESP_ENTRIES
block|,
name|AAC_DB_RESPONSE_READY
block|}
block|,
block|{
name|AAC_ADAP_HIGH_RESP_ENTRIES
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_comment
comment|/*  * Atomically insert an entry into the nominated queue, returns 0 on success or EBUSY  * if the queue is full.  *  * Note: it would be more efficient to defer notifying the controller in  *       the case where we may be inserting several entries in rapid succession, but  *       implementing this usefully may be difficult (it would involve a separate  *       queue/notify interface).  */
end_comment

begin_function
specifier|static
name|int
name|aac_enqueue_fib
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|queue
parameter_list|,
name|u_int32_t
name|fib_size
parameter_list|,
name|u_int32_t
name|fib_addr
parameter_list|)
block|{
name|u_int32_t
name|pi
decl_stmt|,
name|ci
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
decl_stmt|;
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* get the producer/consumer indices */
name|pi
operator|=
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|queue
index|]
index|[
name|AAC_PRODUCER_INDEX
index|]
expr_stmt|;
name|ci
operator|=
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|queue
index|]
index|[
name|AAC_CONSUMER_INDEX
index|]
expr_stmt|;
comment|/* wrap the queue? */
if|if
condition|(
name|pi
operator|>=
name|aac_qinfo
index|[
name|queue
index|]
operator|.
name|size
condition|)
name|pi
operator|=
literal|0
expr_stmt|;
comment|/* check for queue full */
if|if
condition|(
operator|(
name|pi
operator|+
literal|1
operator|)
operator|==
name|ci
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* populate queue entry */
operator|(
name|sc
operator|->
name|aac_qentries
index|[
name|queue
index|]
operator|+
name|pi
operator|)
operator|->
name|aq_fib_size
operator|=
name|fib_size
expr_stmt|;
operator|(
name|sc
operator|->
name|aac_qentries
index|[
name|queue
index|]
operator|+
name|pi
operator|)
operator|->
name|aq_fib_addr
operator|=
name|fib_addr
expr_stmt|;
comment|/* update producer index */
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|queue
index|]
index|[
name|AAC_PRODUCER_INDEX
index|]
operator|=
name|pi
operator|+
literal|1
expr_stmt|;
comment|/* notify the adapter if we know how */
if|if
condition|(
name|aac_qinfo
index|[
name|queue
index|]
operator|.
name|notify
operator|!=
literal|0
condition|)
name|AAC_QNOTIFY
argument_list|(
name|sc
argument_list|,
name|aac_qinfo
index|[
name|queue
index|]
operator|.
name|notify
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Atomically remove one entry from the nominated queue, returns 0 on success or ENOENT  * if the queue is empty.  */
end_comment

begin_function
specifier|static
name|int
name|aac_dequeue_fib
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|queue
parameter_list|,
name|u_int32_t
modifier|*
name|fib_size
parameter_list|,
name|struct
name|aac_fib
modifier|*
modifier|*
name|fib_addr
parameter_list|)
block|{
name|u_int32_t
name|pi
decl_stmt|,
name|ci
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
decl_stmt|;
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* get the producer/consumer indices */
name|pi
operator|=
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|queue
index|]
index|[
name|AAC_PRODUCER_INDEX
index|]
expr_stmt|;
name|ci
operator|=
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|queue
index|]
index|[
name|AAC_CONSUMER_INDEX
index|]
expr_stmt|;
comment|/* check for queue empty */
if|if
condition|(
name|ci
operator|==
name|pi
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* wrap the queue? */
if|if
condition|(
name|ci
operator|>=
name|aac_qinfo
index|[
name|queue
index|]
operator|.
name|size
condition|)
name|ci
operator|=
literal|0
expr_stmt|;
comment|/* fetch the entry */
operator|*
name|fib_size
operator|=
operator|(
name|sc
operator|->
name|aac_qentries
index|[
name|queue
index|]
operator|+
name|ci
operator|)
operator|->
name|aq_fib_size
expr_stmt|;
operator|*
name|fib_addr
operator|=
operator|(
expr|struct
name|aac_fib
operator|*
operator|)
operator|(
name|sc
operator|->
name|aac_qentries
index|[
name|queue
index|]
operator|+
name|ci
operator|)
operator|->
name|aq_fib_addr
expr_stmt|;
comment|/* update consumer index */
name|sc
operator|->
name|aac_queues
operator|->
name|qt_qindex
index|[
name|queue
index|]
index|[
name|AAC_CONSUMER_INDEX
index|]
operator|=
name|ci
operator|+
literal|1
expr_stmt|;
comment|/* if we have made the queue un-full, notify the adapter */
if|if
condition|(
operator|(
operator|(
name|pi
operator|+
literal|1
operator|)
operator|==
name|ci
operator|)
operator|&&
operator|(
name|aac_qinfo
index|[
name|queue
index|]
operator|.
name|notify
operator|!=
literal|0
operator|)
condition|)
name|AAC_QNOTIFY
argument_list|(
name|sc
argument_list|,
name|aac_qinfo
index|[
name|queue
index|]
operator|.
name|notify
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Check for commands that have been outstanding for a suspiciously long time,  * and complain about them.  */
end_comment

begin_function
specifier|static
name|void
name|aac_timeout
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|struct
name|aac_command
modifier|*
name|cm
decl_stmt|;
name|time_t
name|deadline
decl_stmt|;
comment|/* simulate an interrupt to handle possibly-missed interrupts */
name|aac_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* kick the I/O queue to restart it in the case of deadlock */
name|aac_startio
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* traverse the busy command list, bitch about late commands once only */
name|deadline
operator|=
name|time_second
operator|-
name|AAC_CMD_TIMEOUT
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|cm
argument_list|,
argument|&sc->aac_busy
argument_list|,
argument|cm_link
argument_list|)
block|{
if|if
condition|(
operator|(
name|cm
operator|->
name|cm_timestamp
operator|<
name|deadline
operator|)
operator|&&
operator|!
operator|(
name|cm
operator|->
name|cm_flags
operator|&
name|AAC_CMD_TIMEDOUT
operator|)
condition|)
block|{
name|cm
operator|->
name|cm_flags
operator||=
name|AAC_CMD_TIMEDOUT
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"COMMAND TIMED OUT AFTER %d SECONDS\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|time_second
operator|-
name|cm
operator|->
name|cm_timestamp
argument_list|)
argument_list|)
expr_stmt|;
name|AAC_PRINT_FIB
argument_list|(
name|sc
argument_list|,
name|cm
operator|->
name|cm_fib
argument_list|)
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* reset the timer for next time */
name|timeout
argument_list|(
operator|(
name|timeout_t
operator|*
operator|)
name|aac_timeout
argument_list|,
name|sc
argument_list|,
name|AAC_PERIODIC_INTERVAL
operator|*
name|hz
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/********************************************************************************  ********************************************************************************                                                        Interface Function Vectors  ********************************************************************************  ********************************************************************************/
end_comment

begin_comment
comment|/********************************************************************************  * Read the current firmware status word.  */
end_comment

begin_function
specifier|static
name|int
name|aac_sa_get_fwstatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
return|return
operator|(
name|AAC_GETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SA_FWSTATUS
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aac_rx_get_fwstatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
return|return
operator|(
name|AAC_GETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RX_FWSTATUS
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Notify the controller of a change in a given queue  */
end_comment

begin_function
specifier|static
name|void
name|aac_sa_qnotify
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|qbit
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|AAC_SETREG2
argument_list|(
name|sc
argument_list|,
name|AAC_SA_DOORBELL1_SET
argument_list|,
name|qbit
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|aac_rx_qnotify
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|qbit
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RX_IDBR
argument_list|,
name|qbit
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Get the interrupt reason bits  */
end_comment

begin_function
specifier|static
name|int
name|aac_sa_get_istatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
return|return
operator|(
name|AAC_GETREG2
argument_list|(
name|sc
argument_list|,
name|AAC_SA_DOORBELL0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aac_rx_get_istatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
return|return
operator|(
name|AAC_GETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RX_ODBR
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Clear some interrupt reason bits  */
end_comment

begin_function
specifier|static
name|void
name|aac_sa_clear_istatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|mask
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|AAC_SETREG2
argument_list|(
name|sc
argument_list|,
name|AAC_SA_DOORBELL0_CLEAR
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|aac_rx_clear_istatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|mask
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RX_ODBR
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Populate the mailbox and set the command word  */
end_comment

begin_function
specifier|static
name|void
name|aac_sa_set_mailbox
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|command
parameter_list|,
name|u_int32_t
name|arg0
parameter_list|,
name|u_int32_t
name|arg1
parameter_list|,
name|u_int32_t
name|arg2
parameter_list|,
name|u_int32_t
name|arg3
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SA_MAILBOX
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SA_MAILBOX
operator|+
literal|4
argument_list|,
name|arg0
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SA_MAILBOX
operator|+
literal|8
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SA_MAILBOX
operator|+
literal|12
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SA_MAILBOX
operator|+
literal|16
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|aac_rx_set_mailbox
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|command
parameter_list|,
name|u_int32_t
name|arg0
parameter_list|,
name|u_int32_t
name|arg1
parameter_list|,
name|u_int32_t
name|arg2
parameter_list|,
name|u_int32_t
name|arg3
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RX_MAILBOX
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RX_MAILBOX
operator|+
literal|4
argument_list|,
name|arg0
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RX_MAILBOX
operator|+
literal|8
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RX_MAILBOX
operator|+
literal|12
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RX_MAILBOX
operator|+
literal|16
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Fetch the immediate command status word  */
end_comment

begin_function
specifier|static
name|int
name|aac_sa_get_mailboxstatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|4
argument_list|)
expr_stmt|;
return|return
operator|(
name|AAC_GETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_SA_MAILBOX
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aac_rx_get_mailboxstatus
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|4
argument_list|)
expr_stmt|;
return|return
operator|(
name|AAC_GETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RX_MAILBOX
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Set/clear interrupt masks  */
end_comment

begin_function
specifier|static
name|void
name|aac_sa_set_interrupts
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
name|debug
argument_list|(
literal|2
argument_list|,
literal|"%sable interrupts"
argument_list|,
name|enable
condition|?
literal|"en"
else|:
literal|"dis"
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
block|{
name|AAC_SETREG2
argument_list|(
operator|(
name|sc
operator|)
argument_list|,
name|AAC_SA_MASK0_CLEAR
argument_list|,
name|AAC_DB_INTERRUPTS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AAC_SETREG2
argument_list|(
operator|(
name|sc
operator|)
argument_list|,
name|AAC_SA_MASK0_SET
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|aac_rx_set_interrupts
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
name|debug
argument_list|(
literal|2
argument_list|,
literal|"%sable interrupts"
argument_list|,
name|enable
condition|?
literal|"en"
else|:
literal|"dis"
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
block|{
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RX_OIMR
argument_list|,
operator|~
name|AAC_DB_INTERRUPTS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AAC_SETREG4
argument_list|(
name|sc
argument_list|,
name|AAC_RX_OIMR
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/********************************************************************************  ********************************************************************************                                                         Debugging and Diagnostics  ********************************************************************************  ********************************************************************************/
end_comment

begin_comment
comment|/********************************************************************************  * Print some information about the controller.  */
end_comment

begin_function
specifier|static
name|void
name|aac_describe_controller
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int8_t
name|buf
index|[
name|AAC_FIB_DATASIZE
index|]
decl_stmt|;
comment|/* XXX really a bit big for the stack */
name|u_int16_t
name|bufsize
decl_stmt|;
name|struct
name|aac_adapter_info
modifier|*
name|info
decl_stmt|;
name|u_int8_t
name|arg
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|arg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|aac_sync_fib
argument_list|(
name|sc
argument_list|,
name|RequestAdapterInfo
argument_list|,
literal|0
argument_list|,
operator|&
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|arg
argument_list|)
argument_list|,
operator|&
name|buf
argument_list|,
operator|&
name|bufsize
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"RequestAdapterInfo failed\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bufsize
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|info
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"RequestAdapterInfo returned wrong data size (%d != %d)\n"
argument_list|,
name|bufsize
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|info
argument_list|)
argument_list|)
expr_stmt|;
comment|/*return;*/
block|}
name|info
operator|=
operator|(
expr|struct
name|aac_adapter_info
operator|*
operator|)
operator|&
name|buf
index|[
literal|0
index|]
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"%s %dMHz, %dMB total memory, %s (%d)\n"
argument_list|,
name|aac_describe_code
argument_list|(
name|aac_cpu_variant
argument_list|,
name|info
operator|->
name|CpuVariant
argument_list|)
argument_list|,
name|info
operator|->
name|ClockSpeed
argument_list|,
name|info
operator|->
name|TotalMem
operator|/
operator|(
literal|1024
operator|*
literal|1024
operator|)
argument_list|,
name|aac_describe_code
argument_list|(
name|aac_battery_platform
argument_list|,
name|info
operator|->
name|batteryPlatform
argument_list|)
argument_list|,
name|info
operator|->
name|batteryPlatform
argument_list|)
expr_stmt|;
comment|/* save the kernel revision structure for later use */
name|sc
operator|->
name|aac_revision
operator|=
name|info
operator|->
name|KernelRevision
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"Kernel %d.%d-%d, S/N %llx\n"
argument_list|,
name|info
operator|->
name|KernelRevision
operator|.
name|external
operator|.
name|comp
operator|.
name|major
argument_list|,
name|info
operator|->
name|KernelRevision
operator|.
name|external
operator|.
name|comp
operator|.
name|minor
argument_list|,
name|info
operator|->
name|KernelRevision
operator|.
name|external
operator|.
name|comp
operator|.
name|dash
argument_list|,
name|info
operator|->
name|SerialNumber
argument_list|)
expr_stmt|;
comment|/* XXX how is this meant to be formatted? */
block|}
end_function

begin_comment
comment|/********************************************************************************  * Look up a text description of a numeric error code and return a pointer to  * same.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|aac_describe_code
parameter_list|(
name|struct
name|aac_code_lookup
modifier|*
name|table
parameter_list|,
name|u_int32_t
name|code
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|table
index|[
name|i
index|]
operator|.
name|string
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|table
index|[
name|i
index|]
operator|.
name|code
operator|==
name|code
condition|)
return|return
operator|(
name|table
index|[
name|i
index|]
operator|.
name|string
operator|)
return|;
return|return
operator|(
name|table
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|string
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  *****************************************************************************                                                     Management Interface  *****************************************************************************  *****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|aac_open
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
init|=
name|dev
operator|->
name|si_drv1
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* Check to make sure the device isn't already open */
if|if
condition|(
name|sc
operator|->
name|aac_state
operator|&
name|AAC_STATE_OPEN
condition|)
block|{
return|return
name|EBUSY
return|;
block|}
name|sc
operator|->
name|aac_state
operator||=
name|AAC_STATE_OPEN
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aac_close
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|aac_softc
modifier|*
name|sc
init|=
name|dev
operator|->
name|si_drv1
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* Mark this unit as no longer open  */
name|sc
operator|->
name|aac_state
operator|&=
operator|~
name|AAC_STATE_OPEN
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aac_ioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|union
name|aac_statrequest
modifier|*
name|as
init|=
operator|(
expr|union
name|aac_statrequest
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|aac_softc
modifier|*
name|sc
init|=
name|dev
operator|->
name|si_drv1
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|AAC_COMPAT_LINUX
name|int
name|i
decl_stmt|;
endif|#
directive|endif
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|AACIO_STATS
case|:
switch|switch
condition|(
name|as
operator|->
name|as_item
condition|)
block|{
case|case
name|AACQ_FREE
case|:
case|case
name|AACQ_BIO
case|:
case|case
name|AACQ_READY
case|:
case|case
name|AACQ_BUSY
case|:
case|case
name|AACQ_COMPLETE
case|:
name|bcopy
argument_list|(
operator|&
name|sc
operator|->
name|aac_qstat
index|[
name|as
operator|->
name|as_item
index|]
argument_list|,
operator|&
name|as
operator|->
name|as_qstat
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_qstat
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
break|break;
ifdef|#
directive|ifdef
name|AAC_COMPAT_LINUX
case|case
name|FSACTL_SENDFIB
case|:
name|debug
argument_list|(
literal|1
argument_list|,
literal|"FSACTL_SENDFIB"
argument_list|)
expr_stmt|;
name|error
operator|=
name|aac_ioctl_sendfib
argument_list|(
name|sc
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|FSACTL_AIF_THREAD
case|:
name|debug
argument_list|(
literal|1
argument_list|,
literal|"FSACTL_AIF_THREAD"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|FSACTL_OPEN_GET_ADAPTER_FIB
case|:
name|debug
argument_list|(
literal|1
argument_list|,
literal|"FSACTL_OPEN_GET_ADAPTER_FIB"
argument_list|)
expr_stmt|;
comment|/* 	 * Pass the caller out an AdapterFibContext. 	 * 	 * Note that because we only support one opener, we 	 * basically ignore this.  Set the caller's context to a magic 	 * number just in case. 	 * 	 * The Linux code hands the driver a pointer into kernel space, 	 * and then trusts it when the caller hands it back.  Aiee! 	 */
name|i
operator|=
name|AAC_AIF_SILLYMAGIC
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|i
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FSACTL_GET_NEXT_ADAPTER_FIB
case|:
name|debug
argument_list|(
literal|1
argument_list|,
literal|"FSACTL_GET_NEXT_ADAPTER_FIB"
argument_list|)
expr_stmt|;
name|error
operator|=
name|aac_linux_getnext_aif
argument_list|(
name|sc
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|FSACTL_CLOSE_GET_ADAPTER_FIB
case|:
name|debug
argument_list|(
literal|1
argument_list|,
literal|"FSACTL_CLOSE_GET_ADAPTER_FIB"
argument_list|)
expr_stmt|;
comment|/* don't do anything here */
break|break;
case|case
name|FSACTL_MINIPORT_REV_CHECK
case|:
name|debug
argument_list|(
literal|1
argument_list|,
literal|"FSACTL_MINIPORT_REV_CHECK"
argument_list|)
expr_stmt|;
name|error
operator|=
name|aac_linux_rev_check
argument_list|(
name|sc
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"unsupported cmd 0x%lx\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Send a FIB supplied from userspace  */
end_comment

begin_function
specifier|static
name|int
name|aac_ioctl_sendfib
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|caddr_t
name|ufib
parameter_list|)
block|{
name|struct
name|aac_command
modifier|*
name|cm
decl_stmt|;
name|int
name|size
decl_stmt|,
name|error
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|cm
operator|=
name|NULL
expr_stmt|;
comment|/*      * Get a command      */
if|if
condition|(
name|aac_alloc_command
argument_list|(
name|sc
argument_list|,
operator|&
name|cm
argument_list|)
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/*      * Fetch the FIB header, then re-copy to get data as well.      */
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|ufib
argument_list|,
name|cm
operator|->
name|cm_fib
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib_header
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|size
operator|=
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|Size
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"incoming FIB oversized (%d> %d)\n"
argument_list|,
name|size
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|ufib
argument_list|,
name|cm
operator|->
name|cm_fib
argument_list|,
name|size
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|Size
operator|=
name|size
expr_stmt|;
comment|/*      * Pass the FIB to the controller, wait for it to complete.      */
if|if
condition|(
operator|(
name|error
operator|=
name|aac_wait_command
argument_list|(
name|cm
argument_list|,
literal|30
argument_list|)
operator|)
operator|!=
literal|0
condition|)
comment|/* XXX user timeout? */
goto|goto
name|out
goto|;
comment|/*      * Copy the FIB and data back out to the caller.      */
name|size
operator|=
name|cm
operator|->
name|cm_fib
operator|->
name|Header
operator|.
name|Size
expr_stmt|;
if|if
condition|(
name|size
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|aac_dev
argument_list|,
literal|"outbound FIB oversized (%d> %d)\n"
argument_list|,
name|size
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|aac_fib
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|copyout
argument_list|(
name|cm
operator|->
name|cm_fib
argument_list|,
name|ufib
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|cm
operator|!=
name|NULL
condition|)
name|aac_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Handle an AIF sent to us by the controller; queue it for later reference.  *  * XXX what's the right thing to do here when the queue is full?  Drop the older  * or newer entries?  */
end_comment

begin_function
specifier|static
name|void
name|aac_handle_aif
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|aac_aif_command
modifier|*
name|aif
parameter_list|)
block|{
name|int
name|next
decl_stmt|,
name|s
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|next
operator|=
operator|(
name|sc
operator|->
name|aac_aifq_head
operator|+
literal|1
operator|)
operator|%
name|AAC_AIFQ_LENGTH
expr_stmt|;
if|if
condition|(
name|next
operator|!=
name|sc
operator|->
name|aac_aifq_tail
condition|)
block|{
name|bcopy
argument_list|(
name|aif
argument_list|,
operator|&
name|sc
operator|->
name|aac_aifq
index|[
name|next
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_aif_command
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|aac_aifq_head
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|aac_state
operator|&
name|AAC_STATE_AIF_SLEEPER
condition|)
name|wakeup
argument_list|(
name|sc
operator|->
name|aac_aifq
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|aac_print_aif
argument_list|(
name|sc
argument_list|,
name|aif
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/********************************************************************************  ********************************************************************************                                                        Linux Management Interface  ********************************************************************************  ********************************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AAC_COMPAT_LINUX
end_ifdef

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<machine/../linux/linux.h>
end_include

begin_include
include|#
directive|include
file|<machine/../linux/linux_proto.h>
end_include

begin_include
include|#
directive|include
file|<compat/linux/linux_ioctl.h>
end_include

begin_define
define|#
directive|define
name|AAC_LINUX_IOCTL_MIN
value|0x2000
end_define

begin_define
define|#
directive|define
name|AAC_LINUX_IOCTL_MAX
value|0x21ff
end_define

begin_decl_stmt
specifier|static
name|linux_ioctl_function_t
name|aac_linux_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|linux_ioctl_handler
name|aac_handler
init|=
block|{
name|aac_linux_ioctl
block|,
name|AAC_LINUX_IOCTL_MIN
block|,
name|AAC_LINUX_IOCTL_MAX
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSINIT
argument_list|(
name|aac_register
argument_list|,
name|SI_SUB_KLD
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|,
name|linux_ioctl_register_handler
argument_list|,
operator|&
name|aac_handler
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSUNINIT
argument_list|(
name|aac_unregister
argument_list|,
name|SI_SUB_KLD
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|,
name|linux_ioctl_unregister_handler
argument_list|,
operator|&
name|aac_handler
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|aac
argument_list|,
name|linux
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|aac_linux_ioctl
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|linux_ioctl_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|file
modifier|*
name|fp
init|=
name|p
operator|->
name|p_fd
operator|->
name|fd_ofiles
index|[
name|args
operator|->
name|fd
index|]
decl_stmt|;
name|u_long
name|cmd
init|=
name|args
operator|->
name|cmd
decl_stmt|;
comment|/*      * Pass the ioctl off to our standard handler.      */
return|return
operator|(
name|fo_ioctl
argument_list|(
name|fp
argument_list|,
name|cmd
argument_list|,
operator|(
name|caddr_t
operator|)
name|args
operator|->
name|arg
argument_list|,
name|p
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Return the Revision of the driver to userspace and check to see if the  * userspace app is possibly compatible.  This is extremely bogus right now  * because I have no idea how to handle the versioning of this driver.  It is  * needed, though, to get aaccli working.  */
end_comment

begin_function
specifier|static
name|int
name|aac_linux_rev_check
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|caddr_t
name|udata
parameter_list|)
block|{
name|struct
name|aac_rev_check
name|rev_check
decl_stmt|;
name|struct
name|aac_rev_check_resp
name|rev_check_resp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/*      * Copyin the revision struct from userspace      */
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|udata
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|rev_check
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_rev_check
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
name|error
return|;
block|}
name|debug
argument_list|(
literal|2
argument_list|,
literal|"Userland revision= %d\n"
argument_list|,
name|rev_check
operator|.
name|callingRevision
operator|.
name|buildNumber
argument_list|)
expr_stmt|;
comment|/*      * Doctor up the response struct.      */
name|rev_check_resp
operator|.
name|possiblyCompatible
operator|=
literal|1
expr_stmt|;
name|rev_check_resp
operator|.
name|adapterSWRevision
operator|.
name|external
operator|.
name|ul
operator|=
name|sc
operator|->
name|aac_revision
operator|.
name|external
operator|.
name|ul
expr_stmt|;
name|rev_check_resp
operator|.
name|adapterSWRevision
operator|.
name|buildNumber
operator|=
name|sc
operator|->
name|aac_revision
operator|.
name|buildNumber
expr_stmt|;
return|return
operator|(
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|rev_check_resp
argument_list|,
name|udata
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_rev_check_resp
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Pass the caller the next AIF in their queue  */
end_comment

begin_function
specifier|static
name|int
name|aac_linux_getnext_aif
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|caddr_t
name|arg
parameter_list|)
block|{
name|struct
name|get_adapter_fib_ioctl
name|agf
decl_stmt|;
name|int
name|error
decl_stmt|,
name|s
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|agf
argument_list|,
sizeof|sizeof
argument_list|(
name|agf
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 	 * Check the magic number that we gave the caller. 	 */
if|if
condition|(
name|agf
operator|.
name|AdapterFibContext
operator|!=
name|AAC_AIF_SILLYMAGIC
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|error
operator|=
name|aac_linux_return_aif
argument_list|(
name|sc
argument_list|,
name|agf
operator|.
name|AifFib
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|==
name|EAGAIN
operator|)
operator|&&
operator|(
name|agf
operator|.
name|Wait
operator|)
condition|)
block|{
name|sc
operator|->
name|aac_state
operator||=
name|AAC_STATE_AIF_SLEEPER
expr_stmt|;
while|while
condition|(
name|error
operator|==
name|EAGAIN
condition|)
block|{
name|error
operator|=
name|tsleep
argument_list|(
name|sc
operator|->
name|aac_aifq
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"aacaif"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|aac_linux_return_aif
argument_list|(
name|sc
argument_list|,
name|agf
operator|.
name|AifFib
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|aac_state
operator|&=
operator|~
name|AAC_STATE_AIF_SLEEPER
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Hand the next AIF off the top of the queue out to userspace.  */
end_comment

begin_function
specifier|static
name|int
name|aac_linux_return_aif
parameter_list|(
name|struct
name|aac_softc
modifier|*
name|sc
parameter_list|,
name|caddr_t
name|uptr
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|s
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|aac_aifq_tail
operator|==
name|sc
operator|->
name|aac_aifq_head
condition|)
block|{
name|error
operator|=
name|EAGAIN
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|sc
operator|->
name|aac_aifq
index|[
name|sc
operator|->
name|aac_aifq_tail
index|]
argument_list|,
name|uptr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aac_aif_command
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|sc
operator|->
name|aac_aifq_tail
operator|=
operator|(
name|sc
operator|->
name|aac_aifq_tail
operator|+
literal|1
operator|)
operator|%
name|AAC_AIFQ_LENGTH
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AAC_COMPAT_LINUX */
end_comment

end_unit

