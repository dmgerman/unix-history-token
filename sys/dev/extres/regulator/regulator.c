begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright 2016 Michal Meloun<mmel@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_platform.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/kobj.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|FDT
end_ifdef

begin_include
include|#
directive|include
file|<dev/fdt/fdt_common.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus_subr.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/extres/regulator/regulator.h>
end_include

begin_include
include|#
directive|include
file|"regdev_if.h"
end_include

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_REGULATOR
argument_list|,
literal|"regulator"
argument_list|,
literal|"Regulator framework"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Forward declarations. */
end_comment

begin_struct_decl
struct_decl|struct
name|regulator
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|regnode
struct_decl|;
end_struct_decl

begin_typedef
typedef|typedef
name|TAILQ_HEAD
argument_list|(
argument|regnode_list
argument_list|,
argument|regnode
argument_list|)
name|regnode_list_t
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|TAILQ_HEAD
argument_list|(
argument|regulator_list
argument_list|,
argument|regulator
argument_list|)
name|regulator_list_t
expr_stmt|;
end_typedef

begin_comment
comment|/* Default regulator methods. */
end_comment

begin_function_decl
specifier|static
name|int
name|regnode_method_enable
parameter_list|(
name|struct
name|regnode
modifier|*
name|regnode
parameter_list|,
name|bool
name|enable
parameter_list|,
name|int
modifier|*
name|udelay
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|regnode_method_status
parameter_list|(
name|struct
name|regnode
modifier|*
name|regnode
parameter_list|,
name|int
modifier|*
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|regnode_method_set_voltage
parameter_list|(
name|struct
name|regnode
modifier|*
name|regnode
parameter_list|,
name|int
name|min_uvolt
parameter_list|,
name|int
name|max_uvolt
parameter_list|,
name|int
modifier|*
name|udelay
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|regnode_method_get_voltage
parameter_list|(
name|struct
name|regnode
modifier|*
name|regnode
parameter_list|,
name|int
modifier|*
name|uvolt
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Regulator controller methods.  */
end_comment

begin_decl_stmt
specifier|static
name|regnode_method_t
name|regnode_methods
index|[]
init|=
block|{
name|REGNODEMETHOD
argument_list|(
name|regnode_enable
argument_list|,
name|regnode_method_enable
argument_list|)
block|,
name|REGNODEMETHOD
argument_list|(
name|regnode_status
argument_list|,
name|regnode_method_status
argument_list|)
block|,
name|REGNODEMETHOD
argument_list|(
name|regnode_set_voltage
argument_list|,
name|regnode_method_set_voltage
argument_list|)
block|,
name|REGNODEMETHOD
argument_list|(
name|regnode_get_voltage
argument_list|,
name|regnode_method_get_voltage
argument_list|)
block|,
name|REGNODEMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DEFINE_CLASS_0
argument_list|(
name|regnode
argument_list|,
name|regnode_class
argument_list|,
name|regnode_methods
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Regulator node - basic element for modelling SOC and bard power supply  * chains. Its contains producer data.  */
end_comment

begin_struct
struct|struct
name|regnode
block|{
name|KOBJ_FIELDS
expr_stmt|;
name|TAILQ_ENTRY
argument_list|(
argument|regnode
argument_list|)
name|reglist_link
expr_stmt|;
comment|/* Global list entry */
name|regulator_list_t
name|consumers_list
decl_stmt|;
comment|/* Consumers list */
comment|/* Cache for already resolved names */
name|struct
name|regnode
modifier|*
name|parent
decl_stmt|;
comment|/* Resolved parent */
comment|/* Details of this device. */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Globally unique name */
specifier|const
name|char
modifier|*
name|parent_name
decl_stmt|;
comment|/* Parent name */
name|device_t
name|pdev
decl_stmt|;
comment|/* Producer device_t */
name|void
modifier|*
name|softc
decl_stmt|;
comment|/* Producer softc */
name|intptr_t
name|id
decl_stmt|;
comment|/* Per producer unique id */
ifdef|#
directive|ifdef
name|FDT
name|phandle_t
name|ofw_node
decl_stmt|;
comment|/* OFW node of regulator */
endif|#
directive|endif
name|int
name|flags
decl_stmt|;
comment|/* REGULATOR_FLAGS_ */
name|struct
name|sx
name|lock
decl_stmt|;
comment|/* Lock for this regulator */
name|int
name|ref_cnt
decl_stmt|;
comment|/* Reference counter */
name|int
name|enable_cnt
decl_stmt|;
comment|/* Enabled counter */
name|struct
name|regnode_std_param
name|std_param
decl_stmt|;
comment|/* Standard parameters */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Per consumer data, information about how a consumer is using a regulator  * node.  * A pointer to this structure is used as a handle in the consumer interface.  */
end_comment

begin_struct
struct|struct
name|regulator
block|{
name|device_t
name|cdev
decl_stmt|;
comment|/* Consumer device */
name|struct
name|regnode
modifier|*
name|regnode
decl_stmt|;
name|TAILQ_ENTRY
argument_list|(
argument|regulator
argument_list|)
name|link
expr_stmt|;
comment|/* Consumers list entry */
name|int
name|enable_cnt
decl_stmt|;
name|int
name|min_uvolt
decl_stmt|;
comment|/* Requested uvolt range */
name|int
name|max_uvolt
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Regulator names must be system wide unique.  */
end_comment

begin_decl_stmt
specifier|static
name|regnode_list_t
name|regnode_list
init|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|regnode_list
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sx
name|regnode_topo_lock
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SX_SYSINIT
argument_list|(
name|regulator_topology
argument_list|,
operator|&
name|regnode_topo_lock
argument_list|,
literal|"Regulator topology lock"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|REG_TOPO_SLOCK
parameter_list|()
value|sx_slock(&regnode_topo_lock)
end_define

begin_define
define|#
directive|define
name|REG_TOPO_XLOCK
parameter_list|()
value|sx_xlock(&regnode_topo_lock)
end_define

begin_define
define|#
directive|define
name|REG_TOPO_UNLOCK
parameter_list|()
value|sx_unlock(&regnode_topo_lock)
end_define

begin_define
define|#
directive|define
name|REG_TOPO_ASSERT
parameter_list|()
value|sx_assert(&regnode_topo_lock, SA_LOCKED)
end_define

begin_define
define|#
directive|define
name|REG_TOPO_XASSERT
parameter_list|()
value|sx_assert(&regnode_topo_lock, SA_XLOCKED)
end_define

begin_define
define|#
directive|define
name|REGNODE_SLOCK
parameter_list|(
name|_sc
parameter_list|)
value|sx_slock(&((_sc)->lock))
end_define

begin_define
define|#
directive|define
name|REGNODE_XLOCK
parameter_list|(
name|_sc
parameter_list|)
value|sx_xlock(&((_sc)->lock))
end_define

begin_define
define|#
directive|define
name|REGNODE_UNLOCK
parameter_list|(
name|_sc
parameter_list|)
value|sx_unlock(&((_sc)->lock))
end_define

begin_comment
comment|/* ----------------------------------------------------------------------------  *  * Default regulator methods for base class.  *  */
end_comment

begin_function
specifier|static
name|int
name|regnode_method_enable
parameter_list|(
name|struct
name|regnode
modifier|*
name|regnode
parameter_list|,
name|bool
name|enable
parameter_list|,
name|int
modifier|*
name|udelay
parameter_list|)
block|{
if|if
condition|(
operator|!
name|enable
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
operator|*
name|udelay
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|regnode_method_status
parameter_list|(
name|struct
name|regnode
modifier|*
name|regnode
parameter_list|,
name|int
modifier|*
name|status
parameter_list|)
block|{
operator|*
name|status
operator|=
name|REGULATOR_STATUS_ENABLED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|regnode_method_set_voltage
parameter_list|(
name|struct
name|regnode
modifier|*
name|regnode
parameter_list|,
name|int
name|min_uvolt
parameter_list|,
name|int
name|max_uvolt
parameter_list|,
name|int
modifier|*
name|udelay
parameter_list|)
block|{
if|if
condition|(
operator|(
name|min_uvolt
operator|>
name|regnode
operator|->
name|std_param
operator|.
name|max_uvolt
operator|)
operator|||
operator|(
name|max_uvolt
operator|<
name|regnode
operator|->
name|std_param
operator|.
name|min_uvolt
operator|)
condition|)
return|return
operator|(
name|ERANGE
operator|)
return|;
operator|*
name|udelay
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|regnode_method_get_voltage
parameter_list|(
name|struct
name|regnode
modifier|*
name|regnode
parameter_list|,
name|int
modifier|*
name|uvolt
parameter_list|)
block|{
return|return
operator|(
name|regnode
operator|->
name|std_param
operator|.
name|min_uvolt
operator|+
operator|(
name|regnode
operator|->
name|std_param
operator|.
name|max_uvolt
operator|-
name|regnode
operator|->
name|std_param
operator|.
name|min_uvolt
operator|)
operator|/
literal|2
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ----------------------------------------------------------------------------  *  * Internal functions.  *  */
end_comment

begin_function
specifier|static
name|struct
name|regnode
modifier|*
name|regnode_find_by_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|regnode
modifier|*
name|entry
decl_stmt|;
name|REG_TOPO_ASSERT
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|entry
argument_list|,
argument|&regnode_list
argument_list|,
argument|reglist_link
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|entry
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|entry
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|regnode
modifier|*
name|regnode_find_by_id
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|intptr_t
name|id
parameter_list|)
block|{
name|struct
name|regnode
modifier|*
name|entry
decl_stmt|;
name|REG_TOPO_ASSERT
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|entry
argument_list|,
argument|&regnode_list
argument_list|,
argument|reglist_link
argument_list|)
block|{
if|if
condition|(
operator|(
name|entry
operator|->
name|pdev
operator|==
name|dev
operator|)
operator|&&
operator|(
name|entry
operator|->
name|id
operator|==
name|id
operator|)
condition|)
return|return
operator|(
name|entry
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create and initialize regulator object, but do not register it.  */
end_comment

begin_function
name|struct
name|regnode
modifier|*
name|regnode_create
parameter_list|(
name|device_t
name|pdev
parameter_list|,
name|regnode_class_t
name|regnode_class
parameter_list|,
name|struct
name|regnode_init_def
modifier|*
name|def
parameter_list|)
block|{
name|struct
name|regnode
modifier|*
name|regnode
decl_stmt|;
name|KASSERT
argument_list|(
name|def
operator|->
name|name
operator|!=
name|NULL
argument_list|,
operator|(
literal|"regulator name is NULL"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|def
operator|->
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
argument_list|,
operator|(
literal|"regulator name is empty"
operator|)
argument_list|)
expr_stmt|;
name|REG_TOPO_SLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|regnode_find_by_name
argument_list|(
name|def
operator|->
name|name
argument_list|)
operator|!=
name|NULL
condition|)
name|panic
argument_list|(
literal|"Duplicated regulator registration: %s\n"
argument_list|,
name|def
operator|->
name|name
argument_list|)
expr_stmt|;
name|REG_TOPO_UNLOCK
argument_list|()
expr_stmt|;
comment|/* Create object and initialize it. */
name|regnode
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|regnode
argument_list|)
argument_list|,
name|M_REGULATOR
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|kobj_init
argument_list|(
operator|(
name|kobj_t
operator|)
name|regnode
argument_list|,
operator|(
name|kobj_class_t
operator|)
name|regnode_class
argument_list|)
expr_stmt|;
name|sx_init
argument_list|(
operator|&
name|regnode
operator|->
name|lock
argument_list|,
literal|"Regulator node lock"
argument_list|)
expr_stmt|;
comment|/* Allocate softc if required. */
if|if
condition|(
name|regnode_class
operator|->
name|size
operator|>
literal|0
condition|)
block|{
name|regnode
operator|->
name|softc
operator|=
name|malloc
argument_list|(
name|regnode_class
operator|->
name|size
argument_list|,
name|M_REGULATOR
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
block|}
comment|/* Copy all strings unless they're flagged as static. */
if|if
condition|(
name|def
operator|->
name|flags
operator|&
name|REGULATOR_FLAGS_STATIC
condition|)
block|{
name|regnode
operator|->
name|name
operator|=
name|def
operator|->
name|name
expr_stmt|;
name|regnode
operator|->
name|parent_name
operator|=
name|def
operator|->
name|parent_name
expr_stmt|;
block|}
else|else
block|{
name|regnode
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|def
operator|->
name|name
argument_list|,
name|M_REGULATOR
argument_list|)
expr_stmt|;
if|if
condition|(
name|def
operator|->
name|parent_name
operator|!=
name|NULL
condition|)
name|regnode
operator|->
name|parent_name
operator|=
name|strdup
argument_list|(
name|def
operator|->
name|parent_name
argument_list|,
name|M_REGULATOR
argument_list|)
expr_stmt|;
block|}
comment|/* Rest of init. */
name|TAILQ_INIT
argument_list|(
operator|&
name|regnode
operator|->
name|consumers_list
argument_list|)
expr_stmt|;
name|regnode
operator|->
name|id
operator|=
name|def
operator|->
name|id
expr_stmt|;
name|regnode
operator|->
name|pdev
operator|=
name|pdev
expr_stmt|;
name|regnode
operator|->
name|flags
operator|=
name|def
operator|->
name|flags
expr_stmt|;
name|regnode
operator|->
name|parent
operator|=
name|NULL
expr_stmt|;
name|regnode
operator|->
name|std_param
operator|=
name|def
operator|->
name|std_param
expr_stmt|;
ifdef|#
directive|ifdef
name|FDT
name|regnode
operator|->
name|ofw_node
operator|=
name|def
operator|->
name|ofw_node
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|regnode
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Register regulator object. */
end_comment

begin_function
name|struct
name|regnode
modifier|*
name|regnode_register
parameter_list|(
name|struct
name|regnode
modifier|*
name|regnode
parameter_list|)
block|{
name|int
name|rv
decl_stmt|;
ifdef|#
directive|ifdef
name|FDT
if|if
condition|(
name|regnode
operator|->
name|ofw_node
operator|<=
literal|0
condition|)
name|regnode
operator|->
name|ofw_node
operator|=
name|ofw_bus_get_node
argument_list|(
name|regnode
operator|->
name|pdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|regnode
operator|->
name|ofw_node
operator|<=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
endif|#
directive|endif
name|rv
operator|=
name|REGNODE_INIT
argument_list|(
name|regnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"REGNODE_INIT failed: %d\n"
argument_list|,
name|rv
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|REG_TOPO_XLOCK
argument_list|()
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|regnode_list
argument_list|,
name|regnode
argument_list|,
name|reglist_link
argument_list|)
expr_stmt|;
name|REG_TOPO_UNLOCK
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|FDT
name|OF_device_register_xref
argument_list|(
name|OF_xref_from_node
argument_list|(
name|regnode
operator|->
name|ofw_node
argument_list|)
argument_list|,
name|regnode
operator|->
name|pdev
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|regnode
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|regnode_resolve_parent
parameter_list|(
name|struct
name|regnode
modifier|*
name|regnode
parameter_list|)
block|{
comment|/* All ready resolved or no parent? */
if|if
condition|(
operator|(
name|regnode
operator|->
name|parent
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|regnode
operator|->
name|parent_name
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|regnode
operator|->
name|parent
operator|=
name|regnode_find_by_name
argument_list|(
name|regnode
operator|->
name|parent_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|regnode
operator|->
name|parent
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|regnode_delay
parameter_list|(
name|int
name|usec
parameter_list|)
block|{
name|int
name|ticks
decl_stmt|;
if|if
condition|(
name|usec
operator|==
literal|0
condition|)
return|return;
name|ticks
operator|=
operator|(
name|usec
operator|*
name|hz
operator|+
literal|999999
operator|)
operator|/
literal|1000000
expr_stmt|;
if|if
condition|(
name|cold
operator|||
name|ticks
operator|<
literal|2
condition|)
name|DELAY
argument_list|(
name|usec
argument_list|)
expr_stmt|;
else|else
name|pause
argument_list|(
literal|"REGULATOR"
argument_list|,
name|ticks
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------------  *  * Regulator providers interface  *  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|regnode_get_name
parameter_list|(
name|struct
name|regnode
modifier|*
name|regnode
parameter_list|)
block|{
return|return
operator|(
name|regnode
operator|->
name|name
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|regnode_get_parent_name
parameter_list|(
name|struct
name|regnode
modifier|*
name|regnode
parameter_list|)
block|{
return|return
operator|(
name|regnode
operator|->
name|parent_name
operator|)
return|;
block|}
end_function

begin_function
name|int
name|regnode_get_flags
parameter_list|(
name|struct
name|regnode
modifier|*
name|regnode
parameter_list|)
block|{
return|return
operator|(
name|regnode
operator|->
name|flags
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|regnode_get_softc
parameter_list|(
name|struct
name|regnode
modifier|*
name|regnode
parameter_list|)
block|{
return|return
operator|(
name|regnode
operator|->
name|softc
operator|)
return|;
block|}
end_function

begin_function
name|device_t
name|regnode_get_device
parameter_list|(
name|struct
name|regnode
modifier|*
name|regnode
parameter_list|)
block|{
return|return
operator|(
name|regnode
operator|->
name|pdev
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|regnode_std_param
modifier|*
name|regnode_get_stdparam
parameter_list|(
name|struct
name|regnode
modifier|*
name|regnode
parameter_list|)
block|{
return|return
operator|(
operator|&
name|regnode
operator|->
name|std_param
operator|)
return|;
block|}
end_function

begin_function
name|void
name|regnode_topo_unlock
parameter_list|(
name|void
parameter_list|)
block|{
name|REG_TOPO_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|regnode_topo_xlock
parameter_list|(
name|void
parameter_list|)
block|{
name|REG_TOPO_XLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|regnode_topo_slock
parameter_list|(
name|void
parameter_list|)
block|{
name|REG_TOPO_SLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------------  *  * Real consumers executive  *  */
end_comment

begin_function
name|struct
name|regnode
modifier|*
name|regnode_get_parent
parameter_list|(
name|struct
name|regnode
modifier|*
name|regnode
parameter_list|)
block|{
name|int
name|rv
decl_stmt|;
name|REG_TOPO_ASSERT
argument_list|()
expr_stmt|;
name|rv
operator|=
name|regnode_resolve_parent
argument_list|(
name|regnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|regnode
operator|->
name|parent
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Enable regulator.  */
end_comment

begin_function
name|int
name|regnode_enable
parameter_list|(
name|struct
name|regnode
modifier|*
name|regnode
parameter_list|)
block|{
name|int
name|udelay
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|REG_TOPO_ASSERT
argument_list|()
expr_stmt|;
comment|/* Enable regulator for each node in chain, starting from source. */
name|rv
operator|=
name|regnode_resolve_parent
argument_list|(
name|regnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
return|return
operator|(
name|rv
operator|)
return|;
if|if
condition|(
name|regnode
operator|->
name|parent
operator|!=
name|NULL
condition|)
block|{
name|rv
operator|=
name|regnode_enable
argument_list|(
name|regnode
operator|->
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
return|return
operator|(
name|rv
operator|)
return|;
block|}
comment|/* Handle this node. */
name|REGNODE_XLOCK
argument_list|(
name|regnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|regnode
operator|->
name|enable_cnt
operator|==
literal|0
condition|)
block|{
name|rv
operator|=
name|REGNODE_ENABLE
argument_list|(
name|regnode
argument_list|,
name|true
argument_list|,
operator|&
name|udelay
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|REGNODE_UNLOCK
argument_list|(
name|regnode
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
name|regnode_delay
argument_list|(
name|udelay
argument_list|)
expr_stmt|;
block|}
name|regnode
operator|->
name|enable_cnt
operator|++
expr_stmt|;
name|REGNODE_UNLOCK
argument_list|(
name|regnode
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Disable regulator.  */
end_comment

begin_function
name|int
name|regnode_disable
parameter_list|(
name|struct
name|regnode
modifier|*
name|regnode
parameter_list|)
block|{
name|int
name|udelay
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|REG_TOPO_ASSERT
argument_list|()
expr_stmt|;
name|rv
operator|=
literal|0
expr_stmt|;
name|REGNODE_XLOCK
argument_list|(
name|regnode
argument_list|)
expr_stmt|;
comment|/* Disable regulator for each node in chain, starting from consumer. */
if|if
condition|(
operator|(
name|regnode
operator|->
name|enable_cnt
operator|==
literal|1
operator|)
operator|&&
operator|(
operator|(
name|regnode
operator|->
name|flags
operator|&
name|REGULATOR_FLAGS_NOT_DISABLE
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|rv
operator|=
name|REGNODE_ENABLE
argument_list|(
name|regnode
argument_list|,
name|false
argument_list|,
operator|&
name|udelay
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|REGNODE_UNLOCK
argument_list|(
name|regnode
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
name|regnode_delay
argument_list|(
name|udelay
argument_list|)
expr_stmt|;
block|}
name|regnode
operator|->
name|enable_cnt
operator|--
expr_stmt|;
name|REGNODE_UNLOCK
argument_list|(
name|regnode
argument_list|)
expr_stmt|;
name|rv
operator|=
name|regnode_resolve_parent
argument_list|(
name|regnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
return|return
operator|(
name|rv
operator|)
return|;
if|if
condition|(
name|regnode
operator|->
name|parent
operator|!=
name|NULL
condition|)
name|rv
operator|=
name|regnode_disable
argument_list|(
name|regnode
operator|->
name|parent
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Stop regulator.  */
end_comment

begin_function
name|int
name|regnode_stop
parameter_list|(
name|struct
name|regnode
modifier|*
name|regnode
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|int
name|udelay
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|REG_TOPO_ASSERT
argument_list|()
expr_stmt|;
name|rv
operator|=
literal|0
expr_stmt|;
name|REGNODE_XLOCK
argument_list|(
name|regnode
argument_list|)
expr_stmt|;
comment|/* The first node must not be enabled. */
if|if
condition|(
operator|(
name|regnode
operator|->
name|enable_cnt
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|depth
operator|==
literal|0
operator|)
condition|)
block|{
name|REGNODE_UNLOCK
argument_list|(
name|regnode
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
comment|/* Disable regulator for each node in chain, starting from consumer */
if|if
condition|(
operator|(
name|regnode
operator|->
name|enable_cnt
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|regnode
operator|->
name|flags
operator|&
name|REGULATOR_FLAGS_NOT_DISABLE
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|rv
operator|=
name|REGNODE_ENABLE
argument_list|(
name|regnode
argument_list|,
name|false
argument_list|,
operator|&
name|udelay
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|REGNODE_UNLOCK
argument_list|(
name|regnode
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
name|regnode_delay
argument_list|(
name|udelay
argument_list|)
expr_stmt|;
block|}
name|REGNODE_UNLOCK
argument_list|(
name|regnode
argument_list|)
expr_stmt|;
name|rv
operator|=
name|regnode_resolve_parent
argument_list|(
name|regnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
return|return
operator|(
name|rv
operator|)
return|;
if|if
condition|(
name|regnode
operator|->
name|parent
operator|!=
name|NULL
condition|)
name|rv
operator|=
name|regnode_stop
argument_list|(
name|regnode
operator|->
name|parent
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get regulator status. (REGULATOR_STATUS_*)  */
end_comment

begin_function
name|int
name|regnode_status
parameter_list|(
name|struct
name|regnode
modifier|*
name|regnode
parameter_list|,
name|int
modifier|*
name|status
parameter_list|)
block|{
name|int
name|rv
decl_stmt|;
name|REG_TOPO_ASSERT
argument_list|()
expr_stmt|;
name|REGNODE_XLOCK
argument_list|(
name|regnode
argument_list|)
expr_stmt|;
name|rv
operator|=
name|REGNODE_STATUS
argument_list|(
name|regnode
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|REGNODE_UNLOCK
argument_list|(
name|regnode
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get actual regulator voltage.  */
end_comment

begin_function
name|int
name|regnode_get_voltage
parameter_list|(
name|struct
name|regnode
modifier|*
name|regnode
parameter_list|,
name|int
modifier|*
name|uvolt
parameter_list|)
block|{
name|int
name|rv
decl_stmt|;
name|REG_TOPO_ASSERT
argument_list|()
expr_stmt|;
name|REGNODE_XLOCK
argument_list|(
name|regnode
argument_list|)
expr_stmt|;
name|rv
operator|=
name|REGNODE_GET_VOLTAGE
argument_list|(
name|regnode
argument_list|,
name|uvolt
argument_list|)
expr_stmt|;
name|REGNODE_UNLOCK
argument_list|(
name|regnode
argument_list|)
expr_stmt|;
comment|/* Pass call into parent, if regulator is in bypass mode. */
if|if
condition|(
name|rv
operator|==
name|ENOENT
condition|)
block|{
name|rv
operator|=
name|regnode_resolve_parent
argument_list|(
name|regnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
return|return
operator|(
name|rv
operator|)
return|;
if|if
condition|(
name|regnode
operator|->
name|parent
operator|!=
name|NULL
condition|)
name|rv
operator|=
name|regnode_get_voltage
argument_list|(
name|regnode
operator|->
name|parent
argument_list|,
name|uvolt
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set regulator voltage.  */
end_comment

begin_function
name|int
name|regnode_set_voltage
parameter_list|(
name|struct
name|regnode
modifier|*
name|regnode
parameter_list|,
name|int
name|min_uvolt
parameter_list|,
name|int
name|max_uvolt
parameter_list|)
block|{
name|int
name|udelay
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|REG_TOPO_ASSERT
argument_list|()
expr_stmt|;
name|REGNODE_XLOCK
argument_list|(
name|regnode
argument_list|)
expr_stmt|;
name|rv
operator|=
name|REGNODE_SET_VOLTAGE
argument_list|(
name|regnode
argument_list|,
name|min_uvolt
argument_list|,
name|max_uvolt
argument_list|,
operator|&
name|udelay
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
literal|0
condition|)
name|regnode_delay
argument_list|(
name|udelay
argument_list|)
expr_stmt|;
name|REGNODE_UNLOCK
argument_list|(
name|regnode
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Consumer variant of regnode_set_voltage().  */
end_comment

begin_function
specifier|static
name|int
name|regnode_set_voltage_checked
parameter_list|(
name|struct
name|regnode
modifier|*
name|regnode
parameter_list|,
name|struct
name|regulator
modifier|*
name|reg
parameter_list|,
name|int
name|min_uvolt
parameter_list|,
name|int
name|max_uvolt
parameter_list|)
block|{
name|int
name|udelay
decl_stmt|;
name|int
name|all_max_uvolt
decl_stmt|;
name|int
name|all_min_uvolt
decl_stmt|;
name|struct
name|regulator
modifier|*
name|tmp
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|REG_TOPO_ASSERT
argument_list|()
expr_stmt|;
name|REGNODE_XLOCK
argument_list|(
name|regnode
argument_list|)
expr_stmt|;
comment|/* Return error if requested range is outside of regulator range. */
if|if
condition|(
operator|(
name|min_uvolt
operator|>
name|regnode
operator|->
name|std_param
operator|.
name|max_uvolt
operator|)
operator|||
operator|(
name|max_uvolt
operator|<
name|regnode
operator|->
name|std_param
operator|.
name|min_uvolt
operator|)
condition|)
block|{
name|REGNODE_UNLOCK
argument_list|(
name|regnode
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERANGE
operator|)
return|;
block|}
comment|/* Get actual voltage range for all consumers. */
name|all_min_uvolt
operator|=
name|regnode
operator|->
name|std_param
operator|.
name|min_uvolt
expr_stmt|;
name|all_max_uvolt
operator|=
name|regnode
operator|->
name|std_param
operator|.
name|max_uvolt
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|tmp
argument_list|,
argument|&regnode->consumers_list
argument_list|,
argument|link
argument_list|)
block|{
comment|/* Don't take requestor in account. */
if|if
condition|(
name|tmp
operator|==
name|reg
condition|)
continue|continue;
if|if
condition|(
name|all_min_uvolt
operator|<
name|tmp
operator|->
name|min_uvolt
condition|)
name|all_min_uvolt
operator|=
name|tmp
operator|->
name|min_uvolt
expr_stmt|;
if|if
condition|(
name|all_max_uvolt
operator|>
name|tmp
operator|->
name|max_uvolt
condition|)
name|all_max_uvolt
operator|=
name|tmp
operator|->
name|max_uvolt
expr_stmt|;
block|}
comment|/* Test if request fits to actual contract. */
if|if
condition|(
operator|(
name|min_uvolt
operator|>
name|all_max_uvolt
operator|)
operator|||
operator|(
name|max_uvolt
operator|<
name|all_min_uvolt
operator|)
condition|)
block|{
name|REGNODE_UNLOCK
argument_list|(
name|regnode
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERANGE
operator|)
return|;
block|}
comment|/* Adjust new range.*/
if|if
condition|(
name|min_uvolt
operator|<
name|all_min_uvolt
condition|)
name|min_uvolt
operator|=
name|all_min_uvolt
expr_stmt|;
if|if
condition|(
name|max_uvolt
operator|>
name|all_max_uvolt
condition|)
name|max_uvolt
operator|=
name|all_max_uvolt
expr_stmt|;
name|rv
operator|=
name|REGNODE_SET_VOLTAGE
argument_list|(
name|regnode
argument_list|,
name|min_uvolt
argument_list|,
name|max_uvolt
argument_list|,
operator|&
name|udelay
argument_list|)
expr_stmt|;
name|regnode_delay
argument_list|(
name|udelay
argument_list|)
expr_stmt|;
name|REGNODE_UNLOCK
argument_list|(
name|regnode
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FDT
end_ifdef

begin_function
name|phandle_t
name|regnode_get_ofw_node
parameter_list|(
name|struct
name|regnode
modifier|*
name|regnode
parameter_list|)
block|{
return|return
operator|(
name|regnode
operator|->
name|ofw_node
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* --------------------------------------------------------------------------  *  * Regulator consumers interface.  *  */
end_comment

begin_comment
comment|/* Helper function for regulator_get*() */
end_comment

begin_function
specifier|static
name|regulator_t
name|regulator_create
parameter_list|(
name|struct
name|regnode
modifier|*
name|regnode
parameter_list|,
name|device_t
name|cdev
parameter_list|)
block|{
name|struct
name|regulator
modifier|*
name|reg
decl_stmt|;
name|REG_TOPO_ASSERT
argument_list|()
expr_stmt|;
name|reg
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|regulator
argument_list|)
argument_list|,
name|M_REGULATOR
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|reg
operator|->
name|cdev
operator|=
name|cdev
expr_stmt|;
name|reg
operator|->
name|regnode
operator|=
name|regnode
expr_stmt|;
name|reg
operator|->
name|enable_cnt
operator|=
literal|0
expr_stmt|;
name|REGNODE_XLOCK
argument_list|(
name|regnode
argument_list|)
expr_stmt|;
name|regnode
operator|->
name|ref_cnt
operator|++
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|regnode
operator|->
name|consumers_list
argument_list|,
name|reg
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|reg
operator|->
name|min_uvolt
operator|=
name|regnode
operator|->
name|std_param
operator|.
name|min_uvolt
expr_stmt|;
name|reg
operator|->
name|max_uvolt
operator|=
name|regnode
operator|->
name|std_param
operator|.
name|max_uvolt
expr_stmt|;
name|REGNODE_UNLOCK
argument_list|(
name|regnode
argument_list|)
expr_stmt|;
return|return
operator|(
name|reg
operator|)
return|;
block|}
end_function

begin_function
name|int
name|regulator_enable
parameter_list|(
name|regulator_t
name|reg
parameter_list|)
block|{
name|int
name|rv
decl_stmt|;
name|struct
name|regnode
modifier|*
name|regnode
decl_stmt|;
name|regnode
operator|=
name|reg
operator|->
name|regnode
expr_stmt|;
name|KASSERT
argument_list|(
name|regnode
operator|->
name|ref_cnt
operator|>
literal|0
argument_list|,
operator|(
literal|"Attempt to access unreferenced regulator: %s\n"
operator|,
name|regnode
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
name|REG_TOPO_SLOCK
argument_list|()
expr_stmt|;
name|rv
operator|=
name|regnode_enable
argument_list|(
name|regnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
literal|0
condition|)
name|reg
operator|->
name|enable_cnt
operator|++
expr_stmt|;
name|REG_TOPO_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
name|int
name|regulator_disable
parameter_list|(
name|regulator_t
name|reg
parameter_list|)
block|{
name|int
name|rv
decl_stmt|;
name|struct
name|regnode
modifier|*
name|regnode
decl_stmt|;
name|regnode
operator|=
name|reg
operator|->
name|regnode
expr_stmt|;
name|KASSERT
argument_list|(
name|regnode
operator|->
name|ref_cnt
operator|>
literal|0
argument_list|,
operator|(
literal|"Attempt to access unreferenced regulator: %s\n"
operator|,
name|regnode
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|reg
operator|->
name|enable_cnt
operator|>
literal|0
argument_list|,
operator|(
literal|"Attempt to disable already disabled regulator: %s\n"
operator|,
name|regnode
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
name|REG_TOPO_SLOCK
argument_list|()
expr_stmt|;
name|rv
operator|=
name|regnode_disable
argument_list|(
name|regnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
literal|0
condition|)
name|reg
operator|->
name|enable_cnt
operator|--
expr_stmt|;
name|REG_TOPO_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
name|int
name|regulator_stop
parameter_list|(
name|regulator_t
name|reg
parameter_list|)
block|{
name|int
name|rv
decl_stmt|;
name|struct
name|regnode
modifier|*
name|regnode
decl_stmt|;
name|regnode
operator|=
name|reg
operator|->
name|regnode
expr_stmt|;
name|KASSERT
argument_list|(
name|regnode
operator|->
name|ref_cnt
operator|>
literal|0
argument_list|,
operator|(
literal|"Attempt to access unreferenced regulator: %s\n"
operator|,
name|regnode
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|reg
operator|->
name|enable_cnt
operator|==
literal|0
argument_list|,
operator|(
literal|"Attempt to stop already enabled regulator: %s\n"
operator|,
name|regnode
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
name|REG_TOPO_SLOCK
argument_list|()
expr_stmt|;
name|rv
operator|=
name|regnode_stop
argument_list|(
name|regnode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_TOPO_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
name|int
name|regulator_status
parameter_list|(
name|regulator_t
name|reg
parameter_list|,
name|int
modifier|*
name|status
parameter_list|)
block|{
name|int
name|rv
decl_stmt|;
name|struct
name|regnode
modifier|*
name|regnode
decl_stmt|;
name|regnode
operator|=
name|reg
operator|->
name|regnode
expr_stmt|;
name|KASSERT
argument_list|(
name|regnode
operator|->
name|ref_cnt
operator|>
literal|0
argument_list|,
operator|(
literal|"Attempt to access unreferenced regulator: %s\n"
operator|,
name|regnode
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
name|REG_TOPO_SLOCK
argument_list|()
expr_stmt|;
name|rv
operator|=
name|regnode_status
argument_list|(
name|regnode
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|REG_TOPO_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
name|int
name|regulator_get_voltage
parameter_list|(
name|regulator_t
name|reg
parameter_list|,
name|int
modifier|*
name|uvolt
parameter_list|)
block|{
name|int
name|rv
decl_stmt|;
name|struct
name|regnode
modifier|*
name|regnode
decl_stmt|;
name|regnode
operator|=
name|reg
operator|->
name|regnode
expr_stmt|;
name|KASSERT
argument_list|(
name|regnode
operator|->
name|ref_cnt
operator|>
literal|0
argument_list|,
operator|(
literal|"Attempt to access unreferenced regulator: %s\n"
operator|,
name|regnode
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
name|REG_TOPO_SLOCK
argument_list|()
expr_stmt|;
name|rv
operator|=
name|regnode_get_voltage
argument_list|(
name|regnode
argument_list|,
name|uvolt
argument_list|)
expr_stmt|;
name|REG_TOPO_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
name|int
name|regulator_set_voltage
parameter_list|(
name|regulator_t
name|reg
parameter_list|,
name|int
name|min_uvolt
parameter_list|,
name|int
name|max_uvolt
parameter_list|)
block|{
name|struct
name|regnode
modifier|*
name|regnode
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|regnode
operator|=
name|reg
operator|->
name|regnode
expr_stmt|;
name|KASSERT
argument_list|(
name|regnode
operator|->
name|ref_cnt
operator|>
literal|0
argument_list|,
operator|(
literal|"Attempt to access unreferenced regulator: %s\n"
operator|,
name|regnode
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
name|REG_TOPO_SLOCK
argument_list|()
expr_stmt|;
name|rv
operator|=
name|regnode_set_voltage_checked
argument_list|(
name|regnode
argument_list|,
name|reg
argument_list|,
name|min_uvolt
argument_list|,
name|max_uvolt
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
literal|0
condition|)
block|{
name|reg
operator|->
name|min_uvolt
operator|=
name|min_uvolt
expr_stmt|;
name|reg
operator|->
name|max_uvolt
operator|=
name|max_uvolt
expr_stmt|;
block|}
name|REG_TOPO_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|regulator_get_name
parameter_list|(
name|regulator_t
name|reg
parameter_list|)
block|{
name|struct
name|regnode
modifier|*
name|regnode
decl_stmt|;
name|regnode
operator|=
name|reg
operator|->
name|regnode
expr_stmt|;
name|KASSERT
argument_list|(
name|regnode
operator|->
name|ref_cnt
operator|>
literal|0
argument_list|,
operator|(
literal|"Attempt to access unreferenced regulator: %s\n"
operator|,
name|regnode
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|regnode
operator|->
name|name
operator|)
return|;
block|}
end_function

begin_function
name|int
name|regulator_get_by_name
parameter_list|(
name|device_t
name|cdev
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|regulator_t
modifier|*
name|reg
parameter_list|)
block|{
name|struct
name|regnode
modifier|*
name|regnode
decl_stmt|;
name|REG_TOPO_SLOCK
argument_list|()
expr_stmt|;
name|regnode
operator|=
name|regnode_find_by_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|regnode
operator|==
name|NULL
condition|)
block|{
name|REG_TOPO_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
operator|*
name|reg
operator|=
name|regulator_create
argument_list|(
name|regnode
argument_list|,
name|cdev
argument_list|)
expr_stmt|;
name|REG_TOPO_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|regulator_get_by_id
parameter_list|(
name|device_t
name|cdev
parameter_list|,
name|device_t
name|pdev
parameter_list|,
name|intptr_t
name|id
parameter_list|,
name|regulator_t
modifier|*
name|reg
parameter_list|)
block|{
name|struct
name|regnode
modifier|*
name|regnode
decl_stmt|;
name|REG_TOPO_SLOCK
argument_list|()
expr_stmt|;
name|regnode
operator|=
name|regnode_find_by_id
argument_list|(
name|pdev
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|regnode
operator|==
name|NULL
condition|)
block|{
name|REG_TOPO_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
operator|*
name|reg
operator|=
name|regulator_create
argument_list|(
name|regnode
argument_list|,
name|cdev
argument_list|)
expr_stmt|;
name|REG_TOPO_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|regulator_release
parameter_list|(
name|regulator_t
name|reg
parameter_list|)
block|{
name|struct
name|regnode
modifier|*
name|regnode
decl_stmt|;
name|regnode
operator|=
name|reg
operator|->
name|regnode
expr_stmt|;
name|KASSERT
argument_list|(
name|regnode
operator|->
name|ref_cnt
operator|>
literal|0
argument_list|,
operator|(
literal|"Attempt to access unreferenced regulator: %s\n"
operator|,
name|regnode
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
name|REG_TOPO_SLOCK
argument_list|()
expr_stmt|;
while|while
condition|(
name|reg
operator|->
name|enable_cnt
operator|>
literal|0
condition|)
block|{
name|regnode_disable
argument_list|(
name|regnode
argument_list|)
expr_stmt|;
name|reg
operator|->
name|enable_cnt
operator|--
expr_stmt|;
block|}
name|REGNODE_XLOCK
argument_list|(
name|regnode
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|regnode
operator|->
name|consumers_list
argument_list|,
name|reg
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|regnode
operator|->
name|ref_cnt
operator|--
expr_stmt|;
name|REGNODE_UNLOCK
argument_list|(
name|regnode
argument_list|)
expr_stmt|;
name|REG_TOPO_UNLOCK
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|reg
argument_list|,
name|M_REGULATOR
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FDT
end_ifdef

begin_comment
comment|/* Default DT mapper. */
end_comment

begin_function
name|int
name|regdev_default_ofw_map
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|phandle_t
name|xref
parameter_list|,
name|int
name|ncells
parameter_list|,
name|pcell_t
modifier|*
name|cells
parameter_list|,
name|intptr_t
modifier|*
name|id
parameter_list|)
block|{
if|if
condition|(
name|ncells
operator|==
literal|0
condition|)
operator|*
name|id
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|ncells
operator|==
literal|1
condition|)
operator|*
name|id
operator|=
name|cells
index|[
literal|0
index|]
expr_stmt|;
else|else
return|return
operator|(
name|ERANGE
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|regulator_parse_ofw_stdparam
parameter_list|(
name|device_t
name|pdev
parameter_list|,
name|phandle_t
name|node
parameter_list|,
name|struct
name|regnode_init_def
modifier|*
name|def
parameter_list|)
block|{
name|phandle_t
name|supply_xref
decl_stmt|;
name|struct
name|regnode_std_param
modifier|*
name|par
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|par
operator|=
operator|&
name|def
operator|->
name|std_param
expr_stmt|;
name|rv
operator|=
name|OF_getprop_alloc
argument_list|(
name|node
argument_list|,
literal|"regulator-name"
argument_list|,
literal|1
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|def
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|<=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|pdev
argument_list|,
literal|"%s: Missing regulator name\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|rv
operator|=
name|OF_getencprop
argument_list|(
name|node
argument_list|,
literal|"regulator-min-microvolt"
argument_list|,
operator|&
name|par
operator|->
name|min_uvolt
argument_list|,
sizeof|sizeof
argument_list|(
name|par
operator|->
name|min_uvolt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|<=
literal|0
condition|)
name|par
operator|->
name|min_uvolt
operator|=
literal|0
expr_stmt|;
name|rv
operator|=
name|OF_getencprop
argument_list|(
name|node
argument_list|,
literal|"regulator-max-microvolt"
argument_list|,
operator|&
name|par
operator|->
name|max_uvolt
argument_list|,
sizeof|sizeof
argument_list|(
name|par
operator|->
name|max_uvolt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|<=
literal|0
condition|)
name|par
operator|->
name|max_uvolt
operator|=
literal|0
expr_stmt|;
name|rv
operator|=
name|OF_getencprop
argument_list|(
name|node
argument_list|,
literal|"regulator-min-microamp"
argument_list|,
operator|&
name|par
operator|->
name|min_uamp
argument_list|,
sizeof|sizeof
argument_list|(
name|par
operator|->
name|min_uamp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|<=
literal|0
condition|)
name|par
operator|->
name|min_uamp
operator|=
literal|0
expr_stmt|;
name|rv
operator|=
name|OF_getencprop
argument_list|(
name|node
argument_list|,
literal|"regulator-max-microamp"
argument_list|,
operator|&
name|par
operator|->
name|max_uamp
argument_list|,
sizeof|sizeof
argument_list|(
name|par
operator|->
name|max_uamp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|<=
literal|0
condition|)
name|par
operator|->
name|max_uamp
operator|=
literal|0
expr_stmt|;
name|rv
operator|=
name|OF_getencprop
argument_list|(
name|node
argument_list|,
literal|"regulator-ramp-delay"
argument_list|,
operator|&
name|par
operator|->
name|ramp_delay
argument_list|,
sizeof|sizeof
argument_list|(
name|par
operator|->
name|ramp_delay
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|<=
literal|0
condition|)
name|par
operator|->
name|ramp_delay
operator|=
literal|0
expr_stmt|;
name|rv
operator|=
name|OF_getencprop
argument_list|(
name|node
argument_list|,
literal|"regulator-enable-ramp-delay"
argument_list|,
operator|&
name|par
operator|->
name|enable_delay
argument_list|,
sizeof|sizeof
argument_list|(
name|par
operator|->
name|enable_delay
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|<=
literal|0
condition|)
name|par
operator|->
name|enable_delay
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|OF_hasprop
argument_list|(
name|node
argument_list|,
literal|"regulator-boot-on"
argument_list|)
condition|)
name|par
operator|->
name|boot_on
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|OF_hasprop
argument_list|(
name|node
argument_list|,
literal|"regulator-always-on"
argument_list|)
condition|)
name|par
operator|->
name|always_on
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|OF_hasprop
argument_list|(
name|node
argument_list|,
literal|"enable-active-high"
argument_list|)
condition|)
name|par
operator|->
name|enable_active_high
operator|=
literal|1
expr_stmt|;
name|rv
operator|=
name|OF_getencprop
argument_list|(
name|node
argument_list|,
literal|"vin-supply"
argument_list|,
operator|&
name|supply_xref
argument_list|,
sizeof|sizeof
argument_list|(
name|supply_xref
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|>=
literal|0
condition|)
block|{
name|rv
operator|=
name|OF_getprop_alloc
argument_list|(
name|supply_xref
argument_list|,
literal|"regulator-name"
argument_list|,
literal|1
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|def
operator|->
name|parent_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|<=
literal|0
condition|)
name|def
operator|->
name|parent_name
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|regulator_get_by_ofw_property
parameter_list|(
name|device_t
name|cdev
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|regulator_t
modifier|*
name|reg
parameter_list|)
block|{
name|phandle_t
name|cnode
decl_stmt|,
modifier|*
name|cells
decl_stmt|;
name|device_t
name|regdev
decl_stmt|;
name|int
name|ncells
decl_stmt|,
name|rv
decl_stmt|;
name|intptr_t
name|id
decl_stmt|;
operator|*
name|reg
operator|=
name|NULL
expr_stmt|;
name|cnode
operator|=
name|ofw_bus_get_node
argument_list|(
name|cdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnode
operator|<=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|cdev
argument_list|,
literal|"%s called on not ofw based device\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|cells
operator|=
name|NULL
expr_stmt|;
name|ncells
operator|=
name|OF_getencprop_alloc
argument_list|(
name|cnode
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cells
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|cells
argument_list|)
expr_stmt|;
if|if
condition|(
name|ncells
operator|<=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Translate xref to device */
name|regdev
operator|=
name|OF_device_from_xref
argument_list|(
name|cells
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|regdev
operator|==
name|NULL
condition|)
block|{
name|OF_prop_free
argument_list|(
name|cells
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
comment|/* Map regulator to number */
name|rv
operator|=
name|REGDEV_MAP
argument_list|(
name|regdev
argument_list|,
name|cells
index|[
literal|0
index|]
argument_list|,
name|ncells
operator|-
literal|1
argument_list|,
name|cells
operator|+
literal|1
argument_list|,
operator|&
name|id
argument_list|)
expr_stmt|;
name|OF_prop_free
argument_list|(
name|cells
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
return|return
operator|(
name|rv
operator|)
return|;
return|return
operator|(
name|regulator_get_by_id
argument_list|(
name|cdev
argument_list|,
name|regdev
argument_list|,
name|id
argument_list|,
name|reg
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

