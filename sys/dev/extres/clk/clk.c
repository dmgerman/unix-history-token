begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright 2016 Michal Meloun<mmel@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_platform.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/kobj.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|FDT
end_ifdef

begin_include
include|#
directive|include
file|<dev/fdt/fdt_common.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus_subr.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/extres/clk/clk.h>
end_include

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_CLOCK
argument_list|,
literal|"clocks"
argument_list|,
literal|"Clock framework"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Forward declarations. */
end_comment

begin_struct_decl
struct_decl|struct
name|clk
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|clknodenode
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|clkdom
struct_decl|;
end_struct_decl

begin_typedef
typedef|typedef
name|TAILQ_HEAD
argument_list|(
argument|clknode_list
argument_list|,
argument|clknode
argument_list|)
name|clknode_list_t
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|TAILQ_HEAD
argument_list|(
argument|clkdom_list
argument_list|,
argument|clkdom
argument_list|)
name|clkdom_list_t
expr_stmt|;
end_typedef

begin_comment
comment|/* Default clock methods. */
end_comment

begin_function_decl
specifier|static
name|int
name|clknode_method_init
parameter_list|(
name|struct
name|clknode
modifier|*
name|clk
parameter_list|,
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|clknode_method_recalc_freq
parameter_list|(
name|struct
name|clknode
modifier|*
name|clk
parameter_list|,
name|uint64_t
modifier|*
name|freq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|clknode_method_set_freq
parameter_list|(
name|struct
name|clknode
modifier|*
name|clk
parameter_list|,
name|uint64_t
name|fin
parameter_list|,
name|uint64_t
modifier|*
name|fout
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
modifier|*
name|stop
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|clknode_method_set_gate
parameter_list|(
name|struct
name|clknode
modifier|*
name|clk
parameter_list|,
name|bool
name|enable
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|clknode_method_set_mux
parameter_list|(
name|struct
name|clknode
modifier|*
name|clk
parameter_list|,
name|int
name|idx
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Clock controller methods.  */
end_comment

begin_decl_stmt
specifier|static
name|clknode_method_t
name|clknode_methods
index|[]
init|=
block|{
name|CLKNODEMETHOD
argument_list|(
name|clknode_init
argument_list|,
name|clknode_method_init
argument_list|)
block|,
name|CLKNODEMETHOD
argument_list|(
name|clknode_recalc_freq
argument_list|,
name|clknode_method_recalc_freq
argument_list|)
block|,
name|CLKNODEMETHOD
argument_list|(
name|clknode_set_freq
argument_list|,
name|clknode_method_set_freq
argument_list|)
block|,
name|CLKNODEMETHOD
argument_list|(
name|clknode_set_gate
argument_list|,
name|clknode_method_set_gate
argument_list|)
block|,
name|CLKNODEMETHOD
argument_list|(
name|clknode_set_mux
argument_list|,
name|clknode_method_set_mux
argument_list|)
block|,
name|CLKNODEMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DEFINE_CLASS_0
argument_list|(
name|clknode
argument_list|,
name|clknode_class
argument_list|,
name|clknode_methods
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Clock node - basic element for modeling SOC clock graph.  It holds the clock  * provider's data about the clock, and the links for the clock's membership in  * various lists.  */
end_comment

begin_struct
struct|struct
name|clknode
block|{
name|KOBJ_FIELDS
expr_stmt|;
comment|/* Clock nodes topology. */
name|struct
name|clkdom
modifier|*
name|clkdom
decl_stmt|;
comment|/* Owning clock domain */
name|TAILQ_ENTRY
argument_list|(
argument|clknode
argument_list|)
name|clkdom_link
expr_stmt|;
comment|/* Domain list entry */
name|TAILQ_ENTRY
argument_list|(
argument|clknode
argument_list|)
name|clklist_link
expr_stmt|;
comment|/* Global list entry */
comment|/* String based parent list. */
specifier|const
name|char
modifier|*
modifier|*
name|parent_names
decl_stmt|;
comment|/* Array of parent names */
name|int
name|parent_cnt
decl_stmt|;
comment|/* Number of parents */
name|int
name|parent_idx
decl_stmt|;
comment|/* Parent index or -1 */
comment|/* Cache for already resolved names. */
name|struct
name|clknode
modifier|*
modifier|*
name|parents
decl_stmt|;
comment|/* Array of potential parents */
name|struct
name|clknode
modifier|*
name|parent
decl_stmt|;
comment|/* Current parent */
comment|/* Parent/child relationship links. */
name|clknode_list_t
name|children
decl_stmt|;
comment|/* List of our children */
name|TAILQ_ENTRY
argument_list|(
argument|clknode
argument_list|)
name|sibling_link
expr_stmt|;
comment|/* Our entry in parent's list */
comment|/* Details of this device. */
name|void
modifier|*
name|softc
decl_stmt|;
comment|/* Instance softc */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Globally unique name */
name|intptr_t
name|id
decl_stmt|;
comment|/* Per domain unique id */
name|int
name|flags
decl_stmt|;
comment|/* CLK_FLAG_*  */
name|struct
name|sx
name|lock
decl_stmt|;
comment|/* Lock for this clock */
name|int
name|ref_cnt
decl_stmt|;
comment|/* Reference counter */
name|int
name|enable_cnt
decl_stmt|;
comment|/* Enabled counter */
comment|/* Cached values. */
name|uint64_t
name|freq
decl_stmt|;
comment|/* Actual frequency */
block|}
struct|;
end_struct

begin_comment
comment|/*  *  Per consumer data, information about how a consumer is using a clock node.  *  A pointer to this structure is used as a handle in the consumer interface.  */
end_comment

begin_struct
struct|struct
name|clk
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|clknode
modifier|*
name|clknode
decl_stmt|;
name|int
name|enable_cnt
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Clock domain - a group of clocks provided by one clock device.  */
end_comment

begin_struct
struct|struct
name|clkdom
block|{
name|device_t
name|dev
decl_stmt|;
comment|/* Link to provider device */
name|TAILQ_ENTRY
argument_list|(
argument|clkdom
argument_list|)
name|link
expr_stmt|;
comment|/* Global domain list entry */
name|clknode_list_t
name|clknode_list
decl_stmt|;
comment|/* All clocks in the domain */
ifdef|#
directive|ifdef
name|FDT
name|clknode_ofw_mapper_func
modifier|*
name|ofw_mapper
decl_stmt|;
comment|/* Find clock using FDT xref */
endif|#
directive|endif
block|}
struct|;
end_struct

begin_comment
comment|/*  * The system-wide list of clock domains.  */
end_comment

begin_decl_stmt
specifier|static
name|clkdom_list_t
name|clkdom_list
init|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|clkdom_list
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Each clock node is linked on a system-wide list and can be searched by name.  */
end_comment

begin_decl_stmt
specifier|static
name|clknode_list_t
name|clknode_list
init|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|clknode_list
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Locking - we use three levels of locking:  * - First, topology lock is taken.  This one protect all lists.  * - Second level is per clknode lock.  It protects clknode data.  * - Third level is outside of this file, it protect clock device registers.  * First two levels use sleepable locks; clock device can use mutex or sx lock.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sx
name|clk_topo_lock
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SX_SYSINIT
argument_list|(
name|clock_topology
argument_list|,
operator|&
name|clk_topo_lock
argument_list|,
literal|"Clock topology lock"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|CLK_TOPO_SLOCK
parameter_list|()
value|sx_slock(&clk_topo_lock)
end_define

begin_define
define|#
directive|define
name|CLK_TOPO_XLOCK
parameter_list|()
value|sx_xlock(&clk_topo_lock)
end_define

begin_define
define|#
directive|define
name|CLK_TOPO_UNLOCK
parameter_list|()
value|sx_unlock(&clk_topo_lock)
end_define

begin_define
define|#
directive|define
name|CLK_TOPO_ASSERT
parameter_list|()
value|sx_assert(&clk_topo_lock, SA_LOCKED)
end_define

begin_define
define|#
directive|define
name|CLK_TOPO_XASSERT
parameter_list|()
value|sx_assert(&clk_topo_lock, SA_XLOCKED)
end_define

begin_define
define|#
directive|define
name|CLKNODE_SLOCK
parameter_list|(
name|_sc
parameter_list|)
value|sx_slock(&((_sc)->lock))
end_define

begin_define
define|#
directive|define
name|CLKNODE_XLOCK
parameter_list|(
name|_sc
parameter_list|)
value|sx_xlock(&((_sc)->lock))
end_define

begin_define
define|#
directive|define
name|CLKNODE_UNLOCK
parameter_list|(
name|_sc
parameter_list|)
value|sx_unlock(&((_sc)->lock))
end_define

begin_function_decl
specifier|static
name|void
name|clknode_adjust_parent
parameter_list|(
name|struct
name|clknode
modifier|*
name|clknode
parameter_list|,
name|int
name|idx
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Default clock methods for base class.  */
end_comment

begin_function
specifier|static
name|int
name|clknode_method_init
parameter_list|(
name|struct
name|clknode
modifier|*
name|clknode
parameter_list|,
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|clknode_method_recalc_freq
parameter_list|(
name|struct
name|clknode
modifier|*
name|clknode
parameter_list|,
name|uint64_t
modifier|*
name|freq
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|clknode_method_set_freq
parameter_list|(
name|struct
name|clknode
modifier|*
name|clknode
parameter_list|,
name|uint64_t
name|fin
parameter_list|,
name|uint64_t
modifier|*
name|fout
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
modifier|*
name|stop
parameter_list|)
block|{
operator|*
name|stop
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|clknode_method_set_gate
parameter_list|(
name|struct
name|clknode
modifier|*
name|clk
parameter_list|,
name|bool
name|enable
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|clknode_method_set_mux
parameter_list|(
name|struct
name|clknode
modifier|*
name|clk
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Internal functions.  */
end_comment

begin_comment
comment|/*  * Duplicate an array of parent names.  *  * Compute total size and allocate a single block which holds both the array of  * pointers to strings and the copied strings themselves.  Returns a pointer to  * the start of the block where the array of copied string pointers lives.  *  * XXX Revisit this, no need for the DECONST stuff.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
modifier|*
name|strdup_list
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|names
parameter_list|,
name|int
name|num
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|,
name|slen
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|outptr
decl_stmt|,
modifier|*
name|ptr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|num
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|names
index|[
name|i
index|]
operator|==
name|NULL
condition|)
continue|continue;
name|slen
operator|=
name|strlen
argument_list|(
name|names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|slen
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"Clock parent names array have empty string"
argument_list|)
expr_stmt|;
name|len
operator|+=
name|slen
operator|+
literal|1
expr_stmt|;
block|}
name|outptr
operator|=
name|malloc
argument_list|(
name|len
argument_list|,
name|M_CLOCK
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|outptr
operator|+
name|num
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|names
index|[
name|i
index|]
operator|==
name|NULL
condition|)
continue|continue;
name|outptr
index|[
name|i
index|]
operator|=
name|ptr
expr_stmt|;
name|slen
operator|=
name|strlen
argument_list|(
name|names
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
name|bcopy
argument_list|(
name|names
index|[
name|i
index|]
argument_list|,
name|__DECONST
argument_list|(
name|void
operator|*
argument_list|,
name|outptr
index|[
name|i
index|]
argument_list|)
argument_list|,
name|slen
argument_list|)
expr_stmt|;
name|ptr
operator|+=
name|slen
expr_stmt|;
block|}
return|return
operator|(
name|outptr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Recompute the cached frequency for this node and all its children.  */
end_comment

begin_function
specifier|static
name|int
name|clknode_refresh_cache
parameter_list|(
name|struct
name|clknode
modifier|*
name|clknode
parameter_list|,
name|uint64_t
name|freq
parameter_list|)
block|{
name|int
name|rv
decl_stmt|;
name|struct
name|clknode
modifier|*
name|entry
decl_stmt|;
name|CLK_TOPO_XASSERT
argument_list|()
expr_stmt|;
comment|/* Compute generated frequency. */
name|rv
operator|=
name|CLKNODE_RECALC_FREQ
argument_list|(
name|clknode
argument_list|,
operator|&
name|freq
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
comment|/* XXX If an error happens while refreshing children 		  * this leaves the world in a  partially-updated state. 		  * Panic for now. 		  */
name|panic
argument_list|(
literal|"clknode_refresh_cache failed for '%s'\n"
argument_list|,
name|clknode
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
comment|/* Refresh cache for this node. */
name|clknode
operator|->
name|freq
operator|=
name|freq
expr_stmt|;
comment|/* Refresh cache for all children. */
name|TAILQ_FOREACH
argument_list|(
argument|entry
argument_list|,
argument|&(clknode->children)
argument_list|,
argument|sibling_link
argument_list|)
block|{
name|rv
operator|=
name|clknode_refresh_cache
argument_list|(
name|entry
argument_list|,
name|freq
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
return|return
operator|(
name|rv
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Public interface.  */
end_comment

begin_function
name|struct
name|clknode
modifier|*
name|clknode_find_by_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|clknode
modifier|*
name|entry
decl_stmt|;
name|CLK_TOPO_ASSERT
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|entry
argument_list|,
argument|&clknode_list
argument_list|,
argument|clklist_link
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|entry
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|entry
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|clknode
modifier|*
name|clknode_find_by_id
parameter_list|(
name|struct
name|clkdom
modifier|*
name|clkdom
parameter_list|,
name|intptr_t
name|id
parameter_list|)
block|{
name|struct
name|clknode
modifier|*
name|entry
decl_stmt|;
name|CLK_TOPO_ASSERT
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|entry
argument_list|,
argument|&clkdom->clknode_list
argument_list|,
argument|clkdom_link
argument_list|)
block|{
if|if
condition|(
name|entry
operator|->
name|id
operator|==
name|id
condition|)
return|return
operator|(
name|entry
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* -------------------------------------------------------------------------- */
end_comment

begin_comment
comment|/*  * Clock domain functions  */
end_comment

begin_comment
comment|/* Find clock domain associated to device in global list. */
end_comment

begin_function
name|struct
name|clkdom
modifier|*
name|clkdom_get_by_dev
parameter_list|(
specifier|const
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|clkdom
modifier|*
name|entry
decl_stmt|;
name|CLK_TOPO_ASSERT
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|entry
argument_list|,
argument|&clkdom_list
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|entry
operator|->
name|dev
operator|==
name|dev
condition|)
return|return
operator|(
name|entry
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FDT
end_ifdef

begin_comment
comment|/* Default DT mapper. */
end_comment

begin_function
specifier|static
name|int
name|clknode_default_ofw_map
parameter_list|(
name|struct
name|clkdom
modifier|*
name|clkdom
parameter_list|,
name|uint32_t
name|ncells
parameter_list|,
name|phandle_t
modifier|*
name|cells
parameter_list|,
name|struct
name|clknode
modifier|*
modifier|*
name|clk
parameter_list|)
block|{
name|CLK_TOPO_ASSERT
argument_list|()
expr_stmt|;
if|if
condition|(
name|ncells
operator|==
literal|0
condition|)
operator|*
name|clk
operator|=
name|clknode_find_by_id
argument_list|(
name|clkdom
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ncells
operator|==
literal|1
condition|)
operator|*
name|clk
operator|=
name|clknode_find_by_id
argument_list|(
name|clkdom
argument_list|,
name|cells
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
return|return
operator|(
name|ERANGE
operator|)
return|;
if|if
condition|(
operator|*
name|clk
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Create a clock domain.  Returns with the topo lock held.  */
end_comment

begin_function
name|struct
name|clkdom
modifier|*
name|clkdom_create
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|clkdom
modifier|*
name|clkdom
decl_stmt|;
name|clkdom
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|clkdom
argument_list|)
argument_list|,
name|M_CLOCK
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|clkdom
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|clkdom
operator|->
name|clknode_list
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FDT
name|clkdom
operator|->
name|ofw_mapper
operator|=
name|clknode_default_ofw_map
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|clkdom
operator|)
return|;
block|}
end_function

begin_function
name|void
name|clkdom_unlock
parameter_list|(
name|struct
name|clkdom
modifier|*
name|clkdom
parameter_list|)
block|{
name|CLK_TOPO_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|clkdom_xlock
parameter_list|(
name|struct
name|clkdom
modifier|*
name|clkdom
parameter_list|)
block|{
name|CLK_TOPO_XLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Finalize initialization of clock domain.  Releases topo lock.  *  * XXX Revisit failure handling.  */
end_comment

begin_function
name|int
name|clkdom_finit
parameter_list|(
name|struct
name|clkdom
modifier|*
name|clkdom
parameter_list|)
block|{
name|struct
name|clknode
modifier|*
name|clknode
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rv
decl_stmt|;
ifdef|#
directive|ifdef
name|FDT
name|phandle_t
name|node
decl_stmt|;
if|if
condition|(
operator|(
name|node
operator|=
name|ofw_bus_get_node
argument_list|(
name|clkdom
operator|->
name|dev
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|device_printf
argument_list|(
name|clkdom
operator|->
name|dev
argument_list|,
literal|"%s called on not ofw based device\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
endif|#
directive|endif
name|rv
operator|=
literal|0
expr_stmt|;
comment|/* Make clock domain globally visible. */
name|CLK_TOPO_XLOCK
argument_list|()
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|clkdom_list
argument_list|,
name|clkdom
argument_list|,
name|link
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FDT
name|OF_device_register_xref
argument_list|(
name|OF_xref_from_node
argument_list|(
name|node
argument_list|)
argument_list|,
name|clkdom
operator|->
name|dev
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Register all clock names into global list. */
name|TAILQ_FOREACH
argument_list|(
argument|clknode
argument_list|,
argument|&clkdom->clknode_list
argument_list|,
argument|clkdom_link
argument_list|)
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|clknode_list
argument_list|,
name|clknode
argument_list|,
name|clklist_link
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * At this point all domain nodes must be registered and all 	 * parents must be valid. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|clknode
argument_list|,
argument|&clkdom->clknode_list
argument_list|,
argument|clkdom_link
argument_list|)
block|{
if|if
condition|(
name|clknode
operator|->
name|parent_cnt
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|clknode
operator|->
name|parent_cnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|clknode
operator|->
name|parents
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|clknode
operator|->
name|parent_names
index|[
name|i
index|]
operator|==
name|NULL
condition|)
continue|continue;
name|clknode
operator|->
name|parents
index|[
name|i
index|]
operator|=
name|clknode_find_by_name
argument_list|(
name|clknode
operator|->
name|parent_names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|clknode
operator|->
name|parents
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|clkdom
operator|->
name|dev
argument_list|,
literal|"Clock %s have unknown parent: %s\n"
argument_list|,
name|clknode
operator|->
name|name
argument_list|,
name|clknode
operator|->
name|parent_names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|rv
operator|=
name|ENODEV
expr_stmt|;
block|}
block|}
comment|/* If parent index is not set yet... */
if|if
condition|(
name|clknode
operator|->
name|parent_idx
operator|==
name|CLKNODE_IDX_NONE
condition|)
block|{
name|device_printf
argument_list|(
name|clkdom
operator|->
name|dev
argument_list|,
literal|"Clock %s have not set parent idx\n"
argument_list|,
name|clknode
operator|->
name|name
argument_list|)
expr_stmt|;
name|rv
operator|=
name|ENXIO
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|clknode
operator|->
name|parents
index|[
name|clknode
operator|->
name|parent_idx
index|]
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|clkdom
operator|->
name|dev
argument_list|,
literal|"Clock %s have unknown parent(idx %d): %s\n"
argument_list|,
name|clknode
operator|->
name|name
argument_list|,
name|clknode
operator|->
name|parent_idx
argument_list|,
name|clknode
operator|->
name|parent_names
index|[
name|clknode
operator|->
name|parent_idx
index|]
argument_list|)
expr_stmt|;
name|rv
operator|=
name|ENXIO
expr_stmt|;
continue|continue;
block|}
name|clknode_adjust_parent
argument_list|(
name|clknode
argument_list|,
name|clknode
operator|->
name|parent_idx
argument_list|)
expr_stmt|;
block|}
name|CLK_TOPO_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Dump clock domain. */
end_comment

begin_function
name|void
name|clkdom_dump
parameter_list|(
name|struct
name|clkdom
modifier|*
name|clkdom
parameter_list|)
block|{
name|struct
name|clknode
modifier|*
name|clknode
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|uint64_t
name|freq
decl_stmt|;
name|CLK_TOPO_SLOCK
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|clknode
argument_list|,
argument|&clkdom->clknode_list
argument_list|,
argument|clkdom_link
argument_list|)
block|{
name|rv
operator|=
name|clknode_get_freq
argument_list|(
name|clknode
argument_list|,
operator|&
name|freq
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Clock: %s, parent: %s(%d), freq: %ju\n"
argument_list|,
name|clknode
operator|->
name|name
argument_list|,
name|clknode
operator|->
name|parent
operator|==
name|NULL
condition|?
literal|"(NULL)"
else|:
name|clknode
operator|->
name|parent
operator|->
name|name
argument_list|,
name|clknode
operator|->
name|parent_idx
argument_list|,
call|(
name|uintmax_t
call|)
argument_list|(
operator|(
name|rv
operator|==
literal|0
operator|)
condition|?
name|freq
else|:
name|rv
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|CLK_TOPO_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Create and initialize clock object, but do not register it.  */
end_comment

begin_function
name|struct
name|clknode
modifier|*
name|clknode_create
parameter_list|(
name|struct
name|clkdom
modifier|*
name|clkdom
parameter_list|,
name|clknode_class_t
name|clknode_class
parameter_list|,
specifier|const
name|struct
name|clknode_init_def
modifier|*
name|def
parameter_list|)
block|{
name|struct
name|clknode
modifier|*
name|clknode
decl_stmt|;
name|KASSERT
argument_list|(
name|def
operator|->
name|name
operator|!=
name|NULL
argument_list|,
operator|(
literal|"clock name is NULL"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|def
operator|->
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
argument_list|,
operator|(
literal|"clock name is empty"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|CLK_TOPO_SLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|clknode_find_by_name
argument_list|(
name|def
operator|->
name|name
argument_list|)
operator|!=
name|NULL
condition|)
name|panic
argument_list|(
literal|"Duplicated clock registration: %s\n"
argument_list|,
name|def
operator|->
name|name
argument_list|)
expr_stmt|;
name|CLK_TOPO_UNLOCK
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Create object and initialize it. */
name|clknode
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|clknode
argument_list|)
argument_list|,
name|M_CLOCK
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|kobj_init
argument_list|(
operator|(
name|kobj_t
operator|)
name|clknode
argument_list|,
operator|(
name|kobj_class_t
operator|)
name|clknode_class
argument_list|)
expr_stmt|;
name|sx_init
argument_list|(
operator|&
name|clknode
operator|->
name|lock
argument_list|,
literal|"Clocknode lock"
argument_list|)
expr_stmt|;
comment|/* Allocate softc if required. */
if|if
condition|(
name|clknode_class
operator|->
name|size
operator|>
literal|0
condition|)
block|{
name|clknode
operator|->
name|softc
operator|=
name|malloc
argument_list|(
name|clknode_class
operator|->
name|size
argument_list|,
name|M_CLOCK
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
block|}
comment|/* Prepare array for ptrs to parent clocks. */
name|clknode
operator|->
name|parents
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|clknode
operator|*
argument_list|)
operator|*
name|def
operator|->
name|parent_cnt
argument_list|,
name|M_CLOCK
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
comment|/* Copy all strings unless they're flagged as static. */
if|if
condition|(
name|def
operator|->
name|flags
operator|&
name|CLK_NODE_STATIC_STRINGS
condition|)
block|{
name|clknode
operator|->
name|name
operator|=
name|def
operator|->
name|name
expr_stmt|;
name|clknode
operator|->
name|parent_names
operator|=
name|def
operator|->
name|parent_names
expr_stmt|;
block|}
else|else
block|{
name|clknode
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|def
operator|->
name|name
argument_list|,
name|M_CLOCK
argument_list|)
expr_stmt|;
name|clknode
operator|->
name|parent_names
operator|=
name|strdup_list
argument_list|(
name|def
operator|->
name|parent_names
argument_list|,
name|def
operator|->
name|parent_cnt
argument_list|)
expr_stmt|;
block|}
comment|/* Rest of init. */
name|clknode
operator|->
name|id
operator|=
name|def
operator|->
name|id
expr_stmt|;
name|clknode
operator|->
name|clkdom
operator|=
name|clkdom
expr_stmt|;
name|clknode
operator|->
name|flags
operator|=
name|def
operator|->
name|flags
expr_stmt|;
name|clknode
operator|->
name|parent_cnt
operator|=
name|def
operator|->
name|parent_cnt
expr_stmt|;
name|clknode
operator|->
name|parent
operator|=
name|NULL
expr_stmt|;
name|clknode
operator|->
name|parent_idx
operator|=
name|CLKNODE_IDX_NONE
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|clknode
operator|->
name|children
argument_list|)
expr_stmt|;
return|return
operator|(
name|clknode
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Register clock object into clock domain hierarchy.  */
end_comment

begin_function
name|struct
name|clknode
modifier|*
name|clknode_register
parameter_list|(
name|struct
name|clkdom
modifier|*
name|clkdom
parameter_list|,
name|struct
name|clknode
modifier|*
name|clknode
parameter_list|)
block|{
name|int
name|rv
decl_stmt|;
name|rv
operator|=
name|CLKNODE_INIT
argument_list|(
name|clknode
argument_list|,
name|clknode_get_device
argument_list|(
name|clknode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|" CLKNODE_INIT failed: %d\n"
argument_list|,
name|rv
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|clkdom
operator|->
name|clknode_list
argument_list|,
name|clknode
argument_list|,
name|clkdom_link
argument_list|)
expr_stmt|;
return|return
operator|(
name|clknode
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Clock providers interface.  */
end_comment

begin_comment
comment|/*  * Reparent clock node.  */
end_comment

begin_function
specifier|static
name|void
name|clknode_adjust_parent
parameter_list|(
name|struct
name|clknode
modifier|*
name|clknode
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|CLK_TOPO_XASSERT
argument_list|()
expr_stmt|;
if|if
condition|(
name|clknode
operator|->
name|parent_cnt
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|idx
operator|==
name|CLKNODE_IDX_NONE
operator|)
operator|||
operator|(
name|idx
operator|>=
name|clknode
operator|->
name|parent_cnt
operator|)
condition|)
name|panic
argument_list|(
literal|"Invalid clock parent index\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|clknode
operator|->
name|parents
index|[
name|idx
index|]
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"%s: Attempt to set invalid parent %d for clock %s"
argument_list|,
name|__func__
argument_list|,
name|idx
argument_list|,
name|clknode
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* Remove me from old children list. */
if|if
condition|(
name|clknode
operator|->
name|parent
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|clknode
operator|->
name|parent
operator|->
name|children
argument_list|,
name|clknode
argument_list|,
name|sibling_link
argument_list|)
expr_stmt|;
block|}
comment|/* Insert into children list of new parent. */
name|clknode
operator|->
name|parent_idx
operator|=
name|idx
expr_stmt|;
name|clknode
operator|->
name|parent
operator|=
name|clknode
operator|->
name|parents
index|[
name|idx
index|]
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|clknode
operator|->
name|parent
operator|->
name|children
argument_list|,
name|clknode
argument_list|,
name|sibling_link
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set parent index - init function.  */
end_comment

begin_function
name|void
name|clknode_init_parent_idx
parameter_list|(
name|struct
name|clknode
modifier|*
name|clknode
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
if|if
condition|(
name|clknode
operator|->
name|parent_cnt
operator|==
literal|0
condition|)
block|{
name|clknode
operator|->
name|parent_idx
operator|=
name|CLKNODE_IDX_NONE
expr_stmt|;
name|clknode
operator|->
name|parent
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|idx
operator|==
name|CLKNODE_IDX_NONE
operator|)
operator|||
operator|(
name|idx
operator|>=
name|clknode
operator|->
name|parent_cnt
operator|)
operator|||
operator|(
name|clknode
operator|->
name|parent_names
index|[
name|idx
index|]
operator|==
name|NULL
operator|)
condition|)
name|panic
argument_list|(
literal|"%s: Invalid clock parent index: %d\n"
argument_list|,
name|__func__
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|clknode
operator|->
name|parent_idx
operator|=
name|idx
expr_stmt|;
block|}
end_function

begin_function
name|int
name|clknode_set_parent_by_idx
parameter_list|(
name|struct
name|clknode
modifier|*
name|clknode
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|int
name|rv
decl_stmt|;
name|uint64_t
name|freq
decl_stmt|;
name|int
name|oldidx
decl_stmt|;
comment|/* We have exclusive topology lock, node lock is not needed. */
name|CLK_TOPO_XASSERT
argument_list|()
expr_stmt|;
if|if
condition|(
name|clknode
operator|->
name|parent_cnt
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|clknode
operator|->
name|parent_idx
operator|==
name|idx
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|oldidx
operator|=
name|clknode
operator|->
name|parent_idx
expr_stmt|;
name|clknode_adjust_parent
argument_list|(
name|clknode
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|rv
operator|=
name|CLKNODE_SET_MUX
argument_list|(
name|clknode
argument_list|,
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|clknode_adjust_parent
argument_list|(
name|clknode
argument_list|,
name|oldidx
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
name|rv
operator|=
name|clknode_get_freq
argument_list|(
name|clknode
operator|->
name|parent
argument_list|,
operator|&
name|freq
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
return|return
operator|(
name|rv
operator|)
return|;
name|rv
operator|=
name|clknode_refresh_cache
argument_list|(
name|clknode
argument_list|,
name|freq
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
name|int
name|clknode_set_parent_by_name
parameter_list|(
name|struct
name|clknode
modifier|*
name|clknode
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|rv
decl_stmt|;
name|uint64_t
name|freq
decl_stmt|;
name|int
name|oldidx
decl_stmt|,
name|idx
decl_stmt|;
comment|/* We have exclusive topology lock, node lock is not needed. */
name|CLK_TOPO_XASSERT
argument_list|()
expr_stmt|;
if|if
condition|(
name|clknode
operator|->
name|parent_cnt
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * If this node doesnt have mux, then passthrough request to parent. 	 * This feature is used in clock domain initialization and allows us to 	 * set clock source and target frequency on the tail node of the clock 	 * chain. 	 */
if|if
condition|(
name|clknode
operator|->
name|parent_cnt
operator|==
literal|1
condition|)
block|{
name|rv
operator|=
name|clknode_set_parent_by_name
argument_list|(
name|clknode
operator|->
name|parent
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|clknode
operator|->
name|parent_cnt
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
name|clknode
operator|->
name|parent_names
index|[
name|idx
index|]
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|clknode
operator|->
name|parent_names
index|[
name|idx
index|]
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|idx
operator|>=
name|clknode
operator|->
name|parent_cnt
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|clknode
operator|->
name|parent_idx
operator|==
name|idx
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|oldidx
operator|=
name|clknode
operator|->
name|parent_idx
expr_stmt|;
name|clknode_adjust_parent
argument_list|(
name|clknode
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|rv
operator|=
name|CLKNODE_SET_MUX
argument_list|(
name|clknode
argument_list|,
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|clknode_adjust_parent
argument_list|(
name|clknode
argument_list|,
name|oldidx
argument_list|)
expr_stmt|;
name|CLKNODE_UNLOCK
argument_list|(
name|clknode
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
name|rv
operator|=
name|clknode_get_freq
argument_list|(
name|clknode
operator|->
name|parent
argument_list|,
operator|&
name|freq
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
return|return
operator|(
name|rv
operator|)
return|;
name|rv
operator|=
name|clknode_refresh_cache
argument_list|(
name|clknode
argument_list|,
name|freq
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|clknode
modifier|*
name|clknode_get_parent
parameter_list|(
name|struct
name|clknode
modifier|*
name|clknode
parameter_list|)
block|{
return|return
operator|(
name|clknode
operator|->
name|parent
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|clknode_get_name
parameter_list|(
name|struct
name|clknode
modifier|*
name|clknode
parameter_list|)
block|{
return|return
operator|(
name|clknode
operator|->
name|name
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
modifier|*
name|clknode_get_parent_names
parameter_list|(
name|struct
name|clknode
modifier|*
name|clknode
parameter_list|)
block|{
return|return
operator|(
name|clknode
operator|->
name|parent_names
operator|)
return|;
block|}
end_function

begin_function
name|int
name|clknode_get_parents_num
parameter_list|(
name|struct
name|clknode
modifier|*
name|clknode
parameter_list|)
block|{
return|return
operator|(
name|clknode
operator|->
name|parent_cnt
operator|)
return|;
block|}
end_function

begin_function
name|int
name|clknode_get_parent_idx
parameter_list|(
name|struct
name|clknode
modifier|*
name|clknode
parameter_list|)
block|{
return|return
operator|(
name|clknode
operator|->
name|parent_idx
operator|)
return|;
block|}
end_function

begin_function
name|int
name|clknode_get_flags
parameter_list|(
name|struct
name|clknode
modifier|*
name|clknode
parameter_list|)
block|{
return|return
operator|(
name|clknode
operator|->
name|flags
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|clknode_get_softc
parameter_list|(
name|struct
name|clknode
modifier|*
name|clknode
parameter_list|)
block|{
return|return
operator|(
name|clknode
operator|->
name|softc
operator|)
return|;
block|}
end_function

begin_function
name|device_t
name|clknode_get_device
parameter_list|(
name|struct
name|clknode
modifier|*
name|clknode
parameter_list|)
block|{
return|return
operator|(
name|clknode
operator|->
name|clkdom
operator|->
name|dev
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FDT
end_ifdef

begin_function
name|void
name|clkdom_set_ofw_mapper
parameter_list|(
name|struct
name|clkdom
modifier|*
name|clkdom
parameter_list|,
name|clknode_ofw_mapper_func
modifier|*
name|map
parameter_list|)
block|{
name|clkdom
operator|->
name|ofw_mapper
operator|=
name|map
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Real consumers executive  */
end_comment

begin_function
name|int
name|clknode_get_freq
parameter_list|(
name|struct
name|clknode
modifier|*
name|clknode
parameter_list|,
name|uint64_t
modifier|*
name|freq
parameter_list|)
block|{
name|int
name|rv
decl_stmt|;
name|CLK_TOPO_ASSERT
argument_list|()
expr_stmt|;
comment|/* Use cached value, if it exists. */
operator|*
name|freq
operator|=
name|clknode
operator|->
name|freq
expr_stmt|;
if|if
condition|(
operator|*
name|freq
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Get frequency from parent, if the clock has a parent. */
if|if
condition|(
name|clknode
operator|->
name|parent_cnt
operator|>
literal|0
condition|)
block|{
name|rv
operator|=
name|clknode_get_freq
argument_list|(
name|clknode
operator|->
name|parent
argument_list|,
name|freq
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|rv
operator|)
return|;
block|}
block|}
comment|/* And recalculate my output frequency. */
name|CLKNODE_XLOCK
argument_list|(
name|clknode
argument_list|)
expr_stmt|;
name|rv
operator|=
name|CLKNODE_RECALC_FREQ
argument_list|(
name|clknode
argument_list|,
name|freq
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|CLKNODE_UNLOCK
argument_list|(
name|clknode
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Cannot get frequency for clk: %s, error: %d\n"
argument_list|,
name|clknode
operator|->
name|name
argument_list|,
name|rv
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
comment|/* Save new frequency to cache. */
name|clknode
operator|->
name|freq
operator|=
operator|*
name|freq
expr_stmt|;
name|CLKNODE_UNLOCK
argument_list|(
name|clknode
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|clknode_set_freq
parameter_list|(
name|struct
name|clknode
modifier|*
name|clknode
parameter_list|,
name|uint64_t
name|freq
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|enablecnt
parameter_list|)
block|{
name|int
name|rv
decl_stmt|,
name|done
decl_stmt|;
name|uint64_t
name|parent_freq
decl_stmt|;
comment|/* We have exclusive topology lock, node lock is not needed. */
name|CLK_TOPO_XASSERT
argument_list|()
expr_stmt|;
comment|/* Check for no change */
if|if
condition|(
name|clknode
operator|->
name|freq
operator|==
name|freq
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|parent_freq
operator|=
literal|0
expr_stmt|;
comment|/* 	 * We can set frequency only if 	 *   clock is disabled 	 * OR 	 *   clock is glitch free and is enabled by calling consumer only 	 */
if|if
condition|(
operator|(
name|flags
operator|&
name|CLK_SET_DRYRUN
operator|)
operator|==
literal|0
operator|&&
name|clknode
operator|->
name|enable_cnt
operator|>
literal|1
operator|&&
name|clknode
operator|->
name|enable_cnt
operator|>
name|enablecnt
operator|&&
operator|(
name|clknode
operator|->
name|flags
operator|&
name|CLK_NODE_GLITCH_FREE
operator|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
comment|/* Get frequency from parent, if the clock has a parent. */
if|if
condition|(
name|clknode
operator|->
name|parent_cnt
operator|>
literal|0
condition|)
block|{
name|rv
operator|=
name|clknode_get_freq
argument_list|(
name|clknode
operator|->
name|parent
argument_list|,
operator|&
name|parent_freq
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|rv
operator|)
return|;
block|}
block|}
comment|/* Set frequency for this clock. */
name|rv
operator|=
name|CLKNODE_SET_FREQ
argument_list|(
name|clknode
argument_list|,
name|parent_freq
argument_list|,
operator|&
name|freq
argument_list|,
name|flags
argument_list|,
operator|&
name|done
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Cannot set frequency for clk: %s, error: %d\n"
argument_list|,
name|clknode
operator|->
name|name
argument_list|,
name|rv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|CLK_SET_DRYRUN
operator|)
operator|==
literal|0
condition|)
name|clknode_refresh_cache
argument_list|(
name|clknode
argument_list|,
name|parent_freq
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
if|if
condition|(
name|done
condition|)
block|{
comment|/* Success - invalidate frequency cache for all children. */
if|if
condition|(
operator|(
name|flags
operator|&
name|CLK_SET_DRYRUN
operator|)
operator|==
literal|0
condition|)
block|{
name|clknode
operator|->
name|freq
operator|=
name|freq
expr_stmt|;
name|clknode_refresh_cache
argument_list|(
name|clknode
argument_list|,
name|parent_freq
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|clknode
operator|->
name|parent
operator|!=
name|NULL
condition|)
block|{
comment|/* Nothing changed, pass request to parent. */
name|rv
operator|=
name|clknode_set_freq
argument_list|(
name|clknode
operator|->
name|parent
argument_list|,
name|freq
argument_list|,
name|flags
argument_list|,
name|enablecnt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* End of chain without action. */
name|printf
argument_list|(
literal|"Cannot set frequency for clk: %s, end of chain\n"
argument_list|,
name|clknode
operator|->
name|name
argument_list|)
expr_stmt|;
name|rv
operator|=
name|ENXIO
expr_stmt|;
block|}
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
name|int
name|clknode_enable
parameter_list|(
name|struct
name|clknode
modifier|*
name|clknode
parameter_list|)
block|{
name|int
name|rv
decl_stmt|;
name|CLK_TOPO_ASSERT
argument_list|()
expr_stmt|;
comment|/* Enable clock for each node in chain, starting from source. */
if|if
condition|(
name|clknode
operator|->
name|parent_cnt
operator|>
literal|0
condition|)
block|{
name|rv
operator|=
name|clknode_enable
argument_list|(
name|clknode
operator|->
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|rv
operator|)
return|;
block|}
block|}
comment|/* Handle this node */
name|CLKNODE_XLOCK
argument_list|(
name|clknode
argument_list|)
expr_stmt|;
if|if
condition|(
name|clknode
operator|->
name|enable_cnt
operator|==
literal|0
condition|)
block|{
name|rv
operator|=
name|CLKNODE_SET_GATE
argument_list|(
name|clknode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|CLKNODE_UNLOCK
argument_list|(
name|clknode
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
block|}
name|clknode
operator|->
name|enable_cnt
operator|++
expr_stmt|;
name|CLKNODE_UNLOCK
argument_list|(
name|clknode
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|clknode_disable
parameter_list|(
name|struct
name|clknode
modifier|*
name|clknode
parameter_list|)
block|{
name|int
name|rv
decl_stmt|;
name|CLK_TOPO_ASSERT
argument_list|()
expr_stmt|;
name|rv
operator|=
literal|0
expr_stmt|;
name|CLKNODE_XLOCK
argument_list|(
name|clknode
argument_list|)
expr_stmt|;
comment|/* Disable clock for each node in chain, starting from consumer. */
if|if
condition|(
operator|(
name|clknode
operator|->
name|enable_cnt
operator|==
literal|1
operator|)
operator|&&
operator|(
operator|(
name|clknode
operator|->
name|flags
operator|&
name|CLK_NODE_CANNOT_STOP
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|rv
operator|=
name|CLKNODE_SET_GATE
argument_list|(
name|clknode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|CLKNODE_UNLOCK
argument_list|(
name|clknode
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
block|}
name|clknode
operator|->
name|enable_cnt
operator|--
expr_stmt|;
name|CLKNODE_UNLOCK
argument_list|(
name|clknode
argument_list|)
expr_stmt|;
if|if
condition|(
name|clknode
operator|->
name|parent_cnt
operator|>
literal|0
condition|)
block|{
name|rv
operator|=
name|clknode_disable
argument_list|(
name|clknode
operator|->
name|parent
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
name|int
name|clknode_stop
parameter_list|(
name|struct
name|clknode
modifier|*
name|clknode
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|int
name|rv
decl_stmt|;
name|CLK_TOPO_ASSERT
argument_list|()
expr_stmt|;
name|rv
operator|=
literal|0
expr_stmt|;
name|CLKNODE_XLOCK
argument_list|(
name|clknode
argument_list|)
expr_stmt|;
comment|/* The first node cannot be enabled. */
if|if
condition|(
operator|(
name|clknode
operator|->
name|enable_cnt
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|depth
operator|==
literal|0
operator|)
condition|)
block|{
name|CLKNODE_UNLOCK
argument_list|(
name|clknode
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
comment|/* Stop clock for each node in chain, starting from consumer. */
if|if
condition|(
operator|(
name|clknode
operator|->
name|enable_cnt
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|clknode
operator|->
name|flags
operator|&
name|CLK_NODE_CANNOT_STOP
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|rv
operator|=
name|CLKNODE_SET_GATE
argument_list|(
name|clknode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|CLKNODE_UNLOCK
argument_list|(
name|clknode
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
block|}
name|CLKNODE_UNLOCK
argument_list|(
name|clknode
argument_list|)
expr_stmt|;
if|if
condition|(
name|clknode
operator|->
name|parent_cnt
operator|>
literal|0
condition|)
name|rv
operator|=
name|clknode_stop
argument_list|(
name|clknode
operator|->
name|parent
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------------  *  * Clock consumers interface.  *  */
end_comment

begin_comment
comment|/* Helper function for clk_get*() */
end_comment

begin_function
specifier|static
name|clk_t
name|clk_create
parameter_list|(
name|struct
name|clknode
modifier|*
name|clknode
parameter_list|,
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|clk
modifier|*
name|clk
decl_stmt|;
name|CLK_TOPO_ASSERT
argument_list|()
expr_stmt|;
name|clk
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|clk
argument_list|)
argument_list|,
name|M_CLOCK
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|clk
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|clk
operator|->
name|clknode
operator|=
name|clknode
expr_stmt|;
name|clk
operator|->
name|enable_cnt
operator|=
literal|0
expr_stmt|;
name|clknode
operator|->
name|ref_cnt
operator|++
expr_stmt|;
return|return
operator|(
name|clk
operator|)
return|;
block|}
end_function

begin_function
name|int
name|clk_get_freq
parameter_list|(
name|clk_t
name|clk
parameter_list|,
name|uint64_t
modifier|*
name|freq
parameter_list|)
block|{
name|int
name|rv
decl_stmt|;
name|struct
name|clknode
modifier|*
name|clknode
decl_stmt|;
name|clknode
operator|=
name|clk
operator|->
name|clknode
expr_stmt|;
name|KASSERT
argument_list|(
name|clknode
operator|->
name|ref_cnt
operator|>
literal|0
argument_list|,
operator|(
literal|"Attempt to access unreferenced clock: %s\n"
operator|,
name|clknode
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
name|CLK_TOPO_SLOCK
argument_list|()
expr_stmt|;
name|rv
operator|=
name|clknode_get_freq
argument_list|(
name|clknode
argument_list|,
name|freq
argument_list|)
expr_stmt|;
name|CLK_TOPO_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
name|int
name|clk_set_freq
parameter_list|(
name|clk_t
name|clk
parameter_list|,
name|uint64_t
name|freq
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|rv
decl_stmt|;
name|struct
name|clknode
modifier|*
name|clknode
decl_stmt|;
name|flags
operator|&=
name|CLK_SET_USER_MASK
expr_stmt|;
name|clknode
operator|=
name|clk
operator|->
name|clknode
expr_stmt|;
name|KASSERT
argument_list|(
name|clknode
operator|->
name|ref_cnt
operator|>
literal|0
argument_list|,
operator|(
literal|"Attempt to access unreferenced clock: %s\n"
operator|,
name|clknode
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
name|CLK_TOPO_XLOCK
argument_list|()
expr_stmt|;
name|rv
operator|=
name|clknode_set_freq
argument_list|(
name|clknode
argument_list|,
name|freq
argument_list|,
name|flags
argument_list|,
name|clk
operator|->
name|enable_cnt
argument_list|)
expr_stmt|;
name|CLK_TOPO_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
name|int
name|clk_test_freq
parameter_list|(
name|clk_t
name|clk
parameter_list|,
name|uint64_t
name|freq
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|rv
decl_stmt|;
name|struct
name|clknode
modifier|*
name|clknode
decl_stmt|;
name|flags
operator|&=
name|CLK_SET_USER_MASK
expr_stmt|;
name|clknode
operator|=
name|clk
operator|->
name|clknode
expr_stmt|;
name|KASSERT
argument_list|(
name|clknode
operator|->
name|ref_cnt
operator|>
literal|0
argument_list|,
operator|(
literal|"Attempt to access unreferenced clock: %s\n"
operator|,
name|clknode
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
name|CLK_TOPO_XLOCK
argument_list|()
expr_stmt|;
name|rv
operator|=
name|clknode_set_freq
argument_list|(
name|clknode
argument_list|,
name|freq
argument_list|,
name|flags
operator||
name|CLK_SET_DRYRUN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CLK_TOPO_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
name|int
name|clk_get_parent
parameter_list|(
name|clk_t
name|clk
parameter_list|,
name|clk_t
modifier|*
name|parent
parameter_list|)
block|{
name|struct
name|clknode
modifier|*
name|clknode
decl_stmt|;
name|struct
name|clknode
modifier|*
name|parentnode
decl_stmt|;
name|clknode
operator|=
name|clk
operator|->
name|clknode
expr_stmt|;
name|KASSERT
argument_list|(
name|clknode
operator|->
name|ref_cnt
operator|>
literal|0
argument_list|,
operator|(
literal|"Attempt to access unreferenced clock: %s\n"
operator|,
name|clknode
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
name|CLK_TOPO_SLOCK
argument_list|()
expr_stmt|;
name|parentnode
operator|=
name|clknode_get_parent
argument_list|(
name|clknode
argument_list|)
expr_stmt|;
if|if
condition|(
name|parentnode
operator|==
name|NULL
condition|)
block|{
name|CLK_TOPO_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
operator|*
name|parent
operator|=
name|clk_create
argument_list|(
name|parentnode
argument_list|,
name|clk
operator|->
name|dev
argument_list|)
expr_stmt|;
name|CLK_TOPO_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|clk_set_parent_by_clk
parameter_list|(
name|clk_t
name|clk
parameter_list|,
name|clk_t
name|parent
parameter_list|)
block|{
name|int
name|rv
decl_stmt|;
name|struct
name|clknode
modifier|*
name|clknode
decl_stmt|;
name|struct
name|clknode
modifier|*
name|parentnode
decl_stmt|;
name|clknode
operator|=
name|clk
operator|->
name|clknode
expr_stmt|;
name|parentnode
operator|=
name|parent
operator|->
name|clknode
expr_stmt|;
name|KASSERT
argument_list|(
name|clknode
operator|->
name|ref_cnt
operator|>
literal|0
argument_list|,
operator|(
literal|"Attempt to access unreferenced clock: %s\n"
operator|,
name|clknode
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|parentnode
operator|->
name|ref_cnt
operator|>
literal|0
argument_list|,
operator|(
literal|"Attempt to access unreferenced clock: %s\n"
operator|,
name|clknode
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
name|CLK_TOPO_XLOCK
argument_list|()
expr_stmt|;
name|rv
operator|=
name|clknode_set_parent_by_name
argument_list|(
name|clknode
argument_list|,
name|parentnode
operator|->
name|name
argument_list|)
expr_stmt|;
name|CLK_TOPO_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
name|int
name|clk_enable
parameter_list|(
name|clk_t
name|clk
parameter_list|)
block|{
name|int
name|rv
decl_stmt|;
name|struct
name|clknode
modifier|*
name|clknode
decl_stmt|;
name|clknode
operator|=
name|clk
operator|->
name|clknode
expr_stmt|;
name|KASSERT
argument_list|(
name|clknode
operator|->
name|ref_cnt
operator|>
literal|0
argument_list|,
operator|(
literal|"Attempt to access unreferenced clock: %s\n"
operator|,
name|clknode
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
name|CLK_TOPO_SLOCK
argument_list|()
expr_stmt|;
name|rv
operator|=
name|clknode_enable
argument_list|(
name|clknode
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
literal|0
condition|)
name|clk
operator|->
name|enable_cnt
operator|++
expr_stmt|;
name|CLK_TOPO_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
name|int
name|clk_disable
parameter_list|(
name|clk_t
name|clk
parameter_list|)
block|{
name|int
name|rv
decl_stmt|;
name|struct
name|clknode
modifier|*
name|clknode
decl_stmt|;
name|clknode
operator|=
name|clk
operator|->
name|clknode
expr_stmt|;
name|KASSERT
argument_list|(
name|clknode
operator|->
name|ref_cnt
operator|>
literal|0
argument_list|,
operator|(
literal|"Attempt to access unreferenced clock: %s\n"
operator|,
name|clknode
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|clk
operator|->
name|enable_cnt
operator|>
literal|0
argument_list|,
operator|(
literal|"Attempt to disable already disabled clock: %s\n"
operator|,
name|clknode
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
name|CLK_TOPO_SLOCK
argument_list|()
expr_stmt|;
name|rv
operator|=
name|clknode_disable
argument_list|(
name|clknode
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
literal|0
condition|)
name|clk
operator|->
name|enable_cnt
operator|--
expr_stmt|;
name|CLK_TOPO_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
name|int
name|clk_stop
parameter_list|(
name|clk_t
name|clk
parameter_list|)
block|{
name|int
name|rv
decl_stmt|;
name|struct
name|clknode
modifier|*
name|clknode
decl_stmt|;
name|clknode
operator|=
name|clk
operator|->
name|clknode
expr_stmt|;
name|KASSERT
argument_list|(
name|clknode
operator|->
name|ref_cnt
operator|>
literal|0
argument_list|,
operator|(
literal|"Attempt to access unreferenced clock: %s\n"
operator|,
name|clknode
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|clk
operator|->
name|enable_cnt
operator|==
literal|0
argument_list|,
operator|(
literal|"Attempt to stop already enabled clock: %s\n"
operator|,
name|clknode
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
name|CLK_TOPO_SLOCK
argument_list|()
expr_stmt|;
name|rv
operator|=
name|clknode_stop
argument_list|(
name|clknode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CLK_TOPO_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
name|int
name|clk_release
parameter_list|(
name|clk_t
name|clk
parameter_list|)
block|{
name|struct
name|clknode
modifier|*
name|clknode
decl_stmt|;
name|clknode
operator|=
name|clk
operator|->
name|clknode
expr_stmt|;
name|KASSERT
argument_list|(
name|clknode
operator|->
name|ref_cnt
operator|>
literal|0
argument_list|,
operator|(
literal|"Attempt to access unreferenced clock: %s\n"
operator|,
name|clknode
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
name|CLK_TOPO_SLOCK
argument_list|()
expr_stmt|;
while|while
condition|(
name|clk
operator|->
name|enable_cnt
operator|>
literal|0
condition|)
block|{
name|clknode_disable
argument_list|(
name|clknode
argument_list|)
expr_stmt|;
name|clk
operator|->
name|enable_cnt
operator|--
expr_stmt|;
block|}
name|CLKNODE_XLOCK
argument_list|(
name|clknode
argument_list|)
expr_stmt|;
name|clknode
operator|->
name|ref_cnt
operator|--
expr_stmt|;
name|CLKNODE_UNLOCK
argument_list|(
name|clknode
argument_list|)
expr_stmt|;
name|CLK_TOPO_UNLOCK
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|clk
argument_list|,
name|M_CLOCK
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|clk_get_name
parameter_list|(
name|clk_t
name|clk
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|clknode
modifier|*
name|clknode
decl_stmt|;
name|clknode
operator|=
name|clk
operator|->
name|clknode
expr_stmt|;
name|KASSERT
argument_list|(
name|clknode
operator|->
name|ref_cnt
operator|>
literal|0
argument_list|,
operator|(
literal|"Attempt to access unreferenced clock: %s\n"
operator|,
name|clknode
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|clknode_get_name
argument_list|(
name|clknode
argument_list|)
expr_stmt|;
return|return
operator|(
name|name
operator|)
return|;
block|}
end_function

begin_function
name|int
name|clk_get_by_name
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|clk_t
modifier|*
name|clk
parameter_list|)
block|{
name|struct
name|clknode
modifier|*
name|clknode
decl_stmt|;
name|CLK_TOPO_SLOCK
argument_list|()
expr_stmt|;
name|clknode
operator|=
name|clknode_find_by_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|clknode
operator|==
name|NULL
condition|)
block|{
name|CLK_TOPO_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
operator|*
name|clk
operator|=
name|clk_create
argument_list|(
name|clknode
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|CLK_TOPO_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|clk_get_by_id
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|clkdom
modifier|*
name|clkdom
parameter_list|,
name|intptr_t
name|id
parameter_list|,
name|clk_t
modifier|*
name|clk
parameter_list|)
block|{
name|struct
name|clknode
modifier|*
name|clknode
decl_stmt|;
name|CLK_TOPO_SLOCK
argument_list|()
expr_stmt|;
name|clknode
operator|=
name|clknode_find_by_id
argument_list|(
name|clkdom
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|clknode
operator|==
name|NULL
condition|)
block|{
name|CLK_TOPO_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
operator|*
name|clk
operator|=
name|clk_create
argument_list|(
name|clknode
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|CLK_TOPO_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FDT
end_ifdef

begin_function
name|int
name|clk_set_assigned
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|phandle_t
name|node
parameter_list|)
block|{
name|clk_t
name|clk
decl_stmt|,
name|clk_parent
decl_stmt|;
name|int
name|error
decl_stmt|,
name|nclocks
decl_stmt|,
name|i
decl_stmt|;
name|error
operator|=
name|ofw_bus_parse_xref_list_get_length
argument_list|(
name|node
argument_list|,
literal|"assigned-clock-parents"
argument_list|,
literal|"#clock-cells"
argument_list|,
operator|&
name|nclocks
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|error
operator|!=
name|ENOENT
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot parse assigned-clock-parents property\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nclocks
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|clk_get_by_ofw_index_prop
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|"assigned-clock-parents"
argument_list|,
name|i
argument_list|,
operator|&
name|clk_parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot get parent %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|clk_get_by_ofw_index_prop
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|"assigned-clocks"
argument_list|,
name|i
argument_list|,
operator|&
name|clk
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot get assigned clock %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|clk_release
argument_list|(
name|clk_parent
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|clk_set_parent_by_clk
argument_list|(
name|clk
argument_list|,
name|clk_parent
argument_list|)
expr_stmt|;
name|clk_release
argument_list|(
name|clk_parent
argument_list|)
expr_stmt|;
name|clk_release
argument_list|(
name|clk
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|clk_get_by_ofw_index_prop
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|phandle_t
name|cnode
parameter_list|,
specifier|const
name|char
modifier|*
name|prop
parameter_list|,
name|int
name|idx
parameter_list|,
name|clk_t
modifier|*
name|clk
parameter_list|)
block|{
name|phandle_t
name|parent
decl_stmt|,
modifier|*
name|cells
decl_stmt|;
name|device_t
name|clockdev
decl_stmt|;
name|int
name|ncells
decl_stmt|,
name|rv
decl_stmt|;
name|struct
name|clkdom
modifier|*
name|clkdom
decl_stmt|;
name|struct
name|clknode
modifier|*
name|clknode
decl_stmt|;
operator|*
name|clk
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cnode
operator|<=
literal|0
condition|)
name|cnode
operator|=
name|ofw_bus_get_node
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnode
operator|<=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s called on not ofw based device\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|rv
operator|=
name|ofw_bus_parse_xref_list_alloc
argument_list|(
name|cnode
argument_list|,
name|prop
argument_list|,
literal|"#clock-cells"
argument_list|,
name|idx
argument_list|,
operator|&
name|parent
argument_list|,
operator|&
name|ncells
argument_list|,
operator|&
name|cells
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|rv
operator|)
return|;
block|}
name|clockdev
operator|=
name|OF_device_from_xref
argument_list|(
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|clockdev
operator|==
name|NULL
condition|)
block|{
name|rv
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|CLK_TOPO_SLOCK
argument_list|()
expr_stmt|;
name|clkdom
operator|=
name|clkdom_get_by_dev
argument_list|(
name|clockdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|clkdom
operator|==
name|NULL
condition|)
block|{
name|CLK_TOPO_UNLOCK
argument_list|()
expr_stmt|;
name|rv
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|rv
operator|=
name|clkdom
operator|->
name|ofw_mapper
argument_list|(
name|clkdom
argument_list|,
name|ncells
argument_list|,
name|cells
argument_list|,
operator|&
name|clknode
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
literal|0
condition|)
block|{
operator|*
name|clk
operator|=
name|clk_create
argument_list|(
name|clknode
argument_list|,
name|dev
argument_list|)
expr_stmt|;
block|}
name|CLK_TOPO_UNLOCK
argument_list|()
expr_stmt|;
name|done
label|:
if|if
condition|(
name|cells
operator|!=
name|NULL
condition|)
name|OF_prop_free
argument_list|(
name|cells
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
name|int
name|clk_get_by_ofw_index
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|phandle_t
name|cnode
parameter_list|,
name|int
name|idx
parameter_list|,
name|clk_t
modifier|*
name|clk
parameter_list|)
block|{
return|return
operator|(
name|clk_get_by_ofw_index_prop
argument_list|(
name|dev
argument_list|,
name|cnode
argument_list|,
literal|"clocks"
argument_list|,
name|idx
argument_list|,
name|clk
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|clk_get_by_ofw_name
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|phandle_t
name|cnode
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|clk_t
modifier|*
name|clk
parameter_list|)
block|{
name|int
name|rv
decl_stmt|,
name|idx
decl_stmt|;
if|if
condition|(
name|cnode
operator|<=
literal|0
condition|)
name|cnode
operator|=
name|ofw_bus_get_node
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnode
operator|<=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s called on not ofw based device\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|rv
operator|=
name|ofw_bus_find_string_index
argument_list|(
name|cnode
argument_list|,
literal|"clock-names"
argument_list|,
name|name
argument_list|,
operator|&
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
return|return
operator|(
name|rv
operator|)
return|;
return|return
operator|(
name|clk_get_by_ofw_index
argument_list|(
name|dev
argument_list|,
name|cnode
argument_list|,
name|idx
argument_list|,
name|clk
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------------  *  * Support functions for parsing various clock related OFW things.  */
end_comment

begin_comment
comment|/*  * Get "clock-output-names" and  (optional) "clock-indices" lists.  * Both lists are alocated using M_OFWPROP specifier.  *  * Returns number of items or 0.  */
end_comment

begin_function
name|int
name|clk_parse_ofw_out_names
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|phandle_t
name|node
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
modifier|*
name|out_names
parameter_list|,
name|uint32_t
modifier|*
modifier|*
name|indices
parameter_list|)
block|{
name|int
name|name_items
decl_stmt|,
name|rv
decl_stmt|;
operator|*
name|out_names
operator|=
name|NULL
expr_stmt|;
operator|*
name|indices
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|OF_hasprop
argument_list|(
name|node
argument_list|,
literal|"clock-output-names"
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|rv
operator|=
name|ofw_bus_string_list_to_array
argument_list|(
name|node
argument_list|,
literal|"clock-output-names"
argument_list|,
name|out_names
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|<=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|name_items
operator|=
name|rv
expr_stmt|;
if|if
condition|(
operator|!
name|OF_hasprop
argument_list|(
name|node
argument_list|,
literal|"clock-indices"
argument_list|)
condition|)
return|return
operator|(
name|name_items
operator|)
return|;
name|rv
operator|=
name|OF_getencprop_alloc
argument_list|(
name|node
argument_list|,
literal|"clock-indices"
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
name|indices
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|name_items
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|" Size of 'clock-output-names' and "
literal|"'clock-indices' differs\n"
argument_list|)
expr_stmt|;
name|OF_prop_free
argument_list|(
operator|*
name|out_names
argument_list|)
expr_stmt|;
name|OF_prop_free
argument_list|(
operator|*
name|indices
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|name_items
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get output clock name for single output clock node.  */
end_comment

begin_function
name|int
name|clk_parse_ofw_clk_name
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|phandle_t
name|node
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|out_names
decl_stmt|;
specifier|const
name|char
modifier|*
name|tmp_name
decl_stmt|;
name|int
name|rv
decl_stmt|;
operator|*
name|name
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|OF_hasprop
argument_list|(
name|node
argument_list|,
literal|"clock-output-names"
argument_list|)
condition|)
block|{
name|tmp_name
operator|=
name|ofw_bus_get_name
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_name
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
operator|*
name|name
operator|=
name|strdup
argument_list|(
name|tmp_name
argument_list|,
name|M_OFWPROP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|rv
operator|=
name|ofw_bus_string_list_to_array
argument_list|(
name|node
argument_list|,
literal|"clock-output-names"
argument_list|,
operator|&
name|out_names
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|1
condition|)
block|{
name|OF_prop_free
argument_list|(
name|out_names
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Malformed 'clock-output-names' property\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
operator|*
name|name
operator|=
name|strdup
argument_list|(
name|out_names
index|[
literal|0
index|]
argument_list|,
name|M_OFWPROP
argument_list|)
expr_stmt|;
name|OF_prop_free
argument_list|(
name|out_names
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

