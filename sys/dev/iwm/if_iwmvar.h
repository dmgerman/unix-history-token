begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$OpenBSD: if_iwmvar.h,v 1.7 2015/03/02 13:51:10 jsg Exp $	*/
end_comment

begin_comment
comment|/*	$FreeBSD$ */
end_comment

begin_comment
comment|/*  * Copyright (c) 2014 genua mbh<info@genua.de>  * Copyright (c) 2014 Fixup Software Ltd.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/*-  * Based on BSD-licensed source modules in the Linux iwlwifi driver,  * which were used as the reference documentation for this implementation.  *  * Driver version we are currently based off of is  * Linux 3.14.3 (tag id a2df521e42b1d9a23f620ac79dbfe8655a8391dd)  *  ***********************************************************************  *  * This file is provided under a dual BSD/GPLv2 license.  When using or  * redistributing this file, you may do so under either license.  *  * GPL LICENSE SUMMARY  *  * Copyright(c) 2007 - 2013 Intel Corporation. All rights reserved.  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of version 2 of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it will be useful, but  * WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  * General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110,  * USA  *  * The full GNU General Public License is included in this distribution  * in the file called COPYING.  *  * Contact Information:  *  Intel Linux Wireless<ilw@linux.intel.com>  * Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497  *  *  * BSD LICENSE  *  * Copyright(c) 2005 - 2013 Intel Corporation. All rights reserved.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  *  * Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * Neither the name Intel Corporation nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2007-2010 Damien Bergamini<damien.bergamini@free.fr>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_struct
struct|struct
name|iwm_rx_radiotap_header
block|{
name|struct
name|ieee80211_radiotap_header
name|wr_ihdr
decl_stmt|;
name|uint64_t
name|wr_tsft
decl_stmt|;
name|uint8_t
name|wr_flags
decl_stmt|;
name|uint8_t
name|wr_rate
decl_stmt|;
name|uint16_t
name|wr_chan_freq
decl_stmt|;
name|uint16_t
name|wr_chan_flags
decl_stmt|;
name|int8_t
name|wr_dbm_antsignal
decl_stmt|;
name|int8_t
name|wr_dbm_antnoise
decl_stmt|;
block|}
name|__packed
struct|;
end_struct

begin_define
define|#
directive|define
name|IWM_RX_RADIOTAP_PRESENT
define|\
value|((1<< IEEE80211_RADIOTAP_TSFT) |				\ 	 (1<< IEEE80211_RADIOTAP_FLAGS) |				\ 	 (1<< IEEE80211_RADIOTAP_RATE) |				\ 	 (1<< IEEE80211_RADIOTAP_CHANNEL) |				\ 	 (1<< IEEE80211_RADIOTAP_DBM_ANTSIGNAL) |			\ 	 (1<< IEEE80211_RADIOTAP_DBM_ANTNOISE))
end_define

begin_struct
struct|struct
name|iwm_tx_radiotap_header
block|{
name|struct
name|ieee80211_radiotap_header
name|wt_ihdr
decl_stmt|;
name|uint8_t
name|wt_flags
decl_stmt|;
name|uint8_t
name|wt_rate
decl_stmt|;
name|uint16_t
name|wt_chan_freq
decl_stmt|;
name|uint16_t
name|wt_chan_flags
decl_stmt|;
block|}
name|__packed
struct|;
end_struct

begin_define
define|#
directive|define
name|IWM_TX_RADIOTAP_PRESENT
define|\
value|((1<< IEEE80211_RADIOTAP_FLAGS) |				\ 	 (1<< IEEE80211_RADIOTAP_RATE) |				\ 	 (1<< IEEE80211_RADIOTAP_CHANNEL))
end_define

begin_define
define|#
directive|define
name|IWM_UCODE_SECTION_MAX
value|16
end_define

begin_comment
comment|/*  * fw_status is used to determine if we've already parsed the firmware file  *  * In addition to the following, status< 0 ==> -error  */
end_comment

begin_define
define|#
directive|define
name|IWM_FW_STATUS_NONE
value|0
end_define

begin_define
define|#
directive|define
name|IWM_FW_STATUS_INPROGRESS
value|1
end_define

begin_define
define|#
directive|define
name|IWM_FW_STATUS_DONE
value|2
end_define

begin_comment
comment|/**  * enum iwm_ucode_type  *  * The type of ucode.  *  * @IWM_UCODE_REGULAR: Normal runtime ucode  * @IWM_UCODE_INIT: Initial ucode  * @IWM_UCODE_WOWLAN: Wake on Wireless enabled ucode  * @IWM_UCODE_REGULAR_USNIFFER: Normal runtime ucode when using usniffer image  */
end_comment

begin_enum
enum|enum
name|iwm_ucode_type
block|{
name|IWM_UCODE_REGULAR
block|,
name|IWM_UCODE_INIT
block|,
name|IWM_UCODE_WOWLAN
block|,
name|IWM_UCODE_REGULAR_USNIFFER
block|,
name|IWM_UCODE_TYPE_MAX
block|}
enum|;
end_enum

begin_struct
struct|struct
name|iwm_ucode_capabilities
block|{
name|uint32_t
name|max_probe_length
decl_stmt|;
name|uint32_t
name|n_scan_channels
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|uint8_t
name|enabled_api
index|[
name|howmany
argument_list|(
name|IWM_NUM_UCODE_TLV_API
argument_list|,
name|NBBY
argument_list|)
index|]
decl_stmt|;
name|uint8_t
name|enabled_capa
index|[
name|howmany
argument_list|(
name|IWM_NUM_UCODE_TLV_CAPA
argument_list|,
name|NBBY
argument_list|)
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
specifier|inline
name|int
name|fw_has_api
parameter_list|(
specifier|const
name|struct
name|iwm_ucode_capabilities
modifier|*
name|capabilities
parameter_list|,
name|unsigned
name|int
name|api
parameter_list|)
block|{
return|return
name|isset
argument_list|(
name|capabilities
operator|->
name|enabled_api
argument_list|,
name|api
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|fw_has_capa
parameter_list|(
specifier|const
name|struct
name|iwm_ucode_capabilities
modifier|*
name|capabilities
parameter_list|,
name|unsigned
name|int
name|capa
parameter_list|)
block|{
return|return
name|isset
argument_list|(
name|capabilities
operator|->
name|enabled_capa
argument_list|,
name|capa
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* one for each uCode image (inst/data, init/runtime/wowlan) */
end_comment

begin_struct
struct|struct
name|iwm_fw_desc
block|{
specifier|const
name|void
modifier|*
name|data
decl_stmt|;
comment|/* vmalloc'ed data */
name|uint32_t
name|len
decl_stmt|;
comment|/* size in bytes */
name|uint32_t
name|offset
decl_stmt|;
comment|/* offset in the device */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|iwm_fw_info
block|{
specifier|const
name|struct
name|firmware
modifier|*
name|fw_fp
decl_stmt|;
name|int
name|fw_status
decl_stmt|;
struct|struct
name|iwm_fw_sects
block|{
name|struct
name|iwm_fw_desc
name|fw_sect
index|[
name|IWM_UCODE_SECTION_MAX
index|]
decl_stmt|;
name|int
name|fw_count
decl_stmt|;
name|int
name|is_dual_cpus
decl_stmt|;
name|uint32_t
name|paging_mem_size
decl_stmt|;
block|}
name|fw_sects
index|[
name|IWM_UCODE_TYPE_MAX
index|]
struct|;
name|uint32_t
name|phy_config
decl_stmt|;
name|uint8_t
name|valid_tx_ant
decl_stmt|;
name|uint8_t
name|valid_rx_ant
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|iwm_nvm_data
block|{
name|int
name|n_hw_addrs
decl_stmt|;
name|uint8_t
name|hw_addr
index|[
name|IEEE80211_ADDR_LEN
index|]
decl_stmt|;
name|int
name|sku_cap_band_24GHz_enable
decl_stmt|;
name|int
name|sku_cap_band_52GHz_enable
decl_stmt|;
name|int
name|sku_cap_11n_enable
decl_stmt|;
name|int
name|sku_cap_amt_enable
decl_stmt|;
name|int
name|sku_cap_ipan_enable
decl_stmt|;
name|uint8_t
name|radio_cfg_type
decl_stmt|;
name|uint8_t
name|radio_cfg_step
decl_stmt|;
name|uint8_t
name|radio_cfg_dash
decl_stmt|;
name|uint8_t
name|radio_cfg_pnum
decl_stmt|;
name|uint8_t
name|valid_tx_ant
decl_stmt|,
name|valid_rx_ant
decl_stmt|;
define|#
directive|define
name|IWM_NUM_CHANNELS
value|39
define|#
directive|define
name|IWM_NUM_CHANNELS_8000
value|51
name|uint16_t
name|nvm_version
decl_stmt|;
name|uint8_t
name|max_tx_pwr_half_dbm
decl_stmt|;
name|uint16_t
name|nvm_ch_flags
index|[]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* max bufs per tfd the driver will use */
end_comment

begin_define
define|#
directive|define
name|IWM_MAX_CMD_TBS_PER_TFD
value|2
end_define

begin_struct_decl
struct_decl|struct
name|iwm_rx_packet
struct_decl|;
end_struct_decl

begin_struct
struct|struct
name|iwm_host_cmd
block|{
specifier|const
name|void
modifier|*
name|data
index|[
name|IWM_MAX_CMD_TBS_PER_TFD
index|]
decl_stmt|;
name|struct
name|iwm_rx_packet
modifier|*
name|resp_pkt
decl_stmt|;
name|unsigned
name|long
name|_rx_page_addr
decl_stmt|;
name|uint32_t
name|_rx_page_order
decl_stmt|;
name|int
name|handler_status
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|uint32_t
name|id
decl_stmt|;
name|uint16_t
name|len
index|[
name|IWM_MAX_CMD_TBS_PER_TFD
index|]
decl_stmt|;
name|uint8_t
name|dataflags
index|[
name|IWM_MAX_CMD_TBS_PER_TFD
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * DMA glue is from iwn  */
end_comment

begin_typedef
typedef|typedef
name|caddr_t
name|iwm_caddr_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|void
modifier|*
name|iwm_hookarg_t
typedef|;
end_typedef

begin_struct
struct|struct
name|iwm_dma_info
block|{
name|bus_dma_tag_t
name|tag
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
name|bus_dma_segment_t
name|seg
decl_stmt|;
name|bus_addr_t
name|paddr
decl_stmt|;
name|void
modifier|*
name|vaddr
decl_stmt|;
name|bus_size_t
name|size
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/**  * struct iwm_fw_paging  * @fw_paging_block: dma memory info  * @fw_paging_size: page size  */
end_comment

begin_struct
struct|struct
name|iwm_fw_paging
block|{
name|struct
name|iwm_dma_info
name|fw_paging_block
decl_stmt|;
name|uint32_t
name|fw_paging_size
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|IWM_TX_RING_COUNT
value|256
end_define

begin_define
define|#
directive|define
name|IWM_TX_RING_LOMARK
value|192
end_define

begin_define
define|#
directive|define
name|IWM_TX_RING_HIMARK
value|224
end_define

begin_struct
struct|struct
name|iwm_tx_data
block|{
name|bus_dmamap_t
name|map
decl_stmt|;
name|bus_addr_t
name|cmd_paddr
decl_stmt|;
name|bus_addr_t
name|scratch_paddr
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|iwm_node
modifier|*
name|in
decl_stmt|;
name|int
name|done
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|iwm_tx_ring
block|{
name|struct
name|iwm_dma_info
name|desc_dma
decl_stmt|;
name|struct
name|iwm_dma_info
name|cmd_dma
decl_stmt|;
name|struct
name|iwm_tfd
modifier|*
name|desc
decl_stmt|;
name|struct
name|iwm_device_cmd
modifier|*
name|cmd
decl_stmt|;
name|bus_dma_tag_t
name|data_dmat
decl_stmt|;
name|struct
name|iwm_tx_data
name|data
index|[
name|IWM_TX_RING_COUNT
index|]
decl_stmt|;
name|int
name|qid
decl_stmt|;
name|int
name|queued
decl_stmt|;
name|int
name|cur
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|IWM_RX_RING_COUNT
value|256
end_define

begin_comment
comment|/* Linux driver optionally uses 8k buffer */
end_comment

begin_define
define|#
directive|define
name|IWM_RBUF_SIZE
value|4096
end_define

begin_define
define|#
directive|define
name|IWM_MAX_SCATTER
value|20
end_define

begin_struct
struct|struct
name|iwm_rx_data
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|iwm_rx_ring
block|{
name|struct
name|iwm_dma_info
name|desc_dma
decl_stmt|;
name|struct
name|iwm_dma_info
name|stat_dma
decl_stmt|;
name|struct
name|iwm_dma_info
name|buf_dma
decl_stmt|;
name|uint32_t
modifier|*
name|desc
decl_stmt|;
name|struct
name|iwm_rb_status
modifier|*
name|stat
decl_stmt|;
name|struct
name|iwm_rx_data
name|data
index|[
name|IWM_RX_RING_COUNT
index|]
decl_stmt|;
name|bus_dmamap_t
name|spare_map
decl_stmt|;
comment|/* for iwm_rx_addbuf() */
name|bus_dma_tag_t
name|data_dmat
decl_stmt|;
name|int
name|cur
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|IWM_CMD_RESP_MAX
value|PAGE_SIZE
end_define

begin_define
define|#
directive|define
name|IWM_MVM_TE_SESSION_PROTECTION_MAX_TIME_MS
value|500
end_define

begin_define
define|#
directive|define
name|IWM_MVM_TE_SESSION_PROTECTION_MIN_TIME_MS
value|400
end_define

begin_comment
comment|/*  * Command headers are in iwl-trans.h, which is full of all  * kinds of other junk, so we just replicate the structures here.  * First the software bits:  */
end_comment

begin_enum
enum|enum
name|IWM_CMD_MODE
block|{
name|IWM_CMD_SYNC
init|=
literal|0
block|,
name|IWM_CMD_ASYNC
init|=
operator|(
literal|1
operator|<<
literal|0
operator|)
block|,
name|IWM_CMD_WANT_SKB
init|=
operator|(
literal|1
operator|<<
literal|1
operator|)
block|,
name|IWM_CMD_SEND_IN_RFKILL
init|=
operator|(
literal|1
operator|<<
literal|2
operator|)
block|, }
enum|;
end_enum

begin_enum
enum|enum
name|iwm_hcmd_dataflag
block|{
name|IWM_HCMD_DFL_NOCOPY
init|=
operator|(
literal|1
operator|<<
literal|0
operator|)
block|,
name|IWM_HCMD_DFL_DUP
init|=
operator|(
literal|1
operator|<<
literal|1
operator|)
block|, }
enum|;
end_enum

begin_struct
struct|struct
name|iwm_int_sta
block|{
name|uint32_t
name|sta_id
decl_stmt|;
name|uint32_t
name|tfd_queue_msk
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|iwm_mvm_phy_ctxt
block|{
name|uint16_t
name|id
decl_stmt|;
name|uint16_t
name|color
decl_stmt|;
name|uint32_t
name|ref
decl_stmt|;
name|struct
name|ieee80211_channel
modifier|*
name|channel
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|iwm_bf_data
block|{
name|int
name|bf_enabled
decl_stmt|;
comment|/* filtering	*/
name|int
name|ba_enabled
decl_stmt|;
comment|/* abort	*/
name|int
name|ave_beacon_signal
decl_stmt|;
name|int
name|last_cqm_event
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|iwm_vap
block|{
name|struct
name|ieee80211vap
name|iv_vap
decl_stmt|;
name|int
name|is_uploaded
decl_stmt|;
name|int
function_decl|(
modifier|*
name|iv_newstate
function_decl|)
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
name|enum
name|ieee80211_state
parameter_list|,
name|int
parameter_list|)
function_decl|;
name|struct
name|iwm_mvm_phy_ctxt
modifier|*
name|phy_ctxt
decl_stmt|;
name|uint16_t
name|id
decl_stmt|;
name|uint16_t
name|color
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|IWM_VAP
parameter_list|(
name|_vap
parameter_list|)
value|((struct iwm_vap *)(_vap))
end_define

begin_struct
struct|struct
name|iwm_node
block|{
name|struct
name|ieee80211_node
name|in_ni
decl_stmt|;
comment|/* status "bits" */
name|int
name|in_assoc
decl_stmt|;
name|struct
name|iwm_lq_cmd
name|in_lq
decl_stmt|;
name|uint8_t
name|in_ridx
index|[
name|IEEE80211_RATE_MAXSIZE
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|IWM_NODE
parameter_list|(
name|_ni
parameter_list|)
value|((struct iwm_node *)(_ni))
end_define

begin_define
define|#
directive|define
name|IWM_STATION_ID
value|0
end_define

begin_define
define|#
directive|define
name|IWM_AUX_STA_ID
value|1
end_define

begin_define
define|#
directive|define
name|IWM_DEFAULT_MACID
value|0
end_define

begin_define
define|#
directive|define
name|IWM_DEFAULT_COLOR
value|0
end_define

begin_define
define|#
directive|define
name|IWM_DEFAULT_TSFID
value|0
end_define

begin_define
define|#
directive|define
name|IWM_ICT_SIZE
value|4096
end_define

begin_define
define|#
directive|define
name|IWM_ICT_COUNT
value|(IWM_ICT_SIZE / sizeof (uint32_t))
end_define

begin_define
define|#
directive|define
name|IWM_ICT_PADDR_SHIFT
value|12
end_define

begin_struct_decl
struct_decl|struct
name|iwm_cfg
struct_decl|;
end_struct_decl

begin_struct
struct|struct
name|iwm_softc
block|{
name|device_t
name|sc_dev
decl_stmt|;
name|uint32_t
name|sc_debug
decl_stmt|;
name|int
name|sc_attached
decl_stmt|;
name|struct
name|mtx
name|sc_mtx
decl_stmt|;
name|struct
name|mbufq
name|sc_snd
decl_stmt|;
name|struct
name|ieee80211com
name|sc_ic
decl_stmt|;
name|struct
name|ieee80211_ratectl_tx_status
name|sc_txs
decl_stmt|;
name|int
name|sc_flags
decl_stmt|;
define|#
directive|define
name|IWM_FLAG_USE_ICT
value|(1<< 0)
define|#
directive|define
name|IWM_FLAG_HW_INITED
value|(1<< 1)
define|#
directive|define
name|IWM_FLAG_STOPPED
value|(1<< 2)
define|#
directive|define
name|IWM_FLAG_RFKILL
value|(1<< 3)
define|#
directive|define
name|IWM_FLAG_BUSY
value|(1<< 4)
define|#
directive|define
name|IWM_FLAG_SCANNING
value|(1<< 5)
define|#
directive|define
name|IWM_FLAG_SCAN_RUNNING
value|(1<< 6)
name|struct
name|intr_config_hook
name|sc_preinit_hook
decl_stmt|;
name|struct
name|callout
name|sc_watchdog_to
decl_stmt|;
name|struct
name|callout
name|sc_led_blink_to
decl_stmt|;
name|struct
name|task
name|init_task
decl_stmt|;
name|struct
name|resource
modifier|*
name|sc_irq
decl_stmt|;
name|struct
name|resource
modifier|*
name|sc_mem
decl_stmt|;
name|bus_space_tag_t
name|sc_st
decl_stmt|;
name|bus_space_handle_t
name|sc_sh
decl_stmt|;
name|bus_size_t
name|sc_sz
decl_stmt|;
name|bus_dma_tag_t
name|sc_dmat
decl_stmt|;
name|void
modifier|*
name|sc_ih
decl_stmt|;
comment|/* TX scheduler rings. */
name|struct
name|iwm_dma_info
name|sched_dma
decl_stmt|;
name|uint32_t
name|scd_base_addr
decl_stmt|;
comment|/* TX/RX rings. */
name|struct
name|iwm_tx_ring
name|txq
index|[
name|IWM_MVM_MAX_QUEUES
index|]
decl_stmt|;
name|struct
name|iwm_rx_ring
name|rxq
decl_stmt|;
name|int
name|qfullmsk
decl_stmt|;
name|int
name|sc_sf_state
decl_stmt|;
comment|/* ICT table. */
name|struct
name|iwm_dma_info
name|ict_dma
decl_stmt|;
name|int
name|ict_cur
decl_stmt|;
name|int
name|sc_hw_rev
decl_stmt|;
name|int
name|sc_hw_id
decl_stmt|;
name|struct
name|iwm_dma_info
name|kw_dma
decl_stmt|;
name|struct
name|iwm_dma_info
name|fw_dma
decl_stmt|;
name|int
name|sc_fw_chunk_done
decl_stmt|;
name|enum
name|iwm_ucode_type
name|cur_ucode
decl_stmt|;
name|int
name|ucode_loaded
decl_stmt|;
name|char
name|sc_fwver
index|[
literal|32
index|]
decl_stmt|;
name|struct
name|iwm_ucode_capabilities
name|ucode_capa
decl_stmt|;
name|char
name|sc_fw_mcc
index|[
literal|3
index|]
decl_stmt|;
name|int
name|sc_intmask
decl_stmt|;
comment|/* 	 * So why do we need a separate stopped flag and a generation? 	 * the former protects the device from issuing commands when it's 	 * stopped (duh).  The latter protects against race from a very 	 * fast stop/unstop cycle where threads waiting for responses do 	 * not have a chance to run in between.  Notably: we want to stop 	 * the device from interrupt context when it craps out, so we 	 * don't have the luxury of waiting for quiescense. 	 */
name|int
name|sc_generation
decl_stmt|;
name|struct
name|iwm_fw_info
name|sc_fw
decl_stmt|;
name|struct
name|iwm_tlv_calib_ctrl
name|sc_default_calib
index|[
name|IWM_UCODE_TYPE_MAX
index|]
decl_stmt|;
specifier|const
name|struct
name|iwm_cfg
modifier|*
name|cfg
decl_stmt|;
name|struct
name|iwm_nvm_data
modifier|*
name|nvm_data
decl_stmt|;
name|struct
name|iwm_phy_db
modifier|*
name|sc_phy_db
decl_stmt|;
name|struct
name|iwm_bf_data
name|sc_bf
decl_stmt|;
name|int
name|sc_tx_timer
decl_stmt|;
name|int
name|sc_scan_last_antenna
decl_stmt|;
name|int
name|sc_fixed_ridx
decl_stmt|;
name|int
name|sc_staid
decl_stmt|;
name|int
name|sc_nodecolor
decl_stmt|;
name|uint8_t
name|sc_cmd_resp
index|[
name|IWM_CMD_RESP_MAX
index|]
decl_stmt|;
name|int
name|sc_wantresp
decl_stmt|;
name|struct
name|task
name|sc_es_task
decl_stmt|;
name|struct
name|iwm_rx_phy_info
name|sc_last_phy_info
decl_stmt|;
name|int
name|sc_ampdu_ref
decl_stmt|;
name|struct
name|iwm_int_sta
name|sc_aux_sta
decl_stmt|;
comment|/* phy contexts.  we only use the first one */
name|struct
name|iwm_mvm_phy_ctxt
name|sc_phyctxt
index|[
name|IWM_NUM_PHY_CTX
index|]
decl_stmt|;
name|struct
name|iwm_notif_statistics
name|sc_stats
decl_stmt|;
name|int
name|sc_noise
decl_stmt|;
name|caddr_t
name|sc_drvbpf
decl_stmt|;
name|struct
name|iwm_rx_radiotap_header
name|sc_rxtap
decl_stmt|;
name|struct
name|iwm_tx_radiotap_header
name|sc_txtap
decl_stmt|;
name|int
name|sc_max_rssi
decl_stmt|;
name|struct
name|iwm_notif_wait_data
modifier|*
name|sc_notif_wait
decl_stmt|;
name|int
name|cmd_hold_nic_awake
decl_stmt|;
comment|/* Firmware status */
name|uint32_t
name|error_event_table
decl_stmt|;
name|uint32_t
name|log_event_table
decl_stmt|;
name|uint32_t
name|umac_error_event_table
decl_stmt|;
name|int
name|support_umac_log
decl_stmt|;
comment|/* 	 * Paging parameters - All of the parameters should be set by the 	 * opmode when paging is enabled 	 */
name|struct
name|iwm_fw_paging
name|fw_paging_db
index|[
name|IWM_NUM_OF_FW_PAGING_BLOCKS
index|]
decl_stmt|;
name|uint16_t
name|num_of_paging_blk
decl_stmt|;
name|uint16_t
name|num_of_pages_in_last_blk
decl_stmt|;
name|boolean_t
name|last_ebs_successful
decl_stmt|;
comment|/* Indicate if device power save is allowed */
name|boolean_t
name|sc_ps_disabled
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|IWM_LOCK_INIT
parameter_list|(
name|_sc
parameter_list|)
define|\
value|mtx_init(&(_sc)->sc_mtx, device_get_nameunit((_sc)->sc_dev), \ 	    MTX_NETWORK_LOCK, MTX_DEF);
end_define

begin_define
define|#
directive|define
name|IWM_LOCK
parameter_list|(
name|_sc
parameter_list|)
value|mtx_lock(&(_sc)->sc_mtx)
end_define

begin_define
define|#
directive|define
name|IWM_UNLOCK
parameter_list|(
name|_sc
parameter_list|)
value|mtx_unlock(&(_sc)->sc_mtx)
end_define

begin_define
define|#
directive|define
name|IWM_LOCK_DESTROY
parameter_list|(
name|_sc
parameter_list|)
value|mtx_destroy(&(_sc)->sc_mtx)
end_define

end_unit

