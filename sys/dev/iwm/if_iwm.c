begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$OpenBSD: if_iwm.c,v 1.42 2015/05/30 02:49:23 deraadt Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 2014 genua mbh<info@genua.de>  * Copyright (c) 2014 Fixup Software Ltd.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/*-  * Based on BSD-licensed source modules in the Linux iwlwifi driver,  * which were used as the reference documentation for this implementation.  *  * Driver version we are currently based off of is  * Linux 3.14.3 (tag id a2df521e42b1d9a23f620ac79dbfe8655a8391dd)  *  ***********************************************************************  *  * This file is provided under a dual BSD/GPLv2 license.  When using or  * redistributing this file, you may do so under either license.  *  * GPL LICENSE SUMMARY  *  * Copyright(c) 2007 - 2013 Intel Corporation. All rights reserved.  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of version 2 of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it will be useful, but  * WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  * General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110,  * USA  *  * The full GNU General Public License is included in this distribution  * in the file called COPYING.  *  * Contact Information:  *  Intel Linux Wireless<ilw@linux.intel.com>  * Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497  *  *  * BSD LICENSE  *  * Copyright(c) 2005 - 2013 Intel Corporation. All rights reserved.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  *  * Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * Neither the name Intel Corporation nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2007-2010 Damien Bergamini<damien.bergamini@free.fr>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_wlan.h"
end_include

begin_include
include|#
directive|include
file|"opt_iwm.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/firmware.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/endian.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_regdomain.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_ratectl.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_radiotap.h>
end_include

begin_include
include|#
directive|include
file|<dev/iwm/if_iwmreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/iwm/if_iwmvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/iwm/if_iwm_config.h>
end_include

begin_include
include|#
directive|include
file|<dev/iwm/if_iwm_debug.h>
end_include

begin_include
include|#
directive|include
file|<dev/iwm/if_iwm_notif_wait.h>
end_include

begin_include
include|#
directive|include
file|<dev/iwm/if_iwm_util.h>
end_include

begin_include
include|#
directive|include
file|<dev/iwm/if_iwm_binding.h>
end_include

begin_include
include|#
directive|include
file|<dev/iwm/if_iwm_phy_db.h>
end_include

begin_include
include|#
directive|include
file|<dev/iwm/if_iwm_mac_ctxt.h>
end_include

begin_include
include|#
directive|include
file|<dev/iwm/if_iwm_phy_ctxt.h>
end_include

begin_include
include|#
directive|include
file|<dev/iwm/if_iwm_time_event.h>
end_include

begin_include
include|#
directive|include
file|<dev/iwm/if_iwm_power.h>
end_include

begin_include
include|#
directive|include
file|<dev/iwm/if_iwm_scan.h>
end_include

begin_include
include|#
directive|include
file|<dev/iwm/if_iwm_sf.h>
end_include

begin_include
include|#
directive|include
file|<dev/iwm/if_iwm_sta.h>
end_include

begin_include
include|#
directive|include
file|<dev/iwm/if_iwm_pcie_trans.h>
end_include

begin_include
include|#
directive|include
file|<dev/iwm/if_iwm_led.h>
end_include

begin_include
include|#
directive|include
file|<dev/iwm/if_iwm_fw.h>
end_include

begin_comment
comment|/* From DragonflyBSD */
end_comment

begin_define
define|#
directive|define
name|mtodoff
parameter_list|(
name|m
parameter_list|,
name|t
parameter_list|,
name|off
parameter_list|)
value|((t)((m)->m_data + (off)))
end_define

begin_decl_stmt
specifier|const
name|uint8_t
name|iwm_nvm_channels
index|[]
init|=
block|{
comment|/* 2.4 GHz */
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
comment|/* 5 GHz */
literal|36
block|,
literal|40
block|,
literal|44
block|,
literal|48
block|,
literal|52
block|,
literal|56
block|,
literal|60
block|,
literal|64
block|,
literal|100
block|,
literal|104
block|,
literal|108
block|,
literal|112
block|,
literal|116
block|,
literal|120
block|,
literal|124
block|,
literal|128
block|,
literal|132
block|,
literal|136
block|,
literal|140
block|,
literal|144
block|,
literal|149
block|,
literal|153
block|,
literal|157
block|,
literal|161
block|,
literal|165
block|}
decl_stmt|;
end_decl_stmt

begin_assert
assert|_Static_assert
argument_list|(
name|nitems
argument_list|(
name|iwm_nvm_channels
argument_list|)
operator|<=
name|IWM_NUM_CHANNELS
argument_list|,
literal|"IWM_NUM_CHANNELS is too small"
argument_list|)
assert|;
end_assert

begin_decl_stmt
specifier|const
name|uint8_t
name|iwm_nvm_channels_8000
index|[]
init|=
block|{
comment|/* 2.4 GHz */
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
comment|/* 5 GHz */
literal|36
block|,
literal|40
block|,
literal|44
block|,
literal|48
block|,
literal|52
block|,
literal|56
block|,
literal|60
block|,
literal|64
block|,
literal|68
block|,
literal|72
block|,
literal|76
block|,
literal|80
block|,
literal|84
block|,
literal|88
block|,
literal|92
block|,
literal|96
block|,
literal|100
block|,
literal|104
block|,
literal|108
block|,
literal|112
block|,
literal|116
block|,
literal|120
block|,
literal|124
block|,
literal|128
block|,
literal|132
block|,
literal|136
block|,
literal|140
block|,
literal|144
block|,
literal|149
block|,
literal|153
block|,
literal|157
block|,
literal|161
block|,
literal|165
block|,
literal|169
block|,
literal|173
block|,
literal|177
block|,
literal|181
block|}
decl_stmt|;
end_decl_stmt

begin_assert
assert|_Static_assert
argument_list|(
name|nitems
argument_list|(
name|iwm_nvm_channels_8000
argument_list|)
operator|<=
name|IWM_NUM_CHANNELS_8000
argument_list|,
literal|"IWM_NUM_CHANNELS_8000 is too small"
argument_list|)
assert|;
end_assert

begin_define
define|#
directive|define
name|IWM_NUM_2GHZ_CHANNELS
value|14
end_define

begin_define
define|#
directive|define
name|IWM_N_HW_ADDR_MASK
value|0xF
end_define

begin_comment
comment|/*  * XXX For now, there's simply a fixed set of rate table entries  * that are populated.  */
end_comment

begin_struct
specifier|const
struct|struct
name|iwm_rate
block|{
name|uint8_t
name|rate
decl_stmt|;
name|uint8_t
name|plcp
decl_stmt|;
block|}
name|iwm_rates
index|[]
init|=
block|{
block|{
literal|2
block|,
name|IWM_RATE_1M_PLCP
block|}
block|,
block|{
literal|4
block|,
name|IWM_RATE_2M_PLCP
block|}
block|,
block|{
literal|11
block|,
name|IWM_RATE_5M_PLCP
block|}
block|,
block|{
literal|22
block|,
name|IWM_RATE_11M_PLCP
block|}
block|,
block|{
literal|12
block|,
name|IWM_RATE_6M_PLCP
block|}
block|,
block|{
literal|18
block|,
name|IWM_RATE_9M_PLCP
block|}
block|,
block|{
literal|24
block|,
name|IWM_RATE_12M_PLCP
block|}
block|,
block|{
literal|36
block|,
name|IWM_RATE_18M_PLCP
block|}
block|,
block|{
literal|48
block|,
name|IWM_RATE_24M_PLCP
block|}
block|,
block|{
literal|72
block|,
name|IWM_RATE_36M_PLCP
block|}
block|,
block|{
literal|96
block|,
name|IWM_RATE_48M_PLCP
block|}
block|,
block|{
literal|108
block|,
name|IWM_RATE_54M_PLCP
block|}
block|, }
struct|;
end_struct

begin_define
define|#
directive|define
name|IWM_RIDX_CCK
value|0
end_define

begin_define
define|#
directive|define
name|IWM_RIDX_OFDM
value|4
end_define

begin_define
define|#
directive|define
name|IWM_RIDX_MAX
value|(nitems(iwm_rates)-1)
end_define

begin_define
define|#
directive|define
name|IWM_RIDX_IS_CCK
parameter_list|(
name|_i_
parameter_list|)
value|((_i_)< IWM_RIDX_OFDM)
end_define

begin_define
define|#
directive|define
name|IWM_RIDX_IS_OFDM
parameter_list|(
name|_i_
parameter_list|)
value|((_i_)>= IWM_RIDX_OFDM)
end_define

begin_struct
struct|struct
name|iwm_nvm_section
block|{
name|uint16_t
name|length
decl_stmt|;
name|uint8_t
modifier|*
name|data
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|IWM_MVM_UCODE_ALIVE_TIMEOUT
value|hz
end_define

begin_define
define|#
directive|define
name|IWM_MVM_UCODE_CALIB_TIMEOUT
value|(2*hz)
end_define

begin_struct
struct|struct
name|iwm_mvm_alive_data
block|{
name|int
name|valid
decl_stmt|;
name|uint32_t
name|scd_base_addr
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|iwm_store_cscheme
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
specifier|const
name|uint8_t
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_firmware_store_section
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|enum
name|iwm_ucode_type
parameter_list|,
specifier|const
name|uint8_t
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_set_default_calib
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_fw_info_free
parameter_list|(
name|struct
name|iwm_fw_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_read_firmware
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|enum
name|iwm_ucode_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_alloc_fwmem
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_alloc_sched
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_alloc_kw
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_alloc_ict
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_alloc_rx_ring
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|struct
name|iwm_rx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_reset_rx_ring
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|struct
name|iwm_rx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_free_rx_ring
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|struct
name|iwm_rx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_alloc_tx_ring
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|struct
name|iwm_tx_ring
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_reset_tx_ring
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|struct
name|iwm_tx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_free_tx_ring
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|struct
name|iwm_tx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_enable_interrupts
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_restore_interrupts
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_disable_interrupts
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_ict_reset
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_allow_mcast
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_stop_device
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_mvm_nic_config
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_nic_rx_init
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_nic_tx_init
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_nic_init
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_trans_pcie_fw_alive
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_nvm_read_chunk
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|uint16_t
parameter_list|,
name|uint16_t
parameter_list|,
name|uint16_t
parameter_list|,
name|uint8_t
modifier|*
parameter_list|,
name|uint16_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_nvm_read_section
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|uint16_t
parameter_list|,
name|uint8_t
modifier|*
parameter_list|,
name|uint16_t
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|iwm_eeprom_channel_flags
parameter_list|(
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_add_channel_band
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211_channel
type|[]
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|,
name|size_t
parameter_list|,
specifier|const
name|uint8_t
index|[]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_init_channel_map
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|,
name|struct
name|ieee80211_channel
type|[]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|iwm_nvm_data
modifier|*
name|iwm_parse_nvm_data
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
specifier|const
name|uint16_t
modifier|*
parameter_list|,
specifier|const
name|uint16_t
modifier|*
parameter_list|,
specifier|const
name|uint16_t
modifier|*
parameter_list|,
specifier|const
name|uint16_t
modifier|*
parameter_list|,
specifier|const
name|uint16_t
modifier|*
parameter_list|,
specifier|const
name|uint16_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_free_nvm_data
parameter_list|(
name|struct
name|iwm_nvm_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_set_hw_address_family_8000
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|struct
name|iwm_nvm_data
modifier|*
parameter_list|,
specifier|const
name|uint16_t
modifier|*
parameter_list|,
specifier|const
name|uint16_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_get_sku
parameter_list|(
specifier|const
name|struct
name|iwm_softc
modifier|*
parameter_list|,
specifier|const
name|uint16_t
modifier|*
parameter_list|,
specifier|const
name|uint16_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_get_nvm_version
parameter_list|(
specifier|const
name|struct
name|iwm_softc
modifier|*
parameter_list|,
specifier|const
name|uint16_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_get_radio_cfg
parameter_list|(
specifier|const
name|struct
name|iwm_softc
modifier|*
parameter_list|,
specifier|const
name|uint16_t
modifier|*
parameter_list|,
specifier|const
name|uint16_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_get_n_hw_addrs
parameter_list|(
specifier|const
name|struct
name|iwm_softc
modifier|*
parameter_list|,
specifier|const
name|uint16_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_set_radio_cfg
parameter_list|(
specifier|const
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|struct
name|iwm_nvm_data
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|iwm_nvm_data
modifier|*
name|iwm_parse_nvm_sections
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|struct
name|iwm_nvm_section
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_nvm_init
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_pcie_load_section
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
specifier|const
name|struct
name|iwm_fw_desc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_pcie_load_firmware_chunk
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|bus_addr_t
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_pcie_load_cpu_sections_8000
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|iwm_fw_sects
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_pcie_load_cpu_sections
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|iwm_fw_sects
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_pcie_load_given_ucode_8000
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|iwm_fw_sects
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_pcie_load_given_ucode
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|iwm_fw_sects
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_start_fw
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|iwm_fw_sects
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_send_tx_ant_cfg
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_send_phy_cfg_cmd
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_mvm_load_ucode_wait_alive
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|enum
name|iwm_ucode_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_run_init_mvm_ucode
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_rx_addbuf
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_mvm_get_signal_strength
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|struct
name|iwm_rx_phy_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_mvm_rx_rx_phy_cmd
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|struct
name|iwm_rx_packet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_get_noise
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|iwm_mvm_statistics_rx_non_phy
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean_t
name|iwm_mvm_rx_rx_mpdu
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|boolean_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_mvm_rx_tx_cmd_single
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|struct
name|iwm_rx_packet
modifier|*
parameter_list|,
name|struct
name|iwm_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_mvm_rx_tx_cmd
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|struct
name|iwm_rx_packet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_cmd_done
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|struct
name|iwm_rx_packet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void	iwm_update_sched(struct iwm_softc *, int, int, uint8_t,                                  uint16_t);
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
specifier|const
name|struct
name|iwm_rate
modifier|*
name|iwm_tx_fill_cmd
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|struct
name|iwm_node
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|iwm_tx_cmd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_tx
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_raw_xmit
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
specifier|const
name|struct
name|ieee80211_bpf_params
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_mvm_update_quotas
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|struct
name|iwm_vap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_auth
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_release
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|struct
name|iwm_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ieee80211_node
modifier|*
name|iwm_node_alloc
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
specifier|const
name|uint8_t
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_setrates
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|struct
name|iwm_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_newstate
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
name|enum
name|ieee80211_state
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_endscan_cb
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_send_bt_init_conf
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean_t
name|iwm_mvm_is_lar_supported
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean_t
name|iwm_mvm_is_wifi_mcc_supported
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_send_update_mcc_cmd
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_mvm_tt_tx_backoff
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_init_hw
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_init
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_start
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_stop
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_watchdog
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_parent
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|IWM_DEBUG
end_ifdef

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|iwm_desc_lookup
parameter_list|(
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_nic_error
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_nic_umac_error
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|iwm_handle_rxb
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_notif_intr
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_is_valid_ether_addr
parameter_list|(
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_preinit
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_detach_local
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_init_task
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_radiotap_attach
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ieee80211vap
modifier|*
name|iwm_vap_create
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|,
specifier|const
name|char
index|[
name|IFNAMSIZ
index|]
parameter_list|,
name|int
parameter_list|,
name|enum
name|ieee80211_opmode
parameter_list|,
name|int
parameter_list|,
specifier|const
name|uint8_t
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|uint8_t
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_vap_delete
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_scan_start
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_scan_end
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_update_mcast
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_set_channel
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_scan_curchan
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
parameter_list|,
name|unsigned
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_scan_mindwell
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|iwm_lar_disable
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.iwm.lar.disable"
argument_list|,
operator|&
name|iwm_lar_disable
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Firmware parser.  */
end_comment

begin_function
specifier|static
name|int
name|iwm_store_cscheme
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|data
parameter_list|,
name|size_t
name|dlen
parameter_list|)
block|{
specifier|const
name|struct
name|iwm_fw_cscheme_list
modifier|*
name|l
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|dlen
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|l
argument_list|)
operator|||
name|dlen
operator|<
sizeof|sizeof
argument_list|(
name|l
operator|->
name|size
argument_list|)
operator|+
name|l
operator|->
name|size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|l
operator|->
name|cs
argument_list|)
condition|)
return|return
name|EINVAL
return|;
comment|/* we don't actually store anything for now, always use s/w crypto */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_firmware_store_section
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|enum
name|iwm_ucode_type
name|type
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|data
parameter_list|,
name|size_t
name|dlen
parameter_list|)
block|{
name|struct
name|iwm_fw_sects
modifier|*
name|fws
decl_stmt|;
name|struct
name|iwm_fw_desc
modifier|*
name|fwone
decl_stmt|;
if|if
condition|(
name|type
operator|>=
name|IWM_UCODE_TYPE_MAX
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|dlen
operator|<
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
return|return
name|EINVAL
return|;
name|fws
operator|=
operator|&
name|sc
operator|->
name|sc_fw
operator|.
name|fw_sects
index|[
name|type
index|]
expr_stmt|;
if|if
condition|(
name|fws
operator|->
name|fw_count
operator|>=
name|IWM_UCODE_SECTION_MAX
condition|)
return|return
name|EINVAL
return|;
name|fwone
operator|=
operator|&
name|fws
operator|->
name|fw_sect
index|[
name|fws
operator|->
name|fw_count
index|]
expr_stmt|;
comment|/* first 32bit are device load offset */
name|memcpy
argument_list|(
operator|&
name|fwone
operator|->
name|offset
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* rest is data */
name|fwone
operator|->
name|data
operator|=
name|data
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|fwone
operator|->
name|len
operator|=
name|dlen
operator|-
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|fws
operator|->
name|fw_count
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|IWM_DEFAULT_SCAN_CHANNELS
value|40
end_define

begin_comment
comment|/* iwlwifi: iwl-drv.c */
end_comment

begin_struct
struct|struct
name|iwm_tlv_calib_data
block|{
name|uint32_t
name|ucode_type
decl_stmt|;
name|struct
name|iwm_tlv_calib_ctrl
name|calib
decl_stmt|;
block|}
name|__packed
struct|;
end_struct

begin_function
specifier|static
name|int
name|iwm_set_default_calib
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|)
block|{
specifier|const
name|struct
name|iwm_tlv_calib_data
modifier|*
name|def_calib
init|=
name|data
decl_stmt|;
name|uint32_t
name|ucode_type
init|=
name|le32toh
argument_list|(
name|def_calib
operator|->
name|ucode_type
argument_list|)
decl_stmt|;
if|if
condition|(
name|ucode_type
operator|>=
name|IWM_UCODE_TYPE_MAX
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Wrong ucode_type %u for default "
literal|"calibration.\n"
argument_list|,
name|ucode_type
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|sc
operator|->
name|sc_default_calib
index|[
name|ucode_type
index|]
operator|.
name|flow_trigger
operator|=
name|def_calib
operator|->
name|calib
operator|.
name|flow_trigger
expr_stmt|;
name|sc
operator|->
name|sc_default_calib
index|[
name|ucode_type
index|]
operator|.
name|event_trigger
operator|=
name|def_calib
operator|->
name|calib
operator|.
name|event_trigger
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_set_ucode_api_flags
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|data
parameter_list|,
name|struct
name|iwm_ucode_capabilities
modifier|*
name|capa
parameter_list|)
block|{
specifier|const
name|struct
name|iwm_ucode_api
modifier|*
name|ucode_api
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
name|data
decl_stmt|;
name|uint32_t
name|api_index
init|=
name|le32toh
argument_list|(
name|ucode_api
operator|->
name|api_index
argument_list|)
decl_stmt|;
name|uint32_t
name|api_flags
init|=
name|le32toh
argument_list|(
name|ucode_api
operator|->
name|api_flags
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|api_index
operator|>=
name|howmany
argument_list|(
name|IWM_NUM_UCODE_TLV_API
argument_list|,
literal|32
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"api flags index %d larger than supported by driver\n"
argument_list|,
name|api_index
argument_list|)
expr_stmt|;
comment|/* don't return an error so we can load FW that has more bits */
return|return
literal|0
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|api_flags
operator|&
operator|(
literal|1U
operator|<<
name|i
operator|)
condition|)
name|setbit
argument_list|(
name|capa
operator|->
name|enabled_api
argument_list|,
name|i
operator|+
literal|32
operator|*
name|api_index
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_set_ucode_capabilities
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|data
parameter_list|,
name|struct
name|iwm_ucode_capabilities
modifier|*
name|capa
parameter_list|)
block|{
specifier|const
name|struct
name|iwm_ucode_capa
modifier|*
name|ucode_capa
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
name|data
decl_stmt|;
name|uint32_t
name|api_index
init|=
name|le32toh
argument_list|(
name|ucode_capa
operator|->
name|api_index
argument_list|)
decl_stmt|;
name|uint32_t
name|api_flags
init|=
name|le32toh
argument_list|(
name|ucode_capa
operator|->
name|api_capa
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|api_index
operator|>=
name|howmany
argument_list|(
name|IWM_NUM_UCODE_TLV_CAPA
argument_list|,
literal|32
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"capa flags index %d larger than supported by driver\n"
argument_list|,
name|api_index
argument_list|)
expr_stmt|;
comment|/* don't return an error so we can load FW that has more bits */
return|return
literal|0
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|api_flags
operator|&
operator|(
literal|1U
operator|<<
name|i
operator|)
condition|)
name|setbit
argument_list|(
name|capa
operator|->
name|enabled_capa
argument_list|,
name|i
operator|+
literal|32
operator|*
name|api_index
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_fw_info_free
parameter_list|(
name|struct
name|iwm_fw_info
modifier|*
name|fw
parameter_list|)
block|{
name|firmware_put
argument_list|(
name|fw
operator|->
name|fw_fp
argument_list|,
name|FIRMWARE_UNLOAD
argument_list|)
expr_stmt|;
name|fw
operator|->
name|fw_fp
operator|=
name|NULL
expr_stmt|;
comment|/* don't touch fw->fw_status */
name|memset
argument_list|(
name|fw
operator|->
name|fw_sects
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|fw
operator|->
name|fw_sects
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_read_firmware
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|enum
name|iwm_ucode_type
name|ucode_type
parameter_list|)
block|{
name|struct
name|iwm_fw_info
modifier|*
name|fw
init|=
operator|&
name|sc
operator|->
name|sc_fw
decl_stmt|;
specifier|const
name|struct
name|iwm_tlv_ucode_header
modifier|*
name|uhdr
decl_stmt|;
specifier|const
name|struct
name|iwm_ucode_tlv
modifier|*
name|tlv
decl_stmt|;
name|struct
name|iwm_ucode_capabilities
modifier|*
name|capa
init|=
operator|&
name|sc
operator|->
name|ucode_capa
decl_stmt|;
name|enum
name|iwm_ucode_tlv_type
name|tlv_type
decl_stmt|;
specifier|const
name|struct
name|firmware
modifier|*
name|fwp
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|data
decl_stmt|;
name|uint32_t
name|tlv_len
decl_stmt|;
name|uint32_t
name|usniffer_img
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|tlv_data
decl_stmt|;
name|uint32_t
name|paging_mem_size
decl_stmt|;
name|int
name|num_of_cpus
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|size_t
name|len
decl_stmt|;
if|if
condition|(
name|fw
operator|->
name|fw_status
operator|==
name|IWM_FW_STATUS_DONE
operator|&&
name|ucode_type
operator|!=
name|IWM_UCODE_INIT
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|fw
operator|->
name|fw_status
operator|==
name|IWM_FW_STATUS_INPROGRESS
condition|)
name|msleep
argument_list|(
operator|&
name|sc
operator|->
name|sc_fw
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|0
argument_list|,
literal|"iwmfwp"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fw
operator|->
name|fw_status
operator|=
name|IWM_FW_STATUS_INPROGRESS
expr_stmt|;
if|if
condition|(
name|fw
operator|->
name|fw_fp
operator|!=
name|NULL
condition|)
name|iwm_fw_info_free
argument_list|(
name|fw
argument_list|)
expr_stmt|;
comment|/* 	 * Load firmware into driver memory. 	 * fw_fp will be set. 	 */
name|IWM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|fwp
operator|=
name|firmware_get
argument_list|(
name|sc
operator|->
name|cfg
operator|->
name|fw_name
argument_list|)
expr_stmt|;
name|IWM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not read firmware %s (error %d)\n"
argument_list|,
name|sc
operator|->
name|cfg
operator|->
name|fw_name
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|fw
operator|->
name|fw_fp
operator|=
name|fwp
expr_stmt|;
comment|/* (Re-)Initialize default values. */
name|capa
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|capa
operator|->
name|max_probe_length
operator|=
name|IWM_DEFAULT_MAX_PROBE_LENGTH
expr_stmt|;
name|capa
operator|->
name|n_scan_channels
operator|=
name|IWM_DEFAULT_SCAN_CHANNELS
expr_stmt|;
name|memset
argument_list|(
name|capa
operator|->
name|enabled_capa
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|capa
operator|->
name|enabled_capa
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|capa
operator|->
name|enabled_api
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|capa
operator|->
name|enabled_api
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sc
operator|->
name|sc_fw_mcc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_fw_mcc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Parse firmware contents 	 */
name|uhdr
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
name|fw
operator|->
name|fw_fp
operator|->
name|data
expr_stmt|;
if|if
condition|(
operator|*
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|fw
operator|->
name|fw_fp
operator|->
name|data
operator|!=
literal|0
operator|||
name|le32toh
argument_list|(
name|uhdr
operator|->
name|magic
argument_list|)
operator|!=
name|IWM_TLV_UCODE_MAGIC
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"invalid firmware %s\n"
argument_list|,
name|sc
operator|->
name|cfg
operator|->
name|fw_name
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|snprintf
argument_list|(
name|sc
operator|->
name|sc_fwver
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_fwver
argument_list|)
argument_list|,
literal|"%u.%u (API ver %u)"
argument_list|,
name|IWM_UCODE_MAJOR
argument_list|(
name|le32toh
argument_list|(
name|uhdr
operator|->
name|ver
argument_list|)
argument_list|)
argument_list|,
name|IWM_UCODE_MINOR
argument_list|(
name|le32toh
argument_list|(
name|uhdr
operator|->
name|ver
argument_list|)
argument_list|)
argument_list|,
name|IWM_UCODE_API
argument_list|(
name|le32toh
argument_list|(
name|uhdr
operator|->
name|ver
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|=
name|uhdr
operator|->
name|data
expr_stmt|;
name|len
operator|=
name|fw
operator|->
name|fw_fp
operator|->
name|datasize
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|uhdr
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|>=
sizeof|sizeof
argument_list|(
operator|*
name|tlv
argument_list|)
condition|)
block|{
name|len
operator|-=
sizeof|sizeof
argument_list|(
operator|*
name|tlv
argument_list|)
expr_stmt|;
name|tlv
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
name|data
expr_stmt|;
name|tlv_len
operator|=
name|le32toh
argument_list|(
name|tlv
operator|->
name|length
argument_list|)
expr_stmt|;
name|tlv_type
operator|=
name|le32toh
argument_list|(
name|tlv
operator|->
name|type
argument_list|)
expr_stmt|;
name|tlv_data
operator|=
name|tlv
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|tlv_len
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"firmware too short: %zu bytes\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|parse_out
goto|;
block|}
name|len
operator|-=
name|roundup2
argument_list|(
name|tlv_len
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|data
operator|+=
sizeof|sizeof
argument_list|(
name|tlv
argument_list|)
operator|+
name|roundup2
argument_list|(
name|tlv_len
argument_list|,
literal|4
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|int
operator|)
name|tlv_type
condition|)
block|{
case|case
name|IWM_UCODE_TLV_PROBE_MAX_LEN
case|:
if|if
condition|(
name|tlv_len
operator|!=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: PROBE_MAX_LEN (%d) != sizeof(uint32_t)\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|int
operator|)
name|tlv_len
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|parse_out
goto|;
block|}
name|capa
operator|->
name|max_probe_length
operator|=
name|le32_to_cpup
argument_list|(
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|tlv_data
argument_list|)
expr_stmt|;
comment|/* limit it to something sensible */
if|if
condition|(
name|capa
operator|->
name|max_probe_length
operator|>
name|IWM_SCAN_OFFLOAD_PROBE_REQ_SIZE
condition|)
block|{
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_FIRMWARE_TLV
argument_list|,
literal|"%s: IWM_UCODE_TLV_PROBE_MAX_LEN "
literal|"ridiculous\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|parse_out
goto|;
block|}
break|break;
case|case
name|IWM_UCODE_TLV_PAN
case|:
if|if
condition|(
name|tlv_len
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: IWM_UCODE_TLV_PAN: tlv_len (%d)> 0\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|int
operator|)
name|tlv_len
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|parse_out
goto|;
block|}
name|capa
operator|->
name|flags
operator||=
name|IWM_UCODE_TLV_FLAGS_PAN
expr_stmt|;
break|break;
case|case
name|IWM_UCODE_TLV_FLAGS
case|:
if|if
condition|(
name|tlv_len
operator|<
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: IWM_UCODE_TLV_FLAGS: tlv_len (%d)< sizeof(uint32_t)\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|int
operator|)
name|tlv_len
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|parse_out
goto|;
block|}
if|if
condition|(
name|tlv_len
operator|%
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: IWM_UCODE_TLV_FLAGS: tlv_len (%d) %% sizeof(uint32_t)\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|int
operator|)
name|tlv_len
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|parse_out
goto|;
block|}
comment|/* 			 * Apparently there can be many flags, but Linux driver 			 * parses only the first one, and so do we. 			 * 			 * XXX: why does this override IWM_UCODE_TLV_PAN? 			 * Intentional or a bug?  Observations from 			 * current firmware file: 			 *  1) TLV_PAN is parsed first 			 *  2) TLV_FLAGS contains TLV_FLAGS_PAN 			 * ==> this resets TLV_PAN to itself... hnnnk 			 */
name|capa
operator|->
name|flags
operator|=
name|le32_to_cpup
argument_list|(
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|tlv_data
argument_list|)
expr_stmt|;
break|break;
case|case
name|IWM_UCODE_TLV_CSCHEME
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_store_cscheme
argument_list|(
name|sc
argument_list|,
name|tlv_data
argument_list|,
name|tlv_len
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: iwm_store_cscheme(): returned %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|parse_out
goto|;
block|}
break|break;
case|case
name|IWM_UCODE_TLV_NUM_OF_CPU
case|:
if|if
condition|(
name|tlv_len
operator|!=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: IWM_UCODE_TLV_NUM_OF_CPU: tlv_len (%d) != sizeof(uint32_t)\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|int
operator|)
name|tlv_len
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|parse_out
goto|;
block|}
name|num_of_cpus
operator|=
name|le32_to_cpup
argument_list|(
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|tlv_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_of_cpus
operator|==
literal|2
condition|)
block|{
name|fw
operator|->
name|fw_sects
index|[
name|IWM_UCODE_REGULAR
index|]
operator|.
name|is_dual_cpus
operator|=
name|TRUE
expr_stmt|;
name|fw
operator|->
name|fw_sects
index|[
name|IWM_UCODE_INIT
index|]
operator|.
name|is_dual_cpus
operator|=
name|TRUE
expr_stmt|;
name|fw
operator|->
name|fw_sects
index|[
name|IWM_UCODE_WOWLAN
index|]
operator|.
name|is_dual_cpus
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|num_of_cpus
operator|>
literal|2
operator|)
operator|||
operator|(
name|num_of_cpus
operator|<
literal|1
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: Driver supports only 1 or 2 CPUs\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|parse_out
goto|;
block|}
break|break;
case|case
name|IWM_UCODE_TLV_SEC_RT
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_firmware_store_section
argument_list|(
name|sc
argument_list|,
name|IWM_UCODE_REGULAR
argument_list|,
name|tlv_data
argument_list|,
name|tlv_len
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: IWM_UCODE_REGULAR: iwm_firmware_store_section() failed; %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|parse_out
goto|;
block|}
break|break;
case|case
name|IWM_UCODE_TLV_SEC_INIT
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_firmware_store_section
argument_list|(
name|sc
argument_list|,
name|IWM_UCODE_INIT
argument_list|,
name|tlv_data
argument_list|,
name|tlv_len
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: IWM_UCODE_INIT: iwm_firmware_store_section() failed; %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|parse_out
goto|;
block|}
break|break;
case|case
name|IWM_UCODE_TLV_SEC_WOWLAN
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_firmware_store_section
argument_list|(
name|sc
argument_list|,
name|IWM_UCODE_WOWLAN
argument_list|,
name|tlv_data
argument_list|,
name|tlv_len
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: IWM_UCODE_WOWLAN: iwm_firmware_store_section() failed; %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|parse_out
goto|;
block|}
break|break;
case|case
name|IWM_UCODE_TLV_DEF_CALIB
case|:
if|if
condition|(
name|tlv_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|iwm_tlv_calib_data
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: IWM_UCODE_TLV_DEV_CALIB: tlv_len (%d)< sizeof(iwm_tlv_calib_data) (%d)\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|int
operator|)
name|tlv_len
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|iwm_tlv_calib_data
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|parse_out
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_set_default_calib
argument_list|(
name|sc
argument_list|,
name|tlv_data
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: iwm_set_default_calib() failed: %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|parse_out
goto|;
block|}
break|break;
case|case
name|IWM_UCODE_TLV_PHY_SKU
case|:
if|if
condition|(
name|tlv_len
operator|!=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: IWM_UCODE_TLV_PHY_SKU: tlv_len (%d)< sizeof(uint32_t)\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|int
operator|)
name|tlv_len
argument_list|)
expr_stmt|;
goto|goto
name|parse_out
goto|;
block|}
name|sc
operator|->
name|sc_fw
operator|.
name|phy_config
operator|=
name|le32_to_cpup
argument_list|(
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|tlv_data
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_fw
operator|.
name|valid_tx_ant
operator|=
operator|(
name|sc
operator|->
name|sc_fw
operator|.
name|phy_config
operator|&
name|IWM_FW_PHY_CFG_TX_CHAIN
operator|)
operator|>>
name|IWM_FW_PHY_CFG_TX_CHAIN_POS
expr_stmt|;
name|sc
operator|->
name|sc_fw
operator|.
name|valid_rx_ant
operator|=
operator|(
name|sc
operator|->
name|sc_fw
operator|.
name|phy_config
operator|&
name|IWM_FW_PHY_CFG_RX_CHAIN
operator|)
operator|>>
name|IWM_FW_PHY_CFG_RX_CHAIN_POS
expr_stmt|;
break|break;
case|case
name|IWM_UCODE_TLV_API_CHANGES_SET
case|:
block|{
if|if
condition|(
name|tlv_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|iwm_ucode_api
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|parse_out
goto|;
block|}
if|if
condition|(
name|iwm_set_ucode_api_flags
argument_list|(
name|sc
argument_list|,
name|tlv_data
argument_list|,
name|capa
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|parse_out
goto|;
block|}
break|break;
block|}
case|case
name|IWM_UCODE_TLV_ENABLED_CAPABILITIES
case|:
block|{
if|if
condition|(
name|tlv_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|iwm_ucode_capa
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|parse_out
goto|;
block|}
if|if
condition|(
name|iwm_set_ucode_capabilities
argument_list|(
name|sc
argument_list|,
name|tlv_data
argument_list|,
name|capa
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|parse_out
goto|;
block|}
break|break;
block|}
case|case
literal|48
case|:
comment|/* undocumented TLV */
case|case
name|IWM_UCODE_TLV_SDIO_ADMA_ADDR
case|:
case|case
name|IWM_UCODE_TLV_FW_GSCAN_CAPA
case|:
comment|/* ignore, not used by current driver */
break|break;
case|case
name|IWM_UCODE_TLV_SEC_RT_USNIFFER
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_firmware_store_section
argument_list|(
name|sc
argument_list|,
name|IWM_UCODE_REGULAR_USNIFFER
argument_list|,
name|tlv_data
argument_list|,
name|tlv_len
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|parse_out
goto|;
break|break;
case|case
name|IWM_UCODE_TLV_PAGING
case|:
if|if
condition|(
name|tlv_len
operator|!=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|parse_out
goto|;
block|}
name|paging_mem_size
operator|=
name|le32_to_cpup
argument_list|(
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|tlv_data
argument_list|)
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_FIRMWARE_TLV
argument_list|,
literal|"%s: Paging: paging enabled (size = %u bytes)\n"
argument_list|,
name|__func__
argument_list|,
name|paging_mem_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|paging_mem_size
operator|>
name|IWM_MAX_PAGING_IMAGE_SIZE
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: Paging: driver supports up to %u bytes for paging image\n"
argument_list|,
name|__func__
argument_list|,
name|IWM_MAX_PAGING_IMAGE_SIZE
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|paging_mem_size
operator|&
operator|(
name|IWM_FW_PAGING_SIZE
operator|-
literal|1
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: Paging: image isn't multiple %u\n"
argument_list|,
name|__func__
argument_list|,
name|IWM_FW_PAGING_SIZE
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|sc
operator|->
name|sc_fw
operator|.
name|fw_sects
index|[
name|IWM_UCODE_REGULAR
index|]
operator|.
name|paging_mem_size
operator|=
name|paging_mem_size
expr_stmt|;
name|usniffer_img
operator|=
name|IWM_UCODE_REGULAR_USNIFFER
expr_stmt|;
name|sc
operator|->
name|sc_fw
operator|.
name|fw_sects
index|[
name|usniffer_img
index|]
operator|.
name|paging_mem_size
operator|=
name|paging_mem_size
expr_stmt|;
break|break;
case|case
name|IWM_UCODE_TLV_N_SCAN_CHANNELS
case|:
if|if
condition|(
name|tlv_len
operator|!=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|parse_out
goto|;
block|}
name|capa
operator|->
name|n_scan_channels
operator|=
name|le32_to_cpup
argument_list|(
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|tlv_data
argument_list|)
expr_stmt|;
break|break;
case|case
name|IWM_UCODE_TLV_FW_VERSION
case|:
if|if
condition|(
name|tlv_len
operator|!=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
literal|3
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|parse_out
goto|;
block|}
name|snprintf
argument_list|(
name|sc
operator|->
name|sc_fwver
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_fwver
argument_list|)
argument_list|,
literal|"%d.%d.%d"
argument_list|,
name|le32toh
argument_list|(
operator|(
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|tlv_data
operator|)
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|le32toh
argument_list|(
operator|(
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|tlv_data
operator|)
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|le32toh
argument_list|(
operator|(
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|tlv_data
operator|)
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IWM_UCODE_TLV_FW_MEM_SEG
case|:
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: unknown firmware section %d, abort\n"
argument_list|,
name|__func__
argument_list|,
name|tlv_type
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|parse_out
goto|;
block|}
block|}
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"unhandled error"
operator|)
argument_list|)
expr_stmt|;
name|parse_out
label|:
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"firmware parse error %d, "
literal|"section type %d\n"
argument_list|,
name|error
argument_list|,
name|tlv_type
argument_list|)
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|error
condition|)
block|{
name|fw
operator|->
name|fw_status
operator|=
name|IWM_FW_STATUS_NONE
expr_stmt|;
if|if
condition|(
name|fw
operator|->
name|fw_fp
operator|!=
name|NULL
condition|)
name|iwm_fw_info_free
argument_list|(
name|fw
argument_list|)
expr_stmt|;
block|}
else|else
name|fw
operator|->
name|fw_status
operator|=
name|IWM_FW_STATUS_DONE
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|sc_fw
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * DMA resource routines  */
end_comment

begin_comment
comment|/* fwmem is used to load firmware onto the card */
end_comment

begin_function
specifier|static
name|int
name|iwm_alloc_fwmem
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Must be aligned on a 16-byte boundary. */
return|return
name|iwm_dma_contig_alloc
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
operator|&
name|sc
operator|->
name|fw_dma
argument_list|,
name|IWM_FH_MEM_TB_MAX_LENGTH
argument_list|,
literal|16
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* tx scheduler rings.  not used? */
end_comment

begin_function
specifier|static
name|int
name|iwm_alloc_sched
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* TX scheduler rings must be aligned on a 1KB boundary. */
return|return
name|iwm_dma_contig_alloc
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
operator|&
name|sc
operator|->
name|sched_dma
argument_list|,
name|nitems
argument_list|(
name|sc
operator|->
name|txq
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|iwm_agn_scd_bc_tbl
argument_list|)
argument_list|,
literal|1024
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* keep-warm page is used internally by the card.  see iwl-fh.h for more info */
end_comment

begin_function
specifier|static
name|int
name|iwm_alloc_kw
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return
name|iwm_dma_contig_alloc
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
operator|&
name|sc
operator|->
name|kw_dma
argument_list|,
literal|4096
argument_list|,
literal|4096
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* interrupt cause table */
end_comment

begin_function
specifier|static
name|int
name|iwm_alloc_ict
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return
name|iwm_dma_contig_alloc
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
operator|&
name|sc
operator|->
name|ict_dma
argument_list|,
name|IWM_ICT_SIZE
argument_list|,
literal|1
operator|<<
name|IWM_ICT_PADDR_SHIFT
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_alloc_rx_ring
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwm_rx_ring
modifier|*
name|ring
parameter_list|)
block|{
name|bus_size_t
name|size
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|ring
operator|->
name|cur
operator|=
literal|0
expr_stmt|;
comment|/* Allocate RX descriptors (256-byte aligned). */
name|size
operator|=
name|IWM_RX_RING_COUNT
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwm_dma_contig_alloc
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
operator|&
name|ring
operator|->
name|desc_dma
argument_list|,
name|size
argument_list|,
literal|256
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not allocate RX ring DMA memory\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ring
operator|->
name|desc
operator|=
name|ring
operator|->
name|desc_dma
operator|.
name|vaddr
expr_stmt|;
comment|/* Allocate RX status area (16-byte aligned). */
name|error
operator|=
name|iwm_dma_contig_alloc
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
operator|&
name|ring
operator|->
name|stat_dma
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ring
operator|->
name|stat
argument_list|)
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not allocate RX status DMA memory\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ring
operator|->
name|stat
operator|=
name|ring
operator|->
name|stat_dma
operator|.
name|vaddr
expr_stmt|;
comment|/* Create RX buffer DMA tag. */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|IWM_RBUF_SIZE
argument_list|,
literal|1
argument_list|,
name|IWM_RBUF_SIZE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|ring
operator|->
name|data_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not create RX buf DMA tag, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Allocate spare bus_dmamap_t for iwm_rx_addbuf() */
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
literal|0
argument_list|,
operator|&
name|ring
operator|->
name|spare_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not create RX buf DMA map, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 	 * Allocate and map RX buffers. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IWM_RX_RING_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|iwm_rx_data
modifier|*
name|data
init|=
operator|&
name|ring
operator|->
name|data
index|[
name|i
index|]
decl_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
literal|0
argument_list|,
operator|&
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not create RX buf DMA map, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|data
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_rx_addbuf
argument_list|(
name|sc
argument_list|,
name|IWM_RBUF_SIZE
argument_list|,
name|i
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|fail
goto|;
block|}
block|}
return|return
literal|0
return|;
name|fail
label|:
name|iwm_free_rx_ring
argument_list|(
name|sc
argument_list|,
name|ring
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_reset_rx_ring
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwm_rx_ring
modifier|*
name|ring
parameter_list|)
block|{
comment|/* Reset the ring state */
name|ring
operator|->
name|cur
operator|=
literal|0
expr_stmt|;
comment|/* 	 * The hw rx ring index in shared memory must also be cleared, 	 * otherwise the discrepancy can cause reprocessing chaos. 	 */
name|memset
argument_list|(
name|sc
operator|->
name|rxq
operator|.
name|stat
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
operator|->
name|rxq
operator|.
name|stat
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_free_rx_ring
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwm_rx_ring
modifier|*
name|ring
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|iwm_dma_contig_free
argument_list|(
operator|&
name|ring
operator|->
name|desc_dma
argument_list|)
expr_stmt|;
name|iwm_dma_contig_free
argument_list|(
operator|&
name|ring
operator|->
name|stat_dma
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IWM_RX_RING_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|iwm_rx_data
modifier|*
name|data
init|=
operator|&
name|ring
operator|->
name|data
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|data
operator|->
name|m
argument_list|)
expr_stmt|;
name|data
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|->
name|map
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
name|data
operator|->
name|map
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ring
operator|->
name|spare_map
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|ring
operator|->
name|spare_map
argument_list|)
expr_stmt|;
name|ring
operator|->
name|spare_map
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ring
operator|->
name|data_dmat
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|)
expr_stmt|;
name|ring
operator|->
name|data_dmat
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_alloc_tx_ring
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwm_tx_ring
modifier|*
name|ring
parameter_list|,
name|int
name|qid
parameter_list|)
block|{
name|bus_addr_t
name|paddr
decl_stmt|;
name|bus_size_t
name|size
decl_stmt|;
name|size_t
name|maxsize
decl_stmt|;
name|int
name|nsegments
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|ring
operator|->
name|qid
operator|=
name|qid
expr_stmt|;
name|ring
operator|->
name|queued
operator|=
literal|0
expr_stmt|;
name|ring
operator|->
name|cur
operator|=
literal|0
expr_stmt|;
comment|/* Allocate TX descriptors (256-byte aligned). */
name|size
operator|=
name|IWM_TX_RING_COUNT
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|iwm_tfd
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwm_dma_contig_alloc
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
operator|&
name|ring
operator|->
name|desc_dma
argument_list|,
name|size
argument_list|,
literal|256
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not allocate TX ring DMA memory\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ring
operator|->
name|desc
operator|=
name|ring
operator|->
name|desc_dma
operator|.
name|vaddr
expr_stmt|;
comment|/* 	 * We only use rings 0 through 9 (4 EDCA + cmd) so there is no need 	 * to allocate commands space for other rings. 	 */
if|if
condition|(
name|qid
operator|>
name|IWM_MVM_CMD_QUEUE
condition|)
return|return
literal|0
return|;
name|size
operator|=
name|IWM_TX_RING_COUNT
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|iwm_device_cmd
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwm_dma_contig_alloc
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
operator|&
name|ring
operator|->
name|cmd_dma
argument_list|,
name|size
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not allocate TX cmd DMA memory\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ring
operator|->
name|cmd
operator|=
name|ring
operator|->
name|cmd_dma
operator|.
name|vaddr
expr_stmt|;
comment|/* FW commands may require more mapped space than packets. */
if|if
condition|(
name|qid
operator|==
name|IWM_MVM_CMD_QUEUE
condition|)
block|{
name|maxsize
operator|=
name|IWM_RBUF_SIZE
expr_stmt|;
name|nsegments
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|maxsize
operator|=
name|MCLBYTES
expr_stmt|;
name|nsegments
operator|=
name|IWM_MAX_SCATTER
operator|-
literal|2
expr_stmt|;
block|}
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|maxsize
argument_list|,
name|nsegments
argument_list|,
name|maxsize
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|ring
operator|->
name|data_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not create TX buf DMA tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|paddr
operator|=
name|ring
operator|->
name|cmd_dma
operator|.
name|paddr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IWM_TX_RING_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|iwm_tx_data
modifier|*
name|data
init|=
operator|&
name|ring
operator|->
name|data
index|[
name|i
index|]
decl_stmt|;
name|data
operator|->
name|cmd_paddr
operator|=
name|paddr
expr_stmt|;
name|data
operator|->
name|scratch_paddr
operator|=
name|paddr
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|iwm_cmd_header
argument_list|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|iwm_tx_cmd
argument_list|,
name|scratch
argument_list|)
expr_stmt|;
name|paddr
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|iwm_device_cmd
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
literal|0
argument_list|,
operator|&
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not create TX buf DMA map\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
name|KASSERT
argument_list|(
name|paddr
operator|==
name|ring
operator|->
name|cmd_dma
operator|.
name|paddr
operator|+
name|size
argument_list|,
operator|(
literal|"invalid physical address"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|fail
label|:
name|iwm_free_tx_ring
argument_list|(
name|sc
argument_list|,
name|ring
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_reset_tx_ring
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwm_tx_ring
modifier|*
name|ring
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IWM_TX_RING_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|iwm_tx_data
modifier|*
name|data
init|=
operator|&
name|ring
operator|->
name|data
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|data
operator|->
name|m
argument_list|)
expr_stmt|;
name|data
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Clear TX descriptors. */
name|memset
argument_list|(
name|ring
operator|->
name|desc
argument_list|,
literal|0
argument_list|,
name|ring
operator|->
name|desc_dma
operator|.
name|size
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|desc_dma
operator|.
name|tag
argument_list|,
name|ring
operator|->
name|desc_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|qfullmsk
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|ring
operator|->
name|qid
operator|)
expr_stmt|;
name|ring
operator|->
name|queued
operator|=
literal|0
expr_stmt|;
name|ring
operator|->
name|cur
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ring
operator|->
name|qid
operator|==
name|IWM_MVM_CMD_QUEUE
operator|&&
name|sc
operator|->
name|cmd_hold_nic_awake
condition|)
name|iwm_pcie_clear_cmd_in_flight
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_free_tx_ring
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwm_tx_ring
modifier|*
name|ring
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|iwm_dma_contig_free
argument_list|(
operator|&
name|ring
operator|->
name|desc_dma
argument_list|)
expr_stmt|;
name|iwm_dma_contig_free
argument_list|(
operator|&
name|ring
operator|->
name|cmd_dma
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IWM_TX_RING_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|iwm_tx_data
modifier|*
name|data
init|=
operator|&
name|ring
operator|->
name|data
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|data
operator|->
name|m
argument_list|)
expr_stmt|;
name|data
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|->
name|map
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
name|data
operator|->
name|map
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ring
operator|->
name|data_dmat
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|)
expr_stmt|;
name|ring
operator|->
name|data_dmat
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * High-level hardware frobbing routines  */
end_comment

begin_function
specifier|static
name|void
name|iwm_enable_interrupts
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|sc_intmask
operator|=
name|IWM_CSR_INI_SET_MASK
expr_stmt|;
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_INT_MASK
argument_list|,
name|sc
operator|->
name|sc_intmask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_restore_interrupts
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_INT_MASK
argument_list|,
name|sc
operator|->
name|sc_intmask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_disable_interrupts
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* disable interrupts */
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_INT_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* acknowledge all interrupts */
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_INT
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_FH_INT_STATUS
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_ict_reset
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|iwm_disable_interrupts
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Reset ICT table. */
name|memset
argument_list|(
name|sc
operator|->
name|ict_dma
operator|.
name|vaddr
argument_list|,
literal|0
argument_list|,
name|IWM_ICT_SIZE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ict_cur
operator|=
literal|0
expr_stmt|;
comment|/* Set physical address of ICT table (4KB aligned). */
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_DRAM_INT_TBL_REG
argument_list|,
name|IWM_CSR_DRAM_INT_TBL_ENABLE
operator||
name|IWM_CSR_DRAM_INIT_TBL_WRITE_POINTER
operator||
name|IWM_CSR_DRAM_INIT_TBL_WRAP_CHECK
operator||
name|sc
operator|->
name|ict_dma
operator|.
name|paddr
operator|>>
name|IWM_ICT_PADDR_SHIFT
argument_list|)
expr_stmt|;
comment|/* Switch to ICT interrupt mode in driver. */
name|sc
operator|->
name|sc_flags
operator||=
name|IWM_FLAG_USE_ICT
expr_stmt|;
comment|/* Re-enable interrupts. */
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_INT
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
name|iwm_enable_interrupts
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* iwlwifi pcie/trans.c */
end_comment

begin_comment
comment|/*  * Since this .. hard-resets things, it's time to actually  * mark the first vap (if any) as having no mac context.  * It's annoying, but since the driver is potentially being  * stop/start'ed whilst active (thanks openbsd port!) we  * have to correctly track this.  */
end_comment

begin_function
specifier|static
name|void
name|iwm_stop_device
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
decl_stmt|;
name|int
name|chnl
decl_stmt|,
name|qid
decl_stmt|;
name|uint32_t
name|mask
init|=
literal|0
decl_stmt|;
comment|/* tell the device to stop sending interrupts */
name|iwm_disable_interrupts
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * FreeBSD-local: mark the first vap as not-uploaded, 	 * so the next transition through auth/assoc 	 * will correctly populate the MAC context. 	 */
if|if
condition|(
name|vap
condition|)
block|{
name|struct
name|iwm_vap
modifier|*
name|iv
init|=
name|IWM_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|iv
operator|->
name|phy_ctxt
operator|=
name|NULL
expr_stmt|;
name|iv
operator|->
name|is_uploaded
operator|=
literal|0
expr_stmt|;
block|}
comment|/* device going down, Stop using ICT table */
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|IWM_FLAG_USE_ICT
expr_stmt|;
comment|/* stop tx and rx.  tx and rx bits, as usual, are from if_iwn */
if|if
condition|(
name|iwm_nic_lock
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|iwm_write_prph
argument_list|(
name|sc
argument_list|,
name|IWM_SCD_TXFACT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Stop each Tx DMA channel */
for|for
control|(
name|chnl
operator|=
literal|0
init|;
name|chnl
operator|<
name|IWM_FH_TCSR_CHNL_NUM
condition|;
name|chnl
operator|++
control|)
block|{
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_FH_TCSR_CHNL_TX_CONFIG_REG
argument_list|(
name|chnl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mask
operator||=
name|IWM_FH_TSSR_TX_STATUS_REG_MSK_CHNL_IDLE
argument_list|(
name|chnl
argument_list|)
expr_stmt|;
block|}
comment|/* Wait for DMA channels to be idle */
if|if
condition|(
operator|!
name|iwm_poll_bit
argument_list|(
name|sc
argument_list|,
name|IWM_FH_TSSR_TX_STATUS_REG
argument_list|,
name|mask
argument_list|,
name|mask
argument_list|,
literal|5000
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Failing on timeout while stopping DMA channel: [0x%08x]\n"
argument_list|,
name|IWM_READ
argument_list|(
name|sc
argument_list|,
name|IWM_FH_TSSR_TX_STATUS_REG
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|iwm_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|iwm_pcie_rx_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Stop RX ring. */
name|iwm_reset_rx_ring
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rxq
argument_list|)
expr_stmt|;
comment|/* Reset all TX rings. */
for|for
control|(
name|qid
operator|=
literal|0
init|;
name|qid
operator|<
name|nitems
argument_list|(
name|sc
operator|->
name|txq
argument_list|)
condition|;
name|qid
operator|++
control|)
name|iwm_reset_tx_ring
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|txq
index|[
name|qid
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|cfg
operator|->
name|device_family
operator|==
name|IWM_DEVICE_FAMILY_7000
condition|)
block|{
comment|/* Power-down device's busmaster DMA clocks */
if|if
condition|(
name|iwm_nic_lock
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|iwm_write_prph
argument_list|(
name|sc
argument_list|,
name|IWM_APMG_CLK_DIS_REG
argument_list|,
name|IWM_APMG_CLK_VAL_DMA_CLK_RQT
argument_list|)
expr_stmt|;
name|iwm_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure (redundant) we've released our request to stay awake */
name|IWM_CLRBITS
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_GP_CNTRL
argument_list|,
name|IWM_CSR_GP_CNTRL_REG_FLAG_MAC_ACCESS_REQ
argument_list|)
expr_stmt|;
comment|/* Stop the device, and put it in low power state */
name|iwm_apm_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Upon stop, the APM issues an interrupt if HW RF kill is set. 	 * Clean again the interrupt here 	 */
name|iwm_disable_interrupts
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* stop and reset the on-board processor */
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_RESET
argument_list|,
name|IWM_CSR_RESET_REG_FLAG_SW_RESET
argument_list|)
expr_stmt|;
comment|/* 	 * Even if we stop the HW, we still want the RF kill 	 * interrupt 	 */
name|iwm_enable_rfkill_int
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iwm_check_rfkill
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* iwlwifi: mvm/ops.c */
end_comment

begin_function
specifier|static
name|void
name|iwm_mvm_nic_config
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint8_t
name|radio_cfg_type
decl_stmt|,
name|radio_cfg_step
decl_stmt|,
name|radio_cfg_dash
decl_stmt|;
name|uint32_t
name|reg_val
init|=
literal|0
decl_stmt|;
name|uint32_t
name|phy_config
init|=
name|iwm_mvm_get_phy_config
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|radio_cfg_type
operator|=
operator|(
name|phy_config
operator|&
name|IWM_FW_PHY_CFG_RADIO_TYPE
operator|)
operator|>>
name|IWM_FW_PHY_CFG_RADIO_TYPE_POS
expr_stmt|;
name|radio_cfg_step
operator|=
operator|(
name|phy_config
operator|&
name|IWM_FW_PHY_CFG_RADIO_STEP
operator|)
operator|>>
name|IWM_FW_PHY_CFG_RADIO_STEP_POS
expr_stmt|;
name|radio_cfg_dash
operator|=
operator|(
name|phy_config
operator|&
name|IWM_FW_PHY_CFG_RADIO_DASH
operator|)
operator|>>
name|IWM_FW_PHY_CFG_RADIO_DASH_POS
expr_stmt|;
comment|/* SKU control */
name|reg_val
operator||=
name|IWM_CSR_HW_REV_STEP
argument_list|(
name|sc
operator|->
name|sc_hw_rev
argument_list|)
operator|<<
name|IWM_CSR_HW_IF_CONFIG_REG_POS_MAC_STEP
expr_stmt|;
name|reg_val
operator||=
name|IWM_CSR_HW_REV_DASH
argument_list|(
name|sc
operator|->
name|sc_hw_rev
argument_list|)
operator|<<
name|IWM_CSR_HW_IF_CONFIG_REG_POS_MAC_DASH
expr_stmt|;
comment|/* radio configuration */
name|reg_val
operator||=
name|radio_cfg_type
operator|<<
name|IWM_CSR_HW_IF_CONFIG_REG_POS_PHY_TYPE
expr_stmt|;
name|reg_val
operator||=
name|radio_cfg_step
operator|<<
name|IWM_CSR_HW_IF_CONFIG_REG_POS_PHY_STEP
expr_stmt|;
name|reg_val
operator||=
name|radio_cfg_dash
operator|<<
name|IWM_CSR_HW_IF_CONFIG_REG_POS_PHY_DASH
expr_stmt|;
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_HW_IF_CONFIG_REG
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_RESET
argument_list|,
literal|"Radio type=0x%x-0x%x-0x%x\n"
argument_list|,
name|radio_cfg_type
argument_list|,
name|radio_cfg_step
argument_list|,
name|radio_cfg_dash
argument_list|)
expr_stmt|;
comment|/* 	 * W/A : NIC is stuck in a reset state after Early PCIe power off 	 * (PCIe power is lost before PERST# is asserted), causing ME FW 	 * to lose ownership and not being able to obtain it back. 	 */
if|if
condition|(
name|sc
operator|->
name|cfg
operator|->
name|device_family
operator|==
name|IWM_DEVICE_FAMILY_7000
condition|)
block|{
name|iwm_set_bits_mask_prph
argument_list|(
name|sc
argument_list|,
name|IWM_APMG_PS_CTRL_REG
argument_list|,
name|IWM_APMG_PS_CTRL_EARLY_PWR_OFF_RESET_DIS
argument_list|,
operator|~
name|IWM_APMG_PS_CTRL_EARLY_PWR_OFF_RESET_DIS
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_nic_rx_init
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* 	 * Initialize RX ring.  This is from the iwn driver. 	 */
name|memset
argument_list|(
name|sc
operator|->
name|rxq
operator|.
name|stat
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
operator|->
name|rxq
operator|.
name|stat
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Stop Rx DMA */
name|iwm_pcie_rx_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iwm_nic_lock
argument_list|(
name|sc
argument_list|)
condition|)
return|return
name|EBUSY
return|;
comment|/* reset and flush pointers */
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_FH_MEM_RCSR_CHNL0_RBDCB_WPTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_FH_MEM_RCSR_CHNL0_FLUSH_RB_REQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_FH_RSCSR_CHNL0_RDPTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_FH_RSCSR_CHNL0_RBDCB_WPTR_REG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set physical address of RX ring (256-byte aligned). */
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_FH_RSCSR_CHNL0_RBDCB_BASE_REG
argument_list|,
name|sc
operator|->
name|rxq
operator|.
name|desc_dma
operator|.
name|paddr
operator|>>
literal|8
argument_list|)
expr_stmt|;
comment|/* Set physical address of RX status (16-byte aligned). */
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_FH_RSCSR_CHNL0_STTS_WPTR_REG
argument_list|,
name|sc
operator|->
name|rxq
operator|.
name|stat_dma
operator|.
name|paddr
operator|>>
literal|4
argument_list|)
expr_stmt|;
comment|/* Enable Rx DMA 	 * XXX 5000 HW isn't supported by the iwm(4) driver. 	 * IWM_FH_RCSR_CHNL0_RX_IGNORE_RXF_EMPTY is set because of HW bug in 	 *      the credit mechanism in 5000 HW RX FIFO 	 * Direct rx interrupts to hosts 	 * Rx buffer size 4 or 8k or 12k 	 * RB timeout 0x10 	 * 256 RBDs 	 */
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_FH_MEM_RCSR_CHNL0_CONFIG_REG
argument_list|,
name|IWM_FH_RCSR_RX_CONFIG_CHNL_EN_ENABLE_VAL
operator||
name|IWM_FH_RCSR_CHNL0_RX_IGNORE_RXF_EMPTY
operator||
comment|/* HW bug */
name|IWM_FH_RCSR_CHNL0_RX_CONFIG_IRQ_DEST_INT_HOST_VAL
operator||
name|IWM_FH_RCSR_RX_CONFIG_REG_VAL_RB_SIZE_4K
operator||
operator|(
name|IWM_RX_RB_TIMEOUT
operator|<<
name|IWM_FH_RCSR_RX_CONFIG_REG_IRQ_RBTH_POS
operator|)
operator||
name|IWM_RX_QUEUE_SIZE_LOG
operator|<<
name|IWM_FH_RCSR_RX_CONFIG_RBDCB_SIZE_POS
argument_list|)
expr_stmt|;
name|IWM_WRITE_1
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_INT_COALESCING
argument_list|,
name|IWM_HOST_INT_TIMEOUT_DEF
argument_list|)
expr_stmt|;
comment|/* W/A for interrupt coalescing bug in 7260 and 3160 */
if|if
condition|(
name|sc
operator|->
name|cfg
operator|->
name|host_interrupt_operation_mode
condition|)
name|IWM_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_INT_COALESCING
argument_list|,
name|IWM_HOST_INT_OPER_MODE
argument_list|)
expr_stmt|;
comment|/* 	 * Thus sayeth el jefe (iwlwifi) via a comment: 	 * 	 * This value should initially be 0 (before preparing any 	 * RBs), should be 8 after preparing the first 8 RBs (for example) 	 */
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_FH_RSCSR_CHNL0_WPTR
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|iwm_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_nic_tx_init
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|qid
decl_stmt|;
if|if
condition|(
operator|!
name|iwm_nic_lock
argument_list|(
name|sc
argument_list|)
condition|)
return|return
name|EBUSY
return|;
comment|/* Deactivate TX scheduler. */
name|iwm_write_prph
argument_list|(
name|sc
argument_list|,
name|IWM_SCD_TXFACT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set physical address of "keep warm" page (16-byte aligned). */
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_FH_KW_MEM_ADDR_REG
argument_list|,
name|sc
operator|->
name|kw_dma
operator|.
name|paddr
operator|>>
literal|4
argument_list|)
expr_stmt|;
comment|/* Initialize TX rings. */
for|for
control|(
name|qid
operator|=
literal|0
init|;
name|qid
operator|<
name|nitems
argument_list|(
name|sc
operator|->
name|txq
argument_list|)
condition|;
name|qid
operator|++
control|)
block|{
name|struct
name|iwm_tx_ring
modifier|*
name|txq
init|=
operator|&
name|sc
operator|->
name|txq
index|[
name|qid
index|]
decl_stmt|;
comment|/* Set physical address of TX ring (256-byte aligned). */
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_FH_MEM_CBBC_QUEUE
argument_list|(
name|qid
argument_list|)
argument_list|,
name|txq
operator|->
name|desc_dma
operator|.
name|paddr
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_XMIT
argument_list|,
literal|"%s: loading ring %d descriptors (%p) at %lx\n"
argument_list|,
name|__func__
argument_list|,
name|qid
argument_list|,
name|txq
operator|->
name|desc
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|txq
operator|->
name|desc_dma
operator|.
name|paddr
operator|>>
literal|8
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|iwm_write_prph
argument_list|(
name|sc
argument_list|,
name|IWM_SCD_GP_CTRL
argument_list|,
name|IWM_SCD_GP_CTRL_AUTO_ACTIVE_MODE
argument_list|)
expr_stmt|;
name|iwm_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_nic_init
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|iwm_apm_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|cfg
operator|->
name|device_family
operator|==
name|IWM_DEVICE_FAMILY_7000
condition|)
name|iwm_set_pwr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iwm_mvm_nic_config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_nic_rx_init
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
comment|/* 	 * Ditto for TX, from iwn 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_nic_tx_init
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_RESET
argument_list|,
literal|"%s: shadow registers enabled\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|IWM_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_MAC_SHADOW_REG_CTRL
argument_list|,
literal|0x800fffff
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|iwm_enable_txq
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|int
name|sta_id
parameter_list|,
name|int
name|qid
parameter_list|,
name|int
name|fifo
parameter_list|)
block|{
if|if
condition|(
operator|!
name|iwm_nic_lock
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: cannot enable txq %d\n"
argument_list|,
name|__func__
argument_list|,
name|qid
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_HBUS_TARG_WRPTR
argument_list|,
name|qid
operator|<<
literal|8
operator||
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|qid
operator|==
name|IWM_MVM_CMD_QUEUE
condition|)
block|{
comment|/* unactivate before configuration */
name|iwm_write_prph
argument_list|(
name|sc
argument_list|,
name|IWM_SCD_QUEUE_STATUS_BITS
argument_list|(
name|qid
argument_list|)
argument_list|,
operator|(
literal|0
operator|<<
name|IWM_SCD_QUEUE_STTS_REG_POS_ACTIVE
operator|)
operator||
operator|(
literal|1
operator|<<
name|IWM_SCD_QUEUE_STTS_REG_POS_SCD_ACT_EN
operator|)
argument_list|)
expr_stmt|;
name|iwm_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iwm_clear_bits_prph
argument_list|(
name|sc
argument_list|,
name|IWM_SCD_AGGR_SEL
argument_list|,
operator|(
literal|1
operator|<<
name|qid
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iwm_nic_lock
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: cannot enable txq %d\n"
argument_list|,
name|__func__
argument_list|,
name|qid
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
name|iwm_write_prph
argument_list|(
name|sc
argument_list|,
name|IWM_SCD_QUEUE_RDPTR
argument_list|(
name|qid
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iwm_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iwm_write_mem32
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|scd_base_addr
operator|+
name|IWM_SCD_CONTEXT_QUEUE_OFFSET
argument_list|(
name|qid
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set scheduler window size and frame limit. */
name|iwm_write_mem32
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|scd_base_addr
operator|+
name|IWM_SCD_CONTEXT_QUEUE_OFFSET
argument_list|(
name|qid
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
operator|(
operator|(
name|IWM_FRAME_LIMIT
operator|<<
name|IWM_SCD_QUEUE_CTX_REG2_WIN_SIZE_POS
operator|)
operator|&
name|IWM_SCD_QUEUE_CTX_REG2_WIN_SIZE_MSK
operator|)
operator||
operator|(
operator|(
name|IWM_FRAME_LIMIT
operator|<<
name|IWM_SCD_QUEUE_CTX_REG2_FRAME_LIMIT_POS
operator|)
operator|&
name|IWM_SCD_QUEUE_CTX_REG2_FRAME_LIMIT_MSK
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iwm_nic_lock
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: cannot enable txq %d\n"
argument_list|,
name|__func__
argument_list|,
name|qid
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
name|iwm_write_prph
argument_list|(
name|sc
argument_list|,
name|IWM_SCD_QUEUE_STATUS_BITS
argument_list|(
name|qid
argument_list|)
argument_list|,
operator|(
literal|1
operator|<<
name|IWM_SCD_QUEUE_STTS_REG_POS_ACTIVE
operator|)
operator||
operator|(
name|fifo
operator|<<
name|IWM_SCD_QUEUE_STTS_REG_POS_TXF
operator|)
operator||
operator|(
literal|1
operator|<<
name|IWM_SCD_QUEUE_STTS_REG_POS_WSL
operator|)
operator||
name|IWM_SCD_QUEUE_STTS_REG_MSK
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|iwm_scd_txq_cfg_cmd
name|cmd
decl_stmt|;
name|int
name|error
decl_stmt|;
name|iwm_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|scd_queue
operator|=
name|qid
expr_stmt|;
name|cmd
operator|.
name|enable
operator|=
literal|1
expr_stmt|;
name|cmd
operator|.
name|sta_id
operator|=
name|sta_id
expr_stmt|;
name|cmd
operator|.
name|tx_fifo
operator|=
name|fifo
expr_stmt|;
name|cmd
operator|.
name|aggregate
operator|=
literal|0
expr_stmt|;
name|cmd
operator|.
name|window
operator|=
name|IWM_FRAME_LIMIT
expr_stmt|;
name|error
operator|=
name|iwm_mvm_send_cmd_pdu
argument_list|(
name|sc
argument_list|,
name|IWM_SCD_QUEUE_CFG
argument_list|,
name|IWM_CMD_SYNC
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot enable txq %d\n"
argument_list|,
name|qid
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
operator|!
name|iwm_nic_lock
argument_list|(
name|sc
argument_list|)
condition|)
return|return
name|EBUSY
return|;
block|}
name|iwm_write_prph
argument_list|(
name|sc
argument_list|,
name|IWM_SCD_EN_CTRL
argument_list|,
name|iwm_read_prph
argument_list|(
name|sc
argument_list|,
name|IWM_SCD_EN_CTRL
argument_list|)
operator||
name|qid
argument_list|)
expr_stmt|;
name|iwm_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_XMIT
argument_list|,
literal|"%s: enabled txq %d FIFO %d\n"
argument_list|,
name|__func__
argument_list|,
name|qid
argument_list|,
name|fifo
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_trans_pcie_fw_alive
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|scd_base_addr
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|chnl
decl_stmt|;
name|int
name|clear_dwords
init|=
operator|(
name|IWM_SCD_TRANS_TBL_MEM_UPPER_BOUND
operator|-
name|IWM_SCD_CONTEXT_MEM_LOWER_BOUND
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|iwm_nic_lock
argument_list|(
name|sc
argument_list|)
condition|)
return|return
name|EBUSY
return|;
name|iwm_ict_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|scd_base_addr
operator|=
name|iwm_read_prph
argument_list|(
name|sc
argument_list|,
name|IWM_SCD_SRAM_BASE_ADDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|scd_base_addr
operator|!=
literal|0
operator|&&
name|scd_base_addr
operator|!=
name|sc
operator|->
name|scd_base_addr
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: sched addr mismatch: alive: 0x%x prph: 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|scd_base_addr
argument_list|,
name|scd_base_addr
argument_list|)
expr_stmt|;
block|}
name|iwm_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* reset context data, TX status and translation data */
name|error
operator|=
name|iwm_write_mem
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|scd_base_addr
operator|+
name|IWM_SCD_CONTEXT_MEM_LOWER_BOUND
argument_list|,
name|NULL
argument_list|,
name|clear_dwords
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|EBUSY
return|;
if|if
condition|(
operator|!
name|iwm_nic_lock
argument_list|(
name|sc
argument_list|)
condition|)
return|return
name|EBUSY
return|;
comment|/* Set physical address of TX scheduler rings (1KB aligned). */
name|iwm_write_prph
argument_list|(
name|sc
argument_list|,
name|IWM_SCD_DRAM_BASE_ADDR
argument_list|,
name|sc
operator|->
name|sched_dma
operator|.
name|paddr
operator|>>
literal|10
argument_list|)
expr_stmt|;
name|iwm_write_prph
argument_list|(
name|sc
argument_list|,
name|IWM_SCD_CHAINEXT_EN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iwm_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* enable command channel */
name|error
operator|=
name|iwm_enable_txq
argument_list|(
name|sc
argument_list|,
literal|0
comment|/* unused */
argument_list|,
name|IWM_MVM_CMD_QUEUE
argument_list|,
literal|7
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|!
name|iwm_nic_lock
argument_list|(
name|sc
argument_list|)
condition|)
return|return
name|EBUSY
return|;
name|iwm_write_prph
argument_list|(
name|sc
argument_list|,
name|IWM_SCD_TXFACT
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* Enable DMA channels. */
for|for
control|(
name|chnl
operator|=
literal|0
init|;
name|chnl
operator|<
name|IWM_FH_TCSR_CHNL_NUM
condition|;
name|chnl
operator|++
control|)
block|{
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_FH_TCSR_CHNL_TX_CONFIG_REG
argument_list|(
name|chnl
argument_list|)
argument_list|,
name|IWM_FH_TCSR_TX_CONFIG_REG_VAL_DMA_CHNL_ENABLE
operator||
name|IWM_FH_TCSR_TX_CONFIG_REG_VAL_DMA_CREDIT_ENABLE
argument_list|)
expr_stmt|;
block|}
name|IWM_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWM_FH_TX_CHICKEN_BITS_REG
argument_list|,
name|IWM_FH_TX_CHICKEN_BITS_SCD_AUTO_RETRY_EN
argument_list|)
expr_stmt|;
name|iwm_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Enable L1-Active */
if|if
condition|(
name|sc
operator|->
name|cfg
operator|->
name|device_family
operator|!=
name|IWM_DEVICE_FAMILY_8000
condition|)
block|{
name|iwm_clear_bits_prph
argument_list|(
name|sc
argument_list|,
name|IWM_APMG_PCIDEV_STT_REG
argument_list|,
name|IWM_APMG_PCIDEV_STT_VAL_L1_ACT_DIS
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * NVM read access and content parsing.  We do not support  * external NVM or writing NVM.  * iwlwifi/mvm/nvm.c  */
end_comment

begin_comment
comment|/* Default NVM size to read */
end_comment

begin_define
define|#
directive|define
name|IWM_NVM_DEFAULT_CHUNK_SIZE
value|(2*1024)
end_define

begin_define
define|#
directive|define
name|IWM_NVM_WRITE_OPCODE
value|1
end_define

begin_define
define|#
directive|define
name|IWM_NVM_READ_OPCODE
value|0
end_define

begin_comment
comment|/* load nvm chunk response */
end_comment

begin_enum
enum|enum
block|{
name|IWM_READ_NVM_CHUNK_SUCCEED
init|=
literal|0
block|,
name|IWM_READ_NVM_CHUNK_NOT_VALID_ADDRESS
init|=
literal|1
block|}
enum|;
end_enum

begin_function
specifier|static
name|int
name|iwm_nvm_read_chunk
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|uint16_t
name|section
parameter_list|,
name|uint16_t
name|offset
parameter_list|,
name|uint16_t
name|length
parameter_list|,
name|uint8_t
modifier|*
name|data
parameter_list|,
name|uint16_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|iwm_nvm_access_cmd
name|nvm_access_cmd
init|=
block|{
operator|.
name|offset
operator|=
name|htole16
argument_list|(
name|offset
argument_list|)
block|,
operator|.
name|length
operator|=
name|htole16
argument_list|(
name|length
argument_list|)
block|,
operator|.
name|type
operator|=
name|htole16
argument_list|(
name|section
argument_list|)
block|,
operator|.
name|op_code
operator|=
name|IWM_NVM_READ_OPCODE
block|, 	}
decl_stmt|;
name|struct
name|iwm_nvm_access_resp
modifier|*
name|nvm_resp
decl_stmt|;
name|struct
name|iwm_rx_packet
modifier|*
name|pkt
decl_stmt|;
name|struct
name|iwm_host_cmd
name|cmd
init|=
block|{
operator|.
name|id
operator|=
name|IWM_NVM_ACCESS_CMD
block|,
operator|.
name|flags
operator|=
name|IWM_CMD_WANT_SKB
operator||
name|IWM_CMD_SEND_IN_RFKILL
block|,
operator|.
name|data
operator|=
block|{
operator|&
name|nvm_access_cmd
block|, }
block|, 	}
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|bytes_read
decl_stmt|,
name|offset_read
decl_stmt|;
name|uint8_t
modifier|*
name|resp_data
decl_stmt|;
name|cmd
operator|.
name|len
index|[
literal|0
index|]
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|iwm_nvm_access_cmd
argument_list|)
expr_stmt|;
name|ret
operator|=
name|iwm_send_cmd
argument_list|(
name|sc
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Could not send NVM_ACCESS command (error=%d)\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|pkt
operator|=
name|cmd
operator|.
name|resp_pkt
expr_stmt|;
comment|/* Extract NVM response */
name|nvm_resp
operator|=
operator|(
name|void
operator|*
operator|)
name|pkt
operator|->
name|data
expr_stmt|;
name|ret
operator|=
name|le16toh
argument_list|(
name|nvm_resp
operator|->
name|status
argument_list|)
expr_stmt|;
name|bytes_read
operator|=
name|le16toh
argument_list|(
name|nvm_resp
operator|->
name|length
argument_list|)
expr_stmt|;
name|offset_read
operator|=
name|le16toh
argument_list|(
name|nvm_resp
operator|->
name|offset
argument_list|)
expr_stmt|;
name|resp_data
operator|=
name|nvm_resp
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
if|if
condition|(
operator|(
name|offset
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ret
operator|==
name|IWM_READ_NVM_CHUNK_NOT_VALID_ADDRESS
operator|)
condition|)
block|{
comment|/* 			 * meaning of NOT_VALID_ADDRESS: 			 * driver try to read chunk from address that is 			 * multiple of 2K and got an error since addr is empty. 			 * meaning of (offset != 0): driver already 			 * read valid data from another chunk so this case 			 * is not an error. 			 */
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_EEPROM
operator||
name|IWM_DEBUG_RESET
argument_list|,
literal|"NVM access command failed on offset 0x%x since that section size is multiple 2K\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
operator|*
name|len
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_EEPROM
operator||
name|IWM_DEBUG_RESET
argument_list|,
literal|"NVM access command failed with status %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|=
name|EIO
expr_stmt|;
block|}
goto|goto
name|exit
goto|;
block|}
if|if
condition|(
name|offset_read
operator|!=
name|offset
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"NVM ACCESS response with invalid offset %d\n"
argument_list|,
name|offset_read
argument_list|)
expr_stmt|;
name|ret
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
if|if
condition|(
name|bytes_read
operator|>
name|length
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"NVM ACCESS response with too much data "
literal|"(%d bytes requested, %d bytes received)\n"
argument_list|,
name|length
argument_list|,
name|bytes_read
argument_list|)
expr_stmt|;
name|ret
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
comment|/* Write data to NVM */
name|memcpy
argument_list|(
name|data
operator|+
name|offset
argument_list|,
name|resp_data
argument_list|,
name|bytes_read
argument_list|)
expr_stmt|;
operator|*
name|len
operator|=
name|bytes_read
expr_stmt|;
name|exit
label|:
name|iwm_free_resp
argument_list|(
name|sc
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Reads an NVM section completely.  * NICs prior to 7000 family don't have a real NVM, but just read  * section 0 which is the EEPROM. Because the EEPROM reading is unlimited  * by uCode, we need to manually check in this case that we don't  * overflow and try to read more than the EEPROM size.  * For 7000 family NICs, we supply the maximal size we can read, and  * the uCode fills the response with as much data as we can,  * without overflowing, so no check is needed.  */
end_comment

begin_function
specifier|static
name|int
name|iwm_nvm_read_section
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|uint16_t
name|section
parameter_list|,
name|uint8_t
modifier|*
name|data
parameter_list|,
name|uint16_t
modifier|*
name|len
parameter_list|,
name|uint32_t
name|size_read
parameter_list|)
block|{
name|uint16_t
name|seglen
decl_stmt|,
name|length
decl_stmt|,
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* Set nvm section read length */
name|length
operator|=
name|IWM_NVM_DEFAULT_CHUNK_SIZE
expr_stmt|;
name|seglen
operator|=
name|length
expr_stmt|;
comment|/* Read the NVM until exhausted (reading less than requested) */
while|while
condition|(
name|seglen
operator|==
name|length
condition|)
block|{
comment|/* Check no memory assumptions fail and cause an overflow */
if|if
condition|(
operator|(
name|size_read
operator|+
name|offset
operator|+
name|length
operator|)
operator|>
name|sc
operator|->
name|cfg
operator|->
name|eeprom_size
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"EEPROM size is too small for NVM\n"
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
name|ret
operator|=
name|iwm_nvm_read_chunk
argument_list|(
name|sc
argument_list|,
name|section
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|data
argument_list|,
operator|&
name|seglen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_EEPROM
operator||
name|IWM_DEBUG_RESET
argument_list|,
literal|"Cannot read NVM from section %d offset %d, length %d\n"
argument_list|,
name|section
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|offset
operator|+=
name|seglen
expr_stmt|;
block|}
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_EEPROM
operator||
name|IWM_DEBUG_RESET
argument_list|,
literal|"NVM section %d read completed\n"
argument_list|,
name|section
argument_list|)
expr_stmt|;
operator|*
name|len
operator|=
name|offset
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * BEGIN IWM_NVM_PARSE  */
end_comment

begin_comment
comment|/* iwlwifi/iwl-nvm-parse.c */
end_comment

begin_comment
comment|/* NVM offsets (in words) definitions */
end_comment

begin_enum
enum|enum
name|iwm_nvm_offsets
block|{
comment|/* NVM HW-Section offset (in words) definitions */
name|IWM_HW_ADDR
init|=
literal|0x15
block|,
comment|/* NVM SW-Section offset (in words) definitions */
name|IWM_NVM_SW_SECTION
init|=
literal|0x1C0
block|,
name|IWM_NVM_VERSION
init|=
literal|0
block|,
name|IWM_RADIO_CFG
init|=
literal|1
block|,
name|IWM_SKU
init|=
literal|2
block|,
name|IWM_N_HW_ADDRS
init|=
literal|3
block|,
name|IWM_NVM_CHANNELS
init|=
literal|0x1E0
operator|-
name|IWM_NVM_SW_SECTION
block|,
comment|/* NVM calibration section offset (in words) definitions */
name|IWM_NVM_CALIB_SECTION
init|=
literal|0x2B8
block|,
name|IWM_XTAL_CALIB
init|=
literal|0x316
operator|-
name|IWM_NVM_CALIB_SECTION
block|}
enum|;
end_enum

begin_enum
enum|enum
name|iwm_8000_nvm_offsets
block|{
comment|/* NVM HW-Section offset (in words) definitions */
name|IWM_HW_ADDR0_WFPM_8000
init|=
literal|0x12
block|,
name|IWM_HW_ADDR1_WFPM_8000
init|=
literal|0x16
block|,
name|IWM_HW_ADDR0_PCIE_8000
init|=
literal|0x8A
block|,
name|IWM_HW_ADDR1_PCIE_8000
init|=
literal|0x8E
block|,
name|IWM_MAC_ADDRESS_OVERRIDE_8000
init|=
literal|1
block|,
comment|/* NVM SW-Section offset (in words) definitions */
name|IWM_NVM_SW_SECTION_8000
init|=
literal|0x1C0
block|,
name|IWM_NVM_VERSION_8000
init|=
literal|0
block|,
name|IWM_RADIO_CFG_8000
init|=
literal|0
block|,
name|IWM_SKU_8000
init|=
literal|2
block|,
name|IWM_N_HW_ADDRS_8000
init|=
literal|3
block|,
comment|/* NVM REGULATORY -Section offset (in words) definitions */
name|IWM_NVM_CHANNELS_8000
init|=
literal|0
block|,
name|IWM_NVM_LAR_OFFSET_8000_OLD
init|=
literal|0x4C7
block|,
name|IWM_NVM_LAR_OFFSET_8000
init|=
literal|0x507
block|,
name|IWM_NVM_LAR_ENABLED_8000
init|=
literal|0x7
block|,
comment|/* NVM calibration section offset (in words) definitions */
name|IWM_NVM_CALIB_SECTION_8000
init|=
literal|0x2B8
block|,
name|IWM_XTAL_CALIB_8000
init|=
literal|0x316
operator|-
name|IWM_NVM_CALIB_SECTION_8000
block|}
enum|;
end_enum

begin_comment
comment|/* SKU Capabilities (actual values from NVM definition) */
end_comment

begin_enum
enum|enum
name|nvm_sku_bits
block|{
name|IWM_NVM_SKU_CAP_BAND_24GHZ
init|=
operator|(
literal|1
operator|<<
literal|0
operator|)
block|,
name|IWM_NVM_SKU_CAP_BAND_52GHZ
init|=
operator|(
literal|1
operator|<<
literal|1
operator|)
block|,
name|IWM_NVM_SKU_CAP_11N_ENABLE
init|=
operator|(
literal|1
operator|<<
literal|2
operator|)
block|,
name|IWM_NVM_SKU_CAP_11AC_ENABLE
init|=
operator|(
literal|1
operator|<<
literal|3
operator|)
block|, }
enum|;
end_enum

begin_comment
comment|/* radio config bits (actual values from NVM definition) */
end_comment

begin_define
define|#
directive|define
name|IWM_NVM_RF_CFG_DASH_MSK
parameter_list|(
name|x
parameter_list|)
value|(x& 0x3)
end_define

begin_comment
comment|/* bits 0-1   */
end_comment

begin_define
define|#
directive|define
name|IWM_NVM_RF_CFG_STEP_MSK
parameter_list|(
name|x
parameter_list|)
value|((x>> 2)& 0x3)
end_define

begin_comment
comment|/* bits 2-3   */
end_comment

begin_define
define|#
directive|define
name|IWM_NVM_RF_CFG_TYPE_MSK
parameter_list|(
name|x
parameter_list|)
value|((x>> 4)& 0x3)
end_define

begin_comment
comment|/* bits 4-5   */
end_comment

begin_define
define|#
directive|define
name|IWM_NVM_RF_CFG_PNUM_MSK
parameter_list|(
name|x
parameter_list|)
value|((x>> 6)& 0x3)
end_define

begin_comment
comment|/* bits 6-7   */
end_comment

begin_define
define|#
directive|define
name|IWM_NVM_RF_CFG_TX_ANT_MSK
parameter_list|(
name|x
parameter_list|)
value|((x>> 8)& 0xF)
end_define

begin_comment
comment|/* bits 8-11  */
end_comment

begin_define
define|#
directive|define
name|IWM_NVM_RF_CFG_RX_ANT_MSK
parameter_list|(
name|x
parameter_list|)
value|((x>> 12)& 0xF)
end_define

begin_comment
comment|/* bits 12-15 */
end_comment

begin_define
define|#
directive|define
name|IWM_NVM_RF_CFG_FLAVOR_MSK_8000
parameter_list|(
name|x
parameter_list|)
value|(x& 0xF)
end_define

begin_define
define|#
directive|define
name|IWM_NVM_RF_CFG_DASH_MSK_8000
parameter_list|(
name|x
parameter_list|)
value|((x>> 4)& 0xF)
end_define

begin_define
define|#
directive|define
name|IWM_NVM_RF_CFG_STEP_MSK_8000
parameter_list|(
name|x
parameter_list|)
value|((x>> 8)& 0xF)
end_define

begin_define
define|#
directive|define
name|IWM_NVM_RF_CFG_TYPE_MSK_8000
parameter_list|(
name|x
parameter_list|)
value|((x>> 12)& 0xFFF)
end_define

begin_define
define|#
directive|define
name|IWM_NVM_RF_CFG_TX_ANT_MSK_8000
parameter_list|(
name|x
parameter_list|)
value|((x>> 24)& 0xF)
end_define

begin_define
define|#
directive|define
name|IWM_NVM_RF_CFG_RX_ANT_MSK_8000
parameter_list|(
name|x
parameter_list|)
value|((x>> 28)& 0xF)
end_define

begin_define
define|#
directive|define
name|DEFAULT_MAX_TX_POWER
value|16
end_define

begin_comment
comment|/**  * enum iwm_nvm_channel_flags - channel flags in NVM  * @IWM_NVM_CHANNEL_VALID: channel is usable for this SKU/geo  * @IWM_NVM_CHANNEL_IBSS: usable as an IBSS channel  * @IWM_NVM_CHANNEL_ACTIVE: active scanning allowed  * @IWM_NVM_CHANNEL_RADAR: radar detection required  * XXX cannot find this (DFS) flag in iwm-nvm-parse.c  * @IWM_NVM_CHANNEL_DFS: dynamic freq selection candidate  * @IWM_NVM_CHANNEL_WIDE: 20 MHz channel okay (?)  * @IWM_NVM_CHANNEL_40MHZ: 40 MHz channel okay (?)  * @IWM_NVM_CHANNEL_80MHZ: 80 MHz channel okay (?)  * @IWM_NVM_CHANNEL_160MHZ: 160 MHz channel okay (?)  */
end_comment

begin_enum
enum|enum
name|iwm_nvm_channel_flags
block|{
name|IWM_NVM_CHANNEL_VALID
init|=
operator|(
literal|1
operator|<<
literal|0
operator|)
block|,
name|IWM_NVM_CHANNEL_IBSS
init|=
operator|(
literal|1
operator|<<
literal|1
operator|)
block|,
name|IWM_NVM_CHANNEL_ACTIVE
init|=
operator|(
literal|1
operator|<<
literal|3
operator|)
block|,
name|IWM_NVM_CHANNEL_RADAR
init|=
operator|(
literal|1
operator|<<
literal|4
operator|)
block|,
name|IWM_NVM_CHANNEL_DFS
init|=
operator|(
literal|1
operator|<<
literal|7
operator|)
block|,
name|IWM_NVM_CHANNEL_WIDE
init|=
operator|(
literal|1
operator|<<
literal|8
operator|)
block|,
name|IWM_NVM_CHANNEL_40MHZ
init|=
operator|(
literal|1
operator|<<
literal|9
operator|)
block|,
name|IWM_NVM_CHANNEL_80MHZ
init|=
operator|(
literal|1
operator|<<
literal|10
operator|)
block|,
name|IWM_NVM_CHANNEL_160MHZ
init|=
operator|(
literal|1
operator|<<
literal|11
operator|)
block|, }
enum|;
end_enum

begin_comment
comment|/*  * Translate EEPROM flags to net80211.  */
end_comment

begin_function
specifier|static
name|uint32_t
name|iwm_eeprom_channel_flags
parameter_list|(
name|uint16_t
name|ch_flags
parameter_list|)
block|{
name|uint32_t
name|nflags
decl_stmt|;
name|nflags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ch_flags
operator|&
name|IWM_NVM_CHANNEL_ACTIVE
operator|)
operator|==
literal|0
condition|)
name|nflags
operator||=
name|IEEE80211_CHAN_PASSIVE
expr_stmt|;
if|if
condition|(
operator|(
name|ch_flags
operator|&
name|IWM_NVM_CHANNEL_IBSS
operator|)
operator|==
literal|0
condition|)
name|nflags
operator||=
name|IEEE80211_CHAN_NOADHOC
expr_stmt|;
if|if
condition|(
name|ch_flags
operator|&
name|IWM_NVM_CHANNEL_RADAR
condition|)
block|{
name|nflags
operator||=
name|IEEE80211_CHAN_DFS
expr_stmt|;
comment|/* Just in case. */
name|nflags
operator||=
name|IEEE80211_CHAN_NOADHOC
expr_stmt|;
block|}
return|return
operator|(
name|nflags
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_add_channel_band
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_channel
name|chans
index|[]
parameter_list|,
name|int
name|maxchans
parameter_list|,
name|int
modifier|*
name|nchans
parameter_list|,
name|int
name|ch_idx
parameter_list|,
name|size_t
name|ch_num
parameter_list|,
specifier|const
name|uint8_t
name|bands
index|[]
parameter_list|)
block|{
specifier|const
name|uint16_t
modifier|*
specifier|const
name|nvm_ch_flags
init|=
name|sc
operator|->
name|nvm_data
operator|->
name|nvm_ch_flags
decl_stmt|;
name|uint32_t
name|nflags
decl_stmt|;
name|uint16_t
name|ch_flags
decl_stmt|;
name|uint8_t
name|ieee
decl_stmt|;
name|int
name|error
decl_stmt|;
for|for
control|(
init|;
name|ch_idx
operator|<
name|ch_num
condition|;
name|ch_idx
operator|++
control|)
block|{
name|ch_flags
operator|=
name|le16_to_cpup
argument_list|(
name|nvm_ch_flags
operator|+
name|ch_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|cfg
operator|->
name|device_family
operator|==
name|IWM_DEVICE_FAMILY_7000
condition|)
name|ieee
operator|=
name|iwm_nvm_channels
index|[
name|ch_idx
index|]
expr_stmt|;
else|else
name|ieee
operator|=
name|iwm_nvm_channels_8000
index|[
name|ch_idx
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ch_flags
operator|&
name|IWM_NVM_CHANNEL_VALID
operator|)
condition|)
block|{
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_EEPROM
argument_list|,
literal|"Ch. %d Flags %x [%sGHz] - No traffic\n"
argument_list|,
name|ieee
argument_list|,
name|ch_flags
argument_list|,
operator|(
name|ch_idx
operator|>=
name|IWM_NUM_2GHZ_CHANNELS
operator|)
condition|?
literal|"5.2"
else|:
literal|"2.4"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|nflags
operator|=
name|iwm_eeprom_channel_flags
argument_list|(
name|ch_flags
argument_list|)
expr_stmt|;
name|error
operator|=
name|ieee80211_add_channel
argument_list|(
name|chans
argument_list|,
name|maxchans
argument_list|,
name|nchans
argument_list|,
name|ieee
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|nflags
argument_list|,
name|bands
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_EEPROM
argument_list|,
literal|"Ch. %d Flags %x [%sGHz] - Added\n"
argument_list|,
name|ieee
argument_list|,
name|ch_flags
argument_list|,
operator|(
name|ch_idx
operator|>=
name|IWM_NUM_2GHZ_CHANNELS
operator|)
condition|?
literal|"5.2"
else|:
literal|"2.4"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_init_channel_map
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|int
name|maxchans
parameter_list|,
name|int
modifier|*
name|nchans
parameter_list|,
name|struct
name|ieee80211_channel
name|chans
index|[]
parameter_list|)
block|{
name|struct
name|iwm_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|struct
name|iwm_nvm_data
modifier|*
name|data
init|=
name|sc
operator|->
name|nvm_data
decl_stmt|;
name|uint8_t
name|bands
index|[
name|IEEE80211_MODE_BYTES
index|]
decl_stmt|;
name|size_t
name|ch_num
decl_stmt|;
name|memset
argument_list|(
name|bands
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|bands
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 1-13: 11b/g channels. */
name|setbit
argument_list|(
name|bands
argument_list|,
name|IEEE80211_MODE_11B
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|bands
argument_list|,
name|IEEE80211_MODE_11G
argument_list|)
expr_stmt|;
name|iwm_add_channel_band
argument_list|(
name|sc
argument_list|,
name|chans
argument_list|,
name|maxchans
argument_list|,
name|nchans
argument_list|,
literal|0
argument_list|,
name|IWM_NUM_2GHZ_CHANNELS
operator|-
literal|1
argument_list|,
name|bands
argument_list|)
expr_stmt|;
comment|/* 14: 11b channel only. */
name|clrbit
argument_list|(
name|bands
argument_list|,
name|IEEE80211_MODE_11G
argument_list|)
expr_stmt|;
name|iwm_add_channel_band
argument_list|(
name|sc
argument_list|,
name|chans
argument_list|,
name|maxchans
argument_list|,
name|nchans
argument_list|,
name|IWM_NUM_2GHZ_CHANNELS
operator|-
literal|1
argument_list|,
name|IWM_NUM_2GHZ_CHANNELS
argument_list|,
name|bands
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|sku_cap_band_52GHz_enable
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|cfg
operator|->
name|device_family
operator|==
name|IWM_DEVICE_FAMILY_7000
condition|)
name|ch_num
operator|=
name|nitems
argument_list|(
name|iwm_nvm_channels
argument_list|)
expr_stmt|;
else|else
name|ch_num
operator|=
name|nitems
argument_list|(
name|iwm_nvm_channels_8000
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|bands
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|bands
argument_list|)
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|bands
argument_list|,
name|IEEE80211_MODE_11A
argument_list|)
expr_stmt|;
name|iwm_add_channel_band
argument_list|(
name|sc
argument_list|,
name|chans
argument_list|,
name|maxchans
argument_list|,
name|nchans
argument_list|,
name|IWM_NUM_2GHZ_CHANNELS
argument_list|,
name|ch_num
argument_list|,
name|bands
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_set_hw_address_family_8000
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwm_nvm_data
modifier|*
name|data
parameter_list|,
specifier|const
name|uint16_t
modifier|*
name|mac_override
parameter_list|,
specifier|const
name|uint16_t
modifier|*
name|nvm_hw
parameter_list|)
block|{
specifier|const
name|uint8_t
modifier|*
name|hw_addr
decl_stmt|;
if|if
condition|(
name|mac_override
condition|)
block|{
specifier|static
specifier|const
name|uint8_t
name|reserved_mac
index|[]
init|=
block|{
literal|0x02
block|,
literal|0xcc
block|,
literal|0xaa
block|,
literal|0xff
block|,
literal|0xee
block|,
literal|0x00
block|}
decl_stmt|;
name|hw_addr
operator|=
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
operator|(
name|mac_override
operator|+
name|IWM_MAC_ADDRESS_OVERRIDE_8000
operator|)
expr_stmt|;
comment|/* 		 * Store the MAC address from MAO section. 		 * No byte swapping is required in MAO section 		 */
name|IEEE80211_ADDR_COPY
argument_list|(
name|data
operator|->
name|hw_addr
argument_list|,
name|hw_addr
argument_list|)
expr_stmt|;
comment|/* 		 * Force the use of the OTP MAC address in case of reserved MAC 		 * address in the NVM, or if address is given but invalid. 		 */
if|if
condition|(
operator|!
name|IEEE80211_ADDR_EQ
argument_list|(
name|reserved_mac
argument_list|,
name|hw_addr
argument_list|)
operator|&&
operator|!
name|IEEE80211_ADDR_EQ
argument_list|(
name|ieee80211broadcastaddr
argument_list|,
name|data
operator|->
name|hw_addr
argument_list|)
operator|&&
name|iwm_is_valid_ether_addr
argument_list|(
name|data
operator|->
name|hw_addr
argument_list|)
operator|&&
operator|!
name|IEEE80211_IS_MULTICAST
argument_list|(
name|data
operator|->
name|hw_addr
argument_list|)
condition|)
return|return;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_RESET
argument_list|,
literal|"%s: mac address from nvm override section invalid\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nvm_hw
condition|)
block|{
comment|/* read the mac address from WFMP registers */
name|uint32_t
name|mac_addr0
init|=
name|htole32
argument_list|(
name|iwm_read_prph
argument_list|(
name|sc
argument_list|,
name|IWM_WFMP_MAC_ADDR_0
argument_list|)
argument_list|)
decl_stmt|;
name|uint32_t
name|mac_addr1
init|=
name|htole32
argument_list|(
name|iwm_read_prph
argument_list|(
name|sc
argument_list|,
name|IWM_WFMP_MAC_ADDR_1
argument_list|)
argument_list|)
decl_stmt|;
name|hw_addr
operator|=
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
operator|&
name|mac_addr0
expr_stmt|;
name|data
operator|->
name|hw_addr
index|[
literal|0
index|]
operator|=
name|hw_addr
index|[
literal|3
index|]
expr_stmt|;
name|data
operator|->
name|hw_addr
index|[
literal|1
index|]
operator|=
name|hw_addr
index|[
literal|2
index|]
expr_stmt|;
name|data
operator|->
name|hw_addr
index|[
literal|2
index|]
operator|=
name|hw_addr
index|[
literal|1
index|]
expr_stmt|;
name|data
operator|->
name|hw_addr
index|[
literal|3
index|]
operator|=
name|hw_addr
index|[
literal|0
index|]
expr_stmt|;
name|hw_addr
operator|=
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
operator|&
name|mac_addr1
expr_stmt|;
name|data
operator|->
name|hw_addr
index|[
literal|4
index|]
operator|=
name|hw_addr
index|[
literal|1
index|]
expr_stmt|;
name|data
operator|->
name|hw_addr
index|[
literal|5
index|]
operator|=
name|hw_addr
index|[
literal|0
index|]
expr_stmt|;
return|return;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: mac address not found\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|data
operator|->
name|hw_addr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|data
operator|->
name|hw_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_get_sku
parameter_list|(
specifier|const
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|uint16_t
modifier|*
name|nvm_sw
parameter_list|,
specifier|const
name|uint16_t
modifier|*
name|phy_sku
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|cfg
operator|->
name|device_family
operator|!=
name|IWM_DEVICE_FAMILY_8000
condition|)
return|return
name|le16_to_cpup
argument_list|(
name|nvm_sw
operator|+
name|IWM_SKU
argument_list|)
return|;
return|return
name|le32_to_cpup
argument_list|(
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
operator|(
name|phy_sku
operator|+
name|IWM_SKU_8000
operator|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_get_nvm_version
parameter_list|(
specifier|const
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|uint16_t
modifier|*
name|nvm_sw
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|cfg
operator|->
name|device_family
operator|!=
name|IWM_DEVICE_FAMILY_8000
condition|)
return|return
name|le16_to_cpup
argument_list|(
name|nvm_sw
operator|+
name|IWM_NVM_VERSION
argument_list|)
return|;
else|else
return|return
name|le32_to_cpup
argument_list|(
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
operator|(
name|nvm_sw
operator|+
name|IWM_NVM_VERSION_8000
operator|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_get_radio_cfg
parameter_list|(
specifier|const
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|uint16_t
modifier|*
name|nvm_sw
parameter_list|,
specifier|const
name|uint16_t
modifier|*
name|phy_sku
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|cfg
operator|->
name|device_family
operator|!=
name|IWM_DEVICE_FAMILY_8000
condition|)
return|return
name|le16_to_cpup
argument_list|(
name|nvm_sw
operator|+
name|IWM_RADIO_CFG
argument_list|)
return|;
return|return
name|le32_to_cpup
argument_list|(
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
operator|(
name|phy_sku
operator|+
name|IWM_RADIO_CFG_8000
operator|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_get_n_hw_addrs
parameter_list|(
specifier|const
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|uint16_t
modifier|*
name|nvm_sw
parameter_list|)
block|{
name|int
name|n_hw_addr
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|cfg
operator|->
name|device_family
operator|!=
name|IWM_DEVICE_FAMILY_8000
condition|)
return|return
name|le16_to_cpup
argument_list|(
name|nvm_sw
operator|+
name|IWM_N_HW_ADDRS
argument_list|)
return|;
name|n_hw_addr
operator|=
name|le32_to_cpup
argument_list|(
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
operator|(
name|nvm_sw
operator|+
name|IWM_N_HW_ADDRS_8000
operator|)
argument_list|)
expr_stmt|;
return|return
name|n_hw_addr
operator|&
name|IWM_N_HW_ADDR_MASK
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_set_radio_cfg
parameter_list|(
specifier|const
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwm_nvm_data
modifier|*
name|data
parameter_list|,
name|uint32_t
name|radio_cfg
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|cfg
operator|->
name|device_family
operator|!=
name|IWM_DEVICE_FAMILY_8000
condition|)
block|{
name|data
operator|->
name|radio_cfg_type
operator|=
name|IWM_NVM_RF_CFG_TYPE_MSK
argument_list|(
name|radio_cfg
argument_list|)
expr_stmt|;
name|data
operator|->
name|radio_cfg_step
operator|=
name|IWM_NVM_RF_CFG_STEP_MSK
argument_list|(
name|radio_cfg
argument_list|)
expr_stmt|;
name|data
operator|->
name|radio_cfg_dash
operator|=
name|IWM_NVM_RF_CFG_DASH_MSK
argument_list|(
name|radio_cfg
argument_list|)
expr_stmt|;
name|data
operator|->
name|radio_cfg_pnum
operator|=
name|IWM_NVM_RF_CFG_PNUM_MSK
argument_list|(
name|radio_cfg
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* set the radio configuration for family 8000 */
name|data
operator|->
name|radio_cfg_type
operator|=
name|IWM_NVM_RF_CFG_TYPE_MSK_8000
argument_list|(
name|radio_cfg
argument_list|)
expr_stmt|;
name|data
operator|->
name|radio_cfg_step
operator|=
name|IWM_NVM_RF_CFG_STEP_MSK_8000
argument_list|(
name|radio_cfg
argument_list|)
expr_stmt|;
name|data
operator|->
name|radio_cfg_dash
operator|=
name|IWM_NVM_RF_CFG_DASH_MSK_8000
argument_list|(
name|radio_cfg
argument_list|)
expr_stmt|;
name|data
operator|->
name|radio_cfg_pnum
operator|=
name|IWM_NVM_RF_CFG_FLAVOR_MSK_8000
argument_list|(
name|radio_cfg
argument_list|)
expr_stmt|;
name|data
operator|->
name|valid_tx_ant
operator|=
name|IWM_NVM_RF_CFG_TX_ANT_MSK_8000
argument_list|(
name|radio_cfg
argument_list|)
expr_stmt|;
name|data
operator|->
name|valid_rx_ant
operator|=
name|IWM_NVM_RF_CFG_RX_ANT_MSK_8000
argument_list|(
name|radio_cfg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_set_hw_address
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwm_nvm_data
modifier|*
name|data
parameter_list|,
specifier|const
name|uint16_t
modifier|*
name|nvm_hw
parameter_list|,
specifier|const
name|uint16_t
modifier|*
name|mac_override
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|notyet
comment|/* for FAMILY 9000 */
if|if
condition|(
name|cfg
operator|->
name|mac_addr_from_csr
condition|)
block|{
name|iwm_set_hw_address_from_csr
argument_list|(
name|sc
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|cfg
operator|->
name|device_family
operator|!=
name|IWM_DEVICE_FAMILY_8000
condition|)
block|{
specifier|const
name|uint8_t
modifier|*
name|hw_addr
init|=
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
operator|(
name|nvm_hw
operator|+
name|IWM_HW_ADDR
operator|)
decl_stmt|;
comment|/* The byte order is little endian 16 bit, meaning 214365 */
name|data
operator|->
name|hw_addr
index|[
literal|0
index|]
operator|=
name|hw_addr
index|[
literal|1
index|]
expr_stmt|;
name|data
operator|->
name|hw_addr
index|[
literal|1
index|]
operator|=
name|hw_addr
index|[
literal|0
index|]
expr_stmt|;
name|data
operator|->
name|hw_addr
index|[
literal|2
index|]
operator|=
name|hw_addr
index|[
literal|3
index|]
expr_stmt|;
name|data
operator|->
name|hw_addr
index|[
literal|3
index|]
operator|=
name|hw_addr
index|[
literal|2
index|]
expr_stmt|;
name|data
operator|->
name|hw_addr
index|[
literal|4
index|]
operator|=
name|hw_addr
index|[
literal|5
index|]
expr_stmt|;
name|data
operator|->
name|hw_addr
index|[
literal|5
index|]
operator|=
name|hw_addr
index|[
literal|4
index|]
expr_stmt|;
block|}
else|else
block|{
name|iwm_set_hw_address_family_8000
argument_list|(
name|sc
argument_list|,
name|data
argument_list|,
name|mac_override
argument_list|,
name|nvm_hw
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|iwm_is_valid_ether_addr
argument_list|(
name|data
operator|->
name|hw_addr
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"no valid mac address was found\n"
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|iwm_nvm_data
modifier|*
name|iwm_parse_nvm_data
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|uint16_t
modifier|*
name|nvm_hw
parameter_list|,
specifier|const
name|uint16_t
modifier|*
name|nvm_sw
parameter_list|,
specifier|const
name|uint16_t
modifier|*
name|nvm_calib
parameter_list|,
specifier|const
name|uint16_t
modifier|*
name|mac_override
parameter_list|,
specifier|const
name|uint16_t
modifier|*
name|phy_sku
parameter_list|,
specifier|const
name|uint16_t
modifier|*
name|regulatory
parameter_list|)
block|{
name|struct
name|iwm_nvm_data
modifier|*
name|data
decl_stmt|;
name|uint32_t
name|sku
decl_stmt|,
name|radio_cfg
decl_stmt|;
name|uint16_t
name|lar_config
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|cfg
operator|->
name|device_family
operator|!=
name|IWM_DEVICE_FAMILY_8000
condition|)
block|{
name|data
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
operator|+
name|IWM_NUM_CHANNELS
operator|*
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|data
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
operator|+
name|IWM_NUM_CHANNELS_8000
operator|*
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|data
condition|)
return|return
name|NULL
return|;
name|data
operator|->
name|nvm_version
operator|=
name|iwm_get_nvm_version
argument_list|(
name|sc
argument_list|,
name|nvm_sw
argument_list|)
expr_stmt|;
name|radio_cfg
operator|=
name|iwm_get_radio_cfg
argument_list|(
name|sc
argument_list|,
name|nvm_sw
argument_list|,
name|phy_sku
argument_list|)
expr_stmt|;
name|iwm_set_radio_cfg
argument_list|(
name|sc
argument_list|,
name|data
argument_list|,
name|radio_cfg
argument_list|)
expr_stmt|;
name|sku
operator|=
name|iwm_get_sku
argument_list|(
name|sc
argument_list|,
name|nvm_sw
argument_list|,
name|phy_sku
argument_list|)
expr_stmt|;
name|data
operator|->
name|sku_cap_band_24GHz_enable
operator|=
name|sku
operator|&
name|IWM_NVM_SKU_CAP_BAND_24GHZ
expr_stmt|;
name|data
operator|->
name|sku_cap_band_52GHz_enable
operator|=
name|sku
operator|&
name|IWM_NVM_SKU_CAP_BAND_52GHZ
expr_stmt|;
name|data
operator|->
name|sku_cap_11n_enable
operator|=
literal|0
expr_stmt|;
name|data
operator|->
name|n_hw_addrs
operator|=
name|iwm_get_n_hw_addrs
argument_list|(
name|sc
argument_list|,
name|nvm_sw
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|cfg
operator|->
name|device_family
operator|==
name|IWM_DEVICE_FAMILY_8000
condition|)
block|{
name|uint16_t
name|lar_offset
init|=
name|data
operator|->
name|nvm_version
operator|<
literal|0xE39
condition|?
name|IWM_NVM_LAR_OFFSET_8000_OLD
else|:
name|IWM_NVM_LAR_OFFSET_8000
decl_stmt|;
name|lar_config
operator|=
name|le16_to_cpup
argument_list|(
name|regulatory
operator|+
name|lar_offset
argument_list|)
expr_stmt|;
name|data
operator|->
name|lar_enabled
operator|=
operator|!
operator|!
operator|(
name|lar_config
operator|&
name|IWM_NVM_LAR_ENABLED_8000
operator|)
expr_stmt|;
block|}
comment|/* If no valid mac address was found - bail out */
if|if
condition|(
name|iwm_set_hw_address
argument_list|(
name|sc
argument_list|,
name|data
argument_list|,
name|nvm_hw
argument_list|,
name|mac_override
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|data
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|cfg
operator|->
name|device_family
operator|==
name|IWM_DEVICE_FAMILY_7000
condition|)
block|{
name|memcpy
argument_list|(
name|data
operator|->
name|nvm_ch_flags
argument_list|,
operator|&
name|nvm_sw
index|[
name|IWM_NVM_CHANNELS
index|]
argument_list|,
name|IWM_NUM_CHANNELS
operator|*
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|data
operator|->
name|nvm_ch_flags
argument_list|,
operator|&
name|regulatory
index|[
name|IWM_NVM_CHANNELS_8000
index|]
argument_list|,
name|IWM_NUM_CHANNELS_8000
operator|*
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|data
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_free_nvm_data
parameter_list|(
name|struct
name|iwm_nvm_data
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
name|data
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|data
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|iwm_nvm_data
modifier|*
name|iwm_parse_nvm_sections
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwm_nvm_section
modifier|*
name|sections
parameter_list|)
block|{
specifier|const
name|uint16_t
modifier|*
name|hw
decl_stmt|,
modifier|*
name|sw
decl_stmt|,
modifier|*
name|calib
decl_stmt|,
modifier|*
name|regulatory
decl_stmt|,
modifier|*
name|mac_override
decl_stmt|,
modifier|*
name|phy_sku
decl_stmt|;
comment|/* Checking for required sections */
if|if
condition|(
name|sc
operator|->
name|cfg
operator|->
name|device_family
operator|==
name|IWM_DEVICE_FAMILY_7000
condition|)
block|{
if|if
condition|(
operator|!
name|sections
index|[
name|IWM_NVM_SECTION_TYPE_SW
index|]
operator|.
name|data
operator|||
operator|!
name|sections
index|[
name|sc
operator|->
name|cfg
operator|->
name|nvm_hw_section_num
index|]
operator|.
name|data
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Can't parse empty OTP/NVM sections\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|cfg
operator|->
name|device_family
operator|==
name|IWM_DEVICE_FAMILY_8000
condition|)
block|{
comment|/* SW and REGULATORY sections are mandatory */
if|if
condition|(
operator|!
name|sections
index|[
name|IWM_NVM_SECTION_TYPE_SW
index|]
operator|.
name|data
operator|||
operator|!
name|sections
index|[
name|IWM_NVM_SECTION_TYPE_REGULATORY
index|]
operator|.
name|data
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Can't parse empty OTP/NVM sections\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* MAC_OVERRIDE or at least HW section must exist */
if|if
condition|(
operator|!
name|sections
index|[
name|sc
operator|->
name|cfg
operator|->
name|nvm_hw_section_num
index|]
operator|.
name|data
operator|&&
operator|!
name|sections
index|[
name|IWM_NVM_SECTION_TYPE_MAC_OVERRIDE
index|]
operator|.
name|data
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Can't parse mac_address, empty sections\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* PHY_SKU section is mandatory in B0 */
if|if
condition|(
operator|!
name|sections
index|[
name|IWM_NVM_SECTION_TYPE_PHY_SKU
index|]
operator|.
name|data
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Can't parse phy_sku in B0, empty sections\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
else|else
block|{
name|panic
argument_list|(
literal|"unknown device family %d\n"
argument_list|,
name|sc
operator|->
name|cfg
operator|->
name|device_family
argument_list|)
expr_stmt|;
block|}
name|hw
operator|=
operator|(
specifier|const
name|uint16_t
operator|*
operator|)
name|sections
index|[
name|sc
operator|->
name|cfg
operator|->
name|nvm_hw_section_num
index|]
operator|.
name|data
expr_stmt|;
name|sw
operator|=
operator|(
specifier|const
name|uint16_t
operator|*
operator|)
name|sections
index|[
name|IWM_NVM_SECTION_TYPE_SW
index|]
operator|.
name|data
expr_stmt|;
name|calib
operator|=
operator|(
specifier|const
name|uint16_t
operator|*
operator|)
name|sections
index|[
name|IWM_NVM_SECTION_TYPE_CALIBRATION
index|]
operator|.
name|data
expr_stmt|;
name|regulatory
operator|=
operator|(
specifier|const
name|uint16_t
operator|*
operator|)
name|sections
index|[
name|IWM_NVM_SECTION_TYPE_REGULATORY
index|]
operator|.
name|data
expr_stmt|;
name|mac_override
operator|=
operator|(
specifier|const
name|uint16_t
operator|*
operator|)
name|sections
index|[
name|IWM_NVM_SECTION_TYPE_MAC_OVERRIDE
index|]
operator|.
name|data
expr_stmt|;
name|phy_sku
operator|=
operator|(
specifier|const
name|uint16_t
operator|*
operator|)
name|sections
index|[
name|IWM_NVM_SECTION_TYPE_PHY_SKU
index|]
operator|.
name|data
expr_stmt|;
return|return
name|iwm_parse_nvm_data
argument_list|(
name|sc
argument_list|,
name|hw
argument_list|,
name|sw
argument_list|,
name|calib
argument_list|,
name|mac_override
argument_list|,
name|phy_sku
argument_list|,
name|regulatory
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_nvm_init
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|iwm_nvm_section
name|nvm_sections
index|[
name|IWM_NVM_MAX_NUM_SECTIONS
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|,
name|section
decl_stmt|;
name|uint32_t
name|size_read
init|=
literal|0
decl_stmt|;
name|uint8_t
modifier|*
name|nvm_buffer
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|uint16_t
name|len
decl_stmt|;
name|memset
argument_list|(
name|nvm_sections
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|nvm_sections
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|cfg
operator|->
name|nvm_hw_section_num
operator|>=
name|IWM_NVM_MAX_NUM_SECTIONS
condition|)
return|return
name|EINVAL
return|;
comment|/* load NVM values from nic */
comment|/* Read From FW NVM */
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_EEPROM
argument_list|,
literal|"Read from NVM\n"
argument_list|)
expr_stmt|;
name|nvm_buffer
operator|=
name|malloc
argument_list|(
name|sc
operator|->
name|cfg
operator|->
name|eeprom_size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nvm_buffer
condition|)
return|return
name|ENOMEM
return|;
for|for
control|(
name|section
operator|=
literal|0
init|;
name|section
operator|<
name|IWM_NVM_MAX_NUM_SECTIONS
condition|;
name|section
operator|++
control|)
block|{
comment|/* we override the constness for initial read */
name|ret
operator|=
name|iwm_nvm_read_section
argument_list|(
name|sc
argument_list|,
name|section
argument_list|,
name|nvm_buffer
argument_list|,
operator|&
name|len
argument_list|,
name|size_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
continue|continue;
name|size_read
operator|+=
name|len
expr_stmt|;
name|temp
operator|=
name|malloc
argument_list|(
name|len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
block|{
name|ret
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|memcpy
argument_list|(
name|temp
argument_list|,
name|nvm_buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|nvm_sections
index|[
name|section
index|]
operator|.
name|data
operator|=
name|temp
expr_stmt|;
name|nvm_sections
index|[
name|section
index|]
operator|.
name|length
operator|=
name|len
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|size_read
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"OTP is blank\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nvm_buffer
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|sc
operator|->
name|nvm_data
operator|=
name|iwm_parse_nvm_sections
argument_list|(
name|sc
argument_list|,
name|nvm_sections
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|nvm_data
condition|)
return|return
name|EINVAL
return|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_EEPROM
operator||
name|IWM_DEBUG_RESET
argument_list|,
literal|"nvm version = %x\n"
argument_list|,
name|sc
operator|->
name|nvm_data
operator|->
name|nvm_version
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IWM_NVM_MAX_NUM_SECTIONS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|nvm_sections
index|[
name|i
index|]
operator|.
name|data
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|nvm_sections
index|[
name|i
index|]
operator|.
name|data
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_pcie_load_section
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|section_num
parameter_list|,
specifier|const
name|struct
name|iwm_fw_desc
modifier|*
name|section
parameter_list|)
block|{
name|struct
name|iwm_dma_info
modifier|*
name|dma
init|=
operator|&
name|sc
operator|->
name|fw_dma
decl_stmt|;
name|uint8_t
modifier|*
name|v_addr
decl_stmt|;
name|bus_addr_t
name|p_addr
decl_stmt|;
name|uint32_t
name|offset
decl_stmt|,
name|chunk_sz
init|=
name|MIN
argument_list|(
name|IWM_FH_MEM_TB_MAX_LENGTH
argument_list|,
name|section
operator|->
name|len
argument_list|)
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_RESET
argument_list|,
literal|"%s: [%d] uCode section being loaded...\n"
argument_list|,
name|__func__
argument_list|,
name|section_num
argument_list|)
expr_stmt|;
name|v_addr
operator|=
name|dma
operator|->
name|vaddr
expr_stmt|;
name|p_addr
operator|=
name|dma
operator|->
name|paddr
expr_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|section
operator|->
name|len
condition|;
name|offset
operator|+=
name|chunk_sz
control|)
block|{
name|uint32_t
name|copy_size
decl_stmt|,
name|dst_addr
decl_stmt|;
name|int
name|extended_addr
init|=
name|FALSE
decl_stmt|;
name|copy_size
operator|=
name|MIN
argument_list|(
name|chunk_sz
argument_list|,
name|section
operator|->
name|len
operator|-
name|offset
argument_list|)
expr_stmt|;
name|dst_addr
operator|=
name|section
operator|->
name|offset
operator|+
name|offset
expr_stmt|;
if|if
condition|(
name|dst_addr
operator|>=
name|IWM_FW_MEM_EXTENDED_START
operator|&&
name|dst_addr
operator|<=
name|IWM_FW_MEM_EXTENDED_END
condition|)
name|extended_addr
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|extended_addr
condition|)
name|iwm_set_bits_prph
argument_list|(
name|sc
argument_list|,
name|IWM_LMPM_CHICK
argument_list|,
name|IWM_LMPM_CHICK_EXTENDED_ADDR_SPACE
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|v_addr
argument_list|,
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
name|section
operator|->
name|data
operator|+
name|offset
argument_list|,
name|copy_size
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
name|dma
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|ret
operator|=
name|iwm_pcie_load_firmware_chunk
argument_list|(
name|sc
argument_list|,
name|dst_addr
argument_list|,
name|p_addr
argument_list|,
name|copy_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|extended_addr
condition|)
name|iwm_clear_bits_prph
argument_list|(
name|sc
argument_list|,
name|IWM_LMPM_CHICK
argument_list|,
name|IWM_LMPM_CHICK_EXTENDED_ADDR_SPACE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: Could not load the [%d] uCode section\n"
argument_list|,
name|__func__
argument_list|,
name|section_num
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * ucode  */
end_comment

begin_function
specifier|static
name|int
name|iwm_pcie_load_firmware_chunk
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|dst_addr
parameter_list|,
name|bus_addr_t
name|phy_addr
parameter_list|,
name|uint32_t
name|byte_cnt
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|sc
operator|->
name|sc_fw_chunk_done
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|iwm_nic_lock
argument_list|(
name|sc
argument_list|)
condition|)
return|return
name|EBUSY
return|;
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_FH_TCSR_CHNL_TX_CONFIG_REG
argument_list|(
name|IWM_FH_SRVC_CHNL
argument_list|)
argument_list|,
name|IWM_FH_TCSR_TX_CONFIG_REG_VAL_DMA_CHNL_PAUSE
argument_list|)
expr_stmt|;
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_FH_SRVC_CHNL_SRAM_ADDR_REG
argument_list|(
name|IWM_FH_SRVC_CHNL
argument_list|)
argument_list|,
name|dst_addr
argument_list|)
expr_stmt|;
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_FH_TFDIB_CTRL0_REG
argument_list|(
name|IWM_FH_SRVC_CHNL
argument_list|)
argument_list|,
name|phy_addr
operator|&
name|IWM_FH_MEM_TFDIB_DRAM_ADDR_LSB_MSK
argument_list|)
expr_stmt|;
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_FH_TFDIB_CTRL1_REG
argument_list|(
name|IWM_FH_SRVC_CHNL
argument_list|)
argument_list|,
operator|(
name|iwm_get_dma_hi_addr
argument_list|(
name|phy_addr
argument_list|)
operator|<<
name|IWM_FH_MEM_TFDIB_REG1_ADDR_BITSHIFT
operator|)
operator||
name|byte_cnt
argument_list|)
expr_stmt|;
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_FH_TCSR_CHNL_TX_BUF_STS_REG
argument_list|(
name|IWM_FH_SRVC_CHNL
argument_list|)
argument_list|,
literal|1
operator|<<
name|IWM_FH_TCSR_CHNL_TX_BUF_STS_REG_POS_TB_NUM
operator||
literal|1
operator|<<
name|IWM_FH_TCSR_CHNL_TX_BUF_STS_REG_POS_TB_IDX
operator||
name|IWM_FH_TCSR_CHNL_TX_BUF_STS_REG_VAL_TFDB_VALID
argument_list|)
expr_stmt|;
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_FH_TCSR_CHNL_TX_CONFIG_REG
argument_list|(
name|IWM_FH_SRVC_CHNL
argument_list|)
argument_list|,
name|IWM_FH_TCSR_TX_CONFIG_REG_VAL_DMA_CHNL_ENABLE
operator||
name|IWM_FH_TCSR_TX_CONFIG_REG_VAL_DMA_CREDIT_DISABLE
operator||
name|IWM_FH_TCSR_TX_CONFIG_REG_VAL_CIRQ_HOST_ENDTFD
argument_list|)
expr_stmt|;
name|iwm_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* wait up to 5s for this segment to load */
name|ret
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|sc
operator|->
name|sc_fw_chunk_done
condition|)
block|{
name|ret
operator|=
name|msleep
argument_list|(
operator|&
name|sc
operator|->
name|sc_fw
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|0
argument_list|,
literal|"iwmfw"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
break|break;
block|}
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"fw chunk addr 0x%x len %d failed to load\n"
argument_list|,
name|dst_addr
argument_list|,
name|byte_cnt
argument_list|)
expr_stmt|;
return|return
name|ETIMEDOUT
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_pcie_load_cpu_sections_8000
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|iwm_fw_sects
modifier|*
name|image
parameter_list|,
name|int
name|cpu
parameter_list|,
name|int
modifier|*
name|first_ucode_section
parameter_list|)
block|{
name|int
name|shift_param
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|,
name|sec_num
init|=
literal|0x1
decl_stmt|;
name|uint32_t
name|val
decl_stmt|,
name|last_read_idx
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|cpu
operator|==
literal|1
condition|)
block|{
name|shift_param
operator|=
literal|0
expr_stmt|;
operator|*
name|first_ucode_section
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|shift_param
operator|=
literal|16
expr_stmt|;
operator|(
operator|*
name|first_ucode_section
operator|)
operator|++
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
operator|*
name|first_ucode_section
init|;
name|i
operator|<
name|IWM_UCODE_SECTION_MAX
condition|;
name|i
operator|++
control|)
block|{
name|last_read_idx
operator|=
name|i
expr_stmt|;
comment|/* 		 * CPU1_CPU2_SEPARATOR_SECTION delimiter - separate between 		 * CPU1 to CPU2. 		 * PAGING_SEPARATOR_SECTION delimiter - separate between 		 * CPU2 non paged to CPU2 paging sec. 		 */
if|if
condition|(
operator|!
name|image
operator|->
name|fw_sect
index|[
name|i
index|]
operator|.
name|data
operator|||
name|image
operator|->
name|fw_sect
index|[
name|i
index|]
operator|.
name|offset
operator|==
name|IWM_CPU1_CPU2_SEPARATOR_SECTION
operator|||
name|image
operator|->
name|fw_sect
index|[
name|i
index|]
operator|.
name|offset
operator|==
name|IWM_PAGING_SEPARATOR_SECTION
condition|)
block|{
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_RESET
argument_list|,
literal|"Break since Data not valid or Empty section, sec = %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
name|ret
operator|=
name|iwm_pcie_load_section
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
operator|&
name|image
operator|->
name|fw_sect
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
comment|/* Notify the ucode of the loaded section number and status */
if|if
condition|(
name|iwm_nic_lock
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|val
operator|=
name|IWM_READ
argument_list|(
name|sc
argument_list|,
name|IWM_FH_UCODE_LOAD_STATUS
argument_list|)
expr_stmt|;
name|val
operator|=
name|val
operator||
operator|(
name|sec_num
operator|<<
name|shift_param
operator|)
expr_stmt|;
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_FH_UCODE_LOAD_STATUS
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|sec_num
operator|=
operator|(
name|sec_num
operator|<<
literal|1
operator|)
operator||
literal|0x1
expr_stmt|;
name|iwm_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|first_ucode_section
operator|=
name|last_read_idx
expr_stmt|;
name|iwm_enable_interrupts
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|iwm_nic_lock
argument_list|(
name|sc
argument_list|)
condition|)
block|{
if|if
condition|(
name|cpu
operator|==
literal|1
condition|)
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_FH_UCODE_LOAD_STATUS
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
else|else
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_FH_UCODE_LOAD_STATUS
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
name|iwm_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_pcie_load_cpu_sections
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|iwm_fw_sects
modifier|*
name|image
parameter_list|,
name|int
name|cpu
parameter_list|,
name|int
modifier|*
name|first_ucode_section
parameter_list|)
block|{
name|int
name|shift_param
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|uint32_t
name|last_read_idx
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|cpu
operator|==
literal|1
condition|)
block|{
name|shift_param
operator|=
literal|0
expr_stmt|;
operator|*
name|first_ucode_section
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|shift_param
operator|=
literal|16
expr_stmt|;
operator|(
operator|*
name|first_ucode_section
operator|)
operator|++
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
operator|*
name|first_ucode_section
init|;
name|i
operator|<
name|IWM_UCODE_SECTION_MAX
condition|;
name|i
operator|++
control|)
block|{
name|last_read_idx
operator|=
name|i
expr_stmt|;
comment|/* 		 * CPU1_CPU2_SEPARATOR_SECTION delimiter - separate between 		 * CPU1 to CPU2. 		 * PAGING_SEPARATOR_SECTION delimiter - separate between 		 * CPU2 non paged to CPU2 paging sec. 		 */
if|if
condition|(
operator|!
name|image
operator|->
name|fw_sect
index|[
name|i
index|]
operator|.
name|data
operator|||
name|image
operator|->
name|fw_sect
index|[
name|i
index|]
operator|.
name|offset
operator|==
name|IWM_CPU1_CPU2_SEPARATOR_SECTION
operator|||
name|image
operator|->
name|fw_sect
index|[
name|i
index|]
operator|.
name|offset
operator|==
name|IWM_PAGING_SEPARATOR_SECTION
condition|)
block|{
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_RESET
argument_list|,
literal|"Break since Data not valid or Empty section, sec = %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
name|ret
operator|=
name|iwm_pcie_load_section
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
operator|&
name|image
operator|->
name|fw_sect
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
operator|*
name|first_ucode_section
operator|=
name|last_read_idx
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_pcie_load_given_ucode
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|iwm_fw_sects
modifier|*
name|image
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|first_ucode_section
decl_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_RESET
argument_list|,
literal|"working with %s CPU\n"
argument_list|,
name|image
operator|->
name|is_dual_cpus
condition|?
literal|"Dual"
else|:
literal|"Single"
argument_list|)
expr_stmt|;
comment|/* load to FW the binary non secured sections of CPU1 */
name|ret
operator|=
name|iwm_pcie_load_cpu_sections
argument_list|(
name|sc
argument_list|,
name|image
argument_list|,
literal|1
argument_list|,
operator|&
name|first_ucode_section
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|image
operator|->
name|is_dual_cpus
condition|)
block|{
comment|/* set CPU2 header address */
if|if
condition|(
name|iwm_nic_lock
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|iwm_write_prph
argument_list|(
name|sc
argument_list|,
name|IWM_LMPM_SECURE_UCODE_LOAD_CPU2_HDR_ADDR
argument_list|,
name|IWM_LMPM_SECURE_CPU2_HDR_MEM_SPACE
argument_list|)
expr_stmt|;
name|iwm_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* load to FW the binary sections of CPU2 */
name|ret
operator|=
name|iwm_pcie_load_cpu_sections
argument_list|(
name|sc
argument_list|,
name|image
argument_list|,
literal|2
argument_list|,
operator|&
name|first_ucode_section
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
name|iwm_enable_interrupts
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* release CPU reset */
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_RESET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|iwm_pcie_load_given_ucode_8000
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|iwm_fw_sects
modifier|*
name|image
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|first_ucode_section
decl_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_RESET
argument_list|,
literal|"working with %s CPU\n"
argument_list|,
name|image
operator|->
name|is_dual_cpus
condition|?
literal|"Dual"
else|:
literal|"Single"
argument_list|)
expr_stmt|;
comment|/* configure the ucode to be ready to get the secured image */
comment|/* release CPU reset */
if|if
condition|(
name|iwm_nic_lock
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|iwm_write_prph
argument_list|(
name|sc
argument_list|,
name|IWM_RELEASE_CPU_RESET
argument_list|,
name|IWM_RELEASE_CPU_RESET_BIT
argument_list|)
expr_stmt|;
name|iwm_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* load to FW the binary Secured sections of CPU1 */
name|ret
operator|=
name|iwm_pcie_load_cpu_sections_8000
argument_list|(
name|sc
argument_list|,
name|image
argument_list|,
literal|1
argument_list|,
operator|&
name|first_ucode_section
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
comment|/* load to FW the binary sections of CPU2 */
return|return
name|iwm_pcie_load_cpu_sections_8000
argument_list|(
name|sc
argument_list|,
name|image
argument_list|,
literal|2
argument_list|,
operator|&
name|first_ucode_section
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* XXX Get rid of this definition */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|iwm_enable_fw_load_int
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_INTR
argument_list|,
literal|"Enabling FW load interrupt\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_intmask
operator|=
name|IWM_CSR_INT_BIT_FH_TX
expr_stmt|;
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_INT_MASK
argument_list|,
name|sc
operator|->
name|sc_intmask
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* XXX Add proper rfkill support code */
end_comment

begin_function
specifier|static
name|int
name|iwm_start_fw
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|iwm_fw_sects
modifier|*
name|fw
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
comment|/* This may fail if AMT took ownership of the device */
if|if
condition|(
name|iwm_prepare_card_hw
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: Exit HW not ready\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ret
operator|=
name|EIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_INT
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
name|iwm_disable_interrupts
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* make sure rfkill handshake bits are cleared */
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_UCODE_DRV_GP1_CLR
argument_list|,
name|IWM_CSR_UCODE_SW_BIT_RFKILL
argument_list|)
expr_stmt|;
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_UCODE_DRV_GP1_CLR
argument_list|,
name|IWM_CSR_UCODE_DRV_GP1_BIT_CMD_BLOCKED
argument_list|)
expr_stmt|;
comment|/* clear (again), then enable host interrupts */
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_INT
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
name|ret
operator|=
name|iwm_nic_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: Unable to init nic\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Now, we load the firmware and don't want to be interrupted, even 	 * by the RF-Kill interrupt (hence mask all the interrupt besides the 	 * FH_TX interrupt which is needed to load the firmware). If the 	 * RF-Kill switch is toggled, we will find out after having loaded 	 * the firmware and return the proper value to the caller. 	 */
name|iwm_enable_fw_load_int
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* really make sure rfkill handshake bits are cleared */
comment|/* maybe we should write a few times more?  just to make sure */
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_UCODE_DRV_GP1_CLR
argument_list|,
name|IWM_CSR_UCODE_SW_BIT_RFKILL
argument_list|)
expr_stmt|;
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_UCODE_DRV_GP1_CLR
argument_list|,
name|IWM_CSR_UCODE_SW_BIT_RFKILL
argument_list|)
expr_stmt|;
comment|/* Load the given image to the HW */
if|if
condition|(
name|sc
operator|->
name|cfg
operator|->
name|device_family
operator|==
name|IWM_DEVICE_FAMILY_8000
condition|)
name|ret
operator|=
name|iwm_pcie_load_given_ucode_8000
argument_list|(
name|sc
argument_list|,
name|fw
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|iwm_pcie_load_given_ucode
argument_list|(
name|sc
argument_list|,
name|fw
argument_list|)
expr_stmt|;
comment|/* XXX re-check RF-Kill state */
name|out
label|:
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_send_tx_ant_cfg
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|valid_tx_ant
parameter_list|)
block|{
name|struct
name|iwm_tx_ant_cfg_cmd
name|tx_ant_cmd
init|=
block|{
operator|.
name|valid
operator|=
name|htole32
argument_list|(
name|valid_tx_ant
argument_list|)
block|, 	}
decl_stmt|;
return|return
name|iwm_mvm_send_cmd_pdu
argument_list|(
name|sc
argument_list|,
name|IWM_TX_ANT_CONFIGURATION_CMD
argument_list|,
name|IWM_CMD_SYNC
argument_list|,
sizeof|sizeof
argument_list|(
name|tx_ant_cmd
argument_list|)
argument_list|,
operator|&
name|tx_ant_cmd
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* iwlwifi: mvm/fw.c */
end_comment

begin_function
specifier|static
name|int
name|iwm_send_phy_cfg_cmd
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|iwm_phy_cfg_cmd
name|phy_cfg_cmd
decl_stmt|;
name|enum
name|iwm_ucode_type
name|ucode_type
init|=
name|sc
operator|->
name|cur_ucode
decl_stmt|;
comment|/* Set parameters */
name|phy_cfg_cmd
operator|.
name|phy_cfg
operator|=
name|htole32
argument_list|(
name|iwm_mvm_get_phy_config
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|phy_cfg_cmd
operator|.
name|calib_control
operator|.
name|event_trigger
operator|=
name|sc
operator|->
name|sc_default_calib
index|[
name|ucode_type
index|]
operator|.
name|event_trigger
expr_stmt|;
name|phy_cfg_cmd
operator|.
name|calib_control
operator|.
name|flow_trigger
operator|=
name|sc
operator|->
name|sc_default_calib
index|[
name|ucode_type
index|]
operator|.
name|flow_trigger
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_CMD
operator||
name|IWM_DEBUG_RESET
argument_list|,
literal|"Sending Phy CFG command: 0x%x\n"
argument_list|,
name|phy_cfg_cmd
operator|.
name|phy_cfg
argument_list|)
expr_stmt|;
return|return
name|iwm_mvm_send_cmd_pdu
argument_list|(
name|sc
argument_list|,
name|IWM_PHY_CONFIGURATION_CMD
argument_list|,
name|IWM_CMD_SYNC
argument_list|,
sizeof|sizeof
argument_list|(
name|phy_cfg_cmd
argument_list|)
argument_list|,
operator|&
name|phy_cfg_cmd
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_alive_fn
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwm_rx_packet
modifier|*
name|pkt
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|iwm_mvm_alive_data
modifier|*
name|alive_data
init|=
name|data
decl_stmt|;
name|struct
name|iwm_mvm_alive_resp_ver1
modifier|*
name|palive1
decl_stmt|;
name|struct
name|iwm_mvm_alive_resp_ver2
modifier|*
name|palive2
decl_stmt|;
name|struct
name|iwm_mvm_alive_resp
modifier|*
name|palive
decl_stmt|;
if|if
condition|(
name|iwm_rx_packet_payload_len
argument_list|(
name|pkt
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
operator|*
name|palive1
argument_list|)
condition|)
block|{
name|palive1
operator|=
operator|(
name|void
operator|*
operator|)
name|pkt
operator|->
name|data
expr_stmt|;
name|sc
operator|->
name|support_umac_log
operator|=
name|FALSE
expr_stmt|;
name|sc
operator|->
name|error_event_table
operator|=
name|le32toh
argument_list|(
name|palive1
operator|->
name|error_event_table_ptr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|log_event_table
operator|=
name|le32toh
argument_list|(
name|palive1
operator|->
name|log_event_table_ptr
argument_list|)
expr_stmt|;
name|alive_data
operator|->
name|scd_base_addr
operator|=
name|le32toh
argument_list|(
name|palive1
operator|->
name|scd_base_ptr
argument_list|)
expr_stmt|;
name|alive_data
operator|->
name|valid
operator|=
name|le16toh
argument_list|(
name|palive1
operator|->
name|status
argument_list|)
operator|==
name|IWM_ALIVE_STATUS_OK
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_RESET
argument_list|,
literal|"Alive VER1 ucode status 0x%04x revision 0x%01X 0x%01X flags 0x%01X\n"
argument_list|,
name|le16toh
argument_list|(
name|palive1
operator|->
name|status
argument_list|)
argument_list|,
name|palive1
operator|->
name|ver_type
argument_list|,
name|palive1
operator|->
name|ver_subtype
argument_list|,
name|palive1
operator|->
name|flags
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iwm_rx_packet_payload_len
argument_list|(
name|pkt
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
operator|*
name|palive2
argument_list|)
condition|)
block|{
name|palive2
operator|=
operator|(
name|void
operator|*
operator|)
name|pkt
operator|->
name|data
expr_stmt|;
name|sc
operator|->
name|error_event_table
operator|=
name|le32toh
argument_list|(
name|palive2
operator|->
name|error_event_table_ptr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|log_event_table
operator|=
name|le32toh
argument_list|(
name|palive2
operator|->
name|log_event_table_ptr
argument_list|)
expr_stmt|;
name|alive_data
operator|->
name|scd_base_addr
operator|=
name|le32toh
argument_list|(
name|palive2
operator|->
name|scd_base_ptr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|umac_error_event_table
operator|=
name|le32toh
argument_list|(
name|palive2
operator|->
name|error_info_addr
argument_list|)
expr_stmt|;
name|alive_data
operator|->
name|valid
operator|=
name|le16toh
argument_list|(
name|palive2
operator|->
name|status
argument_list|)
operator|==
name|IWM_ALIVE_STATUS_OK
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|umac_error_event_table
condition|)
name|sc
operator|->
name|support_umac_log
operator|=
name|TRUE
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_RESET
argument_list|,
literal|"Alive VER2 ucode status 0x%04x revision 0x%01X 0x%01X flags 0x%01X\n"
argument_list|,
name|le16toh
argument_list|(
name|palive2
operator|->
name|status
argument_list|)
argument_list|,
name|palive2
operator|->
name|ver_type
argument_list|,
name|palive2
operator|->
name|ver_subtype
argument_list|,
name|palive2
operator|->
name|flags
argument_list|)
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_RESET
argument_list|,
literal|"UMAC version: Major - 0x%x, Minor - 0x%x\n"
argument_list|,
name|palive2
operator|->
name|umac_major
argument_list|,
name|palive2
operator|->
name|umac_minor
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iwm_rx_packet_payload_len
argument_list|(
name|pkt
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
operator|*
name|palive
argument_list|)
condition|)
block|{
name|palive
operator|=
operator|(
name|void
operator|*
operator|)
name|pkt
operator|->
name|data
expr_stmt|;
name|sc
operator|->
name|error_event_table
operator|=
name|le32toh
argument_list|(
name|palive
operator|->
name|error_event_table_ptr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|log_event_table
operator|=
name|le32toh
argument_list|(
name|palive
operator|->
name|log_event_table_ptr
argument_list|)
expr_stmt|;
name|alive_data
operator|->
name|scd_base_addr
operator|=
name|le32toh
argument_list|(
name|palive
operator|->
name|scd_base_ptr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|umac_error_event_table
operator|=
name|le32toh
argument_list|(
name|palive
operator|->
name|error_info_addr
argument_list|)
expr_stmt|;
name|alive_data
operator|->
name|valid
operator|=
name|le16toh
argument_list|(
name|palive
operator|->
name|status
argument_list|)
operator|==
name|IWM_ALIVE_STATUS_OK
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|umac_error_event_table
condition|)
name|sc
operator|->
name|support_umac_log
operator|=
name|TRUE
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_RESET
argument_list|,
literal|"Alive VER3 ucode status 0x%04x revision 0x%01X 0x%01X flags 0x%01X\n"
argument_list|,
name|le16toh
argument_list|(
name|palive
operator|->
name|status
argument_list|)
argument_list|,
name|palive
operator|->
name|ver_type
argument_list|,
name|palive
operator|->
name|ver_subtype
argument_list|,
name|palive
operator|->
name|flags
argument_list|)
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_RESET
argument_list|,
literal|"UMAC version: Major - 0x%x, Minor - 0x%x\n"
argument_list|,
name|le32toh
argument_list|(
name|palive
operator|->
name|umac_major
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|palive
operator|->
name|umac_minor
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_wait_phy_db_entry
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwm_rx_packet
modifier|*
name|pkt
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|iwm_phy_db
modifier|*
name|phy_db
init|=
name|data
decl_stmt|;
if|if
condition|(
name|pkt
operator|->
name|hdr
operator|.
name|code
operator|!=
name|IWM_CALIB_RES_NOTIF_PHY_DB
condition|)
block|{
if|if
condition|(
name|pkt
operator|->
name|hdr
operator|.
name|code
operator|!=
name|IWM_INIT_COMPLETE_NOTIF
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: Unexpected cmd: %d\n"
argument_list|,
name|__func__
argument_list|,
name|pkt
operator|->
name|hdr
operator|.
name|code
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|iwm_phy_db_set_section
argument_list|(
name|phy_db
argument_list|,
name|pkt
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: iwm_phy_db_set_section failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_mvm_load_ucode_wait_alive
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|enum
name|iwm_ucode_type
name|ucode_type
parameter_list|)
block|{
name|struct
name|iwm_notification_wait
name|alive_wait
decl_stmt|;
name|struct
name|iwm_mvm_alive_data
name|alive_data
decl_stmt|;
specifier|const
name|struct
name|iwm_fw_sects
modifier|*
name|fw
decl_stmt|;
name|enum
name|iwm_ucode_type
name|old_type
init|=
name|sc
operator|->
name|cur_ucode
decl_stmt|;
name|int
name|error
decl_stmt|;
specifier|static
specifier|const
name|uint16_t
name|alive_cmd
index|[]
init|=
block|{
name|IWM_MVM_ALIVE
block|}
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_read_firmware
argument_list|(
name|sc
argument_list|,
name|ucode_type
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"iwm_read_firmware: failed %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|fw
operator|=
operator|&
name|sc
operator|->
name|sc_fw
operator|.
name|fw_sects
index|[
name|ucode_type
index|]
expr_stmt|;
name|sc
operator|->
name|cur_ucode
operator|=
name|ucode_type
expr_stmt|;
name|sc
operator|->
name|ucode_loaded
operator|=
name|FALSE
expr_stmt|;
name|memset
argument_list|(
operator|&
name|alive_data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|alive_data
argument_list|)
argument_list|)
expr_stmt|;
name|iwm_init_notification_wait
argument_list|(
name|sc
operator|->
name|sc_notif_wait
argument_list|,
operator|&
name|alive_wait
argument_list|,
name|alive_cmd
argument_list|,
name|nitems
argument_list|(
name|alive_cmd
argument_list|)
argument_list|,
name|iwm_alive_fn
argument_list|,
operator|&
name|alive_data
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwm_start_fw
argument_list|(
name|sc
argument_list|,
name|fw
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"iwm_start_fw: failed %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|sc
operator|->
name|cur_ucode
operator|=
name|old_type
expr_stmt|;
name|iwm_remove_notification
argument_list|(
name|sc
operator|->
name|sc_notif_wait
argument_list|,
operator|&
name|alive_wait
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* 	 * Some things may run in the background now, but we 	 * just wait for the ALIVE notification here. 	 */
name|IWM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwm_wait_notification
argument_list|(
name|sc
operator|->
name|sc_notif_wait
argument_list|,
operator|&
name|alive_wait
argument_list|,
name|IWM_MVM_UCODE_ALIVE_TIMEOUT
argument_list|)
expr_stmt|;
name|IWM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|cfg
operator|->
name|device_family
operator|==
name|IWM_DEVICE_FAMILY_8000
condition|)
block|{
name|uint32_t
name|a
init|=
literal|0x5a5a5a5a
decl_stmt|,
name|b
init|=
literal|0x5a5a5a5a
decl_stmt|;
if|if
condition|(
name|iwm_nic_lock
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|a
operator|=
name|iwm_read_prph
argument_list|(
name|sc
argument_list|,
name|IWM_SB_CPU_1_STATUS
argument_list|)
expr_stmt|;
name|b
operator|=
name|iwm_read_prph
argument_list|(
name|sc
argument_list|,
name|IWM_SB_CPU_2_STATUS
argument_list|)
expr_stmt|;
name|iwm_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"SecBoot CPU1 Status: 0x%x, CPU2 Status: 0x%x\n"
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|cur_ucode
operator|=
name|old_type
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
operator|!
name|alive_data
operator|.
name|valid
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: Loaded ucode is not valid\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|cur_ucode
operator|=
name|old_type
expr_stmt|;
return|return
name|EIO
return|;
block|}
name|iwm_trans_pcie_fw_alive
argument_list|(
name|sc
argument_list|,
name|alive_data
operator|.
name|scd_base_addr
argument_list|)
expr_stmt|;
comment|/* 	 * configure and operate fw paging mechanism. 	 * driver configures the paging flow only once, CPU2 paging image 	 * included in the IWM_UCODE_INIT image. 	 */
if|if
condition|(
name|fw
operator|->
name|paging_mem_size
condition|)
block|{
name|error
operator|=
name|iwm_save_fw_paging
argument_list|(
name|sc
argument_list|,
name|fw
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: failed to save the FW paging image\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|error
operator|=
name|iwm_send_paging_cmd
argument_list|(
name|sc
argument_list|,
name|fw
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: failed to send the paging cmd\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|iwm_free_fw_paging
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
if|if
condition|(
operator|!
name|error
condition|)
name|sc
operator|->
name|ucode_loaded
operator|=
name|TRUE
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * mvm misc bits  */
end_comment

begin_comment
comment|/*  * follows iwlwifi/fw.c  */
end_comment

begin_function
specifier|static
name|int
name|iwm_run_init_mvm_ucode
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|int
name|justnvm
parameter_list|)
block|{
name|struct
name|iwm_notification_wait
name|calib_wait
decl_stmt|;
specifier|static
specifier|const
name|uint16_t
name|init_complete
index|[]
init|=
block|{
name|IWM_INIT_COMPLETE_NOTIF
block|,
name|IWM_CALIB_RES_NOTIF_PHY_DB
block|}
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* do not operate with rfkill switch turned on */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWM_FLAG_RFKILL
operator|)
operator|&&
operator|!
name|justnvm
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"radio is disabled by hardware switch\n"
argument_list|)
expr_stmt|;
return|return
name|EPERM
return|;
block|}
name|iwm_init_notification_wait
argument_list|(
name|sc
operator|->
name|sc_notif_wait
argument_list|,
operator|&
name|calib_wait
argument_list|,
name|init_complete
argument_list|,
name|nitems
argument_list|(
name|init_complete
argument_list|)
argument_list|,
name|iwm_wait_phy_db_entry
argument_list|,
name|sc
operator|->
name|sc_phy_db
argument_list|)
expr_stmt|;
comment|/* Will also start the device */
name|ret
operator|=
name|iwm_mvm_load_ucode_wait_alive
argument_list|(
name|sc
argument_list|,
name|IWM_UCODE_INIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Failed to start INIT ucode: %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|justnvm
condition|)
block|{
comment|/* Read nvm */
name|ret
operator|=
name|iwm_nvm_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"failed to read nvm\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|IEEE80211_ADDR_COPY
argument_list|(
name|sc
operator|->
name|sc_ic
operator|.
name|ic_macaddr
argument_list|,
name|sc
operator|->
name|nvm_data
operator|->
name|hw_addr
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|ret
operator|=
name|iwm_send_bt_init_conf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"failed to send bt coex configuration: %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* Send TX valid antennas before triggering calibrations */
name|ret
operator|=
name|iwm_send_tx_ant_cfg
argument_list|(
name|sc
argument_list|,
name|iwm_mvm_get_valid_tx_ant
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"failed to send antennas before calibration: %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* 	 * Send phy configurations command to init uCode 	 * to start the 16.0 uCode init image internal calibrations. 	 */
name|ret
operator|=
name|iwm_send_phy_cfg_cmd
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: Failed to run INIT calibrations: %d\n"
argument_list|,
name|__func__
argument_list|,
name|ret
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* 	 * Nothing to do but wait for the init complete notification 	 * from the firmware. 	 */
name|IWM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ret
operator|=
name|iwm_wait_notification
argument_list|(
name|sc
operator|->
name|sc_notif_wait
argument_list|,
operator|&
name|calib_wait
argument_list|,
name|IWM_MVM_UCODE_CALIB_TIMEOUT
argument_list|)
expr_stmt|;
name|IWM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
name|error
label|:
name|iwm_remove_notification
argument_list|(
name|sc
operator|->
name|sc_notif_wait
argument_list|,
operator|&
name|calib_wait
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * receive side  */
end_comment

begin_comment
comment|/* (re)stock rx ring, called at init-time and at runtime */
end_comment

begin_function
specifier|static
name|int
name|iwm_rx_addbuf
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|struct
name|iwm_rx_ring
modifier|*
name|ring
init|=
operator|&
name|sc
operator|->
name|rxq
decl_stmt|;
name|struct
name|iwm_rx_data
modifier|*
name|data
init|=
operator|&
name|ring
operator|->
name|data
index|[
name|idx
index|]
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|bus_dmamap_t
name|dmamap
decl_stmt|;
name|bus_dma_segment_t
name|seg
decl_stmt|;
name|int
name|nsegs
decl_stmt|,
name|error
decl_stmt|;
name|m
operator|=
name|m_getjcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|,
name|IWM_RBUF_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|ENOBUFS
return|;
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_ext
operator|.
name|ext_size
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|ring
operator|->
name|spare_map
argument_list|,
name|m
argument_list|,
operator|&
name|seg
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: can't map mbuf, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
name|data
operator|->
name|m
operator|!=
name|NULL
condition|)
name|bus_dmamap_unload
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
comment|/* Swap ring->spare_map with data->map */
name|dmamap
operator|=
name|data
operator|->
name|map
expr_stmt|;
name|data
operator|->
name|map
operator|=
name|ring
operator|->
name|spare_map
expr_stmt|;
name|ring
operator|->
name|spare_map
operator|=
name|dmamap
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|data
operator|->
name|m
operator|=
name|m
expr_stmt|;
comment|/* Update RX descriptor. */
name|KASSERT
argument_list|(
operator|(
name|seg
operator|.
name|ds_addr
operator|&
literal|255
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"seg.ds_addr not aligned"
operator|)
argument_list|)
expr_stmt|;
name|ring
operator|->
name|desc
index|[
name|idx
index|]
operator|=
name|htole32
argument_list|(
name|seg
operator|.
name|ds_addr
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|desc_dma
operator|.
name|tag
argument_list|,
name|ring
operator|->
name|desc_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* iwlwifi: mvm/rx.c */
end_comment

begin_comment
comment|/*  * iwm_mvm_get_signal_strength - use new rx PHY INFO API  * values are reported by the fw as positive values - need to negate  * to obtain their dBM.  Account for missing antennas by replacing 0  * values by -256dBm: practically 0 power and a non-feasible 8 bit value.  */
end_comment

begin_function
specifier|static
name|int
name|iwm_mvm_get_signal_strength
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwm_rx_phy_info
modifier|*
name|phy_info
parameter_list|)
block|{
name|int
name|energy_a
decl_stmt|,
name|energy_b
decl_stmt|,
name|energy_c
decl_stmt|,
name|max_energy
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|val
operator|=
name|le32toh
argument_list|(
name|phy_info
operator|->
name|non_cfg_phy
index|[
name|IWM_RX_INFO_ENERGY_ANT_ABC_IDX
index|]
argument_list|)
expr_stmt|;
name|energy_a
operator|=
operator|(
name|val
operator|&
name|IWM_RX_INFO_ENERGY_ANT_A_MSK
operator|)
operator|>>
name|IWM_RX_INFO_ENERGY_ANT_A_POS
expr_stmt|;
name|energy_a
operator|=
name|energy_a
condition|?
operator|-
name|energy_a
else|:
operator|-
literal|256
expr_stmt|;
name|energy_b
operator|=
operator|(
name|val
operator|&
name|IWM_RX_INFO_ENERGY_ANT_B_MSK
operator|)
operator|>>
name|IWM_RX_INFO_ENERGY_ANT_B_POS
expr_stmt|;
name|energy_b
operator|=
name|energy_b
condition|?
operator|-
name|energy_b
else|:
operator|-
literal|256
expr_stmt|;
name|energy_c
operator|=
operator|(
name|val
operator|&
name|IWM_RX_INFO_ENERGY_ANT_C_MSK
operator|)
operator|>>
name|IWM_RX_INFO_ENERGY_ANT_C_POS
expr_stmt|;
name|energy_c
operator|=
name|energy_c
condition|?
operator|-
name|energy_c
else|:
operator|-
literal|256
expr_stmt|;
name|max_energy
operator|=
name|MAX
argument_list|(
name|energy_a
argument_list|,
name|energy_b
argument_list|)
expr_stmt|;
name|max_energy
operator|=
name|MAX
argument_list|(
name|max_energy
argument_list|,
name|energy_c
argument_list|)
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_RECV
argument_list|,
literal|"energy In A %d B %d C %d , and max %d\n"
argument_list|,
name|energy_a
argument_list|,
name|energy_b
argument_list|,
name|energy_c
argument_list|,
name|max_energy
argument_list|)
expr_stmt|;
return|return
name|max_energy
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_mvm_rx_rx_phy_cmd
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwm_rx_packet
modifier|*
name|pkt
parameter_list|)
block|{
name|struct
name|iwm_rx_phy_info
modifier|*
name|phy_info
init|=
operator|(
name|void
operator|*
operator|)
name|pkt
operator|->
name|data
decl_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_RECV
argument_list|,
literal|"received PHY stats\n"
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sc
operator|->
name|sc_last_phy_info
argument_list|,
name|phy_info
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_last_phy_info
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Retrieve the average noise (in dBm) among receivers.  */
end_comment

begin_function
specifier|static
name|int
name|iwm_get_noise
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|iwm_mvm_statistics_rx_non_phy
modifier|*
name|stats
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|total
decl_stmt|,
name|nbant
decl_stmt|,
name|noise
decl_stmt|;
name|total
operator|=
name|nbant
operator|=
name|noise
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|noise
operator|=
name|le32toh
argument_list|(
name|stats
operator|->
name|beacon_silence_rssi
index|[
name|i
index|]
argument_list|)
operator|&
literal|0xff
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_RECV
argument_list|,
literal|"%s: i=%d, noise=%d\n"
argument_list|,
name|__func__
argument_list|,
name|i
argument_list|,
name|noise
argument_list|)
expr_stmt|;
if|if
condition|(
name|noise
condition|)
block|{
name|total
operator|+=
name|noise
expr_stmt|;
name|nbant
operator|++
expr_stmt|;
block|}
block|}
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_RECV
argument_list|,
literal|"%s: nbant=%d, total=%d\n"
argument_list|,
name|__func__
argument_list|,
name|nbant
argument_list|,
name|total
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* There should be at least one antenna but check anyway. */
block|return (nbant == 0) ? -127 : (total / nbant) - 107;
else|#
directive|else
comment|/* For now, just hard-code it to -96 to be safe */
return|return
operator|(
operator|-
literal|96
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * iwm_mvm_rx_rx_mpdu - IWM_REPLY_RX_MPDU_CMD handler  *  * Handles the actual data of the Rx packet from the fw  */
end_comment

begin_function
specifier|static
name|boolean_t
name|iwm_mvm_rx_rx_mpdu
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|uint32_t
name|offset
parameter_list|,
name|boolean_t
name|stolen
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|struct
name|ieee80211_rx_stats
name|rxs
decl_stmt|;
name|struct
name|iwm_rx_phy_info
modifier|*
name|phy_info
decl_stmt|;
name|struct
name|iwm_rx_mpdu_res_start
modifier|*
name|rx_res
decl_stmt|;
name|struct
name|iwm_rx_packet
modifier|*
name|pkt
init|=
name|mtodoff
argument_list|(
name|m
argument_list|,
expr|struct
name|iwm_rx_packet
operator|*
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|uint32_t
name|len
decl_stmt|;
name|uint32_t
name|rx_pkt_status
decl_stmt|;
name|int
name|rssi
decl_stmt|;
name|phy_info
operator|=
operator|&
name|sc
operator|->
name|sc_last_phy_info
expr_stmt|;
name|rx_res
operator|=
operator|(
expr|struct
name|iwm_rx_mpdu_res_start
operator|*
operator|)
name|pkt
operator|->
name|data
expr_stmt|;
name|wh
operator|=
operator|(
expr|struct
name|ieee80211_frame
operator|*
operator|)
operator|(
name|pkt
operator|->
name|data
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|rx_res
argument_list|)
operator|)
expr_stmt|;
name|len
operator|=
name|le16toh
argument_list|(
name|rx_res
operator|->
name|byte_count
argument_list|)
expr_stmt|;
name|rx_pkt_status
operator|=
name|le32toh
argument_list|(
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|pkt
operator|->
name|data
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|rx_res
argument_list|)
operator|+
name|len
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|phy_info
operator|->
name|cfg_phy_cnt
operator|>
literal|20
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"dsp size out of range [0,20]: %d\n"
argument_list|,
name|phy_info
operator|->
name|cfg_phy_cnt
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|rx_pkt_status
operator|&
name|IWM_RX_MPDU_RES_STATUS_CRC_OK
operator|)
operator|||
operator|!
operator|(
name|rx_pkt_status
operator|&
name|IWM_RX_MPDU_RES_STATUS_OVERRUN_OK
operator|)
condition|)
block|{
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_RECV
argument_list|,
literal|"Bad CRC or FIFO: 0x%08X.\n"
argument_list|,
name|rx_pkt_status
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|rssi
operator|=
name|iwm_mvm_get_signal_strength
argument_list|(
name|sc
argument_list|,
name|phy_info
argument_list|)
expr_stmt|;
comment|/* Map it to relative value */
name|rssi
operator|=
name|rssi
operator|-
name|sc
operator|->
name|sc_noise
expr_stmt|;
comment|/* replenish ring for the buffer we're going to feed to the sharks */
if|if
condition|(
operator|!
name|stolen
operator|&&
name|iwm_rx_addbuf
argument_list|(
name|sc
argument_list|,
name|IWM_RBUF_SIZE
argument_list|,
name|sc
operator|->
name|rxq
operator|.
name|cur
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: unable to add more buffers\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|m
operator|->
name|m_data
operator|=
name|pkt
operator|->
name|data
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|rx_res
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_RECV
argument_list|,
literal|"%s: rssi=%d, noise=%d\n"
argument_list|,
name|__func__
argument_list|,
name|rssi
argument_list|,
name|sc
operator|->
name|sc_noise
argument_list|)
expr_stmt|;
name|ni
operator|=
name|ieee80211_find_rxnode
argument_list|(
name|ic
argument_list|,
operator|(
expr|struct
name|ieee80211_frame_min
operator|*
operator|)
name|wh
argument_list|)
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_RECV
argument_list|,
literal|"%s: phy_info: channel=%d, flags=0x%08x\n"
argument_list|,
name|__func__
argument_list|,
name|le16toh
argument_list|(
name|phy_info
operator|->
name|channel
argument_list|)
argument_list|,
name|le16toh
argument_list|(
name|phy_info
operator|->
name|phy_flags
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Populate an RX state struct with the provided information. 	 */
name|bzero
argument_list|(
operator|&
name|rxs
argument_list|,
sizeof|sizeof
argument_list|(
name|rxs
argument_list|)
argument_list|)
expr_stmt|;
name|rxs
operator|.
name|r_flags
operator||=
name|IEEE80211_R_IEEE
operator||
name|IEEE80211_R_FREQ
expr_stmt|;
name|rxs
operator|.
name|r_flags
operator||=
name|IEEE80211_R_NF
operator||
name|IEEE80211_R_RSSI
expr_stmt|;
name|rxs
operator|.
name|c_ieee
operator|=
name|le16toh
argument_list|(
name|phy_info
operator|->
name|channel
argument_list|)
expr_stmt|;
if|if
condition|(
name|le16toh
argument_list|(
name|phy_info
operator|->
name|phy_flags
operator|&
name|IWM_RX_RES_PHY_FLAGS_BAND_24
argument_list|)
condition|)
block|{
name|rxs
operator|.
name|c_freq
operator|=
name|ieee80211_ieee2mhz
argument_list|(
name|rxs
operator|.
name|c_ieee
argument_list|,
name|IEEE80211_CHAN_2GHZ
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rxs
operator|.
name|c_freq
operator|=
name|ieee80211_ieee2mhz
argument_list|(
name|rxs
operator|.
name|c_ieee
argument_list|,
name|IEEE80211_CHAN_5GHZ
argument_list|)
expr_stmt|;
block|}
comment|/* rssi is in 1/2db units */
name|rxs
operator|.
name|c_rssi
operator|=
name|rssi
operator|*
literal|2
expr_stmt|;
name|rxs
operator|.
name|c_nf
operator|=
name|sc
operator|->
name|sc_noise
expr_stmt|;
if|if
condition|(
name|ieee80211_add_rx_params
argument_list|(
name|m
argument_list|,
operator|&
name|rxs
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ni
condition|)
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|ieee80211_radiotap_active_vap
argument_list|(
name|vap
argument_list|)
condition|)
block|{
name|struct
name|iwm_rx_radiotap_header
modifier|*
name|tap
init|=
operator|&
name|sc
operator|->
name|sc_rxtap
decl_stmt|;
name|tap
operator|->
name|wr_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|phy_info
operator|->
name|phy_flags
operator|&
name|htole16
argument_list|(
name|IWM_PHY_INFO_FLAG_SHPREAMBLE
argument_list|)
condition|)
name|tap
operator|->
name|wr_flags
operator||=
name|IEEE80211_RADIOTAP_F_SHORTPRE
expr_stmt|;
name|tap
operator|->
name|wr_chan_freq
operator|=
name|htole16
argument_list|(
name|rxs
operator|.
name|c_freq
argument_list|)
expr_stmt|;
comment|/* XXX only if ic->ic_curchan->ic_ieee == rxs.c_ieee */
name|tap
operator|->
name|wr_chan_flags
operator|=
name|htole16
argument_list|(
name|ic
operator|->
name|ic_curchan
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
name|tap
operator|->
name|wr_dbm_antsignal
operator|=
operator|(
name|int8_t
operator|)
name|rssi
expr_stmt|;
name|tap
operator|->
name|wr_dbm_antnoise
operator|=
operator|(
name|int8_t
operator|)
name|sc
operator|->
name|sc_noise
expr_stmt|;
name|tap
operator|->
name|wr_tsft
operator|=
name|phy_info
operator|->
name|system_timestamp
expr_stmt|;
switch|switch
condition|(
name|phy_info
operator|->
name|rate
condition|)
block|{
comment|/* CCK rates. */
case|case
literal|10
case|:
name|tap
operator|->
name|wr_rate
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|20
case|:
name|tap
operator|->
name|wr_rate
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|55
case|:
name|tap
operator|->
name|wr_rate
operator|=
literal|11
expr_stmt|;
break|break;
case|case
literal|110
case|:
name|tap
operator|->
name|wr_rate
operator|=
literal|22
expr_stmt|;
break|break;
comment|/* OFDM rates. */
case|case
literal|0xd
case|:
name|tap
operator|->
name|wr_rate
operator|=
literal|12
expr_stmt|;
break|break;
case|case
literal|0xf
case|:
name|tap
operator|->
name|wr_rate
operator|=
literal|18
expr_stmt|;
break|break;
case|case
literal|0x5
case|:
name|tap
operator|->
name|wr_rate
operator|=
literal|24
expr_stmt|;
break|break;
case|case
literal|0x7
case|:
name|tap
operator|->
name|wr_rate
operator|=
literal|36
expr_stmt|;
break|break;
case|case
literal|0x9
case|:
name|tap
operator|->
name|wr_rate
operator|=
literal|48
expr_stmt|;
break|break;
case|case
literal|0xb
case|:
name|tap
operator|->
name|wr_rate
operator|=
literal|72
expr_stmt|;
break|break;
case|case
literal|0x1
case|:
name|tap
operator|->
name|wr_rate
operator|=
literal|96
expr_stmt|;
break|break;
case|case
literal|0x3
case|:
name|tap
operator|->
name|wr_rate
operator|=
literal|108
expr_stmt|;
break|break;
comment|/* Unknown rate: should not happen. */
default|default:
name|tap
operator|->
name|wr_rate
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|IWM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_RECV
argument_list|,
literal|"input m %p\n"
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|ieee80211_input_mimo
argument_list|(
name|ni
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_RECV
argument_list|,
literal|"inputall m %p\n"
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|ieee80211_input_mimo_all
argument_list|(
name|ic
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
name|IWM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
name|fail
label|:
name|counter_u64_add
argument_list|(
name|ic
operator|->
name|ic_ierrors
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_mvm_rx_tx_cmd_single
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwm_rx_packet
modifier|*
name|pkt
parameter_list|,
name|struct
name|iwm_node
modifier|*
name|in
parameter_list|)
block|{
name|struct
name|iwm_mvm_tx_resp
modifier|*
name|tx_resp
init|=
operator|(
name|void
operator|*
operator|)
name|pkt
operator|->
name|data
decl_stmt|;
name|struct
name|ieee80211_ratectl_tx_status
modifier|*
name|txs
init|=
operator|&
name|sc
operator|->
name|sc_txs
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
operator|&
name|in
operator|->
name|in_ni
decl_stmt|;
name|int
name|status
init|=
name|le16toh
argument_list|(
name|tx_resp
operator|->
name|status
operator|.
name|status
argument_list|)
operator|&
name|IWM_TX_STATUS_MSK
decl_stmt|;
name|KASSERT
argument_list|(
name|tx_resp
operator|->
name|frame_count
operator|==
literal|1
argument_list|,
operator|(
literal|"too many frames"
operator|)
argument_list|)
expr_stmt|;
comment|/* Update rate control statistics. */
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_XMIT
argument_list|,
literal|"%s: status=0x%04x, seq=%d, fc=%d, btc=%d, frts=%d, ff=%d, irate=%08x, wmt=%d\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|int
operator|)
name|le16toh
argument_list|(
name|tx_resp
operator|->
name|status
operator|.
name|status
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|le16toh
argument_list|(
name|tx_resp
operator|->
name|status
operator|.
name|sequence
argument_list|)
argument_list|,
name|tx_resp
operator|->
name|frame_count
argument_list|,
name|tx_resp
operator|->
name|bt_kill_count
argument_list|,
name|tx_resp
operator|->
name|failure_rts
argument_list|,
name|tx_resp
operator|->
name|failure_frame
argument_list|,
name|le32toh
argument_list|(
name|tx_resp
operator|->
name|initial_rate
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|le16toh
argument_list|(
name|tx_resp
operator|->
name|wireless_media_time
argument_list|)
argument_list|)
expr_stmt|;
name|txs
operator|->
name|flags
operator|=
name|IEEE80211_RATECTL_STATUS_SHORT_RETRY
operator||
name|IEEE80211_RATECTL_STATUS_LONG_RETRY
expr_stmt|;
name|txs
operator|->
name|short_retries
operator|=
name|tx_resp
operator|->
name|failure_rts
expr_stmt|;
name|txs
operator|->
name|long_retries
operator|=
name|tx_resp
operator|->
name|failure_frame
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IWM_TX_STATUS_SUCCESS
operator|&&
name|status
operator|!=
name|IWM_TX_STATUS_DIRECT_DONE
condition|)
block|{
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|IWM_TX_STATUS_FAIL_SHORT_LIMIT
case|:
name|txs
operator|->
name|status
operator|=
name|IEEE80211_RATECTL_TX_FAIL_SHORT
expr_stmt|;
break|break;
case|case
name|IWM_TX_STATUS_FAIL_LONG_LIMIT
case|:
name|txs
operator|->
name|status
operator|=
name|IEEE80211_RATECTL_TX_FAIL_LONG
expr_stmt|;
break|break;
case|case
name|IWM_TX_STATUS_FAIL_LIFE_EXPIRE
case|:
name|txs
operator|->
name|status
operator|=
name|IEEE80211_RATECTL_TX_FAIL_EXPIRED
expr_stmt|;
break|break;
default|default:
name|txs
operator|->
name|status
operator|=
name|IEEE80211_RATECTL_TX_FAIL_UNSPECIFIED
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|txs
operator|->
name|status
operator|=
name|IEEE80211_RATECTL_TX_SUCCESS
expr_stmt|;
block|}
name|ieee80211_ratectl_tx_complete
argument_list|(
name|ni
argument_list|,
name|txs
argument_list|)
expr_stmt|;
return|return
operator|(
name|txs
operator|->
name|status
operator|!=
name|IEEE80211_RATECTL_TX_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_mvm_rx_tx_cmd
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwm_rx_packet
modifier|*
name|pkt
parameter_list|)
block|{
name|struct
name|iwm_cmd_header
modifier|*
name|cmd_hdr
init|=
operator|&
name|pkt
operator|->
name|hdr
decl_stmt|;
name|int
name|idx
init|=
name|cmd_hdr
operator|->
name|idx
decl_stmt|;
name|int
name|qid
init|=
name|cmd_hdr
operator|->
name|qid
decl_stmt|;
name|struct
name|iwm_tx_ring
modifier|*
name|ring
init|=
operator|&
name|sc
operator|->
name|txq
index|[
name|qid
index|]
decl_stmt|;
name|struct
name|iwm_tx_data
modifier|*
name|txd
init|=
operator|&
name|ring
operator|->
name|data
index|[
name|idx
index|]
decl_stmt|;
name|struct
name|iwm_node
modifier|*
name|in
init|=
name|txd
operator|->
name|in
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
name|txd
operator|->
name|m
decl_stmt|;
name|int
name|status
decl_stmt|;
name|KASSERT
argument_list|(
name|txd
operator|->
name|done
operator|==
literal|0
argument_list|,
operator|(
literal|"txd not done"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|txd
operator|->
name|in
operator|!=
name|NULL
argument_list|,
operator|(
literal|"txd without node"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|txd
operator|->
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"txd without mbuf"
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tx_timer
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|iwm_mvm_rx_tx_cmd_single
argument_list|(
name|sc
argument_list|,
name|pkt
argument_list|,
name|in
argument_list|)
expr_stmt|;
comment|/* Unmap and free mbuf. */
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|txd
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|txd
operator|->
name|map
argument_list|)
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_XMIT
argument_list|,
literal|"free txd %p, in %p\n"
argument_list|,
name|txd
argument_list|,
name|txd
operator|->
name|in
argument_list|)
expr_stmt|;
name|txd
operator|->
name|done
operator|=
literal|1
expr_stmt|;
name|txd
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
name|txd
operator|->
name|in
operator|=
name|NULL
expr_stmt|;
name|ieee80211_tx_complete
argument_list|(
operator|&
name|in
operator|->
name|in_ni
argument_list|,
name|m
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|ring
operator|->
name|queued
operator|<
name|IWM_TX_RING_LOMARK
condition|)
block|{
name|sc
operator|->
name|qfullmsk
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|ring
operator|->
name|qid
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|qfullmsk
operator|==
literal|0
condition|)
block|{
name|iwm_start
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * transmit side  */
end_comment

begin_comment
comment|/*  * Process a "command done" firmware notification.  This is where we wakeup  * processes waiting for a synchronous command completion.  * from if_iwn  */
end_comment

begin_function
specifier|static
name|void
name|iwm_cmd_done
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwm_rx_packet
modifier|*
name|pkt
parameter_list|)
block|{
name|struct
name|iwm_tx_ring
modifier|*
name|ring
init|=
operator|&
name|sc
operator|->
name|txq
index|[
name|IWM_MVM_CMD_QUEUE
index|]
decl_stmt|;
name|struct
name|iwm_tx_data
modifier|*
name|data
decl_stmt|;
if|if
condition|(
name|pkt
operator|->
name|hdr
operator|.
name|qid
operator|!=
name|IWM_MVM_CMD_QUEUE
condition|)
block|{
return|return;
comment|/* Not a command ack. */
block|}
comment|/* XXX wide commands? */
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_CMD
argument_list|,
literal|"cmd notification type 0x%x qid %d idx %d\n"
argument_list|,
name|pkt
operator|->
name|hdr
operator|.
name|code
argument_list|,
name|pkt
operator|->
name|hdr
operator|.
name|qid
argument_list|,
name|pkt
operator|->
name|hdr
operator|.
name|idx
argument_list|)
expr_stmt|;
name|data
operator|=
operator|&
name|ring
operator|->
name|data
index|[
name|pkt
operator|->
name|hdr
operator|.
name|idx
index|]
expr_stmt|;
comment|/* If the command was mapped in an mbuf, free it. */
if|if
condition|(
name|data
operator|->
name|m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|data
operator|->
name|m
argument_list|)
expr_stmt|;
name|data
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
block|}
name|wakeup
argument_list|(
operator|&
name|ring
operator|->
name|desc
index|[
name|pkt
operator|->
name|hdr
operator|.
name|idx
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|pkt
operator|->
name|hdr
operator|.
name|idx
operator|+
name|ring
operator|->
name|queued
operator|)
operator|%
name|IWM_TX_RING_COUNT
operator|)
operator|!=
name|ring
operator|->
name|cur
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: Some HCMDs skipped?: idx=%d queued=%d cur=%d\n"
argument_list|,
name|__func__
argument_list|,
name|pkt
operator|->
name|hdr
operator|.
name|idx
argument_list|,
name|ring
operator|->
name|queued
argument_list|,
name|ring
operator|->
name|cur
argument_list|)
expr_stmt|;
comment|/* XXX call iwm_force_nmi() */
block|}
name|KASSERT
argument_list|(
name|ring
operator|->
name|queued
operator|>
literal|0
argument_list|,
operator|(
literal|"ring->queued is empty?"
operator|)
argument_list|)
expr_stmt|;
name|ring
operator|->
name|queued
operator|--
expr_stmt|;
if|if
condition|(
name|ring
operator|->
name|queued
operator|==
literal|0
condition|)
name|iwm_pcie_clear_cmd_in_flight
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * necessary only for block ack mode  */
end_comment

begin_comment
unit|void iwm_update_sched(struct iwm_softc *sc, int qid, int idx, uint8_t sta_id, 	uint16_t len) { 	struct iwm_agn_scd_bc_tbl *scd_bc_tbl; 	uint16_t w_val;  	scd_bc_tbl = sc->sched_dma.vaddr;  	len += 8;
comment|/* magic numbers came naturally from paris */
end_comment

begin_comment
unit|len = roundup(len, 4) / 4;  	w_val = htole16(sta_id<< 12 | len);
comment|/* Update TX scheduler. */
end_comment

begin_comment
unit|scd_bc_tbl[qid].tfd_offset[idx] = w_val; 	bus_dmamap_sync(sc->sched_dma.tag, sc->sched_dma.map, 	    BUS_DMASYNC_PREWRITE);
comment|/* I really wonder what this is ?!? */
end_comment

begin_endif
unit|if (idx< IWM_TFD_QUEUE_SIZE_BC_DUP) { 		scd_bc_tbl[qid].tfd_offset[IWM_TFD_QUEUE_SIZE_MAX + idx] = w_val; 		bus_dmamap_sync(sc->sched_dma.tag, sc->sched_dma.map, 		    BUS_DMASYNC_PREWRITE); 	} }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Take an 802.11 (non-n) rate, find the relevant rate  * table entry.  return the index into in_ridx[].  *  * The caller then uses that index back into in_ridx  * to figure out the rate index programmed /into/  * the firmware for this given node.  */
end_comment

begin_function
specifier|static
name|int
name|iwm_tx_rateidx_lookup
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwm_node
modifier|*
name|in
parameter_list|,
name|uint8_t
name|rate
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint8_t
name|r
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|in
operator|->
name|in_ridx
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|r
operator|=
name|iwm_rates
index|[
name|in
operator|->
name|in_ridx
index|[
name|i
index|]
index|]
operator|.
name|rate
expr_stmt|;
if|if
condition|(
name|rate
operator|==
name|r
condition|)
return|return
operator|(
name|i
operator|)
return|;
block|}
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_XMIT
operator||
name|IWM_DEBUG_TXRATE
argument_list|,
literal|"%s: couldn't find an entry for rate=%d\n"
argument_list|,
name|__func__
argument_list|,
name|rate
argument_list|)
expr_stmt|;
comment|/* XXX Return the first */
comment|/* XXX TODO: have it return the /lowest/ */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_tx_rateidx_global_lookup
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|rate
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|iwm_rates
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|iwm_rates
index|[
name|i
index|]
operator|.
name|rate
operator|==
name|rate
condition|)
return|return
operator|(
name|i
operator|)
return|;
block|}
comment|/* XXX error? */
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_XMIT
operator||
name|IWM_DEBUG_TXRATE
argument_list|,
literal|"%s: couldn't find an entry for rate=%d\n"
argument_list|,
name|__func__
argument_list|,
name|rate
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fill in the rate related information for a transmit command.  */
end_comment

begin_function
specifier|static
specifier|const
name|struct
name|iwm_rate
modifier|*
name|iwm_tx_fill_cmd
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwm_node
modifier|*
name|in
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|iwm_tx_cmd
modifier|*
name|tx
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
operator|&
name|in
operator|->
name|in_ni
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
specifier|const
name|struct
name|ieee80211_txparam
modifier|*
name|tp
init|=
name|ni
operator|->
name|ni_txparms
decl_stmt|;
specifier|const
name|struct
name|iwm_rate
modifier|*
name|rinfo
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|ridx
decl_stmt|,
name|rate_flags
decl_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|type
operator|=
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_TYPE_MASK
expr_stmt|;
name|tx
operator|->
name|rts_retry_limit
operator|=
name|IWM_RTS_DFAULT_RETRY_LIMIT
expr_stmt|;
name|tx
operator|->
name|data_retry_limit
operator|=
name|IWM_DEFAULT_TX_RETRY
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|IEEE80211_FC0_TYPE_MGT
operator|||
name|type
operator|==
name|IEEE80211_FC0_TYPE_CTL
operator|||
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EAPOL
operator|)
operator|!=
literal|0
condition|)
block|{
name|ridx
operator|=
name|iwm_tx_rateidx_global_lookup
argument_list|(
name|sc
argument_list|,
name|tp
operator|->
name|mgmtrate
argument_list|)
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_TXRATE
argument_list|,
literal|"%s: MGT (%d)\n"
argument_list|,
name|__func__
argument_list|,
name|tp
operator|->
name|mgmtrate
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IEEE80211_IS_MULTICAST
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
condition|)
block|{
name|ridx
operator|=
name|iwm_tx_rateidx_global_lookup
argument_list|(
name|sc
argument_list|,
name|tp
operator|->
name|mcastrate
argument_list|)
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_TXRATE
argument_list|,
literal|"%s: MCAST (%d)\n"
argument_list|,
name|__func__
argument_list|,
name|tp
operator|->
name|mcastrate
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tp
operator|->
name|ucastrate
operator|!=
name|IEEE80211_FIXED_RATE_NONE
condition|)
block|{
name|ridx
operator|=
name|iwm_tx_rateidx_global_lookup
argument_list|(
name|sc
argument_list|,
name|tp
operator|->
name|ucastrate
argument_list|)
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_TXRATE
argument_list|,
literal|"%s: FIXED_RATE (%d)\n"
argument_list|,
name|__func__
argument_list|,
name|tp
operator|->
name|ucastrate
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
comment|/* for data frames, use RS table */
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_TXRATE
argument_list|,
literal|"%s: DATA\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* XXX pass pktlen */
operator|(
name|void
operator|)
name|ieee80211_ratectl_rate
argument_list|(
name|ni
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|i
operator|=
name|iwm_tx_rateidx_lookup
argument_list|(
name|sc
argument_list|,
name|in
argument_list|,
name|ni
operator|->
name|ni_txrate
argument_list|)
expr_stmt|;
name|ridx
operator|=
name|in
operator|->
name|in_ridx
index|[
name|i
index|]
expr_stmt|;
comment|/* This is the index into the programmed table */
name|tx
operator|->
name|initial_rate_index
operator|=
name|i
expr_stmt|;
name|tx
operator|->
name|tx_flags
operator||=
name|htole32
argument_list|(
name|IWM_TX_CMD_FLG_STA_RATE
argument_list|)
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_XMIT
operator||
name|IWM_DEBUG_TXRATE
argument_list|,
literal|"%s: start with i=%d, txrate %d\n"
argument_list|,
name|__func__
argument_list|,
name|i
argument_list|,
name|iwm_rates
index|[
name|ridx
index|]
operator|.
name|rate
argument_list|)
expr_stmt|;
block|}
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_XMIT
operator||
name|IWM_DEBUG_TXRATE
argument_list|,
literal|"%s: frame type=%d txrate %d\n"
argument_list|,
name|__func__
argument_list|,
name|type
argument_list|,
name|iwm_rates
index|[
name|ridx
index|]
operator|.
name|rate
argument_list|)
expr_stmt|;
name|rinfo
operator|=
operator|&
name|iwm_rates
index|[
name|ridx
index|]
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_TXRATE
argument_list|,
literal|"%s: ridx=%d; rate=%d, CCK=%d\n"
argument_list|,
name|__func__
argument_list|,
name|ridx
argument_list|,
name|rinfo
operator|->
name|rate
argument_list|,
operator|!
operator|!
operator|(
name|IWM_RIDX_IS_CCK
argument_list|(
name|ridx
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX TODO: hard-coded TX antenna? */
name|rate_flags
operator|=
literal|1
operator|<<
name|IWM_RATE_MCS_ANT_POS
expr_stmt|;
if|if
condition|(
name|IWM_RIDX_IS_CCK
argument_list|(
name|ridx
argument_list|)
condition|)
name|rate_flags
operator||=
name|IWM_RATE_MCS_CCK_MSK
expr_stmt|;
name|tx
operator|->
name|rate_n_flags
operator|=
name|htole32
argument_list|(
name|rate_flags
operator||
name|rinfo
operator|->
name|plcp
argument_list|)
expr_stmt|;
return|return
name|rinfo
return|;
block|}
end_function

begin_define
define|#
directive|define
name|TB0_SIZE
value|16
end_define

begin_function
specifier|static
name|int
name|iwm_tx
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int
name|ac
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
decl_stmt|;
name|struct
name|iwm_node
modifier|*
name|in
init|=
name|IWM_NODE
argument_list|(
name|ni
argument_list|)
decl_stmt|;
name|struct
name|iwm_tx_ring
modifier|*
name|ring
decl_stmt|;
name|struct
name|iwm_tx_data
modifier|*
name|data
decl_stmt|;
name|struct
name|iwm_tfd
modifier|*
name|desc
decl_stmt|;
name|struct
name|iwm_device_cmd
modifier|*
name|cmd
decl_stmt|;
name|struct
name|iwm_tx_cmd
modifier|*
name|tx
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|struct
name|ieee80211_key
modifier|*
name|k
init|=
name|NULL
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m1
decl_stmt|;
specifier|const
name|struct
name|iwm_rate
modifier|*
name|rinfo
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|u_int
name|hdrlen
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|seg
decl_stmt|,
name|segs
index|[
name|IWM_MAX_SCATTER
index|]
decl_stmt|;
name|int
name|nsegs
decl_stmt|;
name|uint8_t
name|tid
decl_stmt|,
name|type
decl_stmt|;
name|int
name|i
decl_stmt|,
name|totlen
decl_stmt|,
name|error
decl_stmt|,
name|pad
decl_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|hdrlen
operator|=
name|ieee80211_anyhdrsize
argument_list|(
name|wh
argument_list|)
expr_stmt|;
name|type
operator|=
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_TYPE_MASK
expr_stmt|;
name|tid
operator|=
literal|0
expr_stmt|;
name|ring
operator|=
operator|&
name|sc
operator|->
name|txq
index|[
name|ac
index|]
expr_stmt|;
name|desc
operator|=
operator|&
name|ring
operator|->
name|desc
index|[
name|ring
operator|->
name|cur
index|]
expr_stmt|;
name|memset
argument_list|(
name|desc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|desc
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|=
operator|&
name|ring
operator|->
name|data
index|[
name|ring
operator|->
name|cur
index|]
expr_stmt|;
comment|/* Fill out iwm_tx_cmd to send to the firmware */
name|cmd
operator|=
operator|&
name|ring
operator|->
name|cmd
index|[
name|ring
operator|->
name|cur
index|]
expr_stmt|;
name|cmd
operator|->
name|hdr
operator|.
name|code
operator|=
name|IWM_TX_CMD
expr_stmt|;
name|cmd
operator|->
name|hdr
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|hdr
operator|.
name|qid
operator|=
name|ring
operator|->
name|qid
expr_stmt|;
name|cmd
operator|->
name|hdr
operator|.
name|idx
operator|=
name|ring
operator|->
name|cur
expr_stmt|;
name|tx
operator|=
operator|(
name|void
operator|*
operator|)
name|cmd
operator|->
name|data
expr_stmt|;
name|memset
argument_list|(
name|tx
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|rinfo
operator|=
name|iwm_tx_fill_cmd
argument_list|(
name|sc
argument_list|,
name|in
argument_list|,
name|m
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* Encrypt the frame if need be. */
if|if
condition|(
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_PROTECTED
condition|)
block|{
comment|/* Retrieve key for TX&& do software encryption. */
name|k
operator|=
name|ieee80211_crypto_encap
argument_list|(
name|ni
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
comment|/* 802.11 header may have moved. */
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ieee80211_radiotap_active_vap
argument_list|(
name|vap
argument_list|)
condition|)
block|{
name|struct
name|iwm_tx_radiotap_header
modifier|*
name|tap
init|=
operator|&
name|sc
operator|->
name|sc_txtap
decl_stmt|;
name|tap
operator|->
name|wt_flags
operator|=
literal|0
expr_stmt|;
name|tap
operator|->
name|wt_chan_freq
operator|=
name|htole16
argument_list|(
name|ni
operator|->
name|ni_chan
operator|->
name|ic_freq
argument_list|)
expr_stmt|;
name|tap
operator|->
name|wt_chan_flags
operator|=
name|htole16
argument_list|(
name|ni
operator|->
name|ni_chan
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
name|tap
operator|->
name|wt_rate
operator|=
name|rinfo
operator|->
name|rate
expr_stmt|;
if|if
condition|(
name|k
operator|!=
name|NULL
condition|)
name|tap
operator|->
name|wt_flags
operator||=
name|IEEE80211_RADIOTAP_F_WEP
expr_stmt|;
name|ieee80211_radiotap_tx
argument_list|(
name|vap
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
name|totlen
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|IEEE80211_IS_MULTICAST
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
condition|)
block|{
name|flags
operator||=
name|IWM_TX_CMD_FLG_ACK
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|IEEE80211_FC0_TYPE_DATA
operator|&&
operator|(
name|totlen
operator|+
name|IEEE80211_CRC_LEN
operator|>
name|vap
operator|->
name|iv_rtsthreshold
operator|)
operator|&&
operator|!
name|IEEE80211_IS_MULTICAST
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
condition|)
block|{
name|flags
operator||=
name|IWM_TX_CMD_FLG_PROT_REQUIRE
expr_stmt|;
block|}
if|if
condition|(
name|IEEE80211_IS_MULTICAST
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
operator|||
name|type
operator|!=
name|IEEE80211_FC0_TYPE_DATA
condition|)
name|tx
operator|->
name|sta_id
operator|=
name|sc
operator|->
name|sc_aux_sta
operator|.
name|sta_id
expr_stmt|;
else|else
name|tx
operator|->
name|sta_id
operator|=
name|IWM_STATION_ID
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|IEEE80211_FC0_TYPE_MGT
condition|)
block|{
name|uint8_t
name|subtype
init|=
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
decl_stmt|;
if|if
condition|(
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_ASSOC_REQ
operator|||
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_REASSOC_REQ
condition|)
block|{
name|tx
operator|->
name|pm_frame_timeout
operator|=
name|htole16
argument_list|(
name|IWM_PM_FRAME_ASSOC
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_ACTION
condition|)
block|{
name|tx
operator|->
name|pm_frame_timeout
operator|=
name|htole16
argument_list|(
name|IWM_PM_FRAME_NONE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tx
operator|->
name|pm_frame_timeout
operator|=
name|htole16
argument_list|(
name|IWM_PM_FRAME_MGMT
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|tx
operator|->
name|pm_frame_timeout
operator|=
name|htole16
argument_list|(
name|IWM_PM_FRAME_NONE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hdrlen
operator|&
literal|3
condition|)
block|{
comment|/* First segment length must be a multiple of 4. */
name|flags
operator||=
name|IWM_TX_CMD_FLG_MH_PAD
expr_stmt|;
name|pad
operator|=
literal|4
operator|-
operator|(
name|hdrlen
operator|&
literal|3
operator|)
expr_stmt|;
block|}
else|else
name|pad
operator|=
literal|0
expr_stmt|;
name|tx
operator|->
name|driver_txop
operator|=
literal|0
expr_stmt|;
name|tx
operator|->
name|next_frame_len
operator|=
literal|0
expr_stmt|;
name|tx
operator|->
name|len
operator|=
name|htole16
argument_list|(
name|totlen
argument_list|)
expr_stmt|;
name|tx
operator|->
name|tid_tspec
operator|=
name|tid
expr_stmt|;
name|tx
operator|->
name|life_time
operator|=
name|htole32
argument_list|(
name|IWM_TX_CMD_LIFE_TIME_INFINITE
argument_list|)
expr_stmt|;
comment|/* Set physical address of "scratch area". */
name|tx
operator|->
name|dram_lsb_ptr
operator|=
name|htole32
argument_list|(
name|data
operator|->
name|scratch_paddr
argument_list|)
expr_stmt|;
name|tx
operator|->
name|dram_msb_ptr
operator|=
name|iwm_get_dma_hi_addr
argument_list|(
name|data
operator|->
name|scratch_paddr
argument_list|)
expr_stmt|;
comment|/* Copy 802.11 header in TX command. */
name|memcpy
argument_list|(
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|tx
operator|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|tx
argument_list|)
argument_list|,
name|wh
argument_list|,
name|hdrlen
argument_list|)
expr_stmt|;
name|flags
operator||=
name|IWM_TX_CMD_FLG_BT_DIS
operator||
name|IWM_TX_CMD_FLG_SEQ_CTL
expr_stmt|;
name|tx
operator|->
name|sec_ctl
operator|=
literal|0
expr_stmt|;
name|tx
operator|->
name|tx_flags
operator||=
name|htole32
argument_list|(
name|flags
argument_list|)
expr_stmt|;
comment|/* Trim 802.11 header. */
name|m_adj
argument_list|(
name|m
argument_list|,
name|hdrlen
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|m
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|error
operator|!=
name|EFBIG
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"can't map mbuf (error %d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Too many DMA segments, linearize mbuf. */
name|m1
operator|=
name|m_collapse
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|,
name|IWM_MAX_SCATTER
operator|-
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|m1
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not defrag mbuf\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|m
operator|=
name|m1
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|m
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"can't map mbuf (error %d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
name|data
operator|->
name|m
operator|=
name|m
expr_stmt|;
name|data
operator|->
name|in
operator|=
name|in
expr_stmt|;
name|data
operator|->
name|done
operator|=
literal|0
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_XMIT
argument_list|,
literal|"sending txd %p, in %p\n"
argument_list|,
name|data
argument_list|,
name|data
operator|->
name|in
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|data
operator|->
name|in
operator|!=
name|NULL
argument_list|,
operator|(
literal|"node is NULL"
operator|)
argument_list|)
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_XMIT
argument_list|,
literal|"sending data: qid=%d idx=%d len=%d nsegs=%d txflags=0x%08x rate_n_flags=0x%08x rateidx=%u\n"
argument_list|,
name|ring
operator|->
name|qid
argument_list|,
name|ring
operator|->
name|cur
argument_list|,
name|totlen
argument_list|,
name|nsegs
argument_list|,
name|le32toh
argument_list|(
name|tx
operator|->
name|tx_flags
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|tx
operator|->
name|rate_n_flags
argument_list|)
argument_list|,
name|tx
operator|->
name|initial_rate_index
argument_list|)
expr_stmt|;
comment|/* Fill TX descriptor. */
name|desc
operator|->
name|num_tbs
operator|=
literal|2
operator|+
name|nsegs
expr_stmt|;
name|desc
operator|->
name|tbs
index|[
literal|0
index|]
operator|.
name|lo
operator|=
name|htole32
argument_list|(
name|data
operator|->
name|cmd_paddr
argument_list|)
expr_stmt|;
name|desc
operator|->
name|tbs
index|[
literal|0
index|]
operator|.
name|hi_n_len
operator|=
name|htole16
argument_list|(
name|iwm_get_dma_hi_addr
argument_list|(
name|data
operator|->
name|cmd_paddr
argument_list|)
argument_list|)
operator||
operator|(
name|TB0_SIZE
operator|<<
literal|4
operator|)
expr_stmt|;
name|desc
operator|->
name|tbs
index|[
literal|1
index|]
operator|.
name|lo
operator|=
name|htole32
argument_list|(
name|data
operator|->
name|cmd_paddr
operator|+
name|TB0_SIZE
argument_list|)
expr_stmt|;
name|desc
operator|->
name|tbs
index|[
literal|1
index|]
operator|.
name|hi_n_len
operator|=
name|htole16
argument_list|(
name|iwm_get_dma_hi_addr
argument_list|(
name|data
operator|->
name|cmd_paddr
argument_list|)
argument_list|)
operator||
operator|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|iwm_cmd_header
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|tx
argument_list|)
operator|+
name|hdrlen
operator|+
name|pad
operator|-
name|TB0_SIZE
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
comment|/* Other DMA segments are for data payload. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsegs
condition|;
name|i
operator|++
control|)
block|{
name|seg
operator|=
operator|&
name|segs
index|[
name|i
index|]
expr_stmt|;
name|desc
operator|->
name|tbs
index|[
name|i
operator|+
literal|2
index|]
operator|.
name|lo
operator|=
name|htole32
argument_list|(
name|seg
operator|->
name|ds_addr
argument_list|)
expr_stmt|;
name|desc
operator|->
name|tbs
index|[
name|i
operator|+
literal|2
index|]
operator|.
name|hi_n_len
operator|=
expr|\
name|htole16
argument_list|(
name|iwm_get_dma_hi_addr
argument_list|(
name|seg
operator|->
name|ds_addr
argument_list|)
argument_list|)
operator||
operator|(
operator|(
name|seg
operator|->
name|ds_len
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|cmd_dma
operator|.
name|tag
argument_list|,
name|ring
operator|->
name|cmd_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|desc_dma
operator|.
name|tag
argument_list|,
name|ring
operator|->
name|desc_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|iwm_update_sched(sc, ring->qid, ring->cur, tx->sta_id, le16toh(tx->len));
endif|#
directive|endif
comment|/* Kick TX ring. */
name|ring
operator|->
name|cur
operator|=
operator|(
name|ring
operator|->
name|cur
operator|+
literal|1
operator|)
operator|%
name|IWM_TX_RING_COUNT
expr_stmt|;
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_HBUS_TARG_WRPTR
argument_list|,
name|ring
operator|->
name|qid
operator|<<
literal|8
operator||
name|ring
operator|->
name|cur
argument_list|)
expr_stmt|;
comment|/* Mark TX ring as full if we reach a certain threshold. */
if|if
condition|(
operator|++
name|ring
operator|->
name|queued
operator|>
name|IWM_TX_RING_HIMARK
condition|)
block|{
name|sc
operator|->
name|qfullmsk
operator||=
literal|1
operator|<<
name|ring
operator|->
name|qid
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_raw_xmit
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|ieee80211_bpf_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|iwm_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_XMIT
argument_list|,
literal|"->%s begin\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWM_FLAG_HW_INITED
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_XMIT
argument_list|,
literal|"<-%s not RUNNING\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENETDOWN
operator|)
return|;
block|}
name|IWM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* XXX fix this */
if|if
condition|(
name|params
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|iwm_tx
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
name|ni
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|iwm_tx
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
name|ni
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_tx_timer
operator|=
literal|5
expr_stmt|;
name|IWM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * mvm/tx.c  */
end_comment

begin_comment
comment|/*  * Note that there are transports that buffer frames before they reach  * the firmware. This means that after flush_tx_path is called, the  * queue might not be empty. The race-free way to handle this is to:  * 1) set the station as draining  * 2) flush the Tx path  * 3) wait for the transport queues to be empty  */
end_comment

begin_function
name|int
name|iwm_mvm_flush_tx_path
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|tfd_msk
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|struct
name|iwm_tx_path_flush_cmd
name|flush_cmd
init|=
block|{
operator|.
name|queues_ctl
operator|=
name|htole32
argument_list|(
name|tfd_msk
argument_list|)
block|,
operator|.
name|flush_ctl
operator|=
name|htole16
argument_list|(
name|IWM_DUMP_TX_FIFO_FLUSH
argument_list|)
block|, 	}
decl_stmt|;
name|ret
operator|=
name|iwm_mvm_send_cmd_pdu
argument_list|(
name|sc
argument_list|,
name|IWM_TXPATH_FLUSH
argument_list|,
name|flags
argument_list|,
sizeof|sizeof
argument_list|(
name|flush_cmd
argument_list|)
argument_list|,
operator|&
name|flush_cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Flushing tx queue failed: %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * BEGIN mvm/quota.c  */
end_comment

begin_function
specifier|static
name|int
name|iwm_mvm_update_quotas
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwm_vap
modifier|*
name|ivp
parameter_list|)
block|{
name|struct
name|iwm_time_quota_cmd
name|cmd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|idx
decl_stmt|,
name|ret
decl_stmt|,
name|num_active_macs
decl_stmt|,
name|quota
decl_stmt|,
name|quota_rem
decl_stmt|;
name|int
name|colors
index|[
name|IWM_MAX_BINDINGS
index|]
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|, }
decl_stmt|;
name|int
name|n_ifs
index|[
name|IWM_MAX_BINDINGS
index|]
init|=
block|{
literal|0
block|, }
decl_stmt|;
name|uint16_t
name|id
decl_stmt|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* currently, PHY ID == binding ID */
if|if
condition|(
name|ivp
condition|)
block|{
name|id
operator|=
name|ivp
operator|->
name|phy_ctxt
operator|->
name|id
expr_stmt|;
name|KASSERT
argument_list|(
name|id
operator|<
name|IWM_MAX_BINDINGS
argument_list|,
operator|(
literal|"invalid id"
operator|)
argument_list|)
expr_stmt|;
name|colors
index|[
name|id
index|]
operator|=
name|ivp
operator|->
name|phy_ctxt
operator|->
name|color
expr_stmt|;
if|if
condition|(
literal|1
condition|)
name|n_ifs
index|[
name|id
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * The FW's scheduling session consists of 	 * IWM_MVM_MAX_QUOTA fragments. Divide these fragments 	 * equally between all the bindings that require quota 	 */
name|num_active_macs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IWM_MAX_BINDINGS
condition|;
name|i
operator|++
control|)
block|{
name|cmd
operator|.
name|quotas
index|[
name|i
index|]
operator|.
name|id_and_color
operator|=
name|htole32
argument_list|(
name|IWM_FW_CTXT_INVALID
argument_list|)
expr_stmt|;
name|num_active_macs
operator|+=
name|n_ifs
index|[
name|i
index|]
expr_stmt|;
block|}
name|quota
operator|=
literal|0
expr_stmt|;
name|quota_rem
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|num_active_macs
condition|)
block|{
name|quota
operator|=
name|IWM_MVM_MAX_QUOTA
operator|/
name|num_active_macs
expr_stmt|;
name|quota_rem
operator|=
name|IWM_MVM_MAX_QUOTA
operator|%
name|num_active_macs
expr_stmt|;
block|}
for|for
control|(
name|idx
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IWM_MAX_BINDINGS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|colors
index|[
name|i
index|]
operator|<
literal|0
condition|)
continue|continue;
name|cmd
operator|.
name|quotas
index|[
name|idx
index|]
operator|.
name|id_and_color
operator|=
name|htole32
argument_list|(
name|IWM_FW_CMD_ID_AND_COLOR
argument_list|(
name|i
argument_list|,
name|colors
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_ifs
index|[
name|i
index|]
operator|<=
literal|0
condition|)
block|{
name|cmd
operator|.
name|quotas
index|[
name|idx
index|]
operator|.
name|quota
operator|=
name|htole32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|quotas
index|[
name|idx
index|]
operator|.
name|max_duration
operator|=
name|htole32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cmd
operator|.
name|quotas
index|[
name|idx
index|]
operator|.
name|quota
operator|=
name|htole32
argument_list|(
name|quota
operator|*
name|n_ifs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|quotas
index|[
name|idx
index|]
operator|.
name|max_duration
operator|=
name|htole32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|idx
operator|++
expr_stmt|;
block|}
comment|/* Give the remainder of the session to the first binding */
name|cmd
operator|.
name|quotas
index|[
literal|0
index|]
operator|.
name|quota
operator|=
name|htole32
argument_list|(
name|le32toh
argument_list|(
name|cmd
operator|.
name|quotas
index|[
literal|0
index|]
operator|.
name|quota
argument_list|)
operator|+
name|quota_rem
argument_list|)
expr_stmt|;
name|ret
operator|=
name|iwm_mvm_send_cmd_pdu
argument_list|(
name|sc
argument_list|,
name|IWM_TIME_QUOTA_CMD
argument_list|,
name|IWM_CMD_SYNC
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: Failed to send quota: %d\n"
argument_list|,
name|__func__
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * END mvm/quota.c  */
end_comment

begin_comment
comment|/*  * ieee80211 routines  */
end_comment

begin_comment
comment|/*  * Change to AUTH state in 80211 state machine.  Roughly matches what  * Linux does in bss_info_changed().  */
end_comment

begin_function
specifier|static
name|int
name|iwm_auth
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|struct
name|iwm_node
modifier|*
name|in
decl_stmt|;
name|struct
name|iwm_vap
modifier|*
name|iv
init|=
name|IWM_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|uint32_t
name|duration
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * XXX i have a feeling that the vap node is being 	 * freed from underneath us. Grr. 	 */
name|ni
operator|=
name|ieee80211_ref_node
argument_list|(
name|vap
operator|->
name|iv_bss
argument_list|)
expr_stmt|;
name|in
operator|=
name|IWM_NODE
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_RESET
operator||
name|IWM_DEBUG_STATE
argument_list|,
literal|"%s: called; vap=%p, bss ni=%p\n"
argument_list|,
name|__func__
argument_list|,
name|vap
argument_list|,
name|ni
argument_list|)
expr_stmt|;
name|in
operator|->
name|in_assoc
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Firmware bug - it'll crash if the beacon interval is less 	 * than 16. We can't avoid connecting at all, so refuse the 	 * station state change, this will cause net80211 to abandon 	 * attempts to connect to this AP, and eventually wpa_s will 	 * blacklist the AP... 	 */
if|if
condition|(
name|ni
operator|->
name|ni_intval
operator|<
literal|16
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"AP %s beacon interval is %d, refusing due to firmware bug!\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_bssid
argument_list|)
argument_list|,
name|ni
operator|->
name|ni_intval
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|iwm_allow_mcast
argument_list|(
name|vap
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: failed to set multicast\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * This is where it deviates from what Linux does. 	 * 	 * Linux iwlwifi doesn't reset the nic each time, nor does it 	 * call ctxt_add() here.  Instead, it adds it during vap creation, 	 * and always does a mac_ctx_changed(). 	 * 	 * The openbsd port doesn't attempt to do that - it reset things 	 * at odd states and does the add here. 	 * 	 * So, until the state handling is fixed (ie, we never reset 	 * the NIC except for a firmware failure, which should drag 	 * the NIC back to IDLE, re-setup and re-add all the mac/phy 	 * contexts that are required), let's do a dirty hack here. 	 */
if|if
condition|(
name|iv
operator|->
name|is_uploaded
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_mvm_mac_ctxt_changed
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: failed to update MAC\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_mvm_mac_ctxt_add
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: failed to add MAC\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_mvm_phy_ctxt_changed
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_phyctxt
index|[
literal|0
index|]
argument_list|,
name|in
operator|->
name|in_ni
operator|.
name|ni_chan
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: failed update phy ctxt\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|iv
operator|->
name|phy_ctxt
operator|=
operator|&
name|sc
operator|->
name|sc_phyctxt
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_mvm_binding_add_vif
argument_list|(
name|sc
argument_list|,
name|iv
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: binding update cmd\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Authentication becomes unreliable when powersaving is left enabled 	 * here. Powersaving will be activated again when association has 	 * finished or is aborted. 	 */
name|iv
operator|->
name|ps_disabled
operator|=
name|TRUE
expr_stmt|;
name|error
operator|=
name|iwm_mvm_power_update_mac
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iv
operator|->
name|ps_disabled
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: failed to update power management\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_mvm_add_sta
argument_list|(
name|sc
argument_list|,
name|in
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: failed to add sta\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Prevent the FW from wandering off channel during association 	 * by "protecting" the session with a time event. 	 */
comment|/* XXX duration is in units of TU, not MS */
name|duration
operator|=
name|IWM_MVM_TE_SESSION_PROTECTION_MAX_TIME_MS
expr_stmt|;
name|iwm_mvm_protect_session
argument_list|(
name|sc
argument_list|,
name|iv
argument_list|,
name|duration
argument_list|,
literal|500
comment|/* XXX magic number */
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_release
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwm_node
modifier|*
name|in
parameter_list|)
block|{
name|uint32_t
name|tfd_msk
decl_stmt|;
comment|/* 	 * Ok, so *technically* the proper set of calls for going 	 * from RUN back to SCAN is: 	 * 	 * iwm_mvm_power_mac_disable(sc, in); 	 * iwm_mvm_mac_ctxt_changed(sc, vap); 	 * iwm_mvm_rm_sta(sc, in); 	 * iwm_mvm_update_quotas(sc, NULL); 	 * iwm_mvm_mac_ctxt_changed(sc, in); 	 * iwm_mvm_binding_remove_vif(sc, IWM_VAP(in->in_ni.ni_vap)); 	 * iwm_mvm_mac_ctxt_remove(sc, in); 	 * 	 * However, that freezes the device not matter which permutations 	 * and modifications are attempted.  Obviously, this driver is missing 	 * something since it works in the Linux driver, but figuring out what 	 * is missing is a little more complicated.  Now, since we're going 	 * back to nothing anyway, we'll just do a complete device reset. 	 * Up your's, device! 	 */
comment|/* 	 * Just using 0xf for the queues mask is fine as long as we only 	 * get here from RUN state. 	 */
name|tfd_msk
operator|=
literal|0xf
expr_stmt|;
name|mbufq_drain
argument_list|(
operator|&
name|sc
operator|->
name|sc_snd
argument_list|)
expr_stmt|;
name|iwm_mvm_flush_tx_path
argument_list|(
name|sc
argument_list|,
name|tfd_msk
argument_list|,
name|IWM_CMD_SYNC
argument_list|)
expr_stmt|;
comment|/* 	 * We seem to get away with just synchronously sending the 	 * IWM_TXPATH_FLUSH command. 	 */
comment|//	iwm_trans_wait_tx_queue_empty(sc, tfd_msk);
name|iwm_stop_device
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iwm_init_hw
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
condition|)
name|in
operator|->
name|in_assoc
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
if|#
directive|if
literal|0
block|int error;  	iwm_mvm_power_mac_disable(sc, in);  	if ((error = iwm_mvm_mac_ctxt_changed(sc, vap)) != 0) { 		device_printf(sc->sc_dev, "mac ctxt change fail 1 %d\n", error); 		return error; 	}  	if ((error = iwm_mvm_rm_sta(sc, in)) != 0) { 		device_printf(sc->sc_dev, "sta remove fail %d\n", error); 		return error; 	} 	error = iwm_mvm_rm_sta(sc, in); 	in->in_assoc = 0; 	iwm_mvm_update_quotas(sc, NULL); 	if ((error = iwm_mvm_mac_ctxt_changed(sc, vap)) != 0) { 		device_printf(sc->sc_dev, "mac ctxt change fail 2 %d\n", error); 		return error; 	} 	iwm_mvm_binding_remove_vif(sc, IWM_VAP(in->in_ni.ni_vap));  	iwm_mvm_mac_ctxt_remove(sc, in);  	return error;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|struct
name|ieee80211_node
modifier|*
name|iwm_node_alloc
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
return|return
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|iwm_node
argument_list|)
argument_list|,
name|M_80211_NODE
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
return|;
block|}
end_function

begin_function
name|uint8_t
name|iwm_ridx2rate
parameter_list|(
name|struct
name|ieee80211_rateset
modifier|*
name|rs
parameter_list|,
name|int
name|ridx
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint8_t
name|rval
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rs
operator|->
name|rs_nrates
condition|;
name|i
operator|++
control|)
block|{
name|rval
operator|=
operator|(
name|rs
operator|->
name|rs_rates
index|[
name|i
index|]
operator|&
name|IEEE80211_RATE_VAL
operator|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
name|iwm_rates
index|[
name|ridx
index|]
operator|.
name|rate
condition|)
return|return
name|rs
operator|->
name|rs_rates
index|[
name|i
index|]
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_setrates
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwm_node
modifier|*
name|in
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
operator|&
name|in
operator|->
name|in_ni
decl_stmt|;
name|struct
name|iwm_lq_cmd
modifier|*
name|lq
init|=
operator|&
name|in
operator|->
name|in_lq
decl_stmt|;
name|int
name|nrates
init|=
name|ni
operator|->
name|ni_rates
operator|.
name|rs_nrates
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ridx
decl_stmt|,
name|tab
init|=
literal|0
decl_stmt|;
comment|//	int txant = 0;
if|if
condition|(
name|nrates
operator|>
name|nitems
argument_list|(
name|lq
operator|->
name|rs_table
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: node supports %d rates, driver handles "
literal|"only %zu\n"
argument_list|,
name|__func__
argument_list|,
name|nrates
argument_list|,
name|nitems
argument_list|(
name|lq
operator|->
name|rs_table
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|nrates
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: node supports 0 rates, odd!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * XXX .. and most of iwm_node is not initialised explicitly; 	 * it's all just 0x0 passed to the firmware. 	 */
comment|/* first figure out which rates we should support */
comment|/* XXX TODO: this isn't 11n aware /at all/ */
name|memset
argument_list|(
operator|&
name|in
operator|->
name|in_ridx
argument_list|,
operator|-
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|in
operator|->
name|in_ridx
argument_list|)
argument_list|)
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_TXRATE
argument_list|,
literal|"%s: nrates=%d\n"
argument_list|,
name|__func__
argument_list|,
name|nrates
argument_list|)
expr_stmt|;
comment|/* 	 * Loop over nrates and populate in_ridx from the highest 	 * rate to the lowest rate.  Remember, in_ridx[] has 	 * IEEE80211_RATE_MAXSIZE entries! 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|min
argument_list|(
name|nrates
argument_list|,
name|IEEE80211_RATE_MAXSIZE
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|rate
init|=
name|ni
operator|->
name|ni_rates
operator|.
name|rs_rates
index|[
operator|(
name|nrates
operator|-
literal|1
operator|)
operator|-
name|i
index|]
operator|&
name|IEEE80211_RATE_VAL
decl_stmt|;
comment|/* Map 802.11 rate to HW rate index. */
for|for
control|(
name|ridx
operator|=
literal|0
init|;
name|ridx
operator|<=
name|IWM_RIDX_MAX
condition|;
name|ridx
operator|++
control|)
if|if
condition|(
name|iwm_rates
index|[
name|ridx
index|]
operator|.
name|rate
operator|==
name|rate
condition|)
break|break;
if|if
condition|(
name|ridx
operator|>
name|IWM_RIDX_MAX
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: WARNING: device rate for %d not found!\n"
argument_list|,
name|__func__
argument_list|,
name|rate
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_TXRATE
argument_list|,
literal|"%s: rate: i: %d, rate=%d, ridx=%d\n"
argument_list|,
name|__func__
argument_list|,
name|i
argument_list|,
name|rate
argument_list|,
name|ridx
argument_list|)
expr_stmt|;
name|in
operator|->
name|in_ridx
index|[
name|i
index|]
operator|=
name|ridx
expr_stmt|;
block|}
block|}
comment|/* then construct a lq_cmd based on those */
name|memset
argument_list|(
name|lq
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lq
argument_list|)
argument_list|)
expr_stmt|;
name|lq
operator|->
name|sta_id
operator|=
name|IWM_STATION_ID
expr_stmt|;
comment|/* For HT, always enable RTS/CTS to avoid excessive retries. */
if|if
condition|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_HT
condition|)
name|lq
operator|->
name|flags
operator||=
name|IWM_LQ_FLAG_USE_RTS_MSK
expr_stmt|;
comment|/* 	 * are these used? (we don't do SISO or MIMO) 	 * need to set them to non-zero, though, or we get an error. 	 */
name|lq
operator|->
name|single_stream_ant_msk
operator|=
literal|1
expr_stmt|;
name|lq
operator|->
name|dual_stream_ant_msk
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Build the actual rate selection table. 	 * The lowest bits are the rates.  Additionally, 	 * CCK needs bit 9 to be set.  The rest of the bits 	 * we add to the table select the tx antenna 	 * Note that we add the rates in the highest rate first 	 * (opposite of ni_rates). 	 */
comment|/* 	 * XXX TODO: this should be looping over the min of nrates 	 * and LQ_MAX_RETRY_NUM.  Sigh. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrates
condition|;
name|i
operator|++
control|)
block|{
name|int
name|nextant
decl_stmt|;
if|#
directive|if
literal|0
block|if (txant == 0) 			txant = iwm_mvm_get_valid_tx_ant(sc); 		nextant = 1<<(ffs(txant)-1); 		txant&= ~nextant;
else|#
directive|else
name|nextant
operator|=
name|iwm_mvm_get_valid_tx_ant
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * Map the rate id into a rate index into 		 * our hardware table containing the 		 * configuration to use for this rate. 		 */
name|ridx
operator|=
name|in
operator|->
name|in_ridx
index|[
name|i
index|]
expr_stmt|;
name|tab
operator|=
name|iwm_rates
index|[
name|ridx
index|]
operator|.
name|plcp
expr_stmt|;
name|tab
operator||=
name|nextant
operator|<<
name|IWM_RATE_MCS_ANT_POS
expr_stmt|;
if|if
condition|(
name|IWM_RIDX_IS_CCK
argument_list|(
name|ridx
argument_list|)
condition|)
name|tab
operator||=
name|IWM_RATE_MCS_CCK_MSK
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_TXRATE
argument_list|,
literal|"station rate i=%d, rate=%d, hw=%x\n"
argument_list|,
name|i
argument_list|,
name|iwm_rates
index|[
name|ridx
index|]
operator|.
name|rate
argument_list|,
name|tab
argument_list|)
expr_stmt|;
name|lq
operator|->
name|rs_table
index|[
name|i
index|]
operator|=
name|htole32
argument_list|(
name|tab
argument_list|)
expr_stmt|;
block|}
comment|/* then fill the rest with the lowest possible rate */
for|for
control|(
name|i
operator|=
name|nrates
init|;
name|i
operator|<
name|nitems
argument_list|(
name|lq
operator|->
name|rs_table
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|KASSERT
argument_list|(
name|tab
operator|!=
literal|0
argument_list|,
operator|(
literal|"invalid tab"
operator|)
argument_list|)
expr_stmt|;
name|lq
operator|->
name|rs_table
index|[
name|i
index|]
operator|=
name|htole32
argument_list|(
name|tab
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|iwm_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|ieee80211_media_change
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENETRESET
condition|)
return|return
name|error
return|;
name|IWM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_nrunning
operator|>
literal|0
condition|)
block|{
name|iwm_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iwm_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|IWM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_newstate
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|enum
name|ieee80211_state
name|nstate
parameter_list|,
name|int
name|arg
parameter_list|)
block|{
name|struct
name|iwm_vap
modifier|*
name|ivp
init|=
name|IWM_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|iwm_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|struct
name|iwm_node
modifier|*
name|in
decl_stmt|;
name|int
name|error
decl_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_STATE
argument_list|,
literal|"switching state %s -> %s\n"
argument_list|,
name|ieee80211_state_name
index|[
name|vap
operator|->
name|iv_state
index|]
argument_list|,
name|ieee80211_state_name
index|[
name|nstate
index|]
argument_list|)
expr_stmt|;
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|IWM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_SCAN
operator|&&
name|nstate
operator|!=
name|vap
operator|->
name|iv_state
condition|)
name|iwm_led_blink_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* disable beacon filtering if we're hopping out of RUN */
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_RUN
operator|&&
name|nstate
operator|!=
name|vap
operator|->
name|iv_state
condition|)
block|{
name|iwm_mvm_disable_beacon_filter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|in
operator|=
name|IWM_NODE
argument_list|(
name|vap
operator|->
name|iv_bss
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
condition|)
name|in
operator|->
name|in_assoc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nstate
operator|==
name|IEEE80211_S_INIT
condition|)
block|{
name|IWM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|error
operator|=
name|ivp
operator|->
name|iv_newstate
argument_list|(
name|vap
argument_list|,
name|nstate
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|IWM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iwm_release
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|IWM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* 		 * It's impossible to directly go RUN->SCAN. If we iwm_release() 		 * above then the card will be completely reinitialized, 		 * so the driver must do everything necessary to bring the card 		 * from INIT to SCAN. 		 * 		 * Additionally, upon receiving deauth frame from AP, 		 * OpenBSD 802.11 stack puts the driver in IEEE80211_S_AUTH 		 * state. This will also fail with this driver, so bring the FSM 		 * from IEEE80211_S_RUN to IEEE80211_S_SCAN in this case as well. 		 * 		 * XXX TODO: fix this for FreeBSD! 		 */
if|if
condition|(
name|nstate
operator|==
name|IEEE80211_S_SCAN
operator|||
name|nstate
operator|==
name|IEEE80211_S_AUTH
operator|||
name|nstate
operator|==
name|IEEE80211_S_ASSOC
condition|)
block|{
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_STATE
argument_list|,
literal|"Force transition to INIT; MGT=%d\n"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|IWM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
comment|/* Always pass arg as -1 since we can't Tx right now. */
comment|/* 			 * XXX arg is just ignored anyway when transitioning 			 *     to IEEE80211_S_INIT. 			 */
name|vap
operator|->
name|iv_newstate
argument_list|(
name|vap
argument_list|,
name|IEEE80211_S_INIT
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_STATE
argument_list|,
literal|"Going INIT->SCAN\n"
argument_list|)
expr_stmt|;
name|nstate
operator|=
name|IEEE80211_S_SCAN
expr_stmt|;
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|IWM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|nstate
condition|)
block|{
case|case
name|IEEE80211_S_INIT
case|:
case|case
name|IEEE80211_S_SCAN
case|:
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_AUTH
operator|||
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_ASSOC
condition|)
block|{
name|int
name|myerr
decl_stmt|;
name|IWM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|myerr
operator|=
name|ivp
operator|->
name|iv_newstate
argument_list|(
name|vap
argument_list|,
name|nstate
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|IWM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwm_mvm_rm_sta
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: Failed to remove station: %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|iwm_mvm_mac_ctxt_changed
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: Failed to change mac context: %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|iwm_mvm_binding_remove_vif
argument_list|(
name|sc
argument_list|,
name|ivp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: Failed to remove channel ctx: %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|ivp
operator|->
name|phy_ctxt
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|iwm_mvm_power_update_mac
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: failed to update power management\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
name|IWM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
return|return
name|myerr
return|;
block|}
break|break;
case|case
name|IEEE80211_S_AUTH
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_auth
argument_list|(
name|vap
argument_list|,
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not move to auth state: %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IEEE80211_S_ASSOC
case|:
comment|/* 		 * EBS may be disabled due to previous failures reported by FW. 		 * Reset EBS status here assuming environment has been changed. 		 */
name|sc
operator|->
name|last_ebs_successful
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|IEEE80211_S_RUN
case|:
block|{
name|struct
name|iwm_host_cmd
name|cmd
init|=
block|{
operator|.
name|id
operator|=
name|IWM_LQ_CMD
block|,
operator|.
name|len
operator|=
block|{
sizeof|sizeof
argument_list|(
name|in
operator|->
name|in_lq
argument_list|)
block|, }
block|,
operator|.
name|flags
operator|=
name|IWM_CMD_SYNC
block|, 		}
decl_stmt|;
name|in
operator|=
name|IWM_NODE
argument_list|(
name|vap
operator|->
name|iv_bss
argument_list|)
expr_stmt|;
comment|/* Update the association state, now we have it all */
comment|/* (eg associd comes in at this point */
name|error
operator|=
name|iwm_mvm_update_sta
argument_list|(
name|sc
argument_list|,
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: failed to update STA\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|IWM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|in
operator|->
name|in_assoc
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|iwm_mvm_mac_ctxt_changed
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: failed to update MAC: %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|iwm_mvm_sf_update
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|iwm_mvm_enable_beacon_filter
argument_list|(
name|sc
argument_list|,
name|ivp
argument_list|)
expr_stmt|;
name|iwm_mvm_power_update_mac
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iwm_mvm_update_quotas
argument_list|(
name|sc
argument_list|,
name|ivp
argument_list|)
expr_stmt|;
name|iwm_setrates
argument_list|(
name|sc
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|data
index|[
literal|0
index|]
operator|=
operator|&
name|in
operator|->
name|in_lq
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_send_cmd
argument_list|(
name|sc
argument_list|,
operator|&
name|cmd
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: IWM_LQ_CMD failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
name|iwm_mvm_led_enable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
break|break;
block|}
name|IWM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
return|return
operator|(
name|ivp
operator|->
name|iv_newstate
argument_list|(
name|vap
argument_list|,
name|nstate
argument_list|,
name|arg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|iwm_endscan_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|iwm_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_SCAN
operator||
name|IWM_DEBUG_TRACE
argument_list|,
literal|"%s: scan ended\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ieee80211_scan_done
argument_list|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_send_bt_init_conf
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|iwm_bt_coex_cmd
name|bt_cmd
decl_stmt|;
name|bt_cmd
operator|.
name|mode
operator|=
name|htole32
argument_list|(
name|IWM_BT_COEX_WIFI
argument_list|)
expr_stmt|;
name|bt_cmd
operator|.
name|enabled_modules
operator|=
name|htole32
argument_list|(
name|IWM_BT_COEX_HIGH_BAND_RET
argument_list|)
expr_stmt|;
return|return
name|iwm_mvm_send_cmd_pdu
argument_list|(
name|sc
argument_list|,
name|IWM_BT_CONFIG
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|bt_cmd
argument_list|)
argument_list|,
operator|&
name|bt_cmd
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|iwm_mvm_is_lar_supported
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|boolean_t
name|nvm_lar
init|=
name|sc
operator|->
name|nvm_data
operator|->
name|lar_enabled
decl_stmt|;
name|boolean_t
name|tlv_lar
init|=
name|fw_has_capa
argument_list|(
operator|&
name|sc
operator|->
name|ucode_capa
argument_list|,
name|IWM_UCODE_TLV_CAPA_LAR_SUPPORT
argument_list|)
decl_stmt|;
if|if
condition|(
name|iwm_lar_disable
condition|)
return|return
name|FALSE
return|;
comment|/* 	 * Enable LAR only if it is supported by the FW (TLV)&& 	 * enabled in the NVM 	 */
if|if
condition|(
name|sc
operator|->
name|cfg
operator|->
name|device_family
operator|==
name|IWM_DEVICE_FAMILY_8000
condition|)
return|return
name|nvm_lar
operator|&&
name|tlv_lar
return|;
else|else
return|return
name|tlv_lar
return|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|iwm_mvm_is_wifi_mcc_supported
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return
name|fw_has_api
argument_list|(
operator|&
name|sc
operator|->
name|ucode_capa
argument_list|,
name|IWM_UCODE_TLV_API_WIFI_MCC_UPDATE
argument_list|)
operator|||
name|fw_has_capa
argument_list|(
operator|&
name|sc
operator|->
name|ucode_capa
argument_list|,
name|IWM_UCODE_TLV_CAPA_LAR_MULTI_MCC
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_send_update_mcc_cmd
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|alpha2
parameter_list|)
block|{
name|struct
name|iwm_mcc_update_cmd
name|mcc_cmd
decl_stmt|;
name|struct
name|iwm_host_cmd
name|hcmd
init|=
block|{
operator|.
name|id
operator|=
name|IWM_MCC_UPDATE_CMD
block|,
operator|.
name|flags
operator|=
operator|(
name|IWM_CMD_SYNC
operator||
name|IWM_CMD_WANT_SKB
operator|)
block|,
operator|.
name|data
operator|=
block|{
operator|&
name|mcc_cmd
block|}
block|, 	}
decl_stmt|;
name|int
name|ret
decl_stmt|;
ifdef|#
directive|ifdef
name|IWM_DEBUG
name|struct
name|iwm_rx_packet
modifier|*
name|pkt
decl_stmt|;
name|struct
name|iwm_mcc_update_resp_v1
modifier|*
name|mcc_resp_v1
init|=
name|NULL
decl_stmt|;
name|struct
name|iwm_mcc_update_resp
modifier|*
name|mcc_resp
decl_stmt|;
name|int
name|n_channels
decl_stmt|;
name|uint16_t
name|mcc
decl_stmt|;
endif|#
directive|endif
name|int
name|resp_v2
init|=
name|fw_has_capa
argument_list|(
operator|&
name|sc
operator|->
name|ucode_capa
argument_list|,
name|IWM_UCODE_TLV_CAPA_LAR_SUPPORT_V2
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|iwm_mvm_is_lar_supported
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_LAR
argument_list|,
literal|"%s: no LAR support\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|memset
argument_list|(
operator|&
name|mcc_cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mcc_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|mcc_cmd
operator|.
name|mcc
operator|=
name|htole16
argument_list|(
name|alpha2
index|[
literal|0
index|]
operator|<<
literal|8
operator||
name|alpha2
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|iwm_mvm_is_wifi_mcc_supported
argument_list|(
name|sc
argument_list|)
condition|)
name|mcc_cmd
operator|.
name|source_id
operator|=
name|IWM_MCC_SOURCE_GET_CURRENT
expr_stmt|;
else|else
name|mcc_cmd
operator|.
name|source_id
operator|=
name|IWM_MCC_SOURCE_OLD_FW
expr_stmt|;
if|if
condition|(
name|resp_v2
condition|)
name|hcmd
operator|.
name|len
index|[
literal|0
index|]
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|iwm_mcc_update_cmd
argument_list|)
expr_stmt|;
else|else
name|hcmd
operator|.
name|len
index|[
literal|0
index|]
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|iwm_mcc_update_cmd_v1
argument_list|)
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_LAR
argument_list|,
literal|"send MCC update to FW with '%c%c' src = %d\n"
argument_list|,
name|alpha2
index|[
literal|0
index|]
argument_list|,
name|alpha2
index|[
literal|1
index|]
argument_list|,
name|mcc_cmd
operator|.
name|source_id
argument_list|)
expr_stmt|;
name|ret
operator|=
name|iwm_send_cmd
argument_list|(
name|sc
argument_list|,
operator|&
name|hcmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
ifdef|#
directive|ifdef
name|IWM_DEBUG
name|pkt
operator|=
name|hcmd
operator|.
name|resp_pkt
expr_stmt|;
comment|/* Extract MCC response */
if|if
condition|(
name|resp_v2
condition|)
block|{
name|mcc_resp
operator|=
operator|(
name|void
operator|*
operator|)
name|pkt
operator|->
name|data
expr_stmt|;
name|mcc
operator|=
name|mcc_resp
operator|->
name|mcc
expr_stmt|;
name|n_channels
operator|=
name|le32toh
argument_list|(
name|mcc_resp
operator|->
name|n_channels
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mcc_resp_v1
operator|=
operator|(
name|void
operator|*
operator|)
name|pkt
operator|->
name|data
expr_stmt|;
name|mcc
operator|=
name|mcc_resp_v1
operator|->
name|mcc
expr_stmt|;
name|n_channels
operator|=
name|le32toh
argument_list|(
name|mcc_resp_v1
operator|->
name|n_channels
argument_list|)
expr_stmt|;
block|}
comment|/* W/A for a FW/NVM issue - returns 0x00 for the world domain */
if|if
condition|(
name|mcc
operator|==
literal|0
condition|)
name|mcc
operator|=
literal|0x3030
expr_stmt|;
comment|/* "00" - world */
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_LAR
argument_list|,
literal|"regulatory domain '%c%c' (%d channels available)\n"
argument_list|,
name|mcc
operator|>>
literal|8
argument_list|,
name|mcc
operator|&
literal|0xff
argument_list|,
name|n_channels
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|iwm_free_resp
argument_list|(
name|sc
argument_list|,
operator|&
name|hcmd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_mvm_tt_tx_backoff
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|backoff
parameter_list|)
block|{
name|struct
name|iwm_host_cmd
name|cmd
init|=
block|{
operator|.
name|id
operator|=
name|IWM_REPLY_THERMAL_MNG_BACKOFF
block|,
operator|.
name|len
operator|=
block|{
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
block|, }
block|,
operator|.
name|data
operator|=
block|{
operator|&
name|backoff
block|, }
block|, 	}
decl_stmt|;
if|if
condition|(
name|iwm_send_cmd
argument_list|(
name|sc
argument_list|,
operator|&
name|cmd
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"failed to change thermal tx backoff\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_init_hw
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|ac
decl_stmt|;
name|sc
operator|->
name|sf_state
operator|=
name|IWM_SF_UNINIT
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_start_hw
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"iwm_start_hw: failed %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_run_init_mvm_ucode
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"iwm_run_init_mvm_ucode: failed %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* 	 * should stop and start HW since that INIT 	 * image just loaded 	 */
name|iwm_stop_device
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ps_disabled
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_start_hw
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not initialize hardware\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* omstart, this time with the regular firmware */
name|error
operator|=
name|iwm_mvm_load_ucode_wait_alive
argument_list|(
name|sc
argument_list|,
name|IWM_UCODE_REGULAR
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not load firmware\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|error
operator|=
name|iwm_mvm_sf_update
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Failed to initialize Smart Fifo\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_send_bt_init_conf
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"bt init conf failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|error
operator|=
name|iwm_send_tx_ant_cfg
argument_list|(
name|sc
argument_list|,
name|iwm_mvm_get_valid_tx_ant
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"antenna config failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* Send phy db control command and then phy db calibration */
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_send_phy_db_data
argument_list|(
name|sc
operator|->
name|sc_phy_db
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_send_phy_cfg_cmd
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"phy_cfg_cmd failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* Add auxiliary station for scanning */
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_mvm_add_aux_sta
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"add_aux_sta failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IWM_NUM_PHY_CTX
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * The channel used here isn't relevant as it's 		 * going to be overwritten in the other flows. 		 * For now use the first channel we have. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_mvm_phy_ctxt_add
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_phyctxt
index|[
name|i
index|]
argument_list|,
operator|&
name|ic
operator|->
name|ic_channels
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
block|}
comment|/* Initialize tx backoffs to the minimum. */
if|if
condition|(
name|sc
operator|->
name|cfg
operator|->
name|device_family
operator|==
name|IWM_DEVICE_FAMILY_7000
condition|)
name|iwm_mvm_tt_tx_backoff
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwm_mvm_power_update_device
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_send_update_mcc_cmd
argument_list|(
name|sc
argument_list|,
literal|"ZZ"
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|fw_has_capa
argument_list|(
operator|&
name|sc
operator|->
name|ucode_capa
argument_list|,
name|IWM_UCODE_TLV_CAPA_UMAC_SCAN
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_mvm_config_umac_scan
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
block|}
comment|/* Enable Tx queues. */
for|for
control|(
name|ac
operator|=
literal|0
init|;
name|ac
operator|<
name|WME_NUM_AC
condition|;
name|ac
operator|++
control|)
block|{
name|error
operator|=
name|iwm_enable_txq
argument_list|(
name|sc
argument_list|,
name|IWM_STATION_ID
argument_list|,
name|ac
argument_list|,
name|iwm_mvm_ac_to_tx_fifo
index|[
name|ac
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|error
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_mvm_disable_beacon_filter
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"failed to disable beacon filter\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
return|return
literal|0
return|;
name|error
label|:
name|iwm_stop_device
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* Allow multicast from our BSSID. */
end_comment

begin_function
specifier|static
name|int
name|iwm_allow_mcast
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|vap
operator|->
name|iv_bss
decl_stmt|;
name|struct
name|iwm_mcast_filter_cmd
modifier|*
name|cmd
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|int
name|error
decl_stmt|;
name|size
operator|=
name|roundup
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|cmd
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|malloc
argument_list|(
name|size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|cmd
operator|->
name|filter_own
operator|=
literal|1
expr_stmt|;
name|cmd
operator|->
name|port_id
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|pass_all
operator|=
literal|1
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|cmd
operator|->
name|bssid
argument_list|,
name|ni
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwm_mvm_send_cmd_pdu
argument_list|(
name|sc
argument_list|,
name|IWM_MCAST_FILTER_CMD
argument_list|,
name|IWM_CMD_SYNC
argument_list|,
name|size
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cmd
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ifnet interfaces  */
end_comment

begin_function
specifier|static
name|void
name|iwm_init
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWM_FLAG_HW_INITED
condition|)
block|{
return|return;
block|}
name|sc
operator|->
name|sc_generation
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|IWM_FLAG_STOPPED
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_init_hw
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"iwm_init_hw failed %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|iwm_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Ok, firmware loaded and we are jogging 	 */
name|sc
operator|->
name|sc_flags
operator||=
name|IWM_FLAG_HW_INITED
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_watchdog_to
argument_list|,
name|hz
argument_list|,
name|iwm_watchdog
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_transmit
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|iwm_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|ic
operator|->
name|ic_softc
expr_stmt|;
name|IWM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWM_FLAG_HW_INITED
operator|)
operator|==
literal|0
condition|)
block|{
name|IWM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|error
operator|=
name|mbufq_enqueue
argument_list|(
operator|&
name|sc
operator|->
name|sc_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|IWM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|iwm_start
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IWM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Dequeue packets from sendq and call send.  */
end_comment

begin_function
specifier|static
name|void
name|iwm_start
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|ac
init|=
literal|0
decl_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_XMIT
operator||
name|IWM_DEBUG_TRACE
argument_list|,
literal|"->%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|qfullmsk
operator|==
literal|0
operator|&&
operator|(
name|m
operator|=
name|mbufq_dequeue
argument_list|(
operator|&
name|sc
operator|->
name|sc_snd
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ni
operator|=
operator|(
expr|struct
name|ieee80211_node
operator|*
operator|)
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
if|if
condition|(
name|iwm_tx
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
name|ni
argument_list|,
name|ac
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|if_inc_counter
argument_list|(
name|ni
operator|->
name|ni_vap
operator|->
name|iv_ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|sc
operator|->
name|sc_tx_timer
operator|=
literal|15
expr_stmt|;
block|}
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_XMIT
operator||
name|IWM_DEBUG_TRACE
argument_list|,
literal|"<-%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_stop
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|IWM_FLAG_HW_INITED
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|IWM_FLAG_STOPPED
expr_stmt|;
name|sc
operator|->
name|sc_generation
operator|++
expr_stmt|;
name|iwm_led_blink_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tx_timer
operator|=
literal|0
expr_stmt|;
name|iwm_stop_device
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|IWM_FLAG_SCAN_RUNNING
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_watchdog
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|iwm_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_tx_timer
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|--
name|sc
operator|->
name|sc_tx_timer
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"device timeout\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IWM_DEBUG
name|iwm_nic_error
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ieee80211_restart_all
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|counter_u64_add
argument_list|(
name|sc
operator|->
name|sc_ic
operator|.
name|ic_oerrors
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_watchdog_to
argument_list|,
name|hz
argument_list|,
name|iwm_watchdog
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_parent
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|iwm_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|int
name|startall
init|=
literal|0
decl_stmt|;
name|IWM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_nrunning
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWM_FLAG_HW_INITED
operator|)
condition|)
block|{
name|iwm_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|startall
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWM_FLAG_HW_INITED
condition|)
name|iwm_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IWM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|startall
condition|)
name|ieee80211_start_all
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The interrupt side of things  */
end_comment

begin_comment
comment|/*  * error dumping routines are from iwlwifi/mvm/utils.c  */
end_comment

begin_comment
comment|/*  * Note: This structure is read from the device with IO accesses,  * and the reading already does the endian conversion. As it is  * read with uint32_t-sized accesses, any members with a different size  * need to be ordered correctly though!  */
end_comment

begin_struct
struct|struct
name|iwm_error_event_table
block|{
name|uint32_t
name|valid
decl_stmt|;
comment|/* (nonzero) valid, (0) log is empty */
name|uint32_t
name|error_id
decl_stmt|;
comment|/* type of error */
name|uint32_t
name|trm_hw_status0
decl_stmt|;
comment|/* TRM HW status */
name|uint32_t
name|trm_hw_status1
decl_stmt|;
comment|/* TRM HW status */
name|uint32_t
name|blink2
decl_stmt|;
comment|/* branch link */
name|uint32_t
name|ilink1
decl_stmt|;
comment|/* interrupt link */
name|uint32_t
name|ilink2
decl_stmt|;
comment|/* interrupt link */
name|uint32_t
name|data1
decl_stmt|;
comment|/* error-specific data */
name|uint32_t
name|data2
decl_stmt|;
comment|/* error-specific data */
name|uint32_t
name|data3
decl_stmt|;
comment|/* error-specific data */
name|uint32_t
name|bcon_time
decl_stmt|;
comment|/* beacon timer */
name|uint32_t
name|tsf_low
decl_stmt|;
comment|/* network timestamp function timer */
name|uint32_t
name|tsf_hi
decl_stmt|;
comment|/* network timestamp function timer */
name|uint32_t
name|gp1
decl_stmt|;
comment|/* GP1 timer register */
name|uint32_t
name|gp2
decl_stmt|;
comment|/* GP2 timer register */
name|uint32_t
name|fw_rev_type
decl_stmt|;
comment|/* firmware revision type */
name|uint32_t
name|major
decl_stmt|;
comment|/* uCode version major */
name|uint32_t
name|minor
decl_stmt|;
comment|/* uCode version minor */
name|uint32_t
name|hw_ver
decl_stmt|;
comment|/* HW Silicon version */
name|uint32_t
name|brd_ver
decl_stmt|;
comment|/* HW board version */
name|uint32_t
name|log_pc
decl_stmt|;
comment|/* log program counter */
name|uint32_t
name|frame_ptr
decl_stmt|;
comment|/* frame pointer */
name|uint32_t
name|stack_ptr
decl_stmt|;
comment|/* stack pointer */
name|uint32_t
name|hcmd
decl_stmt|;
comment|/* last host command header */
name|uint32_t
name|isr0
decl_stmt|;
comment|/* isr status register LMPM_NIC_ISR0: 				 * rxtx_flag */
name|uint32_t
name|isr1
decl_stmt|;
comment|/* isr status register LMPM_NIC_ISR1: 				 * host_flag */
name|uint32_t
name|isr2
decl_stmt|;
comment|/* isr status register LMPM_NIC_ISR2: 				 * enc_flag */
name|uint32_t
name|isr3
decl_stmt|;
comment|/* isr status register LMPM_NIC_ISR3: 				 * time_flag */
name|uint32_t
name|isr4
decl_stmt|;
comment|/* isr status register LMPM_NIC_ISR4: 				 * wico interrupt */
name|uint32_t
name|last_cmd_id
decl_stmt|;
comment|/* last HCMD id handled by the firmware */
name|uint32_t
name|wait_event
decl_stmt|;
comment|/* wait event() caller address */
name|uint32_t
name|l2p_control
decl_stmt|;
comment|/* L2pControlField */
name|uint32_t
name|l2p_duration
decl_stmt|;
comment|/* L2pDurationField */
name|uint32_t
name|l2p_mhvalid
decl_stmt|;
comment|/* L2pMhValidBits */
name|uint32_t
name|l2p_addr_match
decl_stmt|;
comment|/* L2pAddrMatchStat */
name|uint32_t
name|lmpm_pmg_sel
decl_stmt|;
comment|/* indicate which clocks are turned on 				 * (LMPM_PMG_SEL) */
name|uint32_t
name|u_timestamp
decl_stmt|;
comment|/* indicate when the date and time of the 				 * compilation */
name|uint32_t
name|flow_handler
decl_stmt|;
comment|/* FH read/write pointers, RX credit */
block|}
name|__packed
comment|/* LOG_ERROR_TABLE_API_S_VER_3 */
struct|;
end_struct

begin_comment
comment|/*  * UMAC error struct - relevant starting from family 8000 chip.  * Note: This structure is read from the device with IO accesses,  * and the reading already does the endian conversion. As it is  * read with u32-sized accesses, any members with a different size  * need to be ordered correctly though!  */
end_comment

begin_struct
struct|struct
name|iwm_umac_error_event_table
block|{
name|uint32_t
name|valid
decl_stmt|;
comment|/* (nonzero) valid, (0) log is empty */
name|uint32_t
name|error_id
decl_stmt|;
comment|/* type of error */
name|uint32_t
name|blink1
decl_stmt|;
comment|/* branch link */
name|uint32_t
name|blink2
decl_stmt|;
comment|/* branch link */
name|uint32_t
name|ilink1
decl_stmt|;
comment|/* interrupt link */
name|uint32_t
name|ilink2
decl_stmt|;
comment|/* interrupt link */
name|uint32_t
name|data1
decl_stmt|;
comment|/* error-specific data */
name|uint32_t
name|data2
decl_stmt|;
comment|/* error-specific data */
name|uint32_t
name|data3
decl_stmt|;
comment|/* error-specific data */
name|uint32_t
name|umac_major
decl_stmt|;
name|uint32_t
name|umac_minor
decl_stmt|;
name|uint32_t
name|frame_pointer
decl_stmt|;
comment|/* core register 27*/
name|uint32_t
name|stack_pointer
decl_stmt|;
comment|/* core register 28 */
name|uint32_t
name|cmd_header
decl_stmt|;
comment|/* latest host cmd sent to UMAC */
name|uint32_t
name|nic_isr_pref
decl_stmt|;
comment|/* ISR status register */
block|}
name|__packed
struct|;
end_struct

begin_define
define|#
directive|define
name|ERROR_START_OFFSET
value|(1 * sizeof(uint32_t))
end_define

begin_define
define|#
directive|define
name|ERROR_ELEM_SIZE
value|(7 * sizeof(uint32_t))
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|IWM_DEBUG
end_ifdef

begin_struct
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|uint8_t
name|num
decl_stmt|;
block|}
name|advanced_lookup
index|[]
init|=
block|{
block|{
literal|"NMI_INTERRUPT_WDG"
block|,
literal|0x34
block|}
block|,
block|{
literal|"SYSASSERT"
block|,
literal|0x35
block|}
block|,
block|{
literal|"UCODE_VERSION_MISMATCH"
block|,
literal|0x37
block|}
block|,
block|{
literal|"BAD_COMMAND"
block|,
literal|0x38
block|}
block|,
block|{
literal|"NMI_INTERRUPT_DATA_ACTION_PT"
block|,
literal|0x3C
block|}
block|,
block|{
literal|"FATAL_ERROR"
block|,
literal|0x3D
block|}
block|,
block|{
literal|"NMI_TRM_HW_ERR"
block|,
literal|0x46
block|}
block|,
block|{
literal|"NMI_INTERRUPT_TRM"
block|,
literal|0x4C
block|}
block|,
block|{
literal|"NMI_INTERRUPT_BREAK_POINT"
block|,
literal|0x54
block|}
block|,
block|{
literal|"NMI_INTERRUPT_WDG_RXF_FULL"
block|,
literal|0x5C
block|}
block|,
block|{
literal|"NMI_INTERRUPT_WDG_NO_RBD_RXF_FULL"
block|,
literal|0x64
block|}
block|,
block|{
literal|"NMI_INTERRUPT_HOST"
block|,
literal|0x66
block|}
block|,
block|{
literal|"NMI_INTERRUPT_ACTION_PT"
block|,
literal|0x7C
block|}
block|,
block|{
literal|"NMI_INTERRUPT_UNKNOWN"
block|,
literal|0x84
block|}
block|,
block|{
literal|"NMI_INTERRUPT_INST_ACTION_PT"
block|,
literal|0x86
block|}
block|,
block|{
literal|"ADVANCED_SYSASSERT"
block|,
literal|0
block|}
block|, }
struct|;
end_struct

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|iwm_desc_lookup
parameter_list|(
name|uint32_t
name|num
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|advanced_lookup
argument_list|)
operator|-
literal|1
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|advanced_lookup
index|[
name|i
index|]
operator|.
name|num
operator|==
name|num
condition|)
return|return
name|advanced_lookup
index|[
name|i
index|]
operator|.
name|name
return|;
comment|/* No entry matches 'num', so it is the last: ADVANCED_SYSASSERT */
return|return
name|advanced_lookup
index|[
name|i
index|]
operator|.
name|name
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_nic_umac_error
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|iwm_umac_error_event_table
name|table
decl_stmt|;
name|uint32_t
name|base
decl_stmt|;
name|base
operator|=
name|sc
operator|->
name|umac_error_event_table
expr_stmt|;
if|if
condition|(
name|base
operator|<
literal|0x800000
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Invalid error log pointer 0x%08x\n"
argument_list|,
name|base
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|iwm_read_mem
argument_list|(
name|sc
argument_list|,
name|base
argument_list|,
operator|&
name|table
argument_list|,
sizeof|sizeof
argument_list|(
name|table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"reading errlog failed\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ERROR_START_OFFSET
operator|<=
name|table
operator|.
name|valid
operator|*
name|ERROR_ELEM_SIZE
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Start UMAC Error Log Dump:\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Status: 0x%x, count: %d\n"
argument_list|,
name|sc
operator|->
name|sc_flags
argument_list|,
name|table
operator|.
name|valid
argument_list|)
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"0x%08X | %s\n"
argument_list|,
name|table
operator|.
name|error_id
argument_list|,
name|iwm_desc_lookup
argument_list|(
name|table
operator|.
name|error_id
argument_list|)
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"0x%08X | umac branchlink1\n"
argument_list|,
name|table
operator|.
name|blink1
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"0x%08X | umac branchlink2\n"
argument_list|,
name|table
operator|.
name|blink2
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"0x%08X | umac interruptlink1\n"
argument_list|,
name|table
operator|.
name|ilink1
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"0x%08X | umac interruptlink2\n"
argument_list|,
name|table
operator|.
name|ilink2
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"0x%08X | umac data1\n"
argument_list|,
name|table
operator|.
name|data1
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"0x%08X | umac data2\n"
argument_list|,
name|table
operator|.
name|data2
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"0x%08X | umac data3\n"
argument_list|,
name|table
operator|.
name|data3
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"0x%08X | umac major\n"
argument_list|,
name|table
operator|.
name|umac_major
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"0x%08X | umac minor\n"
argument_list|,
name|table
operator|.
name|umac_minor
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"0x%08X | frame pointer\n"
argument_list|,
name|table
operator|.
name|frame_pointer
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"0x%08X | stack pointer\n"
argument_list|,
name|table
operator|.
name|stack_pointer
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"0x%08X | last host cmd\n"
argument_list|,
name|table
operator|.
name|cmd_header
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"0x%08X | isr status reg\n"
argument_list|,
name|table
operator|.
name|nic_isr_pref
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Support for dumping the error log seemed like a good idea ...  * but it's mostly hex junk and the only sensible thing is the  * hw/ucode revision (which we know anyway).  Since it's here,  * I'll just leave it in, just in case e.g. the Intel guys want to  * help us decipher some "ADVANCED_SYSASSERT" later.  */
end_comment

begin_function
specifier|static
name|void
name|iwm_nic_error
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|iwm_error_event_table
name|table
decl_stmt|;
name|uint32_t
name|base
decl_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"dumping device error log\n"
argument_list|)
expr_stmt|;
name|base
operator|=
name|sc
operator|->
name|error_event_table
expr_stmt|;
if|if
condition|(
name|base
operator|<
literal|0x800000
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Invalid error log pointer 0x%08x\n"
argument_list|,
name|base
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|iwm_read_mem
argument_list|(
name|sc
argument_list|,
name|base
argument_list|,
operator|&
name|table
argument_list|,
sizeof|sizeof
argument_list|(
name|table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"reading errlog failed\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|table
operator|.
name|valid
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"errlog not found, skipping\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ERROR_START_OFFSET
operator|<=
name|table
operator|.
name|valid
operator|*
name|ERROR_ELEM_SIZE
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Start Error Log Dump:\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Status: 0x%x, count: %d\n"
argument_list|,
name|sc
operator|->
name|sc_flags
argument_list|,
name|table
operator|.
name|valid
argument_list|)
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"0x%08X | %-28s\n"
argument_list|,
name|table
operator|.
name|error_id
argument_list|,
name|iwm_desc_lookup
argument_list|(
name|table
operator|.
name|error_id
argument_list|)
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | trm_hw_status0\n"
argument_list|,
name|table
operator|.
name|trm_hw_status0
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | trm_hw_status1\n"
argument_list|,
name|table
operator|.
name|trm_hw_status1
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | branchlink2\n"
argument_list|,
name|table
operator|.
name|blink2
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | interruptlink1\n"
argument_list|,
name|table
operator|.
name|ilink1
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | interruptlink2\n"
argument_list|,
name|table
operator|.
name|ilink2
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | data1\n"
argument_list|,
name|table
operator|.
name|data1
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | data2\n"
argument_list|,
name|table
operator|.
name|data2
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | data3\n"
argument_list|,
name|table
operator|.
name|data3
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | beacon time\n"
argument_list|,
name|table
operator|.
name|bcon_time
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | tsf low\n"
argument_list|,
name|table
operator|.
name|tsf_low
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | tsf hi\n"
argument_list|,
name|table
operator|.
name|tsf_hi
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | time gp1\n"
argument_list|,
name|table
operator|.
name|gp1
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | time gp2\n"
argument_list|,
name|table
operator|.
name|gp2
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | uCode revision type\n"
argument_list|,
name|table
operator|.
name|fw_rev_type
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | uCode version major\n"
argument_list|,
name|table
operator|.
name|major
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | uCode version minor\n"
argument_list|,
name|table
operator|.
name|minor
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | hw version\n"
argument_list|,
name|table
operator|.
name|hw_ver
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | board version\n"
argument_list|,
name|table
operator|.
name|brd_ver
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | hcmd\n"
argument_list|,
name|table
operator|.
name|hcmd
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | isr0\n"
argument_list|,
name|table
operator|.
name|isr0
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | isr1\n"
argument_list|,
name|table
operator|.
name|isr1
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | isr2\n"
argument_list|,
name|table
operator|.
name|isr2
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | isr3\n"
argument_list|,
name|table
operator|.
name|isr3
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | isr4\n"
argument_list|,
name|table
operator|.
name|isr4
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | last cmd Id\n"
argument_list|,
name|table
operator|.
name|last_cmd_id
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | wait_event\n"
argument_list|,
name|table
operator|.
name|wait_event
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | l2p_control\n"
argument_list|,
name|table
operator|.
name|l2p_control
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | l2p_duration\n"
argument_list|,
name|table
operator|.
name|l2p_duration
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | l2p_mhvalid\n"
argument_list|,
name|table
operator|.
name|l2p_mhvalid
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | l2p_addr_match\n"
argument_list|,
name|table
operator|.
name|l2p_addr_match
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | lmpm_pmg_sel\n"
argument_list|,
name|table
operator|.
name|lmpm_pmg_sel
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | timestamp\n"
argument_list|,
name|table
operator|.
name|u_timestamp
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | flow_handler\n"
argument_list|,
name|table
operator|.
name|flow_handler
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|umac_error_event_table
condition|)
name|iwm_nic_umac_error
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|iwm_handle_rxb
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|iwm_cmd_response
modifier|*
name|cresp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m1
decl_stmt|;
name|uint32_t
name|offset
init|=
literal|0
decl_stmt|;
name|uint32_t
name|maxoff
init|=
name|IWM_RBUF_SIZE
decl_stmt|;
name|uint32_t
name|nextoff
decl_stmt|;
name|boolean_t
name|stolen
init|=
name|FALSE
decl_stmt|;
define|#
directive|define
name|HAVEROOM
parameter_list|(
name|a
parameter_list|)
define|\
value|((a) + sizeof(uint32_t) + sizeof(struct iwm_cmd_header)< maxoff)
while|while
condition|(
name|HAVEROOM
argument_list|(
name|offset
argument_list|)
condition|)
block|{
name|struct
name|iwm_rx_packet
modifier|*
name|pkt
init|=
name|mtodoff
argument_list|(
name|m
argument_list|,
expr|struct
name|iwm_rx_packet
operator|*
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|int
name|qid
decl_stmt|,
name|idx
decl_stmt|,
name|code
decl_stmt|,
name|len
decl_stmt|;
name|qid
operator|=
name|pkt
operator|->
name|hdr
operator|.
name|qid
expr_stmt|;
name|idx
operator|=
name|pkt
operator|->
name|hdr
operator|.
name|idx
expr_stmt|;
name|code
operator|=
name|IWM_WIDE_ID
argument_list|(
name|pkt
operator|->
name|hdr
operator|.
name|flags
argument_list|,
name|pkt
operator|->
name|hdr
operator|.
name|code
argument_list|)
expr_stmt|;
comment|/* 		 * randomly get these from the firmware, no idea why. 		 * they at least seem harmless, so just ignore them for now 		 */
if|if
condition|(
operator|(
name|pkt
operator|->
name|hdr
operator|.
name|code
operator|==
literal|0
operator|&&
operator|(
name|qid
operator|&
operator|~
literal|0x80
operator|)
operator|==
literal|0
operator|&&
name|idx
operator|==
literal|0
operator|)
operator|||
name|pkt
operator|->
name|len_n_flags
operator|==
name|htole32
argument_list|(
name|IWM_FH_RSCSR_FRAME_INVALID
argument_list|)
condition|)
block|{
break|break;
block|}
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_INTR
argument_list|,
literal|"rx packet qid=%d idx=%d type=%x\n"
argument_list|,
name|qid
operator|&
operator|~
literal|0x80
argument_list|,
name|pkt
operator|->
name|hdr
operator|.
name|idx
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|len
operator|=
name|iwm_rx_packet_len
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
name|len
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
comment|/* account for status word */
name|nextoff
operator|=
name|offset
operator|+
name|roundup2
argument_list|(
name|len
argument_list|,
name|IWM_FH_RSCSR_FRAME_ALIGN
argument_list|)
expr_stmt|;
name|iwm_notification_wait_notify
argument_list|(
name|sc
operator|->
name|sc_notif_wait
argument_list|,
name|code
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|IWM_REPLY_RX_PHY_CMD
case|:
name|iwm_mvm_rx_rx_phy_cmd
argument_list|(
name|sc
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
break|break;
case|case
name|IWM_REPLY_RX_MPDU_CMD
case|:
block|{
comment|/* 			 * If this is the last frame in the RX buffer, we 			 * can directly feed the mbuf to the sharks here. 			 */
name|struct
name|iwm_rx_packet
modifier|*
name|nextpkt
init|=
name|mtodoff
argument_list|(
name|m
argument_list|,
expr|struct
name|iwm_rx_packet
operator|*
argument_list|,
name|nextoff
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|HAVEROOM
argument_list|(
name|nextoff
argument_list|)
operator|||
operator|(
name|nextpkt
operator|->
name|hdr
operator|.
name|code
operator|==
literal|0
operator|&&
operator|(
name|nextpkt
operator|->
name|hdr
operator|.
name|qid
operator|&
operator|~
literal|0x80
operator|)
operator|==
literal|0
operator|&&
name|nextpkt
operator|->
name|hdr
operator|.
name|idx
operator|==
literal|0
operator|)
operator|||
operator|(
name|nextpkt
operator|->
name|len_n_flags
operator|==
name|htole32
argument_list|(
name|IWM_FH_RSCSR_FRAME_INVALID
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|iwm_mvm_rx_rx_mpdu
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
name|offset
argument_list|,
name|stolen
argument_list|)
condition|)
block|{
name|stolen
operator|=
name|FALSE
expr_stmt|;
comment|/* Make sure we abort the loop */
name|nextoff
operator|=
name|maxoff
expr_stmt|;
block|}
break|break;
block|}
comment|/* 			 * Use m_copym instead of m_split, because that 			 * makes it easier to keep a valid rx buffer in 			 * the ring, when iwm_mvm_rx_rx_mpdu() fails. 			 * 			 * We need to start m_copym() at offset 0, to get the 			 * M_PKTHDR flag preserved. 			 */
name|m1
operator|=
name|m_copym
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m1
condition|)
block|{
if|if
condition|(
name|iwm_mvm_rx_rx_mpdu
argument_list|(
name|sc
argument_list|,
name|m1
argument_list|,
name|offset
argument_list|,
name|stolen
argument_list|)
condition|)
name|stolen
operator|=
name|TRUE
expr_stmt|;
else|else
name|m_freem
argument_list|(
name|m1
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|IWM_TX_CMD
case|:
name|iwm_mvm_rx_tx_cmd
argument_list|(
name|sc
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
break|break;
case|case
name|IWM_MISSED_BEACONS_NOTIFICATION
case|:
block|{
name|struct
name|iwm_missed_beacons_notif
modifier|*
name|resp
decl_stmt|;
name|int
name|missed
decl_stmt|;
comment|/* XXX look at mac_id to determine interface ID */
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
decl_stmt|;
name|resp
operator|=
operator|(
name|void
operator|*
operator|)
name|pkt
operator|->
name|data
expr_stmt|;
name|missed
operator|=
name|le32toh
argument_list|(
name|resp
operator|->
name|consec_missed_beacons
argument_list|)
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_BEACON
operator||
name|IWM_DEBUG_STATE
argument_list|,
literal|"%s: MISSED_BEACON: mac_id=%d, "
literal|"consec_since_last_rx=%d, consec=%d, num_expect=%d "
literal|"num_rx=%d\n"
argument_list|,
name|__func__
argument_list|,
name|le32toh
argument_list|(
name|resp
operator|->
name|mac_id
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|resp
operator|->
name|consec_missed_beacons_since_last_rx
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|resp
operator|->
name|consec_missed_beacons
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|resp
operator|->
name|num_expected_beacons
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|resp
operator|->
name|num_recvd_beacons
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Be paranoid */
if|if
condition|(
name|vap
operator|==
name|NULL
condition|)
break|break;
comment|/* XXX no net80211 locking? */
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_RUN
operator|&&
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SCAN
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|missed
operator|>
name|vap
operator|->
name|iv_bmissthreshold
condition|)
block|{
comment|/* XXX bad locking; turn into task */
name|IWM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ieee80211_beacon_miss
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|IWM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|IWM_MFUART_LOAD_NOTIFICATION
case|:
break|break;
case|case
name|IWM_MVM_ALIVE
case|:
break|break;
case|case
name|IWM_CALIB_RES_NOTIF_PHY_DB
case|:
break|break;
case|case
name|IWM_STATISTICS_NOTIFICATION
case|:
block|{
name|struct
name|iwm_notif_statistics
modifier|*
name|stats
decl_stmt|;
name|stats
operator|=
operator|(
name|void
operator|*
operator|)
name|pkt
operator|->
name|data
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sc
operator|->
name|sc_stats
argument_list|,
name|stats
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_stats
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_noise
operator|=
name|iwm_get_noise
argument_list|(
name|sc
argument_list|,
operator|&
name|stats
operator|->
name|rx
operator|.
name|general
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|IWM_NVM_ACCESS_CMD
case|:
case|case
name|IWM_MCC_UPDATE_CMD
case|:
if|if
condition|(
name|sc
operator|->
name|sc_wantresp
operator|==
operator|(
operator|(
operator|(
name|qid
operator|&
operator|~
literal|0x80
operator|)
operator|<<
literal|16
operator|)
operator||
name|idx
operator|)
condition|)
block|{
name|memcpy
argument_list|(
name|sc
operator|->
name|sc_cmd_resp
argument_list|,
name|pkt
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_cmd_resp
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IWM_MCC_CHUB_UPDATE_CMD
case|:
block|{
name|struct
name|iwm_mcc_chub_notif
modifier|*
name|notif
decl_stmt|;
name|notif
operator|=
operator|(
name|void
operator|*
operator|)
name|pkt
operator|->
name|data
expr_stmt|;
name|sc
operator|->
name|sc_fw_mcc
index|[
literal|0
index|]
operator|=
operator|(
name|notif
operator|->
name|mcc
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
expr_stmt|;
name|sc
operator|->
name|sc_fw_mcc
index|[
literal|1
index|]
operator|=
name|notif
operator|->
name|mcc
operator|&
literal|0xff
expr_stmt|;
name|sc
operator|->
name|sc_fw_mcc
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_LAR
argument_list|,
literal|"fw source %d sent CC '%s'\n"
argument_list|,
name|notif
operator|->
name|source_id
argument_list|,
name|sc
operator|->
name|sc_fw_mcc
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|IWM_DTS_MEASUREMENT_NOTIFICATION
case|:
case|case
name|IWM_WIDE_ID
argument_list|(
name|IWM_PHY_OPS_GROUP
argument_list|,
name|IWM_DTS_MEASUREMENT_NOTIF_WIDE
argument_list|)
case|:
block|{
name|struct
name|iwm_dts_measurement_notif_v1
modifier|*
name|notif
decl_stmt|;
if|if
condition|(
name|iwm_rx_packet_payload_len
argument_list|(
name|pkt
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|notif
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Invalid DTS_MEASUREMENT_NOTIFICATION\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|notif
operator|=
operator|(
name|void
operator|*
operator|)
name|pkt
operator|->
name|data
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_TEMP
argument_list|,
literal|"IWM_DTS_MEASUREMENT_NOTIFICATION - %d\n"
argument_list|,
name|notif
operator|->
name|temp
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|IWM_PHY_CONFIGURATION_CMD
case|:
case|case
name|IWM_TX_ANT_CONFIGURATION_CMD
case|:
case|case
name|IWM_ADD_STA
case|:
case|case
name|IWM_MAC_CONTEXT_CMD
case|:
case|case
name|IWM_REPLY_SF_CFG_CMD
case|:
case|case
name|IWM_POWER_TABLE_CMD
case|:
case|case
name|IWM_PHY_CONTEXT_CMD
case|:
case|case
name|IWM_BINDING_CONTEXT_CMD
case|:
case|case
name|IWM_TIME_EVENT_CMD
case|:
case|case
name|IWM_WIDE_ID
argument_list|(
name|IWM_ALWAYS_LONG_GROUP
argument_list|,
name|IWM_SCAN_CFG_CMD
argument_list|)
case|:
case|case
name|IWM_WIDE_ID
argument_list|(
name|IWM_ALWAYS_LONG_GROUP
argument_list|,
name|IWM_SCAN_REQ_UMAC
argument_list|)
case|:
case|case
name|IWM_WIDE_ID
argument_list|(
name|IWM_ALWAYS_LONG_GROUP
argument_list|,
name|IWM_SCAN_ABORT_UMAC
argument_list|)
case|:
case|case
name|IWM_SCAN_OFFLOAD_REQUEST_CMD
case|:
case|case
name|IWM_SCAN_OFFLOAD_ABORT_CMD
case|:
case|case
name|IWM_REPLY_BEACON_FILTERING_CMD
case|:
case|case
name|IWM_MAC_PM_POWER_TABLE
case|:
case|case
name|IWM_TIME_QUOTA_CMD
case|:
case|case
name|IWM_REMOVE_STA
case|:
case|case
name|IWM_TXPATH_FLUSH
case|:
case|case
name|IWM_LQ_CMD
case|:
case|case
name|IWM_WIDE_ID
argument_list|(
name|IWM_ALWAYS_LONG_GROUP
argument_list|,
name|IWM_FW_PAGING_BLOCK_CMD
argument_list|)
case|:
case|case
name|IWM_BT_CONFIG
case|:
case|case
name|IWM_REPLY_THERMAL_MNG_BACKOFF
case|:
name|cresp
operator|=
operator|(
name|void
operator|*
operator|)
name|pkt
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_wantresp
operator|==
operator|(
operator|(
operator|(
name|qid
operator|&
operator|~
literal|0x80
operator|)
operator|<<
literal|16
operator|)
operator||
name|idx
operator|)
condition|)
block|{
name|memcpy
argument_list|(
name|sc
operator|->
name|sc_cmd_resp
argument_list|,
name|pkt
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pkt
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|cresp
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* ignore */
case|case
name|IWM_PHY_DB_CMD
case|:
break|break;
case|case
name|IWM_INIT_COMPLETE_NOTIF
case|:
break|break;
case|case
name|IWM_SCAN_OFFLOAD_COMPLETE
case|:
name|iwm_mvm_rx_lmac_scan_complete_notif
argument_list|(
name|sc
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWM_FLAG_SCAN_RUNNING
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|IWM_FLAG_SCAN_RUNNING
expr_stmt|;
name|ieee80211_runtask
argument_list|(
name|ic
argument_list|,
operator|&
name|sc
operator|->
name|sc_es_task
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IWM_SCAN_ITERATION_COMPLETE
case|:
block|{
name|struct
name|iwm_lmac_scan_complete_notif
modifier|*
name|notif
decl_stmt|;
name|notif
operator|=
operator|(
name|void
operator|*
operator|)
name|pkt
operator|->
name|data
expr_stmt|;
break|break;
block|}
case|case
name|IWM_SCAN_COMPLETE_UMAC
case|:
name|iwm_mvm_rx_umac_scan_complete_notif
argument_list|(
name|sc
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWM_FLAG_SCAN_RUNNING
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|IWM_FLAG_SCAN_RUNNING
expr_stmt|;
name|ieee80211_runtask
argument_list|(
name|ic
argument_list|,
operator|&
name|sc
operator|->
name|sc_es_task
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IWM_SCAN_ITERATION_COMPLETE_UMAC
case|:
block|{
name|struct
name|iwm_umac_scan_iter_complete_notif
modifier|*
name|notif
decl_stmt|;
name|notif
operator|=
operator|(
name|void
operator|*
operator|)
name|pkt
operator|->
name|data
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_SCAN
argument_list|,
literal|"UMAC scan iteration "
literal|"complete, status=0x%x, %d channels scanned\n"
argument_list|,
name|notif
operator|->
name|status
argument_list|,
name|notif
operator|->
name|scanned_channels
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|IWM_REPLY_ERROR
case|:
block|{
name|struct
name|iwm_error_resp
modifier|*
name|resp
decl_stmt|;
name|resp
operator|=
operator|(
name|void
operator|*
operator|)
name|pkt
operator|->
name|data
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"firmware error 0x%x, cmd 0x%x\n"
argument_list|,
name|le32toh
argument_list|(
name|resp
operator|->
name|error_type
argument_list|)
argument_list|,
name|resp
operator|->
name|cmd_id
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|IWM_TIME_EVENT_NOTIFICATION
case|:
block|{
name|struct
name|iwm_time_event_notif
modifier|*
name|notif
decl_stmt|;
name|notif
operator|=
operator|(
name|void
operator|*
operator|)
name|pkt
operator|->
name|data
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_INTR
argument_list|,
literal|"TE notif status = 0x%x action = 0x%x\n"
argument_list|,
name|notif
operator|->
name|status
argument_list|,
name|notif
operator|->
name|action
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * Firmware versions 21 and 22 generate some DEBUG_LOG_MSG 		 * messages. Just ignore them for now. 		 */
case|case
name|IWM_DEBUG_LOG_MSG
case|:
break|break;
case|case
name|IWM_MCAST_FILTER_CMD
case|:
break|break;
case|case
name|IWM_SCD_QUEUE_CFG
case|:
block|{
name|struct
name|iwm_scd_txq_cfg_rsp
modifier|*
name|rsp
decl_stmt|;
name|rsp
operator|=
operator|(
name|void
operator|*
operator|)
name|pkt
operator|->
name|data
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_CMD
argument_list|,
literal|"queue cfg token=0x%x sta_id=%d "
literal|"tid=%d scd_queue=%d\n"
argument_list|,
name|rsp
operator|->
name|token
argument_list|,
name|rsp
operator|->
name|sta_id
argument_list|,
name|rsp
operator|->
name|tid
argument_list|,
name|rsp
operator|->
name|scd_queue
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"frame %d/%d %x UNHANDLED (this should "
literal|"not happen)\n"
argument_list|,
name|qid
operator|&
operator|~
literal|0x80
argument_list|,
name|idx
argument_list|,
name|pkt
operator|->
name|len_n_flags
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * Why test bit 0x80?  The Linux driver: 		 * 		 * There is one exception:  uCode sets bit 15 when it 		 * originates the response/notification, i.e. when the 		 * response/notification is not a direct response to a 		 * command sent by the driver.  For example, uCode issues 		 * IWM_REPLY_RX when it sends a received frame to the driver; 		 * it is not a direct response to any driver command. 		 * 		 * Ok, so since when is 7 == 15?  Well, the Linux driver 		 * uses a slightly different format for pkt->hdr, and "qid" 		 * is actually the upper byte of a two-byte field. 		 */
if|if
condition|(
operator|!
operator|(
name|qid
operator|&
operator|(
literal|1
operator|<<
literal|7
operator|)
operator|)
condition|)
name|iwm_cmd_done
argument_list|(
name|sc
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
name|offset
operator|=
name|nextoff
expr_stmt|;
block|}
if|if
condition|(
name|stolen
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|HAVEROOM
block|}
end_function

begin_comment
comment|/*  * Process an IWM_CSR_INT_BIT_FH_RX or IWM_CSR_INT_BIT_SW_RX interrupt.  * Basic structure from if_iwn  */
end_comment

begin_function
specifier|static
name|void
name|iwm_notif_intr
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint16_t
name|hw
decl_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rxq
operator|.
name|stat_dma
operator|.
name|tag
argument_list|,
name|sc
operator|->
name|rxq
operator|.
name|stat_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|hw
operator|=
name|le16toh
argument_list|(
name|sc
operator|->
name|rxq
operator|.
name|stat
operator|->
name|closed_rb_num
argument_list|)
operator|&
literal|0xfff
expr_stmt|;
comment|/* 	 * Process responses 	 */
while|while
condition|(
name|sc
operator|->
name|rxq
operator|.
name|cur
operator|!=
name|hw
condition|)
block|{
name|struct
name|iwm_rx_ring
modifier|*
name|ring
init|=
operator|&
name|sc
operator|->
name|rxq
decl_stmt|;
name|struct
name|iwm_rx_data
modifier|*
name|data
init|=
operator|&
name|ring
operator|->
name|data
index|[
name|ring
operator|->
name|cur
index|]
decl_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_INTR
argument_list|,
literal|"%s: hw = %d cur = %d\n"
argument_list|,
name|__func__
argument_list|,
name|hw
argument_list|,
name|ring
operator|->
name|cur
argument_list|)
expr_stmt|;
name|iwm_handle_rxb
argument_list|(
name|sc
argument_list|,
name|data
operator|->
name|m
argument_list|)
expr_stmt|;
name|ring
operator|->
name|cur
operator|=
operator|(
name|ring
operator|->
name|cur
operator|+
literal|1
operator|)
operator|%
name|IWM_RX_RING_COUNT
expr_stmt|;
block|}
comment|/* 	 * Tell the firmware that it can reuse the ring entries that 	 * we have just processed. 	 * Seems like the hardware gets upset unless we align 	 * the write by 8?? 	 */
name|hw
operator|=
operator|(
name|hw
operator|==
literal|0
operator|)
condition|?
name|IWM_RX_RING_COUNT
operator|-
literal|1
else|:
name|hw
operator|-
literal|1
expr_stmt|;
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_FH_RSCSR_CHNL0_WPTR
argument_list|,
name|rounddown2
argument_list|(
name|hw
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|iwm_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|int
name|handled
init|=
literal|0
decl_stmt|;
name|int
name|r1
decl_stmt|,
name|r2
decl_stmt|,
name|rv
init|=
literal|0
decl_stmt|;
name|int
name|isperiodic
init|=
literal|0
decl_stmt|;
name|IWM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_INT_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWM_FLAG_USE_ICT
condition|)
block|{
name|uint32_t
modifier|*
name|ict
init|=
name|sc
operator|->
name|ict_dma
operator|.
name|vaddr
decl_stmt|;
name|int
name|tmp
decl_stmt|;
name|tmp
operator|=
name|htole32
argument_list|(
name|ict
index|[
name|sc
operator|->
name|ict_cur
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
goto|goto
name|out_ena
goto|;
comment|/* 		 * ok, there was something.  keep plowing until we have all. 		 */
name|r1
operator|=
name|r2
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|tmp
condition|)
block|{
name|r1
operator||=
name|tmp
expr_stmt|;
name|ict
index|[
name|sc
operator|->
name|ict_cur
index|]
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|ict_cur
operator|=
operator|(
name|sc
operator|->
name|ict_cur
operator|+
literal|1
operator|)
operator|%
name|IWM_ICT_COUNT
expr_stmt|;
name|tmp
operator|=
name|htole32
argument_list|(
name|ict
index|[
name|sc
operator|->
name|ict_cur
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* this is where the fun begins.  don't ask */
if|if
condition|(
name|r1
operator|==
literal|0xffffffff
condition|)
name|r1
operator|=
literal|0
expr_stmt|;
comment|/* i am not expected to understand this */
if|if
condition|(
name|r1
operator|&
literal|0xc0000
condition|)
name|r1
operator||=
literal|0x8000
expr_stmt|;
name|r1
operator|=
operator|(
literal|0xff
operator|&
name|r1
operator|)
operator||
operator|(
operator|(
literal|0xff00
operator|&
name|r1
operator|)
operator|<<
literal|16
operator|)
expr_stmt|;
block|}
else|else
block|{
name|r1
operator|=
name|IWM_READ
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_INT
argument_list|)
expr_stmt|;
comment|/* "hardware gone" (where, fishing?) */
if|if
condition|(
name|r1
operator|==
literal|0xffffffff
operator|||
operator|(
name|r1
operator|&
literal|0xfffffff0
operator|)
operator|==
literal|0xa5a5a5a0
condition|)
goto|goto
name|out
goto|;
name|r2
operator|=
name|IWM_READ
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_FH_INT_STATUS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r1
operator|==
literal|0
operator|&&
name|r2
operator|==
literal|0
condition|)
block|{
goto|goto
name|out_ena
goto|;
block|}
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_INT
argument_list|,
name|r1
operator||
operator|~
name|sc
operator|->
name|sc_intmask
argument_list|)
expr_stmt|;
comment|/* Safely ignore these bits for debug checks below */
name|r1
operator|&=
operator|~
operator|(
name|IWM_CSR_INT_BIT_ALIVE
operator||
name|IWM_CSR_INT_BIT_SCD
operator|)
expr_stmt|;
if|if
condition|(
name|r1
operator|&
name|IWM_CSR_INT_BIT_SW_ERR
condition|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|IWM_DEBUG
name|iwm_nic_error
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Dump driver status (TX and RX rings) while we're here. */
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"driver status:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IWM_MVM_MAX_QUEUES
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|iwm_tx_ring
modifier|*
name|ring
init|=
operator|&
name|sc
operator|->
name|txq
index|[
name|i
index|]
decl_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"  tx ring %2d: qid=%-2d cur=%-3d "
literal|"queued=%-3d\n"
argument_list|,
name|i
argument_list|,
name|ring
operator|->
name|qid
argument_list|,
name|ring
operator|->
name|cur
argument_list|,
name|ring
operator|->
name|queued
argument_list|)
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"  rx ring: cur=%d\n"
argument_list|,
name|sc
operator|->
name|rxq
operator|.
name|cur
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"  802.11 state %d\n"
argument_list|,
operator|(
name|vap
operator|==
name|NULL
operator|)
condition|?
operator|-
literal|1
else|:
name|vap
operator|->
name|iv_state
argument_list|)
expr_stmt|;
comment|/* Don't stop the device; just do a VAP restart */
name|IWM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: null vap\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: controller panicked, iv_state = %d; "
literal|"restarting\n"
argument_list|,
name|__func__
argument_list|,
name|vap
operator|->
name|iv_state
argument_list|)
expr_stmt|;
name|ieee80211_restart_all
argument_list|(
name|ic
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|r1
operator|&
name|IWM_CSR_INT_BIT_HW_ERR
condition|)
block|{
name|handled
operator||=
name|IWM_CSR_INT_BIT_HW_ERR
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"hardware error, stopping device\n"
argument_list|)
expr_stmt|;
name|iwm_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rv
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* firmware chunk loaded */
if|if
condition|(
name|r1
operator|&
name|IWM_CSR_INT_BIT_FH_TX
condition|)
block|{
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_FH_INT_STATUS
argument_list|,
name|IWM_CSR_FH_INT_TX_MASK
argument_list|)
expr_stmt|;
name|handled
operator||=
name|IWM_CSR_INT_BIT_FH_TX
expr_stmt|;
name|sc
operator|->
name|sc_fw_chunk_done
operator|=
literal|1
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|sc_fw
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r1
operator|&
name|IWM_CSR_INT_BIT_RF_KILL
condition|)
block|{
name|handled
operator||=
name|IWM_CSR_INT_BIT_RF_KILL
expr_stmt|;
if|if
condition|(
name|iwm_check_rfkill
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: rfkill switch, disabling interface\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|iwm_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * The Linux driver uses periodic interrupts to avoid races. 	 * We cargo-cult like it's going out of fashion. 	 */
if|if
condition|(
name|r1
operator|&
name|IWM_CSR_INT_BIT_RX_PERIODIC
condition|)
block|{
name|handled
operator||=
name|IWM_CSR_INT_BIT_RX_PERIODIC
expr_stmt|;
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_INT
argument_list|,
name|IWM_CSR_INT_BIT_RX_PERIODIC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r1
operator|&
operator|(
name|IWM_CSR_INT_BIT_FH_RX
operator||
name|IWM_CSR_INT_BIT_SW_RX
operator|)
operator|)
operator|==
literal|0
condition|)
name|IWM_WRITE_1
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_INT_PERIODIC_REG
argument_list|,
name|IWM_CSR_INT_PERIODIC_DIS
argument_list|)
expr_stmt|;
name|isperiodic
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|r1
operator|&
operator|(
name|IWM_CSR_INT_BIT_FH_RX
operator||
name|IWM_CSR_INT_BIT_SW_RX
operator|)
operator|)
operator|||
name|isperiodic
condition|)
block|{
name|handled
operator||=
operator|(
name|IWM_CSR_INT_BIT_FH_RX
operator||
name|IWM_CSR_INT_BIT_SW_RX
operator|)
expr_stmt|;
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_FH_INT_STATUS
argument_list|,
name|IWM_CSR_FH_INT_RX_MASK
argument_list|)
expr_stmt|;
name|iwm_notif_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* enable periodic interrupt, see above */
if|if
condition|(
name|r1
operator|&
operator|(
name|IWM_CSR_INT_BIT_FH_RX
operator||
name|IWM_CSR_INT_BIT_SW_RX
operator|)
operator|&&
operator|!
name|isperiodic
condition|)
name|IWM_WRITE_1
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_INT_PERIODIC_REG
argument_list|,
name|IWM_CSR_INT_PERIODIC_ENA
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|__predict_false
argument_list|(
name|r1
operator|&
operator|~
name|handled
argument_list|)
condition|)
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_INTR
argument_list|,
literal|"%s: unhandled interrupts: %x\n"
argument_list|,
name|__func__
argument_list|,
name|r1
argument_list|)
expr_stmt|;
name|rv
operator|=
literal|1
expr_stmt|;
name|out_ena
label|:
name|iwm_restore_interrupts
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|out
label|:
name|IWM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Autoconf glue-sniffing  */
end_comment

begin_define
define|#
directive|define
name|PCI_VENDOR_INTEL
value|0x8086
end_define

begin_define
define|#
directive|define
name|PCI_PRODUCT_INTEL_WL_3160_1
value|0x08b3
end_define

begin_define
define|#
directive|define
name|PCI_PRODUCT_INTEL_WL_3160_2
value|0x08b4
end_define

begin_define
define|#
directive|define
name|PCI_PRODUCT_INTEL_WL_3165_1
value|0x3165
end_define

begin_define
define|#
directive|define
name|PCI_PRODUCT_INTEL_WL_3165_2
value|0x3166
end_define

begin_define
define|#
directive|define
name|PCI_PRODUCT_INTEL_WL_7260_1
value|0x08b1
end_define

begin_define
define|#
directive|define
name|PCI_PRODUCT_INTEL_WL_7260_2
value|0x08b2
end_define

begin_define
define|#
directive|define
name|PCI_PRODUCT_INTEL_WL_7265_1
value|0x095a
end_define

begin_define
define|#
directive|define
name|PCI_PRODUCT_INTEL_WL_7265_2
value|0x095b
end_define

begin_define
define|#
directive|define
name|PCI_PRODUCT_INTEL_WL_8260_1
value|0x24f3
end_define

begin_define
define|#
directive|define
name|PCI_PRODUCT_INTEL_WL_8260_2
value|0x24f4
end_define

begin_struct
specifier|static
specifier|const
struct|struct
name|iwm_devices
block|{
name|uint16_t
name|device
decl_stmt|;
specifier|const
name|struct
name|iwm_cfg
modifier|*
name|cfg
decl_stmt|;
block|}
name|iwm_devices
index|[]
init|=
block|{
block|{
name|PCI_PRODUCT_INTEL_WL_3160_1
block|,
operator|&
name|iwm3160_cfg
block|}
block|,
block|{
name|PCI_PRODUCT_INTEL_WL_3160_2
block|,
operator|&
name|iwm3160_cfg
block|}
block|,
block|{
name|PCI_PRODUCT_INTEL_WL_3165_1
block|,
operator|&
name|iwm3165_cfg
block|}
block|,
block|{
name|PCI_PRODUCT_INTEL_WL_3165_2
block|,
operator|&
name|iwm3165_cfg
block|}
block|,
block|{
name|PCI_PRODUCT_INTEL_WL_7260_1
block|,
operator|&
name|iwm7260_cfg
block|}
block|,
block|{
name|PCI_PRODUCT_INTEL_WL_7260_2
block|,
operator|&
name|iwm7260_cfg
block|}
block|,
block|{
name|PCI_PRODUCT_INTEL_WL_7265_1
block|,
operator|&
name|iwm7265_cfg
block|}
block|,
block|{
name|PCI_PRODUCT_INTEL_WL_7265_2
block|,
operator|&
name|iwm7265_cfg
block|}
block|,
block|{
name|PCI_PRODUCT_INTEL_WL_8260_1
block|,
operator|&
name|iwm8260_cfg
block|}
block|,
block|{
name|PCI_PRODUCT_INTEL_WL_8260_2
block|,
operator|&
name|iwm8260_cfg
block|}
block|, }
struct|;
end_struct

begin_function
specifier|static
name|int
name|iwm_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|iwm_devices
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_VENDOR_INTEL
operator|&&
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|iwm_devices
index|[
name|i
index|]
operator|.
name|device
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|iwm_devices
index|[
name|i
index|]
operator|.
name|cfg
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_dev_check
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|iwm_softc
modifier|*
name|sc
decl_stmt|;
name|uint16_t
name|devid
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|devid
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|iwm_devices
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|iwm_devices
index|[
name|i
index|]
operator|.
name|device
operator|==
name|devid
condition|)
block|{
name|sc
operator|->
name|cfg
operator|=
name|iwm_devices
index|[
name|i
index|]
operator|.
name|cfg
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unknown adapter type\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
end_function

begin_comment
comment|/* PCI registers */
end_comment

begin_define
define|#
directive|define
name|PCI_CFG_RETRY_TIMEOUT
value|0x041
end_define

begin_function
specifier|static
name|int
name|iwm_pci_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|iwm_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|count
decl_stmt|,
name|error
decl_stmt|,
name|rid
decl_stmt|;
name|uint16_t
name|reg
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* We disable the RETRY_TIMEOUT register (0x41) to keep 	 * PCI Tx retries from interfering with C3 CPU state */
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCI_CFG_RETRY_TIMEOUT
argument_list|,
literal|0x00
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Enable bus-mastering and hardware bug workaround. */
name|pci_enable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|reg
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_STATUS
argument_list|,
sizeof|sizeof
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* if !MSI */
if|if
condition|(
name|reg
operator|&
name|PCIM_STATUS_INTxSTATE
condition|)
block|{
name|reg
operator|&=
operator|~
name|PCIM_STATUS_INTxSTATE
expr_stmt|;
block|}
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_STATUS
argument_list|,
name|reg
argument_list|,
sizeof|sizeof
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|rid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_mem
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_mem
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"can't map mem space\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|sc_st
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|sc_mem
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_sh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|sc_mem
argument_list|)
expr_stmt|;
comment|/* Install interrupt handler. */
name|count
operator|=
literal|1
expr_stmt|;
name|rid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pci_alloc_msi
argument_list|(
name|dev
argument_list|,
operator|&
name|count
argument_list|)
operator|==
literal|0
condition|)
name|rid
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_irq
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
operator||
operator|(
name|rid
operator|!=
literal|0
condition|?
literal|0
else|:
name|RF_SHAREABLE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_irq
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can't map interrupt\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|sc_irq
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|iwm_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_ih
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ih
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can't establish interrupt"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|sc_dmat
operator|=
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_pci_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|iwm_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_irq
operator|!=
name|NULL
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|sc_irq
argument_list|,
name|sc
operator|->
name|sc_ih
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rman_get_rid
argument_list|(
name|sc
operator|->
name|sc_irq
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_irq
argument_list|)
expr_stmt|;
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_mem
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|rman_get_rid
argument_list|(
name|sc
operator|->
name|sc_mem
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_mem
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|iwm_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|txq_i
decl_stmt|,
name|i
decl_stmt|;
name|sc
operator|->
name|sc_dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|sc_attached
operator|=
literal|1
expr_stmt|;
name|IWM_LOCK_INIT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mbufq_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_snd
argument_list|,
name|ifqmaxlen
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_watchdog_to
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_led_blink_to
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_es_task
argument_list|,
literal|0
argument_list|,
name|iwm_endscan_cb
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_notif_wait
operator|=
name|iwm_notification_wait_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_notif_wait
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to init notification wait struct\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sc
operator|->
name|sf_state
operator|=
name|IWM_SF_UNINIT
expr_stmt|;
comment|/* Init phy db */
name|sc
operator|->
name|sc_phy_db
operator|=
name|iwm_phy_db_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_phy_db
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot init phy_db\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Set EBS as successful as long as not stated otherwise by the FW. */
name|sc
operator|->
name|last_ebs_successful
operator|=
name|TRUE
expr_stmt|;
comment|/* PCI attach */
name|error
operator|=
name|iwm_pci_attach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|sc
operator|->
name|sc_wantresp
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Check device type */
name|error
operator|=
name|iwm_dev_check
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|sc
operator|->
name|sc_hw_rev
operator|=
name|IWM_READ
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_HW_REV
argument_list|)
expr_stmt|;
comment|/* 	 * In the 8000 HW family the format of the 4 bytes of CSR_HW_REV have 	 * changed, and now the revision step also includes bit 0-1 (no more 	 * "dash" value). To keep hw_rev backwards compatible - we'll store it 	 * in the old format. 	 */
if|if
condition|(
name|sc
operator|->
name|cfg
operator|->
name|device_family
operator|==
name|IWM_DEVICE_FAMILY_8000
condition|)
name|sc
operator|->
name|sc_hw_rev
operator|=
operator|(
name|sc
operator|->
name|sc_hw_rev
operator|&
literal|0xfff0
operator|)
operator||
operator|(
name|IWM_CSR_HW_REV_STEP
argument_list|(
name|sc
operator|->
name|sc_hw_rev
operator|<<
literal|2
argument_list|)
operator|<<
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|iwm_prepare_card_hw
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not initialize hardware\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|sc
operator|->
name|cfg
operator|->
name|device_family
operator|==
name|IWM_DEVICE_FAMILY_8000
condition|)
block|{
name|int
name|ret
decl_stmt|;
name|uint32_t
name|hw_step
decl_stmt|;
comment|/* 		 * In order to recognize C step the driver should read the 		 * chip version id located at the AUX bus MISC address. 		 */
name|IWM_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_GP_CNTRL
argument_list|,
name|IWM_CSR_GP_CNTRL_REG_FLAG_INIT_DONE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|ret
operator|=
name|iwm_poll_bit
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_GP_CNTRL
argument_list|,
name|IWM_CSR_GP_CNTRL_REG_FLAG_MAC_CLOCK_READY
argument_list|,
name|IWM_CSR_GP_CNTRL_REG_FLAG_MAC_CLOCK_READY
argument_list|,
literal|25000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Failed to wake up the nic\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|iwm_nic_lock
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|hw_step
operator|=
name|iwm_read_prph
argument_list|(
name|sc
argument_list|,
name|IWM_WFPM_CTRL_REG
argument_list|)
expr_stmt|;
name|hw_step
operator||=
name|IWM_ENABLE_WFPM
expr_stmt|;
name|iwm_write_prph
argument_list|(
name|sc
argument_list|,
name|IWM_WFPM_CTRL_REG
argument_list|,
name|hw_step
argument_list|)
expr_stmt|;
name|hw_step
operator|=
name|iwm_read_prph
argument_list|(
name|sc
argument_list|,
name|IWM_AUX_MISC_REG
argument_list|)
expr_stmt|;
name|hw_step
operator|=
operator|(
name|hw_step
operator|>>
name|IWM_HW_STEP_LOCATION_BITS
operator|)
operator|&
literal|0xF
expr_stmt|;
if|if
condition|(
name|hw_step
operator|==
literal|0x3
condition|)
name|sc
operator|->
name|sc_hw_rev
operator|=
operator|(
name|sc
operator|->
name|sc_hw_rev
operator|&
literal|0xFFFFFFF3
operator|)
operator||
operator|(
name|IWM_SILICON_C_STEP
operator|<<
literal|2
operator|)
expr_stmt|;
name|iwm_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Failed to lock the nic\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
comment|/* special-case 7265D, it has the same PCI IDs. */
if|if
condition|(
name|sc
operator|->
name|cfg
operator|==
operator|&
name|iwm7265_cfg
operator|&&
operator|(
name|sc
operator|->
name|sc_hw_rev
operator|&
name|IWM_CSR_HW_REV_TYPE_MSK
operator|)
operator|==
name|IWM_CSR_HW_REV_TYPE_7265D
condition|)
block|{
name|sc
operator|->
name|cfg
operator|=
operator|&
name|iwm7265d_cfg
expr_stmt|;
block|}
comment|/* Allocate DMA memory for firmware transfers. */
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_alloc_fwmem
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate memory for firmware\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Allocate "Keep Warm" page. */
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_alloc_kw
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate keep warm page\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* We use ICT interrupts */
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_alloc_ict
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate ICT table\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Allocate TX scheduler "rings". */
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_alloc_sched
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate TX scheduler rings\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Allocate TX rings */
for|for
control|(
name|txq_i
operator|=
literal|0
init|;
name|txq_i
operator|<
name|nitems
argument_list|(
name|sc
operator|->
name|txq
argument_list|)
condition|;
name|txq_i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_alloc_tx_ring
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|txq
index|[
name|txq_i
index|]
argument_list|,
name|txq_i
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate TX ring %d\n"
argument_list|,
name|txq_i
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
comment|/* Allocate RX ring. */
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_alloc_rx_ring
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rxq
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate RX ring\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Clear pending interrupts. */
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_INT
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_softc
operator|=
name|sc
expr_stmt|;
name|ic
operator|->
name|ic_name
operator|=
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_phytype
operator|=
name|IEEE80211_T_OFDM
expr_stmt|;
comment|/* not only, but not used */
name|ic
operator|->
name|ic_opmode
operator|=
name|IEEE80211_M_STA
expr_stmt|;
comment|/* default to BSS mode */
comment|/* Set device capabilities. */
name|ic
operator|->
name|ic_caps
operator|=
name|IEEE80211_C_STA
operator||
name|IEEE80211_C_WPA
operator||
comment|/* WPA/RSN */
name|IEEE80211_C_WME
operator||
name|IEEE80211_C_PMGT
operator||
name|IEEE80211_C_SHSLOT
operator||
comment|/* short slot time supported */
name|IEEE80211_C_SHPREAMBLE
comment|/* short preamble supported */
comment|//	    IEEE80211_C_BGSCAN		/* capable of bg scanning */
expr_stmt|;
comment|/* Advertise full-offload scanning */
name|ic
operator|->
name|ic_flags_ext
operator|=
name|IEEE80211_FEXT_SCAN_OFFLOAD
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|sc
operator|->
name|sc_phyctxt
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|sc_phyctxt
index|[
name|i
index|]
operator|.
name|id
operator|=
name|i
expr_stmt|;
name|sc
operator|->
name|sc_phyctxt
index|[
name|i
index|]
operator|.
name|color
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_phyctxt
index|[
name|i
index|]
operator|.
name|ref
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_phyctxt
index|[
name|i
index|]
operator|.
name|channel
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Default noise floor */
name|sc
operator|->
name|sc_noise
operator|=
operator|-
literal|96
expr_stmt|;
comment|/* Max RSSI */
name|sc
operator|->
name|sc_max_rssi
operator|=
name|IWM_MAX_DBM
operator|-
name|IWM_MIN_DBM
expr_stmt|;
name|sc
operator|->
name|sc_preinit_hook
operator|.
name|ich_func
operator|=
name|iwm_preinit
expr_stmt|;
name|sc
operator|->
name|sc_preinit_hook
operator|.
name|ich_arg
operator|=
name|sc
expr_stmt|;
if|if
condition|(
name|config_intrhook_establish
argument_list|(
operator|&
name|sc
operator|->
name|sc_preinit_hook
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"config_intrhook_establish failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
ifdef|#
directive|ifdef
name|IWM_DEBUG
name|SYSCTL_ADD_INT
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"debug"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|sc_debug
argument_list|,
literal|0
argument_list|,
literal|"control debugging"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_RESET
operator||
name|IWM_DEBUG_TRACE
argument_list|,
literal|"<-%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* Free allocated memory if something failed during attachment. */
name|fail
label|:
name|iwm_detach_local
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_is_valid_ether_addr
parameter_list|(
name|uint8_t
modifier|*
name|addr
parameter_list|)
block|{
name|char
name|zero_addr
index|[
name|IEEE80211_ADDR_LEN
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
if|if
condition|(
operator|(
name|addr
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|||
name|IEEE80211_ADDR_EQ
argument_list|(
name|zero_addr
argument_list|,
name|addr
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_wme_update
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
define|#
directive|define
name|IWM_EXP2
parameter_list|(
name|x
parameter_list|)
value|((1<< (x)) - 1)
comment|/* CWmin = 2^ECWmin - 1 */
name|struct
name|iwm_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
decl_stmt|;
name|struct
name|iwm_vap
modifier|*
name|ivp
init|=
name|IWM_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|struct
name|iwm_node
modifier|*
name|in
decl_stmt|;
name|struct
name|wmeParams
name|tmp
index|[
name|WME_NUM_AC
index|]
decl_stmt|;
name|int
name|aci
decl_stmt|,
name|error
decl_stmt|;
if|if
condition|(
name|vap
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
for|for
control|(
name|aci
operator|=
literal|0
init|;
name|aci
operator|<
name|WME_NUM_AC
condition|;
name|aci
operator|++
control|)
name|tmp
index|[
name|aci
index|]
operator|=
name|ic
operator|->
name|ic_wme
operator|.
name|wme_chanParams
operator|.
name|cap_wmeParams
index|[
name|aci
index|]
expr_stmt|;
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|IWM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|aci
operator|=
literal|0
init|;
name|aci
operator|<
name|WME_NUM_AC
condition|;
name|aci
operator|++
control|)
block|{
specifier|const
name|struct
name|wmeParams
modifier|*
name|ac
init|=
operator|&
name|tmp
index|[
name|aci
index|]
decl_stmt|;
name|ivp
operator|->
name|queue_params
index|[
name|aci
index|]
operator|.
name|aifsn
operator|=
name|ac
operator|->
name|wmep_aifsn
expr_stmt|;
name|ivp
operator|->
name|queue_params
index|[
name|aci
index|]
operator|.
name|cw_min
operator|=
name|IWM_EXP2
argument_list|(
name|ac
operator|->
name|wmep_logcwmin
argument_list|)
expr_stmt|;
name|ivp
operator|->
name|queue_params
index|[
name|aci
index|]
operator|.
name|cw_max
operator|=
name|IWM_EXP2
argument_list|(
name|ac
operator|->
name|wmep_logcwmax
argument_list|)
expr_stmt|;
name|ivp
operator|->
name|queue_params
index|[
name|aci
index|]
operator|.
name|edca_txop
operator|=
name|IEEE80211_TXOP_TO_US
argument_list|(
name|ac
operator|->
name|wmep_txopLimit
argument_list|)
expr_stmt|;
block|}
name|ivp
operator|->
name|have_wme
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|ivp
operator|->
name|is_uploaded
operator|&&
name|vap
operator|->
name|iv_bss
operator|!=
name|NULL
condition|)
block|{
name|in
operator|=
name|IWM_NODE
argument_list|(
name|vap
operator|->
name|iv_bss
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|->
name|in_assoc
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_mvm_mac_ctxt_changed
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: failed to update MAC\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|IWM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
undef|#
directive|undef
name|IWM_EXP2
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_preinit
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|iwm_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|device_t
name|dev
init|=
name|sc
operator|->
name|sc_dev
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|int
name|error
decl_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_RESET
operator||
name|IWM_DEBUG_TRACE
argument_list|,
literal|"->%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|IWM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_start_hw
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not initialize hardware\n"
argument_list|)
expr_stmt|;
name|IWM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|iwm_run_init_mvm_ucode
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|iwm_stop_device
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|IWM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"hw rev 0x%x, fw ver %s, address %s\n"
argument_list|,
name|sc
operator|->
name|sc_hw_rev
operator|&
name|IWM_CSR_HW_REV_TYPE_MSK
argument_list|,
name|sc
operator|->
name|sc_fwver
argument_list|,
name|ether_sprintf
argument_list|(
name|sc
operator|->
name|nvm_data
operator|->
name|hw_addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* not all hardware can do 5GHz band */
if|if
condition|(
operator|!
name|sc
operator|->
name|nvm_data
operator|->
name|sku_cap_band_52GHz_enable
condition|)
name|memset
argument_list|(
operator|&
name|ic
operator|->
name|ic_sup_rates
index|[
name|IEEE80211_MODE_11A
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ic
operator|->
name|ic_sup_rates
index|[
name|IEEE80211_MODE_11A
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|IWM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iwm_init_channel_map
argument_list|(
name|ic
argument_list|,
name|IEEE80211_CHAN_MAX
argument_list|,
operator|&
name|ic
operator|->
name|ic_nchans
argument_list|,
name|ic
operator|->
name|ic_channels
argument_list|)
expr_stmt|;
comment|/* 	 * At this point we've committed - if we fail to do setup, 	 * we now also have to tear down the net80211 state. 	 */
name|ieee80211_ifattach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_vap_create
operator|=
name|iwm_vap_create
expr_stmt|;
name|ic
operator|->
name|ic_vap_delete
operator|=
name|iwm_vap_delete
expr_stmt|;
name|ic
operator|->
name|ic_raw_xmit
operator|=
name|iwm_raw_xmit
expr_stmt|;
name|ic
operator|->
name|ic_node_alloc
operator|=
name|iwm_node_alloc
expr_stmt|;
name|ic
operator|->
name|ic_scan_start
operator|=
name|iwm_scan_start
expr_stmt|;
name|ic
operator|->
name|ic_scan_end
operator|=
name|iwm_scan_end
expr_stmt|;
name|ic
operator|->
name|ic_update_mcast
operator|=
name|iwm_update_mcast
expr_stmt|;
name|ic
operator|->
name|ic_getradiocaps
operator|=
name|iwm_init_channel_map
expr_stmt|;
name|ic
operator|->
name|ic_set_channel
operator|=
name|iwm_set_channel
expr_stmt|;
name|ic
operator|->
name|ic_scan_curchan
operator|=
name|iwm_scan_curchan
expr_stmt|;
name|ic
operator|->
name|ic_scan_mindwell
operator|=
name|iwm_scan_mindwell
expr_stmt|;
name|ic
operator|->
name|ic_wme
operator|.
name|wme_update
operator|=
name|iwm_wme_update
expr_stmt|;
name|ic
operator|->
name|ic_parent
operator|=
name|iwm_parent
expr_stmt|;
name|ic
operator|->
name|ic_transmit
operator|=
name|iwm_transmit
expr_stmt|;
name|iwm_radiotap_attach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|ieee80211_announce
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_RESET
operator||
name|IWM_DEBUG_TRACE
argument_list|,
literal|"<-%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|config_intrhook_disestablish
argument_list|(
operator|&
name|sc
operator|->
name|sc_preinit_hook
argument_list|)
expr_stmt|;
return|return;
name|fail
label|:
name|config_intrhook_disestablish
argument_list|(
operator|&
name|sc
operator|->
name|sc_preinit_hook
argument_list|)
expr_stmt|;
name|iwm_detach_local
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Attach the interface to 802.11 radiotap.  */
end_comment

begin_function
specifier|static
name|void
name|iwm_radiotap_attach
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_RESET
operator||
name|IWM_DEBUG_TRACE
argument_list|,
literal|"->%s begin\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ieee80211_radiotap_attach
argument_list|(
name|ic
argument_list|,
operator|&
name|sc
operator|->
name|sc_txtap
operator|.
name|wt_ihdr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_txtap
argument_list|)
argument_list|,
name|IWM_TX_RADIOTAP_PRESENT
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxtap
operator|.
name|wr_ihdr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_rxtap
argument_list|)
argument_list|,
name|IWM_RX_RADIOTAP_PRESENT
argument_list|)
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_RESET
operator||
name|IWM_DEBUG_TRACE
argument_list|,
literal|"->%s end\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ieee80211vap
modifier|*
name|iwm_vap_create
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|char
name|name
index|[
name|IFNAMSIZ
index|]
parameter_list|,
name|int
name|unit
parameter_list|,
name|enum
name|ieee80211_opmode
name|opmode
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|uint8_t
name|bssid
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|iwm_vap
modifier|*
name|ivp
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
condition|)
comment|/* only one at a time */
return|return
name|NULL
return|;
name|ivp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|iwm_vap
argument_list|)
argument_list|,
name|M_80211_VAP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|vap
operator|=
operator|&
name|ivp
operator|->
name|iv_vap
expr_stmt|;
name|ieee80211_vap_setup
argument_list|(
name|ic
argument_list|,
name|vap
argument_list|,
name|name
argument_list|,
name|unit
argument_list|,
name|opmode
argument_list|,
name|flags
argument_list|,
name|bssid
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_bmissthreshold
operator|=
literal|10
expr_stmt|;
comment|/* override default */
comment|/* Override with driver methods. */
name|ivp
operator|->
name|iv_newstate
operator|=
name|vap
operator|->
name|iv_newstate
expr_stmt|;
name|vap
operator|->
name|iv_newstate
operator|=
name|iwm_newstate
expr_stmt|;
name|ivp
operator|->
name|id
operator|=
name|IWM_DEFAULT_MACID
expr_stmt|;
name|ivp
operator|->
name|color
operator|=
name|IWM_DEFAULT_COLOR
expr_stmt|;
name|ivp
operator|->
name|have_wme
operator|=
name|FALSE
expr_stmt|;
name|ivp
operator|->
name|ps_disabled
operator|=
name|FALSE
expr_stmt|;
name|ieee80211_ratectl_init
argument_list|(
name|vap
argument_list|)
expr_stmt|;
comment|/* Complete setup. */
name|ieee80211_vap_attach
argument_list|(
name|vap
argument_list|,
name|iwm_media_change
argument_list|,
name|ieee80211_media_status
argument_list|,
name|mac
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_opmode
operator|=
name|opmode
expr_stmt|;
return|return
name|vap
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_vap_delete
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|iwm_vap
modifier|*
name|ivp
init|=
name|IWM_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|ieee80211_ratectl_deinit
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|ieee80211_vap_detach
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ivp
argument_list|,
name|M_80211_VAP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_scan_start
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
decl_stmt|;
name|struct
name|iwm_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|IWM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWM_FLAG_SCAN_RUNNING
condition|)
block|{
comment|/* This should not be possible */
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: Previous scan not completed yet\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fw_has_capa
argument_list|(
operator|&
name|sc
operator|->
name|ucode_capa
argument_list|,
name|IWM_UCODE_TLV_CAPA_UMAC_SCAN
argument_list|)
condition|)
name|error
operator|=
name|iwm_mvm_umac_scan
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|iwm_mvm_lmac_scan
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not initiate scan\n"
argument_list|)
expr_stmt|;
name|IWM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ieee80211_cancel_scan
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|sc_flags
operator||=
name|IWM_FLAG_SCAN_RUNNING
expr_stmt|;
name|iwm_led_blink_start
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IWM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_scan_end
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
decl_stmt|;
name|struct
name|iwm_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|IWM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iwm_led_blink_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_RUN
condition|)
name|iwm_mvm_led_enable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWM_FLAG_SCAN_RUNNING
condition|)
block|{
comment|/* 		 * Removing IWM_FLAG_SCAN_RUNNING now, is fine because 		 * both iwm_scan_end and iwm_scan_start run in the ic->ic_tq 		 * taskqueue. 		 */
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|IWM_FLAG_SCAN_RUNNING
expr_stmt|;
name|iwm_mvm_scan_stop_wait
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|IWM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure we don't race, if sc_es_task is still enqueued here. 	 * This is to make sure that it won't call ieee80211_scan_done 	 * when we have already started the next scan. 	 */
name|taskqueue_cancel
argument_list|(
name|ic
operator|->
name|ic_tq
argument_list|,
operator|&
name|sc
operator|->
name|sc_es_task
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_update_mcast
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|iwm_set_channel
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|iwm_scan_curchan
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|,
name|unsigned
name|long
name|maxdwell
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|iwm_scan_mindwell
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|)
block|{
return|return;
block|}
end_function

begin_function
name|void
name|iwm_init_task
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|)
block|{
name|struct
name|iwm_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|IWM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWM_FLAG_BUSY
condition|)
name|msleep
argument_list|(
operator|&
name|sc
operator|->
name|sc_flags
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|0
argument_list|,
literal|"iwmpwr"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|IWM_FLAG_BUSY
expr_stmt|;
name|iwm_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ic
operator|.
name|ic_nrunning
operator|>
literal|0
condition|)
name|iwm_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|IWM_FLAG_BUSY
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|sc_flags
argument_list|)
expr_stmt|;
name|IWM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|iwm_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|do_reinit
init|=
literal|0
decl_stmt|;
comment|/* 	 * We disable the RETRY_TIMEOUT register (0x41) to keep 	 * PCI Tx retries from interfering with C3 CPU state. 	 */
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCI_CFG_RETRY_TIMEOUT
argument_list|,
literal|0x00
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|iwm_init_task
argument_list|(
name|device_get_softc
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|IWM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWM_FLAG_SCANNING
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|IWM_FLAG_SCANNING
expr_stmt|;
name|do_reinit
operator|=
literal|1
expr_stmt|;
block|}
name|IWM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_reinit
condition|)
name|ieee80211_resume_all
argument_list|(
operator|&
name|sc
operator|->
name|sc_ic
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|do_stop
init|=
literal|0
decl_stmt|;
name|struct
name|iwm_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|do_stop
operator|=
operator|!
operator|!
operator|(
name|sc
operator|->
name|sc_ic
operator|.
name|ic_nrunning
operator|>
literal|0
operator|)
expr_stmt|;
name|ieee80211_suspend_all
argument_list|(
operator|&
name|sc
operator|->
name|sc_ic
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_stop
condition|)
block|{
name|IWM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iwm_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|IWM_FLAG_SCANNING
expr_stmt|;
name|IWM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_detach_local
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|int
name|do_net80211
parameter_list|)
block|{
name|struct
name|iwm_fw_info
modifier|*
name|fw
init|=
operator|&
name|sc
operator|->
name|sc_fw
decl_stmt|;
name|device_t
name|dev
init|=
name|sc
operator|->
name|sc_dev
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_attached
condition|)
return|return
literal|0
return|;
name|sc
operator|->
name|sc_attached
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|do_net80211
condition|)
name|ieee80211_draintask
argument_list|(
operator|&
name|sc
operator|->
name|sc_ic
argument_list|,
operator|&
name|sc
operator|->
name|sc_es_task
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|sc_led_blink_to
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|sc_watchdog_to
argument_list|)
expr_stmt|;
name|iwm_stop_device
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_net80211
condition|)
block|{
name|ieee80211_ifdetach
argument_list|(
operator|&
name|sc
operator|->
name|sc_ic
argument_list|)
expr_stmt|;
block|}
name|iwm_phy_db_free
argument_list|(
name|sc
operator|->
name|sc_phy_db
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_phy_db
operator|=
name|NULL
expr_stmt|;
name|iwm_free_nvm_data
argument_list|(
name|sc
operator|->
name|nvm_data
argument_list|)
expr_stmt|;
comment|/* Free descriptor rings */
name|iwm_free_rx_ring
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rxq
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|sc
operator|->
name|txq
argument_list|)
condition|;
name|i
operator|++
control|)
name|iwm_free_tx_ring
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|txq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Free firmware */
if|if
condition|(
name|fw
operator|->
name|fw_fp
operator|!=
name|NULL
condition|)
name|iwm_fw_info_free
argument_list|(
name|fw
argument_list|)
expr_stmt|;
comment|/* Free scheduler */
name|iwm_dma_contig_free
argument_list|(
operator|&
name|sc
operator|->
name|sched_dma
argument_list|)
expr_stmt|;
name|iwm_dma_contig_free
argument_list|(
operator|&
name|sc
operator|->
name|ict_dma
argument_list|)
expr_stmt|;
name|iwm_dma_contig_free
argument_list|(
operator|&
name|sc
operator|->
name|kw_dma
argument_list|)
expr_stmt|;
name|iwm_dma_contig_free
argument_list|(
operator|&
name|sc
operator|->
name|fw_dma
argument_list|)
expr_stmt|;
name|iwm_free_fw_paging
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Finished with the hardware - detach things */
name|iwm_pci_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_notif_wait
operator|!=
name|NULL
condition|)
block|{
name|iwm_notification_wait_free
argument_list|(
name|sc
operator|->
name|sc_notif_wait
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_notif_wait
operator|=
name|NULL
expr_stmt|;
block|}
name|mbufq_drain
argument_list|(
operator|&
name|sc
operator|->
name|sc_snd
argument_list|)
expr_stmt|;
name|IWM_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|iwm_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
return|return
operator|(
name|iwm_detach_local
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|iwm_pci_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|iwm_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|iwm_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|iwm_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|iwm_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|iwm_resume
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|iwm_pci_driver
init|=
block|{
literal|"iwm"
block|,
name|iwm_pci_methods
block|,
expr|sizeof
operator|(
expr|struct
name|iwm_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|iwm_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|iwm
argument_list|,
name|pci
argument_list|,
name|iwm_pci_driver
argument_list|,
name|iwm_devclass
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|iwm
argument_list|,
name|firmware
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|iwm
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|iwm
argument_list|,
name|wlan
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

