begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$OpenBSD: if_iwm.c,v 1.39 2015/03/23 00:35:19 jsg Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 2014 genua mbh<info@genua.de>  * Copyright (c) 2014 Fixup Software Ltd.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/*-  * Based on BSD-licensed source modules in the Linux iwlwifi driver,  * which were used as the reference documentation for this implementation.  *  * Driver version we are currently based off of is  * Linux 3.14.3 (tag id a2df521e42b1d9a23f620ac79dbfe8655a8391dd)  *  ***********************************************************************  *  * This file is provided under a dual BSD/GPLv2 license.  When using or  * redistributing this file, you may do so under either license.  *  * GPL LICENSE SUMMARY  *  * Copyright(c) 2007 - 2013 Intel Corporation. All rights reserved.  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of version 2 of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it will be useful, but  * WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  * General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110,  * USA  *  * The full GNU General Public License is included in this distribution  * in the file called COPYING.  *  * Contact Information:  *  Intel Linux Wireless<ilw@linux.intel.com>  * Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497  *  *  * BSD LICENSE  *  * Copyright(c) 2005 - 2013 Intel Corporation. All rights reserved.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  *  * Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * Neither the name Intel Corporation nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2007-2010 Damien Bergamini<damien.bergamini@free.fr>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_wlan.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/firmware.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/endian.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_regdomain.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_ratectl.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_radiotap.h>
end_include

begin_include
include|#
directive|include
file|<dev/iwm/if_iwmreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/iwm/if_iwmvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/iwm/if_iwm_debug.h>
end_include

begin_include
include|#
directive|include
file|<dev/iwm/if_iwm_util.h>
end_include

begin_include
include|#
directive|include
file|<dev/iwm/if_iwm_binding.h>
end_include

begin_include
include|#
directive|include
file|<dev/iwm/if_iwm_phy_db.h>
end_include

begin_include
include|#
directive|include
file|<dev/iwm/if_iwm_mac_ctxt.h>
end_include

begin_include
include|#
directive|include
file|<dev/iwm/if_iwm_phy_ctxt.h>
end_include

begin_include
include|#
directive|include
file|<dev/iwm/if_iwm_time_event.h>
end_include

begin_include
include|#
directive|include
file|<dev/iwm/if_iwm_power.h>
end_include

begin_include
include|#
directive|include
file|<dev/iwm/if_iwm_scan.h>
end_include

begin_include
include|#
directive|include
file|<dev/iwm/if_iwm_pcie_trans.h>
end_include

begin_decl_stmt
specifier|const
name|uint8_t
name|iwm_nvm_channels
index|[]
init|=
block|{
comment|/* 2.4 GHz */
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
comment|/* 5 GHz */
literal|36
block|,
literal|40
block|,
literal|44
block|,
literal|48
block|,
literal|52
block|,
literal|56
block|,
literal|60
block|,
literal|64
block|,
literal|100
block|,
literal|104
block|,
literal|108
block|,
literal|112
block|,
literal|116
block|,
literal|120
block|,
literal|124
block|,
literal|128
block|,
literal|132
block|,
literal|136
block|,
literal|140
block|,
literal|144
block|,
literal|149
block|,
literal|153
block|,
literal|157
block|,
literal|161
block|,
literal|165
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|IWM_NUM_2GHZ_CHANNELS
value|14
end_define

begin_assert
assert|_Static_assert
argument_list|(
name|nitems
argument_list|(
name|iwm_nvm_channels
argument_list|)
operator|<=
name|IWM_NUM_CHANNELS
argument_list|,
literal|"IWM_NUM_CHANNELS is too small"
argument_list|)
assert|;
end_assert

begin_comment
comment|/*  * XXX For now, there's simply a fixed set of rate table entries  * that are populated.  */
end_comment

begin_struct
specifier|const
struct|struct
name|iwm_rate
block|{
name|uint8_t
name|rate
decl_stmt|;
name|uint8_t
name|plcp
decl_stmt|;
block|}
name|iwm_rates
index|[]
init|=
block|{
block|{
literal|2
block|,
name|IWM_RATE_1M_PLCP
block|}
block|,
block|{
literal|4
block|,
name|IWM_RATE_2M_PLCP
block|}
block|,
block|{
literal|11
block|,
name|IWM_RATE_5M_PLCP
block|}
block|,
block|{
literal|22
block|,
name|IWM_RATE_11M_PLCP
block|}
block|,
block|{
literal|12
block|,
name|IWM_RATE_6M_PLCP
block|}
block|,
block|{
literal|18
block|,
name|IWM_RATE_9M_PLCP
block|}
block|,
block|{
literal|24
block|,
name|IWM_RATE_12M_PLCP
block|}
block|,
block|{
literal|36
block|,
name|IWM_RATE_18M_PLCP
block|}
block|,
block|{
literal|48
block|,
name|IWM_RATE_24M_PLCP
block|}
block|,
block|{
literal|72
block|,
name|IWM_RATE_36M_PLCP
block|}
block|,
block|{
literal|96
block|,
name|IWM_RATE_48M_PLCP
block|}
block|,
block|{
literal|108
block|,
name|IWM_RATE_54M_PLCP
block|}
block|, }
struct|;
end_struct

begin_define
define|#
directive|define
name|IWM_RIDX_CCK
value|0
end_define

begin_define
define|#
directive|define
name|IWM_RIDX_OFDM
value|4
end_define

begin_define
define|#
directive|define
name|IWM_RIDX_MAX
value|(nitems(iwm_rates)-1)
end_define

begin_define
define|#
directive|define
name|IWM_RIDX_IS_CCK
parameter_list|(
name|_i_
parameter_list|)
value|((_i_)< IWM_RIDX_OFDM)
end_define

begin_define
define|#
directive|define
name|IWM_RIDX_IS_OFDM
parameter_list|(
name|_i_
parameter_list|)
value|((_i_)>= IWM_RIDX_OFDM)
end_define

begin_function_decl
specifier|static
name|int
name|iwm_store_cscheme
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
specifier|const
name|uint8_t
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_firmware_store_section
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|enum
name|iwm_ucode_type
parameter_list|,
specifier|const
name|uint8_t
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_set_default_calib
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_fw_info_free
parameter_list|(
name|struct
name|iwm_fw_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_read_firmware
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|enum
name|iwm_ucode_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_dma_map_addr
parameter_list|(
name|void
modifier|*
parameter_list|,
name|bus_dma_segment_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_dma_contig_alloc
parameter_list|(
name|bus_dma_tag_t
parameter_list|,
name|struct
name|iwm_dma_info
modifier|*
parameter_list|,
name|bus_size_t
parameter_list|,
name|bus_size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_dma_contig_free
parameter_list|(
name|struct
name|iwm_dma_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_alloc_fwmem
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_free_fwmem
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_alloc_sched
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_free_sched
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_alloc_kw
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_free_kw
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_alloc_ict
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_free_ict
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_alloc_rx_ring
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|struct
name|iwm_rx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_reset_rx_ring
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|struct
name|iwm_rx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_free_rx_ring
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|struct
name|iwm_rx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_alloc_tx_ring
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|struct
name|iwm_tx_ring
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_reset_tx_ring
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|struct
name|iwm_tx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_free_tx_ring
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|struct
name|iwm_tx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_enable_interrupts
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_restore_interrupts
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_disable_interrupts
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_ict_reset
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_allow_mcast
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_stop_device
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_mvm_nic_config
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_nic_rx_init
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_nic_tx_init
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_nic_init
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_enable_txq
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_post_alive
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_nvm_read_chunk
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|uint16_t
parameter_list|,
name|uint16_t
parameter_list|,
name|uint16_t
parameter_list|,
name|uint8_t
modifier|*
parameter_list|,
name|uint16_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_nvm_read_section
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|uint16_t
parameter_list|,
name|uint8_t
modifier|*
parameter_list|,
name|uint16_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|iwm_eeprom_channel_flags
parameter_list|(
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_add_channel_band
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211_channel
type|[]
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
specifier|const
name|uint8_t
index|[]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_init_channel_map
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|,
name|struct
name|ieee80211_channel
type|[]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_parse_nvm_data
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
specifier|const
name|uint16_t
modifier|*
parameter_list|,
specifier|const
name|uint16_t
modifier|*
parameter_list|,
specifier|const
name|uint16_t
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_struct_decl
struct_decl|struct
name|iwm_nvm_section
struct_decl|;
end_struct_decl

begin_function_decl
specifier|static
name|int
name|iwm_parse_nvm_sections
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|struct
name|iwm_nvm_section
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_nvm_init
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_firmware_load_chunk
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
specifier|const
name|uint8_t
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_load_firmware
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|enum
name|iwm_ucode_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_start_fw
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|enum
name|iwm_ucode_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_fw_alive
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_send_tx_ant_cfg
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_send_phy_cfg_cmd
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_mvm_load_ucode_wait_alive
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|enum
name|iwm_ucode_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_run_init_mvm_ucode
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_rx_addbuf
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_mvm_calc_rssi
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|struct
name|iwm_rx_phy_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_mvm_get_signal_strength
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|struct
name|iwm_rx_phy_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_mvm_rx_rx_phy_cmd
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|struct
name|iwm_rx_packet
modifier|*
parameter_list|,
name|struct
name|iwm_rx_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_get_noise
parameter_list|(
specifier|const
name|struct
name|iwm_mvm_statistics_rx_non_phy
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_mvm_rx_rx_mpdu
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|struct
name|iwm_rx_packet
modifier|*
parameter_list|,
name|struct
name|iwm_rx_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_mvm_rx_tx_cmd_single
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|struct
name|iwm_rx_packet
modifier|*
parameter_list|,
name|struct
name|iwm_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_mvm_rx_tx_cmd
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|struct
name|iwm_rx_packet
modifier|*
parameter_list|,
name|struct
name|iwm_rx_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_cmd_done
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|struct
name|iwm_rx_packet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void	iwm_update_sched(struct iwm_softc *, int, int, uint8_t,                                  uint16_t);
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
specifier|const
name|struct
name|iwm_rate
modifier|*
name|iwm_tx_fill_cmd
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|struct
name|iwm_node
modifier|*
parameter_list|,
name|struct
name|ieee80211_frame
modifier|*
parameter_list|,
name|struct
name|iwm_tx_cmd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_tx
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_raw_xmit
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
specifier|const
name|struct
name|ieee80211_bpf_params
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_mvm_add_sta_cmd_v6_to_v5
parameter_list|(
name|struct
name|iwm_mvm_add_sta_cmd_v6
modifier|*
parameter_list|,
name|struct
name|iwm_mvm_add_sta_cmd_v5
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_mvm_send_add_sta_cmd_status
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|struct
name|iwm_mvm_add_sta_cmd_v6
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_mvm_sta_send_to_fw
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|struct
name|iwm_node
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_mvm_add_sta
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|struct
name|iwm_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_mvm_update_sta
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|struct
name|iwm_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_mvm_add_int_sta_common
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|struct
name|iwm_int_sta
modifier|*
parameter_list|,
specifier|const
name|uint8_t
modifier|*
parameter_list|,
name|uint16_t
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_mvm_add_aux_sta
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_mvm_update_quotas
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|struct
name|iwm_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_auth
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_assoc
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_release
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|struct
name|iwm_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ieee80211_node
modifier|*
name|iwm_node_alloc
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
specifier|const
name|uint8_t
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_setrates
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|,
name|struct
name|iwm_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_newstate
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
name|enum
name|ieee80211_state
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_endscan_cb
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_init_hw
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_init
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_start
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_stop
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_watchdog
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_parent
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|IWM_DEBUG
end_ifdef

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|iwm_desc_lookup
parameter_list|(
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_nic_error
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|iwm_notif_intr
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_preinit
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_detach_local
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_init_task
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_radiotap_attach
parameter_list|(
name|struct
name|iwm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ieee80211vap
modifier|*
name|iwm_vap_create
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|,
specifier|const
name|char
index|[
name|IFNAMSIZ
index|]
parameter_list|,
name|int
parameter_list|,
name|enum
name|ieee80211_opmode
parameter_list|,
name|int
parameter_list|,
specifier|const
name|uint8_t
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|uint8_t
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_vap_delete
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_scan_start
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_scan_end
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_update_mcast
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_set_channel
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_scan_curchan
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
parameter_list|,
name|unsigned
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwm_scan_mindwell
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwm_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Firmware parser.  */
end_comment

begin_function
specifier|static
name|int
name|iwm_store_cscheme
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|data
parameter_list|,
name|size_t
name|dlen
parameter_list|)
block|{
specifier|const
name|struct
name|iwm_fw_cscheme_list
modifier|*
name|l
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|dlen
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|l
argument_list|)
operator|||
name|dlen
operator|<
sizeof|sizeof
argument_list|(
name|l
operator|->
name|size
argument_list|)
operator|+
name|l
operator|->
name|size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|l
operator|->
name|cs
argument_list|)
condition|)
return|return
name|EINVAL
return|;
comment|/* we don't actually store anything for now, always use s/w crypto */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_firmware_store_section
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|enum
name|iwm_ucode_type
name|type
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|data
parameter_list|,
name|size_t
name|dlen
parameter_list|)
block|{
name|struct
name|iwm_fw_sects
modifier|*
name|fws
decl_stmt|;
name|struct
name|iwm_fw_onesect
modifier|*
name|fwone
decl_stmt|;
if|if
condition|(
name|type
operator|>=
name|IWM_UCODE_TYPE_MAX
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|dlen
operator|<
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
return|return
name|EINVAL
return|;
name|fws
operator|=
operator|&
name|sc
operator|->
name|sc_fw
operator|.
name|fw_sects
index|[
name|type
index|]
expr_stmt|;
if|if
condition|(
name|fws
operator|->
name|fw_count
operator|>=
name|IWM_UCODE_SECT_MAX
condition|)
return|return
name|EINVAL
return|;
name|fwone
operator|=
operator|&
name|fws
operator|->
name|fw_sect
index|[
name|fws
operator|->
name|fw_count
index|]
expr_stmt|;
comment|/* first 32bit are device load offset */
name|memcpy
argument_list|(
operator|&
name|fwone
operator|->
name|fws_devoff
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* rest is data */
name|fwone
operator|->
name|fws_data
operator|=
name|data
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|fwone
operator|->
name|fws_len
operator|=
name|dlen
operator|-
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|fws
operator|->
name|fw_count
operator|++
expr_stmt|;
name|fws
operator|->
name|fw_totlen
operator|+=
name|fwone
operator|->
name|fws_len
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* iwlwifi: iwl-drv.c */
end_comment

begin_struct
struct|struct
name|iwm_tlv_calib_data
block|{
name|uint32_t
name|ucode_type
decl_stmt|;
name|struct
name|iwm_tlv_calib_ctrl
name|calib
decl_stmt|;
block|}
name|__packed
struct|;
end_struct

begin_function
specifier|static
name|int
name|iwm_set_default_calib
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|)
block|{
specifier|const
name|struct
name|iwm_tlv_calib_data
modifier|*
name|def_calib
init|=
name|data
decl_stmt|;
name|uint32_t
name|ucode_type
init|=
name|le32toh
argument_list|(
name|def_calib
operator|->
name|ucode_type
argument_list|)
decl_stmt|;
if|if
condition|(
name|ucode_type
operator|>=
name|IWM_UCODE_TYPE_MAX
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Wrong ucode_type %u for default "
literal|"calibration.\n"
argument_list|,
name|ucode_type
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|sc
operator|->
name|sc_default_calib
index|[
name|ucode_type
index|]
operator|.
name|flow_trigger
operator|=
name|def_calib
operator|->
name|calib
operator|.
name|flow_trigger
expr_stmt|;
name|sc
operator|->
name|sc_default_calib
index|[
name|ucode_type
index|]
operator|.
name|event_trigger
operator|=
name|def_calib
operator|->
name|calib
operator|.
name|event_trigger
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_fw_info_free
parameter_list|(
name|struct
name|iwm_fw_info
modifier|*
name|fw
parameter_list|)
block|{
name|firmware_put
argument_list|(
name|fw
operator|->
name|fw_fp
argument_list|,
name|FIRMWARE_UNLOAD
argument_list|)
expr_stmt|;
name|fw
operator|->
name|fw_fp
operator|=
name|NULL
expr_stmt|;
comment|/* don't touch fw->fw_status */
name|memset
argument_list|(
name|fw
operator|->
name|fw_sects
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|fw
operator|->
name|fw_sects
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_read_firmware
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|enum
name|iwm_ucode_type
name|ucode_type
parameter_list|)
block|{
name|struct
name|iwm_fw_info
modifier|*
name|fw
init|=
operator|&
name|sc
operator|->
name|sc_fw
decl_stmt|;
specifier|const
name|struct
name|iwm_tlv_ucode_header
modifier|*
name|uhdr
decl_stmt|;
name|struct
name|iwm_ucode_tlv
name|tlv
decl_stmt|;
name|enum
name|iwm_ucode_tlv_type
name|tlv_type
decl_stmt|;
specifier|const
name|struct
name|firmware
modifier|*
name|fwp
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|data
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|size_t
name|len
decl_stmt|;
if|if
condition|(
name|fw
operator|->
name|fw_status
operator|==
name|IWM_FW_STATUS_DONE
operator|&&
name|ucode_type
operator|!=
name|IWM_UCODE_TYPE_INIT
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|fw
operator|->
name|fw_status
operator|==
name|IWM_FW_STATUS_INPROGRESS
condition|)
name|msleep
argument_list|(
operator|&
name|sc
operator|->
name|sc_fw
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|0
argument_list|,
literal|"iwmfwp"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fw
operator|->
name|fw_status
operator|=
name|IWM_FW_STATUS_INPROGRESS
expr_stmt|;
if|if
condition|(
name|fw
operator|->
name|fw_fp
operator|!=
name|NULL
condition|)
name|iwm_fw_info_free
argument_list|(
name|fw
argument_list|)
expr_stmt|;
comment|/* 	 * Load firmware into driver memory. 	 * fw_fp will be set. 	 */
name|IWM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|fwp
operator|=
name|firmware_get
argument_list|(
name|sc
operator|->
name|sc_fwname
argument_list|)
expr_stmt|;
name|IWM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not read firmware %s (error %d)\n"
argument_list|,
name|sc
operator|->
name|sc_fwname
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|fw
operator|->
name|fw_fp
operator|=
name|fwp
expr_stmt|;
comment|/* 	 * Parse firmware contents 	 */
name|uhdr
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
name|fw
operator|->
name|fw_fp
operator|->
name|data
expr_stmt|;
if|if
condition|(
operator|*
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|fw
operator|->
name|fw_fp
operator|->
name|data
operator|!=
literal|0
operator|||
name|le32toh
argument_list|(
name|uhdr
operator|->
name|magic
argument_list|)
operator|!=
name|IWM_TLV_UCODE_MAGIC
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"invalid firmware %s\n"
argument_list|,
name|sc
operator|->
name|sc_fwname
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|sc
operator|->
name|sc_fwver
operator|=
name|le32toh
argument_list|(
name|uhdr
operator|->
name|ver
argument_list|)
expr_stmt|;
name|data
operator|=
name|uhdr
operator|->
name|data
expr_stmt|;
name|len
operator|=
name|fw
operator|->
name|fw_fp
operator|->
name|datasize
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|uhdr
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|>=
sizeof|sizeof
argument_list|(
name|tlv
argument_list|)
condition|)
block|{
name|size_t
name|tlv_len
decl_stmt|;
specifier|const
name|void
modifier|*
name|tlv_data
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|tlv
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|tlv
argument_list|)
argument_list|)
expr_stmt|;
name|tlv_len
operator|=
name|le32toh
argument_list|(
name|tlv
operator|.
name|length
argument_list|)
expr_stmt|;
name|tlv_type
operator|=
name|le32toh
argument_list|(
name|tlv
operator|.
name|type
argument_list|)
expr_stmt|;
name|len
operator|-=
sizeof|sizeof
argument_list|(
name|tlv
argument_list|)
expr_stmt|;
name|data
operator|+=
sizeof|sizeof
argument_list|(
name|tlv
argument_list|)
expr_stmt|;
name|tlv_data
operator|=
name|data
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|tlv_len
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"firmware too short: %zu bytes\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|parse_out
goto|;
block|}
switch|switch
condition|(
operator|(
name|int
operator|)
name|tlv_type
condition|)
block|{
case|case
name|IWM_UCODE_TLV_PROBE_MAX_LEN
case|:
if|if
condition|(
name|tlv_len
operator|<
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: PROBE_MAX_LEN (%d)< sizeof(uint32_t)\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|int
operator|)
name|tlv_len
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|parse_out
goto|;
block|}
name|sc
operator|->
name|sc_capa_max_probe_len
operator|=
name|le32toh
argument_list|(
operator|*
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|tlv_data
argument_list|)
expr_stmt|;
comment|/* limit it to something sensible */
if|if
condition|(
name|sc
operator|->
name|sc_capa_max_probe_len
operator|>
operator|(
literal|1
operator|<<
literal|16
operator|)
condition|)
block|{
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_FIRMWARE_TLV
argument_list|,
literal|"%s: IWM_UCODE_TLV_PROBE_MAX_LEN "
literal|"ridiculous\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|parse_out
goto|;
block|}
break|break;
case|case
name|IWM_UCODE_TLV_PAN
case|:
if|if
condition|(
name|tlv_len
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: IWM_UCODE_TLV_PAN: tlv_len (%d)> 0\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|int
operator|)
name|tlv_len
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|parse_out
goto|;
block|}
name|sc
operator|->
name|sc_capaflags
operator||=
name|IWM_UCODE_TLV_FLAGS_PAN
expr_stmt|;
break|break;
case|case
name|IWM_UCODE_TLV_FLAGS
case|:
if|if
condition|(
name|tlv_len
operator|<
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: IWM_UCODE_TLV_FLAGS: tlv_len (%d)< sizeof(uint32_t)\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|int
operator|)
name|tlv_len
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|parse_out
goto|;
block|}
comment|/* 			 * Apparently there can be many flags, but Linux driver 			 * parses only the first one, and so do we. 			 * 			 * XXX: why does this override IWM_UCODE_TLV_PAN? 			 * Intentional or a bug?  Observations from 			 * current firmware file: 			 *  1) TLV_PAN is parsed first 			 *  2) TLV_FLAGS contains TLV_FLAGS_PAN 			 * ==> this resets TLV_PAN to itself... hnnnk 			 */
name|sc
operator|->
name|sc_capaflags
operator|=
name|le32toh
argument_list|(
operator|*
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|tlv_data
argument_list|)
expr_stmt|;
break|break;
case|case
name|IWM_UCODE_TLV_CSCHEME
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_store_cscheme
argument_list|(
name|sc
argument_list|,
name|tlv_data
argument_list|,
name|tlv_len
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: iwm_store_cscheme(): returned %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|parse_out
goto|;
block|}
break|break;
case|case
name|IWM_UCODE_TLV_NUM_OF_CPU
case|:
if|if
condition|(
name|tlv_len
operator|!=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: IWM_UCODE_TLV_NUM_OF_CPU: tlv_len (%d)< sizeof(uint32_t)\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|int
operator|)
name|tlv_len
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|parse_out
goto|;
block|}
if|if
condition|(
name|le32toh
argument_list|(
operator|*
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|tlv_data
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: driver supports "
literal|"only TLV_NUM_OF_CPU == 1"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|parse_out
goto|;
block|}
break|break;
case|case
name|IWM_UCODE_TLV_SEC_RT
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_firmware_store_section
argument_list|(
name|sc
argument_list|,
name|IWM_UCODE_TYPE_REGULAR
argument_list|,
name|tlv_data
argument_list|,
name|tlv_len
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: IWM_UCODE_TYPE_REGULAR: iwm_firmware_store_section() failed; %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|parse_out
goto|;
block|}
break|break;
case|case
name|IWM_UCODE_TLV_SEC_INIT
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_firmware_store_section
argument_list|(
name|sc
argument_list|,
name|IWM_UCODE_TYPE_INIT
argument_list|,
name|tlv_data
argument_list|,
name|tlv_len
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: IWM_UCODE_TYPE_INIT: iwm_firmware_store_section() failed; %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|parse_out
goto|;
block|}
break|break;
case|case
name|IWM_UCODE_TLV_SEC_WOWLAN
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_firmware_store_section
argument_list|(
name|sc
argument_list|,
name|IWM_UCODE_TYPE_WOW
argument_list|,
name|tlv_data
argument_list|,
name|tlv_len
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: IWM_UCODE_TYPE_WOW: iwm_firmware_store_section() failed; %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|parse_out
goto|;
block|}
break|break;
case|case
name|IWM_UCODE_TLV_DEF_CALIB
case|:
if|if
condition|(
name|tlv_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|iwm_tlv_calib_data
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: IWM_UCODE_TLV_DEV_CALIB: tlv_len (%d)< sizeof(iwm_tlv_calib_data) (%d)\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|int
operator|)
name|tlv_len
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|iwm_tlv_calib_data
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|parse_out
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_set_default_calib
argument_list|(
name|sc
argument_list|,
name|tlv_data
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: iwm_set_default_calib() failed: %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|parse_out
goto|;
block|}
break|break;
case|case
name|IWM_UCODE_TLV_PHY_SKU
case|:
if|if
condition|(
name|tlv_len
operator|!=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: IWM_UCODE_TLV_PHY_SKU: tlv_len (%d)< sizeof(uint32_t)\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|int
operator|)
name|tlv_len
argument_list|)
expr_stmt|;
goto|goto
name|parse_out
goto|;
block|}
name|sc
operator|->
name|sc_fw_phy_config
operator|=
name|le32toh
argument_list|(
operator|*
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|tlv_data
argument_list|)
expr_stmt|;
break|break;
case|case
name|IWM_UCODE_TLV_API_CHANGES_SET
case|:
case|case
name|IWM_UCODE_TLV_ENABLED_CAPABILITIES
case|:
comment|/* ignore, not used by current driver */
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: unknown firmware section %d, abort\n"
argument_list|,
name|__func__
argument_list|,
name|tlv_type
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|parse_out
goto|;
block|}
name|len
operator|-=
name|roundup
argument_list|(
name|tlv_len
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|data
operator|+=
name|roundup
argument_list|(
name|tlv_len
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"unhandled error"
operator|)
argument_list|)
expr_stmt|;
name|parse_out
label|:
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"firmware parse error %d, "
literal|"section type %d\n"
argument_list|,
name|error
argument_list|,
name|tlv_type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_capaflags
operator|&
name|IWM_UCODE_TLV_FLAGS_PM_CMD_SUPPORT
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"device uses unsupported power ops\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOTSUP
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|error
condition|)
block|{
name|fw
operator|->
name|fw_status
operator|=
name|IWM_FW_STATUS_NONE
expr_stmt|;
if|if
condition|(
name|fw
operator|->
name|fw_fp
operator|!=
name|NULL
condition|)
name|iwm_fw_info_free
argument_list|(
name|fw
argument_list|)
expr_stmt|;
block|}
else|else
name|fw
operator|->
name|fw_status
operator|=
name|IWM_FW_STATUS_DONE
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|sc_fw
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * DMA resource routines  */
end_comment

begin_function
specifier|static
name|void
name|iwm_dma_map_addr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return;
name|KASSERT
argument_list|(
name|nsegs
operator|==
literal|1
argument_list|,
operator|(
literal|"too many DMA segments, %d should be 1"
operator|,
name|nsegs
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|bus_addr_t
operator|*
operator|)
name|arg
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_dma_contig_alloc
parameter_list|(
name|bus_dma_tag_t
name|tag
parameter_list|,
name|struct
name|iwm_dma_info
modifier|*
name|dma
parameter_list|,
name|bus_size_t
name|size
parameter_list|,
name|bus_size_t
name|alignment
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|dma
operator|->
name|tag
operator|=
name|NULL
expr_stmt|;
name|dma
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|tag
argument_list|,
name|alignment
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|size
argument_list|,
literal|1
argument_list|,
name|size
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|dma
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|dma
operator|->
name|vaddr
argument_list|,
name|BUS_DMA_NOWAIT
operator||
name|BUS_DMA_ZERO
operator||
name|BUS_DMA_COHERENT
argument_list|,
operator|&
name|dma
operator|->
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
name|dma
operator|->
name|map
argument_list|,
name|dma
operator|->
name|vaddr
argument_list|,
name|size
argument_list|,
name|iwm_dma_map_addr
argument_list|,
operator|&
name|dma
operator|->
name|paddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|bus_dmamap_sync
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
name|dma
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|fail
label|:
name|iwm_dma_contig_free
argument_list|(
name|dma
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_dma_contig_free
parameter_list|(
name|struct
name|iwm_dma_info
modifier|*
name|dma
parameter_list|)
block|{
if|if
condition|(
name|dma
operator|->
name|map
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dma
operator|->
name|vaddr
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
name|dma
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
name|dma
operator|->
name|map
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
name|dma
operator|->
name|vaddr
argument_list|,
name|dma
operator|->
name|map
argument_list|)
expr_stmt|;
name|dma
operator|->
name|vaddr
operator|=
name|NULL
expr_stmt|;
block|}
name|bus_dmamap_destroy
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
name|dma
operator|->
name|map
argument_list|)
expr_stmt|;
name|dma
operator|->
name|map
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|dma
operator|->
name|tag
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|dma
operator|->
name|tag
argument_list|)
expr_stmt|;
name|dma
operator|->
name|tag
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* fwmem is used to load firmware onto the card */
end_comment

begin_function
specifier|static
name|int
name|iwm_alloc_fwmem
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Must be aligned on a 16-byte boundary. */
return|return
name|iwm_dma_contig_alloc
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
operator|&
name|sc
operator|->
name|fw_dma
argument_list|,
name|sc
operator|->
name|sc_fwdmasegsz
argument_list|,
literal|16
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_free_fwmem
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|iwm_dma_contig_free
argument_list|(
operator|&
name|sc
operator|->
name|fw_dma
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* tx scheduler rings.  not used? */
end_comment

begin_function
specifier|static
name|int
name|iwm_alloc_sched
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|rv
decl_stmt|;
comment|/* TX scheduler rings must be aligned on a 1KB boundary. */
name|rv
operator|=
name|iwm_dma_contig_alloc
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
operator|&
name|sc
operator|->
name|sched_dma
argument_list|,
name|nitems
argument_list|(
name|sc
operator|->
name|txq
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|iwm_agn_scd_bc_tbl
argument_list|)
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_free_sched
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|iwm_dma_contig_free
argument_list|(
operator|&
name|sc
operator|->
name|sched_dma
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* keep-warm page is used internally by the card.  see iwl-fh.h for more info */
end_comment

begin_function
specifier|static
name|int
name|iwm_alloc_kw
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return
name|iwm_dma_contig_alloc
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
operator|&
name|sc
operator|->
name|kw_dma
argument_list|,
literal|4096
argument_list|,
literal|4096
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_free_kw
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|iwm_dma_contig_free
argument_list|(
operator|&
name|sc
operator|->
name|kw_dma
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* interrupt cause table */
end_comment

begin_function
specifier|static
name|int
name|iwm_alloc_ict
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return
name|iwm_dma_contig_alloc
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
operator|&
name|sc
operator|->
name|ict_dma
argument_list|,
name|IWM_ICT_SIZE
argument_list|,
literal|1
operator|<<
name|IWM_ICT_PADDR_SHIFT
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_free_ict
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|iwm_dma_contig_free
argument_list|(
operator|&
name|sc
operator|->
name|ict_dma
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_alloc_rx_ring
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwm_rx_ring
modifier|*
name|ring
parameter_list|)
block|{
name|bus_size_t
name|size
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|ring
operator|->
name|cur
operator|=
literal|0
expr_stmt|;
comment|/* Allocate RX descriptors (256-byte aligned). */
name|size
operator|=
name|IWM_RX_RING_COUNT
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwm_dma_contig_alloc
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
operator|&
name|ring
operator|->
name|desc_dma
argument_list|,
name|size
argument_list|,
literal|256
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not allocate RX ring DMA memory\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ring
operator|->
name|desc
operator|=
name|ring
operator|->
name|desc_dma
operator|.
name|vaddr
expr_stmt|;
comment|/* Allocate RX status area (16-byte aligned). */
name|error
operator|=
name|iwm_dma_contig_alloc
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
operator|&
name|ring
operator|->
name|stat_dma
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ring
operator|->
name|stat
argument_list|)
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not allocate RX status DMA memory\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ring
operator|->
name|stat
operator|=
name|ring
operator|->
name|stat_dma
operator|.
name|vaddr
expr_stmt|;
comment|/* Create RX buffer DMA tag. */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|IWM_RBUF_SIZE
argument_list|,
literal|1
argument_list|,
name|IWM_RBUF_SIZE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|ring
operator|->
name|data_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not create RX buf DMA tag, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 	 * Allocate and map RX buffers. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IWM_RX_RING_COUNT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_rx_addbuf
argument_list|(
name|sc
argument_list|,
name|IWM_RBUF_SIZE
argument_list|,
name|i
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|fail
goto|;
block|}
block|}
return|return
literal|0
return|;
name|fail
label|:
name|iwm_free_rx_ring
argument_list|(
name|sc
argument_list|,
name|ring
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_reset_rx_ring
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwm_rx_ring
modifier|*
name|ring
parameter_list|)
block|{
comment|/* XXX print out if we can't lock the NIC? */
if|if
condition|(
name|iwm_nic_lock
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* XXX handle if RX stop doesn't finish? */
operator|(
name|void
operator|)
name|iwm_pcie_rx_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iwm_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* Reset the ring state */
name|ring
operator|->
name|cur
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|sc
operator|->
name|rxq
operator|.
name|stat
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
operator|->
name|rxq
operator|.
name|stat
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_free_rx_ring
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwm_rx_ring
modifier|*
name|ring
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|iwm_dma_contig_free
argument_list|(
operator|&
name|ring
operator|->
name|desc_dma
argument_list|)
expr_stmt|;
name|iwm_dma_contig_free
argument_list|(
operator|&
name|ring
operator|->
name|stat_dma
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IWM_RX_RING_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|iwm_rx_data
modifier|*
name|data
init|=
operator|&
name|ring
operator|->
name|data
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|data
operator|->
name|m
argument_list|)
expr_stmt|;
name|data
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|->
name|map
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
name|data
operator|->
name|map
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ring
operator|->
name|data_dmat
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|)
expr_stmt|;
name|ring
operator|->
name|data_dmat
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_alloc_tx_ring
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwm_tx_ring
modifier|*
name|ring
parameter_list|,
name|int
name|qid
parameter_list|)
block|{
name|bus_addr_t
name|paddr
decl_stmt|;
name|bus_size_t
name|size
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|ring
operator|->
name|qid
operator|=
name|qid
expr_stmt|;
name|ring
operator|->
name|queued
operator|=
literal|0
expr_stmt|;
name|ring
operator|->
name|cur
operator|=
literal|0
expr_stmt|;
comment|/* Allocate TX descriptors (256-byte aligned). */
name|size
operator|=
name|IWM_TX_RING_COUNT
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|iwm_tfd
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwm_dma_contig_alloc
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
operator|&
name|ring
operator|->
name|desc_dma
argument_list|,
name|size
argument_list|,
literal|256
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not allocate TX ring DMA memory\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ring
operator|->
name|desc
operator|=
name|ring
operator|->
name|desc_dma
operator|.
name|vaddr
expr_stmt|;
comment|/* 	 * We only use rings 0 through 9 (4 EDCA + cmd) so there is no need 	 * to allocate commands space for other rings. 	 */
if|if
condition|(
name|qid
operator|>
name|IWM_MVM_CMD_QUEUE
condition|)
return|return
literal|0
return|;
name|size
operator|=
name|IWM_TX_RING_COUNT
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|iwm_device_cmd
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwm_dma_contig_alloc
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
operator|&
name|ring
operator|->
name|cmd_dma
argument_list|,
name|size
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not allocate TX cmd DMA memory\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ring
operator|->
name|cmd
operator|=
name|ring
operator|->
name|cmd_dma
operator|.
name|vaddr
expr_stmt|;
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|MCLBYTES
argument_list|,
name|IWM_MAX_SCATTER
operator|-
literal|2
argument_list|,
name|MCLBYTES
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|ring
operator|->
name|data_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not create TX buf DMA tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|paddr
operator|=
name|ring
operator|->
name|cmd_dma
operator|.
name|paddr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IWM_TX_RING_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|iwm_tx_data
modifier|*
name|data
init|=
operator|&
name|ring
operator|->
name|data
index|[
name|i
index|]
decl_stmt|;
name|data
operator|->
name|cmd_paddr
operator|=
name|paddr
expr_stmt|;
name|data
operator|->
name|scratch_paddr
operator|=
name|paddr
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|iwm_cmd_header
argument_list|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|iwm_tx_cmd
argument_list|,
name|scratch
argument_list|)
expr_stmt|;
name|paddr
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|iwm_device_cmd
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
literal|0
argument_list|,
operator|&
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not create TX buf DMA map\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
name|KASSERT
argument_list|(
name|paddr
operator|==
name|ring
operator|->
name|cmd_dma
operator|.
name|paddr
operator|+
name|size
argument_list|,
operator|(
literal|"invalid physical address"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|fail
label|:
name|iwm_free_tx_ring
argument_list|(
name|sc
argument_list|,
name|ring
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_reset_tx_ring
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwm_tx_ring
modifier|*
name|ring
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IWM_TX_RING_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|iwm_tx_data
modifier|*
name|data
init|=
operator|&
name|ring
operator|->
name|data
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|data
operator|->
name|m
argument_list|)
expr_stmt|;
name|data
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Clear TX descriptors. */
name|memset
argument_list|(
name|ring
operator|->
name|desc
argument_list|,
literal|0
argument_list|,
name|ring
operator|->
name|desc_dma
operator|.
name|size
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|desc_dma
operator|.
name|tag
argument_list|,
name|ring
operator|->
name|desc_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|qfullmsk
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|ring
operator|->
name|qid
operator|)
expr_stmt|;
name|ring
operator|->
name|queued
operator|=
literal|0
expr_stmt|;
name|ring
operator|->
name|cur
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_free_tx_ring
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwm_tx_ring
modifier|*
name|ring
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|iwm_dma_contig_free
argument_list|(
operator|&
name|ring
operator|->
name|desc_dma
argument_list|)
expr_stmt|;
name|iwm_dma_contig_free
argument_list|(
operator|&
name|ring
operator|->
name|cmd_dma
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IWM_TX_RING_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|iwm_tx_data
modifier|*
name|data
init|=
operator|&
name|ring
operator|->
name|data
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|data
operator|->
name|m
argument_list|)
expr_stmt|;
name|data
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|->
name|map
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
name|data
operator|->
name|map
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ring
operator|->
name|data_dmat
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|)
expr_stmt|;
name|ring
operator|->
name|data_dmat
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * High-level hardware frobbing routines  */
end_comment

begin_function
specifier|static
name|void
name|iwm_enable_interrupts
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|sc_intmask
operator|=
name|IWM_CSR_INI_SET_MASK
expr_stmt|;
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_INT_MASK
argument_list|,
name|sc
operator|->
name|sc_intmask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_restore_interrupts
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_INT_MASK
argument_list|,
name|sc
operator|->
name|sc_intmask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_disable_interrupts
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* disable interrupts */
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_INT_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* acknowledge all interrupts */
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_INT
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_FH_INT_STATUS
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_ict_reset
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|iwm_disable_interrupts
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Reset ICT table. */
name|memset
argument_list|(
name|sc
operator|->
name|ict_dma
operator|.
name|vaddr
argument_list|,
literal|0
argument_list|,
name|IWM_ICT_SIZE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ict_cur
operator|=
literal|0
expr_stmt|;
comment|/* Set physical address of ICT table (4KB aligned). */
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_DRAM_INT_TBL_REG
argument_list|,
name|IWM_CSR_DRAM_INT_TBL_ENABLE
operator||
name|IWM_CSR_DRAM_INIT_TBL_WRAP_CHECK
operator||
name|sc
operator|->
name|ict_dma
operator|.
name|paddr
operator|>>
name|IWM_ICT_PADDR_SHIFT
argument_list|)
expr_stmt|;
comment|/* Switch to ICT interrupt mode in driver. */
name|sc
operator|->
name|sc_flags
operator||=
name|IWM_FLAG_USE_ICT
expr_stmt|;
comment|/* Re-enable interrupts. */
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_INT
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
name|iwm_enable_interrupts
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* iwlwifi pcie/trans.c */
end_comment

begin_comment
comment|/*  * Since this .. hard-resets things, it's time to actually  * mark the first vap (if any) as having no mac context.  * It's annoying, but since the driver is potentially being  * stop/start'ed whilst active (thanks openbsd port!) we  * have to correctly track this.  */
end_comment

begin_function
specifier|static
name|void
name|iwm_stop_device
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
decl_stmt|;
name|int
name|chnl
decl_stmt|,
name|ntries
decl_stmt|;
name|int
name|qid
decl_stmt|;
comment|/* tell the device to stop sending interrupts */
name|iwm_disable_interrupts
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * FreeBSD-local: mark the first vap as not-uploaded, 	 * so the next transition through auth/assoc 	 * will correctly populate the MAC context. 	 */
if|if
condition|(
name|vap
condition|)
block|{
name|struct
name|iwm_vap
modifier|*
name|iv
init|=
name|IWM_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|iv
operator|->
name|is_uploaded
operator|=
literal|0
expr_stmt|;
block|}
comment|/* device going down, Stop using ICT table */
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|IWM_FLAG_USE_ICT
expr_stmt|;
comment|/* stop tx and rx.  tx and rx bits, as usual, are from if_iwn */
name|iwm_write_prph
argument_list|(
name|sc
argument_list|,
name|IWM_SCD_TXFACT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Stop all DMA channels. */
if|if
condition|(
name|iwm_nic_lock
argument_list|(
name|sc
argument_list|)
condition|)
block|{
for|for
control|(
name|chnl
operator|=
literal|0
init|;
name|chnl
operator|<
name|IWM_FH_TCSR_CHNL_NUM
condition|;
name|chnl
operator|++
control|)
block|{
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_FH_TCSR_CHNL_TX_CONFIG_REG
argument_list|(
name|chnl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|ntries
operator|=
literal|0
init|;
name|ntries
operator|<
literal|200
condition|;
name|ntries
operator|++
control|)
block|{
name|uint32_t
name|r
decl_stmt|;
name|r
operator|=
name|IWM_READ
argument_list|(
name|sc
argument_list|,
name|IWM_FH_TSSR_TX_STATUS_REG
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|&
name|IWM_FH_TSSR_TX_STATUS_REG_MSK_CHNL_IDLE
argument_list|(
name|chnl
argument_list|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|20
argument_list|)
expr_stmt|;
block|}
block|}
name|iwm_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* Stop RX ring. */
name|iwm_reset_rx_ring
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rxq
argument_list|)
expr_stmt|;
comment|/* Reset all TX rings. */
for|for
control|(
name|qid
operator|=
literal|0
init|;
name|qid
operator|<
name|nitems
argument_list|(
name|sc
operator|->
name|txq
argument_list|)
condition|;
name|qid
operator|++
control|)
name|iwm_reset_tx_ring
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|txq
index|[
name|qid
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Power-down device's busmaster DMA clocks 	 */
name|iwm_write_prph
argument_list|(
name|sc
argument_list|,
name|IWM_APMG_CLK_DIS_REG
argument_list|,
name|IWM_APMG_CLK_VAL_DMA_CLK_RQT
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
comment|/* Make sure (redundant) we've released our request to stay awake */
name|IWM_CLRBITS
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_GP_CNTRL
argument_list|,
name|IWM_CSR_GP_CNTRL_REG_FLAG_MAC_ACCESS_REQ
argument_list|)
expr_stmt|;
comment|/* Stop the device, and put it in low power state */
name|iwm_apm_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Upon stop, the APM issues an interrupt if HW RF kill is set. 	 * Clean again the interrupt here 	 */
name|iwm_disable_interrupts
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* stop and reset the on-board processor */
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_RESET
argument_list|,
name|IWM_CSR_RESET_REG_FLAG_NEVO_RESET
argument_list|)
expr_stmt|;
comment|/* 	 * Even if we stop the HW, we still want the RF kill 	 * interrupt 	 */
name|iwm_enable_rfkill_int
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iwm_check_rfkill
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* iwlwifi: mvm/ops.c */
end_comment

begin_function
specifier|static
name|void
name|iwm_mvm_nic_config
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint8_t
name|radio_cfg_type
decl_stmt|,
name|radio_cfg_step
decl_stmt|,
name|radio_cfg_dash
decl_stmt|;
name|uint32_t
name|reg_val
init|=
literal|0
decl_stmt|;
name|radio_cfg_type
operator|=
operator|(
name|sc
operator|->
name|sc_fw_phy_config
operator|&
name|IWM_FW_PHY_CFG_RADIO_TYPE
operator|)
operator|>>
name|IWM_FW_PHY_CFG_RADIO_TYPE_POS
expr_stmt|;
name|radio_cfg_step
operator|=
operator|(
name|sc
operator|->
name|sc_fw_phy_config
operator|&
name|IWM_FW_PHY_CFG_RADIO_STEP
operator|)
operator|>>
name|IWM_FW_PHY_CFG_RADIO_STEP_POS
expr_stmt|;
name|radio_cfg_dash
operator|=
operator|(
name|sc
operator|->
name|sc_fw_phy_config
operator|&
name|IWM_FW_PHY_CFG_RADIO_DASH
operator|)
operator|>>
name|IWM_FW_PHY_CFG_RADIO_DASH_POS
expr_stmt|;
comment|/* SKU control */
name|reg_val
operator||=
name|IWM_CSR_HW_REV_STEP
argument_list|(
name|sc
operator|->
name|sc_hw_rev
argument_list|)
operator|<<
name|IWM_CSR_HW_IF_CONFIG_REG_POS_MAC_STEP
expr_stmt|;
name|reg_val
operator||=
name|IWM_CSR_HW_REV_DASH
argument_list|(
name|sc
operator|->
name|sc_hw_rev
argument_list|)
operator|<<
name|IWM_CSR_HW_IF_CONFIG_REG_POS_MAC_DASH
expr_stmt|;
comment|/* radio configuration */
name|reg_val
operator||=
name|radio_cfg_type
operator|<<
name|IWM_CSR_HW_IF_CONFIG_REG_POS_PHY_TYPE
expr_stmt|;
name|reg_val
operator||=
name|radio_cfg_step
operator|<<
name|IWM_CSR_HW_IF_CONFIG_REG_POS_PHY_STEP
expr_stmt|;
name|reg_val
operator||=
name|radio_cfg_dash
operator|<<
name|IWM_CSR_HW_IF_CONFIG_REG_POS_PHY_DASH
expr_stmt|;
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_HW_IF_CONFIG_REG
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_RESET
argument_list|,
literal|"Radio type=0x%x-0x%x-0x%x\n"
argument_list|,
name|radio_cfg_type
argument_list|,
name|radio_cfg_step
argument_list|,
name|radio_cfg_dash
argument_list|)
expr_stmt|;
comment|/* 	 * W/A : NIC is stuck in a reset state after Early PCIe power off 	 * (PCIe power is lost before PERST# is asserted), causing ME FW 	 * to lose ownership and not being able to obtain it back. 	 */
name|iwm_set_bits_mask_prph
argument_list|(
name|sc
argument_list|,
name|IWM_APMG_PS_CTRL_REG
argument_list|,
name|IWM_APMG_PS_CTRL_EARLY_PWR_OFF_RESET_DIS
argument_list|,
operator|~
name|IWM_APMG_PS_CTRL_EARLY_PWR_OFF_RESET_DIS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_nic_rx_init
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
operator|!
name|iwm_nic_lock
argument_list|(
name|sc
argument_list|)
condition|)
return|return
name|EBUSY
return|;
comment|/* 	 * Initialize RX ring.  This is from the iwn driver. 	 */
name|memset
argument_list|(
name|sc
operator|->
name|rxq
operator|.
name|stat
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
operator|->
name|rxq
operator|.
name|stat
argument_list|)
argument_list|)
expr_stmt|;
comment|/* stop DMA */
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_FH_MEM_RCSR_CHNL0_CONFIG_REG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_FH_MEM_RCSR_CHNL0_RBDCB_WPTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_FH_MEM_RCSR_CHNL0_FLUSH_RB_REQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_FH_RSCSR_CHNL0_RDPTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_FH_RSCSR_CHNL0_RBDCB_WPTR_REG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set physical address of RX ring (256-byte aligned). */
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_FH_RSCSR_CHNL0_RBDCB_BASE_REG
argument_list|,
name|sc
operator|->
name|rxq
operator|.
name|desc_dma
operator|.
name|paddr
operator|>>
literal|8
argument_list|)
expr_stmt|;
comment|/* Set physical address of RX status (16-byte aligned). */
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_FH_RSCSR_CHNL0_STTS_WPTR_REG
argument_list|,
name|sc
operator|->
name|rxq
operator|.
name|stat_dma
operator|.
name|paddr
operator|>>
literal|4
argument_list|)
expr_stmt|;
comment|/* Enable RX. */
comment|/* 	 * Note: Linux driver also sets this: 	 *  (IWM_RX_RB_TIMEOUT<< IWM_FH_RCSR_RX_CONFIG_REG_IRQ_RBTH_POS) | 	 * 	 * It causes weird behavior.  YMMV. 	 */
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_FH_MEM_RCSR_CHNL0_CONFIG_REG
argument_list|,
name|IWM_FH_RCSR_RX_CONFIG_CHNL_EN_ENABLE_VAL
operator||
name|IWM_FH_RCSR_CHNL0_RX_IGNORE_RXF_EMPTY
operator||
comment|/* HW bug */
name|IWM_FH_RCSR_CHNL0_RX_CONFIG_IRQ_DEST_INT_HOST_VAL
operator||
name|IWM_FH_RCSR_RX_CONFIG_REG_VAL_RB_SIZE_4K
operator||
name|IWM_RX_QUEUE_SIZE_LOG
operator|<<
name|IWM_FH_RCSR_RX_CONFIG_RBDCB_SIZE_POS
argument_list|)
expr_stmt|;
name|IWM_WRITE_1
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_INT_COALESCING
argument_list|,
name|IWM_HOST_INT_TIMEOUT_DEF
argument_list|)
expr_stmt|;
comment|/* W/A for interrupt coalescing bug in 7260 and 3160 */
if|if
condition|(
name|sc
operator|->
name|host_interrupt_operation_mode
condition|)
name|IWM_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_INT_COALESCING
argument_list|,
name|IWM_HOST_INT_OPER_MODE
argument_list|)
expr_stmt|;
comment|/* 	 * Thus sayeth el jefe (iwlwifi) via a comment: 	 * 	 * This value should initially be 0 (before preparing any  	 * RBs), should be 8 after preparing the first 8 RBs (for example) 	 */
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_FH_RSCSR_CHNL0_WPTR
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|iwm_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_nic_tx_init
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|qid
decl_stmt|;
if|if
condition|(
operator|!
name|iwm_nic_lock
argument_list|(
name|sc
argument_list|)
condition|)
return|return
name|EBUSY
return|;
comment|/* Deactivate TX scheduler. */
name|iwm_write_prph
argument_list|(
name|sc
argument_list|,
name|IWM_SCD_TXFACT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set physical address of "keep warm" page (16-byte aligned). */
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_FH_KW_MEM_ADDR_REG
argument_list|,
name|sc
operator|->
name|kw_dma
operator|.
name|paddr
operator|>>
literal|4
argument_list|)
expr_stmt|;
comment|/* Initialize TX rings. */
for|for
control|(
name|qid
operator|=
literal|0
init|;
name|qid
operator|<
name|nitems
argument_list|(
name|sc
operator|->
name|txq
argument_list|)
condition|;
name|qid
operator|++
control|)
block|{
name|struct
name|iwm_tx_ring
modifier|*
name|txq
init|=
operator|&
name|sc
operator|->
name|txq
index|[
name|qid
index|]
decl_stmt|;
comment|/* Set physical address of TX ring (256-byte aligned). */
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_FH_MEM_CBBC_QUEUE
argument_list|(
name|qid
argument_list|)
argument_list|,
name|txq
operator|->
name|desc_dma
operator|.
name|paddr
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_XMIT
argument_list|,
literal|"%s: loading ring %d descriptors (%p) at %lx\n"
argument_list|,
name|__func__
argument_list|,
name|qid
argument_list|,
name|txq
operator|->
name|desc
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|txq
operator|->
name|desc_dma
operator|.
name|paddr
operator|>>
literal|8
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|iwm_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_nic_init
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|iwm_apm_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iwm_set_pwr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iwm_mvm_nic_config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_nic_rx_init
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
comment|/* 	 * Ditto for TX, from iwn 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_nic_tx_init
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_RESET
argument_list|,
literal|"%s: shadow registers enabled\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|IWM_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_MAC_SHADOW_REG_CTRL
argument_list|,
literal|0x800fffff
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_enum
enum|enum
name|iwm_mvm_tx_fifo
block|{
name|IWM_MVM_TX_FIFO_BK
init|=
literal|0
block|,
name|IWM_MVM_TX_FIFO_BE
block|,
name|IWM_MVM_TX_FIFO_VI
block|,
name|IWM_MVM_TX_FIFO_VO
block|,
name|IWM_MVM_TX_FIFO_MCAST
init|=
literal|5
block|, }
enum|;
end_enum

begin_decl_stmt
specifier|const
name|uint8_t
name|iwm_mvm_ac_to_tx_fifo
index|[]
init|=
block|{
name|IWM_MVM_TX_FIFO_VO
block|,
name|IWM_MVM_TX_FIFO_VI
block|,
name|IWM_MVM_TX_FIFO_BE
block|,
name|IWM_MVM_TX_FIFO_BK
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|iwm_enable_txq
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|int
name|qid
parameter_list|,
name|int
name|fifo
parameter_list|)
block|{
if|if
condition|(
operator|!
name|iwm_nic_lock
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: cannot enable txq %d\n"
argument_list|,
name|__func__
argument_list|,
name|qid
argument_list|)
expr_stmt|;
return|return;
comment|/* XXX return EBUSY */
block|}
comment|/* unactivate before configuration */
name|iwm_write_prph
argument_list|(
name|sc
argument_list|,
name|IWM_SCD_QUEUE_STATUS_BITS
argument_list|(
name|qid
argument_list|)
argument_list|,
operator|(
literal|0
operator|<<
name|IWM_SCD_QUEUE_STTS_REG_POS_ACTIVE
operator|)
operator||
operator|(
literal|1
operator|<<
name|IWM_SCD_QUEUE_STTS_REG_POS_SCD_ACT_EN
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qid
operator|!=
name|IWM_MVM_CMD_QUEUE
condition|)
block|{
name|iwm_set_bits_prph
argument_list|(
name|sc
argument_list|,
name|IWM_SCD_QUEUECHAIN_SEL
argument_list|,
operator|(
literal|1
operator|<<
name|qid
operator|)
argument_list|)
expr_stmt|;
block|}
name|iwm_clear_bits_prph
argument_list|(
name|sc
argument_list|,
name|IWM_SCD_AGGR_SEL
argument_list|,
operator|(
literal|1
operator|<<
name|qid
operator|)
argument_list|)
expr_stmt|;
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_HBUS_TARG_WRPTR
argument_list|,
name|qid
operator|<<
literal|8
operator||
literal|0
argument_list|)
expr_stmt|;
name|iwm_write_prph
argument_list|(
name|sc
argument_list|,
name|IWM_SCD_QUEUE_RDPTR
argument_list|(
name|qid
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iwm_write_mem32
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sched_base
operator|+
name|IWM_SCD_CONTEXT_QUEUE_OFFSET
argument_list|(
name|qid
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set scheduler window size and frame limit. */
name|iwm_write_mem32
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sched_base
operator|+
name|IWM_SCD_CONTEXT_QUEUE_OFFSET
argument_list|(
name|qid
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
operator|(
operator|(
name|IWM_FRAME_LIMIT
operator|<<
name|IWM_SCD_QUEUE_CTX_REG2_WIN_SIZE_POS
operator|)
operator|&
name|IWM_SCD_QUEUE_CTX_REG2_WIN_SIZE_MSK
operator|)
operator||
operator|(
operator|(
name|IWM_FRAME_LIMIT
operator|<<
name|IWM_SCD_QUEUE_CTX_REG2_FRAME_LIMIT_POS
operator|)
operator|&
name|IWM_SCD_QUEUE_CTX_REG2_FRAME_LIMIT_MSK
operator|)
argument_list|)
expr_stmt|;
name|iwm_write_prph
argument_list|(
name|sc
argument_list|,
name|IWM_SCD_QUEUE_STATUS_BITS
argument_list|(
name|qid
argument_list|)
argument_list|,
operator|(
literal|1
operator|<<
name|IWM_SCD_QUEUE_STTS_REG_POS_ACTIVE
operator|)
operator||
operator|(
name|fifo
operator|<<
name|IWM_SCD_QUEUE_STTS_REG_POS_TXF
operator|)
operator||
operator|(
literal|1
operator|<<
name|IWM_SCD_QUEUE_STTS_REG_POS_WSL
operator|)
operator||
name|IWM_SCD_QUEUE_STTS_REG_MSK
argument_list|)
expr_stmt|;
name|iwm_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_XMIT
argument_list|,
literal|"%s: enabled txq %d FIFO %d\n"
argument_list|,
name|__func__
argument_list|,
name|qid
argument_list|,
name|fifo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_post_alive
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|nwords
decl_stmt|;
name|int
name|error
decl_stmt|,
name|chnl
decl_stmt|;
if|if
condition|(
operator|!
name|iwm_nic_lock
argument_list|(
name|sc
argument_list|)
condition|)
return|return
name|EBUSY
return|;
if|if
condition|(
name|sc
operator|->
name|sched_base
operator|!=
name|iwm_read_prph
argument_list|(
name|sc
argument_list|,
name|IWM_SCD_SRAM_BASE_ADDR
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: sched addr mismatch"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|iwm_ict_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Clear TX scheduler state in SRAM. */
name|nwords
operator|=
operator|(
name|IWM_SCD_TRANS_TBL_MEM_UPPER_BOUND
operator|-
name|IWM_SCD_CONTEXT_MEM_LOWER_BOUND
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwm_write_mem
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sched_base
operator|+
name|IWM_SCD_CONTEXT_MEM_LOWER_BOUND
argument_list|,
name|NULL
argument_list|,
name|nwords
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
comment|/* Set physical address of TX scheduler rings (1KB aligned). */
name|iwm_write_prph
argument_list|(
name|sc
argument_list|,
name|IWM_SCD_DRAM_BASE_ADDR
argument_list|,
name|sc
operator|->
name|sched_dma
operator|.
name|paddr
operator|>>
literal|10
argument_list|)
expr_stmt|;
name|iwm_write_prph
argument_list|(
name|sc
argument_list|,
name|IWM_SCD_CHAINEXT_EN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* enable command channel */
name|iwm_enable_txq
argument_list|(
name|sc
argument_list|,
name|IWM_MVM_CMD_QUEUE
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|iwm_write_prph
argument_list|(
name|sc
argument_list|,
name|IWM_SCD_TXFACT
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* Enable DMA channels. */
for|for
control|(
name|chnl
operator|=
literal|0
init|;
name|chnl
operator|<
name|IWM_FH_TCSR_CHNL_NUM
condition|;
name|chnl
operator|++
control|)
block|{
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_FH_TCSR_CHNL_TX_CONFIG_REG
argument_list|(
name|chnl
argument_list|)
argument_list|,
name|IWM_FH_TCSR_TX_CONFIG_REG_VAL_DMA_CHNL_ENABLE
operator||
name|IWM_FH_TCSR_TX_CONFIG_REG_VAL_DMA_CREDIT_ENABLE
argument_list|)
expr_stmt|;
block|}
name|IWM_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWM_FH_TX_CHICKEN_BITS_REG
argument_list|,
name|IWM_FH_TX_CHICKEN_BITS_SCD_AUTO_RETRY_EN
argument_list|)
expr_stmt|;
comment|/* Enable L1-Active */
name|iwm_clear_bits_prph
argument_list|(
name|sc
argument_list|,
name|IWM_APMG_PCIDEV_STT_REG
argument_list|,
name|IWM_APMG_PCIDEV_STT_VAL_L1_ACT_DIS
argument_list|)
expr_stmt|;
name|out
label|:
name|iwm_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * NVM read access and content parsing.  We do not support  * external NVM or writing NVM.  * iwlwifi/mvm/nvm.c  */
end_comment

begin_comment
comment|/* list of NVM sections we are allowed/need to read */
end_comment

begin_decl_stmt
specifier|const
name|int
name|nvm_to_read
index|[]
init|=
block|{
name|IWM_NVM_SECTION_TYPE_HW
block|,
name|IWM_NVM_SECTION_TYPE_SW
block|,
name|IWM_NVM_SECTION_TYPE_CALIBRATION
block|,
name|IWM_NVM_SECTION_TYPE_PRODUCTION
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default NVM size to read */
end_comment

begin_define
define|#
directive|define
name|IWM_NVM_DEFAULT_CHUNK_SIZE
value|(2*1024)
end_define

begin_define
define|#
directive|define
name|IWM_MAX_NVM_SECTION_SIZE
value|7000
end_define

begin_define
define|#
directive|define
name|IWM_NVM_WRITE_OPCODE
value|1
end_define

begin_define
define|#
directive|define
name|IWM_NVM_READ_OPCODE
value|0
end_define

begin_function
specifier|static
name|int
name|iwm_nvm_read_chunk
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|uint16_t
name|section
parameter_list|,
name|uint16_t
name|offset
parameter_list|,
name|uint16_t
name|length
parameter_list|,
name|uint8_t
modifier|*
name|data
parameter_list|,
name|uint16_t
modifier|*
name|len
parameter_list|)
block|{
name|offset
operator|=
literal|0
expr_stmt|;
name|struct
name|iwm_nvm_access_cmd
name|nvm_access_cmd
init|=
block|{
operator|.
name|offset
operator|=
name|htole16
argument_list|(
name|offset
argument_list|)
block|,
operator|.
name|length
operator|=
name|htole16
argument_list|(
name|length
argument_list|)
block|,
operator|.
name|type
operator|=
name|htole16
argument_list|(
name|section
argument_list|)
block|,
operator|.
name|op_code
operator|=
name|IWM_NVM_READ_OPCODE
block|, 	}
decl_stmt|;
name|struct
name|iwm_nvm_access_resp
modifier|*
name|nvm_resp
decl_stmt|;
name|struct
name|iwm_rx_packet
modifier|*
name|pkt
decl_stmt|;
name|struct
name|iwm_host_cmd
name|cmd
init|=
block|{
operator|.
name|id
operator|=
name|IWM_NVM_ACCESS_CMD
block|,
operator|.
name|flags
operator|=
name|IWM_CMD_SYNC
operator||
name|IWM_CMD_WANT_SKB
operator||
name|IWM_CMD_SEND_IN_RFKILL
block|,
operator|.
name|data
operator|=
block|{
operator|&
name|nvm_access_cmd
block|, }
block|, 	}
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|bytes_read
decl_stmt|,
name|offset_read
decl_stmt|;
name|uint8_t
modifier|*
name|resp_data
decl_stmt|;
name|cmd
operator|.
name|len
index|[
literal|0
index|]
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|iwm_nvm_access_cmd
argument_list|)
expr_stmt|;
name|ret
operator|=
name|iwm_send_cmd
argument_list|(
name|sc
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|pkt
operator|=
name|cmd
operator|.
name|resp_pkt
expr_stmt|;
if|if
condition|(
name|pkt
operator|->
name|hdr
operator|.
name|flags
operator|&
name|IWM_CMD_FAILED_MSK
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: Bad return from IWM_NVM_ACCES_COMMAND (0x%08X)\n"
argument_list|,
name|__func__
argument_list|,
name|pkt
operator|->
name|hdr
operator|.
name|flags
argument_list|)
expr_stmt|;
name|ret
operator|=
name|EIO
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
comment|/* Extract NVM response */
name|nvm_resp
operator|=
operator|(
name|void
operator|*
operator|)
name|pkt
operator|->
name|data
expr_stmt|;
name|ret
operator|=
name|le16toh
argument_list|(
name|nvm_resp
operator|->
name|status
argument_list|)
expr_stmt|;
name|bytes_read
operator|=
name|le16toh
argument_list|(
name|nvm_resp
operator|->
name|length
argument_list|)
expr_stmt|;
name|offset_read
operator|=
name|le16toh
argument_list|(
name|nvm_resp
operator|->
name|offset
argument_list|)
expr_stmt|;
name|resp_data
operator|=
name|nvm_resp
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: NVM access command failed with status %d\n"
argument_list|,
name|__func__
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
if|if
condition|(
name|offset_read
operator|!=
name|offset
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: NVM ACCESS response with invalid offset %d\n"
argument_list|,
name|__func__
argument_list|,
name|offset_read
argument_list|)
expr_stmt|;
name|ret
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
name|memcpy
argument_list|(
name|data
operator|+
name|offset
argument_list|,
name|resp_data
argument_list|,
name|bytes_read
argument_list|)
expr_stmt|;
operator|*
name|len
operator|=
name|bytes_read
expr_stmt|;
name|exit
label|:
name|iwm_free_resp
argument_list|(
name|sc
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Reads an NVM section completely.  * NICs prior to 7000 family doesn't have a real NVM, but just read  * section 0 which is the EEPROM. Because the EEPROM reading is unlimited  * by uCode, we need to manually check in this case that we don't  * overflow and try to read more than the EEPROM size.  * For 7000 family NICs, we supply the maximal size we can read, and  * the uCode fills the response with as much data as we can,  * without overflowing, so no check is needed.  */
end_comment

begin_function
specifier|static
name|int
name|iwm_nvm_read_section
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|uint16_t
name|section
parameter_list|,
name|uint8_t
modifier|*
name|data
parameter_list|,
name|uint16_t
modifier|*
name|len
parameter_list|)
block|{
name|uint16_t
name|length
decl_stmt|,
name|seglen
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Set nvm section read length */
name|length
operator|=
name|seglen
operator|=
name|IWM_NVM_DEFAULT_CHUNK_SIZE
expr_stmt|;
operator|*
name|len
operator|=
literal|0
expr_stmt|;
comment|/* Read the NVM until exhausted (reading less than requested) */
while|while
condition|(
name|seglen
operator|==
name|length
condition|)
block|{
name|error
operator|=
name|iwm_nvm_read_chunk
argument_list|(
name|sc
argument_list|,
name|section
argument_list|,
operator|*
name|len
argument_list|,
name|length
argument_list|,
name|data
argument_list|,
operator|&
name|seglen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Cannot read NVM from section "
literal|"%d offset %d, length %d\n"
argument_list|,
name|section
argument_list|,
operator|*
name|len
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
operator|*
name|len
operator|+=
name|seglen
expr_stmt|;
block|}
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_RESET
argument_list|,
literal|"NVM section %d read completed\n"
argument_list|,
name|section
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * BEGIN IWM_NVM_PARSE  */
end_comment

begin_comment
comment|/* iwlwifi/iwl-nvm-parse.c */
end_comment

begin_comment
comment|/* NVM offsets (in words) definitions */
end_comment

begin_enum
enum|enum
name|wkp_nvm_offsets
block|{
comment|/* NVM HW-Section offset (in words) definitions */
name|IWM_HW_ADDR
init|=
literal|0x15
block|,
comment|/* NVM SW-Section offset (in words) definitions */
name|IWM_NVM_SW_SECTION
init|=
literal|0x1C0
block|,
name|IWM_NVM_VERSION
init|=
literal|0
block|,
name|IWM_RADIO_CFG
init|=
literal|1
block|,
name|IWM_SKU
init|=
literal|2
block|,
name|IWM_N_HW_ADDRS
init|=
literal|3
block|,
name|IWM_NVM_CHANNELS
init|=
literal|0x1E0
operator|-
name|IWM_NVM_SW_SECTION
block|,
comment|/* NVM calibration section offset (in words) definitions */
name|IWM_NVM_CALIB_SECTION
init|=
literal|0x2B8
block|,
name|IWM_XTAL_CALIB
init|=
literal|0x316
operator|-
name|IWM_NVM_CALIB_SECTION
block|}
enum|;
end_enum

begin_comment
comment|/* SKU Capabilities (actual values from NVM definition) */
end_comment

begin_enum
enum|enum
name|nvm_sku_bits
block|{
name|IWM_NVM_SKU_CAP_BAND_24GHZ
init|=
operator|(
literal|1
operator|<<
literal|0
operator|)
block|,
name|IWM_NVM_SKU_CAP_BAND_52GHZ
init|=
operator|(
literal|1
operator|<<
literal|1
operator|)
block|,
name|IWM_NVM_SKU_CAP_11N_ENABLE
init|=
operator|(
literal|1
operator|<<
literal|2
operator|)
block|,
name|IWM_NVM_SKU_CAP_11AC_ENABLE
init|=
operator|(
literal|1
operator|<<
literal|3
operator|)
block|, }
enum|;
end_enum

begin_comment
comment|/* radio config bits (actual values from NVM definition) */
end_comment

begin_define
define|#
directive|define
name|IWM_NVM_RF_CFG_DASH_MSK
parameter_list|(
name|x
parameter_list|)
value|(x& 0x3)
end_define

begin_comment
comment|/* bits 0-1   */
end_comment

begin_define
define|#
directive|define
name|IWM_NVM_RF_CFG_STEP_MSK
parameter_list|(
name|x
parameter_list|)
value|((x>> 2)& 0x3)
end_define

begin_comment
comment|/* bits 2-3   */
end_comment

begin_define
define|#
directive|define
name|IWM_NVM_RF_CFG_TYPE_MSK
parameter_list|(
name|x
parameter_list|)
value|((x>> 4)& 0x3)
end_define

begin_comment
comment|/* bits 4-5   */
end_comment

begin_define
define|#
directive|define
name|IWM_NVM_RF_CFG_PNUM_MSK
parameter_list|(
name|x
parameter_list|)
value|((x>> 6)& 0x3)
end_define

begin_comment
comment|/* bits 6-7   */
end_comment

begin_define
define|#
directive|define
name|IWM_NVM_RF_CFG_TX_ANT_MSK
parameter_list|(
name|x
parameter_list|)
value|((x>> 8)& 0xF)
end_define

begin_comment
comment|/* bits 8-11  */
end_comment

begin_define
define|#
directive|define
name|IWM_NVM_RF_CFG_RX_ANT_MSK
parameter_list|(
name|x
parameter_list|)
value|((x>> 12)& 0xF)
end_define

begin_comment
comment|/* bits 12-15 */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_MAX_TX_POWER
value|16
end_define

begin_comment
comment|/**  * enum iwm_nvm_channel_flags - channel flags in NVM  * @IWM_NVM_CHANNEL_VALID: channel is usable for this SKU/geo  * @IWM_NVM_CHANNEL_IBSS: usable as an IBSS channel  * @IWM_NVM_CHANNEL_ACTIVE: active scanning allowed  * @IWM_NVM_CHANNEL_RADAR: radar detection required  * XXX cannot find this (DFS) flag in iwl-nvm-parse.c  * @IWM_NVM_CHANNEL_DFS: dynamic freq selection candidate  * @IWM_NVM_CHANNEL_WIDE: 20 MHz channel okay (?)  * @IWM_NVM_CHANNEL_40MHZ: 40 MHz channel okay (?)  * @IWM_NVM_CHANNEL_80MHZ: 80 MHz channel okay (?)  * @IWM_NVM_CHANNEL_160MHZ: 160 MHz channel okay (?)  */
end_comment

begin_enum
enum|enum
name|iwm_nvm_channel_flags
block|{
name|IWM_NVM_CHANNEL_VALID
init|=
operator|(
literal|1
operator|<<
literal|0
operator|)
block|,
name|IWM_NVM_CHANNEL_IBSS
init|=
operator|(
literal|1
operator|<<
literal|1
operator|)
block|,
name|IWM_NVM_CHANNEL_ACTIVE
init|=
operator|(
literal|1
operator|<<
literal|3
operator|)
block|,
name|IWM_NVM_CHANNEL_RADAR
init|=
operator|(
literal|1
operator|<<
literal|4
operator|)
block|,
name|IWM_NVM_CHANNEL_DFS
init|=
operator|(
literal|1
operator|<<
literal|7
operator|)
block|,
name|IWM_NVM_CHANNEL_WIDE
init|=
operator|(
literal|1
operator|<<
literal|8
operator|)
block|,
name|IWM_NVM_CHANNEL_40MHZ
init|=
operator|(
literal|1
operator|<<
literal|9
operator|)
block|,
name|IWM_NVM_CHANNEL_80MHZ
init|=
operator|(
literal|1
operator|<<
literal|10
operator|)
block|,
name|IWM_NVM_CHANNEL_160MHZ
init|=
operator|(
literal|1
operator|<<
literal|11
operator|)
block|, }
enum|;
end_enum

begin_comment
comment|/*  * Translate EEPROM flags to net80211.  */
end_comment

begin_function
specifier|static
name|uint32_t
name|iwm_eeprom_channel_flags
parameter_list|(
name|uint16_t
name|ch_flags
parameter_list|)
block|{
name|uint32_t
name|nflags
decl_stmt|;
name|nflags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ch_flags
operator|&
name|IWM_NVM_CHANNEL_ACTIVE
operator|)
operator|==
literal|0
condition|)
name|nflags
operator||=
name|IEEE80211_CHAN_PASSIVE
expr_stmt|;
if|if
condition|(
operator|(
name|ch_flags
operator|&
name|IWM_NVM_CHANNEL_IBSS
operator|)
operator|==
literal|0
condition|)
name|nflags
operator||=
name|IEEE80211_CHAN_NOADHOC
expr_stmt|;
if|if
condition|(
name|ch_flags
operator|&
name|IWM_NVM_CHANNEL_RADAR
condition|)
block|{
name|nflags
operator||=
name|IEEE80211_CHAN_DFS
expr_stmt|;
comment|/* Just in case. */
name|nflags
operator||=
name|IEEE80211_CHAN_NOADHOC
expr_stmt|;
block|}
return|return
operator|(
name|nflags
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_add_channel_band
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_channel
name|chans
index|[]
parameter_list|,
name|int
name|maxchans
parameter_list|,
name|int
modifier|*
name|nchans
parameter_list|,
name|int
name|ch_idx
parameter_list|,
name|int
name|ch_num
parameter_list|,
specifier|const
name|uint8_t
name|bands
index|[]
parameter_list|)
block|{
specifier|const
name|uint16_t
modifier|*
specifier|const
name|nvm_ch_flags
init|=
name|sc
operator|->
name|sc_nvm
operator|.
name|nvm_ch_flags
decl_stmt|;
name|uint32_t
name|nflags
decl_stmt|;
name|uint16_t
name|ch_flags
decl_stmt|;
name|uint8_t
name|ieee
decl_stmt|;
name|int
name|error
decl_stmt|;
for|for
control|(
init|;
name|ch_idx
operator|<
name|ch_num
condition|;
name|ch_idx
operator|++
control|)
block|{
name|ch_flags
operator|=
name|le16_to_cpup
argument_list|(
name|nvm_ch_flags
operator|+
name|ch_idx
argument_list|)
expr_stmt|;
name|ieee
operator|=
name|iwm_nvm_channels
index|[
name|ch_idx
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ch_flags
operator|&
name|IWM_NVM_CHANNEL_VALID
operator|)
condition|)
block|{
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_EEPROM
argument_list|,
literal|"Ch. %d Flags %x [%sGHz] - No traffic\n"
argument_list|,
name|ieee
argument_list|,
name|ch_flags
argument_list|,
operator|(
name|ch_idx
operator|>=
name|IWM_NUM_2GHZ_CHANNELS
operator|)
condition|?
literal|"5.2"
else|:
literal|"2.4"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|nflags
operator|=
name|iwm_eeprom_channel_flags
argument_list|(
name|ch_flags
argument_list|)
expr_stmt|;
name|error
operator|=
name|ieee80211_add_channel
argument_list|(
name|chans
argument_list|,
name|maxchans
argument_list|,
name|nchans
argument_list|,
name|ieee
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|nflags
argument_list|,
name|bands
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_EEPROM
argument_list|,
literal|"Ch. %d Flags %x [%sGHz] - Added\n"
argument_list|,
name|ieee
argument_list|,
name|ch_flags
argument_list|,
operator|(
name|ch_idx
operator|>=
name|IWM_NUM_2GHZ_CHANNELS
operator|)
condition|?
literal|"5.2"
else|:
literal|"2.4"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_init_channel_map
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|int
name|maxchans
parameter_list|,
name|int
modifier|*
name|nchans
parameter_list|,
name|struct
name|ieee80211_channel
name|chans
index|[]
parameter_list|)
block|{
name|struct
name|iwm_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|struct
name|iwm_nvm_data
modifier|*
name|data
init|=
operator|&
name|sc
operator|->
name|sc_nvm
decl_stmt|;
name|uint8_t
name|bands
index|[
name|IEEE80211_MODE_BYTES
index|]
decl_stmt|;
name|memset
argument_list|(
name|bands
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|bands
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 1-13: 11b/g channels. */
name|setbit
argument_list|(
name|bands
argument_list|,
name|IEEE80211_MODE_11B
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|bands
argument_list|,
name|IEEE80211_MODE_11G
argument_list|)
expr_stmt|;
name|iwm_add_channel_band
argument_list|(
name|sc
argument_list|,
name|chans
argument_list|,
name|maxchans
argument_list|,
name|nchans
argument_list|,
literal|0
argument_list|,
name|IWM_NUM_2GHZ_CHANNELS
operator|-
literal|1
argument_list|,
name|bands
argument_list|)
expr_stmt|;
comment|/* 14: 11b channel only. */
name|clrbit
argument_list|(
name|bands
argument_list|,
name|IEEE80211_MODE_11G
argument_list|)
expr_stmt|;
name|iwm_add_channel_band
argument_list|(
name|sc
argument_list|,
name|chans
argument_list|,
name|maxchans
argument_list|,
name|nchans
argument_list|,
name|IWM_NUM_2GHZ_CHANNELS
operator|-
literal|1
argument_list|,
name|IWM_NUM_2GHZ_CHANNELS
argument_list|,
name|bands
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|sku_cap_band_52GHz_enable
condition|)
block|{
name|memset
argument_list|(
name|bands
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|bands
argument_list|)
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|bands
argument_list|,
name|IEEE80211_MODE_11A
argument_list|)
expr_stmt|;
name|iwm_add_channel_band
argument_list|(
name|sc
argument_list|,
name|chans
argument_list|,
name|maxchans
argument_list|,
name|nchans
argument_list|,
name|IWM_NUM_2GHZ_CHANNELS
argument_list|,
name|nitems
argument_list|(
name|iwm_nvm_channels
argument_list|)
argument_list|,
name|bands
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_parse_nvm_data
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|uint16_t
modifier|*
name|nvm_hw
parameter_list|,
specifier|const
name|uint16_t
modifier|*
name|nvm_sw
parameter_list|,
specifier|const
name|uint16_t
modifier|*
name|nvm_calib
parameter_list|,
name|uint8_t
name|tx_chains
parameter_list|,
name|uint8_t
name|rx_chains
parameter_list|)
block|{
name|struct
name|iwm_nvm_data
modifier|*
name|data
init|=
operator|&
name|sc
operator|->
name|sc_nvm
decl_stmt|;
name|uint8_t
name|hw_addr
index|[
name|IEEE80211_ADDR_LEN
index|]
decl_stmt|;
name|uint16_t
name|radio_cfg
decl_stmt|,
name|sku
decl_stmt|;
name|data
operator|->
name|nvm_version
operator|=
name|le16_to_cpup
argument_list|(
name|nvm_sw
operator|+
name|IWM_NVM_VERSION
argument_list|)
expr_stmt|;
name|radio_cfg
operator|=
name|le16_to_cpup
argument_list|(
name|nvm_sw
operator|+
name|IWM_RADIO_CFG
argument_list|)
expr_stmt|;
name|data
operator|->
name|radio_cfg_type
operator|=
name|IWM_NVM_RF_CFG_TYPE_MSK
argument_list|(
name|radio_cfg
argument_list|)
expr_stmt|;
name|data
operator|->
name|radio_cfg_step
operator|=
name|IWM_NVM_RF_CFG_STEP_MSK
argument_list|(
name|radio_cfg
argument_list|)
expr_stmt|;
name|data
operator|->
name|radio_cfg_dash
operator|=
name|IWM_NVM_RF_CFG_DASH_MSK
argument_list|(
name|radio_cfg
argument_list|)
expr_stmt|;
name|data
operator|->
name|radio_cfg_pnum
operator|=
name|IWM_NVM_RF_CFG_PNUM_MSK
argument_list|(
name|radio_cfg
argument_list|)
expr_stmt|;
name|data
operator|->
name|valid_tx_ant
operator|=
name|IWM_NVM_RF_CFG_TX_ANT_MSK
argument_list|(
name|radio_cfg
argument_list|)
expr_stmt|;
name|data
operator|->
name|valid_rx_ant
operator|=
name|IWM_NVM_RF_CFG_RX_ANT_MSK
argument_list|(
name|radio_cfg
argument_list|)
expr_stmt|;
name|sku
operator|=
name|le16_to_cpup
argument_list|(
name|nvm_sw
operator|+
name|IWM_SKU
argument_list|)
expr_stmt|;
name|data
operator|->
name|sku_cap_band_24GHz_enable
operator|=
name|sku
operator|&
name|IWM_NVM_SKU_CAP_BAND_24GHZ
expr_stmt|;
name|data
operator|->
name|sku_cap_band_52GHz_enable
operator|=
name|sku
operator|&
name|IWM_NVM_SKU_CAP_BAND_52GHZ
expr_stmt|;
name|data
operator|->
name|sku_cap_11n_enable
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|data
operator|->
name|valid_tx_ant
operator|||
operator|!
name|data
operator|->
name|valid_rx_ant
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: invalid antennas (0x%x, 0x%x)\n"
argument_list|,
name|__func__
argument_list|,
name|data
operator|->
name|valid_tx_ant
argument_list|,
name|data
operator|->
name|valid_rx_ant
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|data
operator|->
name|n_hw_addrs
operator|=
name|le16_to_cpup
argument_list|(
name|nvm_sw
operator|+
name|IWM_N_HW_ADDRS
argument_list|)
expr_stmt|;
name|data
operator|->
name|xtal_calib
index|[
literal|0
index|]
operator|=
operator|*
operator|(
name|nvm_calib
operator|+
name|IWM_XTAL_CALIB
operator|)
expr_stmt|;
name|data
operator|->
name|xtal_calib
index|[
literal|1
index|]
operator|=
operator|*
operator|(
name|nvm_calib
operator|+
name|IWM_XTAL_CALIB
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* The byte order is little endian 16 bit, meaning 214365 */
name|IEEE80211_ADDR_COPY
argument_list|(
name|hw_addr
argument_list|,
name|nvm_hw
operator|+
name|IWM_HW_ADDR
argument_list|)
expr_stmt|;
name|data
operator|->
name|hw_addr
index|[
literal|0
index|]
operator|=
name|hw_addr
index|[
literal|1
index|]
expr_stmt|;
name|data
operator|->
name|hw_addr
index|[
literal|1
index|]
operator|=
name|hw_addr
index|[
literal|0
index|]
expr_stmt|;
name|data
operator|->
name|hw_addr
index|[
literal|2
index|]
operator|=
name|hw_addr
index|[
literal|3
index|]
expr_stmt|;
name|data
operator|->
name|hw_addr
index|[
literal|3
index|]
operator|=
name|hw_addr
index|[
literal|2
index|]
expr_stmt|;
name|data
operator|->
name|hw_addr
index|[
literal|4
index|]
operator|=
name|hw_addr
index|[
literal|5
index|]
expr_stmt|;
name|data
operator|->
name|hw_addr
index|[
literal|5
index|]
operator|=
name|hw_addr
index|[
literal|4
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|data
operator|->
name|nvm_ch_flags
argument_list|,
operator|&
name|nvm_sw
index|[
name|IWM_NVM_CHANNELS
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|data
operator|->
name|nvm_ch_flags
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|->
name|calib_version
operator|=
literal|255
expr_stmt|;
comment|/* TODO: 					this value will prevent some checks from 					failing, we need to check if this 					field is still needed, and if it does, 					where is it in the NVM */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * END NVM PARSE  */
end_comment

begin_struct
struct|struct
name|iwm_nvm_section
block|{
name|uint16_t
name|length
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|data
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|iwm_parse_nvm_sections
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwm_nvm_section
modifier|*
name|sections
parameter_list|)
block|{
specifier|const
name|uint16_t
modifier|*
name|hw
decl_stmt|,
modifier|*
name|sw
decl_stmt|,
modifier|*
name|calib
decl_stmt|;
comment|/* Checking for required sections */
if|if
condition|(
operator|!
name|sections
index|[
name|IWM_NVM_SECTION_TYPE_SW
index|]
operator|.
name|data
operator|||
operator|!
name|sections
index|[
name|IWM_NVM_SECTION_TYPE_HW
index|]
operator|.
name|data
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: Can't parse empty NVM sections\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|ENOENT
return|;
block|}
name|hw
operator|=
operator|(
specifier|const
name|uint16_t
operator|*
operator|)
name|sections
index|[
name|IWM_NVM_SECTION_TYPE_HW
index|]
operator|.
name|data
expr_stmt|;
name|sw
operator|=
operator|(
specifier|const
name|uint16_t
operator|*
operator|)
name|sections
index|[
name|IWM_NVM_SECTION_TYPE_SW
index|]
operator|.
name|data
expr_stmt|;
name|calib
operator|=
operator|(
specifier|const
name|uint16_t
operator|*
operator|)
name|sections
index|[
name|IWM_NVM_SECTION_TYPE_CALIBRATION
index|]
operator|.
name|data
expr_stmt|;
return|return
name|iwm_parse_nvm_data
argument_list|(
name|sc
argument_list|,
name|hw
argument_list|,
name|sw
argument_list|,
name|calib
argument_list|,
name|IWM_FW_VALID_TX_ANT
argument_list|(
name|sc
argument_list|)
argument_list|,
name|IWM_FW_VALID_RX_ANT
argument_list|(
name|sc
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_nvm_init
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|iwm_nvm_section
name|nvm_sections
index|[
name|IWM_NVM_NUM_OF_SECTIONS
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|section
decl_stmt|,
name|error
decl_stmt|;
name|uint16_t
name|len
decl_stmt|;
name|uint8_t
modifier|*
name|nvm_buffer
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
comment|/* Read From FW NVM */
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_EEPROM
argument_list|,
literal|"%s: Read NVM\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* TODO: find correct NVM max size for a section */
name|nvm_buffer
operator|=
name|malloc
argument_list|(
name|IWM_OTP_LOW_IMAGE_SIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvm_buffer
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|nvm_to_read
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|section
operator|=
name|nvm_to_read
index|[
name|i
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|section
operator|<=
name|nitems
argument_list|(
name|nvm_sections
argument_list|)
argument_list|,
operator|(
literal|"too many sections"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwm_nvm_read_section
argument_list|(
name|sc
argument_list|,
name|section
argument_list|,
name|nvm_buffer
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|temp
operator|=
name|malloc
argument_list|(
name|len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|memcpy
argument_list|(
name|temp
argument_list|,
name|nvm_buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|nvm_sections
index|[
name|section
index|]
operator|.
name|data
operator|=
name|temp
expr_stmt|;
name|nvm_sections
index|[
name|section
index|]
operator|.
name|length
operator|=
name|len
expr_stmt|;
block|}
name|free
argument_list|(
name|nvm_buffer
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
return|return
name|iwm_parse_nvm_sections
argument_list|(
name|sc
argument_list|,
name|nvm_sections
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Firmware loading gunk.  This is kind of a weird hybrid between the  * iwn driver and the Linux iwlwifi driver.  */
end_comment

begin_function
specifier|static
name|int
name|iwm_firmware_load_chunk
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|dst_addr
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|section
parameter_list|,
name|uint32_t
name|byte_cnt
parameter_list|)
block|{
name|struct
name|iwm_dma_info
modifier|*
name|dma
init|=
operator|&
name|sc
operator|->
name|fw_dma
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Copy firmware section into pre-allocated DMA-safe memory. */
name|memcpy
argument_list|(
name|dma
operator|->
name|vaddr
argument_list|,
name|section
argument_list|,
name|byte_cnt
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
name|dma
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iwm_nic_lock
argument_list|(
name|sc
argument_list|)
condition|)
return|return
name|EBUSY
return|;
name|sc
operator|->
name|sc_fw_chunk_done
operator|=
literal|0
expr_stmt|;
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_FH_TCSR_CHNL_TX_CONFIG_REG
argument_list|(
name|IWM_FH_SRVC_CHNL
argument_list|)
argument_list|,
name|IWM_FH_TCSR_TX_CONFIG_REG_VAL_DMA_CHNL_PAUSE
argument_list|)
expr_stmt|;
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_FH_SRVC_CHNL_SRAM_ADDR_REG
argument_list|(
name|IWM_FH_SRVC_CHNL
argument_list|)
argument_list|,
name|dst_addr
argument_list|)
expr_stmt|;
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_FH_TFDIB_CTRL0_REG
argument_list|(
name|IWM_FH_SRVC_CHNL
argument_list|)
argument_list|,
name|dma
operator|->
name|paddr
operator|&
name|IWM_FH_MEM_TFDIB_DRAM_ADDR_LSB_MSK
argument_list|)
expr_stmt|;
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_FH_TFDIB_CTRL1_REG
argument_list|(
name|IWM_FH_SRVC_CHNL
argument_list|)
argument_list|,
operator|(
name|iwm_get_dma_hi_addr
argument_list|(
name|dma
operator|->
name|paddr
argument_list|)
operator|<<
name|IWM_FH_MEM_TFDIB_REG1_ADDR_BITSHIFT
operator|)
operator||
name|byte_cnt
argument_list|)
expr_stmt|;
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_FH_TCSR_CHNL_TX_BUF_STS_REG
argument_list|(
name|IWM_FH_SRVC_CHNL
argument_list|)
argument_list|,
literal|1
operator|<<
name|IWM_FH_TCSR_CHNL_TX_BUF_STS_REG_POS_TB_NUM
operator||
literal|1
operator|<<
name|IWM_FH_TCSR_CHNL_TX_BUF_STS_REG_POS_TB_IDX
operator||
name|IWM_FH_TCSR_CHNL_TX_BUF_STS_REG_VAL_TFDB_VALID
argument_list|)
expr_stmt|;
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_FH_TCSR_CHNL_TX_CONFIG_REG
argument_list|(
name|IWM_FH_SRVC_CHNL
argument_list|)
argument_list|,
name|IWM_FH_TCSR_TX_CONFIG_REG_VAL_DMA_CHNL_ENABLE
operator||
name|IWM_FH_TCSR_TX_CONFIG_REG_VAL_DMA_CREDIT_DISABLE
operator||
name|IWM_FH_TCSR_TX_CONFIG_REG_VAL_CIRQ_HOST_ENDTFD
argument_list|)
expr_stmt|;
name|iwm_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* wait 1s for this segment to load */
while|while
condition|(
operator|!
name|sc
operator|->
name|sc_fw_chunk_done
condition|)
if|if
condition|(
operator|(
name|error
operator|=
name|msleep
argument_list|(
operator|&
name|sc
operator|->
name|sc_fw
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|0
argument_list|,
literal|"iwmfw"
argument_list|,
name|hz
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_load_firmware
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|enum
name|iwm_ucode_type
name|ucode_type
parameter_list|)
block|{
name|struct
name|iwm_fw_sects
modifier|*
name|fws
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|w
decl_stmt|;
specifier|const
name|void
modifier|*
name|data
decl_stmt|;
name|uint32_t
name|dlen
decl_stmt|;
name|uint32_t
name|offset
decl_stmt|;
name|sc
operator|->
name|sc_uc
operator|.
name|uc_intr
operator|=
literal|0
expr_stmt|;
name|fws
operator|=
operator|&
name|sc
operator|->
name|sc_fw
operator|.
name|fw_sects
index|[
name|ucode_type
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fws
operator|->
name|fw_count
condition|;
name|i
operator|++
control|)
block|{
name|data
operator|=
name|fws
operator|->
name|fw_sect
index|[
name|i
index|]
operator|.
name|fws_data
expr_stmt|;
name|dlen
operator|=
name|fws
operator|->
name|fw_sect
index|[
name|i
index|]
operator|.
name|fws_len
expr_stmt|;
name|offset
operator|=
name|fws
operator|->
name|fw_sect
index|[
name|i
index|]
operator|.
name|fws_devoff
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_FIRMWARE_TLV
argument_list|,
literal|"LOAD FIRMWARE type %d offset %u len %d\n"
argument_list|,
name|ucode_type
argument_list|,
name|offset
argument_list|,
name|dlen
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwm_firmware_load_chunk
argument_list|(
name|sc
argument_list|,
name|offset
argument_list|,
name|data
argument_list|,
name|dlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: chunk %u of %u returned error %02d\n"
argument_list|,
name|__func__
argument_list|,
name|i
argument_list|,
name|fws
operator|->
name|fw_count
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
comment|/* wait for the firmware to load */
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_RESET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|w
operator|=
literal|0
init|;
operator|!
name|sc
operator|->
name|sc_uc
operator|.
name|uc_intr
operator|&&
name|w
operator|<
literal|10
condition|;
name|w
operator|++
control|)
block|{
name|error
operator|=
name|msleep
argument_list|(
operator|&
name|sc
operator|->
name|sc_uc
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|0
argument_list|,
literal|"iwmuc"
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* iwlwifi: pcie/trans.c */
end_comment

begin_function
specifier|static
name|int
name|iwm_start_fw
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|enum
name|iwm_ucode_type
name|ucode_type
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_INT
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_nic_init
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to init nic\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* make sure rfkill handshake bits are cleared */
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_UCODE_DRV_GP1_CLR
argument_list|,
name|IWM_CSR_UCODE_SW_BIT_RFKILL
argument_list|)
expr_stmt|;
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_UCODE_DRV_GP1_CLR
argument_list|,
name|IWM_CSR_UCODE_DRV_GP1_BIT_CMD_BLOCKED
argument_list|)
expr_stmt|;
comment|/* clear (again), then enable host interrupts */
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_INT
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
name|iwm_enable_interrupts
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* really make sure rfkill handshake bits are cleared */
comment|/* maybe we should write a few times more?  just to make sure */
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_UCODE_DRV_GP1_CLR
argument_list|,
name|IWM_CSR_UCODE_SW_BIT_RFKILL
argument_list|)
expr_stmt|;
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_UCODE_DRV_GP1_CLR
argument_list|,
name|IWM_CSR_UCODE_SW_BIT_RFKILL
argument_list|)
expr_stmt|;
comment|/* Load the given image to the HW */
return|return
name|iwm_load_firmware
argument_list|(
name|sc
argument_list|,
name|ucode_type
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_fw_alive
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|sched_base
parameter_list|)
block|{
return|return
name|iwm_post_alive
argument_list|(
name|sc
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_send_tx_ant_cfg
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|valid_tx_ant
parameter_list|)
block|{
name|struct
name|iwm_tx_ant_cfg_cmd
name|tx_ant_cmd
init|=
block|{
operator|.
name|valid
operator|=
name|htole32
argument_list|(
name|valid_tx_ant
argument_list|)
block|, 	}
decl_stmt|;
return|return
name|iwm_mvm_send_cmd_pdu
argument_list|(
name|sc
argument_list|,
name|IWM_TX_ANT_CONFIGURATION_CMD
argument_list|,
name|IWM_CMD_SYNC
argument_list|,
sizeof|sizeof
argument_list|(
name|tx_ant_cmd
argument_list|)
argument_list|,
operator|&
name|tx_ant_cmd
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* iwlwifi: mvm/fw.c */
end_comment

begin_function
specifier|static
name|int
name|iwm_send_phy_cfg_cmd
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|iwm_phy_cfg_cmd
name|phy_cfg_cmd
decl_stmt|;
name|enum
name|iwm_ucode_type
name|ucode_type
init|=
name|sc
operator|->
name|sc_uc_current
decl_stmt|;
comment|/* Set parameters */
name|phy_cfg_cmd
operator|.
name|phy_cfg
operator|=
name|htole32
argument_list|(
name|sc
operator|->
name|sc_fw_phy_config
argument_list|)
expr_stmt|;
name|phy_cfg_cmd
operator|.
name|calib_control
operator|.
name|event_trigger
operator|=
name|sc
operator|->
name|sc_default_calib
index|[
name|ucode_type
index|]
operator|.
name|event_trigger
expr_stmt|;
name|phy_cfg_cmd
operator|.
name|calib_control
operator|.
name|flow_trigger
operator|=
name|sc
operator|->
name|sc_default_calib
index|[
name|ucode_type
index|]
operator|.
name|flow_trigger
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_CMD
operator||
name|IWM_DEBUG_RESET
argument_list|,
literal|"Sending Phy CFG command: 0x%x\n"
argument_list|,
name|phy_cfg_cmd
operator|.
name|phy_cfg
argument_list|)
expr_stmt|;
return|return
name|iwm_mvm_send_cmd_pdu
argument_list|(
name|sc
argument_list|,
name|IWM_PHY_CONFIGURATION_CMD
argument_list|,
name|IWM_CMD_SYNC
argument_list|,
sizeof|sizeof
argument_list|(
name|phy_cfg_cmd
argument_list|)
argument_list|,
operator|&
name|phy_cfg_cmd
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_mvm_load_ucode_wait_alive
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|enum
name|iwm_ucode_type
name|ucode_type
parameter_list|)
block|{
name|enum
name|iwm_ucode_type
name|old_type
init|=
name|sc
operator|->
name|sc_uc_current
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_read_firmware
argument_list|(
name|sc
argument_list|,
name|ucode_type
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|sc
operator|->
name|sc_uc_current
operator|=
name|ucode_type
expr_stmt|;
name|error
operator|=
name|iwm_start_fw
argument_list|(
name|sc
argument_list|,
name|ucode_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|sc
operator|->
name|sc_uc_current
operator|=
name|old_type
expr_stmt|;
return|return
name|error
return|;
block|}
return|return
name|iwm_fw_alive
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sched_base
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * mvm misc bits  */
end_comment

begin_comment
comment|/*  * follows iwlwifi/fw.c  */
end_comment

begin_function
specifier|static
name|int
name|iwm_run_init_mvm_ucode
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|int
name|justnvm
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
comment|/* do not operate with rfkill switch turned on */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWM_FLAG_RFKILL
operator|)
operator|&&
operator|!
name|justnvm
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"radio is disabled by hardware switch\n"
argument_list|)
expr_stmt|;
return|return
name|EPERM
return|;
block|}
name|sc
operator|->
name|sc_init_complete
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_mvm_load_ucode_wait_alive
argument_list|(
name|sc
argument_list|,
name|IWM_UCODE_TYPE_INIT
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
if|if
condition|(
name|justnvm
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_nvm_init
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"failed to read nvm\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|IEEE80211_ADDR_COPY
argument_list|(
name|sc
operator|->
name|sc_ic
operator|.
name|ic_macaddr
argument_list|,
name|sc
operator|->
name|sc_nvm
operator|.
name|hw_addr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_scan_cmd_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|iwm_scan_cmd
argument_list|)
operator|+
name|sc
operator|->
name|sc_capa_max_probe_len
operator|+
name|IWM_MAX_NUM_SCAN_CHANNELS
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|iwm_scan_channel
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_scan_cmd
operator|=
name|malloc
argument_list|(
name|sc
operator|->
name|sc_scan_cmd_len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_scan_cmd
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
return|return
literal|0
return|;
block|}
comment|/* Send TX valid antennas before triggering calibrations */
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_send_tx_ant_cfg
argument_list|(
name|sc
argument_list|,
name|IWM_FW_VALID_TX_ANT
argument_list|(
name|sc
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
comment|/* 	* Send phy configurations command to init uCode 	* to start the 16.0 uCode init image internal calibrations. 	*/
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_send_phy_cfg_cmd
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: failed to run internal calibration: %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* 	 * Nothing to do but wait for the init complete notification 	 * from the firmware 	 */
while|while
condition|(
operator|!
name|sc
operator|->
name|sc_init_complete
condition|)
if|if
condition|(
operator|(
name|error
operator|=
name|msleep
argument_list|(
operator|&
name|sc
operator|->
name|sc_init_complete
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|0
argument_list|,
literal|"iwminit"
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * receive side  */
end_comment

begin_comment
comment|/* (re)stock rx ring, called at init-time and at runtime */
end_comment

begin_function
specifier|static
name|int
name|iwm_rx_addbuf
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|struct
name|iwm_rx_ring
modifier|*
name|ring
init|=
operator|&
name|sc
operator|->
name|rxq
decl_stmt|;
name|struct
name|iwm_rx_data
modifier|*
name|data
init|=
operator|&
name|ring
operator|->
name|data
index|[
name|idx
index|]
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|;
name|bus_addr_t
name|paddr
decl_stmt|;
name|m
operator|=
name|m_getjcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|,
name|IWM_RBUF_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|ENOBUFS
return|;
if|if
condition|(
name|data
operator|->
name|m
operator|!=
name|NULL
condition|)
name|bus_dmamap_unload
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_ext
operator|.
name|ext_size
expr_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
literal|0
argument_list|,
operator|&
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not create RX buf DMA map, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|data
operator|->
name|m
operator|=
name|m
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|mtod
argument_list|(
name|data
operator|->
name|m
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
name|IWM_RBUF_SIZE
argument_list|,
name|iwm_dma_map_addr
argument_list|,
operator|&
name|paddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|EFBIG
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: can't not map mbuf, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
comment|/* Update RX descriptor. */
name|ring
operator|->
name|desc
index|[
name|idx
index|]
operator|=
name|htole32
argument_list|(
name|paddr
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|desc_dma
operator|.
name|tag
argument_list|,
name|ring
operator|->
name|desc_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|fail
label|:
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* iwlwifi: mvm/rx.c */
end_comment

begin_define
define|#
directive|define
name|IWM_RSSI_OFFSET
value|50
end_define

begin_function
specifier|static
name|int
name|iwm_mvm_calc_rssi
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwm_rx_phy_info
modifier|*
name|phy_info
parameter_list|)
block|{
name|int
name|rssi_a
decl_stmt|,
name|rssi_b
decl_stmt|,
name|rssi_a_dbm
decl_stmt|,
name|rssi_b_dbm
decl_stmt|,
name|max_rssi_dbm
decl_stmt|;
name|uint32_t
name|agc_a
decl_stmt|,
name|agc_b
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|val
operator|=
name|le32toh
argument_list|(
name|phy_info
operator|->
name|non_cfg_phy
index|[
name|IWM_RX_INFO_AGC_IDX
index|]
argument_list|)
expr_stmt|;
name|agc_a
operator|=
operator|(
name|val
operator|&
name|IWM_OFDM_AGC_A_MSK
operator|)
operator|>>
name|IWM_OFDM_AGC_A_POS
expr_stmt|;
name|agc_b
operator|=
operator|(
name|val
operator|&
name|IWM_OFDM_AGC_B_MSK
operator|)
operator|>>
name|IWM_OFDM_AGC_B_POS
expr_stmt|;
name|val
operator|=
name|le32toh
argument_list|(
name|phy_info
operator|->
name|non_cfg_phy
index|[
name|IWM_RX_INFO_RSSI_AB_IDX
index|]
argument_list|)
expr_stmt|;
name|rssi_a
operator|=
operator|(
name|val
operator|&
name|IWM_OFDM_RSSI_INBAND_A_MSK
operator|)
operator|>>
name|IWM_OFDM_RSSI_A_POS
expr_stmt|;
name|rssi_b
operator|=
operator|(
name|val
operator|&
name|IWM_OFDM_RSSI_INBAND_B_MSK
operator|)
operator|>>
name|IWM_OFDM_RSSI_B_POS
expr_stmt|;
comment|/* 	 * dBm = rssi dB - agc dB - constant. 	 * Higher AGC (higher radio gain) means lower signal. 	 */
name|rssi_a_dbm
operator|=
name|rssi_a
operator|-
name|IWM_RSSI_OFFSET
operator|-
name|agc_a
expr_stmt|;
name|rssi_b_dbm
operator|=
name|rssi_b
operator|-
name|IWM_RSSI_OFFSET
operator|-
name|agc_b
expr_stmt|;
name|max_rssi_dbm
operator|=
name|MAX
argument_list|(
name|rssi_a_dbm
argument_list|,
name|rssi_b_dbm
argument_list|)
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_RECV
argument_list|,
literal|"Rssi In A %d B %d Max %d AGCA %d AGCB %d\n"
argument_list|,
name|rssi_a_dbm
argument_list|,
name|rssi_b_dbm
argument_list|,
name|max_rssi_dbm
argument_list|,
name|agc_a
argument_list|,
name|agc_b
argument_list|)
expr_stmt|;
return|return
name|max_rssi_dbm
return|;
block|}
end_function

begin_comment
comment|/* iwlwifi: mvm/rx.c */
end_comment

begin_comment
comment|/*  * iwm_mvm_get_signal_strength - use new rx PHY INFO API  * values are reported by the fw as positive values - need to negate  * to obtain their dBM.  Account for missing antennas by replacing 0  * values by -256dBm: practically 0 power and a non-feasible 8 bit value.  */
end_comment

begin_function
specifier|static
name|int
name|iwm_mvm_get_signal_strength
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwm_rx_phy_info
modifier|*
name|phy_info
parameter_list|)
block|{
name|int
name|energy_a
decl_stmt|,
name|energy_b
decl_stmt|,
name|energy_c
decl_stmt|,
name|max_energy
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|val
operator|=
name|le32toh
argument_list|(
name|phy_info
operator|->
name|non_cfg_phy
index|[
name|IWM_RX_INFO_ENERGY_ANT_ABC_IDX
index|]
argument_list|)
expr_stmt|;
name|energy_a
operator|=
operator|(
name|val
operator|&
name|IWM_RX_INFO_ENERGY_ANT_A_MSK
operator|)
operator|>>
name|IWM_RX_INFO_ENERGY_ANT_A_POS
expr_stmt|;
name|energy_a
operator|=
name|energy_a
condition|?
operator|-
name|energy_a
else|:
operator|-
literal|256
expr_stmt|;
name|energy_b
operator|=
operator|(
name|val
operator|&
name|IWM_RX_INFO_ENERGY_ANT_B_MSK
operator|)
operator|>>
name|IWM_RX_INFO_ENERGY_ANT_B_POS
expr_stmt|;
name|energy_b
operator|=
name|energy_b
condition|?
operator|-
name|energy_b
else|:
operator|-
literal|256
expr_stmt|;
name|energy_c
operator|=
operator|(
name|val
operator|&
name|IWM_RX_INFO_ENERGY_ANT_C_MSK
operator|)
operator|>>
name|IWM_RX_INFO_ENERGY_ANT_C_POS
expr_stmt|;
name|energy_c
operator|=
name|energy_c
condition|?
operator|-
name|energy_c
else|:
operator|-
literal|256
expr_stmt|;
name|max_energy
operator|=
name|MAX
argument_list|(
name|energy_a
argument_list|,
name|energy_b
argument_list|)
expr_stmt|;
name|max_energy
operator|=
name|MAX
argument_list|(
name|max_energy
argument_list|,
name|energy_c
argument_list|)
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_RECV
argument_list|,
literal|"energy In A %d B %d C %d , and max %d\n"
argument_list|,
name|energy_a
argument_list|,
name|energy_b
argument_list|,
name|energy_c
argument_list|,
name|max_energy
argument_list|)
expr_stmt|;
return|return
name|max_energy
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_mvm_rx_rx_phy_cmd
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwm_rx_packet
modifier|*
name|pkt
parameter_list|,
name|struct
name|iwm_rx_data
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|iwm_rx_phy_info
modifier|*
name|phy_info
init|=
operator|(
name|void
operator|*
operator|)
name|pkt
operator|->
name|data
decl_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_RECV
argument_list|,
literal|"received PHY stats\n"
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rxq
operator|.
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sc
operator|->
name|sc_last_phy_info
argument_list|,
name|phy_info
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_last_phy_info
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Retrieve the average noise (in dBm) among receivers.  */
end_comment

begin_function
specifier|static
name|int
name|iwm_get_noise
parameter_list|(
specifier|const
name|struct
name|iwm_mvm_statistics_rx_non_phy
modifier|*
name|stats
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|total
decl_stmt|,
name|nbant
decl_stmt|,
name|noise
decl_stmt|;
name|total
operator|=
name|nbant
operator|=
name|noise
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|noise
operator|=
name|le32toh
argument_list|(
name|stats
operator|->
name|beacon_silence_rssi
index|[
name|i
index|]
argument_list|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|noise
condition|)
block|{
name|total
operator|+=
name|noise
expr_stmt|;
name|nbant
operator|++
expr_stmt|;
block|}
block|}
comment|/* There should be at least one antenna but check anyway. */
return|return
operator|(
name|nbant
operator|==
literal|0
operator|)
condition|?
operator|-
literal|127
else|:
operator|(
name|total
operator|/
name|nbant
operator|)
operator|-
literal|107
return|;
block|}
end_function

begin_comment
comment|/*  * iwm_mvm_rx_rx_mpdu - IWM_REPLY_RX_MPDU_CMD handler  *  * Handles the actual data of the Rx packet from the fw  */
end_comment

begin_function
specifier|static
name|void
name|iwm_mvm_rx_rx_mpdu
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwm_rx_packet
modifier|*
name|pkt
parameter_list|,
name|struct
name|iwm_rx_data
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|struct
name|ieee80211_rx_stats
name|rxs
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|iwm_rx_phy_info
modifier|*
name|phy_info
decl_stmt|;
name|struct
name|iwm_rx_mpdu_res_start
modifier|*
name|rx_res
decl_stmt|;
name|uint32_t
name|len
decl_stmt|;
name|uint32_t
name|rx_pkt_status
decl_stmt|;
name|int
name|rssi
decl_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rxq
operator|.
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|phy_info
operator|=
operator|&
name|sc
operator|->
name|sc_last_phy_info
expr_stmt|;
name|rx_res
operator|=
operator|(
expr|struct
name|iwm_rx_mpdu_res_start
operator|*
operator|)
name|pkt
operator|->
name|data
expr_stmt|;
name|wh
operator|=
operator|(
expr|struct
name|ieee80211_frame
operator|*
operator|)
operator|(
name|pkt
operator|->
name|data
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|rx_res
argument_list|)
operator|)
expr_stmt|;
name|len
operator|=
name|le16toh
argument_list|(
name|rx_res
operator|->
name|byte_count
argument_list|)
expr_stmt|;
name|rx_pkt_status
operator|=
name|le32toh
argument_list|(
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|pkt
operator|->
name|data
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|rx_res
argument_list|)
operator|+
name|len
operator|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|data
operator|->
name|m
expr_stmt|;
name|m
operator|->
name|m_data
operator|=
name|pkt
operator|->
name|data
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|rx_res
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|phy_info
operator|->
name|cfg_phy_cnt
operator|>
literal|20
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"dsp size out of range [0,20]: %d\n"
argument_list|,
name|phy_info
operator|->
name|cfg_phy_cnt
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|rx_pkt_status
operator|&
name|IWM_RX_MPDU_RES_STATUS_CRC_OK
operator|)
operator|||
operator|!
operator|(
name|rx_pkt_status
operator|&
name|IWM_RX_MPDU_RES_STATUS_OVERRUN_OK
operator|)
condition|)
block|{
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_RECV
argument_list|,
literal|"Bad CRC or FIFO: 0x%08X.\n"
argument_list|,
name|rx_pkt_status
argument_list|)
expr_stmt|;
return|return;
comment|/* drop */
block|}
if|if
condition|(
name|sc
operator|->
name|sc_capaflags
operator|&
name|IWM_UCODE_TLV_FLAGS_RX_ENERGY_API
condition|)
block|{
name|rssi
operator|=
name|iwm_mvm_get_signal_strength
argument_list|(
name|sc
argument_list|,
name|phy_info
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rssi
operator|=
name|iwm_mvm_calc_rssi
argument_list|(
name|sc
argument_list|,
name|phy_info
argument_list|)
expr_stmt|;
block|}
name|rssi
operator|=
operator|(
literal|0
operator|-
name|IWM_MIN_DBM
operator|)
operator|+
name|rssi
expr_stmt|;
comment|/* normalize */
name|rssi
operator|=
name|MIN
argument_list|(
name|rssi
argument_list|,
name|sc
operator|->
name|sc_max_rssi
argument_list|)
expr_stmt|;
comment|/* clip to max. 100% */
comment|/* replenish ring for the buffer we're going to feed to the sharks */
if|if
condition|(
name|iwm_rx_addbuf
argument_list|(
name|sc
argument_list|,
name|IWM_RBUF_SIZE
argument_list|,
name|sc
operator|->
name|rxq
operator|.
name|cur
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: unable to add more buffers\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
name|ni
operator|=
name|ieee80211_find_rxnode
argument_list|(
name|ic
argument_list|,
operator|(
expr|struct
name|ieee80211_frame_min
operator|*
operator|)
name|wh
argument_list|)
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_RECV
argument_list|,
literal|"%s: phy_info: channel=%d, flags=0x%08x\n"
argument_list|,
name|__func__
argument_list|,
name|le16toh
argument_list|(
name|phy_info
operator|->
name|channel
argument_list|)
argument_list|,
name|le16toh
argument_list|(
name|phy_info
operator|->
name|phy_flags
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Populate an RX state struct with the provided information. 	 */
name|bzero
argument_list|(
operator|&
name|rxs
argument_list|,
sizeof|sizeof
argument_list|(
name|rxs
argument_list|)
argument_list|)
expr_stmt|;
name|rxs
operator|.
name|r_flags
operator||=
name|IEEE80211_R_IEEE
operator||
name|IEEE80211_R_FREQ
expr_stmt|;
name|rxs
operator|.
name|r_flags
operator||=
name|IEEE80211_R_NF
operator||
name|IEEE80211_R_RSSI
expr_stmt|;
name|rxs
operator|.
name|c_ieee
operator|=
name|le16toh
argument_list|(
name|phy_info
operator|->
name|channel
argument_list|)
expr_stmt|;
if|if
condition|(
name|le16toh
argument_list|(
name|phy_info
operator|->
name|phy_flags
operator|&
name|IWM_RX_RES_PHY_FLAGS_BAND_24
argument_list|)
condition|)
block|{
name|rxs
operator|.
name|c_freq
operator|=
name|ieee80211_ieee2mhz
argument_list|(
name|rxs
operator|.
name|c_ieee
argument_list|,
name|IEEE80211_CHAN_2GHZ
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rxs
operator|.
name|c_freq
operator|=
name|ieee80211_ieee2mhz
argument_list|(
name|rxs
operator|.
name|c_ieee
argument_list|,
name|IEEE80211_CHAN_5GHZ
argument_list|)
expr_stmt|;
block|}
name|rxs
operator|.
name|rssi
operator|=
name|rssi
operator|-
name|sc
operator|->
name|sc_noise
expr_stmt|;
name|rxs
operator|.
name|nf
operator|=
name|sc
operator|->
name|sc_noise
expr_stmt|;
if|if
condition|(
name|ieee80211_radiotap_active_vap
argument_list|(
name|vap
argument_list|)
condition|)
block|{
name|struct
name|iwm_rx_radiotap_header
modifier|*
name|tap
init|=
operator|&
name|sc
operator|->
name|sc_rxtap
decl_stmt|;
name|tap
operator|->
name|wr_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|phy_info
operator|->
name|phy_flags
operator|&
name|htole16
argument_list|(
name|IWM_PHY_INFO_FLAG_SHPREAMBLE
argument_list|)
condition|)
name|tap
operator|->
name|wr_flags
operator||=
name|IEEE80211_RADIOTAP_F_SHORTPRE
expr_stmt|;
name|tap
operator|->
name|wr_chan_freq
operator|=
name|htole16
argument_list|(
name|rxs
operator|.
name|c_freq
argument_list|)
expr_stmt|;
comment|/* XXX only if ic->ic_curchan->ic_ieee == rxs.c_ieee */
name|tap
operator|->
name|wr_chan_flags
operator|=
name|htole16
argument_list|(
name|ic
operator|->
name|ic_curchan
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
name|tap
operator|->
name|wr_dbm_antsignal
operator|=
operator|(
name|int8_t
operator|)
name|rssi
expr_stmt|;
name|tap
operator|->
name|wr_dbm_antnoise
operator|=
operator|(
name|int8_t
operator|)
name|sc
operator|->
name|sc_noise
expr_stmt|;
name|tap
operator|->
name|wr_tsft
operator|=
name|phy_info
operator|->
name|system_timestamp
expr_stmt|;
switch|switch
condition|(
name|phy_info
operator|->
name|rate
condition|)
block|{
comment|/* CCK rates. */
case|case
literal|10
case|:
name|tap
operator|->
name|wr_rate
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|20
case|:
name|tap
operator|->
name|wr_rate
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|55
case|:
name|tap
operator|->
name|wr_rate
operator|=
literal|11
expr_stmt|;
break|break;
case|case
literal|110
case|:
name|tap
operator|->
name|wr_rate
operator|=
literal|22
expr_stmt|;
break|break;
comment|/* OFDM rates. */
case|case
literal|0xd
case|:
name|tap
operator|->
name|wr_rate
operator|=
literal|12
expr_stmt|;
break|break;
case|case
literal|0xf
case|:
name|tap
operator|->
name|wr_rate
operator|=
literal|18
expr_stmt|;
break|break;
case|case
literal|0x5
case|:
name|tap
operator|->
name|wr_rate
operator|=
literal|24
expr_stmt|;
break|break;
case|case
literal|0x7
case|:
name|tap
operator|->
name|wr_rate
operator|=
literal|36
expr_stmt|;
break|break;
case|case
literal|0x9
case|:
name|tap
operator|->
name|wr_rate
operator|=
literal|48
expr_stmt|;
break|break;
case|case
literal|0xb
case|:
name|tap
operator|->
name|wr_rate
operator|=
literal|72
expr_stmt|;
break|break;
case|case
literal|0x1
case|:
name|tap
operator|->
name|wr_rate
operator|=
literal|96
expr_stmt|;
break|break;
case|case
literal|0x3
case|:
name|tap
operator|->
name|wr_rate
operator|=
literal|108
expr_stmt|;
break|break;
comment|/* Unknown rate: should not happen. */
default|default:
name|tap
operator|->
name|wr_rate
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|IWM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_RECV
argument_list|,
literal|"input m %p\n"
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|ieee80211_input_mimo
argument_list|(
name|ni
argument_list|,
name|m
argument_list|,
operator|&
name|rxs
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_RECV
argument_list|,
literal|"inputall m %p\n"
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|ieee80211_input_mimo_all
argument_list|(
name|ic
argument_list|,
name|m
argument_list|,
operator|&
name|rxs
argument_list|)
expr_stmt|;
block|}
name|IWM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_mvm_rx_tx_cmd_single
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwm_rx_packet
modifier|*
name|pkt
parameter_list|,
name|struct
name|iwm_node
modifier|*
name|in
parameter_list|)
block|{
name|struct
name|iwm_mvm_tx_resp
modifier|*
name|tx_resp
init|=
operator|(
name|void
operator|*
operator|)
name|pkt
operator|->
name|data
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
operator|&
name|in
operator|->
name|in_ni
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|int
name|status
init|=
name|le16toh
argument_list|(
name|tx_resp
operator|->
name|status
operator|.
name|status
argument_list|)
operator|&
name|IWM_TX_STATUS_MSK
decl_stmt|;
name|int
name|failack
init|=
name|tx_resp
operator|->
name|failure_frame
decl_stmt|;
name|KASSERT
argument_list|(
name|tx_resp
operator|->
name|frame_count
operator|==
literal|1
argument_list|,
operator|(
literal|"too many frames"
operator|)
argument_list|)
expr_stmt|;
comment|/* Update rate control statistics. */
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_XMIT
argument_list|,
literal|"%s: status=0x%04x, seq=%d, fc=%d, btc=%d, frts=%d, ff=%d, irate=%08x, wmt=%d\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|int
operator|)
name|le16toh
argument_list|(
name|tx_resp
operator|->
name|status
operator|.
name|status
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|le16toh
argument_list|(
name|tx_resp
operator|->
name|status
operator|.
name|sequence
argument_list|)
argument_list|,
name|tx_resp
operator|->
name|frame_count
argument_list|,
name|tx_resp
operator|->
name|bt_kill_count
argument_list|,
name|tx_resp
operator|->
name|failure_rts
argument_list|,
name|tx_resp
operator|->
name|failure_frame
argument_list|,
name|le32toh
argument_list|(
name|tx_resp
operator|->
name|initial_rate
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|le16toh
argument_list|(
name|tx_resp
operator|->
name|wireless_media_time
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IWM_TX_STATUS_SUCCESS
operator|&&
name|status
operator|!=
name|IWM_TX_STATUS_DIRECT_DONE
condition|)
block|{
name|ieee80211_ratectl_tx_complete
argument_list|(
name|vap
argument_list|,
name|ni
argument_list|,
name|IEEE80211_RATECTL_TX_FAILURE
argument_list|,
operator|&
name|failack
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
name|ieee80211_ratectl_tx_complete
argument_list|(
name|vap
argument_list|,
name|ni
argument_list|,
name|IEEE80211_RATECTL_TX_SUCCESS
argument_list|,
operator|&
name|failack
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_mvm_rx_tx_cmd
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwm_rx_packet
modifier|*
name|pkt
parameter_list|,
name|struct
name|iwm_rx_data
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|iwm_cmd_header
modifier|*
name|cmd_hdr
init|=
operator|&
name|pkt
operator|->
name|hdr
decl_stmt|;
name|int
name|idx
init|=
name|cmd_hdr
operator|->
name|idx
decl_stmt|;
name|int
name|qid
init|=
name|cmd_hdr
operator|->
name|qid
decl_stmt|;
name|struct
name|iwm_tx_ring
modifier|*
name|ring
init|=
operator|&
name|sc
operator|->
name|txq
index|[
name|qid
index|]
decl_stmt|;
name|struct
name|iwm_tx_data
modifier|*
name|txd
init|=
operator|&
name|ring
operator|->
name|data
index|[
name|idx
index|]
decl_stmt|;
name|struct
name|iwm_node
modifier|*
name|in
init|=
name|txd
operator|->
name|in
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
name|txd
operator|->
name|m
decl_stmt|;
name|int
name|status
decl_stmt|;
name|KASSERT
argument_list|(
name|txd
operator|->
name|done
operator|==
literal|0
argument_list|,
operator|(
literal|"txd not done"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|txd
operator|->
name|in
operator|!=
name|NULL
argument_list|,
operator|(
literal|"txd without node"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|txd
operator|->
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"txd without mbuf"
operator|)
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tx_timer
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|iwm_mvm_rx_tx_cmd_single
argument_list|(
name|sc
argument_list|,
name|pkt
argument_list|,
name|in
argument_list|)
expr_stmt|;
comment|/* Unmap and free mbuf. */
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|txd
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|txd
operator|->
name|map
argument_list|)
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_XMIT
argument_list|,
literal|"free txd %p, in %p\n"
argument_list|,
name|txd
argument_list|,
name|txd
operator|->
name|in
argument_list|)
expr_stmt|;
name|txd
operator|->
name|done
operator|=
literal|1
expr_stmt|;
name|txd
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
name|txd
operator|->
name|in
operator|=
name|NULL
expr_stmt|;
name|ieee80211_tx_complete
argument_list|(
operator|&
name|in
operator|->
name|in_ni
argument_list|,
name|m
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|ring
operator|->
name|queued
operator|<
name|IWM_TX_RING_LOMARK
condition|)
block|{
name|sc
operator|->
name|qfullmsk
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|ring
operator|->
name|qid
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|qfullmsk
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Well, we're in interrupt context, but then again 			 * I guess net80211 does all sorts of stunts in 			 * interrupt context, so maybe this is no biggie. 			 */
name|iwm_start
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * transmit side  */
end_comment

begin_comment
comment|/*  * Process a "command done" firmware notification.  This is where we wakeup  * processes waiting for a synchronous command completion.  * from if_iwn  */
end_comment

begin_function
specifier|static
name|void
name|iwm_cmd_done
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwm_rx_packet
modifier|*
name|pkt
parameter_list|)
block|{
name|struct
name|iwm_tx_ring
modifier|*
name|ring
init|=
operator|&
name|sc
operator|->
name|txq
index|[
name|IWM_MVM_CMD_QUEUE
index|]
decl_stmt|;
name|struct
name|iwm_tx_data
modifier|*
name|data
decl_stmt|;
if|if
condition|(
name|pkt
operator|->
name|hdr
operator|.
name|qid
operator|!=
name|IWM_MVM_CMD_QUEUE
condition|)
block|{
return|return;
comment|/* Not a command ack. */
block|}
name|data
operator|=
operator|&
name|ring
operator|->
name|data
index|[
name|pkt
operator|->
name|hdr
operator|.
name|idx
index|]
expr_stmt|;
comment|/* If the command was mapped in an mbuf, free it. */
if|if
condition|(
name|data
operator|->
name|m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|data
operator|->
name|m
argument_list|)
expr_stmt|;
name|data
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
block|}
name|wakeup
argument_list|(
operator|&
name|ring
operator|->
name|desc
index|[
name|pkt
operator|->
name|hdr
operator|.
name|idx
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * necessary only for block ack mode  */
end_comment

begin_comment
unit|void iwm_update_sched(struct iwm_softc *sc, int qid, int idx, uint8_t sta_id, 	uint16_t len) { 	struct iwm_agn_scd_bc_tbl *scd_bc_tbl; 	uint16_t w_val;  	scd_bc_tbl = sc->sched_dma.vaddr;  	len += 8;
comment|/* magic numbers came naturally from paris */
end_comment

begin_comment
unit|if (sc->sc_capaflags& IWM_UCODE_TLV_FLAGS_DW_BC_TABLE) 		len = roundup(len, 4) / 4;  	w_val = htole16(sta_id<< 12 | len);
comment|/* Update TX scheduler. */
end_comment

begin_comment
unit|scd_bc_tbl[qid].tfd_offset[idx] = w_val; 	bus_dmamap_sync(sc->sched_dma.tag, sc->sched_dma.map, 	    BUS_DMASYNC_PREWRITE);
comment|/* I really wonder what this is ?!? */
end_comment

begin_endif
unit|if (idx< IWM_TFD_QUEUE_SIZE_BC_DUP) { 		scd_bc_tbl[qid].tfd_offset[IWM_TFD_QUEUE_SIZE_MAX + idx] = w_val; 		bus_dmamap_sync(sc->sched_dma.tag, sc->sched_dma.map, 		    BUS_DMASYNC_PREWRITE); 	} }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Take an 802.11 (non-n) rate, find the relevant rate  * table entry.  return the index into in_ridx[].  *  * The caller then uses that index back into in_ridx  * to figure out the rate index programmed /into/  * the firmware for this given node.  */
end_comment

begin_function
specifier|static
name|int
name|iwm_tx_rateidx_lookup
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwm_node
modifier|*
name|in
parameter_list|,
name|uint8_t
name|rate
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint8_t
name|r
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|in
operator|->
name|in_ridx
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|r
operator|=
name|iwm_rates
index|[
name|in
operator|->
name|in_ridx
index|[
name|i
index|]
index|]
operator|.
name|rate
expr_stmt|;
if|if
condition|(
name|rate
operator|==
name|r
condition|)
return|return
operator|(
name|i
operator|)
return|;
block|}
comment|/* XXX Return the first */
comment|/* XXX TODO: have it return the /lowest/ */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fill in the rate related information for a transmit command.  */
end_comment

begin_function
specifier|static
specifier|const
name|struct
name|iwm_rate
modifier|*
name|iwm_tx_fill_cmd
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwm_node
modifier|*
name|in
parameter_list|,
name|struct
name|ieee80211_frame
modifier|*
name|wh
parameter_list|,
name|struct
name|iwm_tx_cmd
modifier|*
name|tx
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
operator|&
name|in
operator|->
name|in_ni
decl_stmt|;
specifier|const
name|struct
name|iwm_rate
modifier|*
name|rinfo
decl_stmt|;
name|int
name|type
init|=
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_TYPE_MASK
decl_stmt|;
name|int
name|ridx
decl_stmt|,
name|rate_flags
decl_stmt|;
name|tx
operator|->
name|rts_retry_limit
operator|=
name|IWM_RTS_DFAULT_RETRY_LIMIT
expr_stmt|;
name|tx
operator|->
name|data_retry_limit
operator|=
name|IWM_DEFAULT_TX_RETRY
expr_stmt|;
comment|/* 	 * XXX TODO: everything about the rate selection here is terrible! 	 */
if|if
condition|(
name|type
operator|==
name|IEEE80211_FC0_TYPE_DATA
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* for data frames, use RS table */
operator|(
name|void
operator|)
name|ieee80211_ratectl_rate
argument_list|(
name|ni
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|i
operator|=
name|iwm_tx_rateidx_lookup
argument_list|(
name|sc
argument_list|,
name|in
argument_list|,
name|ni
operator|->
name|ni_txrate
argument_list|)
expr_stmt|;
name|ridx
operator|=
name|in
operator|->
name|in_ridx
index|[
name|i
index|]
expr_stmt|;
comment|/* This is the index into the programmed table */
name|tx
operator|->
name|initial_rate_index
operator|=
name|i
expr_stmt|;
name|tx
operator|->
name|tx_flags
operator||=
name|htole32
argument_list|(
name|IWM_TX_CMD_FLG_STA_RATE
argument_list|)
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_XMIT
operator||
name|IWM_DEBUG_TXRATE
argument_list|,
literal|"%s: start with i=%d, txrate %d\n"
argument_list|,
name|__func__
argument_list|,
name|i
argument_list|,
name|iwm_rates
index|[
name|ridx
index|]
operator|.
name|rate
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * For non-data, use the lowest supported rate for the given 		 * operational mode. 		 * 		 * Note: there may not be any rate control information available. 		 * This driver currently assumes if we're transmitting data 		 * frames, use the rate control table.  Grr. 		 * 		 * XXX TODO: use the configured rate for the traffic type! 		 * XXX TODO: this should be per-vap, not curmode; as we later 		 * on we'll want to handle off-channel stuff (eg TDLS). 		 */
if|if
condition|(
name|ic
operator|->
name|ic_curmode
operator|==
name|IEEE80211_MODE_11A
condition|)
block|{
comment|/* 			 * XXX this assumes the mode is either 11a or not 11a; 			 * definitely won't work for 11n. 			 */
name|ridx
operator|=
name|IWM_RIDX_OFDM
expr_stmt|;
block|}
else|else
block|{
name|ridx
operator|=
name|IWM_RIDX_CCK
expr_stmt|;
block|}
block|}
name|rinfo
operator|=
operator|&
name|iwm_rates
index|[
name|ridx
index|]
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_TXRATE
argument_list|,
literal|"%s: ridx=%d; rate=%d, CCK=%d\n"
argument_list|,
name|__func__
argument_list|,
name|ridx
argument_list|,
name|rinfo
operator|->
name|rate
argument_list|,
operator|!
operator|!
operator|(
name|IWM_RIDX_IS_CCK
argument_list|(
name|ridx
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX TODO: hard-coded TX antenna? */
name|rate_flags
operator|=
literal|1
operator|<<
name|IWM_RATE_MCS_ANT_POS
expr_stmt|;
if|if
condition|(
name|IWM_RIDX_IS_CCK
argument_list|(
name|ridx
argument_list|)
condition|)
name|rate_flags
operator||=
name|IWM_RATE_MCS_CCK_MSK
expr_stmt|;
name|tx
operator|->
name|rate_n_flags
operator|=
name|htole32
argument_list|(
name|rate_flags
operator||
name|rinfo
operator|->
name|plcp
argument_list|)
expr_stmt|;
return|return
name|rinfo
return|;
block|}
end_function

begin_define
define|#
directive|define
name|TB0_SIZE
value|16
end_define

begin_function
specifier|static
name|int
name|iwm_tx
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int
name|ac
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
decl_stmt|;
name|struct
name|iwm_node
modifier|*
name|in
init|=
name|IWM_NODE
argument_list|(
name|ni
argument_list|)
decl_stmt|;
name|struct
name|iwm_tx_ring
modifier|*
name|ring
decl_stmt|;
name|struct
name|iwm_tx_data
modifier|*
name|data
decl_stmt|;
name|struct
name|iwm_tfd
modifier|*
name|desc
decl_stmt|;
name|struct
name|iwm_device_cmd
modifier|*
name|cmd
decl_stmt|;
name|struct
name|iwm_tx_cmd
modifier|*
name|tx
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|struct
name|ieee80211_key
modifier|*
name|k
init|=
name|NULL
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m1
decl_stmt|;
specifier|const
name|struct
name|iwm_rate
modifier|*
name|rinfo
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|u_int
name|hdrlen
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|seg
decl_stmt|,
name|segs
index|[
name|IWM_MAX_SCATTER
index|]
decl_stmt|;
name|int
name|nsegs
decl_stmt|;
name|uint8_t
name|tid
decl_stmt|,
name|type
decl_stmt|;
name|int
name|i
decl_stmt|,
name|totlen
decl_stmt|,
name|error
decl_stmt|,
name|pad
decl_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|hdrlen
operator|=
name|ieee80211_anyhdrsize
argument_list|(
name|wh
argument_list|)
expr_stmt|;
name|type
operator|=
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_TYPE_MASK
expr_stmt|;
name|tid
operator|=
literal|0
expr_stmt|;
name|ring
operator|=
operator|&
name|sc
operator|->
name|txq
index|[
name|ac
index|]
expr_stmt|;
name|desc
operator|=
operator|&
name|ring
operator|->
name|desc
index|[
name|ring
operator|->
name|cur
index|]
expr_stmt|;
name|memset
argument_list|(
name|desc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|desc
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|=
operator|&
name|ring
operator|->
name|data
index|[
name|ring
operator|->
name|cur
index|]
expr_stmt|;
comment|/* Fill out iwm_tx_cmd to send to the firmware */
name|cmd
operator|=
operator|&
name|ring
operator|->
name|cmd
index|[
name|ring
operator|->
name|cur
index|]
expr_stmt|;
name|cmd
operator|->
name|hdr
operator|.
name|code
operator|=
name|IWM_TX_CMD
expr_stmt|;
name|cmd
operator|->
name|hdr
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|hdr
operator|.
name|qid
operator|=
name|ring
operator|->
name|qid
expr_stmt|;
name|cmd
operator|->
name|hdr
operator|.
name|idx
operator|=
name|ring
operator|->
name|cur
expr_stmt|;
name|tx
operator|=
operator|(
name|void
operator|*
operator|)
name|cmd
operator|->
name|data
expr_stmt|;
name|memset
argument_list|(
name|tx
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|rinfo
operator|=
name|iwm_tx_fill_cmd
argument_list|(
name|sc
argument_list|,
name|in
argument_list|,
name|wh
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* Encrypt the frame if need be. */
if|if
condition|(
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_PROTECTED
condition|)
block|{
comment|/* Retrieve key for TX&& do software encryption. */
name|k
operator|=
name|ieee80211_crypto_encap
argument_list|(
name|ni
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
comment|/* 802.11 header may have moved. */
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ieee80211_radiotap_active_vap
argument_list|(
name|vap
argument_list|)
condition|)
block|{
name|struct
name|iwm_tx_radiotap_header
modifier|*
name|tap
init|=
operator|&
name|sc
operator|->
name|sc_txtap
decl_stmt|;
name|tap
operator|->
name|wt_flags
operator|=
literal|0
expr_stmt|;
name|tap
operator|->
name|wt_chan_freq
operator|=
name|htole16
argument_list|(
name|ni
operator|->
name|ni_chan
operator|->
name|ic_freq
argument_list|)
expr_stmt|;
name|tap
operator|->
name|wt_chan_flags
operator|=
name|htole16
argument_list|(
name|ni
operator|->
name|ni_chan
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
name|tap
operator|->
name|wt_rate
operator|=
name|rinfo
operator|->
name|rate
expr_stmt|;
if|if
condition|(
name|k
operator|!=
name|NULL
condition|)
name|tap
operator|->
name|wt_flags
operator||=
name|IEEE80211_RADIOTAP_F_WEP
expr_stmt|;
name|ieee80211_radiotap_tx
argument_list|(
name|vap
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
name|totlen
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|IEEE80211_IS_MULTICAST
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
condition|)
block|{
name|flags
operator||=
name|IWM_TX_CMD_FLG_ACK
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|!=
name|IEEE80211_FC0_TYPE_DATA
operator|&&
operator|(
name|totlen
operator|+
name|IEEE80211_CRC_LEN
operator|>
name|vap
operator|->
name|iv_rtsthreshold
operator|)
operator|&&
operator|!
name|IEEE80211_IS_MULTICAST
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
condition|)
block|{
name|flags
operator||=
name|IWM_TX_CMD_FLG_PROT_REQUIRE
expr_stmt|;
block|}
if|if
condition|(
name|IEEE80211_IS_MULTICAST
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
operator|||
name|type
operator|!=
name|IEEE80211_FC0_TYPE_DATA
condition|)
name|tx
operator|->
name|sta_id
operator|=
name|sc
operator|->
name|sc_aux_sta
operator|.
name|sta_id
expr_stmt|;
else|else
name|tx
operator|->
name|sta_id
operator|=
name|IWM_STATION_ID
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|IEEE80211_FC0_TYPE_MGT
condition|)
block|{
name|uint8_t
name|subtype
init|=
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
decl_stmt|;
if|if
condition|(
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_ASSOC_REQ
operator|||
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_REASSOC_REQ
condition|)
name|tx
operator|->
name|pm_frame_timeout
operator|=
name|htole16
argument_list|(
literal|3
argument_list|)
expr_stmt|;
else|else
name|tx
operator|->
name|pm_frame_timeout
operator|=
name|htole16
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tx
operator|->
name|pm_frame_timeout
operator|=
name|htole16
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hdrlen
operator|&
literal|3
condition|)
block|{
comment|/* First segment length must be a multiple of 4. */
name|flags
operator||=
name|IWM_TX_CMD_FLG_MH_PAD
expr_stmt|;
name|pad
operator|=
literal|4
operator|-
operator|(
name|hdrlen
operator|&
literal|3
operator|)
expr_stmt|;
block|}
else|else
name|pad
operator|=
literal|0
expr_stmt|;
name|tx
operator|->
name|driver_txop
operator|=
literal|0
expr_stmt|;
name|tx
operator|->
name|next_frame_len
operator|=
literal|0
expr_stmt|;
name|tx
operator|->
name|len
operator|=
name|htole16
argument_list|(
name|totlen
argument_list|)
expr_stmt|;
name|tx
operator|->
name|tid_tspec
operator|=
name|tid
expr_stmt|;
name|tx
operator|->
name|life_time
operator|=
name|htole32
argument_list|(
name|IWM_TX_CMD_LIFE_TIME_INFINITE
argument_list|)
expr_stmt|;
comment|/* Set physical address of "scratch area". */
name|tx
operator|->
name|dram_lsb_ptr
operator|=
name|htole32
argument_list|(
name|data
operator|->
name|scratch_paddr
argument_list|)
expr_stmt|;
name|tx
operator|->
name|dram_msb_ptr
operator|=
name|iwm_get_dma_hi_addr
argument_list|(
name|data
operator|->
name|scratch_paddr
argument_list|)
expr_stmt|;
comment|/* Copy 802.11 header in TX command. */
name|memcpy
argument_list|(
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|tx
operator|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|tx
argument_list|)
argument_list|,
name|wh
argument_list|,
name|hdrlen
argument_list|)
expr_stmt|;
name|flags
operator||=
name|IWM_TX_CMD_FLG_BT_DIS
operator||
name|IWM_TX_CMD_FLG_SEQ_CTL
expr_stmt|;
name|tx
operator|->
name|sec_ctl
operator|=
literal|0
expr_stmt|;
name|tx
operator|->
name|tx_flags
operator||=
name|htole32
argument_list|(
name|flags
argument_list|)
expr_stmt|;
comment|/* Trim 802.11 header. */
name|m_adj
argument_list|(
name|m
argument_list|,
name|hdrlen
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|m
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|error
operator|!=
name|EFBIG
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"can't map mbuf (error %d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Too many DMA segments, linearize mbuf. */
name|m1
operator|=
name|m_collapse
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|,
name|IWM_MAX_SCATTER
operator|-
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|m1
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not defrag mbuf\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|m
operator|=
name|m1
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|m
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"can't map mbuf (error %d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
name|data
operator|->
name|m
operator|=
name|m
expr_stmt|;
name|data
operator|->
name|in
operator|=
name|in
expr_stmt|;
name|data
operator|->
name|done
operator|=
literal|0
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_XMIT
argument_list|,
literal|"sending txd %p, in %p\n"
argument_list|,
name|data
argument_list|,
name|data
operator|->
name|in
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|data
operator|->
name|in
operator|!=
name|NULL
argument_list|,
operator|(
literal|"node is NULL"
operator|)
argument_list|)
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_XMIT
argument_list|,
literal|"sending data: qid=%d idx=%d len=%d nsegs=%d txflags=0x%08x rate_n_flags=0x%08x rateidx=%d\n"
argument_list|,
name|ring
operator|->
name|qid
argument_list|,
name|ring
operator|->
name|cur
argument_list|,
name|totlen
argument_list|,
name|nsegs
argument_list|,
name|le32toh
argument_list|(
name|tx
operator|->
name|tx_flags
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|tx
operator|->
name|rate_n_flags
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|tx
operator|->
name|initial_rate_index
argument_list|)
expr_stmt|;
comment|/* Fill TX descriptor. */
name|desc
operator|->
name|num_tbs
operator|=
literal|2
operator|+
name|nsegs
expr_stmt|;
name|desc
operator|->
name|tbs
index|[
literal|0
index|]
operator|.
name|lo
operator|=
name|htole32
argument_list|(
name|data
operator|->
name|cmd_paddr
argument_list|)
expr_stmt|;
name|desc
operator|->
name|tbs
index|[
literal|0
index|]
operator|.
name|hi_n_len
operator|=
name|htole16
argument_list|(
name|iwm_get_dma_hi_addr
argument_list|(
name|data
operator|->
name|cmd_paddr
argument_list|)
argument_list|)
operator||
operator|(
name|TB0_SIZE
operator|<<
literal|4
operator|)
expr_stmt|;
name|desc
operator|->
name|tbs
index|[
literal|1
index|]
operator|.
name|lo
operator|=
name|htole32
argument_list|(
name|data
operator|->
name|cmd_paddr
operator|+
name|TB0_SIZE
argument_list|)
expr_stmt|;
name|desc
operator|->
name|tbs
index|[
literal|1
index|]
operator|.
name|hi_n_len
operator|=
name|htole16
argument_list|(
name|iwm_get_dma_hi_addr
argument_list|(
name|data
operator|->
name|cmd_paddr
argument_list|)
argument_list|)
operator||
operator|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|iwm_cmd_header
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|tx
argument_list|)
operator|+
name|hdrlen
operator|+
name|pad
operator|-
name|TB0_SIZE
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
comment|/* Other DMA segments are for data payload. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsegs
condition|;
name|i
operator|++
control|)
block|{
name|seg
operator|=
operator|&
name|segs
index|[
name|i
index|]
expr_stmt|;
name|desc
operator|->
name|tbs
index|[
name|i
operator|+
literal|2
index|]
operator|.
name|lo
operator|=
name|htole32
argument_list|(
name|seg
operator|->
name|ds_addr
argument_list|)
expr_stmt|;
name|desc
operator|->
name|tbs
index|[
name|i
operator|+
literal|2
index|]
operator|.
name|hi_n_len
operator|=
expr|\
name|htole16
argument_list|(
name|iwm_get_dma_hi_addr
argument_list|(
name|seg
operator|->
name|ds_addr
argument_list|)
argument_list|)
operator||
operator|(
operator|(
name|seg
operator|->
name|ds_len
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|cmd_dma
operator|.
name|tag
argument_list|,
name|ring
operator|->
name|cmd_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|desc_dma
operator|.
name|tag
argument_list|,
name|ring
operator|->
name|desc_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|iwm_update_sched(sc, ring->qid, ring->cur, tx->sta_id, le16toh(tx->len));
endif|#
directive|endif
comment|/* Kick TX ring. */
name|ring
operator|->
name|cur
operator|=
operator|(
name|ring
operator|->
name|cur
operator|+
literal|1
operator|)
operator|%
name|IWM_TX_RING_COUNT
expr_stmt|;
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_HBUS_TARG_WRPTR
argument_list|,
name|ring
operator|->
name|qid
operator|<<
literal|8
operator||
name|ring
operator|->
name|cur
argument_list|)
expr_stmt|;
comment|/* Mark TX ring as full if we reach a certain threshold. */
if|if
condition|(
operator|++
name|ring
operator|->
name|queued
operator|>
name|IWM_TX_RING_HIMARK
condition|)
block|{
name|sc
operator|->
name|qfullmsk
operator||=
literal|1
operator|<<
name|ring
operator|->
name|qid
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_raw_xmit
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|ieee80211_bpf_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|iwm_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_XMIT
argument_list|,
literal|"->%s begin\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWM_FLAG_HW_INITED
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_XMIT
argument_list|,
literal|"<-%s not RUNNING\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENETDOWN
operator|)
return|;
block|}
name|IWM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* XXX fix this */
if|if
condition|(
name|params
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|iwm_tx
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
name|ni
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|iwm_tx
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
name|ni
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_tx_timer
operator|=
literal|5
expr_stmt|;
name|IWM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * mvm/tx.c  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * Note that there are transports that buffer frames before they reach  * the firmware. This means that after flush_tx_path is called, the  * queue might not be empty. The race-free way to handle this is to:  * 1) set the station as draining  * 2) flush the Tx path  * 3) wait for the transport queues to be empty  */
end_comment

begin_endif
unit|int iwm_mvm_flush_tx_path(struct iwm_softc *sc, int tfd_msk, int sync) { 	struct iwm_tx_path_flush_cmd flush_cmd = { 		.queues_ctl = htole32(tfd_msk), 		.flush_ctl = htole16(IWM_DUMP_TX_FIFO_FLUSH), 	}; 	int ret;  	ret = iwm_mvm_send_cmd_pdu(sc, IWM_TXPATH_FLUSH, 	    sync ? IWM_CMD_SYNC : IWM_CMD_ASYNC, 	    sizeof(flush_cmd),&flush_cmd); 	if (ret)                 device_printf(sc->sc_dev, 		    "Flushing tx queue failed: %d\n", ret); 	return ret; }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * BEGIN mvm/sta.c  */
end_comment

begin_function
specifier|static
name|void
name|iwm_mvm_add_sta_cmd_v6_to_v5
parameter_list|(
name|struct
name|iwm_mvm_add_sta_cmd_v6
modifier|*
name|cmd_v6
parameter_list|,
name|struct
name|iwm_mvm_add_sta_cmd_v5
modifier|*
name|cmd_v5
parameter_list|)
block|{
name|memset
argument_list|(
name|cmd_v5
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cmd_v5
argument_list|)
argument_list|)
expr_stmt|;
name|cmd_v5
operator|->
name|add_modify
operator|=
name|cmd_v6
operator|->
name|add_modify
expr_stmt|;
name|cmd_v5
operator|->
name|tid_disable_tx
operator|=
name|cmd_v6
operator|->
name|tid_disable_tx
expr_stmt|;
name|cmd_v5
operator|->
name|mac_id_n_color
operator|=
name|cmd_v6
operator|->
name|mac_id_n_color
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|cmd_v5
operator|->
name|addr
argument_list|,
name|cmd_v6
operator|->
name|addr
argument_list|)
expr_stmt|;
name|cmd_v5
operator|->
name|sta_id
operator|=
name|cmd_v6
operator|->
name|sta_id
expr_stmt|;
name|cmd_v5
operator|->
name|modify_mask
operator|=
name|cmd_v6
operator|->
name|modify_mask
expr_stmt|;
name|cmd_v5
operator|->
name|station_flags
operator|=
name|cmd_v6
operator|->
name|station_flags
expr_stmt|;
name|cmd_v5
operator|->
name|station_flags_msk
operator|=
name|cmd_v6
operator|->
name|station_flags_msk
expr_stmt|;
name|cmd_v5
operator|->
name|add_immediate_ba_tid
operator|=
name|cmd_v6
operator|->
name|add_immediate_ba_tid
expr_stmt|;
name|cmd_v5
operator|->
name|remove_immediate_ba_tid
operator|=
name|cmd_v6
operator|->
name|remove_immediate_ba_tid
expr_stmt|;
name|cmd_v5
operator|->
name|add_immediate_ba_ssn
operator|=
name|cmd_v6
operator|->
name|add_immediate_ba_ssn
expr_stmt|;
name|cmd_v5
operator|->
name|sleep_tx_count
operator|=
name|cmd_v6
operator|->
name|sleep_tx_count
expr_stmt|;
name|cmd_v5
operator|->
name|sleep_state_flags
operator|=
name|cmd_v6
operator|->
name|sleep_state_flags
expr_stmt|;
name|cmd_v5
operator|->
name|assoc_id
operator|=
name|cmd_v6
operator|->
name|assoc_id
expr_stmt|;
name|cmd_v5
operator|->
name|beamform_flags
operator|=
name|cmd_v6
operator|->
name|beamform_flags
expr_stmt|;
name|cmd_v5
operator|->
name|tfd_queue_msk
operator|=
name|cmd_v6
operator|->
name|tfd_queue_msk
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_mvm_send_add_sta_cmd_status
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwm_mvm_add_sta_cmd_v6
modifier|*
name|cmd
parameter_list|,
name|int
modifier|*
name|status
parameter_list|)
block|{
name|struct
name|iwm_mvm_add_sta_cmd_v5
name|cmd_v5
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_capaflags
operator|&
name|IWM_UCODE_TLV_FLAGS_STA_KEY_CMD
condition|)
block|{
return|return
name|iwm_mvm_send_cmd_pdu_status
argument_list|(
name|sc
argument_list|,
name|IWM_ADD_STA
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cmd
argument_list|)
argument_list|,
name|cmd
argument_list|,
name|status
argument_list|)
return|;
block|}
name|iwm_mvm_add_sta_cmd_v6_to_v5
argument_list|(
name|cmd
argument_list|,
operator|&
name|cmd_v5
argument_list|)
expr_stmt|;
return|return
name|iwm_mvm_send_cmd_pdu_status
argument_list|(
name|sc
argument_list|,
name|IWM_ADD_STA
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd_v5
argument_list|)
argument_list|,
operator|&
name|cmd_v5
argument_list|,
name|status
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* send station add/update command to firmware */
end_comment

begin_function
specifier|static
name|int
name|iwm_mvm_sta_send_to_fw
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwm_node
modifier|*
name|in
parameter_list|,
name|int
name|update
parameter_list|)
block|{
name|struct
name|iwm_mvm_add_sta_cmd_v6
name|add_sta_cmd
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|memset
argument_list|(
operator|&
name|add_sta_cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|add_sta_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|add_sta_cmd
operator|.
name|sta_id
operator|=
name|IWM_STATION_ID
expr_stmt|;
name|add_sta_cmd
operator|.
name|mac_id_n_color
operator|=
name|htole32
argument_list|(
name|IWM_FW_CMD_ID_AND_COLOR
argument_list|(
name|IWM_DEFAULT_MACID
argument_list|,
name|IWM_DEFAULT_COLOR
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|update
condition|)
block|{
name|add_sta_cmd
operator|.
name|tfd_queue_msk
operator|=
name|htole32
argument_list|(
literal|0xf
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
operator|&
name|add_sta_cmd
operator|.
name|addr
argument_list|,
name|in
operator|->
name|in_ni
operator|.
name|ni_bssid
argument_list|)
expr_stmt|;
block|}
name|add_sta_cmd
operator|.
name|add_modify
operator|=
name|update
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|add_sta_cmd
operator|.
name|station_flags_msk
operator||=
name|htole32
argument_list|(
name|IWM_STA_FLG_FAT_EN_MSK
operator||
name|IWM_STA_FLG_MIMO_EN_MSK
argument_list|)
expr_stmt|;
name|status
operator|=
name|IWM_ADD_STA_SUCCESS
expr_stmt|;
name|ret
operator|=
name|iwm_mvm_send_add_sta_cmd_status
argument_list|(
name|sc
argument_list|,
operator|&
name|add_sta_cmd
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|IWM_ADD_STA_SUCCESS
case|:
break|break;
default|default:
name|ret
operator|=
name|EIO
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"IWM_ADD_STA failed\n"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_mvm_add_sta
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwm_node
modifier|*
name|in
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|iwm_mvm_sta_send_to_fw
argument_list|(
name|sc
argument_list|,
name|in
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_mvm_update_sta
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwm_node
modifier|*
name|in
parameter_list|)
block|{
return|return
name|iwm_mvm_sta_send_to_fw
argument_list|(
name|sc
argument_list|,
name|in
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_mvm_add_int_sta_common
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwm_int_sta
modifier|*
name|sta
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|addr
parameter_list|,
name|uint16_t
name|mac_id
parameter_list|,
name|uint16_t
name|color
parameter_list|)
block|{
name|struct
name|iwm_mvm_add_sta_cmd_v6
name|cmd
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|sta_id
operator|=
name|sta
operator|->
name|sta_id
expr_stmt|;
name|cmd
operator|.
name|mac_id_n_color
operator|=
name|htole32
argument_list|(
name|IWM_FW_CMD_ID_AND_COLOR
argument_list|(
name|mac_id
argument_list|,
name|color
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|tfd_queue_msk
operator|=
name|htole32
argument_list|(
name|sta
operator|->
name|tfd_queue_msk
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
condition|)
name|IEEE80211_ADDR_COPY
argument_list|(
name|cmd
operator|.
name|addr
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|ret
operator|=
name|iwm_mvm_send_add_sta_cmd_status
argument_list|(
name|sc
argument_list|,
operator|&
name|cmd
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|IWM_ADD_STA_SUCCESS
case|:
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_RESET
argument_list|,
literal|"%s: Internal station added.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: Add internal station failed, status=0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|ret
operator|=
name|EIO
expr_stmt|;
break|break;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_mvm_add_aux_sta
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|sc
operator|->
name|sc_aux_sta
operator|.
name|sta_id
operator|=
literal|3
expr_stmt|;
name|sc
operator|->
name|sc_aux_sta
operator|.
name|tfd_queue_msk
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|iwm_mvm_add_int_sta_common
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_aux_sta
argument_list|,
name|NULL
argument_list|,
name|IWM_MAC_INDEX_AUX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|memset
argument_list|(
operator|&
name|sc
operator|->
name|sc_aux_sta
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_aux_sta
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * END mvm/sta.c  */
end_comment

begin_comment
comment|/*  * BEGIN mvm/quota.c  */
end_comment

begin_function
specifier|static
name|int
name|iwm_mvm_update_quotas
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwm_node
modifier|*
name|in
parameter_list|)
block|{
name|struct
name|iwm_time_quota_cmd
name|cmd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|idx
decl_stmt|,
name|ret
decl_stmt|,
name|num_active_macs
decl_stmt|,
name|quota
decl_stmt|,
name|quota_rem
decl_stmt|;
name|int
name|colors
index|[
name|IWM_MAX_BINDINGS
index|]
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|, }
decl_stmt|;
name|int
name|n_ifs
index|[
name|IWM_MAX_BINDINGS
index|]
init|=
block|{
literal|0
block|, }
decl_stmt|;
name|uint16_t
name|id
decl_stmt|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* currently, PHY ID == binding ID */
if|if
condition|(
name|in
condition|)
block|{
name|id
operator|=
name|in
operator|->
name|in_phyctxt
operator|->
name|id
expr_stmt|;
name|KASSERT
argument_list|(
name|id
operator|<
name|IWM_MAX_BINDINGS
argument_list|,
operator|(
literal|"invalid id"
operator|)
argument_list|)
expr_stmt|;
name|colors
index|[
name|id
index|]
operator|=
name|in
operator|->
name|in_phyctxt
operator|->
name|color
expr_stmt|;
if|if
condition|(
literal|1
condition|)
name|n_ifs
index|[
name|id
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * The FW's scheduling session consists of 	 * IWM_MVM_MAX_QUOTA fragments. Divide these fragments 	 * equally between all the bindings that require quota 	 */
name|num_active_macs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IWM_MAX_BINDINGS
condition|;
name|i
operator|++
control|)
block|{
name|cmd
operator|.
name|quotas
index|[
name|i
index|]
operator|.
name|id_and_color
operator|=
name|htole32
argument_list|(
name|IWM_FW_CTXT_INVALID
argument_list|)
expr_stmt|;
name|num_active_macs
operator|+=
name|n_ifs
index|[
name|i
index|]
expr_stmt|;
block|}
name|quota
operator|=
literal|0
expr_stmt|;
name|quota_rem
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|num_active_macs
condition|)
block|{
name|quota
operator|=
name|IWM_MVM_MAX_QUOTA
operator|/
name|num_active_macs
expr_stmt|;
name|quota_rem
operator|=
name|IWM_MVM_MAX_QUOTA
operator|%
name|num_active_macs
expr_stmt|;
block|}
for|for
control|(
name|idx
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IWM_MAX_BINDINGS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|colors
index|[
name|i
index|]
operator|<
literal|0
condition|)
continue|continue;
name|cmd
operator|.
name|quotas
index|[
name|idx
index|]
operator|.
name|id_and_color
operator|=
name|htole32
argument_list|(
name|IWM_FW_CMD_ID_AND_COLOR
argument_list|(
name|i
argument_list|,
name|colors
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_ifs
index|[
name|i
index|]
operator|<=
literal|0
condition|)
block|{
name|cmd
operator|.
name|quotas
index|[
name|idx
index|]
operator|.
name|quota
operator|=
name|htole32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|quotas
index|[
name|idx
index|]
operator|.
name|max_duration
operator|=
name|htole32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cmd
operator|.
name|quotas
index|[
name|idx
index|]
operator|.
name|quota
operator|=
name|htole32
argument_list|(
name|quota
operator|*
name|n_ifs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|quotas
index|[
name|idx
index|]
operator|.
name|max_duration
operator|=
name|htole32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|idx
operator|++
expr_stmt|;
block|}
comment|/* Give the remainder of the session to the first binding */
name|cmd
operator|.
name|quotas
index|[
literal|0
index|]
operator|.
name|quota
operator|=
name|htole32
argument_list|(
name|le32toh
argument_list|(
name|cmd
operator|.
name|quotas
index|[
literal|0
index|]
operator|.
name|quota
argument_list|)
operator|+
name|quota_rem
argument_list|)
expr_stmt|;
name|ret
operator|=
name|iwm_mvm_send_cmd_pdu
argument_list|(
name|sc
argument_list|,
name|IWM_TIME_QUOTA_CMD
argument_list|,
name|IWM_CMD_SYNC
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: Failed to send quota: %d\n"
argument_list|,
name|__func__
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * END mvm/quota.c  */
end_comment

begin_comment
comment|/*  * ieee80211 routines  */
end_comment

begin_comment
comment|/*  * Change to AUTH state in 80211 state machine.  Roughly matches what  * Linux does in bss_info_changed().  */
end_comment

begin_function
specifier|static
name|int
name|iwm_auth
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|struct
name|iwm_node
modifier|*
name|in
decl_stmt|;
name|struct
name|iwm_vap
modifier|*
name|iv
init|=
name|IWM_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|uint32_t
name|duration
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * XXX i have a feeling that the vap node is being 	 * freed from underneath us. Grr. 	 */
name|ni
operator|=
name|ieee80211_ref_node
argument_list|(
name|vap
operator|->
name|iv_bss
argument_list|)
expr_stmt|;
name|in
operator|=
name|IWM_NODE
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_RESET
operator||
name|IWM_DEBUG_STATE
argument_list|,
literal|"%s: called; vap=%p, bss ni=%p\n"
argument_list|,
name|__func__
argument_list|,
name|vap
argument_list|,
name|ni
argument_list|)
expr_stmt|;
name|in
operator|->
name|in_assoc
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|iwm_allow_mcast
argument_list|(
name|vap
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: failed to set multicast\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * This is where it deviates from what Linux does. 	 * 	 * Linux iwlwifi doesn't reset the nic each time, nor does it 	 * call ctxt_add() here.  Instead, it adds it during vap creation, 	 * and always does does a mac_ctx_changed(). 	 * 	 * The openbsd port doesn't attempt to do that - it reset things 	 * at odd states and does the add here. 	 * 	 * So, until the state handling is fixed (ie, we never reset 	 * the NIC except for a firmware failure, which should drag 	 * the NIC back to IDLE, re-setup and re-add all the mac/phy 	 * contexts that are required), let's do a dirty hack here. 	 */
if|if
condition|(
name|iv
operator|->
name|is_uploaded
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_mvm_mac_ctxt_changed
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: failed to update MAC\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_mvm_phy_ctxt_changed
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_phyctxt
index|[
literal|0
index|]
argument_list|,
name|in
operator|->
name|in_ni
operator|.
name|ni_chan
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: failed update phy ctxt\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|in
operator|->
name|in_phyctxt
operator|=
operator|&
name|sc
operator|->
name|sc_phyctxt
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_mvm_binding_update
argument_list|(
name|sc
argument_list|,
name|in
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: binding update cmd\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_mvm_update_sta
argument_list|(
name|sc
argument_list|,
name|in
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: failed to update sta\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_mvm_mac_ctxt_add
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: failed to add MAC\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_mvm_phy_ctxt_changed
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_phyctxt
index|[
literal|0
index|]
argument_list|,
name|in
operator|->
name|in_ni
operator|.
name|ni_chan
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: failed add phy ctxt!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|in
operator|->
name|in_phyctxt
operator|=
operator|&
name|sc
operator|->
name|sc_phyctxt
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_mvm_binding_add_vif
argument_list|(
name|sc
argument_list|,
name|in
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: binding add cmd\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_mvm_add_sta
argument_list|(
name|sc
argument_list|,
name|in
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: failed to add sta\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
comment|/* 	 * Prevent the FW from wandering off channel during association 	 * by "protecting" the session with a time event. 	 */
comment|/* XXX duration is in units of TU, not MS */
name|duration
operator|=
name|IWM_MVM_TE_SESSION_PROTECTION_MAX_TIME_MS
expr_stmt|;
name|iwm_mvm_protect_session
argument_list|(
name|sc
argument_list|,
name|in
argument_list|,
name|duration
argument_list|,
literal|500
comment|/* XXX magic number */
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_assoc
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|iwm_node
modifier|*
name|in
init|=
name|IWM_NODE
argument_list|(
name|vap
operator|->
name|iv_bss
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_mvm_update_sta
argument_list|(
name|sc
argument_list|,
name|in
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: failed to update STA\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|in
operator|->
name|in_assoc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_mvm_mac_ctxt_changed
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: failed to update MAC\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_release
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwm_node
modifier|*
name|in
parameter_list|)
block|{
comment|/* 	 * Ok, so *technically* the proper set of calls for going 	 * from RUN back to SCAN is: 	 * 	 * iwm_mvm_power_mac_disable(sc, in); 	 * iwm_mvm_mac_ctxt_changed(sc, in); 	 * iwm_mvm_rm_sta(sc, in); 	 * iwm_mvm_update_quotas(sc, NULL); 	 * iwm_mvm_mac_ctxt_changed(sc, in); 	 * iwm_mvm_binding_remove_vif(sc, in); 	 * iwm_mvm_mac_ctxt_remove(sc, in); 	 * 	 * However, that freezes the device not matter which permutations 	 * and modifications are attempted.  Obviously, this driver is missing 	 * something since it works in the Linux driver, but figuring out what 	 * is missing is a little more complicated.  Now, since we're going 	 * back to nothing anyway, we'll just do a complete device reset. 	 * Up your's, device! 	 */
comment|//iwm_mvm_flush_tx_path(sc, 0xf, 1);
name|iwm_stop_device
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iwm_init_hw
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
condition|)
name|in
operator|->
name|in_assoc
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
if|#
directive|if
literal|0
block|int error;  	iwm_mvm_power_mac_disable(sc, in);  	if ((error = iwm_mvm_mac_ctxt_changed(sc, in)) != 0) { 		device_printf(sc->sc_dev, "mac ctxt change fail 1 %d\n", error); 		return error; 	}  	if ((error = iwm_mvm_rm_sta(sc, in)) != 0) { 		device_printf(sc->sc_dev, "sta remove fail %d\n", error); 		return error; 	} 	error = iwm_mvm_rm_sta(sc, in); 	in->in_assoc = 0; 	iwm_mvm_update_quotas(sc, NULL); 	if ((error = iwm_mvm_mac_ctxt_changed(sc, in)) != 0) { 		device_printf(sc->sc_dev, "mac ctxt change fail 2 %d\n", error); 		return error; 	} 	iwm_mvm_binding_remove_vif(sc, in);  	iwm_mvm_mac_ctxt_remove(sc, in);  	return error;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|struct
name|ieee80211_node
modifier|*
name|iwm_node_alloc
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
return|return
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|iwm_node
argument_list|)
argument_list|,
name|M_80211_NODE
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_setrates
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwm_node
modifier|*
name|in
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
operator|&
name|in
operator|->
name|in_ni
decl_stmt|;
name|struct
name|iwm_lq_cmd
modifier|*
name|lq
init|=
operator|&
name|in
operator|->
name|in_lq
decl_stmt|;
name|int
name|nrates
init|=
name|ni
operator|->
name|ni_rates
operator|.
name|rs_nrates
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ridx
decl_stmt|,
name|tab
init|=
literal|0
decl_stmt|;
name|int
name|txant
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|nrates
operator|>
name|nitems
argument_list|(
name|lq
operator|->
name|rs_table
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: node supports %d rates, driver handles "
literal|"only %zu\n"
argument_list|,
name|__func__
argument_list|,
name|nrates
argument_list|,
name|nitems
argument_list|(
name|lq
operator|->
name|rs_table
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|nrates
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: node supports 0 rates, odd!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * XXX .. and most of iwm_node is not initialised explicitly; 	 * it's all just 0x0 passed to the firmware. 	 */
comment|/* first figure out which rates we should support */
comment|/* XXX TODO: this isn't 11n aware /at all/ */
name|memset
argument_list|(
operator|&
name|in
operator|->
name|in_ridx
argument_list|,
operator|-
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|in
operator|->
name|in_ridx
argument_list|)
argument_list|)
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_TXRATE
argument_list|,
literal|"%s: nrates=%d\n"
argument_list|,
name|__func__
argument_list|,
name|nrates
argument_list|)
expr_stmt|;
comment|/* 	 * Loop over nrates and populate in_ridx from the highest 	 * rate to the lowest rate.  Remember, in_ridx[] has 	 * IEEE80211_RATE_MAXSIZE entries! 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|min
argument_list|(
name|nrates
argument_list|,
name|IEEE80211_RATE_MAXSIZE
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|rate
init|=
name|ni
operator|->
name|ni_rates
operator|.
name|rs_rates
index|[
operator|(
name|nrates
operator|-
literal|1
operator|)
operator|-
name|i
index|]
operator|&
name|IEEE80211_RATE_VAL
decl_stmt|;
comment|/* Map 802.11 rate to HW rate index. */
for|for
control|(
name|ridx
operator|=
literal|0
init|;
name|ridx
operator|<=
name|IWM_RIDX_MAX
condition|;
name|ridx
operator|++
control|)
if|if
condition|(
name|iwm_rates
index|[
name|ridx
index|]
operator|.
name|rate
operator|==
name|rate
condition|)
break|break;
if|if
condition|(
name|ridx
operator|>
name|IWM_RIDX_MAX
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: WARNING: device rate for %d not found!\n"
argument_list|,
name|__func__
argument_list|,
name|rate
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_TXRATE
argument_list|,
literal|"%s: rate: i: %d, rate=%d, ridx=%d\n"
argument_list|,
name|__func__
argument_list|,
name|i
argument_list|,
name|rate
argument_list|,
name|ridx
argument_list|)
expr_stmt|;
name|in
operator|->
name|in_ridx
index|[
name|i
index|]
operator|=
name|ridx
expr_stmt|;
block|}
block|}
comment|/* then construct a lq_cmd based on those */
name|memset
argument_list|(
name|lq
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lq
argument_list|)
argument_list|)
expr_stmt|;
name|lq
operator|->
name|sta_id
operator|=
name|IWM_STATION_ID
expr_stmt|;
comment|/* 	 * are these used? (we don't do SISO or MIMO) 	 * need to set them to non-zero, though, or we get an error. 	 */
name|lq
operator|->
name|single_stream_ant_msk
operator|=
literal|1
expr_stmt|;
name|lq
operator|->
name|dual_stream_ant_msk
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Build the actual rate selection table. 	 * The lowest bits are the rates.  Additionally, 	 * CCK needs bit 9 to be set.  The rest of the bits 	 * we add to the table select the tx antenna 	 * Note that we add the rates in the highest rate first 	 * (opposite of ni_rates). 	 */
comment|/* 	 * XXX TODO: this should be looping over the min of nrates 	 * and LQ_MAX_RETRY_NUM.  Sigh. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrates
condition|;
name|i
operator|++
control|)
block|{
name|int
name|nextant
decl_stmt|;
if|if
condition|(
name|txant
operator|==
literal|0
condition|)
name|txant
operator|=
name|IWM_FW_VALID_TX_ANT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|nextant
operator|=
literal|1
operator|<<
operator|(
name|ffs
argument_list|(
name|txant
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
name|txant
operator|&=
operator|~
name|nextant
expr_stmt|;
comment|/* 		 * Map the rate id into a rate index into 		 * our hardware table containing the 		 * configuration to use for this rate. 		 */
name|ridx
operator|=
name|in
operator|->
name|in_ridx
index|[
name|i
index|]
expr_stmt|;
name|tab
operator|=
name|iwm_rates
index|[
name|ridx
index|]
operator|.
name|plcp
expr_stmt|;
name|tab
operator||=
name|nextant
operator|<<
name|IWM_RATE_MCS_ANT_POS
expr_stmt|;
if|if
condition|(
name|IWM_RIDX_IS_CCK
argument_list|(
name|ridx
argument_list|)
condition|)
name|tab
operator||=
name|IWM_RATE_MCS_CCK_MSK
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_TXRATE
argument_list|,
literal|"station rate i=%d, rate=%d, hw=%x\n"
argument_list|,
name|i
argument_list|,
name|iwm_rates
index|[
name|ridx
index|]
operator|.
name|rate
argument_list|,
name|tab
argument_list|)
expr_stmt|;
name|lq
operator|->
name|rs_table
index|[
name|i
index|]
operator|=
name|htole32
argument_list|(
name|tab
argument_list|)
expr_stmt|;
block|}
comment|/* then fill the rest with the lowest possible rate */
for|for
control|(
name|i
operator|=
name|nrates
init|;
name|i
operator|<
name|nitems
argument_list|(
name|lq
operator|->
name|rs_table
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|KASSERT
argument_list|(
name|tab
operator|!=
literal|0
argument_list|,
operator|(
literal|"invalid tab"
operator|)
argument_list|)
expr_stmt|;
name|lq
operator|->
name|rs_table
index|[
name|i
index|]
operator|=
name|htole32
argument_list|(
name|tab
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|iwm_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|ieee80211_media_change
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENETRESET
condition|)
return|return
name|error
return|;
name|IWM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_nrunning
operator|>
literal|0
condition|)
block|{
name|iwm_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iwm_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|IWM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_newstate
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|enum
name|ieee80211_state
name|nstate
parameter_list|,
name|int
name|arg
parameter_list|)
block|{
name|struct
name|iwm_vap
modifier|*
name|ivp
init|=
name|IWM_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|iwm_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|struct
name|iwm_node
modifier|*
name|in
decl_stmt|;
name|int
name|error
decl_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_STATE
argument_list|,
literal|"switching state %s -> %s\n"
argument_list|,
name|ieee80211_state_name
index|[
name|vap
operator|->
name|iv_state
index|]
argument_list|,
name|ieee80211_state_name
index|[
name|nstate
index|]
argument_list|)
expr_stmt|;
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|IWM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* disable beacon filtering if we're hopping out of RUN */
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_RUN
operator|&&
name|nstate
operator|!=
name|vap
operator|->
name|iv_state
condition|)
block|{
name|iwm_mvm_disable_beacon_filter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|in
operator|=
name|IWM_NODE
argument_list|(
name|vap
operator|->
name|iv_bss
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
condition|)
name|in
operator|->
name|in_assoc
operator|=
literal|0
expr_stmt|;
name|iwm_release
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 		 * It's impossible to directly go RUN->SCAN. If we iwm_release() 		 * above then the card will be completely reinitialized, 		 * so the driver must do everything necessary to bring the card 		 * from INIT to SCAN. 		 * 		 * Additionally, upon receiving deauth frame from AP, 		 * OpenBSD 802.11 stack puts the driver in IEEE80211_S_AUTH 		 * state. This will also fail with this driver, so bring the FSM 		 * from IEEE80211_S_RUN to IEEE80211_S_SCAN in this case as well. 		 * 		 * XXX TODO: fix this for FreeBSD! 		 */
if|if
condition|(
name|nstate
operator|==
name|IEEE80211_S_SCAN
operator|||
name|nstate
operator|==
name|IEEE80211_S_AUTH
operator|||
name|nstate
operator|==
name|IEEE80211_S_ASSOC
condition|)
block|{
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_STATE
argument_list|,
literal|"Force transition to INIT; MGT=%d\n"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|IWM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_newstate
argument_list|(
name|vap
argument_list|,
name|IEEE80211_S_INIT
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_STATE
argument_list|,
literal|"Going INIT->SCAN\n"
argument_list|)
expr_stmt|;
name|nstate
operator|=
name|IEEE80211_S_SCAN
expr_stmt|;
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|IWM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|nstate
condition|)
block|{
case|case
name|IEEE80211_S_INIT
case|:
name|sc
operator|->
name|sc_scanband
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|IEEE80211_S_AUTH
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_auth
argument_list|(
name|vap
argument_list|,
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not move to auth state: %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|IEEE80211_S_ASSOC
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_assoc
argument_list|(
name|vap
argument_list|,
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: failed to associate: %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|IEEE80211_S_RUN
case|:
block|{
name|struct
name|iwm_host_cmd
name|cmd
init|=
block|{
operator|.
name|id
operator|=
name|IWM_LQ_CMD
block|,
operator|.
name|len
operator|=
block|{
sizeof|sizeof
argument_list|(
name|in
operator|->
name|in_lq
argument_list|)
block|, }
block|,
operator|.
name|flags
operator|=
name|IWM_CMD_SYNC
block|, 		}
decl_stmt|;
comment|/* Update the association state, now we have it all */
comment|/* (eg associd comes in at this point */
name|error
operator|=
name|iwm_assoc
argument_list|(
name|vap
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: failed to update association state: %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
block|}
name|in
operator|=
name|IWM_NODE
argument_list|(
name|vap
operator|->
name|iv_bss
argument_list|)
expr_stmt|;
name|iwm_mvm_power_mac_update_mode
argument_list|(
name|sc
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|iwm_mvm_enable_beacon_filter
argument_list|(
name|sc
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|iwm_mvm_update_quotas
argument_list|(
name|sc
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|iwm_setrates
argument_list|(
name|sc
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|data
index|[
literal|0
index|]
operator|=
operator|&
name|in
operator|->
name|in_lq
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_send_cmd
argument_list|(
name|sc
argument_list|,
operator|&
name|cmd
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: IWM_LQ_CMD failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
break|break;
block|}
name|IWM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
return|return
operator|(
name|ivp
operator|->
name|iv_newstate
argument_list|(
name|vap
argument_list|,
name|nstate
argument_list|,
name|arg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|iwm_endscan_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|iwm_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|int
name|done
decl_stmt|;
name|int
name|error
decl_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_SCAN
operator||
name|IWM_DEBUG_TRACE
argument_list|,
literal|"%s: scan ended\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|IWM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_scanband
operator|==
name|IEEE80211_CHAN_2GHZ
operator|&&
name|sc
operator|->
name|sc_nvm
operator|.
name|sku_cap_band_52GHz_enable
condition|)
block|{
name|done
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_mvm_scan_request
argument_list|(
name|sc
argument_list|,
name|IEEE80211_CHAN_5GHZ
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not initiate scan\n"
argument_list|)
expr_stmt|;
name|done
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|done
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|done
condition|)
block|{
name|IWM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ieee80211_scan_done
argument_list|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
argument_list|)
expr_stmt|;
name|IWM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_scanband
operator|=
literal|0
expr_stmt|;
block|}
name|IWM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_init_hw
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|qid
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_start_hw
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_run_init_mvm_ucode
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
name|error
return|;
block|}
comment|/* 	 * should stop and start HW since that INIT 	 * image just loaded 	 */
name|iwm_stop_device
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_start_hw
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not initialize hardware\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* omstart, this time with the regular firmware */
name|error
operator|=
name|iwm_mvm_load_ucode_wait_alive
argument_list|(
name|sc
argument_list|,
name|IWM_UCODE_TYPE_REGULAR
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not load firmware\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_send_tx_ant_cfg
argument_list|(
name|sc
argument_list|,
name|IWM_FW_VALID_TX_ANT
argument_list|(
name|sc
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
comment|/* Send phy db control command and then phy db calibration*/
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_send_phy_db_data
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_send_phy_cfg_cmd
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
comment|/* Add auxiliary station for scanning */
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_mvm_add_aux_sta
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IWM_NUM_PHY_CTX
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * The channel used here isn't relevant as it's 		 * going to be overwritten in the other flows. 		 * For now use the first channel we have. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_mvm_phy_ctxt_add
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_phyctxt
index|[
name|i
index|]
argument_list|,
operator|&
name|ic
operator|->
name|ic_channels
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
block|}
name|error
operator|=
name|iwm_mvm_power_update_device
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|error
goto|;
comment|/* Mark TX rings as active. */
for|for
control|(
name|qid
operator|=
literal|0
init|;
name|qid
operator|<
literal|4
condition|;
name|qid
operator|++
control|)
block|{
name|iwm_enable_txq
argument_list|(
name|sc
argument_list|,
name|qid
argument_list|,
name|qid
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
name|error
label|:
name|iwm_stop_device
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* Allow multicast from our BSSID. */
end_comment

begin_function
specifier|static
name|int
name|iwm_allow_mcast
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|vap
operator|->
name|iv_bss
decl_stmt|;
name|struct
name|iwm_mcast_filter_cmd
modifier|*
name|cmd
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|int
name|error
decl_stmt|;
name|size
operator|=
name|roundup
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|cmd
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|malloc
argument_list|(
name|size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|cmd
operator|->
name|filter_own
operator|=
literal|1
expr_stmt|;
name|cmd
operator|->
name|port_id
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|pass_all
operator|=
literal|1
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|cmd
operator|->
name|bssid
argument_list|,
name|ni
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwm_mvm_send_cmd_pdu
argument_list|(
name|sc
argument_list|,
name|IWM_MCAST_FILTER_CMD
argument_list|,
name|IWM_CMD_SYNC
argument_list|,
name|size
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cmd
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_init
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWM_FLAG_HW_INITED
condition|)
block|{
return|return;
block|}
name|sc
operator|->
name|sc_generation
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|IWM_FLAG_STOPPED
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_init_hw
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|iwm_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  	 * Ok, firmware loaded and we are jogging 	 */
name|sc
operator|->
name|sc_flags
operator||=
name|IWM_FLAG_HW_INITED
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_watchdog_to
argument_list|,
name|hz
argument_list|,
name|iwm_watchdog
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_transmit
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|iwm_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|ic
operator|->
name|ic_softc
expr_stmt|;
name|IWM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWM_FLAG_HW_INITED
operator|)
operator|==
literal|0
condition|)
block|{
name|IWM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|error
operator|=
name|mbufq_enqueue
argument_list|(
operator|&
name|sc
operator|->
name|sc_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|IWM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|iwm_start
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IWM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Dequeue packets from sendq and call send.  */
end_comment

begin_function
specifier|static
name|void
name|iwm_start
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|ac
init|=
literal|0
decl_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_XMIT
operator||
name|IWM_DEBUG_TRACE
argument_list|,
literal|"->%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|qfullmsk
operator|==
literal|0
operator|&&
operator|(
name|m
operator|=
name|mbufq_dequeue
argument_list|(
operator|&
name|sc
operator|->
name|sc_snd
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ni
operator|=
operator|(
expr|struct
name|ieee80211_node
operator|*
operator|)
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
if|if
condition|(
name|iwm_tx
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
name|ni
argument_list|,
name|ac
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|if_inc_counter
argument_list|(
name|ni
operator|->
name|ni_vap
operator|->
name|iv_ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|sc
operator|->
name|sc_tx_timer
operator|=
literal|15
expr_stmt|;
block|}
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_XMIT
operator||
name|IWM_DEBUG_TRACE
argument_list|,
literal|"<-%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_stop
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|IWM_FLAG_HW_INITED
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|IWM_FLAG_STOPPED
expr_stmt|;
name|sc
operator|->
name|sc_generation
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_scanband
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_tx_timer
operator|=
literal|0
expr_stmt|;
name|iwm_stop_device
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_watchdog
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|iwm_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_tx_timer
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|--
name|sc
operator|->
name|sc_tx_timer
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"device timeout\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IWM_DEBUG
name|iwm_nic_error
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ieee80211_restart_all
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|counter_u64_add
argument_list|(
name|ic
operator|->
name|ic_oerrors
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_watchdog_to
argument_list|,
name|hz
argument_list|,
name|iwm_watchdog
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_parent
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|iwm_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|int
name|startall
init|=
literal|0
decl_stmt|;
name|IWM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_nrunning
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWM_FLAG_HW_INITED
operator|)
condition|)
block|{
name|iwm_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|startall
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWM_FLAG_HW_INITED
condition|)
name|iwm_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IWM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|startall
condition|)
name|ieee80211_start_all
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The interrupt side of things  */
end_comment

begin_comment
comment|/*  * error dumping routines are from iwlwifi/mvm/utils.c  */
end_comment

begin_comment
comment|/*  * Note: This structure is read from the device with IO accesses,  * and the reading already does the endian conversion. As it is  * read with uint32_t-sized accesses, any members with a different size  * need to be ordered correctly though!  */
end_comment

begin_struct
struct|struct
name|iwm_error_event_table
block|{
name|uint32_t
name|valid
decl_stmt|;
comment|/* (nonzero) valid, (0) log is empty */
name|uint32_t
name|error_id
decl_stmt|;
comment|/* type of error */
name|uint32_t
name|pc
decl_stmt|;
comment|/* program counter */
name|uint32_t
name|blink1
decl_stmt|;
comment|/* branch link */
name|uint32_t
name|blink2
decl_stmt|;
comment|/* branch link */
name|uint32_t
name|ilink1
decl_stmt|;
comment|/* interrupt link */
name|uint32_t
name|ilink2
decl_stmt|;
comment|/* interrupt link */
name|uint32_t
name|data1
decl_stmt|;
comment|/* error-specific data */
name|uint32_t
name|data2
decl_stmt|;
comment|/* error-specific data */
name|uint32_t
name|data3
decl_stmt|;
comment|/* error-specific data */
name|uint32_t
name|bcon_time
decl_stmt|;
comment|/* beacon timer */
name|uint32_t
name|tsf_low
decl_stmt|;
comment|/* network timestamp function timer */
name|uint32_t
name|tsf_hi
decl_stmt|;
comment|/* network timestamp function timer */
name|uint32_t
name|gp1
decl_stmt|;
comment|/* GP1 timer register */
name|uint32_t
name|gp2
decl_stmt|;
comment|/* GP2 timer register */
name|uint32_t
name|gp3
decl_stmt|;
comment|/* GP3 timer register */
name|uint32_t
name|ucode_ver
decl_stmt|;
comment|/* uCode version */
name|uint32_t
name|hw_ver
decl_stmt|;
comment|/* HW Silicon version */
name|uint32_t
name|brd_ver
decl_stmt|;
comment|/* HW board version */
name|uint32_t
name|log_pc
decl_stmt|;
comment|/* log program counter */
name|uint32_t
name|frame_ptr
decl_stmt|;
comment|/* frame pointer */
name|uint32_t
name|stack_ptr
decl_stmt|;
comment|/* stack pointer */
name|uint32_t
name|hcmd
decl_stmt|;
comment|/* last host command header */
name|uint32_t
name|isr0
decl_stmt|;
comment|/* isr status register LMPM_NIC_ISR0: 				 * rxtx_flag */
name|uint32_t
name|isr1
decl_stmt|;
comment|/* isr status register LMPM_NIC_ISR1: 				 * host_flag */
name|uint32_t
name|isr2
decl_stmt|;
comment|/* isr status register LMPM_NIC_ISR2: 				 * enc_flag */
name|uint32_t
name|isr3
decl_stmt|;
comment|/* isr status register LMPM_NIC_ISR3: 				 * time_flag */
name|uint32_t
name|isr4
decl_stmt|;
comment|/* isr status register LMPM_NIC_ISR4: 				 * wico interrupt */
name|uint32_t
name|isr_pref
decl_stmt|;
comment|/* isr status register LMPM_NIC_PREF_STAT */
name|uint32_t
name|wait_event
decl_stmt|;
comment|/* wait event() caller address */
name|uint32_t
name|l2p_control
decl_stmt|;
comment|/* L2pControlField */
name|uint32_t
name|l2p_duration
decl_stmt|;
comment|/* L2pDurationField */
name|uint32_t
name|l2p_mhvalid
decl_stmt|;
comment|/* L2pMhValidBits */
name|uint32_t
name|l2p_addr_match
decl_stmt|;
comment|/* L2pAddrMatchStat */
name|uint32_t
name|lmpm_pmg_sel
decl_stmt|;
comment|/* indicate which clocks are turned on 				 * (LMPM_PMG_SEL) */
name|uint32_t
name|u_timestamp
decl_stmt|;
comment|/* indicate when the date and time of the 				 * compilation */
name|uint32_t
name|flow_handler
decl_stmt|;
comment|/* FH read/write pointers, RX credit */
block|}
name|__packed
struct|;
end_struct

begin_define
define|#
directive|define
name|ERROR_START_OFFSET
value|(1 * sizeof(uint32_t))
end_define

begin_define
define|#
directive|define
name|ERROR_ELEM_SIZE
value|(7 * sizeof(uint32_t))
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|IWM_DEBUG
end_ifdef

begin_struct
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|uint8_t
name|num
decl_stmt|;
block|}
name|advanced_lookup
index|[]
init|=
block|{
block|{
literal|"NMI_INTERRUPT_WDG"
block|,
literal|0x34
block|}
block|,
block|{
literal|"SYSASSERT"
block|,
literal|0x35
block|}
block|,
block|{
literal|"UCODE_VERSION_MISMATCH"
block|,
literal|0x37
block|}
block|,
block|{
literal|"BAD_COMMAND"
block|,
literal|0x38
block|}
block|,
block|{
literal|"NMI_INTERRUPT_DATA_ACTION_PT"
block|,
literal|0x3C
block|}
block|,
block|{
literal|"FATAL_ERROR"
block|,
literal|0x3D
block|}
block|,
block|{
literal|"NMI_TRM_HW_ERR"
block|,
literal|0x46
block|}
block|,
block|{
literal|"NMI_INTERRUPT_TRM"
block|,
literal|0x4C
block|}
block|,
block|{
literal|"NMI_INTERRUPT_BREAK_POINT"
block|,
literal|0x54
block|}
block|,
block|{
literal|"NMI_INTERRUPT_WDG_RXF_FULL"
block|,
literal|0x5C
block|}
block|,
block|{
literal|"NMI_INTERRUPT_WDG_NO_RBD_RXF_FULL"
block|,
literal|0x64
block|}
block|,
block|{
literal|"NMI_INTERRUPT_HOST"
block|,
literal|0x66
block|}
block|,
block|{
literal|"NMI_INTERRUPT_ACTION_PT"
block|,
literal|0x7C
block|}
block|,
block|{
literal|"NMI_INTERRUPT_UNKNOWN"
block|,
literal|0x84
block|}
block|,
block|{
literal|"NMI_INTERRUPT_INST_ACTION_PT"
block|,
literal|0x86
block|}
block|,
block|{
literal|"ADVANCED_SYSASSERT"
block|,
literal|0
block|}
block|, }
struct|;
end_struct

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|iwm_desc_lookup
parameter_list|(
name|uint32_t
name|num
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|advanced_lookup
argument_list|)
operator|-
literal|1
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|advanced_lookup
index|[
name|i
index|]
operator|.
name|num
operator|==
name|num
condition|)
return|return
name|advanced_lookup
index|[
name|i
index|]
operator|.
name|name
return|;
comment|/* No entry matches 'num', so it is the last: ADVANCED_SYSASSERT */
return|return
name|advanced_lookup
index|[
name|i
index|]
operator|.
name|name
return|;
block|}
end_function

begin_comment
comment|/*  * Support for dumping the error log seemed like a good idea ...  * but it's mostly hex junk and the only sensible thing is the  * hw/ucode revision (which we know anyway).  Since it's here,  * I'll just leave it in, just in case e.g. the Intel guys want to  * help us decipher some "ADVANCED_SYSASSERT" later.  */
end_comment

begin_function
specifier|static
name|void
name|iwm_nic_error
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|iwm_error_event_table
name|table
decl_stmt|;
name|uint32_t
name|base
decl_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"dumping device error log\n"
argument_list|)
expr_stmt|;
name|base
operator|=
name|sc
operator|->
name|sc_uc
operator|.
name|uc_error_event_table
expr_stmt|;
if|if
condition|(
name|base
operator|<
literal|0x800000
operator|||
name|base
operator|>=
literal|0x80C000
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Not valid error log pointer 0x%08x\n"
argument_list|,
name|base
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|iwm_read_mem
argument_list|(
name|sc
argument_list|,
name|base
argument_list|,
operator|&
name|table
argument_list|,
sizeof|sizeof
argument_list|(
name|table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"reading errlog failed\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|table
operator|.
name|valid
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"errlog not found, skipping\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ERROR_START_OFFSET
operator|<=
name|table
operator|.
name|valid
operator|*
name|ERROR_ELEM_SIZE
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Start IWL Error Log Dump:\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Status: 0x%x, count: %d\n"
argument_list|,
name|sc
operator|->
name|sc_flags
argument_list|,
name|table
operator|.
name|valid
argument_list|)
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"0x%08X | %-28s\n"
argument_list|,
name|table
operator|.
name|error_id
argument_list|,
name|iwm_desc_lookup
argument_list|(
name|table
operator|.
name|error_id
argument_list|)
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | uPc\n"
argument_list|,
name|table
operator|.
name|pc
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | branchlink1\n"
argument_list|,
name|table
operator|.
name|blink1
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | branchlink2\n"
argument_list|,
name|table
operator|.
name|blink2
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | interruptlink1\n"
argument_list|,
name|table
operator|.
name|ilink1
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | interruptlink2\n"
argument_list|,
name|table
operator|.
name|ilink2
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | data1\n"
argument_list|,
name|table
operator|.
name|data1
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | data2\n"
argument_list|,
name|table
operator|.
name|data2
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | data3\n"
argument_list|,
name|table
operator|.
name|data3
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | beacon time\n"
argument_list|,
name|table
operator|.
name|bcon_time
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | tsf low\n"
argument_list|,
name|table
operator|.
name|tsf_low
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | tsf hi\n"
argument_list|,
name|table
operator|.
name|tsf_hi
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | time gp1\n"
argument_list|,
name|table
operator|.
name|gp1
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | time gp2\n"
argument_list|,
name|table
operator|.
name|gp2
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | time gp3\n"
argument_list|,
name|table
operator|.
name|gp3
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | uCode version\n"
argument_list|,
name|table
operator|.
name|ucode_ver
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | hw version\n"
argument_list|,
name|table
operator|.
name|hw_ver
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | board version\n"
argument_list|,
name|table
operator|.
name|brd_ver
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | hcmd\n"
argument_list|,
name|table
operator|.
name|hcmd
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | isr0\n"
argument_list|,
name|table
operator|.
name|isr0
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | isr1\n"
argument_list|,
name|table
operator|.
name|isr1
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | isr2\n"
argument_list|,
name|table
operator|.
name|isr2
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | isr3\n"
argument_list|,
name|table
operator|.
name|isr3
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | isr4\n"
argument_list|,
name|table
operator|.
name|isr4
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | isr_pref\n"
argument_list|,
name|table
operator|.
name|isr_pref
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | wait_event\n"
argument_list|,
name|table
operator|.
name|wait_event
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | l2p_control\n"
argument_list|,
name|table
operator|.
name|l2p_control
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | l2p_duration\n"
argument_list|,
name|table
operator|.
name|l2p_duration
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | l2p_mhvalid\n"
argument_list|,
name|table
operator|.
name|l2p_mhvalid
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | l2p_addr_match\n"
argument_list|,
name|table
operator|.
name|l2p_addr_match
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | lmpm_pmg_sel\n"
argument_list|,
name|table
operator|.
name|lmpm_pmg_sel
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | timestamp\n"
argument_list|,
name|table
operator|.
name|u_timestamp
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%08X | flow_handler\n"
argument_list|,
name|table
operator|.
name|flow_handler
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SYNC_RESP_STRUCT
parameter_list|(
name|_var_
parameter_list|,
name|_pkt_
parameter_list|)
define|\
value|do {									\ 	bus_dmamap_sync(ring->data_dmat, data->map, BUS_DMASYNC_POSTREAD);\ 	_var_ = (void *)((_pkt_)+1);					\ } while (
comment|/*CONSTCOND*/
value|0)
end_define

begin_define
define|#
directive|define
name|SYNC_RESP_PTR
parameter_list|(
name|_ptr_
parameter_list|,
name|_len_
parameter_list|,
name|_pkt_
parameter_list|)
define|\
value|do {									\ 	bus_dmamap_sync(ring->data_dmat, data->map, BUS_DMASYNC_POSTREAD);\ 	_ptr_ = (void *)((_pkt_)+1);					\ } while (
comment|/*CONSTCOND*/
value|0)
end_define

begin_define
define|#
directive|define
name|ADVANCE_RXQ
parameter_list|(
name|sc
parameter_list|)
value|(sc->rxq.cur = (sc->rxq.cur + 1) % IWM_RX_RING_COUNT);
end_define

begin_comment
comment|/*  * Process an IWM_CSR_INT_BIT_FH_RX or IWM_CSR_INT_BIT_SW_RX interrupt.  * Basic structure from if_iwn  */
end_comment

begin_function
specifier|static
name|void
name|iwm_notif_intr
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint16_t
name|hw
decl_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rxq
operator|.
name|stat_dma
operator|.
name|tag
argument_list|,
name|sc
operator|->
name|rxq
operator|.
name|stat_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|hw
operator|=
name|le16toh
argument_list|(
name|sc
operator|->
name|rxq
operator|.
name|stat
operator|->
name|closed_rb_num
argument_list|)
operator|&
literal|0xfff
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|rxq
operator|.
name|cur
operator|!=
name|hw
condition|)
block|{
name|struct
name|iwm_rx_ring
modifier|*
name|ring
init|=
operator|&
name|sc
operator|->
name|rxq
decl_stmt|;
name|struct
name|iwm_rx_data
modifier|*
name|data
init|=
operator|&
name|sc
operator|->
name|rxq
operator|.
name|data
index|[
name|sc
operator|->
name|rxq
operator|.
name|cur
index|]
decl_stmt|;
name|struct
name|iwm_rx_packet
modifier|*
name|pkt
decl_stmt|;
name|struct
name|iwm_cmd_response
modifier|*
name|cresp
decl_stmt|;
name|int
name|qid
decl_stmt|,
name|idx
decl_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rxq
operator|.
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|pkt
operator|=
name|mtod
argument_list|(
name|data
operator|->
name|m
argument_list|,
expr|struct
name|iwm_rx_packet
operator|*
argument_list|)
expr_stmt|;
name|qid
operator|=
name|pkt
operator|->
name|hdr
operator|.
name|qid
operator|&
operator|~
literal|0x80
expr_stmt|;
name|idx
operator|=
name|pkt
operator|->
name|hdr
operator|.
name|idx
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_INTR
argument_list|,
literal|"rx packet qid=%d idx=%d flags=%x type=%x %d %d\n"
argument_list|,
name|pkt
operator|->
name|hdr
operator|.
name|qid
operator|&
operator|~
literal|0x80
argument_list|,
name|pkt
operator|->
name|hdr
operator|.
name|idx
argument_list|,
name|pkt
operator|->
name|hdr
operator|.
name|flags
argument_list|,
name|pkt
operator|->
name|hdr
operator|.
name|code
argument_list|,
name|sc
operator|->
name|rxq
operator|.
name|cur
argument_list|,
name|hw
argument_list|)
expr_stmt|;
comment|/* 		 * randomly get these from the firmware, no idea why. 		 * they at least seem harmless, so just ignore them for now 		 */
if|if
condition|(
name|__predict_false
argument_list|(
operator|(
name|pkt
operator|->
name|hdr
operator|.
name|code
operator|==
literal|0
operator|&&
name|qid
operator|==
literal|0
operator|&&
name|idx
operator|==
literal|0
operator|)
operator|||
name|pkt
operator|->
name|len_n_flags
operator|==
name|htole32
argument_list|(
literal|0x55550000
argument_list|)
argument_list|)
condition|)
block|{
name|ADVANCE_RXQ
argument_list|(
name|sc
argument_list|)
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|pkt
operator|->
name|hdr
operator|.
name|code
condition|)
block|{
case|case
name|IWM_REPLY_RX_PHY_CMD
case|:
name|iwm_mvm_rx_rx_phy_cmd
argument_list|(
name|sc
argument_list|,
name|pkt
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|IWM_REPLY_RX_MPDU_CMD
case|:
name|iwm_mvm_rx_rx_mpdu
argument_list|(
name|sc
argument_list|,
name|pkt
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|IWM_TX_CMD
case|:
name|iwm_mvm_rx_tx_cmd
argument_list|(
name|sc
argument_list|,
name|pkt
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|IWM_MISSED_BEACONS_NOTIFICATION
case|:
block|{
name|struct
name|iwm_missed_beacons_notif
modifier|*
name|resp
decl_stmt|;
name|int
name|missed
decl_stmt|;
comment|/* XXX look at mac_id to determine interface ID */
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
decl_stmt|;
name|SYNC_RESP_STRUCT
argument_list|(
name|resp
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
name|missed
operator|=
name|le32toh
argument_list|(
name|resp
operator|->
name|consec_missed_beacons
argument_list|)
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_BEACON
operator||
name|IWM_DEBUG_STATE
argument_list|,
literal|"%s: MISSED_BEACON: mac_id=%d, "
literal|"consec_since_last_rx=%d, consec=%d, num_expect=%d "
literal|"num_rx=%d\n"
argument_list|,
name|__func__
argument_list|,
name|le32toh
argument_list|(
name|resp
operator|->
name|mac_id
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|resp
operator|->
name|consec_missed_beacons_since_last_rx
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|resp
operator|->
name|consec_missed_beacons
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|resp
operator|->
name|num_expected_beacons
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|resp
operator|->
name|num_recvd_beacons
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Be paranoid */
if|if
condition|(
name|vap
operator|==
name|NULL
condition|)
break|break;
comment|/* XXX no net80211 locking? */
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_RUN
operator|&&
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SCAN
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|missed
operator|>
name|vap
operator|->
name|iv_bmissthreshold
condition|)
block|{
comment|/* XXX bad locking; turn into task */
name|IWM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ieee80211_beacon_miss
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|IWM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|IWM_MVM_ALIVE
case|:
block|{
name|struct
name|iwm_mvm_alive_resp
modifier|*
name|resp
decl_stmt|;
name|SYNC_RESP_STRUCT
argument_list|(
name|resp
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_uc
operator|.
name|uc_error_event_table
operator|=
name|le32toh
argument_list|(
name|resp
operator|->
name|error_event_table_ptr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_uc
operator|.
name|uc_log_event_table
operator|=
name|le32toh
argument_list|(
name|resp
operator|->
name|log_event_table_ptr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sched_base
operator|=
name|le32toh
argument_list|(
name|resp
operator|->
name|scd_base_ptr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_uc
operator|.
name|uc_ok
operator|=
name|resp
operator|->
name|status
operator|==
name|IWM_ALIVE_STATUS_OK
expr_stmt|;
name|sc
operator|->
name|sc_uc
operator|.
name|uc_intr
operator|=
literal|1
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|sc_uc
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|IWM_CALIB_RES_NOTIF_PHY_DB
case|:
block|{
name|struct
name|iwm_calib_res_notif_phy_db
modifier|*
name|phy_db_notif
decl_stmt|;
name|SYNC_RESP_STRUCT
argument_list|(
name|phy_db_notif
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
name|iwm_phy_db_set_section
argument_list|(
name|sc
argument_list|,
name|phy_db_notif
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|IWM_STATISTICS_NOTIFICATION
case|:
block|{
name|struct
name|iwm_notif_statistics
modifier|*
name|stats
decl_stmt|;
name|SYNC_RESP_STRUCT
argument_list|(
name|stats
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sc
operator|->
name|sc_stats
argument_list|,
name|stats
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_stats
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_noise
operator|=
name|iwm_get_noise
argument_list|(
operator|&
name|stats
operator|->
name|rx
operator|.
name|general
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|IWM_NVM_ACCESS_CMD
case|:
if|if
condition|(
name|sc
operator|->
name|sc_wantresp
operator|==
operator|(
operator|(
name|qid
operator|<<
literal|16
operator|)
operator||
name|idx
operator|)
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rxq
operator|.
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|sc
operator|->
name|sc_cmd_resp
argument_list|,
name|pkt
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_cmd_resp
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IWM_PHY_CONFIGURATION_CMD
case|:
case|case
name|IWM_TX_ANT_CONFIGURATION_CMD
case|:
case|case
name|IWM_ADD_STA
case|:
case|case
name|IWM_MAC_CONTEXT_CMD
case|:
case|case
name|IWM_REPLY_SF_CFG_CMD
case|:
case|case
name|IWM_POWER_TABLE_CMD
case|:
case|case
name|IWM_PHY_CONTEXT_CMD
case|:
case|case
name|IWM_BINDING_CONTEXT_CMD
case|:
case|case
name|IWM_TIME_EVENT_CMD
case|:
case|case
name|IWM_SCAN_REQUEST_CMD
case|:
case|case
name|IWM_REPLY_BEACON_FILTERING_CMD
case|:
case|case
name|IWM_MAC_PM_POWER_TABLE
case|:
case|case
name|IWM_TIME_QUOTA_CMD
case|:
case|case
name|IWM_REMOVE_STA
case|:
case|case
name|IWM_TXPATH_FLUSH
case|:
case|case
name|IWM_LQ_CMD
case|:
name|SYNC_RESP_STRUCT
argument_list|(
name|cresp
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_wantresp
operator|==
operator|(
operator|(
name|qid
operator|<<
literal|16
operator|)
operator||
name|idx
operator|)
condition|)
block|{
name|memcpy
argument_list|(
name|sc
operator|->
name|sc_cmd_resp
argument_list|,
name|pkt
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pkt
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|cresp
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* ignore */
case|case
literal|0x6c
case|:
comment|/* IWM_PHY_DB_CMD, no idea why it's not in fw-api.h */
break|break;
case|case
name|IWM_INIT_COMPLETE_NOTIF
case|:
name|sc
operator|->
name|sc_init_complete
operator|=
literal|1
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|sc_init_complete
argument_list|)
expr_stmt|;
break|break;
case|case
name|IWM_SCAN_COMPLETE_NOTIFICATION
case|:
block|{
name|struct
name|iwm_scan_complete_notif
modifier|*
name|notif
decl_stmt|;
name|SYNC_RESP_STRUCT
argument_list|(
name|notif
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|,
operator|&
name|sc
operator|->
name|sc_es_task
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|IWM_REPLY_ERROR
case|:
block|{
name|struct
name|iwm_error_resp
modifier|*
name|resp
decl_stmt|;
name|SYNC_RESP_STRUCT
argument_list|(
name|resp
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"firmware error 0x%x, cmd 0x%x\n"
argument_list|,
name|le32toh
argument_list|(
name|resp
operator|->
name|error_type
argument_list|)
argument_list|,
name|resp
operator|->
name|cmd_id
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|IWM_TIME_EVENT_NOTIFICATION
case|:
block|{
name|struct
name|iwm_time_event_notif
modifier|*
name|notif
decl_stmt|;
name|SYNC_RESP_STRUCT
argument_list|(
name|notif
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_INTR
argument_list|,
literal|"TE notif status = 0x%x action = 0x%x\n"
argument_list|,
name|notif
operator|->
name|status
argument_list|,
name|notif
operator|->
name|action
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|IWM_MCAST_FILTER_CMD
case|:
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"frame %d/%d %x UNHANDLED (this should "
literal|"not happen)\n"
argument_list|,
name|qid
argument_list|,
name|idx
argument_list|,
name|pkt
operator|->
name|len_n_flags
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * Why test bit 0x80?  The Linux driver: 		 * 		 * There is one exception:  uCode sets bit 15 when it 		 * originates the response/notification, i.e. when the 		 * response/notification is not a direct response to a 		 * command sent by the driver.  For example, uCode issues 		 * IWM_REPLY_RX when it sends a received frame to the driver; 		 * it is not a direct response to any driver command. 		 * 		 * Ok, so since when is 7 == 15?  Well, the Linux driver 		 * uses a slightly different format for pkt->hdr, and "qid" 		 * is actually the upper byte of a two-byte field. 		 */
if|if
condition|(
operator|!
operator|(
name|pkt
operator|->
name|hdr
operator|.
name|qid
operator|&
operator|(
literal|1
operator|<<
literal|7
operator|)
operator|)
condition|)
block|{
name|iwm_cmd_done
argument_list|(
name|sc
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
block|}
name|ADVANCE_RXQ
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|IWM_CLRBITS
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_GP_CNTRL
argument_list|,
name|IWM_CSR_GP_CNTRL_REG_FLAG_MAC_ACCESS_REQ
argument_list|)
expr_stmt|;
comment|/* 	 * Tell the firmware what we have processed. 	 * Seems like the hardware gets upset unless we align 	 * the write by 8?? 	 */
name|hw
operator|=
operator|(
name|hw
operator|==
literal|0
operator|)
condition|?
name|IWM_RX_RING_COUNT
operator|-
literal|1
else|:
name|hw
operator|-
literal|1
expr_stmt|;
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_FH_RSCSR_CHNL0_WPTR
argument_list|,
name|hw
operator|&
operator|~
literal|7
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|iwm_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|int
name|handled
init|=
literal|0
decl_stmt|;
name|int
name|r1
decl_stmt|,
name|r2
decl_stmt|,
name|rv
init|=
literal|0
decl_stmt|;
name|int
name|isperiodic
init|=
literal|0
decl_stmt|;
name|IWM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_INT_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWM_FLAG_USE_ICT
condition|)
block|{
name|uint32_t
modifier|*
name|ict
init|=
name|sc
operator|->
name|ict_dma
operator|.
name|vaddr
decl_stmt|;
name|int
name|tmp
decl_stmt|;
name|tmp
operator|=
name|htole32
argument_list|(
name|ict
index|[
name|sc
operator|->
name|ict_cur
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
goto|goto
name|out_ena
goto|;
comment|/* 		 * ok, there was something.  keep plowing until we have all. 		 */
name|r1
operator|=
name|r2
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|tmp
condition|)
block|{
name|r1
operator||=
name|tmp
expr_stmt|;
name|ict
index|[
name|sc
operator|->
name|ict_cur
index|]
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|ict_cur
operator|=
operator|(
name|sc
operator|->
name|ict_cur
operator|+
literal|1
operator|)
operator|%
name|IWM_ICT_COUNT
expr_stmt|;
name|tmp
operator|=
name|htole32
argument_list|(
name|ict
index|[
name|sc
operator|->
name|ict_cur
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* this is where the fun begins.  don't ask */
if|if
condition|(
name|r1
operator|==
literal|0xffffffff
condition|)
name|r1
operator|=
literal|0
expr_stmt|;
comment|/* i am not expected to understand this */
if|if
condition|(
name|r1
operator|&
literal|0xc0000
condition|)
name|r1
operator||=
literal|0x8000
expr_stmt|;
name|r1
operator|=
operator|(
literal|0xff
operator|&
name|r1
operator|)
operator||
operator|(
operator|(
literal|0xff00
operator|&
name|r1
operator|)
operator|<<
literal|16
operator|)
expr_stmt|;
block|}
else|else
block|{
name|r1
operator|=
name|IWM_READ
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_INT
argument_list|)
expr_stmt|;
comment|/* "hardware gone" (where, fishing?) */
if|if
condition|(
name|r1
operator|==
literal|0xffffffff
operator|||
operator|(
name|r1
operator|&
literal|0xfffffff0
operator|)
operator|==
literal|0xa5a5a5a0
condition|)
goto|goto
name|out
goto|;
name|r2
operator|=
name|IWM_READ
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_FH_INT_STATUS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r1
operator|==
literal|0
operator|&&
name|r2
operator|==
literal|0
condition|)
block|{
goto|goto
name|out_ena
goto|;
block|}
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_INT
argument_list|,
name|r1
operator||
operator|~
name|sc
operator|->
name|sc_intmask
argument_list|)
expr_stmt|;
comment|/* ignored */
name|handled
operator||=
operator|(
name|r1
operator|&
operator|(
name|IWM_CSR_INT_BIT_ALIVE
comment|/*| IWM_CSR_INT_BIT_SCD*/
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|r1
operator|&
name|IWM_CSR_INT_BIT_SW_ERR
condition|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|IWM_DEBUG
name|iwm_nic_error
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Dump driver status (TX and RX rings) while we're here. */
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"driver status:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IWM_MVM_MAX_QUEUES
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|iwm_tx_ring
modifier|*
name|ring
init|=
operator|&
name|sc
operator|->
name|txq
index|[
name|i
index|]
decl_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"  tx ring %2d: qid=%-2d cur=%-3d "
literal|"queued=%-3d\n"
argument_list|,
name|i
argument_list|,
name|ring
operator|->
name|qid
argument_list|,
name|ring
operator|->
name|cur
argument_list|,
name|ring
operator|->
name|queued
argument_list|)
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"  rx ring: cur=%d\n"
argument_list|,
name|sc
operator|->
name|rxq
operator|.
name|cur
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"  802.11 state %d\n"
argument_list|,
operator|(
name|vap
operator|==
name|NULL
operator|)
condition|?
operator|-
literal|1
else|:
name|vap
operator|->
name|iv_state
argument_list|)
expr_stmt|;
comment|/* Don't stop the device; just do a VAP restart */
name|IWM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: null vap\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: controller panicked, iv_state = %d; "
literal|"restarting\n"
argument_list|,
name|__func__
argument_list|,
name|vap
operator|->
name|iv_state
argument_list|)
expr_stmt|;
comment|/* XXX TODO: turn this into a callout/taskqueue */
name|ieee80211_restart_all
argument_list|(
name|ic
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|r1
operator|&
name|IWM_CSR_INT_BIT_HW_ERR
condition|)
block|{
name|handled
operator||=
name|IWM_CSR_INT_BIT_HW_ERR
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"hardware error, stopping device\n"
argument_list|)
expr_stmt|;
name|iwm_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rv
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* firmware chunk loaded */
if|if
condition|(
name|r1
operator|&
name|IWM_CSR_INT_BIT_FH_TX
condition|)
block|{
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_FH_INT_STATUS
argument_list|,
name|IWM_CSR_FH_INT_TX_MASK
argument_list|)
expr_stmt|;
name|handled
operator||=
name|IWM_CSR_INT_BIT_FH_TX
expr_stmt|;
name|sc
operator|->
name|sc_fw_chunk_done
operator|=
literal|1
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|sc_fw
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r1
operator|&
name|IWM_CSR_INT_BIT_RF_KILL
condition|)
block|{
name|handled
operator||=
name|IWM_CSR_INT_BIT_RF_KILL
expr_stmt|;
if|if
condition|(
name|iwm_check_rfkill
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: rfkill switch, disabling interface\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|iwm_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * The Linux driver uses periodic interrupts to avoid races. 	 * We cargo-cult like it's going out of fashion. 	 */
if|if
condition|(
name|r1
operator|&
name|IWM_CSR_INT_BIT_RX_PERIODIC
condition|)
block|{
name|handled
operator||=
name|IWM_CSR_INT_BIT_RX_PERIODIC
expr_stmt|;
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_INT
argument_list|,
name|IWM_CSR_INT_BIT_RX_PERIODIC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r1
operator|&
operator|(
name|IWM_CSR_INT_BIT_FH_RX
operator||
name|IWM_CSR_INT_BIT_SW_RX
operator|)
operator|)
operator|==
literal|0
condition|)
name|IWM_WRITE_1
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_INT_PERIODIC_REG
argument_list|,
name|IWM_CSR_INT_PERIODIC_DIS
argument_list|)
expr_stmt|;
name|isperiodic
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|r1
operator|&
operator|(
name|IWM_CSR_INT_BIT_FH_RX
operator||
name|IWM_CSR_INT_BIT_SW_RX
operator|)
operator|)
operator|||
name|isperiodic
condition|)
block|{
name|handled
operator||=
operator|(
name|IWM_CSR_INT_BIT_FH_RX
operator||
name|IWM_CSR_INT_BIT_SW_RX
operator|)
expr_stmt|;
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_FH_INT_STATUS
argument_list|,
name|IWM_CSR_FH_INT_RX_MASK
argument_list|)
expr_stmt|;
name|iwm_notif_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* enable periodic interrupt, see above */
if|if
condition|(
name|r1
operator|&
operator|(
name|IWM_CSR_INT_BIT_FH_RX
operator||
name|IWM_CSR_INT_BIT_SW_RX
operator|)
operator|&&
operator|!
name|isperiodic
condition|)
name|IWM_WRITE_1
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_INT_PERIODIC_REG
argument_list|,
name|IWM_CSR_INT_PERIODIC_ENA
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|__predict_false
argument_list|(
name|r1
operator|&
operator|~
name|handled
argument_list|)
condition|)
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_INTR
argument_list|,
literal|"%s: unhandled interrupts: %x\n"
argument_list|,
name|__func__
argument_list|,
name|r1
argument_list|)
expr_stmt|;
name|rv
operator|=
literal|1
expr_stmt|;
name|out_ena
label|:
name|iwm_restore_interrupts
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|out
label|:
name|IWM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Autoconf glue-sniffing  */
end_comment

begin_define
define|#
directive|define
name|PCI_VENDOR_INTEL
value|0x8086
end_define

begin_define
define|#
directive|define
name|PCI_PRODUCT_INTEL_WL_3160_1
value|0x08b3
end_define

begin_define
define|#
directive|define
name|PCI_PRODUCT_INTEL_WL_3160_2
value|0x08b4
end_define

begin_define
define|#
directive|define
name|PCI_PRODUCT_INTEL_WL_7260_1
value|0x08b1
end_define

begin_define
define|#
directive|define
name|PCI_PRODUCT_INTEL_WL_7260_2
value|0x08b2
end_define

begin_define
define|#
directive|define
name|PCI_PRODUCT_INTEL_WL_7265_1
value|0x095a
end_define

begin_define
define|#
directive|define
name|PCI_PRODUCT_INTEL_WL_7265_2
value|0x095b
end_define

begin_struct
specifier|static
specifier|const
struct|struct
name|iwm_devices
block|{
name|uint16_t
name|device
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|iwm_devices
index|[]
init|=
block|{
block|{
name|PCI_PRODUCT_INTEL_WL_3160_1
block|,
literal|"Intel Dual Band Wireless AC 3160"
block|}
block|,
block|{
name|PCI_PRODUCT_INTEL_WL_3160_2
block|,
literal|"Intel Dual Band Wireless AC 3160"
block|}
block|,
block|{
name|PCI_PRODUCT_INTEL_WL_7260_1
block|,
literal|"Intel Dual Band Wireless AC 7260"
block|}
block|,
block|{
name|PCI_PRODUCT_INTEL_WL_7260_2
block|,
literal|"Intel Dual Band Wireless AC 7260"
block|}
block|,
block|{
name|PCI_PRODUCT_INTEL_WL_7265_1
block|,
literal|"Intel Dual Band Wireless AC 7265"
block|}
block|,
block|{
name|PCI_PRODUCT_INTEL_WL_7265_2
block|,
literal|"Intel Dual Band Wireless AC 7265"
block|}
block|, }
struct|;
end_struct

begin_function
specifier|static
name|int
name|iwm_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|iwm_devices
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_VENDOR_INTEL
operator|&&
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|iwm_devices
index|[
name|i
index|]
operator|.
name|device
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|iwm_devices
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_dev_check
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|iwm_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pci_get_device
argument_list|(
name|dev
argument_list|)
condition|)
block|{
case|case
name|PCI_PRODUCT_INTEL_WL_3160_1
case|:
case|case
name|PCI_PRODUCT_INTEL_WL_3160_2
case|:
name|sc
operator|->
name|sc_fwname
operator|=
literal|"iwm3160fw"
expr_stmt|;
name|sc
operator|->
name|host_interrupt_operation_mode
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|PCI_PRODUCT_INTEL_WL_7260_1
case|:
case|case
name|PCI_PRODUCT_INTEL_WL_7260_2
case|:
name|sc
operator|->
name|sc_fwname
operator|=
literal|"iwm7260fw"
expr_stmt|;
name|sc
operator|->
name|host_interrupt_operation_mode
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|PCI_PRODUCT_INTEL_WL_7265_1
case|:
case|case
name|PCI_PRODUCT_INTEL_WL_7265_2
case|:
name|sc
operator|->
name|sc_fwname
operator|=
literal|"iwm7265fw"
expr_stmt|;
name|sc
operator|->
name|host_interrupt_operation_mode
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unknown adapter type\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_pci_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|iwm_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|count
decl_stmt|,
name|error
decl_stmt|,
name|rid
decl_stmt|;
name|uint16_t
name|reg
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Clear device-specific "PCI retry timeout" register (41h). */
name|reg
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
literal|0x40
argument_list|,
sizeof|sizeof
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
literal|0x40
argument_list|,
name|reg
operator|&
operator|~
literal|0xff00
argument_list|,
sizeof|sizeof
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Enable bus-mastering and hardware bug workaround. */
name|pci_enable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|reg
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_STATUS
argument_list|,
sizeof|sizeof
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* if !MSI */
if|if
condition|(
name|reg
operator|&
name|PCIM_STATUS_INTxSTATE
condition|)
block|{
name|reg
operator|&=
operator|~
name|PCIM_STATUS_INTxSTATE
expr_stmt|;
block|}
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_STATUS
argument_list|,
name|reg
argument_list|,
sizeof|sizeof
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|rid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_mem
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_mem
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"can't map mem space\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|sc_st
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|sc_mem
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_sh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|sc_mem
argument_list|)
expr_stmt|;
comment|/* Install interrupt handler. */
name|count
operator|=
literal|1
expr_stmt|;
name|rid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pci_alloc_msi
argument_list|(
name|dev
argument_list|,
operator|&
name|count
argument_list|)
operator|==
literal|0
condition|)
name|rid
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_irq
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
operator||
operator|(
name|rid
operator|!=
literal|0
condition|?
literal|0
else|:
name|RF_SHAREABLE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_irq
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can't map interrupt\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|sc_irq
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|iwm_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_ih
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ih
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can't establish interrupt"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|sc_dmat
operator|=
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_pci_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|iwm_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_irq
operator|!=
name|NULL
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|sc_irq
argument_list|,
name|sc
operator|->
name|sc_ih
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rman_get_rid
argument_list|(
name|sc
operator|->
name|sc_irq
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_irq
argument_list|)
expr_stmt|;
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_mem
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|rman_get_rid
argument_list|(
name|sc
operator|->
name|sc_mem
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_mem
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|iwm_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|txq_i
decl_stmt|,
name|i
decl_stmt|;
name|sc
operator|->
name|sc_dev
operator|=
name|dev
expr_stmt|;
name|IWM_LOCK_INIT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mbufq_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_snd
argument_list|,
name|ifqmaxlen
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_watchdog_to
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_es_task
argument_list|,
literal|0
argument_list|,
name|iwm_endscan_cb
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tq
operator|=
name|taskqueue_create
argument_list|(
literal|"iwm_taskq"
argument_list|,
name|M_WAITOK
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|sc
operator|->
name|sc_tq
argument_list|)
expr_stmt|;
name|error
operator|=
name|taskqueue_start_threads
argument_list|(
operator|&
name|sc
operator|->
name|sc_tq
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"iwm_taskq"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can't start threads, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* PCI attach */
name|error
operator|=
name|iwm_pci_attach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|sc
operator|->
name|sc_wantresp
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Check device type */
name|error
operator|=
name|iwm_dev_check
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|sc
operator|->
name|sc_fwdmasegsz
operator|=
name|IWM_FWDMASEGSZ
expr_stmt|;
comment|/* 	 * We now start fiddling with the hardware 	 */
name|sc
operator|->
name|sc_hw_rev
operator|=
name|IWM_READ
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_HW_REV
argument_list|)
expr_stmt|;
if|if
condition|(
name|iwm_prepare_card_hw
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not initialize hardware\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Allocate DMA memory for firmware transfers. */
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_alloc_fwmem
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate memory for firmware\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Allocate "Keep Warm" page. */
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_alloc_kw
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate keep warm page\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* We use ICT interrupts */
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_alloc_ict
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate ICT table\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Allocate TX scheduler "rings". */
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_alloc_sched
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate TX scheduler rings\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Allocate TX rings */
for|for
control|(
name|txq_i
operator|=
literal|0
init|;
name|txq_i
operator|<
name|nitems
argument_list|(
name|sc
operator|->
name|txq
argument_list|)
condition|;
name|txq_i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_alloc_tx_ring
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|txq
index|[
name|txq_i
index|]
argument_list|,
name|txq_i
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate TX ring %d\n"
argument_list|,
name|txq_i
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
comment|/* Allocate RX ring. */
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_alloc_rx_ring
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rxq
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate RX ring\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Clear pending interrupts. */
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_INT
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_softc
operator|=
name|sc
expr_stmt|;
name|ic
operator|->
name|ic_name
operator|=
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_phytype
operator|=
name|IEEE80211_T_OFDM
expr_stmt|;
comment|/* not only, but not used */
name|ic
operator|->
name|ic_opmode
operator|=
name|IEEE80211_M_STA
expr_stmt|;
comment|/* default to BSS mode */
comment|/* Set device capabilities. */
name|ic
operator|->
name|ic_caps
operator|=
name|IEEE80211_C_STA
operator||
name|IEEE80211_C_WPA
operator||
comment|/* WPA/RSN */
name|IEEE80211_C_WME
operator||
name|IEEE80211_C_SHSLOT
operator||
comment|/* short slot time supported */
name|IEEE80211_C_SHPREAMBLE
comment|/* short preamble supported */
comment|//	    IEEE80211_C_BGSCAN		/* capable of bg scanning */
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|sc
operator|->
name|sc_phyctxt
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|sc_phyctxt
index|[
name|i
index|]
operator|.
name|id
operator|=
name|i
expr_stmt|;
name|sc
operator|->
name|sc_phyctxt
index|[
name|i
index|]
operator|.
name|color
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_phyctxt
index|[
name|i
index|]
operator|.
name|ref
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_phyctxt
index|[
name|i
index|]
operator|.
name|channel
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Max RSSI */
name|sc
operator|->
name|sc_max_rssi
operator|=
name|IWM_MAX_DBM
operator|-
name|IWM_MIN_DBM
expr_stmt|;
name|sc
operator|->
name|sc_preinit_hook
operator|.
name|ich_func
operator|=
name|iwm_preinit
expr_stmt|;
name|sc
operator|->
name|sc_preinit_hook
operator|.
name|ich_arg
operator|=
name|sc
expr_stmt|;
if|if
condition|(
name|config_intrhook_establish
argument_list|(
operator|&
name|sc
operator|->
name|sc_preinit_hook
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"config_intrhook_establish failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
ifdef|#
directive|ifdef
name|IWM_DEBUG
name|SYSCTL_ADD_INT
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"debug"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|sc_debug
argument_list|,
literal|0
argument_list|,
literal|"control debugging"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_RESET
operator||
name|IWM_DEBUG_TRACE
argument_list|,
literal|"<-%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* Free allocated memory if something failed during attachment. */
name|fail
label|:
name|iwm_detach_local
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_update_edca
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|iwm_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: called\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_preinit
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|iwm_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|device_t
name|dev
init|=
name|sc
operator|->
name|sc_dev
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|int
name|error
decl_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_RESET
operator||
name|IWM_DEBUG_TRACE
argument_list|,
literal|"->%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|IWM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_start_hw
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not initialize hardware\n"
argument_list|)
expr_stmt|;
name|IWM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|iwm_run_init_mvm_ucode
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|iwm_stop_device
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|IWM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"revision: 0x%x, firmware %d.%d (API ver. %d)\n"
argument_list|,
name|sc
operator|->
name|sc_hw_rev
operator|&
name|IWM_CSR_HW_REV_TYPE_MSK
argument_list|,
name|IWM_UCODE_MAJOR
argument_list|(
name|sc
operator|->
name|sc_fwver
argument_list|)
argument_list|,
name|IWM_UCODE_MINOR
argument_list|(
name|sc
operator|->
name|sc_fwver
argument_list|)
argument_list|,
name|IWM_UCODE_API
argument_list|(
name|sc
operator|->
name|sc_fwver
argument_list|)
argument_list|)
expr_stmt|;
comment|/* not all hardware can do 5GHz band */
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_nvm
operator|.
name|sku_cap_band_52GHz_enable
condition|)
name|memset
argument_list|(
operator|&
name|ic
operator|->
name|ic_sup_rates
index|[
name|IEEE80211_MODE_11A
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ic
operator|->
name|ic_sup_rates
index|[
name|IEEE80211_MODE_11A
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|IWM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iwm_init_channel_map
argument_list|(
name|ic
argument_list|,
name|IEEE80211_CHAN_MAX
argument_list|,
operator|&
name|ic
operator|->
name|ic_nchans
argument_list|,
name|ic
operator|->
name|ic_channels
argument_list|)
expr_stmt|;
comment|/* 	 * At this point we've committed - if we fail to do setup, 	 * we now also have to tear down the net80211 state. 	 */
name|ieee80211_ifattach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_vap_create
operator|=
name|iwm_vap_create
expr_stmt|;
name|ic
operator|->
name|ic_vap_delete
operator|=
name|iwm_vap_delete
expr_stmt|;
name|ic
operator|->
name|ic_raw_xmit
operator|=
name|iwm_raw_xmit
expr_stmt|;
name|ic
operator|->
name|ic_node_alloc
operator|=
name|iwm_node_alloc
expr_stmt|;
name|ic
operator|->
name|ic_scan_start
operator|=
name|iwm_scan_start
expr_stmt|;
name|ic
operator|->
name|ic_scan_end
operator|=
name|iwm_scan_end
expr_stmt|;
name|ic
operator|->
name|ic_update_mcast
operator|=
name|iwm_update_mcast
expr_stmt|;
name|ic
operator|->
name|ic_getradiocaps
operator|=
name|iwm_init_channel_map
expr_stmt|;
name|ic
operator|->
name|ic_set_channel
operator|=
name|iwm_set_channel
expr_stmt|;
name|ic
operator|->
name|ic_scan_curchan
operator|=
name|iwm_scan_curchan
expr_stmt|;
name|ic
operator|->
name|ic_scan_mindwell
operator|=
name|iwm_scan_mindwell
expr_stmt|;
name|ic
operator|->
name|ic_wme
operator|.
name|wme_update
operator|=
name|iwm_update_edca
expr_stmt|;
name|ic
operator|->
name|ic_parent
operator|=
name|iwm_parent
expr_stmt|;
name|ic
operator|->
name|ic_transmit
operator|=
name|iwm_transmit
expr_stmt|;
name|iwm_radiotap_attach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|ieee80211_announce
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_RESET
operator||
name|IWM_DEBUG_TRACE
argument_list|,
literal|"<-%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|config_intrhook_disestablish
argument_list|(
operator|&
name|sc
operator|->
name|sc_preinit_hook
argument_list|)
expr_stmt|;
return|return;
name|fail
label|:
name|config_intrhook_disestablish
argument_list|(
operator|&
name|sc
operator|->
name|sc_preinit_hook
argument_list|)
expr_stmt|;
name|iwm_detach_local
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Attach the interface to 802.11 radiotap.  */
end_comment

begin_function
specifier|static
name|void
name|iwm_radiotap_attach
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_RESET
operator||
name|IWM_DEBUG_TRACE
argument_list|,
literal|"->%s begin\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ieee80211_radiotap_attach
argument_list|(
name|ic
argument_list|,
operator|&
name|sc
operator|->
name|sc_txtap
operator|.
name|wt_ihdr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_txtap
argument_list|)
argument_list|,
name|IWM_TX_RADIOTAP_PRESENT
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxtap
operator|.
name|wr_ihdr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_rxtap
argument_list|)
argument_list|,
name|IWM_RX_RADIOTAP_PRESENT
argument_list|)
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_RESET
operator||
name|IWM_DEBUG_TRACE
argument_list|,
literal|"->%s end\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ieee80211vap
modifier|*
name|iwm_vap_create
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|char
name|name
index|[
name|IFNAMSIZ
index|]
parameter_list|,
name|int
name|unit
parameter_list|,
name|enum
name|ieee80211_opmode
name|opmode
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|uint8_t
name|bssid
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|iwm_vap
modifier|*
name|ivp
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
condition|)
comment|/* only one at a time */
return|return
name|NULL
return|;
name|ivp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|iwm_vap
argument_list|)
argument_list|,
name|M_80211_VAP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|vap
operator|=
operator|&
name|ivp
operator|->
name|iv_vap
expr_stmt|;
name|ieee80211_vap_setup
argument_list|(
name|ic
argument_list|,
name|vap
argument_list|,
name|name
argument_list|,
name|unit
argument_list|,
name|opmode
argument_list|,
name|flags
argument_list|,
name|bssid
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_bmissthreshold
operator|=
literal|10
expr_stmt|;
comment|/* override default */
comment|/* Override with driver methods. */
name|ivp
operator|->
name|iv_newstate
operator|=
name|vap
operator|->
name|iv_newstate
expr_stmt|;
name|vap
operator|->
name|iv_newstate
operator|=
name|iwm_newstate
expr_stmt|;
name|ieee80211_ratectl_init
argument_list|(
name|vap
argument_list|)
expr_stmt|;
comment|/* Complete setup. */
name|ieee80211_vap_attach
argument_list|(
name|vap
argument_list|,
name|iwm_media_change
argument_list|,
name|ieee80211_media_status
argument_list|,
name|mac
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_opmode
operator|=
name|opmode
expr_stmt|;
return|return
name|vap
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_vap_delete
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|iwm_vap
modifier|*
name|ivp
init|=
name|IWM_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|ieee80211_ratectl_deinit
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|ieee80211_vap_detach
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ivp
argument_list|,
name|M_80211_VAP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_scan_start
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
decl_stmt|;
name|struct
name|iwm_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_scanband
condition|)
return|return;
name|IWM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwm_mvm_scan_request
argument_list|(
name|sc
argument_list|,
name|IEEE80211_CHAN_2GHZ
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not initiate scan\n"
argument_list|)
expr_stmt|;
name|IWM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ieee80211_cancel_scan
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
else|else
name|IWM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwm_scan_end
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|iwm_update_mcast
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|iwm_set_channel
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|iwm_scan_curchan
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|,
name|unsigned
name|long
name|maxdwell
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|iwm_scan_mindwell
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|)
block|{
return|return;
block|}
end_function

begin_function
name|void
name|iwm_init_task
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|)
block|{
name|struct
name|iwm_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|IWM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWM_FLAG_BUSY
condition|)
name|msleep
argument_list|(
operator|&
name|sc
operator|->
name|sc_flags
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|0
argument_list|,
literal|"iwmpwr"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|IWM_FLAG_BUSY
expr_stmt|;
name|iwm_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ic
operator|.
name|ic_nrunning
operator|>
literal|0
condition|)
name|iwm_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|IWM_FLAG_BUSY
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|sc_flags
argument_list|)
expr_stmt|;
name|IWM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|iwm_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|do_reinit
init|=
literal|0
decl_stmt|;
name|uint16_t
name|reg
decl_stmt|;
comment|/* Clear device-specific "PCI retry timeout" register (41h). */
name|reg
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
literal|0x40
argument_list|,
sizeof|sizeof
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
literal|0x40
argument_list|,
name|reg
operator|&
operator|~
literal|0xff00
argument_list|,
sizeof|sizeof
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|iwm_init_task
argument_list|(
name|device_get_softc
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|IWM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWM_FLAG_DORESUME
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|IWM_FLAG_DORESUME
expr_stmt|;
name|do_reinit
operator|=
literal|1
expr_stmt|;
block|}
name|IWM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_reinit
condition|)
name|ieee80211_resume_all
argument_list|(
operator|&
name|sc
operator|->
name|sc_ic
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|do_stop
init|=
literal|0
decl_stmt|;
name|struct
name|iwm_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|do_stop
operator|=
operator|!
operator|!
operator|(
name|sc
operator|->
name|sc_ic
operator|.
name|ic_nrunning
operator|>
literal|0
operator|)
expr_stmt|;
name|ieee80211_suspend_all
argument_list|(
operator|&
name|sc
operator|->
name|sc_ic
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_stop
condition|)
block|{
name|IWM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iwm_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|IWM_FLAG_DORESUME
expr_stmt|;
name|IWM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_detach_local
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|int
name|do_net80211
parameter_list|)
block|{
name|struct
name|iwm_fw_info
modifier|*
name|fw
init|=
operator|&
name|sc
operator|->
name|sc_fw
decl_stmt|;
name|device_t
name|dev
init|=
name|sc
operator|->
name|sc_dev
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_tq
condition|)
block|{
name|taskqueue_drain_all
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|)
expr_stmt|;
block|}
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|sc_watchdog_to
argument_list|)
expr_stmt|;
name|iwm_stop_device
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_net80211
condition|)
name|ieee80211_ifdetach
argument_list|(
operator|&
name|sc
operator|->
name|sc_ic
argument_list|)
expr_stmt|;
comment|/* Free descriptor rings */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|sc
operator|->
name|txq
argument_list|)
condition|;
name|i
operator|++
control|)
name|iwm_free_tx_ring
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|txq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Free firmware */
if|if
condition|(
name|fw
operator|->
name|fw_fp
operator|!=
name|NULL
condition|)
name|iwm_fw_info_free
argument_list|(
name|fw
argument_list|)
expr_stmt|;
comment|/* Free scheduler */
name|iwm_free_sched
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ict_dma
operator|.
name|vaddr
operator|!=
name|NULL
condition|)
name|iwm_free_ict
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|kw_dma
operator|.
name|vaddr
operator|!=
name|NULL
condition|)
name|iwm_free_kw
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|fw_dma
operator|.
name|vaddr
operator|!=
name|NULL
condition|)
name|iwm_free_fwmem
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Finished with the hardware - detach things */
name|iwm_pci_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mbufq_drain
argument_list|(
operator|&
name|sc
operator|->
name|sc_snd
argument_list|)
expr_stmt|;
name|IWM_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwm_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|iwm_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
return|return
operator|(
name|iwm_detach_local
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|iwm_pci_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|iwm_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|iwm_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|iwm_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|iwm_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|iwm_resume
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|iwm_pci_driver
init|=
block|{
literal|"iwm"
block|,
name|iwm_pci_methods
block|,
expr|sizeof
operator|(
expr|struct
name|iwm_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|iwm_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|iwm
argument_list|,
name|pci
argument_list|,
name|iwm_pci_driver
argument_list|,
name|iwm_devclass
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|iwm
argument_list|,
name|firmware
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|iwm
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|iwm
argument_list|,
name|wlan
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

