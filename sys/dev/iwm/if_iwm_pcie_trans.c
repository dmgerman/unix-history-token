begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$OpenBSD: if_iwm.c,v 1.39 2015/03/23 00:35:19 jsg Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 2014 genua mbh<info@genua.de>  * Copyright (c) 2014 Fixup Software Ltd.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/*-  * Based on BSD-licensed source modules in the Linux iwlwifi driver,  * which were used as the reference documentation for this implementation.  *  * Driver version we are currently based off of is  * Linux 3.14.3 (tag id a2df521e42b1d9a23f620ac79dbfe8655a8391dd)  *  ***********************************************************************  *  * This file is provided under a dual BSD/GPLv2 license.  When using or  * redistributing this file, you may do so under either license.  *  * GPL LICENSE SUMMARY  *  * Copyright(c) 2007 - 2013 Intel Corporation. All rights reserved.  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of version 2 of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it will be useful, but  * WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  * General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110,  * USA  *  * The full GNU General Public License is included in this distribution  * in the file called COPYING.  *  * Contact Information:  *  Intel Linux Wireless<ilw@linux.intel.com>  * Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497  *  *  * BSD LICENSE  *  * Copyright(c) 2005 - 2013 Intel Corporation. All rights reserved.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  *  * Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * Neither the name Intel Corporation nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2007-2010 Damien Bergamini<damien.bergamini@free.fr>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_wlan.h"
end_include

begin_include
include|#
directive|include
file|"opt_iwm.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/firmware.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/endian.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_regdomain.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_ratectl.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_radiotap.h>
end_include

begin_include
include|#
directive|include
file|<dev/iwm/if_iwmreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/iwm/if_iwmvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/iwm/if_iwm_config.h>
end_include

begin_include
include|#
directive|include
file|<dev/iwm/if_iwm_debug.h>
end_include

begin_include
include|#
directive|include
file|<dev/iwm/if_iwm_pcie_trans.h>
end_include

begin_comment
comment|/*  * This is a subset of what's in linux iwlwifi/pcie/trans.c.  * The rest can be migrated out into here once they're no longer in  * if_iwm.c.  */
end_comment

begin_comment
comment|/*  * basic device access  */
end_comment

begin_function
name|uint32_t
name|iwm_read_prph
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|)
block|{
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_HBUS_TARG_PRPH_RADDR
argument_list|,
operator|(
operator|(
name|addr
operator|&
literal|0x000fffff
operator|)
operator||
operator|(
literal|3
operator|<<
literal|24
operator|)
operator|)
argument_list|)
expr_stmt|;
name|IWM_BARRIER_READ_WRITE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|IWM_READ
argument_list|(
name|sc
argument_list|,
name|IWM_HBUS_TARG_PRPH_RDAT
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|iwm_write_prph
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_HBUS_TARG_PRPH_WADDR
argument_list|,
operator|(
operator|(
name|addr
operator|&
literal|0x000fffff
operator|)
operator||
operator|(
literal|3
operator|<<
literal|24
operator|)
operator|)
argument_list|)
expr_stmt|;
name|IWM_BARRIER_WRITE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_HBUS_TARG_PRPH_WDAT
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|IWM_DEBUG
end_ifdef

begin_comment
comment|/* iwlwifi: pcie/trans.c */
end_comment

begin_function
name|int
name|iwm_read_mem
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|int
name|dwords
parameter_list|)
block|{
name|int
name|offs
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|uint32_t
modifier|*
name|vals
init|=
name|buf
decl_stmt|;
if|if
condition|(
name|iwm_nic_lock
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_HBUS_TARG_MEM_RADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
for|for
control|(
name|offs
operator|=
literal|0
init|;
name|offs
operator|<
name|dwords
condition|;
name|offs
operator|++
control|)
name|vals
index|[
name|offs
index|]
operator|=
name|IWM_READ
argument_list|(
name|sc
argument_list|,
name|IWM_HBUS_TARG_MEM_RDAT
argument_list|)
expr_stmt|;
name|iwm_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|EBUSY
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* iwlwifi: pcie/trans.c */
end_comment

begin_function
name|int
name|iwm_write_mem
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|int
name|dwords
parameter_list|)
block|{
name|int
name|offs
decl_stmt|;
specifier|const
name|uint32_t
modifier|*
name|vals
init|=
name|buf
decl_stmt|;
if|if
condition|(
name|iwm_nic_lock
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_HBUS_TARG_MEM_WADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/* WADDR auto-increments */
for|for
control|(
name|offs
operator|=
literal|0
init|;
name|offs
operator|<
name|dwords
condition|;
name|offs
operator|++
control|)
block|{
name|uint32_t
name|val
init|=
name|vals
condition|?
name|vals
index|[
name|offs
index|]
else|:
literal|0
decl_stmt|;
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_HBUS_TARG_MEM_WDAT
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|iwm_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_TRANS
argument_list|,
literal|"%s: write_mem failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|iwm_write_mem32
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
return|return
name|iwm_write_mem
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
operator|&
name|val
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|iwm_poll_bit
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|int
name|reg
parameter_list|,
name|uint32_t
name|bits
parameter_list|,
name|uint32_t
name|mask
parameter_list|,
name|int
name|timo
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|IWM_READ
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|)
operator|&
name|mask
operator|)
operator|==
operator|(
name|bits
operator|&
name|mask
operator|)
condition|)
block|{
return|return
literal|1
return|;
block|}
if|if
condition|(
name|timo
operator|<
literal|10
condition|)
block|{
return|return
literal|0
return|;
block|}
name|timo
operator|-=
literal|10
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|iwm_nic_lock
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|rv
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|cmd_hold_nic_awake
condition|)
return|return
literal|1
return|;
name|IWM_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_GP_CNTRL
argument_list|,
name|IWM_CSR_GP_CNTRL_REG_FLAG_MAC_ACCESS_REQ
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|cfg
operator|->
name|device_family
operator|==
name|IWM_DEVICE_FAMILY_8000
condition|)
name|DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|iwm_poll_bit
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_GP_CNTRL
argument_list|,
name|IWM_CSR_GP_CNTRL_REG_VAL_MAC_ACCESS_EN
argument_list|,
name|IWM_CSR_GP_CNTRL_REG_FLAG_MAC_CLOCK_READY
operator||
name|IWM_CSR_GP_CNTRL_REG_FLAG_GOING_TO_SLEEP
argument_list|,
literal|15000
argument_list|)
condition|)
block|{
name|rv
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* jolt */
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_RESET
argument_list|,
literal|"%s: resetting device via NMI\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_RESET
argument_list|,
name|IWM_CSR_RESET_REG_FLAG_FORCE_NMI
argument_list|)
expr_stmt|;
block|}
return|return
name|rv
return|;
block|}
end_function

begin_function
name|void
name|iwm_nic_unlock
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|cmd_hold_nic_awake
condition|)
return|return;
name|IWM_CLRBITS
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_GP_CNTRL
argument_list|,
name|IWM_CSR_GP_CNTRL_REG_FLAG_MAC_ACCESS_REQ
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|iwm_set_bits_mask_prph
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|reg
parameter_list|,
name|uint32_t
name|bits
parameter_list|,
name|uint32_t
name|mask
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
comment|/* XXX: no error path? */
if|if
condition|(
name|iwm_nic_lock
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|val
operator|=
name|iwm_read_prph
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|)
operator|&
name|mask
expr_stmt|;
name|val
operator||=
name|bits
expr_stmt|;
name|iwm_write_prph
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|iwm_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|iwm_set_bits_prph
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|reg
parameter_list|,
name|uint32_t
name|bits
parameter_list|)
block|{
name|iwm_set_bits_mask_prph
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|,
name|bits
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|iwm_clear_bits_prph
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|reg
parameter_list|,
name|uint32_t
name|bits
parameter_list|)
block|{
name|iwm_set_bits_mask_prph
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|,
operator|~
name|bits
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * High-level hardware frobbing routines  */
end_comment

begin_function
name|void
name|iwm_enable_rfkill_int
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|sc_intmask
operator|=
name|IWM_CSR_INT_BIT_RF_KILL
expr_stmt|;
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_INT_MASK
argument_list|,
name|sc
operator|->
name|sc_intmask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|iwm_check_rfkill
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|v
decl_stmt|;
name|int
name|rv
decl_stmt|;
comment|/* 	 * "documentation" is not really helpful here: 	 *  27:	HW_RF_KILL_SW 	 *	Indicates state of (platform's) hardware RF-Kill switch 	 * 	 * But apparently when it's off, it's on ... 	 */
name|v
operator|=
name|IWM_READ
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_GP_CNTRL
argument_list|)
expr_stmt|;
name|rv
operator|=
operator|(
name|v
operator|&
name|IWM_CSR_GP_CNTRL_REG_FLAG_HW_RF_KILL_SW
operator|)
operator|==
literal|0
expr_stmt|;
if|if
condition|(
name|rv
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator||=
name|IWM_FLAG_RFKILL
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|IWM_FLAG_RFKILL
expr_stmt|;
block|}
return|return
name|rv
return|;
block|}
end_function

begin_define
define|#
directive|define
name|IWM_HW_READY_TIMEOUT
value|50
end_define

begin_function
name|int
name|iwm_set_hw_ready
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|ready
decl_stmt|;
name|IWM_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_HW_IF_CONFIG_REG
argument_list|,
name|IWM_CSR_HW_IF_CONFIG_REG_BIT_NIC_READY
argument_list|)
expr_stmt|;
name|ready
operator|=
name|iwm_poll_bit
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_HW_IF_CONFIG_REG
argument_list|,
name|IWM_CSR_HW_IF_CONFIG_REG_BIT_NIC_READY
argument_list|,
name|IWM_CSR_HW_IF_CONFIG_REG_BIT_NIC_READY
argument_list|,
name|IWM_HW_READY_TIMEOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ready
condition|)
block|{
name|IWM_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_MBOX_SET_REG
argument_list|,
name|IWM_CSR_MBOX_SET_REG_OS_ALIVE
argument_list|)
expr_stmt|;
block|}
return|return
name|ready
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|IWM_HW_READY_TIMEOUT
end_undef

begin_function
name|int
name|iwm_prepare_card_hw
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|rv
init|=
literal|0
decl_stmt|;
name|int
name|t
init|=
literal|0
decl_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_RESET
argument_list|,
literal|"->%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|iwm_set_hw_ready
argument_list|(
name|sc
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* If HW is not ready, prepare the conditions to check again */
name|IWM_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_HW_IF_CONFIG_REG
argument_list|,
name|IWM_CSR_HW_IF_CONFIG_REG_PREPARE
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|iwm_set_hw_ready
argument_list|(
name|sc
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|t
operator|+=
literal|200
expr_stmt|;
block|}
do|while
condition|(
name|t
operator|<
literal|150000
condition|)
do|;
name|rv
operator|=
name|ETIMEDOUT
expr_stmt|;
name|out
label|:
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_RESET
argument_list|,
literal|"<-%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_function
name|void
name|iwm_apm_config
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint16_t
name|reg
decl_stmt|;
name|reg
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|PCIER_LINK_CTL
argument_list|,
sizeof|sizeof
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|PCIEM_LINK_CTL_ASPMC_L1
condition|)
block|{
comment|/* Um the Linux driver prints "Disabling L0S for this one ... */
name|IWM_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_GIO_REG
argument_list|,
name|IWM_CSR_GIO_REG_VAL_L0S_ENABLED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* ... and "Enabling" here */
name|IWM_CLRBITS
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_GIO_REG
argument_list|,
name|IWM_CSR_GIO_REG_VAL_L0S_ENABLED
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Start up NIC's basic functionality after it has been reset  * (e.g. after platform boot, or shutdown via iwm_pcie_apm_stop())  * NOTE:  This does not load uCode nor start the embedded processor  */
end_comment

begin_function
name|int
name|iwm_apm_init
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_RESET
argument_list|,
literal|"iwm apm start\n"
argument_list|)
expr_stmt|;
comment|/* Disable L0S exit timer (platform NMI Work/Around) */
if|if
condition|(
name|sc
operator|->
name|cfg
operator|->
name|device_family
operator|!=
name|IWM_DEVICE_FAMILY_8000
condition|)
block|{
name|IWM_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_GIO_CHICKEN_BITS
argument_list|,
name|IWM_CSR_GIO_CHICKEN_BITS_REG_BIT_DIS_L0S_EXIT_TIMER
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Disable L0s without affecting L1; 	 *  don't wait for ICH L0s (ICH bug W/A) 	 */
name|IWM_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_GIO_CHICKEN_BITS
argument_list|,
name|IWM_CSR_GIO_CHICKEN_BITS_REG_BIT_L1A_NO_L0S_RX
argument_list|)
expr_stmt|;
comment|/* Set FH wait threshold to maximum (HW error during stress W/A) */
name|IWM_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_DBG_HPET_MEM_REG
argument_list|,
name|IWM_CSR_DBG_HPET_MEM_REG_VAL
argument_list|)
expr_stmt|;
comment|/* 	 * Enable HAP INTA (interrupt from management bus) to 	 * wake device's PCI Express link L1a -> L0s 	 */
name|IWM_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_HW_IF_CONFIG_REG
argument_list|,
name|IWM_CSR_HW_IF_CONFIG_REG_BIT_HAP_WAKE_L1A
argument_list|)
expr_stmt|;
name|iwm_apm_config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* not for 7k/8k */
comment|/* Configure analog phase-lock-loop before activating to D0A */
block|if (trans->cfg->base_params->pll_cfg_val) 		IWM_SETBITS(trans, IWM_CSR_ANA_PLL_CFG, 		    trans->cfg->base_params->pll_cfg_val);
endif|#
directive|endif
comment|/* 	 * Set "initialization complete" bit to move adapter from 	 * D0U* --> D0A* (powered-up active) state. 	 */
name|IWM_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_GP_CNTRL
argument_list|,
name|IWM_CSR_GP_CNTRL_REG_FLAG_INIT_DONE
argument_list|)
expr_stmt|;
comment|/* 	 * Wait for clock stabilization; once stabilized, access to 	 * device-internal resources is supported, e.g. iwm_write_prph() 	 * and accesses to uCode SRAM. 	 */
if|if
condition|(
operator|!
name|iwm_poll_bit
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_GP_CNTRL
argument_list|,
name|IWM_CSR_GP_CNTRL_REG_FLAG_MAC_CLOCK_READY
argument_list|,
name|IWM_CSR_GP_CNTRL_REG_FLAG_MAC_CLOCK_READY
argument_list|,
literal|25000
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"timeout waiting for clock stabilization\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|sc
operator|->
name|cfg
operator|->
name|host_interrupt_operation_mode
condition|)
block|{
comment|/* 		 * This is a bit of an abuse - This is needed for 7260 / 3160 		 * only check host_interrupt_operation_mode even if this is 		 * not related to host_interrupt_operation_mode. 		 * 		 * Enable the oscillator to count wake up time for L1 exit. This 		 * consumes slightly more power (100uA) - but allows to be sure 		 * that we wake up from L1 on time. 		 * 		 * This looks weird: read twice the same register, discard the 		 * value, set a bit, and yet again, read that same register 		 * just to discard the value. But that's the way the hardware 		 * seems to like it. 		 */
if|if
condition|(
name|iwm_nic_lock
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|iwm_read_prph
argument_list|(
name|sc
argument_list|,
name|IWM_OSC_CLK
argument_list|)
expr_stmt|;
name|iwm_read_prph
argument_list|(
name|sc
argument_list|,
name|IWM_OSC_CLK
argument_list|)
expr_stmt|;
block|}
name|iwm_set_bits_prph
argument_list|(
name|sc
argument_list|,
name|IWM_OSC_CLK
argument_list|,
name|IWM_OSC_CLK_FORCE_CONTROL
argument_list|)
expr_stmt|;
if|if
condition|(
name|iwm_nic_lock
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|iwm_read_prph
argument_list|(
name|sc
argument_list|,
name|IWM_OSC_CLK
argument_list|)
expr_stmt|;
name|iwm_read_prph
argument_list|(
name|sc
argument_list|,
name|IWM_OSC_CLK
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Enable DMA clock and wait for it to stabilize. 	 * 	 * Write to "CLK_EN_REG"; "1" bits enable clocks, while "0" bits 	 * do not disable clocks.  This preserves any hardware bits already 	 * set by default in "CLK_CTRL_REG" after reset. 	 */
if|if
condition|(
name|sc
operator|->
name|cfg
operator|->
name|device_family
operator|==
name|IWM_DEVICE_FAMILY_7000
condition|)
block|{
if|if
condition|(
name|iwm_nic_lock
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|iwm_write_prph
argument_list|(
name|sc
argument_list|,
name|IWM_APMG_CLK_EN_REG
argument_list|,
name|IWM_APMG_CLK_VAL_DMA_CLK_RQT
argument_list|)
expr_stmt|;
block|}
name|DELAY
argument_list|(
literal|20
argument_list|)
expr_stmt|;
comment|/* Disable L1-Active */
name|iwm_set_bits_prph
argument_list|(
name|sc
argument_list|,
name|IWM_APMG_PCIDEV_STT_REG
argument_list|,
name|IWM_APMG_PCIDEV_STT_VAL_L1_ACT_DIS
argument_list|)
expr_stmt|;
comment|/* Clear the interrupt in APMG if the NIC is in RFKILL */
if|if
condition|(
name|iwm_nic_lock
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|iwm_write_prph
argument_list|(
name|sc
argument_list|,
name|IWM_APMG_RTC_INT_STT_REG
argument_list|,
name|IWM_APMG_RTC_INT_STT_RFKILL
argument_list|)
expr_stmt|;
block|}
block|}
name|out
label|:
if|if
condition|(
name|error
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"apm init error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* iwlwifi/pcie/trans.c */
end_comment

begin_function
name|void
name|iwm_apm_stop
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* stop device's busmaster DMA activity */
name|IWM_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_RESET
argument_list|,
name|IWM_CSR_RESET_REG_FLAG_STOP_MASTER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iwm_poll_bit
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_RESET
argument_list|,
name|IWM_CSR_RESET_REG_FLAG_MASTER_DISABLED
argument_list|,
name|IWM_CSR_RESET_REG_FLAG_MASTER_DISABLED
argument_list|,
literal|100
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"timeout waiting for master\n"
argument_list|)
expr_stmt|;
name|IWM_DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWM_DEBUG_TRANS
argument_list|,
literal|"%s: iwm apm stop\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* iwlwifi pcie/trans.c */
end_comment

begin_function
name|int
name|iwm_start_hw
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_prepare_card_hw
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
comment|/* Reset the entire device */
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_RESET
argument_list|,
name|IWM_CSR_RESET_REG_FLAG_SW_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|iwm_apm_init
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|iwm_enable_rfkill_int
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iwm_check_rfkill
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* iwlwifi pcie/trans.c (always main power) */
end_comment

begin_function
name|void
name|iwm_set_pwr
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|iwm_set_bits_mask_prph
argument_list|(
name|sc
argument_list|,
name|IWM_APMG_PS_CTRL_REG
argument_list|,
name|IWM_APMG_PS_CTRL_VAL_PWR_SRC_VMAIN
argument_list|,
operator|~
name|IWM_APMG_PS_CTRL_MSK_PWR_SRC
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* iwlwifi pcie/rx.c */
end_comment

begin_function
name|int
name|iwm_pcie_rx_stop
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|iwm_nic_lock
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|IWM_WRITE
argument_list|(
name|sc
argument_list|,
name|IWM_FH_MEM_RCSR_CHNL0_CONFIG_REG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ret
operator|=
name|iwm_poll_bit
argument_list|(
name|sc
argument_list|,
name|IWM_FH_MEM_RSSR_RX_STATUS_REG
argument_list|,
name|IWM_FH_RSSR_CHNL0_RX_STATUS_CHNL_IDLE
argument_list|,
name|IWM_FH_RSSR_CHNL0_RX_STATUS_CHNL_IDLE
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
name|iwm_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|iwm_pcie_clear_cmd_in_flight
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sc
operator|->
name|cfg
operator|->
name|apmg_wake_up_wa
condition|)
return|return;
if|if
condition|(
operator|!
name|sc
operator|->
name|cmd_hold_nic_awake
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: cmd_hold_nic_awake not set\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc
operator|->
name|cmd_hold_nic_awake
operator|=
literal|0
expr_stmt|;
name|IWM_CLRBITS
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_GP_CNTRL
argument_list|,
name|IWM_CSR_GP_CNTRL_REG_FLAG_MAC_ACCESS_REQ
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|iwm_pcie_set_cmd_in_flight
parameter_list|(
name|struct
name|iwm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
comment|/* 	 * wake up the NIC to make sure that the firmware will see the host 	 * command - we will let the NIC sleep once all the host commands 	 * returned. This needs to be done only on NICs that have 	 * apmg_wake_up_wa set. 	 */
if|if
condition|(
name|sc
operator|->
name|cfg
operator|->
name|apmg_wake_up_wa
operator|&&
operator|!
name|sc
operator|->
name|cmd_hold_nic_awake
condition|)
block|{
name|IWM_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_GP_CNTRL
argument_list|,
name|IWM_CSR_GP_CNTRL_REG_FLAG_MAC_ACCESS_REQ
argument_list|)
expr_stmt|;
name|ret
operator|=
name|iwm_poll_bit
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_GP_CNTRL
argument_list|,
name|IWM_CSR_GP_CNTRL_REG_VAL_MAC_ACCESS_EN
argument_list|,
operator|(
name|IWM_CSR_GP_CNTRL_REG_FLAG_MAC_CLOCK_READY
operator||
name|IWM_CSR_GP_CNTRL_REG_FLAG_GOING_TO_SLEEP
operator|)
argument_list|,
literal|15000
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|IWM_CLRBITS
argument_list|(
name|sc
argument_list|,
name|IWM_CSR_GP_CNTRL
argument_list|,
name|IWM_CSR_GP_CNTRL_REG_FLAG_MAC_ACCESS_REQ
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: Failed to wake NIC for hcmd\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
name|sc
operator|->
name|cmd_hold_nic_awake
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

