begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004-2005 HighPoint Technologies, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_if
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|500000
operator|)
end_if

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|500000
operator|)
end_if

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|__KERNEL__
end_ifndef

begin_define
define|#
directive|define
name|__KERNEL__
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/hptmv/global.h>
end_include

begin_include
include|#
directive|include
file|<dev/hptmv/hptintf.h>
end_include

begin_include
include|#
directive|include
file|<dev/hptmv/osbsd.h>
end_include

begin_include
include|#
directive|include
file|<dev/hptmv/access601.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_LEVEL
end_ifdef

begin_decl_stmt
name|int
name|hpt_dbg_level
init|=
name|DEBUG_LEVEL
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|hpt_dbg_level
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MV_ERROR
value|printf
end_define

begin_comment
comment|/*  * CAM SIM entry points  */
end_comment

begin_function_decl
specifier|static
name|int
name|hpt_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|launch_worker_thread
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hpt_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hpt_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hpt_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hpt_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hpt_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hpt_async
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|u_int32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hpt_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|driver_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|hpt_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|hpt_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|hpt_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|hpt_shutdown
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|hpt_pci_driver
init|=
block|{
name|__str
argument_list|(
name|PROC_DIR_NAME
argument_list|)
block|,
name|driver_methods
block|,
expr|sizeof
operator|(
name|IAL_ADAPTER_T
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|hpt_devclass
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|__DRIVER_MODULE
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|,
name|p3
parameter_list|,
name|p4
parameter_list|,
name|p5
parameter_list|,
name|p6
parameter_list|)
value|DRIVER_MODULE(p1, p2, p3, p4, p5, p6)
end_define

begin_expr_stmt
name|__DRIVER_MODULE
argument_list|(
name|PROC_DIR_NAME
argument_list|,
name|pci
argument_list|,
name|hpt_pci_driver
argument_list|,
name|hpt_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|PROC_DIR_NAME
argument_list|,
name|cam
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|ccb_ccb_ptr
value|spriv_ptr0
end_define

begin_define
define|#
directive|define
name|ccb_adapter
value|ccb_h.spriv_ptr1
end_define

begin_function_decl
specifier|static
name|void
name|SetInquiryData
parameter_list|(
name|PINQUIRYDATA
name|inquiryData
parameter_list|,
name|PVDevice
name|pVDev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|HPTLIBAPI
name|OsSendCommand
parameter_list|(
name|_VBUS_ARG
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|HPTLIBAPI
name|fOsCommandDone
parameter_list|(
name|_VBUS_ARG
name|PCommand
name|pCmd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ccb_done
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hpt_queue_ccb
parameter_list|(
name|union
name|ccb
modifier|*
modifier|*
name|ccb_Q
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hpt_free_ccb
parameter_list|(
name|union
name|ccb
modifier|*
modifier|*
name|ccb_Q
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hptmv_free_edma_queues
parameter_list|(
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hptmv_free_channel
parameter_list|(
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
parameter_list|,
name|MV_U8
name|channelNum
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handleEdmaError
parameter_list|(
name|_VBUS_ARG
name|PCommand
name|pCmd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hptmv_init_channel
parameter_list|(
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
parameter_list|,
name|MV_U8
name|channelNum
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fResetActiveCommands
parameter_list|(
name|PVBus
name|_vbus_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fRegisterVdevice
parameter_list|(
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hptmv_allocate_edma_queues
parameter_list|(
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hptmv_handle_event_disconnect
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hptmv_handle_event_connect
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|start_channel
parameter_list|(
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
parameter_list|,
name|MV_U8
name|channelNum
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_vdev_params
parameter_list|(
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
parameter_list|,
name|MV_U8
name|channel
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hptmv_parse_identify_results
parameter_list|(
name|MV_SATA_CHANNEL
modifier|*
name|pMvSataChannel
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|HPTLIBAPI
name|fOsBuildSgl
parameter_list|(
name|_VBUS_ARG
name|PCommand
name|pCmd
parameter_list|,
name|FPSCAT_GATH
name|pSg
parameter_list|,
name|int
name|logical
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|MV_BOOLEAN
name|CommandCompletionCB
parameter_list|(
name|MV_SATA_ADAPTER
modifier|*
name|pMvSataAdapter
parameter_list|,
name|MV_U8
name|channelNum
parameter_list|,
name|MV_COMPLETION_TYPE
name|comp_type
parameter_list|,
name|MV_VOID_PTR
name|commandId
parameter_list|,
name|MV_U16
name|responseFlags
parameter_list|,
name|MV_U32
name|timeStamp
parameter_list|,
name|MV_STORAGE_DEVICE_REGISTERS
modifier|*
name|registerStruct
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|MV_BOOLEAN
name|hptmv_event_notify
parameter_list|(
name|MV_SATA_ADAPTER
modifier|*
name|pMvSataAdapter
parameter_list|,
name|MV_EVENT_TYPE
name|eventType
parameter_list|,
name|MV_U32
name|param1
parameter_list|,
name|MV_U32
name|param2
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|ccb_ccb_ptr
value|spriv_ptr0
end_define

begin_define
define|#
directive|define
name|ccb_adapter
value|ccb_h.spriv_ptr1
end_define

begin_decl_stmt
name|IAL_ADAPTER_T
modifier|*
name|gIal_Adapter
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|IAL_ADAPTER_T
modifier|*
name|pCurAdapter
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|MV_SATA_CHANNEL
name|gMvSataChannels
index|[
name|MAX_VBUS
index|]
index|[
name|MV_SATA_CHANNELS_NUM
index|]
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|st_HPT_DPC
block|{
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
decl_stmt|;
name|void
function_decl|(
modifier|*
name|dpc
function_decl|)
parameter_list|(
name|IAL_ADAPTER_T
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|UCHAR
parameter_list|)
function_decl|;
name|void
modifier|*
name|arg
decl_stmt|;
name|UCHAR
name|flags
decl_stmt|;
block|}
name|ST_HPT_DPC
typedef|;
end_typedef

begin_define
define|#
directive|define
name|MAX_DPC
value|16
end_define

begin_decl_stmt
name|UCHAR
name|DPC_Request_Nums
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ST_HPT_DPC
name|DpcQueue
index|[
name|MAX_DPC
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|DpcQueue_First
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|DpcQueue_Last
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|DRIVER_VERSION
index|[]
init|=
literal|"v1.16"
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|500000
operator|)
end_if

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|driver_lock
decl_stmt|;
end_decl_stmt

begin_function
name|intrmask_t
name|lock_driver
parameter_list|()
block|{
name|intrmask_t
name|spl
init|=
literal|0
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|driver_lock
argument_list|)
expr_stmt|;
return|return
name|spl
return|;
block|}
end_function

begin_function
name|void
name|unlock_driver
parameter_list|(
name|intrmask_t
name|spl
parameter_list|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|driver_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|int
name|driver_locked
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|intrmask_t
name|lock_driver
parameter_list|()
block|{
name|intrmask_t
name|spl
init|=
name|splcam
argument_list|()
decl_stmt|;
name|loop
label|:
while|while
condition|(
name|driver_locked
condition|)
name|tsleep
argument_list|(
operator|&
name|driver_locked
argument_list|,
name|PRIBIO
argument_list|,
literal|"hptlck"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|driver_locked
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|driver_locked
operator|>
literal|1
condition|)
block|{
name|atomic_subtract_int
argument_list|(
operator|&
name|driver_locked
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
return|return
name|spl
return|;
block|}
end_function

begin_function
name|void
name|unlock_driver
parameter_list|(
name|intrmask_t
name|spl
parameter_list|)
block|{
name|atomic_subtract_int
argument_list|(
operator|&
name|driver_locked
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|driver_locked
operator|==
literal|0
condition|)
block|{
name|wakeup
argument_list|(
operator|&
name|driver_locked
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|spl
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*******************************************************************************  *	Name:	hptmv_free_channel  *  *	Description:	free allocated queues for the given channel  *  *	Parameters:    	pMvSataAdapter - pointer to the RR18xx controler this   * 					channel connected to.   *			channelNum - channel number.   *       ******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|hptmv_free_channel
parameter_list|(
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
parameter_list|,
name|MV_U8
name|channelNum
parameter_list|)
block|{
name|HPT_ASSERT
argument_list|(
name|channelNum
operator|<
name|MV_SATA_CHANNELS_NUM
argument_list|)
expr_stmt|;
name|pAdapter
operator|->
name|mvSataAdapter
operator|.
name|sataChannel
index|[
name|channelNum
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|failDevice
parameter_list|(
name|PVDevice
name|pVDev
parameter_list|)
block|{
name|PVBus
name|_vbus_p
init|=
name|pVDev
operator|->
name|pVBus
decl_stmt|;
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
init|=
operator|(
name|IAL_ADAPTER_T
operator|*
operator|)
name|_vbus_p
operator|->
name|OsExt
decl_stmt|;
name|pVDev
operator|->
name|u
operator|.
name|disk
operator|.
name|df_on_line
operator|=
literal|0
expr_stmt|;
name|pVDev
operator|->
name|vf_online
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pVDev
operator|->
name|pfnDeviceFailed
condition|)
name|CallWhenIdle
argument_list|(
name|_VBUS_P
argument_list|(
argument|DPC_PROC
argument_list|)
name|pVDev
operator|->
name|pfnDeviceFailed
argument_list|,
name|pVDev
argument_list|)
expr_stmt|;
name|fNotifyGUI
argument_list|(
name|ET_DEVICE_REMOVED
argument_list|,
name|pVDev
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|FOR_DEMO
if|if
condition|(
name|pAdapter
operator|->
name|ver_601
operator|==
literal|2
operator|&&
operator|!
name|pAdapter
operator|->
name|beeping
condition|)
block|{
name|pAdapter
operator|->
name|beeping
operator|=
literal|1
expr_stmt|;
name|BeepOn
argument_list|(
name|pAdapter
operator|->
name|mvSataAdapter
operator|.
name|adapterIoBaseAddress
argument_list|)
expr_stmt|;
name|set_fail_led
argument_list|(
operator|&
name|pAdapter
operator|->
name|mvSataAdapter
argument_list|,
name|pVDev
operator|->
name|u
operator|.
name|disk
operator|.
name|mv
operator|->
name|channelNumber
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function_decl
name|int
name|MvSataResetChannel
parameter_list|(
name|MV_SATA_ADAPTER
modifier|*
name|pMvSataAdapter
parameter_list|,
name|MV_U8
name|channel
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|handleEdmaError
parameter_list|(
name|_VBUS_ARG
name|PCommand
name|pCmd
parameter_list|)
block|{
name|PDevice
name|pDevice
init|=
operator|&
name|pCmd
operator|->
name|pVDevice
operator|->
name|u
operator|.
name|disk
decl_stmt|;
name|MV_SATA_ADAPTER
modifier|*
name|pSataAdapter
init|=
name|pDevice
operator|->
name|mv
operator|->
name|mvSataAdapter
decl_stmt|;
if|if
condition|(
operator|!
name|pDevice
operator|->
name|df_on_line
condition|)
block|{
name|KdPrint
argument_list|(
operator|(
literal|"Device is offline"
operator|)
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Result
operator|=
name|RETURN_BAD_DEVICE
expr_stmt|;
name|CallAfterReturn
argument_list|(
name|_VBUS_P
argument_list|(
argument|DPC_PROC
argument_list|)
name|pCmd
operator|->
name|pfnCompletion
argument_list|,
name|pCmd
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pCmd
operator|->
name|RetryCount
operator|++
operator|>
literal|5
condition|)
block|{
name|hpt_printk
argument_list|(
operator|(
literal|"too many retries on channel(%d)\n"
operator|,
name|pDevice
operator|->
name|mv
operator|->
name|channelNumber
operator|)
argument_list|)
expr_stmt|;
name|failed
label|:
name|failDevice
argument_list|(
name|pCmd
operator|->
name|pVDevice
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Result
operator|=
name|RETURN_IDE_ERROR
expr_stmt|;
name|CallAfterReturn
argument_list|(
name|_VBUS_P
argument_list|(
argument|DPC_PROC
argument_list|)
name|pCmd
operator|->
name|pfnCompletion
argument_list|,
name|pCmd
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* reset the channel and retry the command */
if|if
condition|(
name|MvSataResetChannel
argument_list|(
name|pSataAdapter
argument_list|,
name|pDevice
operator|->
name|mv
operator|->
name|channelNumber
argument_list|)
condition|)
goto|goto
name|failed
goto|;
name|fNotifyGUI
argument_list|(
name|ET_DEVICE_ERROR
argument_list|,
name|Map2pVDevice
argument_list|(
name|pDevice
argument_list|)
argument_list|)
expr_stmt|;
name|hpt_printk
argument_list|(
operator|(
literal|"Retry on channel(%d)\n"
operator|,
name|pDevice
operator|->
name|mv
operator|->
name|channelNumber
operator|)
argument_list|)
expr_stmt|;
name|fDeviceSendCommand
argument_list|(
argument|_VBUS_P pCmd
argument_list|)
empty_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************  *	Name:	hptmv_init_channel  *  *	Description:	allocate request and response queues for the EDMA of the   *					given channel and sets other fields.  *  *	Parameters:    	  *		pAdapter - pointer to the emulated adapter data structure  *		channelNum - channel number.   *	Return:	0 on success, otherwise on failure  ****************************************************************/
end_comment

begin_function
specifier|static
name|int
name|hptmv_init_channel
parameter_list|(
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
parameter_list|,
name|MV_U8
name|channelNum
parameter_list|)
block|{
name|MV_SATA_CHANNEL
modifier|*
name|pMvSataChannel
decl_stmt|;
name|dma_addr_t
name|req_dma_addr
decl_stmt|;
name|dma_addr_t
name|rsp_dma_addr
decl_stmt|;
if|if
condition|(
name|channelNum
operator|>=
name|MV_SATA_CHANNELS_NUM
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR18xx[%d]: Bad channelNum=%d"
argument_list|,
name|pAdapter
operator|->
name|mvSataAdapter
operator|.
name|adapterId
argument_list|,
name|channelNum
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|pMvSataChannel
operator|=
operator|&
name|gMvSataChannels
index|[
name|pAdapter
operator|->
name|mvSataAdapter
operator|.
name|adapterId
index|]
index|[
name|channelNum
index|]
expr_stmt|;
name|pAdapter
operator|->
name|mvSataAdapter
operator|.
name|sataChannel
index|[
name|channelNum
index|]
operator|=
name|pMvSataChannel
expr_stmt|;
name|pMvSataChannel
operator|->
name|channelNumber
operator|=
name|channelNum
expr_stmt|;
name|pMvSataChannel
operator|->
name|lba48Address
operator|=
name|MV_FALSE
expr_stmt|;
name|pMvSataChannel
operator|->
name|maxReadTransfer
operator|=
name|MV_FALSE
expr_stmt|;
name|pMvSataChannel
operator|->
name|requestQueue
operator|=
operator|(
expr|struct
name|mvDmaRequestQueueEntry
operator|*
operator|)
operator|(
name|pAdapter
operator|->
name|requestsArrayBaseAlignedAddr
operator|+
operator|(
name|channelNum
operator|*
name|MV_EDMA_REQUEST_QUEUE_SIZE
operator|)
operator|)
expr_stmt|;
name|req_dma_addr
operator|=
name|pAdapter
operator|->
name|requestsArrayBaseDmaAlignedAddr
operator|+
operator|(
name|channelNum
operator|*
name|MV_EDMA_REQUEST_QUEUE_SIZE
operator|)
expr_stmt|;
name|KdPrint
argument_list|(
operator|(
literal|"requestQueue addr is 0x%llX"
operator|,
operator|(
name|HPT_U64
operator|)
operator|(
name|ULONG_PTR
operator|)
name|req_dma_addr
operator|)
argument_list|)
expr_stmt|;
comment|/* check the 1K alignment of the request queue*/
if|if
condition|(
name|req_dma_addr
operator|&
literal|0x3ff
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR18xx[%d]: request queue allocated isn't 1 K aligned,"
literal|" dma_addr=%llx channel=%d\n"
argument_list|,
name|pAdapter
operator|->
name|mvSataAdapter
operator|.
name|adapterId
argument_list|,
operator|(
name|HPT_U64
operator|)
operator|(
name|ULONG_PTR
operator|)
name|req_dma_addr
argument_list|,
name|channelNum
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|pMvSataChannel
operator|->
name|requestQueuePciLowAddress
operator|=
name|req_dma_addr
expr_stmt|;
name|pMvSataChannel
operator|->
name|requestQueuePciHiAddress
operator|=
literal|0
expr_stmt|;
name|KdPrint
argument_list|(
operator|(
literal|"RR18xx[%d,%d]: request queue allocated: 0x%p"
operator|,
name|pAdapter
operator|->
name|mvSataAdapter
operator|.
name|adapterId
operator|,
name|channelNum
operator|,
name|pMvSataChannel
operator|->
name|requestQueue
operator|)
argument_list|)
expr_stmt|;
name|pMvSataChannel
operator|->
name|responseQueue
operator|=
operator|(
expr|struct
name|mvDmaResponseQueueEntry
operator|*
operator|)
operator|(
name|pAdapter
operator|->
name|responsesArrayBaseAlignedAddr
operator|+
operator|(
name|channelNum
operator|*
name|MV_EDMA_RESPONSE_QUEUE_SIZE
operator|)
operator|)
expr_stmt|;
name|rsp_dma_addr
operator|=
name|pAdapter
operator|->
name|responsesArrayBaseDmaAlignedAddr
operator|+
operator|(
name|channelNum
operator|*
name|MV_EDMA_RESPONSE_QUEUE_SIZE
operator|)
expr_stmt|;
comment|/* check the 256 alignment of the response queue*/
if|if
condition|(
name|rsp_dma_addr
operator|&
literal|0xff
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR18xx[%d,%d]: response queue allocated isn't 256 byte "
literal|"aligned, dma_addr=%llx\n"
argument_list|,
name|pAdapter
operator|->
name|mvSataAdapter
operator|.
name|adapterId
argument_list|,
name|channelNum
argument_list|,
operator|(
name|HPT_U64
operator|)
operator|(
name|ULONG_PTR
operator|)
name|rsp_dma_addr
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|pMvSataChannel
operator|->
name|responseQueuePciLowAddress
operator|=
name|rsp_dma_addr
expr_stmt|;
name|pMvSataChannel
operator|->
name|responseQueuePciHiAddress
operator|=
literal|0
expr_stmt|;
name|KdPrint
argument_list|(
operator|(
literal|"RR18xx[%d,%d]: response queue allocated: 0x%p"
operator|,
name|pAdapter
operator|->
name|mvSataAdapter
operator|.
name|adapterId
operator|,
name|channelNum
operator|,
name|pMvSataChannel
operator|->
name|responseQueue
operator|)
argument_list|)
expr_stmt|;
name|pAdapter
operator|->
name|mvChannel
index|[
name|channelNum
index|]
operator|.
name|online
operator|=
name|MV_TRUE
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  *	Name: hptmv_parse_identify_results  *  *	Description:	this functions parses the identify command results, checks  *					that the connected deives can be accesed by RR18xx EDMA,  *					and updates the channel stucture accordingly.  *  *	Parameters:     pMvSataChannel, pointer to the channel data structure.  *  *	Returns:       	=0 ->success,< 0 ->failure.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|hptmv_parse_identify_results
parameter_list|(
name|MV_SATA_CHANNEL
modifier|*
name|pMvSataChannel
parameter_list|)
block|{
name|MV_U16
modifier|*
name|iden
init|=
name|pMvSataChannel
operator|->
name|identifyDevice
decl_stmt|;
comment|/*LBA addressing*/
if|if
condition|(
operator|!
operator|(
name|iden
index|[
name|IDEN_CAPACITY_1_OFFSET
index|]
operator|&
literal|0x200
operator|)
condition|)
block|{
name|KdPrint
argument_list|(
operator|(
literal|"IAL Error in IDENTIFY info: LBA not supported\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|KdPrint
argument_list|(
operator|(
literal|"%25s - %s\n"
operator|,
literal|"Capabilities"
operator|,
literal|"LBA supported"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/*DMA support*/
if|if
condition|(
operator|!
operator|(
name|iden
index|[
name|IDEN_CAPACITY_1_OFFSET
index|]
operator|&
literal|0x100
operator|)
condition|)
block|{
name|KdPrint
argument_list|(
operator|(
literal|"IAL Error in IDENTIFY info: DMA not supported\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|KdPrint
argument_list|(
operator|(
literal|"%25s - %s\n"
operator|,
literal|"Capabilities"
operator|,
literal|"DMA supported"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* PIO */
if|if
condition|(
operator|(
name|iden
index|[
name|IDEN_VALID
index|]
operator|&
literal|2
operator|)
operator|==
literal|0
condition|)
block|{
name|KdPrint
argument_list|(
operator|(
literal|"IAL Error in IDENTIFY info: not able to find PIO mode\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|KdPrint
argument_list|(
operator|(
literal|"%25s - 0x%02x\n"
operator|,
literal|"PIO modes supported"
operator|,
name|iden
index|[
name|IDEN_PIO_MODE_SPPORTED
index|]
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
comment|/*UDMA*/
if|if
condition|(
operator|(
name|iden
index|[
name|IDEN_VALID
index|]
operator|&
literal|4
operator|)
operator|==
literal|0
condition|)
block|{
name|KdPrint
argument_list|(
operator|(
literal|"IAL Error in IDENTIFY info: not able to find UDMA mode\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* 48 bit address */
if|if
condition|(
operator|(
name|iden
index|[
name|IDEN_SUPPORTED_COMMANDS2
index|]
operator|&
literal|0x400
operator|)
condition|)
block|{
name|KdPrint
argument_list|(
operator|(
literal|"%25s - %s\n"
operator|,
literal|"LBA48 addressing"
operator|,
literal|"supported"
operator|)
argument_list|)
expr_stmt|;
name|pMvSataChannel
operator|->
name|lba48Address
operator|=
name|MV_TRUE
expr_stmt|;
block|}
else|else
block|{
name|KdPrint
argument_list|(
operator|(
literal|"%25s - %s\n"
operator|,
literal|"LBA48 addressing"
operator|,
literal|"Not supported"
operator|)
argument_list|)
expr_stmt|;
name|pMvSataChannel
operator|->
name|lba48Address
operator|=
name|MV_FALSE
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_vdev_params
parameter_list|(
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
parameter_list|,
name|MV_U8
name|channel
parameter_list|)
block|{
name|PVDevice
name|pVDev
init|=
operator|&
name|pAdapter
operator|->
name|VDevices
index|[
name|channel
index|]
decl_stmt|;
name|MV_SATA_CHANNEL
modifier|*
name|pMvSataChannel
init|=
name|pAdapter
operator|->
name|mvSataAdapter
operator|.
name|sataChannel
index|[
name|channel
index|]
decl_stmt|;
name|MV_U16_PTR
name|IdentifyData
init|=
name|pMvSataChannel
operator|->
name|identifyDevice
decl_stmt|;
name|pMvSataChannel
operator|->
name|outstandingCommands
operator|=
literal|0
expr_stmt|;
name|pVDev
operator|->
name|u
operator|.
name|disk
operator|.
name|mv
operator|=
name|pMvSataChannel
expr_stmt|;
name|pVDev
operator|->
name|u
operator|.
name|disk
operator|.
name|df_on_line
operator|=
literal|1
expr_stmt|;
name|pVDev
operator|->
name|u
operator|.
name|disk
operator|.
name|pVBus
operator|=
operator|&
name|pAdapter
operator|->
name|VBus
expr_stmt|;
name|pVDev
operator|->
name|pVBus
operator|=
operator|&
name|pAdapter
operator|->
name|VBus
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_48BIT_LBA
if|if
condition|(
name|pMvSataChannel
operator|->
name|lba48Address
operator|==
name|MV_TRUE
condition|)
name|pVDev
operator|->
name|u
operator|.
name|disk
operator|.
name|dDeRealCapacity
operator|=
operator|(
operator|(
name|IdentifyData
index|[
literal|101
index|]
operator|<<
literal|16
operator|)
operator||
name|IdentifyData
index|[
literal|100
index|]
operator|)
operator|-
literal|1
expr_stmt|;
elseif|else
endif|#
directive|endif
if|if
condition|(
name|IdentifyData
index|[
literal|53
index|]
operator|&
literal|1
condition|)
block|{
name|pVDev
operator|->
name|u
operator|.
name|disk
operator|.
name|dDeRealCapacity
operator|=
operator|(
operator|(
operator|(
name|IdentifyData
index|[
literal|58
index|]
operator|<<
literal|16
operator||
name|IdentifyData
index|[
literal|57
index|]
operator|)
operator|<
operator|(
name|IdentifyData
index|[
literal|61
index|]
operator|<<
literal|16
operator||
name|IdentifyData
index|[
literal|60
index|]
operator|)
operator|)
condition|?
operator|(
name|IdentifyData
index|[
literal|61
index|]
operator|<<
literal|16
operator||
name|IdentifyData
index|[
literal|60
index|]
operator|)
else|:
operator|(
name|IdentifyData
index|[
literal|58
index|]
operator|<<
literal|16
operator||
name|IdentifyData
index|[
literal|57
index|]
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|pVDev
operator|->
name|u
operator|.
name|disk
operator|.
name|dDeRealCapacity
operator|=
operator|(
name|IdentifyData
index|[
literal|61
index|]
operator|<<
literal|16
operator||
name|IdentifyData
index|[
literal|60
index|]
operator|)
operator|-
literal|1
expr_stmt|;
name|pVDev
operator|->
name|u
operator|.
name|disk
operator|.
name|bDeUsable_Mode
operator|=
name|pVDev
operator|->
name|u
operator|.
name|disk
operator|.
name|bDeModeSetting
operator|=
name|pAdapter
operator|->
name|mvChannel
index|[
name|channel
index|]
operator|.
name|maxPioModeSupported
operator|-
name|MV_ATA_TRANSFER_PIO_0
expr_stmt|;
if|if
condition|(
name|pAdapter
operator|->
name|mvChannel
index|[
name|channel
index|]
operator|.
name|maxUltraDmaModeSupported
operator|!=
literal|0xFF
condition|)
block|{
name|pVDev
operator|->
name|u
operator|.
name|disk
operator|.
name|bDeUsable_Mode
operator|=
name|pVDev
operator|->
name|u
operator|.
name|disk
operator|.
name|bDeModeSetting
operator|=
name|pAdapter
operator|->
name|mvChannel
index|[
name|channel
index|]
operator|.
name|maxUltraDmaModeSupported
operator|-
name|MV_ATA_TRANSFER_UDMA_0
operator|+
literal|8
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|device_change
parameter_list|(
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
parameter_list|,
name|MV_U8
name|channelIndex
parameter_list|,
name|int
name|plugged
parameter_list|)
block|{
name|PVDevice
name|pVDev
decl_stmt|;
name|MV_SATA_ADAPTER
modifier|*
name|pMvSataAdapter
init|=
operator|&
name|pAdapter
operator|->
name|mvSataAdapter
decl_stmt|;
name|MV_SATA_CHANNEL
modifier|*
name|pMvSataChannel
init|=
name|pMvSataAdapter
operator|->
name|sataChannel
index|[
name|channelIndex
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|pMvSataChannel
condition|)
return|return;
if|if
condition|(
name|plugged
condition|)
block|{
name|pVDev
operator|=
operator|&
operator|(
name|pAdapter
operator|->
name|VDevices
index|[
name|channelIndex
index|]
operator|)
expr_stmt|;
name|init_vdev_params
argument_list|(
name|pAdapter
argument_list|,
name|channelIndex
argument_list|)
expr_stmt|;
name|pVDev
operator|->
name|VDeviceType
operator|=
name|pVDev
operator|->
name|u
operator|.
name|disk
operator|.
name|df_atapi
condition|?
name|VD_ATAPI
else|:
name|pVDev
operator|->
name|u
operator|.
name|disk
operator|.
name|df_removable_drive
condition|?
name|VD_REMOVABLE
else|:
name|VD_SINGLE_DISK
expr_stmt|;
name|pVDev
operator|->
name|VDeviceCapacity
operator|=
name|pVDev
operator|->
name|u
operator|.
name|disk
operator|.
name|dDeRealCapacity
operator|-
name|SAVE_FOR_RAID_INFO
expr_stmt|;
name|pVDev
operator|->
name|pfnSendCommand
operator|=
name|pfnSendCommand
index|[
name|pVDev
operator|->
name|VDeviceType
index|]
expr_stmt|;
name|pVDev
operator|->
name|pfnDeviceFailed
operator|=
name|pfnDeviceFailed
index|[
name|pVDev
operator|->
name|VDeviceType
index|]
expr_stmt|;
name|pVDev
operator|->
name|vf_online
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_ARRAY
if|if
condition|(
name|pVDev
operator|->
name|pParent
condition|)
block|{
name|int
name|iMember
decl_stmt|;
for|for
control|(
name|iMember
operator|=
literal|0
init|;
name|iMember
operator|<
name|pVDev
operator|->
name|pParent
operator|->
name|u
operator|.
name|array
operator|.
name|bArnMember
condition|;
name|iMember
operator|++
control|)
if|if
condition|(
operator|(
name|PVDevice
operator|)
name|pVDev
operator|->
name|pParent
operator|->
name|u
operator|.
name|array
operator|.
name|pMember
index|[
name|iMember
index|]
operator|==
name|pVDev
condition|)
name|pVDev
operator|->
name|pParent
operator|->
name|u
operator|.
name|array
operator|.
name|pMember
index|[
name|iMember
index|]
operator|=
name|NULL
expr_stmt|;
name|pVDev
operator|->
name|pParent
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
name|fNotifyGUI
argument_list|(
name|ET_DEVICE_PLUGGED
argument_list|,
name|pVDev
argument_list|)
expr_stmt|;
name|fCheckBootable
argument_list|(
name|pVDev
argument_list|)
expr_stmt|;
name|RegisterVDevice
argument_list|(
name|pVDev
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|FOR_DEMO
if|if
condition|(
name|pAdapter
operator|->
name|beeping
condition|)
block|{
name|pAdapter
operator|->
name|beeping
operator|=
literal|0
expr_stmt|;
name|BeepOff
argument_list|(
name|pAdapter
operator|->
name|mvSataAdapter
operator|.
name|adapterIoBaseAddress
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
name|pVDev
operator|=
operator|&
operator|(
name|pAdapter
operator|->
name|VDevices
index|[
name|channelIndex
index|]
operator|)
expr_stmt|;
name|failDevice
argument_list|(
name|pVDev
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|start_channel
parameter_list|(
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
parameter_list|,
name|MV_U8
name|channelNum
parameter_list|)
block|{
name|MV_SATA_ADAPTER
modifier|*
name|pMvSataAdapter
init|=
operator|&
name|pAdapter
operator|->
name|mvSataAdapter
decl_stmt|;
name|MV_SATA_CHANNEL
modifier|*
name|pMvSataChannel
init|=
name|pMvSataAdapter
operator|->
name|sataChannel
index|[
name|channelNum
index|]
decl_stmt|;
name|MV_CHANNEL
modifier|*
name|pChannelInfo
init|=
operator|&
operator|(
name|pAdapter
operator|->
name|mvChannel
index|[
name|channelNum
index|]
operator|)
decl_stmt|;
name|MV_U32
name|udmaMode
decl_stmt|,
name|pioMode
decl_stmt|;
name|KdPrint
argument_list|(
operator|(
literal|"RR18xx [%d]: start channel (%d)"
operator|,
name|pMvSataAdapter
operator|->
name|adapterId
operator|,
name|channelNum
operator|)
argument_list|)
expr_stmt|;
comment|/* Software reset channel */
if|if
condition|(
name|mvStorageDevATASoftResetDevice
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channelNum
argument_list|)
operator|==
name|MV_FALSE
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR18xx [%d,%d]: failed to perform Software reset\n"
argument_list|,
name|pMvSataAdapter
operator|->
name|adapterId
argument_list|,
name|channelNum
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Hardware reset channel */
if|if
condition|(
name|mvSataChannelHardReset
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channelNum
argument_list|)
operator|==
name|MV_FALSE
condition|)
block|{
comment|/* If failed, try again - this is when trying to hardreset a channel */
comment|/* when drive is just spinning up */
name|StallExec
argument_list|(
literal|5000000
argument_list|)
expr_stmt|;
comment|/* wait 5 sec before trying again */
if|if
condition|(
name|mvSataChannelHardReset
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channelNum
argument_list|)
operator|==
name|MV_FALSE
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR18xx [%d,%d]: failed to perform Hard reset\n"
argument_list|,
name|pMvSataAdapter
operator|->
name|adapterId
argument_list|,
name|channelNum
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* identify device*/
if|if
condition|(
name|mvStorageDevATAIdentifyDevice
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channelNum
argument_list|)
operator|==
name|MV_FALSE
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR18xx [%d,%d]: failed to perform ATA Identify command\n"
argument_list|,
name|pMvSataAdapter
operator|->
name|adapterId
argument_list|,
name|channelNum
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|hptmv_parse_identify_results
argument_list|(
name|pMvSataChannel
argument_list|)
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR18xx [%d,%d]: Error in parsing ATA Identify message\n"
argument_list|,
name|pMvSataAdapter
operator|->
name|adapterId
argument_list|,
name|channelNum
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* mvStorageDevATASetFeatures */
comment|/* Disable 8 bit PIO in case CFA enabled */
if|if
condition|(
name|pMvSataChannel
operator|->
name|identifyDevice
index|[
literal|86
index|]
operator|&
literal|4
condition|)
block|{
name|KdPrint
argument_list|(
operator|(
literal|"RR18xx [%d]: Disable 8 bit PIO (CFA enabled) \n"
operator|,
name|pMvSataAdapter
operator|->
name|adapterId
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mvStorageDevATASetFeatures
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channelNum
argument_list|,
name|MV_ATA_SET_FEATURES_DISABLE_8_BIT_PIO
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
name|MV_FALSE
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR18xx [%d]: channel %d: mvStorageDevATASetFeatures"
literal|" failed\n"
argument_list|,
name|pMvSataAdapter
operator|->
name|adapterId
argument_list|,
name|channelNum
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* Write cache */
ifdef|#
directive|ifdef
name|ENABLE_WRITE_CACHE
if|if
condition|(
name|pMvSataChannel
operator|->
name|identifyDevice
index|[
literal|82
index|]
operator|&
literal|0x20
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|pMvSataChannel
operator|->
name|identifyDevice
index|[
literal|85
index|]
operator|&
literal|0x20
operator|)
condition|)
comment|/* if not enabled by default */
block|{
if|if
condition|(
name|mvStorageDevATASetFeatures
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channelNum
argument_list|,
name|MV_ATA_SET_FEATURES_ENABLE_WCACHE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
name|MV_FALSE
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR18xx [%d]: channel %d: mvStorageDevATASetFeatures failed\n"
argument_list|,
name|pMvSataAdapter
operator|->
name|adapterId
argument_list|,
name|channelNum
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|KdPrint
argument_list|(
operator|(
literal|"RR18xx [%d]: channel %d, write cache enabled\n"
operator|,
name|pMvSataAdapter
operator|->
name|adapterId
operator|,
name|channelNum
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|KdPrint
argument_list|(
operator|(
literal|"RR18xx [%d]: channel %d, write cache not supported\n"
operator|,
name|pMvSataAdapter
operator|->
name|adapterId
operator|,
name|channelNum
operator|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* disable write cache */
block|{
if|if
condition|(
name|pMvSataChannel
operator|->
name|identifyDevice
index|[
literal|85
index|]
operator|&
literal|0x20
condition|)
block|{
name|KdPrint
argument_list|(
operator|(
literal|"RR18xx [%d]: channel =%d, disable write cache\n"
operator|,
name|pMvSataAdapter
operator|->
name|adapterId
operator|,
name|channelNum
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mvStorageDevATASetFeatures
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channelNum
argument_list|,
name|MV_ATA_SET_FEATURES_DISABLE_WCACHE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
name|MV_FALSE
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR18xx [%d]: channel %d: mvStorageDevATASetFeatures failed\n"
argument_list|,
name|pMvSataAdapter
operator|->
name|adapterId
argument_list|,
name|channelNum
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|KdPrint
argument_list|(
operator|(
literal|"RR18xx [%d]: channel=%d, write cache disabled\n"
operator|,
name|pMvSataAdapter
operator|->
name|adapterId
operator|,
name|channelNum
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Set transfer mode */
name|KdPrint
argument_list|(
operator|(
literal|"RR18xx [%d] Set transfer mode XFER_PIO_SLOW\n"
operator|,
name|pMvSataAdapter
operator|->
name|adapterId
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mvStorageDevATASetFeatures
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channelNum
argument_list|,
name|MV_ATA_SET_FEATURES_TRANSFER
argument_list|,
name|MV_ATA_TRANSFER_PIO_SLOW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
name|MV_FALSE
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR18xx [%d] channel %d: Set Features failed\n"
argument_list|,
name|pMvSataAdapter
operator|->
name|adapterId
argument_list|,
name|channelNum
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|pMvSataChannel
operator|->
name|identifyDevice
index|[
name|IDEN_PIO_MODE_SPPORTED
index|]
operator|&
literal|1
condition|)
block|{
name|pioMode
operator|=
name|MV_ATA_TRANSFER_PIO_4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pMvSataChannel
operator|->
name|identifyDevice
index|[
name|IDEN_PIO_MODE_SPPORTED
index|]
operator|&
literal|2
condition|)
block|{
name|pioMode
operator|=
name|MV_ATA_TRANSFER_PIO_3
expr_stmt|;
block|}
else|else
block|{
name|MV_ERROR
argument_list|(
literal|"IAL Error in IDENTIFY info: PIO modes 3 and 4 not supported\n"
argument_list|)
expr_stmt|;
name|pioMode
operator|=
name|MV_ATA_TRANSFER_PIO_SLOW
expr_stmt|;
block|}
name|KdPrint
argument_list|(
operator|(
literal|"RR18xx [%d] Set transfer mode XFER_PIO_4\n"
operator|,
name|pMvSataAdapter
operator|->
name|adapterId
operator|)
argument_list|)
expr_stmt|;
name|pAdapter
operator|->
name|mvChannel
index|[
name|channelNum
index|]
operator|.
name|maxPioModeSupported
operator|=
name|pioMode
expr_stmt|;
if|if
condition|(
name|mvStorageDevATASetFeatures
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channelNum
argument_list|,
name|MV_ATA_SET_FEATURES_TRANSFER
argument_list|,
name|pioMode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
name|MV_FALSE
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR18xx [%d] channel %d: Set Features failed\n"
argument_list|,
name|pMvSataAdapter
operator|->
name|adapterId
argument_list|,
name|channelNum
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|udmaMode
operator|=
name|MV_ATA_TRANSFER_UDMA_0
expr_stmt|;
if|if
condition|(
name|pMvSataChannel
operator|->
name|identifyDevice
index|[
name|IDEN_UDMA_MODE
index|]
operator|&
literal|0x40
condition|)
block|{
name|udmaMode
operator|=
name|MV_ATA_TRANSFER_UDMA_6
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pMvSataChannel
operator|->
name|identifyDevice
index|[
name|IDEN_UDMA_MODE
index|]
operator|&
literal|0x20
condition|)
block|{
name|udmaMode
operator|=
name|MV_ATA_TRANSFER_UDMA_5
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pMvSataChannel
operator|->
name|identifyDevice
index|[
name|IDEN_UDMA_MODE
index|]
operator|&
literal|0x10
condition|)
block|{
name|udmaMode
operator|=
name|MV_ATA_TRANSFER_UDMA_4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pMvSataChannel
operator|->
name|identifyDevice
index|[
name|IDEN_UDMA_MODE
index|]
operator|&
literal|8
condition|)
block|{
name|udmaMode
operator|=
name|MV_ATA_TRANSFER_UDMA_3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pMvSataChannel
operator|->
name|identifyDevice
index|[
name|IDEN_UDMA_MODE
index|]
operator|&
literal|4
condition|)
block|{
name|udmaMode
operator|=
name|MV_ATA_TRANSFER_UDMA_2
expr_stmt|;
block|}
name|KdPrint
argument_list|(
operator|(
literal|"RR18xx [%d] Set transfer mode XFER_UDMA_%d\n"
operator|,
name|pMvSataAdapter
operator|->
name|adapterId
operator|,
name|udmaMode
operator|&
literal|0xf
operator|)
argument_list|)
expr_stmt|;
name|pChannelInfo
operator|->
name|maxUltraDmaModeSupported
operator|=
name|udmaMode
expr_stmt|;
comment|/*if (mvStorageDevATASetFeatures(pMvSataAdapter, channelNum, 								   MV_ATA_SET_FEATURES_TRANSFER, udmaMode, 								   0, 0, 0) == MV_FALSE) 	{ 		MV_ERROR("RR18xx [%d] channel %d: Set Features failed\n", 				 pMvSataAdapter->adapterId, channelNum);  		return -1; 	}*/
if|if
condition|(
name|pChannelInfo
operator|->
name|maxUltraDmaModeSupported
operator|==
literal|0xFF
condition|)
return|return
name|TRUE
return|;
else|else
do|do
block|{
if|if
condition|(
name|mvStorageDevATASetFeatures
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channelNum
argument_list|,
name|MV_ATA_SET_FEATURES_TRANSFER
argument_list|,
name|pChannelInfo
operator|->
name|maxUltraDmaModeSupported
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
name|MV_FALSE
condition|)
block|{
if|if
condition|(
name|pChannelInfo
operator|->
name|maxUltraDmaModeSupported
operator|>
name|MV_ATA_TRANSFER_UDMA_0
condition|)
block|{
if|if
condition|(
name|mvStorageDevATASoftResetDevice
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channelNum
argument_list|)
operator|==
name|MV_FALSE
condition|)
block|{
name|MV_REG_WRITE_BYTE
argument_list|(
name|pMvSataAdapter
operator|->
name|adapterIoBaseAddress
argument_list|,
name|pMvSataChannel
operator|->
name|eDmaRegsOffset
operator|+
literal|0x11c
argument_list|,
comment|/* command reg */
name|MV_ATA_COMMAND_IDLE_IMMEDIATE
argument_list|)
expr_stmt|;
name|mvMicroSecondsDelay
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|mvSataChannelHardReset
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channelNum
argument_list|)
expr_stmt|;
if|if
condition|(
name|mvStorageDevATASoftResetDevice
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channelNum
argument_list|)
operator|==
name|MV_FALSE
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|mvSataChannelHardReset
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channelNum
argument_list|)
operator|==
name|MV_FALSE
condition|)
return|return
name|FALSE
return|;
name|pChannelInfo
operator|->
name|maxUltraDmaModeSupported
operator|--
expr_stmt|;
continue|continue;
block|}
else|else
return|return
name|FALSE
return|;
block|}
break|break;
block|}
do|while
condition|(
literal|1
condition|)
do|;
comment|/* Read look ahead */
ifdef|#
directive|ifdef
name|ENABLE_READ_AHEAD
if|if
condition|(
name|pMvSataChannel
operator|->
name|identifyDevice
index|[
literal|82
index|]
operator|&
literal|0x40
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|pMvSataChannel
operator|->
name|identifyDevice
index|[
literal|85
index|]
operator|&
literal|0x40
operator|)
condition|)
comment|/* if not enabled by default */
block|{
if|if
condition|(
name|mvStorageDevATASetFeatures
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channelNum
argument_list|,
name|MV_ATA_SET_FEATURES_ENABLE_RLA
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
name|MV_FALSE
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR18xx [%d] channel %d: Set Features failed\n"
argument_list|,
name|pMvSataAdapter
operator|->
name|adapterId
argument_list|,
name|channelNum
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|KdPrint
argument_list|(
operator|(
literal|"RR18xx [%d]: channel=%d, read look ahead enabled\n"
operator|,
name|pMvSataAdapter
operator|->
name|adapterId
operator|,
name|channelNum
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|KdPrint
argument_list|(
operator|(
literal|"RR18xx [%d]: channel %d, Read Look Ahead not supported\n"
operator|,
name|pMvSataAdapter
operator|->
name|adapterId
operator|,
name|channelNum
operator|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
block|{
if|if
condition|(
name|pMvSataChannel
operator|->
name|identifyDevice
index|[
literal|86
index|]
operator|&
literal|0x20
condition|)
block|{
name|KdPrint
argument_list|(
operator|(
literal|"RR18xx [%d]:channel %d, disable read look ahead\n"
operator|,
name|pMvSataAdapter
operator|->
name|adapterId
operator|,
name|channelNum
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mvStorageDevATASetFeatures
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channelNum
argument_list|,
name|MV_ATA_SET_FEATURES_DISABLE_RLA
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
name|MV_FALSE
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR18xx [%d]:channel %d:  ATA Set Features failed\n"
argument_list|,
name|pMvSataAdapter
operator|->
name|adapterId
argument_list|,
name|channelNum
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|KdPrint
argument_list|(
operator|(
literal|"RR18xx [%d]:channel %d, read look ahead disabled\n"
operator|,
name|pMvSataAdapter
operator|->
name|adapterId
operator|,
name|channelNum
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|{
name|KdPrint
argument_list|(
operator|(
literal|"RR18xx [%d]: channel %d config EDMA, Non Queued Mode\n"
operator|,
name|pMvSataAdapter
operator|->
name|adapterId
operator|,
name|channelNum
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mvSataConfigEdmaMode
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channelNum
argument_list|,
name|MV_EDMA_MODE_NOT_QUEUED
argument_list|,
literal|0
argument_list|)
operator|==
name|MV_FALSE
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR18xx [%d] channel %d Error: mvSataConfigEdmaMode failed\n"
argument_list|,
name|pMvSataAdapter
operator|->
name|adapterId
argument_list|,
name|channelNum
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* Enable EDMA */
if|if
condition|(
name|mvSataEnableChannelDma
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channelNum
argument_list|)
operator|==
name|MV_FALSE
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR18xx [%d] Failed to enable DMA, channel=%d\n"
argument_list|,
name|pMvSataAdapter
operator|->
name|adapterId
argument_list|,
name|channelNum
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|MV_ERROR
argument_list|(
literal|"RR18xx [%d,%d]: channel started successfully\n"
argument_list|,
name|pMvSataAdapter
operator|->
name|adapterId
argument_list|,
name|channelNum
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|FOR_DEMO
name|set_fail_led
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channelNum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hptmv_handle_event
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
init|=
operator|(
name|IAL_ADAPTER_T
operator|*
operator|)
name|data
decl_stmt|;
name|MV_SATA_ADAPTER
modifier|*
name|pMvSataAdapter
init|=
operator|&
name|pAdapter
operator|->
name|mvSataAdapter
decl_stmt|;
name|MV_U8
name|channelIndex
decl_stmt|;
comment|/*	mvOsSemTake(&pMvSataAdapter->semaphore); */
for|for
control|(
name|channelIndex
operator|=
literal|0
init|;
name|channelIndex
operator|<
name|MV_SATA_CHANNELS_NUM
condition|;
name|channelIndex
operator|++
control|)
block|{
switch|switch
condition|(
name|pAdapter
operator|->
name|sataEvents
index|[
name|channelIndex
index|]
condition|)
block|{
case|case
name|SATA_EVENT_CHANNEL_CONNECTED
case|:
comment|/* Handle only connects */
if|if
condition|(
name|flag
operator|==
literal|1
condition|)
break|break;
name|KdPrint
argument_list|(
operator|(
literal|"RR18xx [%d,%d]: new device connected\n"
operator|,
name|pMvSataAdapter
operator|->
name|adapterId
operator|,
name|channelIndex
operator|)
argument_list|)
expr_stmt|;
name|hptmv_init_channel
argument_list|(
name|pAdapter
argument_list|,
name|channelIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|mvSataConfigureChannel
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channelIndex
argument_list|)
operator|==
name|MV_FALSE
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR18xx [%d,%d] Failed to configure\n"
argument_list|,
name|pMvSataAdapter
operator|->
name|adapterId
argument_list|,
name|channelIndex
argument_list|)
expr_stmt|;
name|hptmv_free_channel
argument_list|(
name|pAdapter
argument_list|,
name|channelIndex
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*mvSataChannelHardReset(pMvSataAdapter, channel);*/
if|if
condition|(
name|start_channel
argument_list|(
name|pAdapter
argument_list|,
name|channelIndex
argument_list|)
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR18xx [%d,%d]Failed to start channel\n"
argument_list|,
name|pMvSataAdapter
operator|->
name|adapterId
argument_list|,
name|channelIndex
argument_list|)
expr_stmt|;
name|hptmv_free_channel
argument_list|(
name|pAdapter
argument_list|,
name|channelIndex
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_change
argument_list|(
name|pAdapter
argument_list|,
name|channelIndex
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
name|pAdapter
operator|->
name|sataEvents
index|[
name|channelIndex
index|]
operator|=
name|SATA_EVENT_NO_CHANGE
expr_stmt|;
break|break;
case|case
name|SATA_EVENT_CHANNEL_DISCONNECTED
case|:
comment|/* Handle only disconnects */
if|if
condition|(
name|flag
operator|==
literal|0
condition|)
break|break;
name|KdPrint
argument_list|(
operator|(
literal|"RR18xx [%d,%d]: device disconnected\n"
operator|,
name|pMvSataAdapter
operator|->
name|adapterId
operator|,
name|channelIndex
operator|)
argument_list|)
expr_stmt|;
comment|/* Flush pending commands */
if|if
condition|(
name|pMvSataAdapter
operator|->
name|sataChannel
index|[
name|channelIndex
index|]
condition|)
block|{
name|_VBUS_INST
argument_list|(
argument|&pAdapter->VBus
argument_list|)
name|mvSataFlushDmaQueue
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channelIndex
argument_list|,
name|MV_FLUSH_TYPE_CALLBACK
argument_list|)
expr_stmt|;
name|CheckPendingCall
argument_list|(
name|_VBUS_P0
argument_list|)
expr_stmt|;
name|mvSataRemoveChannel
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channelIndex
argument_list|)
expr_stmt|;
name|hptmv_free_channel
argument_list|(
name|pAdapter
argument_list|,
name|channelIndex
argument_list|)
expr_stmt|;
name|pMvSataAdapter
operator|->
name|sataChannel
index|[
name|channelIndex
index|]
operator|=
name|NULL
expr_stmt|;
name|KdPrint
argument_list|(
operator|(
literal|"RR18xx [%d,%d]: channel removed\n"
operator|,
name|pMvSataAdapter
operator|->
name|adapterId
operator|,
name|channelIndex
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pAdapter
operator|->
name|outstandingCommands
operator|==
literal|0
operator|&&
name|DPC_Request_Nums
operator|==
literal|0
condition|)
name|Check_Idle_Call
argument_list|(
name|pAdapter
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|KdPrint
argument_list|(
operator|(
literal|"RR18xx [%d,%d]: channel already removed!!\n"
operator|,
name|pMvSataAdapter
operator|->
name|adapterId
operator|,
name|channelIndex
operator|)
argument_list|)
expr_stmt|;
block|}
name|pAdapter
operator|->
name|sataEvents
index|[
name|channelIndex
index|]
operator|=
name|SATA_EVENT_NO_CHANGE
expr_stmt|;
break|break;
case|case
name|SATA_EVENT_NO_CHANGE
case|:
break|break;
default|default:
break|break;
block|}
block|}
comment|/*	mvOsSemRelease(&pMvSataAdapter->semaphore); */
block|}
end_function

begin_define
define|#
directive|define
name|EVENT_CONNECT
value|1
end_define

begin_define
define|#
directive|define
name|EVENT_DISCONNECT
value|0
end_define

begin_function
specifier|static
name|void
name|hptmv_handle_event_connect
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|hptmv_handle_event
argument_list|(
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hptmv_handle_event_disconnect
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|hptmv_handle_event
argument_list|(
name|data
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|MV_BOOLEAN
name|hptmv_event_notify
parameter_list|(
name|MV_SATA_ADAPTER
modifier|*
name|pMvSataAdapter
parameter_list|,
name|MV_EVENT_TYPE
name|eventType
parameter_list|,
name|MV_U32
name|param1
parameter_list|,
name|MV_U32
name|param2
parameter_list|)
block|{
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
init|=
name|pMvSataAdapter
operator|->
name|IALData
decl_stmt|;
switch|switch
condition|(
name|eventType
condition|)
block|{
case|case
name|MV_EVENT_TYPE_SATA_CABLE
case|:
block|{
name|MV_U8
name|channel
init|=
name|param2
decl_stmt|;
if|if
condition|(
name|param1
operator|==
name|EVENT_CONNECT
condition|)
block|{
name|pAdapter
operator|->
name|sataEvents
index|[
name|channel
index|]
operator|=
name|SATA_EVENT_CHANNEL_CONNECTED
expr_stmt|;
name|KdPrint
argument_list|(
operator|(
literal|"RR18xx [%d,%d]: device connected event received\n"
operator|,
name|pMvSataAdapter
operator|->
name|adapterId
operator|,
name|channel
operator|)
argument_list|)
expr_stmt|;
comment|/* Delete previous timers (if multiple drives connected in the same time */
name|pAdapter
operator|->
name|event_timer_connect
operator|=
name|timeout
argument_list|(
name|hptmv_handle_event_connect
argument_list|,
name|pAdapter
argument_list|,
literal|10
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|param1
operator|==
name|EVENT_DISCONNECT
condition|)
block|{
name|pAdapter
operator|->
name|sataEvents
index|[
name|channel
index|]
operator|=
name|SATA_EVENT_CHANNEL_DISCONNECTED
expr_stmt|;
name|KdPrint
argument_list|(
operator|(
literal|"RR18xx [%d,%d]: device disconnected event received \n"
operator|,
name|pMvSataAdapter
operator|->
name|adapterId
operator|,
name|channel
operator|)
argument_list|)
expr_stmt|;
name|device_change
argument_list|(
name|pAdapter
argument_list|,
name|channel
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Delete previous timers (if multiple drives disconnected in the same time */
comment|/*pAdapter->event_timer_disconnect = timeout(hptmv_handle_event_disconnect, pAdapter, 10*hz); */
comment|/*It is not necessary to wait, handle it directly*/
name|hptmv_handle_event_disconnect
argument_list|(
name|pAdapter
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MV_ERROR
argument_list|(
literal|"RR18xx: illigal value for param1(%d) at "
literal|"connect/disconect event, host=%d\n"
argument_list|,
name|param1
argument_list|,
name|pMvSataAdapter
operator|->
name|adapterId
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|MV_EVENT_TYPE_ADAPTER_ERROR
case|:
name|KdPrint
argument_list|(
operator|(
literal|"RR18xx: DEVICE error event received, pci cause "
literal|"reg=%x,  don't how to handle this\n"
operator|,
name|param1
operator|)
argument_list|)
expr_stmt|;
return|return
name|MV_TRUE
return|;
default|default:
name|MV_ERROR
argument_list|(
literal|"RR18xx[%d]: unknown event type (%d)\n"
argument_list|,
name|pMvSataAdapter
operator|->
name|adapterId
argument_list|,
name|eventType
argument_list|)
expr_stmt|;
return|return
name|MV_FALSE
return|;
block|}
return|return
name|MV_TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hptmv_allocate_edma_queues
parameter_list|(
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
parameter_list|)
block|{
name|pAdapter
operator|->
name|requestsArrayBaseAddr
operator|=
operator|(
name|MV_U8
operator|*
operator|)
name|contigmalloc
argument_list|(
name|REQUESTS_ARRAY_SIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|0ul
argument_list|)
expr_stmt|;
if|if
condition|(
name|pAdapter
operator|->
name|requestsArrayBaseAddr
operator|==
name|NULL
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR18xx[%d]: Failed to allocate memory for EDMA request"
literal|" queues\n"
argument_list|,
name|pAdapter
operator|->
name|mvSataAdapter
operator|.
name|adapterId
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|pAdapter
operator|->
name|requestsArrayBaseDmaAddr
operator|=
name|fOsPhysicalAddress
argument_list|(
name|pAdapter
operator|->
name|requestsArrayBaseAddr
argument_list|)
expr_stmt|;
name|pAdapter
operator|->
name|requestsArrayBaseAlignedAddr
operator|=
name|pAdapter
operator|->
name|requestsArrayBaseAddr
expr_stmt|;
name|pAdapter
operator|->
name|requestsArrayBaseAlignedAddr
operator|+=
name|MV_EDMA_REQUEST_QUEUE_SIZE
expr_stmt|;
name|pAdapter
operator|->
name|requestsArrayBaseAlignedAddr
operator|=
operator|(
name|MV_U8
operator|*
operator|)
operator|(
operator|(
operator|(
name|ULONG_PTR
operator|)
name|pAdapter
operator|->
name|requestsArrayBaseAlignedAddr
operator|)
operator|&
operator|~
call|(
name|ULONG_PTR
call|)
argument_list|(
name|MV_EDMA_REQUEST_QUEUE_SIZE
operator|-
literal|1
argument_list|)
operator|)
expr_stmt|;
name|pAdapter
operator|->
name|requestsArrayBaseDmaAlignedAddr
operator|=
name|pAdapter
operator|->
name|requestsArrayBaseDmaAddr
expr_stmt|;
name|pAdapter
operator|->
name|requestsArrayBaseDmaAlignedAddr
operator|+=
name|MV_EDMA_REQUEST_QUEUE_SIZE
expr_stmt|;
name|pAdapter
operator|->
name|requestsArrayBaseDmaAlignedAddr
operator|&=
operator|~
call|(
name|ULONG_PTR
call|)
argument_list|(
name|MV_EDMA_REQUEST_QUEUE_SIZE
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pAdapter
operator|->
name|requestsArrayBaseDmaAlignedAddr
operator|-
name|pAdapter
operator|->
name|requestsArrayBaseDmaAddr
operator|)
operator|!=
operator|(
name|pAdapter
operator|->
name|requestsArrayBaseAlignedAddr
operator|-
name|pAdapter
operator|->
name|requestsArrayBaseAddr
operator|)
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR18xx[%d]: Error in Request Quueues Alignment\n"
argument_list|,
name|pAdapter
operator|->
name|mvSataAdapter
operator|.
name|adapterId
argument_list|)
expr_stmt|;
name|contigfree
argument_list|(
name|pAdapter
operator|->
name|requestsArrayBaseAddr
argument_list|,
name|REQUESTS_ARRAY_SIZE
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* response queues */
name|pAdapter
operator|->
name|responsesArrayBaseAddr
operator|=
operator|(
name|MV_U8
operator|*
operator|)
name|contigmalloc
argument_list|(
name|RESPONSES_ARRAY_SIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|0ul
argument_list|)
expr_stmt|;
if|if
condition|(
name|pAdapter
operator|->
name|responsesArrayBaseAddr
operator|==
name|NULL
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR18xx[%d]: Failed to allocate memory for EDMA response"
literal|" queues\n"
argument_list|,
name|pAdapter
operator|->
name|mvSataAdapter
operator|.
name|adapterId
argument_list|)
expr_stmt|;
name|contigfree
argument_list|(
name|pAdapter
operator|->
name|requestsArrayBaseAddr
argument_list|,
name|RESPONSES_ARRAY_SIZE
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|pAdapter
operator|->
name|responsesArrayBaseDmaAddr
operator|=
name|fOsPhysicalAddress
argument_list|(
name|pAdapter
operator|->
name|responsesArrayBaseAddr
argument_list|)
expr_stmt|;
name|pAdapter
operator|->
name|responsesArrayBaseAlignedAddr
operator|=
name|pAdapter
operator|->
name|responsesArrayBaseAddr
expr_stmt|;
name|pAdapter
operator|->
name|responsesArrayBaseAlignedAddr
operator|+=
name|MV_EDMA_RESPONSE_QUEUE_SIZE
expr_stmt|;
name|pAdapter
operator|->
name|responsesArrayBaseAlignedAddr
operator|=
operator|(
name|MV_U8
operator|*
operator|)
operator|(
operator|(
operator|(
name|ULONG_PTR
operator|)
name|pAdapter
operator|->
name|responsesArrayBaseAlignedAddr
operator|)
operator|&
operator|~
call|(
name|ULONG_PTR
call|)
argument_list|(
name|MV_EDMA_RESPONSE_QUEUE_SIZE
operator|-
literal|1
argument_list|)
operator|)
expr_stmt|;
name|pAdapter
operator|->
name|responsesArrayBaseDmaAlignedAddr
operator|=
name|pAdapter
operator|->
name|responsesArrayBaseDmaAddr
expr_stmt|;
name|pAdapter
operator|->
name|responsesArrayBaseDmaAlignedAddr
operator|+=
name|MV_EDMA_RESPONSE_QUEUE_SIZE
expr_stmt|;
name|pAdapter
operator|->
name|responsesArrayBaseDmaAlignedAddr
operator|&=
operator|~
call|(
name|ULONG_PTR
call|)
argument_list|(
name|MV_EDMA_RESPONSE_QUEUE_SIZE
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pAdapter
operator|->
name|responsesArrayBaseDmaAlignedAddr
operator|-
name|pAdapter
operator|->
name|responsesArrayBaseDmaAddr
operator|)
operator|!=
operator|(
name|pAdapter
operator|->
name|responsesArrayBaseAlignedAddr
operator|-
name|pAdapter
operator|->
name|responsesArrayBaseAddr
operator|)
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR18xx[%d]: Error in Response Quueues Alignment\n"
argument_list|,
name|pAdapter
operator|->
name|mvSataAdapter
operator|.
name|adapterId
argument_list|)
expr_stmt|;
name|contigfree
argument_list|(
name|pAdapter
operator|->
name|requestsArrayBaseAddr
argument_list|,
name|REQUESTS_ARRAY_SIZE
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|contigfree
argument_list|(
name|pAdapter
operator|->
name|responsesArrayBaseAddr
argument_list|,
name|RESPONSES_ARRAY_SIZE
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hptmv_free_edma_queues
parameter_list|(
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
parameter_list|)
block|{
name|contigfree
argument_list|(
name|pAdapter
operator|->
name|requestsArrayBaseAddr
argument_list|,
name|REQUESTS_ARRAY_SIZE
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|contigfree
argument_list|(
name|pAdapter
operator|->
name|responsesArrayBaseAddr
argument_list|,
name|RESPONSES_ARRAY_SIZE
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|PVOID
name|AllocatePRDTable
parameter_list|(
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
parameter_list|)
block|{
name|PVOID
name|ret
decl_stmt|;
if|if
condition|(
name|pAdapter
operator|->
name|pFreePRDLink
condition|)
block|{
name|KdPrint
argument_list|(
operator|(
literal|"pAdapter->pFreePRDLink:%p\n"
operator|,
name|pAdapter
operator|->
name|pFreePRDLink
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|pAdapter
operator|->
name|pFreePRDLink
expr_stmt|;
name|pAdapter
operator|->
name|pFreePRDLink
operator|=
operator|*
operator|(
name|void
operator|*
operator|*
operator|)
name|ret
expr_stmt|;
return|return
name|ret
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|FreePRDTable
parameter_list|(
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
parameter_list|,
name|PVOID
name|PRDTable
parameter_list|)
block|{
operator|*
operator|(
name|void
operator|*
operator|*
operator|)
name|PRDTable
operator|=
name|pAdapter
operator|->
name|pFreePRDLink
expr_stmt|;
name|pAdapter
operator|->
name|pFreePRDLink
operator|=
name|PRDTable
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|extern
name|PVDevice
name|fGetFirstChild
parameter_list|(
name|PVDevice
name|pLogical
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|fResetBootMark
parameter_list|(
name|PVDevice
name|pLogical
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|fRegisterVdevice
parameter_list|(
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
parameter_list|)
block|{
name|PVDevice
name|pPhysical
decl_stmt|,
name|pLogical
decl_stmt|;
name|PVBus
name|pVBus
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MV_SATA_CHANNELS_NUM
condition|;
name|i
operator|++
control|)
block|{
name|pPhysical
operator|=
operator|&
operator|(
name|pAdapter
operator|->
name|VDevices
index|[
name|i
index|]
operator|)
expr_stmt|;
name|pLogical
operator|=
name|pPhysical
expr_stmt|;
while|while
condition|(
name|pLogical
operator|->
name|pParent
condition|)
name|pLogical
operator|=
name|pLogical
operator|->
name|pParent
expr_stmt|;
if|if
condition|(
name|pLogical
operator|->
name|vf_online
operator|==
literal|0
condition|)
block|{
name|pPhysical
operator|->
name|vf_bootmark
operator|=
name|pLogical
operator|->
name|vf_bootmark
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|pLogical
operator|->
name|VDeviceType
operator|==
name|VD_SPARE
operator|||
name|pPhysical
operator|!=
name|fGetFirstChild
argument_list|(
name|pLogical
argument_list|)
condition|)
continue|continue;
name|pVBus
operator|=
operator|&
name|pAdapter
operator|->
name|VBus
expr_stmt|;
if|if
condition|(
name|pVBus
condition|)
block|{
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|j
operator|<
name|MAX_VDEVICE_PER_VBUS
operator|&&
name|pVBus
operator|->
name|pVDevice
index|[
name|j
index|]
condition|)
name|j
operator|++
expr_stmt|;
if|if
condition|(
name|j
operator|<
name|MAX_VDEVICE_PER_VBUS
condition|)
block|{
name|pVBus
operator|->
name|pVDevice
index|[
name|j
index|]
operator|=
name|pLogical
expr_stmt|;
name|pLogical
operator|->
name|pVBus
operator|=
name|pVBus
expr_stmt|;
if|if
condition|(
name|j
operator|>
literal|0
operator|&&
name|pLogical
operator|->
name|vf_bootmark
condition|)
block|{
if|if
condition|(
name|pVBus
operator|->
name|pVDevice
index|[
literal|0
index|]
operator|->
name|vf_bootmark
condition|)
block|{
name|fResetBootMark
argument_list|(
name|pLogical
argument_list|)
expr_stmt|;
block|}
else|else
block|{
do|do
block|{
name|pVBus
operator|->
name|pVDevice
index|[
name|j
index|]
operator|=
name|pVBus
operator|->
name|pVDevice
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|j
condition|)
do|;
name|pVBus
operator|->
name|pVDevice
index|[
literal|0
index|]
operator|=
name|pLogical
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
end_function

begin_function
name|PVDevice
name|GetSpareDisk
parameter_list|(
name|_VBUS_ARG
name|PVDevice
name|pArray
parameter_list|)
block|{
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
init|=
operator|(
name|IAL_ADAPTER_T
operator|*
operator|)
name|pArray
operator|->
name|pVBus
operator|->
name|OsExt
decl_stmt|;
name|LBA_T
name|capacity
init|=
name|LongDiv
argument_list|(
name|pArray
operator|->
name|VDeviceCapacity
argument_list|,
name|pArray
operator|->
name|u
operator|.
name|array
operator|.
name|bArnMember
operator|-
literal|1
argument_list|)
decl_stmt|;
name|LBA_T
name|thiscap
decl_stmt|,
name|maxcap
init|=
name|MAX_LBA_T
decl_stmt|;
name|PVDevice
name|pVDevice
decl_stmt|,
name|pFind
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MV_SATA_CHANNELS_NUM
condition|;
name|i
operator|++
control|)
block|{
name|pVDevice
operator|=
operator|&
name|pAdapter
operator|->
name|VDevices
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|pVDevice
condition|)
continue|continue;
name|thiscap
operator|=
name|pArray
operator|->
name|vf_format_v2
condition|?
name|pVDevice
operator|->
name|u
operator|.
name|disk
operator|.
name|dDeRealCapacity
else|:
name|pVDevice
operator|->
name|VDeviceCapacity
expr_stmt|;
comment|/* find the smallest usable spare disk */
if|if
condition|(
name|pVDevice
operator|->
name|VDeviceType
operator|==
name|VD_SPARE
operator|&&
name|pVDevice
operator|->
name|u
operator|.
name|disk
operator|.
name|df_on_line
operator|&&
name|thiscap
operator|<
name|maxcap
operator|&&
name|thiscap
operator|>=
name|capacity
condition|)
block|{
name|maxcap
operator|=
name|pVDevice
operator|->
name|VDeviceCapacity
expr_stmt|;
name|pFind
operator|=
name|pVDevice
expr_stmt|;
block|}
block|}
return|return
name|pFind
return|;
block|}
end_function

begin_comment
comment|/******************************************************************  * IO ATA Command  *******************************************************************/
end_comment

begin_function
name|int
name|HPTLIBAPI
name|fDeReadWrite
parameter_list|(
name|PDevice
name|pDev
parameter_list|,
name|ULONG
name|Lba
parameter_list|,
name|UCHAR
name|Cmd
parameter_list|,
name|void
modifier|*
name|tmpBuffer
parameter_list|)
block|{
return|return
name|mvReadWrite
argument_list|(
name|pDev
operator|->
name|mv
argument_list|,
name|Lba
argument_list|,
name|Cmd
argument_list|,
name|tmpBuffer
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|HPTLIBAPI
name|fDeSelectMode
parameter_list|(
name|PDevice
name|pDev
parameter_list|,
name|UCHAR
name|NewMode
parameter_list|)
block|{
name|MV_SATA_CHANNEL
modifier|*
name|pSataChannel
init|=
name|pDev
operator|->
name|mv
decl_stmt|;
name|MV_SATA_ADAPTER
modifier|*
name|pSataAdapter
init|=
name|pSataChannel
operator|->
name|mvSataAdapter
decl_stmt|;
name|MV_U8
name|channelIndex
init|=
name|pSataChannel
operator|->
name|channelNumber
decl_stmt|;
name|UCHAR
name|mvMode
decl_stmt|;
comment|/* 508x don't use MW-DMA? */
if|if
condition|(
name|NewMode
operator|>
literal|4
operator|&&
name|NewMode
operator|<
literal|8
condition|)
name|NewMode
operator|=
literal|4
expr_stmt|;
name|pDev
operator|->
name|bDeModeSetting
operator|=
name|NewMode
expr_stmt|;
if|if
condition|(
name|NewMode
operator|<=
literal|4
condition|)
name|mvMode
operator|=
name|MV_ATA_TRANSFER_PIO_0
operator|+
name|NewMode
expr_stmt|;
else|else
name|mvMode
operator|=
name|MV_ATA_TRANSFER_UDMA_0
operator|+
operator|(
name|NewMode
operator|-
literal|8
operator|)
expr_stmt|;
comment|/*To fix 88i8030 bug*/
if|if
condition|(
name|mvMode
operator|>
name|MV_ATA_TRANSFER_UDMA_0
operator|&&
name|mvMode
operator|<
name|MV_ATA_TRANSFER_UDMA_4
condition|)
name|mvMode
operator|=
name|MV_ATA_TRANSFER_UDMA_0
expr_stmt|;
name|mvSataDisableChannelDma
argument_list|(
name|pSataAdapter
argument_list|,
name|channelIndex
argument_list|)
expr_stmt|;
comment|/* Flush pending commands */
name|mvSataFlushDmaQueue
argument_list|(
name|pSataAdapter
argument_list|,
name|channelIndex
argument_list|,
name|MV_FLUSH_TYPE_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mvStorageDevATASetFeatures
argument_list|(
name|pSataAdapter
argument_list|,
name|channelIndex
argument_list|,
name|MV_ATA_SET_FEATURES_TRANSFER
argument_list|,
name|mvMode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
name|MV_FALSE
condition|)
block|{
name|KdPrint
argument_list|(
operator|(
literal|"channel %d: Set Features failed\n"
operator|,
name|channelIndex
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Enable EDMA */
if|if
condition|(
name|mvSataEnableChannelDma
argument_list|(
name|pSataAdapter
argument_list|,
name|channelIndex
argument_list|)
operator|==
name|MV_FALSE
condition|)
name|KdPrint
argument_list|(
operator|(
literal|"Failed to enable DMA, channel=%d"
operator|,
name|channelIndex
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|HPTLIBAPI
name|fDeSetTCQ
parameter_list|(
name|PDevice
name|pDev
parameter_list|,
name|int
name|enable
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|MV_SATA_CHANNEL
modifier|*
name|pSataChannel
init|=
name|pDev
operator|->
name|mv
decl_stmt|;
name|MV_SATA_ADAPTER
modifier|*
name|pSataAdapter
init|=
name|pSataChannel
operator|->
name|mvSataAdapter
decl_stmt|;
name|MV_U8
name|channelIndex
init|=
name|pSataChannel
operator|->
name|channelNumber
decl_stmt|;
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
init|=
name|pSataAdapter
operator|->
name|IALData
decl_stmt|;
name|MV_CHANNEL
modifier|*
name|channelInfo
init|=
operator|&
operator|(
name|pAdapter
operator|->
name|mvChannel
index|[
name|channelIndex
index|]
operator|)
decl_stmt|;
name|int
name|dmaActive
init|=
name|pSataChannel
operator|->
name|queueCommandsEnabled
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|dmaActive
condition|)
block|{
name|mvSataDisableChannelDma
argument_list|(
name|pSataAdapter
argument_list|,
name|channelIndex
argument_list|)
expr_stmt|;
name|mvSataFlushDmaQueue
argument_list|(
name|pSataAdapter
argument_list|,
name|channelIndex
argument_list|,
name|MV_FLUSH_TYPE_CALLBACK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|enable
condition|)
block|{
if|if
condition|(
name|pSataChannel
operator|->
name|queuedDMA
operator|==
name|MV_EDMA_MODE_NOT_QUEUED
operator|&&
operator|(
name|pSataChannel
operator|->
name|identifyDevice
index|[
name|IDEN_SUPPORTED_COMMANDS2
index|]
operator|&
operator|(
literal|0x2
operator|)
operator|)
condition|)
block|{
name|UCHAR
name|depth
init|=
operator|(
operator|(
name|pSataChannel
operator|->
name|identifyDevice
index|[
name|IDEN_QUEUE_DEPTH
index|]
operator|)
operator|&
literal|0x1f
operator|)
operator|+
literal|1
decl_stmt|;
name|channelInfo
operator|->
name|queueDepth
operator|=
operator|(
name|depth
operator|==
literal|32
operator|)
condition|?
literal|31
else|:
name|depth
expr_stmt|;
name|mvSataConfigEdmaMode
argument_list|(
name|pSataAdapter
argument_list|,
name|channelIndex
argument_list|,
name|MV_EDMA_MODE_QUEUED
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|pSataChannel
operator|->
name|queuedDMA
operator|!=
name|MV_EDMA_MODE_NOT_QUEUED
condition|)
block|{
name|channelInfo
operator|->
name|queueDepth
operator|=
literal|2
expr_stmt|;
name|mvSataConfigEdmaMode
argument_list|(
name|pSataAdapter
argument_list|,
name|channelIndex
argument_list|,
name|MV_EDMA_MODE_NOT_QUEUED
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dmaActive
condition|)
name|mvSataEnableChannelDma
argument_list|(
name|pSataAdapter
argument_list|,
name|channelIndex
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|HPTLIBAPI
name|fDeSetNCQ
parameter_list|(
name|PDevice
name|pDev
parameter_list|,
name|int
name|enable
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|HPTLIBAPI
name|fDeSetWriteCache
parameter_list|(
name|PDevice
name|pDev
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
name|MV_SATA_CHANNEL
modifier|*
name|pSataChannel
init|=
name|pDev
operator|->
name|mv
decl_stmt|;
name|MV_SATA_ADAPTER
modifier|*
name|pSataAdapter
init|=
name|pSataChannel
operator|->
name|mvSataAdapter
decl_stmt|;
name|MV_U8
name|channelIndex
init|=
name|pSataChannel
operator|->
name|channelNumber
decl_stmt|;
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
init|=
name|pSataAdapter
operator|->
name|IALData
decl_stmt|;
name|MV_CHANNEL
modifier|*
name|channelInfo
init|=
operator|&
operator|(
name|pAdapter
operator|->
name|mvChannel
index|[
name|channelIndex
index|]
operator|)
decl_stmt|;
name|int
name|dmaActive
init|=
name|pSataChannel
operator|->
name|queueCommandsEnabled
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|dmaActive
condition|)
block|{
name|mvSataDisableChannelDma
argument_list|(
name|pSataAdapter
argument_list|,
name|channelIndex
argument_list|)
expr_stmt|;
name|mvSataFlushDmaQueue
argument_list|(
name|pSataAdapter
argument_list|,
name|channelIndex
argument_list|,
name|MV_FLUSH_TYPE_CALLBACK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pSataChannel
operator|->
name|identifyDevice
index|[
literal|82
index|]
operator|&
operator|(
literal|0x20
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|enable
condition|)
block|{
if|if
condition|(
name|mvStorageDevATASetFeatures
argument_list|(
name|pSataAdapter
argument_list|,
name|channelIndex
argument_list|,
name|MV_ATA_SET_FEATURES_ENABLE_WCACHE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|channelInfo
operator|->
name|writeCacheEnabled
operator|=
name|MV_TRUE
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|mvStorageDevATASetFeatures
argument_list|(
name|pSataAdapter
argument_list|,
name|channelIndex
argument_list|,
name|MV_ATA_SET_FEATURES_DISABLE_WCACHE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|channelInfo
operator|->
name|writeCacheEnabled
operator|=
name|MV_FALSE
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|dmaActive
condition|)
name|mvSataEnableChannelDma
argument_list|(
name|pSataAdapter
argument_list|,
name|channelIndex
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|HPTLIBAPI
name|fDeSetReadAhead
parameter_list|(
name|PDevice
name|pDev
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
name|MV_SATA_CHANNEL
modifier|*
name|pSataChannel
init|=
name|pDev
operator|->
name|mv
decl_stmt|;
name|MV_SATA_ADAPTER
modifier|*
name|pSataAdapter
init|=
name|pSataChannel
operator|->
name|mvSataAdapter
decl_stmt|;
name|MV_U8
name|channelIndex
init|=
name|pSataChannel
operator|->
name|channelNumber
decl_stmt|;
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
init|=
name|pSataAdapter
operator|->
name|IALData
decl_stmt|;
name|MV_CHANNEL
modifier|*
name|channelInfo
init|=
operator|&
operator|(
name|pAdapter
operator|->
name|mvChannel
index|[
name|channelIndex
index|]
operator|)
decl_stmt|;
name|int
name|dmaActive
init|=
name|pSataChannel
operator|->
name|queueCommandsEnabled
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|dmaActive
condition|)
block|{
name|mvSataDisableChannelDma
argument_list|(
name|pSataAdapter
argument_list|,
name|channelIndex
argument_list|)
expr_stmt|;
name|mvSataFlushDmaQueue
argument_list|(
name|pSataAdapter
argument_list|,
name|channelIndex
argument_list|,
name|MV_FLUSH_TYPE_CALLBACK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pSataChannel
operator|->
name|identifyDevice
index|[
literal|82
index|]
operator|&
operator|(
literal|0x40
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|enable
condition|)
block|{
if|if
condition|(
name|mvStorageDevATASetFeatures
argument_list|(
name|pSataAdapter
argument_list|,
name|channelIndex
argument_list|,
name|MV_ATA_SET_FEATURES_ENABLE_RLA
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|channelInfo
operator|->
name|readAheadEnabled
operator|=
name|MV_TRUE
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|mvStorageDevATASetFeatures
argument_list|(
name|pSataAdapter
argument_list|,
name|channelIndex
argument_list|,
name|MV_ATA_SET_FEATURES_DISABLE_RLA
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|channelInfo
operator|->
name|readAheadEnabled
operator|=
name|MV_FALSE
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|dmaActive
condition|)
name|mvSataEnableChannelDma
argument_list|(
name|pSataAdapter
argument_list|,
name|channelIndex
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SUPPORT_ARRAY
end_ifdef

begin_define
define|#
directive|define
name|IdeRegisterVDevice
value|fCheckArray
end_define

begin_else
else|#
directive|else
end_else

begin_function
name|void
name|IdeRegisterVDevice
parameter_list|(
name|PDevice
name|pDev
parameter_list|)
block|{
name|PVDevice
name|pVDev
init|=
name|Map2pVDevice
argument_list|(
name|pDev
argument_list|)
decl_stmt|;
name|pVDev
operator|->
name|VDeviceType
operator|=
name|pDev
operator|->
name|df_atapi
condition|?
name|VD_ATAPI
else|:
name|pDev
operator|->
name|df_removable_drive
condition|?
name|VD_REMOVABLE
else|:
name|VD_SINGLE_DISK
expr_stmt|;
name|pVDev
operator|->
name|vf_online
operator|=
literal|1
expr_stmt|;
name|pVDev
operator|->
name|VDeviceCapacity
operator|=
name|pDev
operator|->
name|dDeRealCapacity
expr_stmt|;
name|pVDev
operator|->
name|pfnSendCommand
operator|=
name|pfnSendCommand
index|[
name|pVDev
operator|->
name|VDeviceType
index|]
expr_stmt|;
name|pVDev
operator|->
name|pfnDeviceFailed
operator|=
name|pfnDeviceFailed
index|[
name|pVDev
operator|->
name|VDeviceType
index|]
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|__inline
name|PBUS_DMAMAP
name|dmamap_get
parameter_list|(
name|struct
name|IALAdapter
modifier|*
name|pAdapter
parameter_list|)
block|{
name|PBUS_DMAMAP
name|p
init|=
name|pAdapter
operator|->
name|pbus_dmamap_list
decl_stmt|;
if|if
condition|(
name|p
condition|)
name|pAdapter
operator|->
name|pbus_dmamap_list
operator|=
name|p
operator|->
name|next
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|dmamap_put
parameter_list|(
name|PBUS_DMAMAP
name|p
parameter_list|)
block|{
name|p
operator|->
name|next
operator|=
name|p
operator|->
name|pAdapter
operator|->
name|pbus_dmamap_list
expr_stmt|;
name|p
operator|->
name|pAdapter
operator|->
name|pbus_dmamap_list
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_comment
comment|/*Since mtx not provide the initialize when declare, so we Final init here to initialize the global mtx*/
end_comment

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
end_if

begin_define
define|#
directive|define
name|override_kernel_driver
parameter_list|()
end_define

begin_function
specifier|static
name|void
name|hpt_init
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|override_kernel_driver
argument_list|()
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|driver_lock
argument_list|,
literal|"hptsleeplock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|hptinit
argument_list|,
name|SI_SUB_CONFIGURE
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|hpt_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|num_adapters
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|init_adapter
parameter_list|(
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
parameter_list|)
block|{
name|PVBus
name|_vbus_p
init|=
operator|&
name|pAdapter
operator|->
name|VBus
decl_stmt|;
name|MV_SATA_ADAPTER
modifier|*
name|pMvSataAdapter
decl_stmt|;
name|int
name|i
decl_stmt|,
name|channel
decl_stmt|,
name|rid
decl_stmt|;
name|PVDevice
name|pVDev
decl_stmt|;
name|intrmask_t
name|oldspl
init|=
name|lock_driver
argument_list|()
decl_stmt|;
name|pAdapter
operator|->
name|next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gIal_Adapter
operator|==
literal|0
condition|)
block|{
name|gIal_Adapter
operator|=
name|pAdapter
expr_stmt|;
name|pCurAdapter
operator|=
name|gIal_Adapter
expr_stmt|;
block|}
else|else
block|{
name|pCurAdapter
operator|->
name|next
operator|=
name|pAdapter
expr_stmt|;
name|pCurAdapter
operator|=
name|pAdapter
expr_stmt|;
block|}
name|pAdapter
operator|->
name|outstandingCommands
operator|=
literal|0
expr_stmt|;
name|pMvSataAdapter
operator|=
operator|&
operator|(
name|pAdapter
operator|->
name|mvSataAdapter
operator|)
expr_stmt|;
name|_vbus_p
operator|->
name|OsExt
operator|=
operator|(
name|void
operator|*
operator|)
name|pAdapter
expr_stmt|;
name|pMvSataAdapter
operator|->
name|IALData
operator|=
name|pAdapter
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|pAdapter
operator|->
name|hpt_dev
argument_list|)
argument_list|,
comment|/* parent */
literal|4
argument_list|,
comment|/* alignment */
name|BUS_SPACE_MAXADDR_32BIT
operator|+
literal|1
argument_list|,
comment|/* boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|PAGE_SIZE
operator|*
operator|(
name|MAX_SG_DESCRIPTORS
operator|-
literal|1
operator|)
argument_list|,
comment|/* maxsize */
name|MAX_SG_DESCRIPTORS
argument_list|,
comment|/* nsegments */
literal|0x10000
argument_list|,
comment|/* maxsegsize */
name|BUS_DMA_WAITOK
argument_list|,
comment|/* flags */
if|#
directive|if
name|__FreeBSD_version
operator|>
literal|502000
name|busdma_lock_mutex
argument_list|,
comment|/* lockfunc */
operator|&
name|driver_lock
argument_list|,
comment|/* lockfuncarg */
endif|#
directive|endif
operator|&
name|pAdapter
operator|->
name|io_dma_parent
comment|/* tag */
argument_list|)
condition|)
block|{
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
name|hptmv_allocate_edma_queues
argument_list|(
name|pAdapter
argument_list|)
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR18xx: Failed to allocate memory for EDMA queues\n"
argument_list|)
expr_stmt|;
name|unlock_driver
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
comment|/* also map EPROM address */
name|rid
operator|=
literal|0x10
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pAdapter
operator|->
name|mem_res
operator|=
name|bus_alloc_resource
argument_list|(
name|pAdapter
operator|->
name|hpt_dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
name|MV_SATA_PCI_BAR0_SPACE_SIZE
operator|+
literal|0x40000
argument_list|,
name|RF_ACTIVE
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|pMvSataAdapter
operator|->
name|adapterIoBaseAddress
operator|=
name|rman_get_virtual
argument_list|(
name|pAdapter
operator|->
name|mem_res
argument_list|)
operator|)
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR18xx: Failed to remap memory space\n"
argument_list|)
expr_stmt|;
name|hptmv_free_edma_queues
argument_list|(
name|pAdapter
argument_list|)
expr_stmt|;
name|unlock_driver
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
else|else
block|{
name|KdPrint
argument_list|(
operator|(
literal|"RR18xx: io base address 0x%p\n"
operator|,
name|pMvSataAdapter
operator|->
name|adapterIoBaseAddress
operator|)
argument_list|)
expr_stmt|;
block|}
name|pMvSataAdapter
operator|->
name|adapterId
operator|=
name|num_adapters
operator|++
expr_stmt|;
comment|/* get the revision ID */
name|pMvSataAdapter
operator|->
name|pciConfigRevisionId
operator|=
name|pci_read_config
argument_list|(
name|pAdapter
operator|->
name|hpt_dev
argument_list|,
name|PCIR_REVID
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pMvSataAdapter
operator|->
name|pciConfigDeviceId
operator|=
name|pci_get_device
argument_list|(
name|pAdapter
operator|->
name|hpt_dev
argument_list|)
expr_stmt|;
comment|/* init RR18xx */
name|pMvSataAdapter
operator|->
name|intCoalThre
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|pMvSataAdapter
operator|->
name|intCoalThre
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
name|pMvSataAdapter
operator|->
name|intTimeThre
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|pMvSataAdapter
operator|->
name|intTimeThre
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
name|pMvSataAdapter
operator|->
name|pciCommand
operator|=
literal|0x0107E371
expr_stmt|;
name|pMvSataAdapter
operator|->
name|pciSerrMask
operator|=
literal|0xd77fe6ul
expr_stmt|;
name|pMvSataAdapter
operator|->
name|pciInterruptMask
operator|=
literal|0xd77fe6ul
expr_stmt|;
name|pMvSataAdapter
operator|->
name|mvSataEventNotify
operator|=
name|hptmv_event_notify
expr_stmt|;
if|if
condition|(
name|mvSataInitAdapter
argument_list|(
name|pMvSataAdapter
argument_list|)
operator|==
name|MV_FALSE
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR18xx[%d]: core failed to initialize the adapter\n"
argument_list|,
name|pMvSataAdapter
operator|->
name|adapterId
argument_list|)
expr_stmt|;
name|unregister
label|:
name|bus_release_resource
argument_list|(
name|pAdapter
operator|->
name|hpt_dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|rid
argument_list|,
name|pAdapter
operator|->
name|mem_res
argument_list|)
expr_stmt|;
name|hptmv_free_edma_queues
argument_list|(
name|pAdapter
argument_list|)
expr_stmt|;
name|unlock_driver
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|pAdapter
operator|->
name|ver_601
operator|=
name|pMvSataAdapter
operator|->
name|pcbVersion
expr_stmt|;
ifndef|#
directive|ifndef
name|FOR_DEMO
name|set_fail_leds
argument_list|(
name|pMvSataAdapter
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* setup command blocks */
name|KdPrint
argument_list|(
operator|(
literal|"Allocate command blocks\n"
operator|)
argument_list|)
expr_stmt|;
name|_vbus_
argument_list|(
name|pFreeCommands
argument_list|)
operator|=
literal|0
expr_stmt|;
name|pAdapter
operator|->
name|pCommandBlocks
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|_Command
argument_list|)
operator|*
name|MAX_COMMAND_BLOCKS_FOR_EACH_VBUS
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|KdPrint
argument_list|(
operator|(
literal|"pCommandBlocks:%p\n"
operator|,
name|pAdapter
operator|->
name|pCommandBlocks
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pAdapter
operator|->
name|pCommandBlocks
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"insufficient memory\n"
argument_list|)
expr_stmt|;
goto|goto
name|unregister
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_COMMAND_BLOCKS_FOR_EACH_VBUS
condition|;
name|i
operator|++
control|)
block|{
name|FreeCommand
argument_list|(
name|_VBUS_P
operator|&
operator|(
name|pAdapter
operator|->
name|pCommandBlocks
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/*Set up the bus_dmamap*/
name|pAdapter
operator|->
name|pbus_dmamap
operator|=
operator|(
name|PBUS_DMAMAP
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|_BUS_DMAMAP
argument_list|)
operator|*
name|MAX_QUEUE_COMM
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pAdapter
operator|->
name|pbus_dmamap
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"insufficient memory\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pAdapter
operator|->
name|pCommandBlocks
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
goto|goto
name|unregister
goto|;
block|}
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
name|pAdapter
operator|->
name|pbus_dmamap
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|_BUS_DMAMAP
argument_list|)
operator|*
name|MAX_QUEUE_COMM
argument_list|)
expr_stmt|;
name|pAdapter
operator|->
name|pbus_dmamap_list
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_QUEUE_COMM
condition|;
name|i
operator|++
control|)
block|{
name|PBUS_DMAMAP
name|pmap
init|=
operator|&
operator|(
name|pAdapter
operator|->
name|pbus_dmamap
index|[
name|i
index|]
operator|)
decl_stmt|;
name|pmap
operator|->
name|pAdapter
operator|=
name|pAdapter
expr_stmt|;
name|dmamap_put
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|pAdapter
operator|->
name|io_dma_parent
argument_list|,
literal|0
argument_list|,
operator|&
name|pmap
operator|->
name|dma_map
argument_list|)
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"Can not allocate dma map\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pAdapter
operator|->
name|pCommandBlocks
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pAdapter
operator|->
name|pbus_dmamap
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
goto|goto
name|unregister
goto|;
block|}
block|}
comment|/* setup PRD Tables */
name|KdPrint
argument_list|(
operator|(
literal|"Allocate PRD Tables\n"
operator|)
argument_list|)
expr_stmt|;
name|pAdapter
operator|->
name|pFreePRDLink
operator|=
literal|0
expr_stmt|;
name|pAdapter
operator|->
name|prdTableAddr
operator|=
operator|(
name|PUCHAR
operator|)
name|contigmalloc
argument_list|(
operator|(
name|PRD_ENTRIES_SIZE
operator|*
name|PRD_TABLES_FOR_VBUS
operator|+
literal|32
operator|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|0ul
argument_list|)
expr_stmt|;
name|KdPrint
argument_list|(
operator|(
literal|"prdTableAddr:%p\n"
operator|,
name|pAdapter
operator|->
name|prdTableAddr
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pAdapter
operator|->
name|prdTableAddr
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"insufficient PRD Tables\n"
argument_list|)
expr_stmt|;
goto|goto
name|unregister
goto|;
block|}
name|pAdapter
operator|->
name|prdTableAlignedAddr
operator|=
call|(
name|PUCHAR
call|)
argument_list|(
operator|(
operator|(
name|ULONG_PTR
operator|)
name|pAdapter
operator|->
name|prdTableAddr
operator|+
literal|0x1f
operator|)
operator|&
operator|~
operator|(
name|ULONG_PTR
operator|)
literal|0x1fL
argument_list|)
expr_stmt|;
block|{
name|PUCHAR
name|PRDTable
init|=
name|pAdapter
operator|->
name|prdTableAlignedAddr
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PRD_TABLES_FOR_VBUS
condition|;
name|i
operator|++
control|)
block|{
comment|/*			KdPrint(("i=%d,pAdapter->pFreePRDLink=%p\n",i,pAdapter->pFreePRDLink)); */
name|FreePRDTable
argument_list|(
name|pAdapter
argument_list|,
name|PRDTable
argument_list|)
expr_stmt|;
name|PRDTable
operator|+=
name|PRD_ENTRIES_SIZE
expr_stmt|;
block|}
block|}
comment|/* enable the adapter interrupts */
comment|/* configure and start the connected channels*/
for|for
control|(
name|channel
operator|=
literal|0
init|;
name|channel
operator|<
name|MV_SATA_CHANNELS_NUM
condition|;
name|channel
operator|++
control|)
block|{
name|pAdapter
operator|->
name|mvChannel
index|[
name|channel
index|]
operator|.
name|online
operator|=
name|MV_FALSE
expr_stmt|;
if|if
condition|(
name|mvSataIsStorageDeviceConnected
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channel
argument_list|)
operator|==
name|MV_TRUE
condition|)
block|{
name|KdPrint
argument_list|(
operator|(
literal|"RR18xx[%d]: channel %d is connected\n"
operator|,
name|pMvSataAdapter
operator|->
name|adapterId
operator|,
name|channel
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hptmv_init_channel
argument_list|(
name|pAdapter
argument_list|,
name|channel
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mvSataConfigureChannel
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channel
argument_list|)
operator|==
name|MV_FALSE
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR18xx[%d]: Failed to configure channel"
literal|" %d\n"
argument_list|,
name|pMvSataAdapter
operator|->
name|adapterId
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|hptmv_free_channel
argument_list|(
name|pAdapter
argument_list|,
name|channel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|start_channel
argument_list|(
name|pAdapter
argument_list|,
name|channel
argument_list|)
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR18xx[%d]: Failed to start channel,"
literal|" channel=%d\n"
argument_list|,
name|pMvSataAdapter
operator|->
name|adapterId
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|hptmv_free_channel
argument_list|(
name|pAdapter
argument_list|,
name|channel
argument_list|)
expr_stmt|;
block|}
name|pAdapter
operator|->
name|mvChannel
index|[
name|channel
index|]
operator|.
name|online
operator|=
name|MV_TRUE
expr_stmt|;
comment|/*  mvSataChannelSetEdmaLoopBackMode(pMvSataAdapter, 													   channel, 													   MV_TRUE);*/
block|}
block|}
block|}
name|KdPrint
argument_list|(
operator|(
literal|"pAdapter->mvChannel[channel].online:%x, channel:%d\n"
operator|,
name|pAdapter
operator|->
name|mvChannel
index|[
name|channel
index|]
operator|.
name|online
operator|,
name|channel
operator|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SUPPORT_ARRAY
for|for
control|(
name|i
operator|=
name|MAX_ARRAY_DEVICE
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|pVDev
operator|=
name|ArrayTables
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|mArFreeArrayTable
argument_list|(
name|pVDev
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|KdPrint
argument_list|(
operator|(
literal|"Initialize Devices\n"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|channel
operator|=
literal|0
init|;
name|channel
operator|<
name|MV_SATA_CHANNELS_NUM
condition|;
name|channel
operator|++
control|)
block|{
name|MV_SATA_CHANNEL
modifier|*
name|pMvSataChannel
init|=
name|pMvSataAdapter
operator|->
name|sataChannel
index|[
name|channel
index|]
decl_stmt|;
if|if
condition|(
name|pMvSataChannel
condition|)
block|{
name|init_vdev_params
argument_list|(
name|pAdapter
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|IdeRegisterVDevice
argument_list|(
operator|&
name|pAdapter
operator|->
name|VDevices
index|[
name|channel
index|]
operator|.
name|u
operator|.
name|disk
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|SUPPORT_ARRAY
name|CheckArrayCritical
argument_list|(
name|_VBUS_P0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|_vbus_p
operator|->
name|nInstances
operator|=
literal|1
expr_stmt|;
name|fRegisterVdevice
argument_list|(
name|pAdapter
argument_list|)
expr_stmt|;
for|for
control|(
name|channel
operator|=
literal|0
init|;
name|channel
operator|<
name|MV_SATA_CHANNELS_NUM
condition|;
name|channel
operator|++
control|)
block|{
name|pVDev
operator|=
name|_vbus_p
operator|->
name|pVDevice
index|[
name|channel
index|]
expr_stmt|;
if|if
condition|(
name|pVDev
operator|&&
name|pVDev
operator|->
name|vf_online
condition|)
name|fCheckBootable
argument_list|(
name|pVDev
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|SUPPORT_ARRAY
argument_list|)
operator|&&
name|defined
argument_list|(
name|_RAID5N_
argument_list|)
name|init_raid5_memory
argument_list|(
name|_VBUS_P0
argument_list|)
expr_stmt|;
name|_vbus_
argument_list|(
name|r5
argument_list|)
operator|.
name|enable_write_back
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"RR18xx: RAID5 write-back %s\n"
argument_list|,
name|_vbus_
argument_list|(
name|r5
argument_list|)
operator|.
name|enable_write_back
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mvSataUnmaskAdapterInterrupt
argument_list|(
name|pMvSataAdapter
argument_list|)
expr_stmt|;
name|unlock_driver
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|MvSataResetChannel
parameter_list|(
name|MV_SATA_ADAPTER
modifier|*
name|pMvSataAdapter
parameter_list|,
name|MV_U8
name|channel
parameter_list|)
block|{
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
init|=
operator|(
name|IAL_ADAPTER_T
operator|*
operator|)
name|pMvSataAdapter
operator|->
name|IALData
decl_stmt|;
name|mvSataDisableChannelDma
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channel
argument_list|)
expr_stmt|;
comment|/* Flush pending commands */
name|mvSataFlushDmaQueue
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channel
argument_list|,
name|MV_FLUSH_TYPE_CALLBACK
argument_list|)
expr_stmt|;
comment|/* Software reset channel */
if|if
condition|(
name|mvStorageDevATASoftResetDevice
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channel
argument_list|)
operator|==
name|MV_FALSE
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR18xx [%d,%d]: failed to perform Software reset\n"
argument_list|,
name|pMvSataAdapter
operator|->
name|adapterId
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|hptmv_free_channel
argument_list|(
name|pAdapter
argument_list|,
name|channel
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Hardware reset channel */
if|if
condition|(
name|mvSataChannelHardReset
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channel
argument_list|)
operator|==
name|MV_FALSE
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR18xx [%d,%d] Failed to Hard reser the SATA channel\n"
argument_list|,
name|pMvSataAdapter
operator|->
name|adapterId
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|hptmv_free_channel
argument_list|(
name|pAdapter
argument_list|,
name|channel
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|mvSataIsStorageDeviceConnected
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channel
argument_list|)
operator|==
name|MV_FALSE
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR18xx [%d,%d] Failed to Connect Device\n"
argument_list|,
name|pMvSataAdapter
operator|->
name|adapterId
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|hptmv_free_channel
argument_list|(
name|pAdapter
argument_list|,
name|channel
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|MV_ERROR
argument_list|(
literal|"channel %d: perform recalibrate command"
argument_list|,
name|channel
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mvStorageDevATAExecuteNonUDMACommand
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channel
argument_list|,
name|MV_NON_UDMA_PROTOCOL_NON_DATA
argument_list|,
name|MV_FALSE
argument_list|,
name|NULL
argument_list|,
comment|/* pBuffer*/
literal|0
argument_list|,
comment|/* count  */
literal|0
argument_list|,
comment|/*features*/
comment|/* sectorCount */
literal|0
argument_list|,
literal|0
argument_list|,
comment|/* lbaLow */
literal|0
argument_list|,
comment|/* lbaMid */
comment|/* lbaHigh */
literal|0
argument_list|,
literal|0
argument_list|,
comment|/* device */
comment|/* command */
literal|0x10
argument_list|)
condition|)
name|MV_ERROR
argument_list|(
literal|"channel %d: recalibrate failed"
argument_list|,
name|channel
argument_list|)
expr_stmt|;
comment|/* Set transfer mode */
if|if
condition|(
operator|(
name|mvStorageDevATASetFeatures
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channel
argument_list|,
name|MV_ATA_SET_FEATURES_TRANSFER
argument_list|,
name|MV_ATA_TRANSFER_PIO_SLOW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
name|MV_FALSE
operator|)
operator|||
operator|(
name|mvStorageDevATASetFeatures
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channel
argument_list|,
name|MV_ATA_SET_FEATURES_TRANSFER
argument_list|,
name|pAdapter
operator|->
name|mvChannel
index|[
name|channel
index|]
operator|.
name|maxPioModeSupported
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
name|MV_FALSE
operator|)
operator|||
operator|(
name|mvStorageDevATASetFeatures
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channel
argument_list|,
name|MV_ATA_SET_FEATURES_TRANSFER
argument_list|,
name|pAdapter
operator|->
name|mvChannel
index|[
name|channel
index|]
operator|.
name|maxUltraDmaModeSupported
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
name|MV_FALSE
operator|)
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"channel %d: Set Features failed"
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|hptmv_free_channel
argument_list|(
name|pAdapter
argument_list|,
name|channel
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Enable EDMA */
if|if
condition|(
name|mvSataEnableChannelDma
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channel
argument_list|)
operator|==
name|MV_FALSE
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"Failed to enable DMA, channel=%d"
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|hptmv_free_channel
argument_list|(
name|pAdapter
argument_list|,
name|channel
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fResetActiveCommands
parameter_list|(
name|PVBus
name|_vbus_p
parameter_list|)
block|{
name|MV_SATA_ADAPTER
modifier|*
name|pMvSataAdapter
init|=
operator|&
operator|(
operator|(
name|IAL_ADAPTER_T
operator|*
operator|)
name|_vbus_p
operator|->
name|OsExt
operator|)
operator|->
name|mvSataAdapter
decl_stmt|;
name|MV_U8
name|channel
decl_stmt|;
for|for
control|(
name|channel
operator|=
literal|0
init|;
name|channel
operator|<
name|MV_SATA_CHANNELS_NUM
condition|;
name|channel
operator|++
control|)
block|{
if|if
condition|(
name|pMvSataAdapter
operator|->
name|sataChannel
index|[
name|channel
index|]
operator|&&
name|pMvSataAdapter
operator|->
name|sataChannel
index|[
name|channel
index|]
operator|->
name|outstandingCommands
condition|)
name|MvSataResetChannel
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channel
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|fCompleteAllCommandsSynchronously
parameter_list|(
name|PVBus
name|_vbus_p
parameter_list|)
block|{
name|UINT
name|cont
decl_stmt|;
name|ULONG
name|ticks
init|=
literal|0
decl_stmt|;
name|MV_U8
name|channel
decl_stmt|;
name|MV_SATA_ADAPTER
modifier|*
name|pMvSataAdapter
init|=
operator|&
operator|(
operator|(
name|IAL_ADAPTER_T
operator|*
operator|)
name|_vbus_p
operator|->
name|OsExt
operator|)
operator|->
name|mvSataAdapter
decl_stmt|;
name|MV_SATA_CHANNEL
modifier|*
name|pMvSataChannel
decl_stmt|;
do|do
block|{
name|check_cmds
label|:
name|cont
operator|=
literal|0
expr_stmt|;
name|CheckPendingCall
argument_list|(
name|_VBUS_P0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_RAID5N_
name|dataxfer_poll
argument_list|()
expr_stmt|;
name|xor_poll
argument_list|()
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|channel
operator|=
literal|0
init|;
name|channel
operator|<
name|MV_SATA_CHANNELS_NUM
condition|;
name|channel
operator|++
control|)
block|{
name|pMvSataChannel
operator|=
name|pMvSataAdapter
operator|->
name|sataChannel
index|[
name|channel
index|]
expr_stmt|;
if|if
condition|(
name|pMvSataChannel
operator|&&
name|pMvSataChannel
operator|->
name|outstandingCommands
condition|)
block|{
while|while
condition|(
name|pMvSataChannel
operator|->
name|outstandingCommands
condition|)
block|{
if|if
condition|(
operator|!
name|mvSataInterruptServiceRoutine
argument_list|(
name|pMvSataAdapter
argument_list|)
condition|)
block|{
name|StallExec
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|ticks
operator|++
operator|>
literal|3000
condition|)
block|{
name|MvSataResetChannel
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channel
argument_list|)
expr_stmt|;
goto|goto
name|check_cmds
goto|;
block|}
block|}
else|else
name|ticks
operator|=
literal|0
expr_stmt|;
block|}
name|cont
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|cont
condition|)
do|;
block|}
end_function

begin_function
name|void
name|fResetVBus
parameter_list|(
name|_VBUS_ARG0
parameter_list|)
block|{
name|KdPrint
argument_list|(
operator|(
literal|"fMvResetBus(%p)"
operator|,
name|_vbus_p
operator|)
argument_list|)
expr_stmt|;
comment|/* some commands may already finished. */
name|CheckPendingCall
argument_list|(
name|_VBUS_P0
argument_list|)
expr_stmt|;
name|fResetActiveCommands
argument_list|(
name|_vbus_p
argument_list|)
expr_stmt|;
comment|/*  	 * the other pending commands may still be finished successfully. 	 */
name|fCompleteAllCommandsSynchronously
argument_list|(
name|_vbus_p
argument_list|)
expr_stmt|;
comment|/* Now there should be no pending commands. No more action needed. */
name|CheckIdleCall
argument_list|(
name|_VBUS_P0
argument_list|)
expr_stmt|;
name|KdPrint
argument_list|(
operator|(
literal|"fMvResetBus() done"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*No rescan function*/
end_comment

begin_function
name|void
name|fRescanAllDevice
parameter_list|(
name|_VBUS_ARG0
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|MV_BOOLEAN
name|CommandCompletionCB
parameter_list|(
name|MV_SATA_ADAPTER
modifier|*
name|pMvSataAdapter
parameter_list|,
name|MV_U8
name|channelNum
parameter_list|,
name|MV_COMPLETION_TYPE
name|comp_type
parameter_list|,
name|MV_VOID_PTR
name|commandId
parameter_list|,
name|MV_U16
name|responseFlags
parameter_list|,
name|MV_U32
name|timeStamp
parameter_list|,
name|MV_STORAGE_DEVICE_REGISTERS
modifier|*
name|registerStruct
parameter_list|)
block|{
name|PCommand
name|pCmd
init|=
operator|(
name|PCommand
operator|)
name|commandId
decl_stmt|;
name|_VBUS_INST
argument_list|(
argument|pCmd->pVDevice->pVBus
argument_list|)
if|if
condition|(
name|pCmd
operator|->
name|uScratch
operator|.
name|sata_param
operator|.
name|prdAddr
condition|)
name|FreePRDTable
argument_list|(
name|pMvSataAdapter
operator|->
name|IALData
argument_list|,
name|pCmd
operator|->
name|uScratch
operator|.
name|sata_param
operator|.
name|prdAddr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|comp_type
condition|)
block|{
case|case
name|MV_COMPLETION_TYPE_NORMAL
case|:
name|pCmd
operator|->
name|Result
operator|=
name|RETURN_SUCCESS
expr_stmt|;
break|break;
case|case
name|MV_COMPLETION_TYPE_ABORT
case|:
name|pCmd
operator|->
name|Result
operator|=
name|RETURN_BUS_RESET
expr_stmt|;
break|break;
case|case
name|MV_COMPLETION_TYPE_ERROR
case|:
name|MV_ERROR
argument_list|(
literal|"IAL: COMPLETION ERROR, adapter %d, channel %d, flags=%x\n"
argument_list|,
name|pMvSataAdapter
operator|->
name|adapterId
argument_list|,
name|channelNum
argument_list|,
name|responseFlags
argument_list|)
expr_stmt|;
if|if
condition|(
name|responseFlags
operator|&
literal|4
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"ATA regs: error %x, sector count %x, LBA low %x, LBA mid %x,"
literal|" LBA high %x, device %x, status %x\n"
argument_list|,
name|registerStruct
operator|->
name|errorRegister
argument_list|,
name|registerStruct
operator|->
name|sectorCountRegister
argument_list|,
name|registerStruct
operator|->
name|lbaLowRegister
argument_list|,
name|registerStruct
operator|->
name|lbaMidRegister
argument_list|,
name|registerStruct
operator|->
name|lbaHighRegister
argument_list|,
name|registerStruct
operator|->
name|deviceRegister
argument_list|,
name|registerStruct
operator|->
name|statusRegister
argument_list|)
expr_stmt|;
block|}
comment|/*We can't do handleEdmaError directly here, because CommandCompletionCB is called by  		 * mv's ISR, if we retry the command, than the internel data structure may be destroyed*/
name|pCmd
operator|->
name|uScratch
operator|.
name|sata_param
operator|.
name|responseFlags
operator|=
name|responseFlags
expr_stmt|;
name|pCmd
operator|->
name|uScratch
operator|.
name|sata_param
operator|.
name|bIdeStatus
operator|=
name|registerStruct
operator|->
name|statusRegister
expr_stmt|;
name|pCmd
operator|->
name|uScratch
operator|.
name|sata_param
operator|.
name|errorRegister
operator|=
name|registerStruct
operator|->
name|errorRegister
expr_stmt|;
name|pCmd
operator|->
name|pVDevice
operator|->
name|u
operator|.
name|disk
operator|.
name|QueueLength
operator|--
expr_stmt|;
name|CallAfterReturn
argument_list|(
name|_VBUS_P
argument_list|(
argument|DPC_PROC
argument_list|)
name|handleEdmaError
argument_list|,
name|pCmd
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
default|default:
name|MV_ERROR
argument_list|(
literal|" Unknown completion type (%d)\n"
argument_list|,
name|comp_type
argument_list|)
expr_stmt|;
return|return
name|MV_FALSE
return|;
block|}
if|if
condition|(
name|pCmd
operator|->
name|uCmd
operator|.
name|Ide
operator|.
name|Command
operator|==
name|IDE_COMMAND_VERIFY
operator|&&
name|pCmd
operator|->
name|uScratch
operator|.
name|sata_param
operator|.
name|cmd_priv
operator|>
literal|1
condition|)
block|{
name|pCmd
operator|->
name|uScratch
operator|.
name|sata_param
operator|.
name|cmd_priv
operator|--
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|pCmd
operator|->
name|pVDevice
operator|->
name|u
operator|.
name|disk
operator|.
name|QueueLength
operator|--
expr_stmt|;
name|CallAfterReturn
argument_list|(
name|_VBUS_P
argument_list|(
argument|DPC_PROC
argument_list|)
name|pCmd
operator|->
name|pfnCompletion
argument_list|,
name|pCmd
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|void
name|fDeviceSendCommand
parameter_list|(
name|_VBUS_ARG
name|PCommand
name|pCmd
parameter_list|)
block|{
name|MV_SATA_EDMA_PRD_ENTRY
modifier|*
name|pPRDTable
init|=
literal|0
decl_stmt|;
name|MV_SATA_ADAPTER
modifier|*
name|pMvSataAdapter
decl_stmt|;
name|MV_SATA_CHANNEL
modifier|*
name|pMvSataChannel
decl_stmt|;
name|PVDevice
name|pVDevice
init|=
name|pCmd
operator|->
name|pVDevice
decl_stmt|;
name|PDevice
name|pDevice
init|=
operator|&
name|pVDevice
operator|->
name|u
operator|.
name|disk
decl_stmt|;
name|LBA_T
name|Lba
init|=
name|pCmd
operator|->
name|uCmd
operator|.
name|Ide
operator|.
name|Lba
decl_stmt|;
name|USHORT
name|nSector
init|=
name|pCmd
operator|->
name|uCmd
operator|.
name|Ide
operator|.
name|nSectors
decl_stmt|;
name|MV_QUEUE_COMMAND_RESULT
name|result
decl_stmt|;
name|MV_QUEUE_COMMAND_INFO
name|commandInfo
decl_stmt|;
name|MV_UDMA_COMMAND_PARAMS
modifier|*
name|pUdmaParams
init|=
operator|&
name|commandInfo
operator|.
name|commandParams
operator|.
name|udmaCommand
decl_stmt|;
name|MV_NONE_UDMA_COMMAND_PARAMS
modifier|*
name|pNoUdmaParams
init|=
operator|&
name|commandInfo
operator|.
name|commandParams
operator|.
name|NoneUdmaCommand
decl_stmt|;
name|MV_BOOLEAN
name|is48bit
decl_stmt|;
name|MV_U8
name|channel
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|DECLARE_BUFFER
argument_list|(
name|FPSCAT_GATH
argument_list|,
name|tmpSg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pDevice
operator|->
name|df_on_line
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"Device is offline"
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Result
operator|=
name|RETURN_BAD_DEVICE
expr_stmt|;
name|CallAfterReturn
argument_list|(
name|_VBUS_P
argument_list|(
argument|DPC_PROC
argument_list|)
name|pCmd
operator|->
name|pfnCompletion
argument_list|,
name|pCmd
argument_list|)
expr_stmt|;
return|return;
block|}
name|pDevice
operator|->
name|HeadPosition
operator|=
name|pCmd
operator|->
name|uCmd
operator|.
name|Ide
operator|.
name|Lba
operator|+
name|pCmd
operator|->
name|uCmd
operator|.
name|Ide
operator|.
name|nSectors
expr_stmt|;
name|pMvSataChannel
operator|=
name|pDevice
operator|->
name|mv
expr_stmt|;
name|pMvSataAdapter
operator|=
name|pMvSataChannel
operator|->
name|mvSataAdapter
expr_stmt|;
name|channel
operator|=
name|pMvSataChannel
operator|->
name|channelNumber
expr_stmt|;
comment|/* old RAID0 has hidden lba. Remember to clear dDeHiddenLba when delete array! */
name|Lba
operator|+=
name|pDevice
operator|->
name|dDeHiddenLba
expr_stmt|;
comment|/* check LBA */
if|if
condition|(
name|Lba
operator|+
name|nSector
operator|-
literal|1
operator|>
name|pDevice
operator|->
name|dDeRealCapacity
condition|)
block|{
name|pCmd
operator|->
name|Result
operator|=
name|RETURN_INVALID_REQUEST
expr_stmt|;
name|CallAfterReturn
argument_list|(
name|_VBUS_P
argument_list|(
argument|DPC_PROC
argument_list|)
name|pCmd
operator|->
name|pfnCompletion
argument_list|,
name|pCmd
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * always use 48bit LBA if drive supports it. 	 * Some Seagate drives report error if you use a 28-bit command 	 * to access sector 0xfffffff. 	 */
name|is48bit
operator|=
name|pMvSataChannel
operator|->
name|lba48Address
expr_stmt|;
switch|switch
condition|(
name|pCmd
operator|->
name|uCmd
operator|.
name|Ide
operator|.
name|Command
condition|)
block|{
case|case
name|IDE_COMMAND_READ
case|:
case|case
name|IDE_COMMAND_WRITE
case|:
if|if
condition|(
name|pDevice
operator|->
name|bDeModeSetting
operator|<
literal|8
condition|)
goto|goto
name|pio
goto|;
name|commandInfo
operator|.
name|type
operator|=
name|MV_QUEUED_COMMAND_TYPE_UDMA
expr_stmt|;
name|pUdmaParams
operator|->
name|isEXT
operator|=
name|is48bit
expr_stmt|;
name|pUdmaParams
operator|->
name|numOfSectors
operator|=
name|nSector
expr_stmt|;
name|pUdmaParams
operator|->
name|lowLBAAddress
operator|=
name|Lba
expr_stmt|;
name|pUdmaParams
operator|->
name|highLBAAddress
operator|=
literal|0
expr_stmt|;
name|pUdmaParams
operator|->
name|prdHighAddr
operator|=
literal|0
expr_stmt|;
name|pUdmaParams
operator|->
name|callBack
operator|=
name|CommandCompletionCB
expr_stmt|;
name|pUdmaParams
operator|->
name|commandId
operator|=
operator|(
name|MV_VOID_PTR
operator|)
name|pCmd
expr_stmt|;
if|if
condition|(
name|pCmd
operator|->
name|uCmd
operator|.
name|Ide
operator|.
name|Command
operator|==
name|IDE_COMMAND_READ
condition|)
name|pUdmaParams
operator|->
name|readWrite
operator|=
name|MV_UDMA_TYPE_READ
expr_stmt|;
else|else
name|pUdmaParams
operator|->
name|readWrite
operator|=
name|MV_UDMA_TYPE_WRITE
expr_stmt|;
if|if
condition|(
name|pCmd
operator|->
name|pSgTable
operator|&&
name|pCmd
operator|->
name|cf_physical_sg
condition|)
block|{
name|FPSCAT_GATH
name|sg1
init|=
name|tmpSg
decl_stmt|,
name|sg2
init|=
name|pCmd
operator|->
name|pSgTable
decl_stmt|;
do|do
block|{
operator|*
name|sg1
operator|++
operator|=
operator|*
name|sg2
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|sg2
operator|++
operator|->
name|wSgFlag
operator|&
name|SG_FLAG_EOT
operator|)
operator|==
literal|0
condition|)
do|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|pCmd
operator|->
name|pfnBuildSgl
operator|||
operator|!
name|pCmd
operator|->
name|pfnBuildSgl
argument_list|(
argument|_VBUS_P pCmd
argument_list|,
argument|tmpSg
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|pio
label|:
name|mvSataDisableChannelDma
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|mvSataFlushDmaQueue
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channel
argument_list|,
name|MV_FLUSH_TYPE_CALLBACK
argument_list|)
expr_stmt|;
if|if
condition|(
name|pCmd
operator|->
name|pSgTable
operator|&&
name|pCmd
operator|->
name|cf_physical_sg
operator|==
literal|0
condition|)
block|{
name|FPSCAT_GATH
name|sg1
init|=
name|tmpSg
decl_stmt|,
name|sg2
init|=
name|pCmd
operator|->
name|pSgTable
decl_stmt|;
do|do
block|{
operator|*
name|sg1
operator|++
operator|=
operator|*
name|sg2
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|sg2
operator|++
operator|->
name|wSgFlag
operator|&
name|SG_FLAG_EOT
operator|)
operator|==
literal|0
condition|)
do|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|pCmd
operator|->
name|pfnBuildSgl
operator|||
operator|!
name|pCmd
operator|->
name|pfnBuildSgl
argument_list|(
argument|_VBUS_P pCmd
argument_list|,
argument|tmpSg
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|pCmd
operator|->
name|Result
operator|=
name|RETURN_NEED_LOGICAL_SG
expr_stmt|;
goto|goto
name|finish_cmd
goto|;
block|}
block|}
do|do
block|{
name|ULONG
name|size
init|=
name|tmpSg
operator|->
name|wSgSize
condition|?
name|tmpSg
operator|->
name|wSgSize
else|:
literal|0x10000
decl_stmt|;
name|ULONG_PTR
name|addr
init|=
name|tmpSg
operator|->
name|dSgAddress
decl_stmt|;
if|if
condition|(
name|size
operator|&
literal|0x1ff
condition|)
block|{
name|pCmd
operator|->
name|Result
operator|=
name|RETURN_INVALID_REQUEST
expr_stmt|;
goto|goto
name|finish_cmd
goto|;
block|}
if|if
condition|(
name|mvStorageDevATAExecuteNonUDMACommand
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channel
argument_list|,
operator|(
name|pCmd
operator|->
name|cf_data_out
operator|)
condition|?
name|MV_NON_UDMA_PROTOCOL_PIO_DATA_OUT
else|:
name|MV_NON_UDMA_PROTOCOL_PIO_DATA_IN
argument_list|,
name|is48bit
argument_list|,
operator|(
name|MV_U16_PTR
operator|)
name|addr
argument_list|,
name|size
operator|>>
literal|1
argument_list|,
comment|/* count       */
literal|0
argument_list|,
comment|/* features  N/A  */
call|(
name|MV_U16
call|)
argument_list|(
name|size
operator|>>
literal|9
argument_list|)
argument_list|,
comment|/*sector count*/
call|(
name|MV_U16
call|)
argument_list|(
operator|(
name|is48bit
condition|?
call|(
name|MV_U16
call|)
argument_list|(
operator|(
name|Lba
operator|>>
literal|16
operator|)
operator|&
literal|0xFF00
argument_list|)
else|:
literal|0
operator|)
operator||
call|(
name|UCHAR
call|)
argument_list|(
name|Lba
operator|&
literal|0xFF
argument_list|)
argument_list|)
argument_list|,
comment|/*lbalow*/
call|(
name|MV_U16
call|)
argument_list|(
operator|(
name|Lba
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
argument_list|,
comment|/* lbaMid      */
call|(
name|MV_U16
call|)
argument_list|(
operator|(
name|Lba
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
argument_list|)
argument_list|,
comment|/* lbaHigh     */
call|(
name|MV_U8
call|)
argument_list|(
literal|0x40
operator||
operator|(
name|is48bit
condition|?
literal|0
else|:
call|(
name|UCHAR
call|)
argument_list|(
name|Lba
operator|>>
literal|24
argument_list|)
operator|&
literal|0xFF
operator|)
argument_list|)
argument_list|,
comment|/* device      */
call|(
name|MV_U8
call|)
argument_list|(
name|is48bit
condition|?
operator|(
name|pCmd
operator|->
name|cf_data_in
condition|?
name|IDE_COMMAND_READ_EXT
else|:
name|IDE_COMMAND_WRITE_EXT
operator|)
else|:
name|pCmd
operator|->
name|uCmd
operator|.
name|Ide
operator|.
name|Command
argument_list|)
argument_list|)
operator|==
name|MV_FALSE
condition|)
block|{
name|pCmd
operator|->
name|Result
operator|=
name|RETURN_IDE_ERROR
expr_stmt|;
goto|goto
name|finish_cmd
goto|;
block|}
name|Lba
operator|+=
name|size
operator|>>
literal|9
expr_stmt|;
if|if
condition|(
name|Lba
operator|&
literal|0xF0000000
condition|)
name|is48bit
operator|=
name|MV_TRUE
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|tmpSg
operator|++
operator|->
name|wSgFlag
operator|&
name|SG_FLAG_EOT
operator|)
operator|==
literal|0
condition|)
do|;
name|pCmd
operator|->
name|Result
operator|=
name|RETURN_SUCCESS
expr_stmt|;
name|finish_cmd
label|:
name|mvSataEnableChannelDma
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|CallAfterReturn
argument_list|(
name|_VBUS_P
argument_list|(
argument|DPC_PROC
argument_list|)
name|pCmd
operator|->
name|pfnCompletion
argument_list|,
name|pCmd
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|pPRDTable
operator|=
operator|(
name|MV_SATA_EDMA_PRD_ENTRY
operator|*
operator|)
name|AllocatePRDTable
argument_list|(
name|pMvSataAdapter
operator|->
name|IALData
argument_list|)
expr_stmt|;
name|KdPrint
argument_list|(
operator|(
literal|"pPRDTable:%p\n"
operator|,
name|pPRDTable
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pPRDTable
condition|)
block|{
name|pCmd
operator|->
name|Result
operator|=
name|RETURN_DEVICE_BUSY
expr_stmt|;
name|CallAfterReturn
argument_list|(
name|_VBUS_P
argument_list|(
argument|DPC_PROC
argument_list|)
name|pCmd
operator|->
name|pfnCompletion
argument_list|,
name|pCmd
argument_list|)
expr_stmt|;
name|HPT_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
do|do
block|{
name|pPRDTable
index|[
name|i
index|]
operator|.
name|highBaseAddr
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|tmpSg
operator|->
name|dSgAddress
argument_list|)
operator|>
literal|4
condition|?
call|(
name|MV_U32
call|)
argument_list|(
name|tmpSg
operator|->
name|dSgAddress
operator|>>
literal|32
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
name|pPRDTable
index|[
name|i
index|]
operator|.
name|flags
operator|=
operator|(
name|MV_U16
operator|)
name|tmpSg
operator|->
name|wSgFlag
expr_stmt|;
name|pPRDTable
index|[
name|i
index|]
operator|.
name|byteCount
operator|=
operator|(
name|MV_U16
operator|)
name|tmpSg
operator|->
name|wSgSize
expr_stmt|;
name|pPRDTable
index|[
name|i
index|]
operator|.
name|lowBaseAddr
operator|=
operator|(
name|MV_U32
operator|)
name|tmpSg
operator|->
name|dSgAddress
expr_stmt|;
name|pPRDTable
index|[
name|i
index|]
operator|.
name|reserved
operator|=
literal|0
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|tmpSg
operator|++
operator|->
name|wSgFlag
operator|&
name|SG_FLAG_EOT
operator|)
operator|==
literal|0
condition|)
do|;
name|pUdmaParams
operator|->
name|prdLowAddr
operator|=
operator|(
name|ULONG
operator|)
name|fOsPhysicalAddress
argument_list|(
name|pPRDTable
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pUdmaParams
operator|->
name|numOfSectors
operator|==
literal|256
operator|)
operator|&&
operator|(
name|pMvSataChannel
operator|->
name|lba48Address
operator|==
name|MV_FALSE
operator|)
condition|)
block|{
name|pUdmaParams
operator|->
name|numOfSectors
operator|=
literal|0
expr_stmt|;
block|}
name|pCmd
operator|->
name|uScratch
operator|.
name|sata_param
operator|.
name|prdAddr
operator|=
operator|(
name|PVOID
operator|)
name|pPRDTable
expr_stmt|;
name|result
operator|=
name|mvSataQueueCommand
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channel
argument_list|,
operator|&
name|commandInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|MV_QUEUE_COMMAND_RESULT_OK
condition|)
block|{
name|queue_failed
label|:
switch|switch
condition|(
name|result
condition|)
block|{
case|case
name|MV_QUEUE_COMMAND_RESULT_BAD_LBA_ADDRESS
case|:
name|MV_ERROR
argument_list|(
literal|"IAL Error: Edma Queue command failed. Bad LBA "
literal|"LBA[31:0](0x%08x)\n"
argument_list|,
name|pUdmaParams
operator|->
name|lowLBAAddress
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Result
operator|=
name|RETURN_IDE_ERROR
expr_stmt|;
break|break;
case|case
name|MV_QUEUE_COMMAND_RESULT_QUEUED_MODE_DISABLED
case|:
name|MV_ERROR
argument_list|(
literal|"IAL Error: Edma Queue command failed. EDMA"
literal|" disabled adapter %d channel %d\n"
argument_list|,
name|pMvSataAdapter
operator|->
name|adapterId
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|mvSataEnableChannelDma
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Result
operator|=
name|RETURN_IDE_ERROR
expr_stmt|;
break|break;
case|case
name|MV_QUEUE_COMMAND_RESULT_FULL
case|:
name|MV_ERROR
argument_list|(
literal|"IAL Error: Edma Queue command failed. Queue is"
literal|" Full adapter %d channel %d\n"
argument_list|,
name|pMvSataAdapter
operator|->
name|adapterId
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Result
operator|=
name|RETURN_DEVICE_BUSY
expr_stmt|;
break|break;
case|case
name|MV_QUEUE_COMMAND_RESULT_BAD_PARAMS
case|:
name|MV_ERROR
argument_list|(
literal|"IAL Error: Edma Queue command failed. (Bad "
literal|"Params), pMvSataAdapter: %p,  pSataChannel: %p.\n"
argument_list|,
name|pMvSataAdapter
argument_list|,
name|pMvSataAdapter
operator|->
name|sataChannel
index|[
name|channel
index|]
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Result
operator|=
name|RETURN_IDE_ERROR
expr_stmt|;
break|break;
default|default:
name|MV_ERROR
argument_list|(
literal|"IAL Error: Bad result value (%d) from queue"
literal|" command\n"
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Result
operator|=
name|RETURN_IDE_ERROR
expr_stmt|;
block|}
if|if
condition|(
name|pPRDTable
condition|)
name|FreePRDTable
argument_list|(
name|pMvSataAdapter
operator|->
name|IALData
argument_list|,
name|pPRDTable
argument_list|)
expr_stmt|;
name|CallAfterReturn
argument_list|(
name|_VBUS_P
argument_list|(
argument|DPC_PROC
argument_list|)
name|pCmd
operator|->
name|pfnCompletion
argument_list|,
name|pCmd
argument_list|)
expr_stmt|;
block|}
name|pDevice
operator|->
name|QueueLength
operator|++
expr_stmt|;
return|return;
case|case
name|IDE_COMMAND_VERIFY
case|:
name|commandInfo
operator|.
name|type
operator|=
name|MV_QUEUED_COMMAND_TYPE_NONE_UDMA
expr_stmt|;
name|pNoUdmaParams
operator|->
name|bufPtr
operator|=
name|NULL
expr_stmt|;
name|pNoUdmaParams
operator|->
name|callBack
operator|=
name|CommandCompletionCB
expr_stmt|;
name|pNoUdmaParams
operator|->
name|commandId
operator|=
operator|(
name|MV_VOID_PTR
operator|)
name|pCmd
expr_stmt|;
name|pNoUdmaParams
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|pNoUdmaParams
operator|->
name|features
operator|=
literal|0
expr_stmt|;
name|pNoUdmaParams
operator|->
name|protocolType
operator|=
name|MV_NON_UDMA_PROTOCOL_NON_DATA
expr_stmt|;
name|pCmd
operator|->
name|uScratch
operator|.
name|sata_param
operator|.
name|cmd_priv
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pMvSataChannel
operator|->
name|lba48Address
operator|==
name|MV_TRUE
condition|)
block|{
name|pNoUdmaParams
operator|->
name|command
operator|=
name|MV_ATA_COMMAND_READ_VERIFY_SECTORS_EXT
expr_stmt|;
name|pNoUdmaParams
operator|->
name|isEXT
operator|=
name|MV_TRUE
expr_stmt|;
name|pNoUdmaParams
operator|->
name|lbaHigh
operator|=
call|(
name|MV_U16
call|)
argument_list|(
operator|(
name|Lba
operator|&
literal|0xff0000
operator|)
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|pNoUdmaParams
operator|->
name|lbaMid
operator|=
call|(
name|MV_U16
call|)
argument_list|(
operator|(
name|Lba
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|pNoUdmaParams
operator|->
name|lbaLow
operator|=
call|(
name|MV_U16
call|)
argument_list|(
operator|(
operator|(
name|Lba
operator|&
literal|0xff000000
operator|)
operator|>>
literal|16
operator|)
operator||
operator|(
name|Lba
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
name|pNoUdmaParams
operator|->
name|sectorCount
operator|=
name|nSector
expr_stmt|;
name|pNoUdmaParams
operator|->
name|device
operator|=
literal|0x40
expr_stmt|;
name|result
operator|=
name|mvSataQueueCommand
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channel
argument_list|,
operator|&
name|commandInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|MV_QUEUE_COMMAND_RESULT_OK
condition|)
block|{
goto|goto
name|queue_failed
goto|;
block|}
return|return;
block|}
else|else
block|{
name|pNoUdmaParams
operator|->
name|command
operator|=
name|MV_ATA_COMMAND_READ_VERIFY_SECTORS
expr_stmt|;
name|pNoUdmaParams
operator|->
name|isEXT
operator|=
name|MV_FALSE
expr_stmt|;
name|pNoUdmaParams
operator|->
name|lbaHigh
operator|=
call|(
name|MV_U16
call|)
argument_list|(
operator|(
name|Lba
operator|&
literal|0xff0000
operator|)
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|pNoUdmaParams
operator|->
name|lbaMid
operator|=
call|(
name|MV_U16
call|)
argument_list|(
operator|(
name|Lba
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|pNoUdmaParams
operator|->
name|lbaLow
operator|=
call|(
name|MV_U16
call|)
argument_list|(
name|Lba
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|pNoUdmaParams
operator|->
name|sectorCount
operator|=
literal|0xff
operator|&
name|nSector
expr_stmt|;
name|pNoUdmaParams
operator|->
name|device
operator|=
call|(
name|MV_U8
call|)
argument_list|(
literal|0x40
operator||
operator|(
operator|(
name|Lba
operator|&
literal|0xf000000
operator|)
operator|>>
literal|24
operator|)
argument_list|)
expr_stmt|;
name|pNoUdmaParams
operator|->
name|callBack
operator|=
name|CommandCompletionCB
expr_stmt|;
name|result
operator|=
name|mvSataQueueCommand
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channel
argument_list|,
operator|&
name|commandInfo
argument_list|)
expr_stmt|;
comment|/*FIXME: how about the commands already queued? but marvel also forgets to consider this*/
if|if
condition|(
name|result
operator|!=
name|MV_QUEUE_COMMAND_RESULT_OK
condition|)
block|{
goto|goto
name|queue_failed
goto|;
block|}
block|}
break|break;
default|default:
name|pCmd
operator|->
name|Result
operator|=
name|RETURN_INVALID_REQUEST
expr_stmt|;
name|CallAfterReturn
argument_list|(
name|_VBUS_P
argument_list|(
argument|DPC_PROC
argument_list|)
name|pCmd
operator|->
name|pfnCompletion
argument_list|,
name|pCmd
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/**********************************************************  *  *	Probe the hostadapter.  *  **********************************************************/
end_comment

begin_function
specifier|static
name|int
name|hpt_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
operator|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|==
name|MV_SATA_VENDOR_ID
operator|)
operator|&&
operator|(
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|MV_SATA_DEVICE_ID_5081
ifdef|#
directive|ifdef
name|FOR_DEMO
operator|||
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|MV_SATA_DEVICE_ID_5080
endif|#
directive|endif
operator|)
condition|)
block|{
name|KdPrintI
argument_list|(
operator|(
name|CONTROLLER_NAME
literal|" found\n"
operator|)
argument_list|)
expr_stmt|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|CONTROLLER_NAME
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/***********************************************************  *  *      Auto configuration:  attach and init a host adapter.  *  ***********************************************************/
end_comment

begin_function
specifier|static
name|int
name|hpt_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|hpt_vsim
decl_stmt|;
name|printf
argument_list|(
literal|"%s Version %s \n"
argument_list|,
name|DRIVER_NAME
argument_list|,
name|DRIVER_VERSION
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pAdapter
condition|)
block|{
name|pAdapter
operator|=
operator|(
name|IAL_ADAPTER_T
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|IAL_ADAPTER_T
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>
literal|410000
name|device_set_softc
argument_list|(
name|dev
argument_list|,
operator|(
name|void
operator|*
operator|)
name|pAdapter
argument_list|)
expr_stmt|;
else|#
directive|else
name|device_set_driver
argument_list|(
name|dev
argument_list|,
operator|(
name|driver_t
operator|*
operator|)
name|pAdapter
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
name|pAdapter
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|bzero
argument_list|(
name|pAdapter
argument_list|,
sizeof|sizeof
argument_list|(
name|IAL_ADAPTER_T
argument_list|)
argument_list|)
expr_stmt|;
name|pAdapter
operator|->
name|hpt_dev
operator|=
name|dev
expr_stmt|;
name|rid
operator|=
name|init_adapter
argument_list|(
name|pAdapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|rid
condition|)
return|return
name|rid
return|;
name|rid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|pAdapter
operator|->
name|hpt_irq
operator|=
name|bus_alloc_resource
argument_list|(
name|pAdapter
operator|->
name|hpt_dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0ul
argument_list|,
literal|1
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|hpt_printk
argument_list|(
operator|(
literal|"can't allocate interrupt\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|700000
if|if
condition|(
name|bus_setup_intr
argument_list|(
name|pAdapter
operator|->
name|hpt_dev
argument_list|,
name|pAdapter
operator|->
name|hpt_irq
argument_list|,
name|INTR_TYPE_CAM
argument_list|,
name|hpt_intr
argument_list|,
name|pAdapter
argument_list|,
operator|&
name|pAdapter
operator|->
name|hpt_intr
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
name|bus_setup_intr
argument_list|(
name|pAdapter
operator|->
name|hpt_dev
argument_list|,
name|pAdapter
operator|->
name|hpt_irq
argument_list|,
name|INTR_TYPE_CAM
argument_list|,
name|NULL
argument_list|,
name|hpt_intr
argument_list|,
name|pAdapter
argument_list|,
operator|&
name|pAdapter
operator|->
name|hpt_intr
argument_list|)
condition|)
endif|#
directive|endif
block|{
name|hpt_printk
argument_list|(
operator|(
literal|"can't set up interrupt\n"
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pAdapter
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ccb
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
operator|)
operator|!=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|NULL
condition|)
block|{
name|bzero
argument_list|(
name|ccb
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ccb
argument_list|)
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|pinfo
operator|.
name|priority
operator|=
literal|1
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|pinfo
operator|.
name|index
operator|=
name|CAM_UNQUEUED_INDEX
expr_stmt|;
block|}
else|else
block|{
return|return
name|ENOMEM
return|;
block|}
comment|/* 	 * Create the device queue for our SIM(s). 	 */
if|if
condition|(
operator|(
name|devq
operator|=
name|cam_simq_alloc
argument_list|(
literal|8
comment|/*MAX_QUEUE_COMM*/
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|KdPrint
argument_list|(
operator|(
literal|"ENXIO\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
comment|/* 	 * Construct our SIM entry 	 */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|700000
name|hpt_vsim
operator|=
name|cam_sim_alloc
argument_list|(
name|hpt_action
argument_list|,
name|hpt_poll
argument_list|,
name|__str
argument_list|(
name|PROC_DIR_NAME
argument_list|)
argument_list|,
name|pAdapter
argument_list|,
name|device_get_unit
argument_list|(
name|pAdapter
operator|->
name|hpt_dev
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|8
argument_list|,
name|devq
argument_list|)
expr_stmt|;
else|#
directive|else
name|hpt_vsim
operator|=
name|cam_sim_alloc
argument_list|(
name|hpt_action
argument_list|,
name|hpt_poll
argument_list|,
name|__str
argument_list|(
name|PROC_DIR_NAME
argument_list|)
argument_list|,
name|pAdapter
argument_list|,
name|device_get_unit
argument_list|(
name|pAdapter
operator|->
name|hpt_dev
argument_list|)
argument_list|,
operator|&
name|Giant
argument_list|,
literal|1
argument_list|,
literal|8
argument_list|,
name|devq
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|hpt_vsim
operator|==
name|NULL
condition|)
block|{
name|cam_simq_free
argument_list|(
name|devq
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|700000
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|hpt_vsim
argument_list|,
literal|0
argument_list|)
operator|!=
name|CAM_SUCCESS
condition|)
else|#
directive|else
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|hpt_vsim
argument_list|,
name|dev
argument_list|,
literal|0
argument_list|)
operator|!=
name|CAM_SUCCESS
condition|)
endif|#
directive|endif
block|{
name|cam_sim_free
argument_list|(
name|hpt_vsim
argument_list|,
comment|/*free devq*/
name|TRUE
argument_list|)
expr_stmt|;
name|hpt_vsim
operator|=
name|NULL
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|pAdapter
operator|->
name|path
argument_list|,
comment|/*periph */
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|hpt_vsim
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|hpt_vsim
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|hpt_vsim
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
name|hpt_vsim
operator|=
name|NULL
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|xpt_setup_ccb
argument_list|(
operator|&
operator|(
name|ccb
operator|->
name|ccb_h
operator|)
argument_list|,
name|pAdapter
operator|->
name|path
argument_list|,
comment|/*priority*/
literal|5
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SASYNC_CB
expr_stmt|;
name|ccb
operator|->
name|csa
operator|.
name|event_enable
operator|=
name|AC_LOST_DEVICE
expr_stmt|;
name|ccb
operator|->
name|csa
operator|.
name|callback
operator|=
name|hpt_async
expr_stmt|;
name|ccb
operator|->
name|csa
operator|.
name|callback_arg
operator|=
name|hpt_vsim
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|ccb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ccb
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_get_unit
argument_list|(
name|dev
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Start the work thread.  XXX */
name|launch_worker_thread
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hpt_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
end_function

begin_comment
comment|/***************************************************************  * The poll function is used to simulate the interrupt when  * the interrupt subsystem is not functioning.  *  ***************************************************************/
end_comment

begin_function
specifier|static
name|void
name|hpt_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
block|{
name|hpt_intr
argument_list|(
operator|(
name|void
operator|*
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************  *	Name:	hpt_intr  *	Description:	Interrupt handler.  ****************************************************************/
end_comment

begin_function
specifier|static
name|void
name|hpt_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
init|=
operator|(
name|IAL_ADAPTER_T
operator|*
operator|)
name|arg
decl_stmt|;
name|intrmask_t
name|oldspl
init|=
name|lock_driver
argument_list|()
decl_stmt|;
comment|/* KdPrintI(("----- Entering Isr() -----\n")); */
if|if
condition|(
name|mvSataInterruptServiceRoutine
argument_list|(
operator|&
name|pAdapter
operator|->
name|mvSataAdapter
argument_list|)
operator|==
name|MV_TRUE
condition|)
block|{
name|_VBUS_INST
argument_list|(
argument|&pAdapter->VBus
argument_list|)
name|CheckPendingCall
argument_list|(
name|_VBUS_P0
argument_list|)
expr_stmt|;
block|}
comment|/* KdPrintI(("----- Leaving Isr() -----\n")); */
name|unlock_driver
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************  * 			Asynchronous Events  *********************************************************/
end_comment

begin_if
if|#
directive|if
operator|(
operator|!
name|defined
argument_list|(
name|UNREFERENCED_PARAMETER
argument_list|)
operator|)
end_if

begin_define
define|#
directive|define
name|UNREFERENCED_PARAMETER
parameter_list|(
name|x
parameter_list|)
value|(void)(x)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|hpt_async
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|u_int32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
comment|/* debug XXXX */
name|panic
argument_list|(
literal|"Here"
argument_list|)
expr_stmt|;
name|UNREFERENCED_PARAMETER
argument_list|(
name|callback_arg
argument_list|)
expr_stmt|;
name|UNREFERENCED_PARAMETER
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|UNREFERENCED_PARAMETER
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|UNREFERENCED_PARAMETER
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|FlushAdapter
parameter_list|(
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|hpt_printk
argument_list|(
operator|(
literal|"flush all devices\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* flush all devices */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_VDEVICE_PER_VBUS
condition|;
name|i
operator|++
control|)
block|{
name|PVDevice
name|pVDev
init|=
name|pAdapter
operator|->
name|VBus
operator|.
name|pVDevice
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|pVDev
condition|)
name|fFlushVDev
argument_list|(
name|pVDev
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|hpt_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
decl_stmt|;
name|pAdapter
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|pAdapter
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|shutdown_final
argument_list|,
name|pAdapter
operator|->
name|eh
argument_list|)
expr_stmt|;
name|FlushAdapter
argument_list|(
name|pAdapter
argument_list|)
expr_stmt|;
comment|/* give the flush some time to happen,  		    *otherwise "shutdown -p now" will make file system corrupted */
name|DELAY
argument_list|(
literal|1000
operator|*
literal|1000
operator|*
literal|5
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|Check_Idle_Call
parameter_list|(
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
parameter_list|)
block|{
name|_VBUS_INST
argument_list|(
argument|&pAdapter->VBus
argument_list|)
if|if
condition|(
name|mWaitingForIdle
argument_list|(
name|_VBUS_P0
argument_list|)
condition|)
block|{
name|CheckIdleCall
argument_list|(
name|_VBUS_P0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_ARRAY
block|{
name|int
name|i
decl_stmt|;
name|PVDevice
name|pArray
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_ARRAY_PER_VBUS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|pArray
operator|=
name|ArrayTables
argument_list|(
name|i
argument_list|)
operator|)
operator|->
name|u
operator|.
name|array
operator|.
name|dArStamp
operator|==
literal|0
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|pArray
operator|->
name|u
operator|.
name|array
operator|.
name|rf_auto_rebuild
condition|)
block|{
name|KdPrint
argument_list|(
operator|(
literal|"auto rebuild.\n"
operator|)
argument_list|)
expr_stmt|;
name|pArray
operator|->
name|u
operator|.
name|array
operator|.
name|rf_auto_rebuild
operator|=
literal|0
expr_stmt|;
name|hpt_queue_dpc
argument_list|(
operator|(
name|HPT_DPC
operator|)
name|hpt_rebuild_data_block
argument_list|,
name|pAdapter
argument_list|,
name|pArray
argument_list|,
name|DUPLICATE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
block|}
comment|/* launch the awaiting commands blocked by mWaitingForIdle */
while|while
condition|(
name|pAdapter
operator|->
name|pending_Q
operator|!=
name|NULL
condition|)
block|{
name|_VBUS_INST
argument_list|(
argument|&pAdapter->VBus
argument_list|)
name|union
name|ccb
modifier|*
name|ccb
init|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|pAdapter
operator|->
name|pending_Q
operator|->
name|ccb_h
operator|.
name|ccb_ccb_ptr
decl_stmt|;
name|hpt_free_ccb
argument_list|(
operator|&
name|pAdapter
operator|->
name|pending_Q
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
name|CallAfterReturn
argument_list|(
name|_VBUS_P
argument_list|(
argument|DPC_PROC
argument_list|)
name|OsSendCommand
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ccb_done
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|PBUS_DMAMAP
name|pmap
init|=
operator|(
name|PBUS_DMAMAP
operator|)
name|ccb
operator|->
name|ccb_adapter
decl_stmt|;
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
init|=
name|pmap
operator|->
name|pAdapter
decl_stmt|;
name|KdPrintI
argument_list|(
operator|(
literal|"ccb_done: ccb %p status %x\n"
operator|,
name|ccb
operator|,
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|)
argument_list|)
expr_stmt|;
name|dmamap_put
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|pAdapter
operator|->
name|outstandingCommands
operator|--
expr_stmt|;
if|if
condition|(
name|pAdapter
operator|->
name|outstandingCommands
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|DPC_Request_Nums
operator|==
literal|0
condition|)
name|Check_Idle_Call
argument_list|(
name|pAdapter
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/****************************************************************  *	Name:	hpt_action  *	Description:	Process a queued command from the CAM layer.  *	Parameters:		sim - Pointer to SIM object  *					ccb - Pointer to SCSI command structure.  ****************************************************************/
end_comment

begin_function
name|void
name|hpt_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|intrmask_t
name|oldspl
decl_stmt|;
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
init|=
operator|(
name|IAL_ADAPTER_T
operator|*
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
decl_stmt|;
name|PBUS_DMAMAP
name|pmap
decl_stmt|;
name|_VBUS_INST
argument_list|(
argument|&pAdapter->VBus
argument_list|)
name|CAM_DEBUG
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"hpt_action\n"
operator|)
argument_list|)
expr_stmt|;
name|KdPrint
argument_list|(
operator|(
literal|"hpt_action(%lx,%lx{%x})\n"
operator|,
operator|(
name|u_long
operator|)
name|sim
operator|,
operator|(
name|u_long
operator|)
name|ccb
operator|,
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_SCSI_IO
case|:
comment|/* Execute the requested I/O operation */
block|{
comment|/* ccb->ccb_h.path_id is not our bus id - don't check it */
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_LUN_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|>=
name|MAX_VDEVICE_PER_VBUS
operator|||
name|pAdapter
operator|->
name|VBus
operator|.
name|pVDevice
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
operator|==
literal|0
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_TID_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|oldspl
operator|=
name|lock_driver
argument_list|()
expr_stmt|;
if|if
condition|(
name|pAdapter
operator|->
name|outstandingCommands
operator|==
literal|0
operator|&&
name|DPC_Request_Nums
operator|==
literal|0
condition|)
name|Check_Idle_Call
argument_list|(
name|pAdapter
argument_list|)
expr_stmt|;
name|pmap
operator|=
name|dmamap_get
argument_list|(
name|pAdapter
argument_list|)
expr_stmt|;
name|HPT_ASSERT
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_adapter
operator|=
name|pmap
expr_stmt|;
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
name|pmap
operator|->
name|psg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pmap
operator|->
name|psg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mWaitingForIdle
argument_list|(
name|_VBUS_P0
argument_list|)
condition|)
name|hpt_queue_ccb
argument_list|(
operator|&
name|pAdapter
operator|->
name|pending_Q
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
else|else
name|OsSendCommand
argument_list|(
argument|_VBUS_P ccb
argument_list|)
empty_stmt|;
name|unlock_driver
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
comment|/* KdPrint(("leave scsiio\n")); */
break|break;
block|}
case|case
name|XPT_RESET_BUS
case|:
name|KdPrint
argument_list|(
operator|(
literal|"reset bus\n"
operator|)
argument_list|)
expr_stmt|;
name|oldspl
operator|=
name|lock_driver
argument_list|()
expr_stmt|;
name|fResetVBus
argument_list|(
name|_VBUS_P0
argument_list|)
expr_stmt|;
name|unlock_driver
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_RESET_DEV
case|:
comment|/* Bus Device Reset the specified SCSI device */
case|case
name|XPT_EN_LUN
case|:
comment|/* Enable LUN as a target */
case|case
name|XPT_TARGET_IO
case|:
comment|/* Execute target I/O request */
case|case
name|XPT_ACCEPT_TARGET_IO
case|:
comment|/* Accept Host Target Mode CDB */
case|case
name|XPT_CONT_TARGET_IO
case|:
comment|/* Continue Host Target I/O Connection*/
case|case
name|XPT_ABORT
case|:
comment|/* Abort the specified CCB */
case|case
name|XPT_TERM_IO
case|:
comment|/* Terminate the I/O process */
comment|/* XXX Implement */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_GET_TRAN_SETTINGS
case|:
case|case
name|XPT_SET_TRAN_SETTINGS
case|:
comment|/* XXX Implement */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_FUNC_NOTAVAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_CALC_GEOMETRY
case|:
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|cam_calc_geometry
argument_list|(
operator|&
name|ccb
operator|->
name|ccg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
block|{
name|struct
name|ccb_calc_geometry
modifier|*
name|ccg
decl_stmt|;
name|u_int32_t
name|size_mb
decl_stmt|;
name|u_int32_t
name|secs_per_cylinder
decl_stmt|;
name|ccg
operator|=
operator|&
name|ccb
operator|->
name|ccg
expr_stmt|;
name|size_mb
operator|=
name|ccg
operator|->
name|volume_size
operator|/
operator|(
operator|(
literal|1024L
operator|*
literal|1024L
operator|)
operator|/
name|ccg
operator|->
name|block_size
operator|)
expr_stmt|;
if|if
condition|(
name|size_mb
operator|>
literal|1024
condition|)
block|{
name|ccg
operator|->
name|heads
operator|=
literal|255
expr_stmt|;
name|ccg
operator|->
name|secs_per_track
operator|=
literal|63
expr_stmt|;
block|}
else|else
block|{
name|ccg
operator|->
name|heads
operator|=
literal|64
expr_stmt|;
name|ccg
operator|->
name|secs_per_track
operator|=
literal|32
expr_stmt|;
block|}
name|secs_per_cylinder
operator|=
name|ccg
operator|->
name|heads
operator|*
name|ccg
operator|->
name|secs_per_track
expr_stmt|;
name|ccg
operator|->
name|cylinders
operator|=
name|ccg
operator|->
name|volume_size
operator|/
name|secs_per_cylinder
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
block|}
endif|#
directive|endif
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_PATH_INQ
case|:
comment|/* Path routing inquiry */
block|{
name|struct
name|ccb_pathinq
modifier|*
name|cpi
init|=
operator|&
name|ccb
operator|->
name|cpi
decl_stmt|;
name|cpi
operator|->
name|version_num
operator|=
literal|1
expr_stmt|;
comment|/* XXX??? */
name|cpi
operator|->
name|hba_inquiry
operator|=
name|PI_SDTR_ABLE
expr_stmt|;
name|cpi
operator|->
name|target_sprt
operator|=
literal|0
expr_stmt|;
comment|/* Not necessary to reset bus */
name|cpi
operator|->
name|hba_misc
operator|=
name|PIM_NOBUSRESET
expr_stmt|;
name|cpi
operator|->
name|hba_eng_cnt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|max_target
operator|=
name|MAX_VDEVICE_PER_VBUS
expr_stmt|;
name|cpi
operator|->
name|max_lun
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|initiator_id
operator|=
name|MAX_VDEVICE_PER_VBUS
expr_stmt|;
name|cpi
operator|->
name|bus_id
operator|=
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|base_transfer_speed
operator|=
literal|3300
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|sim_vid
argument_list|,
literal|"FreeBSD"
argument_list|,
name|SIM_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|hba_vid
argument_list|,
literal|"HPT   "
argument_list|,
name|HBA_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|dev_name
argument_list|,
name|cam_sim_name
argument_list|(
name|sim
argument_list|)
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|unit_number
operator|=
name|cam_sim_unit
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|transport
operator|=
name|XPORT_SPI
expr_stmt|;
name|cpi
operator|->
name|transport_version
operator|=
literal|2
expr_stmt|;
name|cpi
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cpi
operator|->
name|protocol_version
operator|=
name|SCSI_REV_2
expr_stmt|;
name|cpi
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|KdPrint
argument_list|(
operator|(
literal|"invalid cmd\n"
operator|)
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* KdPrint(("leave hpt_action..............\n")); */
block|}
end_function

begin_comment
comment|/* shall be called at lock_driver() */
end_comment

begin_function
specifier|static
name|void
name|hpt_queue_ccb
parameter_list|(
name|union
name|ccb
modifier|*
modifier|*
name|ccb_Q
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
if|if
condition|(
operator|*
name|ccb_Q
operator|==
name|NULL
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_ccb_ptr
operator|=
name|ccb
expr_stmt|;
else|else
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_ccb_ptr
operator|=
operator|(
operator|*
name|ccb_Q
operator|)
operator|->
name|ccb_h
operator|.
name|ccb_ccb_ptr
expr_stmt|;
operator|(
operator|*
name|ccb_Q
operator|)
operator|->
name|ccb_h
operator|.
name|ccb_ccb_ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|ccb
expr_stmt|;
block|}
operator|*
name|ccb_Q
operator|=
name|ccb
expr_stmt|;
block|}
end_function

begin_comment
comment|/* shall be called at lock_driver() */
end_comment

begin_function
specifier|static
name|void
name|hpt_free_ccb
parameter_list|(
name|union
name|ccb
modifier|*
modifier|*
name|ccb_Q
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|TempCCB
decl_stmt|;
name|TempCCB
operator|=
operator|*
name|ccb_Q
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_ccb_ptr
operator|==
name|ccb
condition|)
comment|/*it means SCpnt is the last one in CURRCMDs*/
operator|*
name|ccb_Q
operator|=
name|NULL
expr_stmt|;
else|else
block|{
while|while
condition|(
name|TempCCB
operator|->
name|ccb_h
operator|.
name|ccb_ccb_ptr
operator|!=
operator|(
name|char
operator|*
operator|)
name|ccb
condition|)
name|TempCCB
operator|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|TempCCB
operator|->
name|ccb_h
operator|.
name|ccb_ccb_ptr
expr_stmt|;
name|TempCCB
operator|->
name|ccb_h
operator|.
name|ccb_ccb_ptr
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_ccb_ptr
expr_stmt|;
if|if
condition|(
operator|*
name|ccb_Q
operator|==
name|ccb
condition|)
operator|*
name|ccb_Q
operator|=
name|TempCCB
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SUPPORT_ARRAY
end_ifdef

begin_comment
comment|/***************************************************************************  * Function:     hpt_worker_thread  * Description:  Do background rebuilding. Execute in kernel thread context.  * Returns:      None  ***************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|hpt_worker_thread
parameter_list|(
name|void
parameter_list|)
block|{
name|intrmask_t
name|oldspl
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
name|DpcQueue_First
operator|!=
name|DpcQueue_Last
condition|)
block|{
name|ST_HPT_DPC
name|p
decl_stmt|;
name|oldspl
operator|=
name|lock_driver
argument_list|()
expr_stmt|;
name|p
operator|=
name|DpcQueue
index|[
name|DpcQueue_First
index|]
expr_stmt|;
name|DpcQueue_First
operator|++
expr_stmt|;
name|DpcQueue_First
operator|%=
name|MAX_DPC
expr_stmt|;
name|DPC_Request_Nums
operator|++
expr_stmt|;
name|unlock_driver
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
name|p
operator|.
name|dpc
argument_list|(
name|p
operator|.
name|pAdapter
argument_list|,
name|p
operator|.
name|arg
argument_list|,
name|p
operator|.
name|flags
argument_list|)
expr_stmt|;
name|oldspl
operator|=
name|lock_driver
argument_list|()
expr_stmt|;
name|DPC_Request_Nums
operator|--
expr_stmt|;
comment|/* since we may have prevented Check_Idle_Call, do it here */
if|if
condition|(
name|DPC_Request_Nums
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|p
operator|.
name|pAdapter
operator|->
name|outstandingCommands
operator|==
literal|0
condition|)
block|{
name|_VBUS_INST
argument_list|(
operator|&
name|p
operator|.
name|pAdapter
operator|->
name|VBus
argument_list|)
expr_stmt|;
name|Check_Idle_Call
argument_list|(
name|p
operator|.
name|pAdapter
argument_list|)
expr_stmt|;
name|CheckPendingCall
argument_list|(
name|_VBUS_P0
argument_list|)
expr_stmt|;
block|}
block|}
name|unlock_driver
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
comment|/*Schedule out*/
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|<
literal|500000
operator|)
name|YIELD_THREAD
expr_stmt|;
else|#
directive|else
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>
literal|700033
operator|)
name|pause
argument_list|(
literal|"sched"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|hpt_worker_thread
argument_list|,
name|PPAUSE
argument_list|,
literal|"sched"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|SIGISMEMBER
argument_list|(
name|curproc
operator|->
name|p_siglist
argument_list|,
name|SIGSTOP
argument_list|)
condition|)
block|{
comment|/* abort rebuilding process. */
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
decl_stmt|;
name|PVDevice
name|pArray
decl_stmt|;
name|PVBus
name|_vbus_p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|pAdapter
operator|=
name|gIal_Adapter
expr_stmt|;
while|while
condition|(
name|pAdapter
operator|!=
literal|0
condition|)
block|{
name|_vbus_p
operator|=
operator|&
name|pAdapter
operator|->
name|VBus
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_ARRAY_PER_VBUS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|pArray
operator|=
name|ArrayTables
argument_list|(
name|i
argument_list|)
operator|)
operator|->
name|u
operator|.
name|array
operator|.
name|dArStamp
operator|==
literal|0
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|pArray
operator|->
name|u
operator|.
name|array
operator|.
name|rf_rebuilding
operator|||
name|pArray
operator|->
name|u
operator|.
name|array
operator|.
name|rf_verifying
operator|||
name|pArray
operator|->
name|u
operator|.
name|array
operator|.
name|rf_initializing
condition|)
block|{
name|pArray
operator|->
name|u
operator|.
name|array
operator|.
name|rf_abort_rebuild
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|pAdapter
operator|=
name|pAdapter
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
comment|/*Remove this debug option*/
comment|/* #ifdef DEBUG 		if (SIGISMEMBER(curproc->p_siglist, SIGSTOP)) #if (__FreeBSD_version> 700033) 			pause("hptrdy", 2*hz); #else 			tsleep((caddr_t)hpt_worker_thread, PPAUSE, "hptrdy", 2*hz); #endif #endif */
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|800002
operator|)
name|kproc_suspend_check
argument_list|(
name|curproc
argument_list|)
expr_stmt|;
elif|#
directive|elif
operator|(
name|__FreeBSD_version
operator|>=
literal|500043
operator|)
name|kthread_suspend_check
argument_list|(
name|curproc
argument_list|)
expr_stmt|;
else|#
directive|else
name|kproc_suspend_loop
argument_list|(
name|curproc
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>
literal|700033
operator|)
name|pause
argument_list|(
literal|"hptrdy"
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
comment|/* wait for something to do */
else|#
directive|else
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|hpt_worker_thread
argument_list|,
name|PPAUSE
argument_list|,
literal|"hptrdy"
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
comment|/* wait for something to do */
endif|#
directive|endif
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|proc
modifier|*
name|hptdaemonproc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|kproc_desc
name|hpt_kp
init|=
block|{
literal|"hpt_wt"
block|,
name|hpt_worker_thread
block|,
operator|&
name|hptdaemonproc
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*Start this thread in the hpt_attach, to prevent kernel from loading it without our controller.*/
end_comment

begin_function
specifier|static
name|void
name|launch_worker_thread
parameter_list|(
name|void
parameter_list|)
block|{
name|IAL_ADAPTER_T
modifier|*
name|pAdapTemp
decl_stmt|;
name|kproc_start
argument_list|(
operator|&
name|hpt_kp
argument_list|)
expr_stmt|;
for|for
control|(
name|pAdapTemp
operator|=
name|gIal_Adapter
init|;
name|pAdapTemp
condition|;
name|pAdapTemp
operator|=
name|pAdapTemp
operator|->
name|next
control|)
block|{
name|_VBUS_INST
argument_list|(
argument|&pAdapTemp->VBus
argument_list|)
name|int
name|i
decl_stmt|;
name|PVDevice
name|pVDev
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_ARRAY_PER_VBUS
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|pVDev
operator|=
name|ArrayTables
argument_list|(
name|i
argument_list|)
operator|)
operator|->
name|u
operator|.
name|array
operator|.
name|dArStamp
operator|==
literal|0
condition|)
continue|continue;
else|else
block|{
if|if
condition|(
name|pVDev
operator|->
name|u
operator|.
name|array
operator|.
name|rf_need_rebuild
operator|&&
operator|!
name|pVDev
operator|->
name|u
operator|.
name|array
operator|.
name|rf_rebuilding
condition|)
name|hpt_queue_dpc
argument_list|(
operator|(
name|HPT_DPC
operator|)
name|hpt_rebuild_data_block
argument_list|,
name|pAdapTemp
argument_list|,
name|pVDev
argument_list|,
call|(
name|UCHAR
call|)
argument_list|(
operator|(
name|pVDev
operator|->
name|u
operator|.
name|array
operator|.
name|CriticalMembers
operator|||
name|pVDev
operator|->
name|VDeviceType
operator|==
name|VD_RAID_1
operator|)
condition|?
name|DUPLICATE
else|:
name|REBUILD_PARITY
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * hpt_worker_thread needs to be suspended after shutdown sync, when fs sync finished. 	 */
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|<
literal|500043
operator|)
name|EVENTHANDLER_REGISTER
argument_list|(
name|shutdown_post_sync
argument_list|,
name|shutdown_kproc
argument_list|,
name|hptdaemonproc
argument_list|,
name|SHUTDOWN_PRI_FIRST
argument_list|)
expr_stmt|;
else|#
directive|else
name|EVENTHANDLER_REGISTER
argument_list|(
name|shutdown_post_sync
argument_list|,
name|kproc_shutdown
argument_list|,
name|hptdaemonproc
argument_list|,
name|SHUTDOWN_PRI_FIRST
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  *SYSINIT(hptwt, SI_SUB_KTHREAD_IDLE, SI_ORDER_FIRST, launch_worker_thread, NULL); */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/********************************************************************************/
end_comment

begin_function
name|int
name|HPTLIBAPI
name|fOsBuildSgl
parameter_list|(
name|_VBUS_ARG
name|PCommand
name|pCmd
parameter_list|,
name|FPSCAT_GATH
name|pSg
parameter_list|,
name|int
name|logical
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
init|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|pCmd
operator|->
name|pOrgCommand
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|sgList
init|=
operator|(
name|bus_dma_segment_t
operator|*
operator|)
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
decl_stmt|;
name|int
name|idx
decl_stmt|;
if|if
condition|(
name|logical
condition|)
block|{
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DATA_PHYS
condition|)
name|panic
argument_list|(
literal|"physical address unsupported"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SCATTER_VALID
condition|)
block|{
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SG_LIST_PHYS
condition|)
name|panic
argument_list|(
literal|"physical address unsupported"
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|ccb
operator|->
name|csio
operator|.
name|sglist_cnt
condition|;
name|idx
operator|++
control|)
block|{
name|pSg
index|[
name|idx
index|]
operator|.
name|dSgAddress
operator|=
operator|(
name|ULONG_PTR
operator|)
operator|(
name|UCHAR
operator|*
operator|)
name|sgList
index|[
name|idx
index|]
operator|.
name|ds_addr
expr_stmt|;
name|pSg
index|[
name|idx
index|]
operator|.
name|wSgSize
operator|=
name|sgList
index|[
name|idx
index|]
operator|.
name|ds_len
expr_stmt|;
name|pSg
index|[
name|idx
index|]
operator|.
name|wSgFlag
operator|=
operator|(
name|idx
operator|==
name|ccb
operator|->
name|csio
operator|.
name|sglist_cnt
operator|-
literal|1
operator|)
condition|?
name|SG_FLAG_EOT
else|:
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|pSg
operator|->
name|dSgAddress
operator|=
operator|(
name|ULONG_PTR
operator|)
operator|(
name|UCHAR
operator|*
operator|)
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
expr_stmt|;
name|pSg
operator|->
name|wSgSize
operator|=
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
expr_stmt|;
name|pSg
operator|->
name|wSgFlag
operator|=
name|SG_FLAG_EOT
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
comment|/* since we have provided physical sg, nobody will ask us to build physical sg */
name|HPT_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|ULONG
name|HPTLIBAPI
name|GetStamp
parameter_list|(
name|void
parameter_list|)
block|{
comment|/*  	 * the system variable, ticks, can't be used since it hasn't yet been active  	 * when our driver starts (ticks==0, it's a invalid stamp value) 	 */
name|ULONG
name|stamp
decl_stmt|;
do|do
block|{
name|stamp
operator|=
name|random
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|stamp
operator|==
literal|0
condition|)
do|;
return|return
name|stamp
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|SetInquiryData
parameter_list|(
name|PINQUIRYDATA
name|inquiryData
parameter_list|,
name|PVDevice
name|pVDev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|IDENTIFY_DATA2
modifier|*
name|pIdentify
init|=
operator|(
name|IDENTIFY_DATA2
operator|*
operator|)
name|pVDev
operator|->
name|u
operator|.
name|disk
operator|.
name|mv
operator|->
name|identifyDevice
decl_stmt|;
name|inquiryData
operator|->
name|DeviceType
operator|=
name|T_DIRECT
expr_stmt|;
comment|/*DIRECT_ACCESS_DEVICE*/
name|inquiryData
operator|->
name|AdditionalLength
operator|=
call|(
name|UCHAR
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|INQUIRYDATA
argument_list|)
operator|-
literal|5
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SERIAL_CMDS
name|inquiryData
operator|->
name|CommandQueue
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|pVDev
operator|->
name|VDeviceType
condition|)
block|{
case|case
name|VD_SINGLE_DISK
case|:
case|case
name|VD_ATAPI
case|:
case|case
name|VD_REMOVABLE
case|:
comment|/* Set the removable bit, if applicable. */
if|if
condition|(
operator|(
name|pVDev
operator|->
name|u
operator|.
name|disk
operator|.
name|df_removable_drive
operator|)
operator|||
operator|(
name|pIdentify
operator|->
name|GeneralConfiguration
operator|&
literal|0x80
operator|)
condition|)
name|inquiryData
operator|->
name|RemovableMedia
operator|=
literal|1
expr_stmt|;
comment|/* Fill in vendor identification fields. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|inquiryData
operator|->
name|VendorId
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|PUCHAR
operator|)
name|pIdentify
operator|->
name|ModelNumber
operator|)
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|inquiryData
operator|->
name|VendorId
index|[
name|i
operator|+
literal|1
index|]
operator|=
operator|(
operator|(
name|PUCHAR
operator|)
name|pIdentify
operator|->
name|ModelNumber
operator|)
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* Initialize unused portion of product id. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|inquiryData
operator|->
name|ProductId
index|[
literal|12
operator|+
name|i
index|]
operator|=
literal|' '
expr_stmt|;
comment|/* firmware revision */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|inquiryData
operator|->
name|ProductRevisionLevel
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|PUCHAR
operator|)
name|pIdentify
operator|->
name|FirmwareRevision
operator|)
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|inquiryData
operator|->
name|ProductRevisionLevel
index|[
name|i
operator|+
literal|1
index|]
operator|=
operator|(
operator|(
name|PUCHAR
operator|)
name|pIdentify
operator|->
name|FirmwareRevision
operator|)
index|[
name|i
index|]
expr_stmt|;
block|}
break|break;
default|default:
name|memcpy
argument_list|(
operator|&
name|inquiryData
operator|->
name|VendorId
argument_list|,
literal|"RR18xx  "
argument_list|,
literal|8
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_ARRAY
switch|switch
condition|(
name|pVDev
operator|->
name|VDeviceType
condition|)
block|{
case|case
name|VD_RAID_0
case|:
if|if
condition|(
operator|(
name|pVDev
operator|->
name|u
operator|.
name|array
operator|.
name|pMember
index|[
literal|0
index|]
operator|&&
name|mIsArray
argument_list|(
name|pVDev
operator|->
name|u
operator|.
name|array
operator|.
name|pMember
index|[
literal|0
index|]
argument_list|)
operator|)
operator|||
operator|(
name|pVDev
operator|->
name|u
operator|.
name|array
operator|.
name|pMember
index|[
literal|1
index|]
operator|&&
name|mIsArray
argument_list|(
name|pVDev
operator|->
name|u
operator|.
name|array
operator|.
name|pMember
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
name|memcpy
argument_list|(
operator|&
name|inquiryData
operator|->
name|ProductId
argument_list|,
literal|"RAID 1/0 Array  "
argument_list|,
literal|16
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
operator|&
name|inquiryData
operator|->
name|ProductId
argument_list|,
literal|"RAID 0 Array    "
argument_list|,
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
name|VD_RAID_1
case|:
if|if
condition|(
operator|(
name|pVDev
operator|->
name|u
operator|.
name|array
operator|.
name|pMember
index|[
literal|0
index|]
operator|&&
name|mIsArray
argument_list|(
name|pVDev
operator|->
name|u
operator|.
name|array
operator|.
name|pMember
index|[
literal|0
index|]
argument_list|)
operator|)
operator|||
operator|(
name|pVDev
operator|->
name|u
operator|.
name|array
operator|.
name|pMember
index|[
literal|1
index|]
operator|&&
name|mIsArray
argument_list|(
name|pVDev
operator|->
name|u
operator|.
name|array
operator|.
name|pMember
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
name|memcpy
argument_list|(
operator|&
name|inquiryData
operator|->
name|ProductId
argument_list|,
literal|"RAID 0/1 Array  "
argument_list|,
literal|16
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
operator|&
name|inquiryData
operator|->
name|ProductId
argument_list|,
literal|"RAID 1 Array    "
argument_list|,
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
name|VD_RAID_5
case|:
name|memcpy
argument_list|(
operator|&
name|inquiryData
operator|->
name|ProductId
argument_list|,
literal|"RAID 5 Array    "
argument_list|,
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
name|VD_JBOD
case|:
name|memcpy
argument_list|(
operator|&
name|inquiryData
operator|->
name|ProductId
argument_list|,
literal|"JBOD Array      "
argument_list|,
literal|16
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
name|memcpy
argument_list|(
operator|&
name|inquiryData
operator|->
name|ProductRevisionLevel
argument_list|,
literal|"3.00"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hpt_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|_VBUS_INST
argument_list|(
argument|&((PBUS_DMAMAP)((union ccb *)arg)->ccb_adapter)->pAdapter->VBus
argument_list|)
name|intrmask_t
name|oldspl
init|=
name|lock_driver
argument_list|()
decl_stmt|;
name|fResetVBus
argument_list|(
name|_VBUS_P0
argument_list|)
expr_stmt|;
name|unlock_driver
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hpt_io_dmamap_callback
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|PCommand
name|pCmd
init|=
operator|(
name|PCommand
operator|)
name|arg
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
init|=
name|pCmd
operator|->
name|pOrgCommand
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
init|=
operator|&
name|ccb
operator|->
name|ccb_h
decl_stmt|;
name|PBUS_DMAMAP
name|pmap
init|=
operator|(
name|PBUS_DMAMAP
operator|)
name|ccb
operator|->
name|ccb_adapter
decl_stmt|;
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
init|=
name|pmap
operator|->
name|pAdapter
decl_stmt|;
name|PVDevice
name|pVDev
init|=
name|pAdapter
operator|->
name|VBus
operator|.
name|pVDevice
index|[
name|ccb_h
operator|->
name|target_id
index|]
decl_stmt|;
name|FPSCAT_GATH
name|psg
init|=
name|pCmd
operator|->
name|pSgTable
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|_VBUS_INST
argument_list|(
argument|pVDev->pVBus
argument_list|)
name|HPT_ASSERT
argument_list|(
name|pCmd
operator|->
name|cf_physical_sg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|nsegs
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"busdma error"
argument_list|)
expr_stmt|;
name|HPT_ASSERT
argument_list|(
name|nsegs
operator|<=
name|MAX_SG_DESCRIPTORS
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|nsegs
condition|;
name|idx
operator|++
operator|,
name|psg
operator|++
control|)
block|{
name|psg
operator|->
name|dSgAddress
operator|=
operator|(
name|ULONG_PTR
operator|)
operator|(
name|UCHAR
operator|*
operator|)
name|segs
index|[
name|idx
index|]
operator|.
name|ds_addr
expr_stmt|;
name|psg
operator|->
name|wSgSize
operator|=
name|segs
index|[
name|idx
index|]
operator|.
name|ds_len
expr_stmt|;
name|psg
operator|->
name|wSgFlag
operator|=
operator|(
name|idx
operator|==
name|nsegs
operator|-
literal|1
operator|)
condition|?
name|SG_FLAG_EOT
else|:
literal|0
expr_stmt|;
comment|/*		KdPrint(("psg[%d]:add=%p,size=%x,flag=%x\n", idx, psg->dSgAddress,psg->wSgSize,psg->wSgFlag)); */
block|}
comment|/*	psg[-1].wSgFlag = SG_FLAG_EOT; */
if|if
condition|(
name|pCmd
operator|->
name|cf_data_in
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|pAdapter
operator|->
name|io_dma_parent
argument_list|,
name|pmap
operator|->
name|dma_map
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pCmd
operator|->
name|cf_data_out
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|pAdapter
operator|->
name|io_dma_parent
argument_list|,
name|pmap
operator|->
name|dma_map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|hpt_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ccb
argument_list|,
literal|20
operator|*
name|hz
argument_list|)
expr_stmt|;
name|pVDev
operator|->
name|pfnSendCommand
argument_list|(
argument|_VBUS_P pCmd
argument_list|)
expr_stmt|;
name|CheckPendingCall
argument_list|(
name|_VBUS_P0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|HPTLIBAPI
name|OsSendCommand
parameter_list|(
name|_VBUS_ARG
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|PBUS_DMAMAP
name|pmap
init|=
operator|(
name|PBUS_DMAMAP
operator|)
name|ccb
operator|->
name|ccb_adapter
decl_stmt|;
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
init|=
name|pmap
operator|->
name|pAdapter
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
init|=
operator|&
name|ccb
operator|->
name|ccb_h
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
init|=
operator|&
name|ccb
operator|->
name|csio
decl_stmt|;
name|PVDevice
name|pVDev
init|=
name|pAdapter
operator|->
name|VBus
operator|.
name|pVDevice
index|[
name|ccb_h
operator|->
name|target_id
index|]
decl_stmt|;
name|KdPrintI
argument_list|(
operator|(
literal|"OsSendCommand: ccb %p  cdb %x-%x-%x\n"
operator|,
name|ccb
operator|,
operator|*
operator|(
name|ULONG
operator|*
operator|)
operator|&
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
operator|,
operator|*
operator|(
name|ULONG
operator|*
operator|)
operator|&
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|4
index|]
operator|,
operator|*
operator|(
name|ULONG
operator|*
operator|)
operator|&
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|8
index|]
operator|)
argument_list|)
expr_stmt|;
name|pAdapter
operator|->
name|outstandingCommands
operator|++
expr_stmt|;
if|if
condition|(
name|pVDev
operator|==
name|NULL
operator|||
name|pVDev
operator|->
name|vf_online
operator|==
literal|0
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|ccb_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
goto|goto
name|Command_Complished
goto|;
block|}
switch|switch
condition|(
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
condition|)
block|{
case|case
name|TEST_UNIT_READY
case|:
case|case
name|START_STOP_UNIT
case|:
case|case
name|SYNCHRONIZE_CACHE
case|:
comment|/* FALLTHROUGH */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
case|case
name|INQUIRY
case|:
name|ZeroMemory
argument_list|(
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
argument_list|)
expr_stmt|;
name|SetInquiryData
argument_list|(
operator|(
name|PINQUIRYDATA
operator|)
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
argument_list|,
name|pVDev
argument_list|)
expr_stmt|;
name|ccb_h
operator|->
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
case|case
name|READ_CAPACITY
case|:
block|{
name|UCHAR
modifier|*
name|rbuf
init|=
name|csio
operator|->
name|data_ptr
decl_stmt|;
name|unsigned
name|int
name|cap
decl_stmt|;
if|if
condition|(
name|pVDev
operator|->
name|VDeviceCapacity
operator|>
literal|0xfffffffful
condition|)
block|{
name|cap
operator|=
literal|0xfffffffful
expr_stmt|;
block|}
else|else
block|{
name|cap
operator|=
name|pVDev
operator|->
name|VDeviceCapacity
operator|-
literal|1
expr_stmt|;
block|}
name|rbuf
index|[
literal|0
index|]
operator|=
call|(
name|UCHAR
call|)
argument_list|(
name|cap
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|rbuf
index|[
literal|1
index|]
operator|=
call|(
name|UCHAR
call|)
argument_list|(
name|cap
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|rbuf
index|[
literal|2
index|]
operator|=
call|(
name|UCHAR
call|)
argument_list|(
name|cap
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|rbuf
index|[
literal|3
index|]
operator|=
operator|(
name|UCHAR
operator|)
name|cap
expr_stmt|;
comment|/* Claim 512 byte blocks (big-endian). */
name|rbuf
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|rbuf
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
name|rbuf
index|[
literal|6
index|]
operator|=
literal|2
expr_stmt|;
name|rbuf
index|[
literal|7
index|]
operator|=
literal|0
expr_stmt|;
name|ccb_h
operator|->
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
block|}
case|case
literal|0x9e
case|:
comment|/*SERVICE_ACTION_IN*/
block|{
name|UCHAR
modifier|*
name|rbuf
init|=
name|csio
operator|->
name|data_ptr
decl_stmt|;
name|LBA_T
name|cap
init|=
name|pVDev
operator|->
name|VDeviceCapacity
operator|-
literal|1
decl_stmt|;
name|rbuf
index|[
literal|0
index|]
operator|=
call|(
name|UCHAR
call|)
argument_list|(
name|cap
operator|>>
literal|56
argument_list|)
expr_stmt|;
name|rbuf
index|[
literal|1
index|]
operator|=
call|(
name|UCHAR
call|)
argument_list|(
name|cap
operator|>>
literal|48
argument_list|)
expr_stmt|;
name|rbuf
index|[
literal|2
index|]
operator|=
call|(
name|UCHAR
call|)
argument_list|(
name|cap
operator|>>
literal|40
argument_list|)
expr_stmt|;
name|rbuf
index|[
literal|3
index|]
operator|=
call|(
name|UCHAR
call|)
argument_list|(
name|cap
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|rbuf
index|[
literal|4
index|]
operator|=
call|(
name|UCHAR
call|)
argument_list|(
name|cap
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|rbuf
index|[
literal|5
index|]
operator|=
call|(
name|UCHAR
call|)
argument_list|(
name|cap
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|rbuf
index|[
literal|6
index|]
operator|=
call|(
name|UCHAR
call|)
argument_list|(
name|cap
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|rbuf
index|[
literal|7
index|]
operator|=
operator|(
name|UCHAR
operator|)
name|cap
expr_stmt|;
name|rbuf
index|[
literal|8
index|]
operator|=
literal|0
expr_stmt|;
name|rbuf
index|[
literal|9
index|]
operator|=
literal|0
expr_stmt|;
name|rbuf
index|[
literal|10
index|]
operator|=
literal|2
expr_stmt|;
name|rbuf
index|[
literal|11
index|]
operator|=
literal|0
expr_stmt|;
name|ccb_h
operator|->
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
block|}
case|case
name|READ_6
case|:
case|case
name|WRITE_6
case|:
case|case
name|READ_10
case|:
case|case
name|WRITE_10
case|:
case|case
literal|0x88
case|:
comment|/* READ_16 */
case|case
literal|0x8a
case|:
comment|/* WRITE_16 */
case|case
literal|0x13
case|:
case|case
literal|0x2f
case|:
block|{
name|UCHAR
name|Cdb
index|[
literal|16
index|]
decl_stmt|;
name|UCHAR
name|CdbLength
decl_stmt|;
name|_VBUS_INST
argument_list|(
argument|pVDev->pVBus
argument_list|)
name|PCommand
name|pCmd
init|=
name|AllocateCommand
argument_list|(
name|_VBUS_P0
argument_list|)
decl_stmt|;
name|HPT_ASSERT
argument_list|(
name|pCmd
argument_list|)
expr_stmt|;
name|CdbLength
operator|=
name|csio
operator|->
name|cdb_len
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_POINTER
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_PHYS
operator|)
operator|==
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_ptr
argument_list|,
name|Cdb
argument_list|,
name|CdbLength
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|KdPrintE
argument_list|(
operator|(
literal|"ERROR!!!\n"
operator|)
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|bcopy
argument_list|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
name|Cdb
argument_list|,
name|CdbLength
argument_list|)
expr_stmt|;
block|}
name|pCmd
operator|->
name|pOrgCommand
operator|=
name|ccb
expr_stmt|;
name|pCmd
operator|->
name|pVDevice
operator|=
name|pVDev
expr_stmt|;
name|pCmd
operator|->
name|pfnCompletion
operator|=
name|fOsCommandDone
expr_stmt|;
name|pCmd
operator|->
name|pfnBuildSgl
operator|=
name|fOsBuildSgl
expr_stmt|;
name|pCmd
operator|->
name|pSgTable
operator|=
name|pmap
operator|->
name|psg
expr_stmt|;
switch|switch
condition|(
name|Cdb
index|[
literal|0
index|]
condition|)
block|{
case|case
name|READ_6
case|:
case|case
name|WRITE_6
case|:
case|case
literal|0x13
case|:
name|pCmd
operator|->
name|uCmd
operator|.
name|Ide
operator|.
name|Lba
operator|=
operator|(
operator|(
name|ULONG
operator|)
name|Cdb
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|ULONG
operator|)
name|Cdb
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|ULONG
operator|)
name|Cdb
index|[
literal|3
index|]
expr_stmt|;
name|pCmd
operator|->
name|uCmd
operator|.
name|Ide
operator|.
name|nSectors
operator|=
operator|(
name|USHORT
operator|)
name|Cdb
index|[
literal|4
index|]
expr_stmt|;
break|break;
case|case
literal|0x88
case|:
comment|/* READ_16 */
case|case
literal|0x8a
case|:
comment|/* WRITE_16 */
name|pCmd
operator|->
name|uCmd
operator|.
name|Ide
operator|.
name|Lba
operator|=
operator|(
name|HPT_U64
operator|)
name|Cdb
index|[
literal|2
index|]
operator|<<
literal|56
operator||
operator|(
name|HPT_U64
operator|)
name|Cdb
index|[
literal|3
index|]
operator|<<
literal|48
operator||
operator|(
name|HPT_U64
operator|)
name|Cdb
index|[
literal|4
index|]
operator|<<
literal|40
operator||
operator|(
name|HPT_U64
operator|)
name|Cdb
index|[
literal|5
index|]
operator|<<
literal|32
operator||
operator|(
name|HPT_U64
operator|)
name|Cdb
index|[
literal|6
index|]
operator|<<
literal|24
operator||
operator|(
name|HPT_U64
operator|)
name|Cdb
index|[
literal|7
index|]
operator|<<
literal|16
operator||
operator|(
name|HPT_U64
operator|)
name|Cdb
index|[
literal|8
index|]
operator|<<
literal|8
operator||
operator|(
name|HPT_U64
operator|)
name|Cdb
index|[
literal|9
index|]
expr_stmt|;
name|pCmd
operator|->
name|uCmd
operator|.
name|Ide
operator|.
name|nSectors
operator|=
operator|(
name|USHORT
operator|)
name|Cdb
index|[
literal|12
index|]
operator|<<
literal|8
operator||
operator|(
name|USHORT
operator|)
name|Cdb
index|[
literal|13
index|]
expr_stmt|;
break|break;
default|default:
name|pCmd
operator|->
name|uCmd
operator|.
name|Ide
operator|.
name|Lba
operator|=
operator|(
name|ULONG
operator|)
name|Cdb
index|[
literal|5
index|]
operator||
operator|(
operator|(
name|ULONG
operator|)
name|Cdb
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|ULONG
operator|)
name|Cdb
index|[
literal|3
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|ULONG
operator|)
name|Cdb
index|[
literal|2
index|]
operator|<<
literal|24
operator|)
expr_stmt|;
name|pCmd
operator|->
name|uCmd
operator|.
name|Ide
operator|.
name|nSectors
operator|=
operator|(
name|USHORT
operator|)
name|Cdb
index|[
literal|8
index|]
operator||
operator|(
operator|(
name|USHORT
operator|)
name|Cdb
index|[
literal|7
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|Cdb
index|[
literal|0
index|]
condition|)
block|{
case|case
name|READ_6
case|:
case|case
name|READ_10
case|:
case|case
literal|0x88
case|:
comment|/* READ_16 */
name|pCmd
operator|->
name|uCmd
operator|.
name|Ide
operator|.
name|Command
operator|=
name|IDE_COMMAND_READ
expr_stmt|;
name|pCmd
operator|->
name|cf_data_in
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|WRITE_6
case|:
case|case
name|WRITE_10
case|:
case|case
literal|0x8a
case|:
comment|/* WRITE_16 */
name|pCmd
operator|->
name|uCmd
operator|.
name|Ide
operator|.
name|Command
operator|=
name|IDE_COMMAND_WRITE
expr_stmt|;
name|pCmd
operator|->
name|cf_data_out
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|0x13
case|:
case|case
literal|0x2f
case|:
name|pCmd
operator|->
name|uCmd
operator|.
name|Ide
operator|.
name|Command
operator|=
name|IDE_COMMAND_VERIFY
expr_stmt|;
break|break;
block|}
comment|/*///////////////////////// */
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SCATTER_VALID
condition|)
block|{
name|int
name|idx
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|sgList
init|=
operator|(
name|bus_dma_segment_t
operator|*
operator|)
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
decl_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SG_LIST_PHYS
condition|)
name|pCmd
operator|->
name|cf_physical_sg
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|ccb
operator|->
name|csio
operator|.
name|sglist_cnt
condition|;
name|idx
operator|++
control|)
block|{
name|pCmd
operator|->
name|pSgTable
index|[
name|idx
index|]
operator|.
name|dSgAddress
operator|=
operator|(
name|ULONG_PTR
operator|)
operator|(
name|UCHAR
operator|*
operator|)
name|sgList
index|[
name|idx
index|]
operator|.
name|ds_addr
expr_stmt|;
name|pCmd
operator|->
name|pSgTable
index|[
name|idx
index|]
operator|.
name|wSgSize
operator|=
name|sgList
index|[
name|idx
index|]
operator|.
name|ds_len
expr_stmt|;
name|pCmd
operator|->
name|pSgTable
index|[
name|idx
index|]
operator|.
name|wSgFlag
operator|=
operator|(
name|idx
operator|==
name|ccb
operator|->
name|csio
operator|.
name|sglist_cnt
operator|-
literal|1
operator|)
condition|?
name|SG_FLAG_EOT
else|:
literal|0
expr_stmt|;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|hpt_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ccb
argument_list|,
literal|20
operator|*
name|hz
argument_list|)
expr_stmt|;
name|pVDev
operator|->
name|pfnSendCommand
argument_list|(
argument|_VBUS_P pCmd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|error
decl_stmt|;
name|pCmd
operator|->
name|cf_physical_sg
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|pAdapter
operator|->
name|io_dma_parent
argument_list|,
name|pmap
operator|->
name|dma_map
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
argument_list|,
name|hpt_io_dmamap_callback
argument_list|,
name|pCmd
argument_list|,
name|BUS_DMA_WAITOK
argument_list|)
expr_stmt|;
name|KdPrint
argument_list|(
operator|(
literal|"bus_dmamap_load return %d\n"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|EINPROGRESS
condition|)
block|{
name|hpt_printk
argument_list|(
operator|(
literal|"bus_dmamap_load error %d\n"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
name|FreeCommand
argument_list|(
argument|_VBUS_P pCmd
argument_list|)
empty_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP_ERR
expr_stmt|;
name|dmamap_put
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pAdapter
operator|->
name|outstandingCommands
operator|--
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
block|}
goto|goto
name|Command_Complished
goto|;
block|}
default|default:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
break|break;
block|}
name|ccb_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|Command_Complished
label|:
name|CheckPendingCall
argument_list|(
name|_VBUS_P0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|HPTLIBAPI
name|fOsCommandDone
parameter_list|(
name|_VBUS_ARG
name|PCommand
name|pCmd
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
init|=
name|pCmd
operator|->
name|pOrgCommand
decl_stmt|;
name|PBUS_DMAMAP
name|pmap
init|=
operator|(
name|PBUS_DMAMAP
operator|)
name|ccb
operator|->
name|ccb_adapter
decl_stmt|;
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
init|=
name|pmap
operator|->
name|pAdapter
decl_stmt|;
name|KdPrint
argument_list|(
operator|(
literal|"fOsCommandDone(pcmd=%p, result=%d)\n"
operator|,
name|pCmd
operator|,
name|pCmd
operator|->
name|Result
operator|)
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|hpt_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ccb
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pCmd
operator|->
name|Result
condition|)
block|{
case|case
name|RETURN_SUCCESS
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
case|case
name|RETURN_BAD_DEVICE
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_DEV_NOT_THERE
expr_stmt|;
break|break;
case|case
name|RETURN_DEVICE_BUSY
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_BUSY
expr_stmt|;
break|break;
case|case
name|RETURN_INVALID_REQUEST
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
break|break;
case|case
name|RETURN_SELECTION_TIMEOUT
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SEL_TIMEOUT
expr_stmt|;
break|break;
case|case
name|RETURN_RETRY
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_BUSY
expr_stmt|;
break|break;
default|default:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SCSI_STATUS_ERROR
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pCmd
operator|->
name|cf_data_in
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|pAdapter
operator|->
name|io_dma_parent
argument_list|,
name|pmap
operator|->
name|dma_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pCmd
operator|->
name|cf_data_in
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|pAdapter
operator|->
name|io_dma_parent
argument_list|,
name|pmap
operator|->
name|dma_map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_unload
argument_list|(
name|pAdapter
operator|->
name|io_dma_parent
argument_list|,
name|pmap
operator|->
name|dma_map
argument_list|)
expr_stmt|;
name|FreeCommand
argument_list|(
argument|_VBUS_P pCmd
argument_list|)
empty_stmt|;
name|ccb_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|hpt_queue_dpc
parameter_list|(
name|HPT_DPC
name|dpc
parameter_list|,
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|UCHAR
name|flags
parameter_list|)
block|{
name|int
name|p
decl_stmt|;
name|p
operator|=
operator|(
name|DpcQueue_Last
operator|+
literal|1
operator|)
operator|%
name|MAX_DPC
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|DpcQueue_First
condition|)
block|{
name|KdPrint
argument_list|(
operator|(
literal|"DPC Queue full!\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|DpcQueue
index|[
name|DpcQueue_Last
index|]
operator|.
name|dpc
operator|=
name|dpc
expr_stmt|;
name|DpcQueue
index|[
name|DpcQueue_Last
index|]
operator|.
name|pAdapter
operator|=
name|pAdapter
expr_stmt|;
name|DpcQueue
index|[
name|DpcQueue_Last
index|]
operator|.
name|arg
operator|=
name|arg
expr_stmt|;
name|DpcQueue
index|[
name|DpcQueue_Last
index|]
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
name|DpcQueue_Last
operator|=
name|p
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_RAID5N_
end_ifdef

begin_comment
comment|/*   * Allocate memory above 16M, otherwise we may eat all low memory for ISA devices.  * How about the memory for 5081 request/response array and PRD table?  */
end_comment

begin_function
name|void
modifier|*
name|os_alloc_page
parameter_list|(
name|_VBUS_ARG0
parameter_list|)
block|{
return|return
operator|(
name|void
operator|*
operator|)
name|contigmalloc
argument_list|(
literal|0x1000
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|,
literal|0x1000000
argument_list|,
literal|0xffffffff
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|0ul
argument_list|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|os_alloc_dma_page
parameter_list|(
name|_VBUS_ARG0
parameter_list|)
block|{
return|return
operator|(
name|void
operator|*
operator|)
name|contigmalloc
argument_list|(
literal|0x1000
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|,
literal|0x1000000
argument_list|,
literal|0xffffffff
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|0ul
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|os_free_page
parameter_list|(
name|_VBUS_ARG
name|void
modifier|*
name|p
parameter_list|)
block|{
name|contigfree
argument_list|(
name|p
argument_list|,
literal|0x1000
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|os_free_dma_page
parameter_list|(
name|_VBUS_ARG
name|void
modifier|*
name|p
parameter_list|)
block|{
name|contigfree
argument_list|(
name|p
argument_list|,
literal|0x1000
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|DoXor1
parameter_list|(
name|ULONG
modifier|*
name|p0
parameter_list|,
name|ULONG
modifier|*
name|p1
parameter_list|,
name|ULONG
modifier|*
name|p2
parameter_list|,
name|UINT
name|nBytes
parameter_list|)
block|{
name|UINT
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nBytes
operator|/
literal|4
condition|;
name|i
operator|++
control|)
operator|*
name|p0
operator|++
operator|=
operator|*
name|p1
operator|++
operator|^
operator|*
name|p2
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|DoXor2
parameter_list|(
name|ULONG
modifier|*
name|p0
parameter_list|,
name|ULONG
modifier|*
name|p2
parameter_list|,
name|UINT
name|nBytes
parameter_list|)
block|{
name|UINT
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nBytes
operator|/
literal|4
condition|;
name|i
operator|++
control|)
operator|*
name|p0
operator|++
operator|^=
operator|*
name|p2
operator|++
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

