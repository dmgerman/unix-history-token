begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003-2004 HighPoint Technologies, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/hptmv/global.h>
end_include

begin_include
include|#
directive|include
file|<dev/hptmv/hptintf.h>
end_include

begin_include
include|#
directive|include
file|<dev/hptmv/osbsd.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/hptmv/access601.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_LEVEL
end_ifdef

begin_decl_stmt
name|int
name|hpt_dbg_level
init|=
name|DEBUG_LEVEL
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|hpt_dbg_level
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MV_ERROR
value|printf
end_define

begin_comment
comment|/*  * CAM SIM entry points  */
end_comment

begin_function_decl
specifier|static
name|int
name|hpt_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hpt_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hpt_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hpt_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hpt_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hpt_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hpt_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|SetInquiryData
parameter_list|(
name|PINQUIRYDATA
name|inquiryData
parameter_list|,
name|PVDevice
name|pVDev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|HPTLIBAPI
name|OsSendCommand
parameter_list|(
name|_VBUS_ARG
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|HPTLIBAPI
name|fOsCommandDone
parameter_list|(
name|_VBUS_ARG
name|PCommand
name|pCmd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ccb_done
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hpt_queue_ccb
parameter_list|(
name|union
name|ccb
modifier|*
modifier|*
name|ccb_Q
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hpt_free_ccb
parameter_list|(
name|union
name|ccb
modifier|*
modifier|*
name|ccb_Q
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|launch_worker_thread
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|MV_SATA_CHANNEL
name|gMvSataChannels
index|[
name|MAX_VBUS
index|]
index|[
name|MV_SATA_CHANNELS_NUM
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|hptmv_free_edma_queues
parameter_list|(
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hptmv_free_channel
parameter_list|(
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
parameter_list|,
name|MV_U8
name|channelNum
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handleEdmaError
parameter_list|(
name|_VBUS_ARG
name|PCommand
name|pCmd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hptmv_init_channel
parameter_list|(
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
parameter_list|,
name|MV_U8
name|channelNum
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fResetActiveCommands
parameter_list|(
name|PVBus
name|_vbus_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fRegisterVdevice
parameter_list|(
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hptmv_allocate_edma_queues
parameter_list|(
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hptmv_handle_event_disconnect
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hptmv_handle_event_connect
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|start_channel
parameter_list|(
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
parameter_list|,
name|MV_U8
name|channelNum
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_vdev_params
parameter_list|(
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
parameter_list|,
name|MV_U8
name|channel
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hptmv_parse_identify_results
parameter_list|(
name|MV_SATA_CHANNEL
modifier|*
name|pMvSataChannel
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hpt_async
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|u_int32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|HPTLIBAPI
name|fOsBuildSgl
parameter_list|(
name|_VBUS_ARG
name|PCommand
name|pCmd
parameter_list|,
name|FPSCAT_GATH
name|pSg
parameter_list|,
name|int
name|logical
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|MV_BOOLEAN
name|CommandCompletionCB
parameter_list|(
name|MV_SATA_ADAPTER
modifier|*
name|pMvSataAdapter
parameter_list|,
name|MV_U8
name|channelNum
parameter_list|,
name|MV_COMPLETION_TYPE
name|comp_type
parameter_list|,
name|MV_VOID_PTR
name|commandId
parameter_list|,
name|MV_U16
name|responseFlags
parameter_list|,
name|MV_U32
name|timeStamp
parameter_list|,
name|MV_STORAGE_DEVICE_REGISTERS
modifier|*
name|registerStruct
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|MV_BOOLEAN
name|hptmv_event_notify
parameter_list|(
name|MV_SATA_ADAPTER
modifier|*
name|pMvSataAdapter
parameter_list|,
name|MV_EVENT_TYPE
name|eventType
parameter_list|,
name|MV_U32
name|param1
parameter_list|,
name|MV_U32
name|param2
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|ccb_ccb_ptr
value|spriv_ptr0
end_define

begin_define
define|#
directive|define
name|ccb_adapter
value|ccb_h.spriv_ptr1
end_define

begin_decl_stmt
name|IAL_ADAPTER_T
modifier|*
name|gIal_Adapter
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|IAL_ADAPTER_T
modifier|*
name|pCurAdapter
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|st_HPT_DPC
block|{
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
decl_stmt|;
name|void
function_decl|(
modifier|*
name|dpc
function_decl|)
parameter_list|(
name|IAL_ADAPTER_T
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|UCHAR
parameter_list|)
function_decl|;
name|void
modifier|*
name|arg
decl_stmt|;
name|UCHAR
name|flags
decl_stmt|;
block|}
name|ST_HPT_DPC
typedef|;
end_typedef

begin_define
define|#
directive|define
name|MAX_DPC
value|16
end_define

begin_decl_stmt
name|UCHAR
name|DPC_Request_Nums
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ST_HPT_DPC
name|DpcQueue
index|[
name|MAX_DPC
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|DpcQueue_First
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|DpcQueue_Last
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|driver_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|hpt_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|hpt_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|hpt_detach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|hpt_pci_driver
init|=
block|{
name|__str
argument_list|(
name|PROC_DIR_NAME
argument_list|)
block|,
name|driver_methods
block|,
expr|sizeof
operator|(
name|IAL_ADAPTER_T
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|hpt_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|PROC_DIR_NAME
argument_list|,
name|pci
argument_list|,
name|hpt_pci_driver
argument_list|,
name|hpt_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|PROC_DIR_NAME
argument_list|,
name|cam
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|intrmask_t
name|lock_driver
parameter_list|()
block|{
name|intrmask_t
name|spl
init|=
name|splcam
argument_list|()
decl_stmt|;
return|return
name|spl
return|;
block|}
end_function

begin_function
name|void
name|unlock_driver
parameter_list|(
name|intrmask_t
name|spl
parameter_list|)
block|{
name|splx
argument_list|(
name|spl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *	Name:	hptmv_free_channel  *  *	Description:	free allocated queues for the given channel  *  *	Parameters:    	pMvSataAdapter - pointer to the RR182x controler this   * 					channel connected to.   *			channelNum - channel number.   *       ******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|hptmv_free_channel
parameter_list|(
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
parameter_list|,
name|MV_U8
name|channelNum
parameter_list|)
block|{
name|PVDevice
name|pVDev
init|=
operator|&
operator|(
name|pAdapter
operator|->
name|VDevices
index|[
name|channelNum
index|]
operator|)
decl_stmt|;
name|_VBUS_INST
argument_list|(
operator|&
name|pAdapter
operator|->
name|VBus
argument_list|)
expr_stmt|;
name|HPT_ASSERT
argument_list|(
name|channelNum
operator|<
name|MV_SATA_CHANNELS_NUM
argument_list|)
expr_stmt|;
name|pAdapter
operator|->
name|mvSataAdapter
operator|.
name|sataChannel
index|[
name|channelNum
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|pVDev
operator|->
name|vf_online
condition|)
block|{
name|pVDev
operator|->
name|u
operator|.
name|disk
operator|.
name|df_on_line
operator|=
literal|0
expr_stmt|;
name|pVDev
operator|->
name|vf_online
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pVDev
operator|->
name|pfnDeviceFailed
condition|)
block|{
name|CallWhenIdle
argument_list|(
name|_VBUS_P
argument_list|(
argument|DPC_PROC
argument_list|)
name|pVDev
operator|->
name|pfnDeviceFailed
argument_list|,
name|pVDev
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function_decl
name|int
name|MvSataResetChannel
parameter_list|(
name|MV_SATA_ADAPTER
modifier|*
name|pMvSataAdapter
parameter_list|,
name|MV_U8
name|channel
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|handleEdmaError
parameter_list|(
name|_VBUS_ARG
name|PCommand
name|pCmd
parameter_list|)
block|{
name|PDevice
name|pDevice
init|=
operator|&
name|pCmd
operator|->
name|pVDevice
operator|->
name|u
operator|.
name|disk
decl_stmt|;
name|MV_SATA_ADAPTER
modifier|*
name|pSataAdapter
init|=
name|pDevice
operator|->
name|mv
operator|->
name|mvSataAdapter
decl_stmt|;
name|MV_ERROR
argument_list|(
literal|"Reset channel\n"
argument_list|)
expr_stmt|;
name|MvSataResetChannel
argument_list|(
name|pSataAdapter
argument_list|,
name|pDevice
operator|->
name|mv
operator|->
name|channelNumber
argument_list|)
expr_stmt|;
comment|/*now no other cmds on this channel*/
if|if
condition|(
operator|!
name|pDevice
operator|->
name|df_on_line
condition|)
block|{
name|KdPrint
argument_list|(
operator|(
literal|"Device is offline"
operator|)
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Result
operator|=
name|RETURN_BAD_DEVICE
expr_stmt|;
name|CallAfterReturn
argument_list|(
name|_VBUS_P
argument_list|(
argument|DPC_PROC
argument_list|)
name|pCmd
operator|->
name|pfnCompletion
argument_list|,
name|pCmd
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pCmd
operator|->
name|RetryCount
operator|++
operator|>
literal|5
condition|)
block|{
name|pDevice
operator|->
name|df_on_line
operator|=
literal|0
expr_stmt|;
name|pCmd
operator|->
name|pVDevice
operator|->
name|vf_online
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pCmd
operator|->
name|pVDevice
operator|->
name|pfnDeviceFailed
condition|)
name|CallWhenIdle
argument_list|(
name|_VBUS_P
argument_list|(
argument|DPC_PROC
argument_list|)
name|pCmd
operator|->
name|pVDevice
operator|->
name|pfnDeviceFailed
argument_list|,
name|pCmd
operator|->
name|pVDevice
argument_list|)
expr_stmt|;
name|fNotifyGUI
argument_list|(
name|ET_DEVICE_REMOVED
argument_list|,
name|Map2pVDevice
argument_list|(
name|pDevice
argument_list|)
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Result
operator|=
name|RETURN_IDE_ERROR
expr_stmt|;
name|CallAfterReturn
argument_list|(
name|_VBUS_P
argument_list|(
argument|DPC_PROC
argument_list|)
name|pCmd
operator|->
name|pfnCompletion
argument_list|,
name|pCmd
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* retry the command */
name|fDeviceSendCommand
argument_list|(
argument|_VBUS_P pCmd
argument_list|)
empty_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************  *	Name:	hptmv_init_channel  *  *	Description:	allocate request and response queues for the EDMA of  *                      the given channel and sets other fields.  *	Parameters:    	  *		pAdapter - pointer to the emulated adapter data structure  *		channelNum - channel number.   *	Return:	0 on success, otherwise on failure  ****************************************************************/
end_comment

begin_function
specifier|static
name|int
name|hptmv_init_channel
parameter_list|(
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
parameter_list|,
name|MV_U8
name|channelNum
parameter_list|)
block|{
name|MV_SATA_CHANNEL
modifier|*
name|pMvSataChannel
decl_stmt|;
name|dma_addr_t
name|req_dma_addr
decl_stmt|;
name|dma_addr_t
name|rsp_dma_addr
decl_stmt|;
if|if
condition|(
name|channelNum
operator|>=
name|MV_SATA_CHANNELS_NUM
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR182x[%d]: Bad channelNum=%d"
argument_list|,
name|pAdapter
operator|->
name|mvSataAdapter
operator|.
name|adapterId
argument_list|,
name|channelNum
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|pMvSataChannel
operator|=
operator|&
name|gMvSataChannels
index|[
name|pAdapter
operator|->
name|mvSataAdapter
operator|.
name|adapterId
index|]
index|[
name|channelNum
index|]
expr_stmt|;
name|pAdapter
operator|->
name|mvSataAdapter
operator|.
name|sataChannel
index|[
name|channelNum
index|]
operator|=
name|pMvSataChannel
expr_stmt|;
name|pMvSataChannel
operator|->
name|channelNumber
operator|=
name|channelNum
expr_stmt|;
name|pMvSataChannel
operator|->
name|lba48Address
operator|=
name|MV_FALSE
expr_stmt|;
name|pMvSataChannel
operator|->
name|maxReadTransfer
operator|=
name|MV_FALSE
expr_stmt|;
name|pMvSataChannel
operator|->
name|requestQueue
operator|=
operator|(
expr|struct
name|mvDmaRequestQueueEntry
operator|*
operator|)
operator|(
name|pAdapter
operator|->
name|requestsArrayBaseAlignedAddr
operator|+
operator|(
name|channelNum
operator|*
name|MV_EDMA_REQUEST_QUEUE_SIZE
operator|)
operator|)
expr_stmt|;
name|req_dma_addr
operator|=
name|pAdapter
operator|->
name|requestsArrayBaseDmaAlignedAddr
operator|+
operator|(
name|channelNum
operator|*
name|MV_EDMA_REQUEST_QUEUE_SIZE
operator|)
expr_stmt|;
name|KdPrint
argument_list|(
operator|(
literal|"requestQueue addr is 0x%lX"
operator|,
operator|(
name|u_long
operator|)
name|req_dma_addr
operator|)
argument_list|)
expr_stmt|;
comment|/* check the 1K alignment of the request queue*/
if|if
condition|(
name|req_dma_addr
operator|&
literal|0x3ff
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR182x[%d]: request queue allocated not 1 K aligned,"
literal|" dma_addr=%lx channel=%d\n"
argument_list|,
name|pAdapter
operator|->
name|mvSataAdapter
operator|.
name|adapterId
argument_list|,
operator|(
name|u_long
operator|)
name|req_dma_addr
argument_list|,
name|channelNum
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|pMvSataChannel
operator|->
name|requestQueuePciLowAddress
operator|=
name|req_dma_addr
expr_stmt|;
name|pMvSataChannel
operator|->
name|requestQueuePciHiAddress
operator|=
literal|0
expr_stmt|;
name|KdPrint
argument_list|(
operator|(
literal|"RR182x[%d,%d]: request queue allocated: 0x%p"
operator|,
name|pAdapter
operator|->
name|mvSataAdapter
operator|.
name|adapterId
operator|,
name|channelNum
operator|,
name|pMvSataChannel
operator|->
name|requestQueue
operator|)
argument_list|)
expr_stmt|;
name|pMvSataChannel
operator|->
name|responseQueue
operator|=
operator|(
expr|struct
name|mvDmaResponseQueueEntry
operator|*
operator|)
operator|(
name|pAdapter
operator|->
name|responsesArrayBaseAlignedAddr
operator|+
operator|(
name|channelNum
operator|*
name|MV_EDMA_RESPONSE_QUEUE_SIZE
operator|)
operator|)
expr_stmt|;
name|rsp_dma_addr
operator|=
name|pAdapter
operator|->
name|responsesArrayBaseDmaAlignedAddr
operator|+
operator|(
name|channelNum
operator|*
name|MV_EDMA_RESPONSE_QUEUE_SIZE
operator|)
expr_stmt|;
comment|/* check the 256 alignment of the response queue*/
if|if
condition|(
name|rsp_dma_addr
operator|&
literal|0xff
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR182x[%d,%d]: response queue allocated not 256 byte"
literal|" aligned, dma_addr=%lx\n"
argument_list|,
name|pAdapter
operator|->
name|mvSataAdapter
operator|.
name|adapterId
argument_list|,
name|channelNum
argument_list|,
operator|(
name|u_long
operator|)
name|rsp_dma_addr
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|pMvSataChannel
operator|->
name|responseQueuePciLowAddress
operator|=
name|rsp_dma_addr
expr_stmt|;
name|pMvSataChannel
operator|->
name|responseQueuePciHiAddress
operator|=
literal|0
expr_stmt|;
name|KdPrint
argument_list|(
operator|(
literal|"RR182x[%d,%d]: response queue allocated: 0x%p"
operator|,
name|pAdapter
operator|->
name|mvSataAdapter
operator|.
name|adapterId
operator|,
name|channelNum
operator|,
name|pMvSataChannel
operator|->
name|responseQueue
operator|)
argument_list|)
expr_stmt|;
name|pAdapter
operator|->
name|mvChannel
index|[
name|channelNum
index|]
operator|.
name|online
operator|=
name|MV_TRUE
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  *	Name: hptmv_parse_identify_results  *  *	Description:	this functions parses the identify command results,  *			checks that the connected deives can be accesed by  *			RR182x EDMA, and updates the channel stucture  *			accordingly.  *	Parameters:     pMvSataChannel, pointer to the channel data structure.  *  *	Returns:       	=0 ->success,< 0 ->failure.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|hptmv_parse_identify_results
parameter_list|(
name|MV_SATA_CHANNEL
modifier|*
name|pMvSataChannel
parameter_list|)
block|{
name|MV_U16
modifier|*
name|iden
init|=
name|pMvSataChannel
operator|->
name|identifyDevice
decl_stmt|;
comment|/*LBA addressing*/
if|if
condition|(
operator|!
operator|(
name|iden
index|[
name|IDEN_CAPACITY_1_OFFSET
index|]
operator|&
literal|0x200
operator|)
condition|)
block|{
name|KdPrint
argument_list|(
operator|(
literal|"IAL Error in IDENTIFY info: LBA not supported\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|KdPrint
argument_list|(
operator|(
literal|"%25s - %s\n"
operator|,
literal|"Capabilities"
operator|,
literal|"LBA supported"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/*DMA support*/
if|if
condition|(
operator|!
operator|(
name|iden
index|[
name|IDEN_CAPACITY_1_OFFSET
index|]
operator|&
literal|0x100
operator|)
condition|)
block|{
name|KdPrint
argument_list|(
operator|(
literal|"IAL Error in IDENTIFY info: DMA not supported\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|KdPrint
argument_list|(
operator|(
literal|"%25s - %s\n"
operator|,
literal|"Capabilities"
operator|,
literal|"DMA supported"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* PIO */
if|if
condition|(
operator|(
name|iden
index|[
name|IDEN_VALID
index|]
operator|&
literal|2
operator|)
operator|==
literal|0
condition|)
block|{
name|KdPrint
argument_list|(
operator|(
literal|"IAL Error in IDENTIFY info: not able to find PIO "
literal|"mode\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|KdPrint
argument_list|(
operator|(
literal|"%25s - 0x%02x\n"
operator|,
literal|"PIO modes supported"
operator|,
name|iden
index|[
name|IDEN_PIO_MODE_SPPORTED
index|]
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
comment|/*UDMA*/
if|if
condition|(
operator|(
name|iden
index|[
name|IDEN_VALID
index|]
operator|&
literal|4
operator|)
operator|==
literal|0
condition|)
block|{
name|KdPrint
argument_list|(
operator|(
literal|"IAL Error in IDENTIFY info: not able to find UDMA "
literal|"mode\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* 48 bit address */
if|if
condition|(
operator|(
name|iden
index|[
name|IDEN_SUPPORTED_COMMANDS2
index|]
operator|&
literal|0x400
operator|)
condition|)
block|{
name|KdPrint
argument_list|(
operator|(
literal|"%25s - %s\n"
operator|,
literal|"LBA48 addressing"
operator|,
literal|"supported"
operator|)
argument_list|)
expr_stmt|;
name|pMvSataChannel
operator|->
name|lba48Address
operator|=
name|MV_TRUE
expr_stmt|;
block|}
else|else
block|{
name|KdPrint
argument_list|(
operator|(
literal|"%25s - %s\n"
operator|,
literal|"LBA48 addressing"
operator|,
literal|"Not supported"
operator|)
argument_list|)
expr_stmt|;
name|pMvSataChannel
operator|->
name|lba48Address
operator|=
name|MV_FALSE
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_vdev_params
parameter_list|(
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
parameter_list|,
name|MV_U8
name|channel
parameter_list|)
block|{
name|PVDevice
name|pVDev
decl_stmt|;
name|MV_SATA_CHANNEL
modifier|*
name|pMvSataChannel
decl_stmt|;
name|MV_U16_PTR
name|IdentifyData
decl_stmt|;
name|pVDev
operator|=
operator|&
name|pAdapter
operator|->
name|VDevices
index|[
name|channel
index|]
expr_stmt|;
name|pMvSataChannel
operator|=
name|pAdapter
operator|->
name|mvSataAdapter
operator|.
name|sataChannel
index|[
name|channel
index|]
expr_stmt|;
name|pMvSataChannel
operator|->
name|outstandingCommands
operator|=
literal|0
expr_stmt|;
name|IdentifyData
operator|=
name|pMvSataChannel
operator|->
name|identifyDevice
expr_stmt|;
name|pVDev
operator|->
name|u
operator|.
name|disk
operator|.
name|mv
operator|=
name|pMvSataChannel
expr_stmt|;
name|pVDev
operator|->
name|u
operator|.
name|disk
operator|.
name|df_on_line
operator|=
literal|1
expr_stmt|;
name|pVDev
operator|->
name|u
operator|.
name|disk
operator|.
name|pVBus
operator|=
operator|&
name|pAdapter
operator|->
name|VBus
expr_stmt|;
name|pVDev
operator|->
name|pVBus
operator|=
operator|&
name|pAdapter
operator|->
name|VBus
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_48BIT_LBA
if|if
condition|(
name|pMvSataChannel
operator|->
name|lba48Address
operator|==
name|MV_TRUE
condition|)
name|pVDev
operator|->
name|u
operator|.
name|disk
operator|.
name|dDeRealCapacity
operator|=
operator|(
operator|(
name|IdentifyData
index|[
literal|101
index|]
operator|<<
literal|16
operator|)
operator||
name|IdentifyData
index|[
literal|100
index|]
operator|)
operator|-
literal|1
expr_stmt|;
elseif|else
endif|#
directive|endif
if|if
condition|(
name|IdentifyData
index|[
literal|53
index|]
operator|&
literal|1
condition|)
block|{
name|pVDev
operator|->
name|u
operator|.
name|disk
operator|.
name|dDeRealCapacity
operator|=
operator|(
operator|(
operator|(
name|IdentifyData
index|[
literal|58
index|]
operator|<<
literal|16
operator||
name|IdentifyData
index|[
literal|57
index|]
operator|)
operator|<
operator|(
name|IdentifyData
index|[
literal|61
index|]
operator|<<
literal|16
operator||
name|IdentifyData
index|[
literal|60
index|]
operator|)
operator|)
condition|?
operator|(
name|IdentifyData
index|[
literal|61
index|]
operator|<<
literal|16
operator||
name|IdentifyData
index|[
literal|60
index|]
operator|)
else|:
operator|(
name|IdentifyData
index|[
literal|58
index|]
operator|<<
literal|16
operator||
name|IdentifyData
index|[
literal|57
index|]
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|pVDev
operator|->
name|u
operator|.
name|disk
operator|.
name|dDeRealCapacity
operator|=
operator|(
name|IdentifyData
index|[
literal|61
index|]
operator|<<
literal|16
operator||
name|IdentifyData
index|[
literal|60
index|]
operator|)
operator|-
literal|1
expr_stmt|;
name|pVDev
operator|->
name|u
operator|.
name|disk
operator|.
name|bDeUsable_Mode
operator|=
name|pVDev
operator|->
name|u
operator|.
name|disk
operator|.
name|bDeModeSetting
operator|=
name|pAdapter
operator|->
name|mvChannel
index|[
name|channel
index|]
operator|.
name|maxPioModeSupported
operator|-
name|MV_ATA_TRANSFER_PIO_0
expr_stmt|;
if|if
condition|(
name|pAdapter
operator|->
name|mvChannel
index|[
name|channel
index|]
operator|.
name|maxUltraDmaModeSupported
operator|!=
literal|0xFF
condition|)
block|{
name|pVDev
operator|->
name|u
operator|.
name|disk
operator|.
name|bDeUsable_Mode
operator|=
name|pVDev
operator|->
name|u
operator|.
name|disk
operator|.
name|bDeModeSetting
operator|=
name|pAdapter
operator|->
name|mvChannel
index|[
name|channel
index|]
operator|.
name|maxUltraDmaModeSupported
operator|-
name|MV_ATA_TRANSFER_UDMA_0
operator|+
literal|8
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|device_change
parameter_list|(
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
parameter_list|,
name|MV_U8
name|channelIndex
parameter_list|,
name|int
name|plugged
parameter_list|)
block|{
name|PVDevice
name|pVDev
decl_stmt|;
name|MV_SATA_ADAPTER
modifier|*
name|pMvSataAdapter
decl_stmt|;
name|MV_SATA_CHANNEL
modifier|*
name|pMvSataChannel
decl_stmt|;
name|PVBus
name|_vbus_p
decl_stmt|;
name|pMvSataAdapter
operator|=
operator|&
name|pAdapter
operator|->
name|mvSataAdapter
expr_stmt|;
name|pMvSataChannel
operator|=
name|pMvSataAdapter
operator|->
name|sataChannel
index|[
name|channelIndex
index|]
expr_stmt|;
name|_vbus_p
operator|=
operator|&
name|pAdapter
operator|->
name|VBus
expr_stmt|;
if|if
condition|(
operator|!
name|pMvSataChannel
condition|)
return|return;
if|if
condition|(
name|plugged
condition|)
block|{
name|pVDev
operator|=
operator|&
operator|(
name|pAdapter
operator|->
name|VDevices
index|[
name|channelIndex
index|]
operator|)
expr_stmt|;
name|init_vdev_params
argument_list|(
name|pAdapter
argument_list|,
name|channelIndex
argument_list|)
expr_stmt|;
name|pVDev
operator|->
name|VDeviceType
operator|=
name|pVDev
operator|->
name|u
operator|.
name|disk
operator|.
name|df_atapi
condition|?
name|VD_ATAPI
else|:
name|pVDev
operator|->
name|u
operator|.
name|disk
operator|.
name|df_removable_drive
condition|?
name|VD_REMOVABLE
else|:
name|VD_SINGLE_DISK
expr_stmt|;
name|pVDev
operator|->
name|VDeviceCapacity
operator|=
name|pVDev
operator|->
name|u
operator|.
name|disk
operator|.
name|dDeRealCapacity
expr_stmt|;
name|pVDev
operator|->
name|pfnSendCommand
operator|=
name|pfnSendCommand
index|[
name|pVDev
operator|->
name|VDeviceType
index|]
expr_stmt|;
name|pVDev
operator|->
name|pfnDeviceFailed
operator|=
name|pfnDeviceFailed
index|[
name|pVDev
operator|->
name|VDeviceType
index|]
expr_stmt|;
name|pVDev
operator|->
name|vf_online
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_ARRAY
if|if
condition|(
name|pVDev
operator|->
name|pParent
condition|)
block|{
name|int
name|iMember
decl_stmt|;
for|for
control|(
name|iMember
operator|=
literal|0
init|;
name|iMember
operator|<
name|pVDev
operator|->
name|pParent
operator|->
name|u
operator|.
name|array
operator|.
name|bArnMember
condition|;
name|iMember
operator|++
control|)
if|if
condition|(
operator|(
name|PVDevice
operator|)
name|pVDev
operator|->
name|pParent
operator|->
name|u
operator|.
name|array
operator|.
name|pMember
index|[
name|iMember
index|]
operator|==
name|pVDev
condition|)
name|pVDev
operator|->
name|pParent
operator|->
name|u
operator|.
name|array
operator|.
name|pMember
index|[
name|iMember
index|]
operator|=
name|NULL
expr_stmt|;
name|pVDev
operator|->
name|pParent
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
name|fNotifyGUI
argument_list|(
name|ET_DEVICE_PLUGGED
argument_list|,
name|pVDev
argument_list|)
expr_stmt|;
name|fCheckBootable
argument_list|(
name|pVDev
argument_list|)
expr_stmt|;
name|RegisterVDevice
argument_list|(
name|pVDev
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|FOR_DEMO
if|if
condition|(
name|pAdapter
operator|->
name|beeping
condition|)
block|{
name|pAdapter
operator|->
name|beeping
operator|=
literal|0
expr_stmt|;
name|BeepOff
argument_list|(
name|pAdapter
operator|->
name|mvSataAdapter
operator|.
name|adapterIoBaseAddress
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
name|pVDev
operator|=
operator|&
operator|(
name|pAdapter
operator|->
name|VDevices
index|[
name|channelIndex
index|]
operator|)
expr_stmt|;
name|pVDev
operator|->
name|u
operator|.
name|disk
operator|.
name|df_on_line
operator|=
literal|0
expr_stmt|;
name|pVDev
operator|->
name|vf_online
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pVDev
operator|->
name|pfnDeviceFailed
condition|)
block|{
name|_VBUS_INST
argument_list|(
argument|&pAdapter->VBus
argument_list|)
name|CallWhenIdle
argument_list|(
name|_VBUS_P
argument_list|(
argument|DPC_PROC
argument_list|)
name|pVDev
operator|->
name|pfnDeviceFailed
argument_list|,
name|pVDev
argument_list|)
expr_stmt|;
block|}
name|fNotifyGUI
argument_list|(
name|ET_DEVICE_REMOVED
argument_list|,
name|pVDev
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|FOR_DEMO
if|if
condition|(
name|pAdapter
operator|->
name|ver_601
operator|==
literal|2
operator|&&
operator|!
name|pAdapter
operator|->
name|beeping
condition|)
block|{
name|pAdapter
operator|->
name|beeping
operator|=
literal|1
expr_stmt|;
name|BeepOn
argument_list|(
name|pAdapter
operator|->
name|mvSataAdapter
operator|.
name|adapterIoBaseAddress
argument_list|)
expr_stmt|;
name|set_fail_led
argument_list|(
operator|&
name|pAdapter
operator|->
name|mvSataAdapter
argument_list|,
name|channelIndex
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|start_channel
parameter_list|(
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
parameter_list|,
name|MV_U8
name|channelNum
parameter_list|)
block|{
name|MV_SATA_ADAPTER
modifier|*
name|pMvSataAdapter
decl_stmt|;
name|MV_SATA_CHANNEL
modifier|*
name|pMvSataChannel
decl_stmt|;
name|MV_CHANNEL
modifier|*
name|pChannelInfo
decl_stmt|;
name|MV_U32
name|udmaMode
decl_stmt|,
name|pioMode
decl_stmt|;
name|pMvSataAdapter
operator|=
operator|&
name|pAdapter
operator|->
name|mvSataAdapter
expr_stmt|;
name|pMvSataChannel
operator|=
name|pMvSataAdapter
operator|->
name|sataChannel
index|[
name|channelNum
index|]
expr_stmt|;
name|pChannelInfo
operator|=
operator|&
operator|(
name|pAdapter
operator|->
name|mvChannel
index|[
name|channelNum
index|]
operator|)
expr_stmt|;
name|KdPrint
argument_list|(
operator|(
literal|"RR182x [%d]: start channel (%d)"
operator|,
name|pMvSataAdapter
operator|->
name|adapterId
operator|,
name|channelNum
operator|)
argument_list|)
expr_stmt|;
comment|/* Software reset channel */
if|if
condition|(
name|mvStorageDevATASoftResetDevice
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channelNum
argument_list|)
operator|==
name|MV_FALSE
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR182x [%d,%d]: failed to perform Software reset\n"
argument_list|,
name|pMvSataAdapter
operator|->
name|adapterId
argument_list|,
name|channelNum
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Hardware reset channel */
if|if
condition|(
name|mvSataChannelHardReset
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channelNum
argument_list|)
operator|==
name|MV_FALSE
condition|)
block|{
comment|/* 		 * If failed, try again - this is when trying to hardreset a 		 * channel when drive is just spinning up 		 */
name|StallExec
argument_list|(
literal|5000000
argument_list|)
expr_stmt|;
comment|/* wait 5 sec before trying again */
if|if
condition|(
name|mvSataChannelHardReset
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channelNum
argument_list|)
operator|==
name|MV_FALSE
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR182x [%d,%d]: failed to perform Hard "
literal|"reset\n"
argument_list|,
name|pMvSataAdapter
operator|->
name|adapterId
argument_list|,
name|channelNum
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* identify device*/
if|if
condition|(
name|mvStorageDevATAIdentifyDevice
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channelNum
argument_list|)
operator|==
name|MV_FALSE
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR182x [%d,%d]: failed to perform ATA Identify "
literal|"command\n"
argument_list|,
name|pMvSataAdapter
operator|->
name|adapterId
argument_list|,
name|channelNum
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|hptmv_parse_identify_results
argument_list|(
name|pMvSataChannel
argument_list|)
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR182x [%d,%d]: Error in parsing ATA Identify "
literal|"message\n"
argument_list|,
name|pMvSataAdapter
operator|->
name|adapterId
argument_list|,
name|channelNum
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* mvStorageDevATASetFeatures */
comment|/* Disable 8 bit PIO in case CFA enabled */
if|if
condition|(
name|pMvSataChannel
operator|->
name|identifyDevice
index|[
literal|86
index|]
operator|&
literal|4
condition|)
block|{
name|KdPrint
argument_list|(
operator|(
literal|"RR182x [%d]: Disable 8 bit PIO (CFA enabled) \n"
operator|,
name|pMvSataAdapter
operator|->
name|adapterId
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mvStorageDevATASetFeatures
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channelNum
argument_list|,
name|MV_ATA_SET_FEATURES_DISABLE_8_BIT_PIO
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
name|MV_FALSE
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR182x [%d]: channel %d: "
literal|"mvStorageDevATASetFeatures failed\n"
argument_list|,
name|pMvSataAdapter
operator|->
name|adapterId
argument_list|,
name|channelNum
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|ENABLE_WRITE_CACHE
comment|/* Write cache */
if|if
condition|(
name|pMvSataChannel
operator|->
name|identifyDevice
index|[
literal|82
index|]
operator|&
literal|0x20
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|pMvSataChannel
operator|->
name|identifyDevice
index|[
literal|85
index|]
operator|&
literal|0x20
operator|)
condition|)
block|{
comment|/* if not enabled by default */
if|if
condition|(
name|mvStorageDevATASetFeatures
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channelNum
argument_list|,
name|MV_ATA_SET_FEATURES_ENABLE_WCACHE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
name|MV_FALSE
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR182x [%d]: channel %d: "
literal|"mvStorageDevATASetFeatures failed\n"
argument_list|,
name|pMvSataAdapter
operator|->
name|adapterId
argument_list|,
name|channelNum
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|KdPrint
argument_list|(
operator|(
literal|"RR182x [%d]: channel %d, write cache enabled\n"
operator|,
name|pMvSataAdapter
operator|->
name|adapterId
operator|,
name|channelNum
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|KdPrint
argument_list|(
operator|(
literal|"RR182x [%d]: channel %d, write cache not supported\n"
operator|,
name|pMvSataAdapter
operator|->
name|adapterId
operator|,
name|channelNum
operator|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* disable write cache */
if|if
condition|(
name|pMvSataChannel
operator|->
name|identifyDevice
index|[
literal|85
index|]
operator|&
literal|0x20
condition|)
block|{
name|KdPrint
argument_list|(
operator|(
literal|"RR182x [%d]: channel =%d, disable write cache\n"
operator|,
name|pMvSataAdapter
operator|->
name|adapterId
operator|,
name|channelNum
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mvStorageDevATASetFeatures
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channelNum
argument_list|,
name|MV_ATA_SET_FEATURES_DISABLE_WCACHE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
name|MV_FALSE
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR182x [%d]: channel %d: "
literal|"mvStorageDevATASetFeatures failed\n"
argument_list|,
name|pMvSataAdapter
operator|->
name|adapterId
argument_list|,
name|channelNum
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|KdPrint
argument_list|(
operator|(
literal|"RR182x [%d]: channel=%d, write cache disabled\n"
operator|,
name|pMvSataAdapter
operator|->
name|adapterId
operator|,
name|channelNum
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set transfer mode */
name|KdPrint
argument_list|(
operator|(
literal|"RR182x [%d] Set transfer mode XFER_PIO_SLOW\n"
operator|,
name|pMvSataAdapter
operator|->
name|adapterId
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mvStorageDevATASetFeatures
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channelNum
argument_list|,
name|MV_ATA_SET_FEATURES_TRANSFER
argument_list|,
name|MV_ATA_TRANSFER_PIO_SLOW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
name|MV_FALSE
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR182x [%d] channel %d: Set Features failed\n"
argument_list|,
name|pMvSataAdapter
operator|->
name|adapterId
argument_list|,
name|channelNum
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|pMvSataChannel
operator|->
name|identifyDevice
index|[
name|IDEN_PIO_MODE_SPPORTED
index|]
operator|&
literal|1
condition|)
block|{
name|pioMode
operator|=
name|MV_ATA_TRANSFER_PIO_4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pMvSataChannel
operator|->
name|identifyDevice
index|[
name|IDEN_PIO_MODE_SPPORTED
index|]
operator|&
literal|2
condition|)
block|{
name|pioMode
operator|=
name|MV_ATA_TRANSFER_PIO_3
expr_stmt|;
block|}
else|else
block|{
name|MV_ERROR
argument_list|(
literal|"IAL Error in IDENTIFY info: PIO modes 3 and 4 not "
literal|"supported\n"
argument_list|)
expr_stmt|;
name|pioMode
operator|=
name|MV_ATA_TRANSFER_PIO_SLOW
expr_stmt|;
block|}
name|KdPrint
argument_list|(
operator|(
literal|"RR182x [%d] Set transfer mode XFER_PIO_4\n"
operator|,
name|pMvSataAdapter
operator|->
name|adapterId
operator|)
argument_list|)
expr_stmt|;
name|pAdapter
operator|->
name|mvChannel
index|[
name|channelNum
index|]
operator|.
name|maxPioModeSupported
operator|=
name|pioMode
expr_stmt|;
if|if
condition|(
name|mvStorageDevATASetFeatures
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channelNum
argument_list|,
name|MV_ATA_SET_FEATURES_TRANSFER
argument_list|,
name|pioMode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
name|MV_FALSE
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR182x [%d] channel %d: Set Features failed\n"
argument_list|,
name|pMvSataAdapter
operator|->
name|adapterId
argument_list|,
name|channelNum
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|udmaMode
operator|=
name|MV_ATA_TRANSFER_UDMA_0
expr_stmt|;
if|if
condition|(
name|pMvSataChannel
operator|->
name|identifyDevice
index|[
name|IDEN_UDMA_MODE
index|]
operator|&
literal|0x40
condition|)
block|{
name|udmaMode
operator|=
name|MV_ATA_TRANSFER_UDMA_6
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pMvSataChannel
operator|->
name|identifyDevice
index|[
name|IDEN_UDMA_MODE
index|]
operator|&
literal|0x20
condition|)
block|{
name|udmaMode
operator|=
name|MV_ATA_TRANSFER_UDMA_5
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pMvSataChannel
operator|->
name|identifyDevice
index|[
name|IDEN_UDMA_MODE
index|]
operator|&
literal|0x10
condition|)
block|{
name|udmaMode
operator|=
name|MV_ATA_TRANSFER_UDMA_4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pMvSataChannel
operator|->
name|identifyDevice
index|[
name|IDEN_UDMA_MODE
index|]
operator|&
literal|8
condition|)
block|{
name|udmaMode
operator|=
name|MV_ATA_TRANSFER_UDMA_3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pMvSataChannel
operator|->
name|identifyDevice
index|[
name|IDEN_UDMA_MODE
index|]
operator|&
literal|4
condition|)
block|{
name|udmaMode
operator|=
name|MV_ATA_TRANSFER_UDMA_2
expr_stmt|;
block|}
name|KdPrint
argument_list|(
operator|(
literal|"RR182x [%d] Set transfer mode XFER_UDMA_%d\n"
operator|,
name|pMvSataAdapter
operator|->
name|adapterId
operator|,
name|udmaMode
operator|&
literal|0xf
operator|)
argument_list|)
expr_stmt|;
name|pChannelInfo
operator|->
name|maxUltraDmaModeSupported
operator|=
name|udmaMode
expr_stmt|;
if|#
directive|if
literal|0
block|if (mvStorageDevATASetFeatures(pMvSataAdapter, channelNum, 	    MV_ATA_SET_FEATURES_TRANSFER, udmaMode, 0, 0, 0) == MV_FALSE) { 		MV_ERROR("RR182x [%d] channel %d: Set Features failed\n", 			 pMvSataAdapter->adapterId, channelNum);  		return -1; 	}
endif|#
directive|endif
if|if
condition|(
name|pChannelInfo
operator|->
name|maxUltraDmaModeSupported
operator|==
literal|0xFF
condition|)
return|return
name|TRUE
return|;
do|do
block|{
if|if
condition|(
name|mvStorageDevATASetFeatures
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channelNum
argument_list|,
name|MV_ATA_SET_FEATURES_TRANSFER
argument_list|,
name|pChannelInfo
operator|->
name|maxUltraDmaModeSupported
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|!=
name|MV_FALSE
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|pChannelInfo
operator|->
name|maxUltraDmaModeSupported
operator|<=
name|MV_ATA_TRANSFER_UDMA_0
condition|)
block|{
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|mvStorageDevATASoftResetDevice
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channelNum
argument_list|)
operator|==
name|MV_FALSE
condition|)
block|{
name|mv_reg_write_byte
argument_list|(
name|pMvSataAdapter
operator|->
name|adapterIoBaseAddress
argument_list|,
name|pMvSataChannel
operator|->
name|eDmaRegsOffset
operator|+
literal|0x11c
argument_list|,
comment|/* command reg */
name|MV_ATA_COMMAND_IDLE_IMMEDIATE
argument_list|)
expr_stmt|;
name|mvMicroSecondsDelay
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|mvSataChannelHardReset
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channelNum
argument_list|)
expr_stmt|;
if|if
condition|(
name|mvStorageDevATASoftResetDevice
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channelNum
argument_list|)
operator|==
name|MV_FALSE
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|mvSataChannelHardReset
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channelNum
argument_list|)
operator|==
name|MV_FALSE
condition|)
return|return
name|FALSE
return|;
name|pChannelInfo
operator|->
name|maxUltraDmaModeSupported
operator|--
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
ifdef|#
directive|ifdef
name|ENABLE_READ_AHEAD
comment|/* Read look ahead */
if|if
condition|(
name|pMvSataChannel
operator|->
name|identifyDevice
index|[
literal|82
index|]
operator|&
literal|0x40
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|pMvSataChannel
operator|->
name|identifyDevice
index|[
literal|85
index|]
operator|&
literal|0x40
operator|)
condition|)
block|{
comment|/* if not enabled by default */
if|if
condition|(
name|mvStorageDevATASetFeatures
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channelNum
argument_list|,
name|MV_ATA_SET_FEATURES_ENABLE_RLA
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
name|MV_FALSE
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR182x [%d] channel %d: Set Features "
literal|"failed\n"
argument_list|,
name|pMvSataAdapter
operator|->
name|adapterId
argument_list|,
name|channelNum
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|KdPrint
argument_list|(
operator|(
literal|"RR182x [%d]: channel=%d, read look ahead enabled\n"
operator|,
name|pMvSataAdapter
operator|->
name|adapterId
operator|,
name|channelNum
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|KdPrint
argument_list|(
operator|(
literal|"RR182x [%d]: channel %d, Read Look Ahead not "
literal|"supported\n"
operator|,
name|pMvSataAdapter
operator|->
name|adapterId
operator|,
name|channelNum
operator|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|pMvSataChannel
operator|->
name|identifyDevice
index|[
literal|86
index|]
operator|&
literal|0x20
condition|)
block|{
name|KdPrint
argument_list|(
operator|(
literal|"RR182x [%d]:channel %d, disable read look ahead\n"
operator|,
name|pMvSataAdapter
operator|->
name|adapterId
operator|,
name|channelNum
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mvStorageDevATASetFeatures
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channelNum
argument_list|,
name|MV_ATA_SET_FEATURES_DISABLE_RLA
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
name|MV_FALSE
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR182x [%d]:channel %d:  ATA Set Features "
literal|"failed\n"
argument_list|,
name|pMvSataAdapter
operator|->
name|adapterId
argument_list|,
name|channelNum
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|KdPrint
argument_list|(
operator|(
literal|"RR182x [%d]:channel %d, read look ahead disabled\n"
operator|,
name|pMvSataAdapter
operator|->
name|adapterId
operator|,
name|channelNum
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
block|KdPrint(("RR182x [%d]:channel %d, Set standby timer to 200 seconds\n", 			  pMvSataAdapter->adapterId, channelNum)); 	if (mvStorageDevATAExecuteNonUDMACommand(pMvSataAdapter, channelNum, 						 MV_NON_UDMA_PROTOCOL_NON_DATA, 						 MV_FALSE,
comment|/* isEXT*/
block|NULL, 0, 0,
comment|/* features*/
block|40,
comment|/*sectorCount*/
block|0,
comment|/*lbaLow*/
block|0,
comment|/*lbaMid*/
block|0,
comment|/*lbaHigh*/
block|0,
comment|/*device*/
block|MV_ATA_COMMAND_IDLE) == 						 MV_FALSE) { 		MV_ERROR("RR182x [%d]:channel %d:  ATA Idle command failed\n", 			 pMvSataAdapter->adapterId, channelNum);  		return -1; 	}
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* 2003-9-16 disable TCQ until we have better solution */
block|if ((pMvSataChannel->identifyDevice[IDEN_SUPPORTED_COMMANDS2]& 2)) { 		MV_U8       depth; 		MV_BOOLEAN  result;  		depth = (pMvSataChannel->identifyDevice[IDEN_QUEUE_DEPTH]& 		    0x1f) + 1; 		KdPrint(("RR182x [%d]: channel %d config EDMA, Queued Mode, " 			"queue depth %d\n", pMvSataAdapter->adapterId, 			channelNum, depth)); 		result = mvSataConfigEdmaMode(pMvSataAdapter, channelNum, 		    MV_EDMA_MODE_QUEUED, depth); 		if (result == MV_FALSE) { 			MV_ERROR("RR182x [%d] Error: mvSataConfigEdmaMode " 				 "failed\n", pMvSataAdapter->adapterId); 			return -1; 		} 	} else {
endif|#
directive|endif
name|KdPrint
argument_list|(
operator|(
literal|"RR182x [%d]: channel %d config EDMA, Non Queued Mode\n"
operator|,
name|pMvSataAdapter
operator|->
name|adapterId
operator|,
name|channelNum
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mvSataConfigEdmaMode
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channelNum
argument_list|,
name|MV_EDMA_MODE_NOT_QUEUED
argument_list|,
literal|0
argument_list|)
operator|==
name|MV_FALSE
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR182x [%d] channel %d Error: mvSataConfigEdmaMode "
literal|"failed\n"
argument_list|,
name|pMvSataAdapter
operator|->
name|adapterId
argument_list|,
name|channelNum
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Enable EDMA */
if|if
condition|(
name|mvSataEnableChannelDma
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channelNum
argument_list|)
operator|==
name|MV_FALSE
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR182x [%d] Failed to enable DMA, channel=%d\n"
argument_list|,
name|pMvSataAdapter
operator|->
name|adapterId
argument_list|,
name|channelNum
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|MV_ERROR
argument_list|(
literal|"RR182x [%d,%d]: channel started successfully\n"
argument_list|,
name|pMvSataAdapter
operator|->
name|adapterId
argument_list|,
name|channelNum
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|FOR_DEMO
name|set_fail_led
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channelNum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hptmv_handle_event
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
decl_stmt|;
name|MV_SATA_ADAPTER
modifier|*
name|pMvSataAdapter
decl_stmt|;
name|MV_U8
name|channelIndex
decl_stmt|;
name|pAdapter
operator|=
operator|(
name|IAL_ADAPTER_T
operator|*
operator|)
name|data
expr_stmt|;
name|pMvSataAdapter
operator|=
operator|&
name|pAdapter
operator|->
name|mvSataAdapter
expr_stmt|;
name|mvOsSemTake
argument_list|(
operator|&
name|pMvSataAdapter
operator|->
name|semaphore
argument_list|)
expr_stmt|;
for|for
control|(
name|channelIndex
operator|=
literal|0
init|;
name|channelIndex
operator|<
name|MV_SATA_CHANNELS_NUM
condition|;
name|channelIndex
operator|++
control|)
block|{
switch|switch
condition|(
name|pAdapter
operator|->
name|sataEvents
index|[
name|channelIndex
index|]
condition|)
block|{
case|case
name|SATA_EVENT_CHANNEL_CONNECTED
case|:
comment|/* Handle only connects */
if|if
condition|(
name|flag
operator|==
literal|1
condition|)
break|break;
name|KdPrint
argument_list|(
operator|(
literal|"RR182x [%d,%d]: new device connected\n"
operator|,
name|pMvSataAdapter
operator|->
name|adapterId
operator|,
name|channelIndex
operator|)
argument_list|)
expr_stmt|;
name|hptmv_init_channel
argument_list|(
name|pAdapter
argument_list|,
name|channelIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|mvSataConfigureChannel
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channelIndex
argument_list|)
operator|==
name|MV_FALSE
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR182x [%d,%d] Failed to configure\n"
argument_list|,
name|pMvSataAdapter
operator|->
name|adapterId
argument_list|,
name|channelIndex
argument_list|)
expr_stmt|;
name|hptmv_free_channel
argument_list|(
name|pAdapter
argument_list|,
name|channelIndex
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
literal|0
block|mvSataChannelHardReset(pMvSataAdapter, channel);
endif|#
directive|endif
if|if
condition|(
name|start_channel
argument_list|(
name|pAdapter
argument_list|,
name|channelIndex
argument_list|)
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR182x [%d,%d]Failed to start"
literal|" channel\n"
argument_list|,
name|pMvSataAdapter
operator|->
name|adapterId
argument_list|,
name|channelIndex
argument_list|)
expr_stmt|;
name|hptmv_free_channel
argument_list|(
name|pAdapter
argument_list|,
name|channelIndex
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_change
argument_list|(
name|pAdapter
argument_list|,
name|channelIndex
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
name|pAdapter
operator|->
name|sataEvents
index|[
name|channelIndex
index|]
operator|=
name|SATA_EVENT_NO_CHANGE
expr_stmt|;
break|break;
case|case
name|SATA_EVENT_CHANNEL_DISCONNECTED
case|:
comment|/* Handle only disconnects */
if|if
condition|(
name|flag
operator|==
literal|0
condition|)
break|break;
name|KdPrint
argument_list|(
operator|(
literal|"RR182x [%d,%d]: device disconnected\n"
operator|,
name|pMvSataAdapter
operator|->
name|adapterId
operator|,
name|channelIndex
operator|)
argument_list|)
expr_stmt|;
comment|/* Flush pending commands */
if|if
condition|(
name|pMvSataAdapter
operator|->
name|sataChannel
index|[
name|channelIndex
index|]
condition|)
block|{
name|_VBUS_INST
argument_list|(
argument|&pAdapter->VBus
argument_list|)
name|mvSataFlushDmaQueue
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channelIndex
argument_list|,
name|MV_FLUSH_TYPE_CALLBACK
argument_list|)
expr_stmt|;
name|CheckPendingCall
argument_list|(
name|_VBUS_P0
argument_list|)
expr_stmt|;
name|mvSataRemoveChannel
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channelIndex
argument_list|)
expr_stmt|;
name|hptmv_free_channel
argument_list|(
name|pAdapter
argument_list|,
name|channelIndex
argument_list|)
expr_stmt|;
name|pMvSataAdapter
operator|->
name|sataChannel
index|[
name|channelIndex
index|]
operator|=
name|NULL
expr_stmt|;
name|KdPrint
argument_list|(
operator|(
literal|"RR182x [%d,%d]: channel removed\n"
operator|,
name|pMvSataAdapter
operator|->
name|adapterId
operator|,
name|channelIndex
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pAdapter
operator|->
name|outstandingCommands
operator|==
literal|0
operator|&&
name|DPC_Request_Nums
operator|==
literal|0
condition|)
name|Check_Idle_Call
argument_list|(
name|pAdapter
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|KdPrint
argument_list|(
operator|(
literal|"RR182x [%d,%d]: channel already "
literal|"removed!!\n"
operator|,
name|pMvSataAdapter
operator|->
name|adapterId
operator|,
name|channelIndex
operator|)
argument_list|)
expr_stmt|;
block|}
name|pAdapter
operator|->
name|sataEvents
index|[
name|channelIndex
index|]
operator|=
name|SATA_EVENT_NO_CHANGE
expr_stmt|;
break|break;
case|case
name|SATA_EVENT_NO_CHANGE
case|:
break|break;
default|default:
break|break;
block|}
block|}
name|mvOsSemRelease
argument_list|(
operator|&
name|pMvSataAdapter
operator|->
name|semaphore
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|EVENT_CONNECT
value|1
end_define

begin_define
define|#
directive|define
name|EVENT_DISCONNECT
value|0
end_define

begin_function
specifier|static
name|void
name|hptmv_handle_event_connect
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|hptmv_handle_event
argument_list|(
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hptmv_handle_event_disconnect
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|hptmv_handle_event
argument_list|(
name|data
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|MV_BOOLEAN
name|hptmv_event_notify
parameter_list|(
name|MV_SATA_ADAPTER
modifier|*
name|pMvSataAdapter
parameter_list|,
name|MV_EVENT_TYPE
name|eventType
parameter_list|,
name|MV_U32
name|param1
parameter_list|,
name|MV_U32
name|param2
parameter_list|)
block|{
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
init|=
name|pMvSataAdapter
operator|->
name|IALData
decl_stmt|;
switch|switch
condition|(
name|eventType
condition|)
block|{
case|case
name|MV_EVENT_TYPE_SATA_CABLE
case|:
block|{
name|MV_U8
name|channel
init|=
name|param2
decl_stmt|;
if|if
condition|(
name|param1
operator|==
name|EVENT_CONNECT
condition|)
block|{
name|pAdapter
operator|->
name|sataEvents
index|[
name|channel
index|]
operator|=
name|SATA_EVENT_CHANNEL_CONNECTED
expr_stmt|;
name|KdPrint
argument_list|(
operator|(
literal|"RR182x [%d,%d]: device connected event "
literal|"received\n"
operator|,
name|pMvSataAdapter
operator|->
name|adapterId
operator|,
name|channel
operator|)
argument_list|)
expr_stmt|;
comment|/* 			 * Delete previous timers (if multiple drives connected 			 * in the same time 			 */
name|pAdapter
operator|->
name|event_timer_connect
operator|=
name|timeout
argument_list|(
name|hptmv_handle_event_connect
argument_list|,
name|pAdapter
argument_list|,
literal|10
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|param1
operator|==
name|EVENT_DISCONNECT
condition|)
block|{
name|pAdapter
operator|->
name|sataEvents
index|[
name|channel
index|]
operator|=
name|SATA_EVENT_CHANNEL_DISCONNECTED
expr_stmt|;
name|KdPrint
argument_list|(
operator|(
literal|"RR182x [%d,%d]: device disconnected event "
literal|"received \n"
operator|,
name|pMvSataAdapter
operator|->
name|adapterId
operator|,
name|channel
operator|)
argument_list|)
expr_stmt|;
name|device_change
argument_list|(
name|pAdapter
argument_list|,
name|channel
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* 			 * Delete previous timers (if multiple drives 			 * disconnected in the same time 			 */
name|pAdapter
operator|->
name|event_timer_disconnect
operator|=
name|timeout
argument_list|(
name|hptmv_handle_event_disconnect
argument_list|,
name|pAdapter
argument_list|,
literal|10
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MV_ERROR
argument_list|(
literal|"RR182x: illigal value for param1(%d) at "
literal|"connect/disconect event, host=%d\n"
argument_list|,
name|param1
argument_list|,
name|pMvSataAdapter
operator|->
name|adapterId
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|MV_EVENT_TYPE_ADAPTER_ERROR
case|:
name|KdPrint
argument_list|(
operator|(
literal|"RR182x: DEVICE error event received, pci cause "
literal|"reg=%x,  don't how to handle this\n"
operator|,
name|param1
operator|)
argument_list|)
expr_stmt|;
return|return
name|MV_TRUE
return|;
default|default:
name|MV_ERROR
argument_list|(
literal|"RR182x[%d]: unknown event type (%d)\n"
argument_list|,
name|pMvSataAdapter
operator|->
name|adapterId
argument_list|,
name|eventType
argument_list|)
expr_stmt|;
return|return
name|MV_FALSE
return|;
block|}
return|return
name|MV_TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hptmv_map_req
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|dma_addr_t
modifier|*
name|addr
decl_stmt|;
name|addr
operator|=
operator|(
name|dma_addr_t
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|nsegs
operator|!=
literal|1
condition|)
return|return;
operator|*
name|addr
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|hptmv_allocate_edma_queues
parameter_list|(
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
parameter_list|)
block|{
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|pAdapter
operator|->
name|req_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|pAdapter
operator|->
name|requestsArrayBaseAddr
argument_list|,
name|BUS_DMA_WAITOK
argument_list|,
operator|&
name|pAdapter
operator|->
name|req_map
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR182x[%d]: Failed to allocate memory for EDMA "
literal|"request queues\n"
argument_list|,
name|pAdapter
operator|->
name|mvSataAdapter
operator|.
name|adapterId
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
operator|(
name|void
operator|)
name|bus_dmamap_load
argument_list|(
name|pAdapter
operator|->
name|req_dmat
argument_list|,
name|pAdapter
operator|->
name|req_map
argument_list|,
name|pAdapter
operator|->
name|requestsArrayBaseAddr
argument_list|,
name|REQUESTS_ARRAY_SIZE
argument_list|,
name|hptmv_map_req
argument_list|,
operator|&
name|pAdapter
operator|->
name|requestsArrayBaseDmaAddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pAdapter
operator|->
name|requestsArrayBaseAlignedAddr
operator|=
name|pAdapter
operator|->
name|requestsArrayBaseAddr
expr_stmt|;
name|pAdapter
operator|->
name|requestsArrayBaseAlignedAddr
operator|+=
name|MV_EDMA_REQUEST_QUEUE_SIZE
expr_stmt|;
name|pAdapter
operator|->
name|requestsArrayBaseAlignedAddr
operator|=
operator|(
name|MV_U8
operator|*
operator|)
operator|(
operator|(
operator|(
name|ULONG_PTR
operator|)
name|pAdapter
operator|->
name|requestsArrayBaseAlignedAddr
operator|)
operator|&
operator|~
call|(
name|ULONG_PTR
call|)
argument_list|(
name|MV_EDMA_REQUEST_QUEUE_SIZE
operator|-
literal|1
argument_list|)
operator|)
expr_stmt|;
name|pAdapter
operator|->
name|requestsArrayBaseDmaAlignedAddr
operator|=
name|pAdapter
operator|->
name|requestsArrayBaseDmaAddr
expr_stmt|;
name|pAdapter
operator|->
name|requestsArrayBaseDmaAlignedAddr
operator|+=
name|MV_EDMA_REQUEST_QUEUE_SIZE
expr_stmt|;
name|pAdapter
operator|->
name|requestsArrayBaseDmaAlignedAddr
operator|&=
operator|~
call|(
name|ULONG_PTR
call|)
argument_list|(
name|MV_EDMA_REQUEST_QUEUE_SIZE
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pAdapter
operator|->
name|requestsArrayBaseDmaAlignedAddr
operator|-
name|pAdapter
operator|->
name|requestsArrayBaseDmaAddr
operator|)
operator|!=
operator|(
name|pAdapter
operator|->
name|requestsArrayBaseAlignedAddr
operator|-
name|pAdapter
operator|->
name|requestsArrayBaseAddr
operator|)
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR182x[%d]: Error in Request Quueues Alignment\n"
argument_list|,
name|pAdapter
operator|->
name|mvSataAdapter
operator|.
name|adapterId
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|pAdapter
operator|->
name|req_dmat
argument_list|,
name|pAdapter
operator|->
name|req_map
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|pAdapter
operator|->
name|req_dmat
argument_list|,
name|pAdapter
operator|->
name|requestsArrayBaseAddr
argument_list|,
name|pAdapter
operator|->
name|req_map
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* response queues */
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|pAdapter
operator|->
name|resp_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|pAdapter
operator|->
name|responsesArrayBaseAddr
argument_list|,
name|BUS_DMA_WAITOK
argument_list|,
operator|&
name|pAdapter
operator|->
name|resp_map
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR182x[%d]: Failed to allocate memory for EDMA "
literal|"response queues\n"
argument_list|,
name|pAdapter
operator|->
name|mvSataAdapter
operator|.
name|adapterId
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|pAdapter
operator|->
name|req_dmat
argument_list|,
name|pAdapter
operator|->
name|req_map
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|pAdapter
operator|->
name|req_dmat
argument_list|,
name|pAdapter
operator|->
name|requestsArrayBaseAddr
argument_list|,
name|pAdapter
operator|->
name|req_map
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
operator|(
name|void
operator|)
name|bus_dmamap_load
argument_list|(
name|pAdapter
operator|->
name|resp_dmat
argument_list|,
name|pAdapter
operator|->
name|resp_map
argument_list|,
name|pAdapter
operator|->
name|responsesArrayBaseAddr
argument_list|,
name|RESPONSES_ARRAY_SIZE
argument_list|,
name|hptmv_map_req
argument_list|,
operator|&
name|pAdapter
operator|->
name|responsesArrayBaseDmaAddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pAdapter
operator|->
name|responsesArrayBaseAlignedAddr
operator|=
name|pAdapter
operator|->
name|responsesArrayBaseAddr
expr_stmt|;
name|pAdapter
operator|->
name|responsesArrayBaseAlignedAddr
operator|+=
name|MV_EDMA_RESPONSE_QUEUE_SIZE
expr_stmt|;
name|pAdapter
operator|->
name|responsesArrayBaseAlignedAddr
operator|=
operator|(
name|MV_U8
operator|*
operator|)
operator|(
operator|(
operator|(
name|ULONG_PTR
operator|)
name|pAdapter
operator|->
name|responsesArrayBaseAlignedAddr
operator|)
operator|&
operator|~
call|(
name|ULONG_PTR
call|)
argument_list|(
name|MV_EDMA_RESPONSE_QUEUE_SIZE
operator|-
literal|1
argument_list|)
operator|)
expr_stmt|;
name|pAdapter
operator|->
name|responsesArrayBaseDmaAlignedAddr
operator|=
name|pAdapter
operator|->
name|responsesArrayBaseDmaAddr
expr_stmt|;
name|pAdapter
operator|->
name|responsesArrayBaseDmaAlignedAddr
operator|+=
name|MV_EDMA_RESPONSE_QUEUE_SIZE
expr_stmt|;
name|pAdapter
operator|->
name|responsesArrayBaseDmaAlignedAddr
operator|&=
operator|~
call|(
name|ULONG_PTR
call|)
argument_list|(
name|MV_EDMA_RESPONSE_QUEUE_SIZE
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pAdapter
operator|->
name|responsesArrayBaseDmaAlignedAddr
operator|-
name|pAdapter
operator|->
name|responsesArrayBaseDmaAddr
operator|)
operator|!=
operator|(
name|pAdapter
operator|->
name|responsesArrayBaseAlignedAddr
operator|-
name|pAdapter
operator|->
name|responsesArrayBaseAddr
operator|)
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR182x[%d]: Error in Response Quueues Alignment\n"
argument_list|,
name|pAdapter
operator|->
name|mvSataAdapter
operator|.
name|adapterId
argument_list|)
expr_stmt|;
name|hptmv_free_edma_queues
argument_list|(
name|pAdapter
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hptmv_free_edma_queues
parameter_list|(
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
parameter_list|)
block|{
name|bus_dmamap_unload
argument_list|(
name|pAdapter
operator|->
name|req_dmat
argument_list|,
name|pAdapter
operator|->
name|req_map
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|pAdapter
operator|->
name|req_dmat
argument_list|,
name|pAdapter
operator|->
name|requestsArrayBaseAddr
argument_list|,
name|pAdapter
operator|->
name|req_map
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|pAdapter
operator|->
name|resp_dmat
argument_list|,
name|pAdapter
operator|->
name|resp_map
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|pAdapter
operator|->
name|resp_dmat
argument_list|,
name|pAdapter
operator|->
name|responsesArrayBaseAddr
argument_list|,
name|pAdapter
operator|->
name|resp_map
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|PVOID
name|AllocatePRDTable
parameter_list|(
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
parameter_list|)
block|{
name|PVOID
name|ret
decl_stmt|;
if|if
condition|(
name|pAdapter
operator|->
name|pFreePRDLink
condition|)
block|{
name|KdPrint
argument_list|(
operator|(
literal|"pAdapter->pFreePRDLink:%p\n"
operator|,
name|pAdapter
operator|->
name|pFreePRDLink
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|pAdapter
operator|->
name|pFreePRDLink
expr_stmt|;
name|pAdapter
operator|->
name|pFreePRDLink
operator|=
operator|*
operator|(
name|void
operator|*
operator|*
operator|)
name|ret
expr_stmt|;
return|return
name|ret
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|FreePRDTable
parameter_list|(
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
parameter_list|,
name|PVOID
name|PRDTable
parameter_list|)
block|{
operator|*
operator|(
name|void
operator|*
operator|*
operator|)
name|PRDTable
operator|=
name|pAdapter
operator|->
name|pFreePRDLink
expr_stmt|;
name|pAdapter
operator|->
name|pFreePRDLink
operator|=
name|PRDTable
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|extern
name|PVDevice
name|fGetFirstChild
parameter_list|(
name|PVDevice
name|pLogical
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|fResetBootMark
parameter_list|(
name|PVDevice
name|pLogical
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|fRegisterVdevice
parameter_list|(
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
parameter_list|)
block|{
name|PVDevice
name|pPhysical
decl_stmt|,
name|pLogical
decl_stmt|;
name|PVBus
name|pVBus
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MV_SATA_CHANNELS_NUM
condition|;
name|i
operator|++
control|)
block|{
name|pPhysical
operator|=
operator|&
operator|(
name|pAdapter
operator|->
name|VDevices
index|[
name|i
index|]
operator|)
expr_stmt|;
name|pLogical
operator|=
name|pPhysical
expr_stmt|;
while|while
condition|(
name|pLogical
operator|->
name|pParent
condition|)
name|pLogical
operator|=
name|pLogical
operator|->
name|pParent
expr_stmt|;
if|if
condition|(
name|pLogical
operator|->
name|vf_online
operator|==
literal|0
condition|)
block|{
name|pPhysical
operator|->
name|vf_bootmark
operator|=
name|pLogical
operator|->
name|vf_bootmark
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|pLogical
operator|->
name|VDeviceType
operator|==
name|VD_SPARE
operator|||
name|pPhysical
operator|!=
name|fGetFirstChild
argument_list|(
name|pLogical
argument_list|)
condition|)
continue|continue;
name|pVBus
operator|=
operator|&
name|pAdapter
operator|->
name|VBus
expr_stmt|;
if|if
condition|(
name|pVBus
condition|)
block|{
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|j
operator|<
name|MAX_VDEVICE_PER_VBUS
operator|&&
name|pVBus
operator|->
name|pVDevice
index|[
name|j
index|]
condition|)
name|j
operator|++
expr_stmt|;
if|if
condition|(
name|j
operator|<
name|MAX_VDEVICE_PER_VBUS
condition|)
block|{
name|pVBus
operator|->
name|pVDevice
index|[
name|j
index|]
operator|=
name|pLogical
expr_stmt|;
name|pLogical
operator|->
name|pVBus
operator|=
name|pVBus
expr_stmt|;
if|if
condition|(
name|j
operator|>
literal|0
operator|&&
name|pLogical
operator|->
name|vf_bootmark
condition|)
block|{
if|if
condition|(
name|pVBus
operator|->
name|pVDevice
index|[
literal|0
index|]
operator|->
name|vf_bootmark
condition|)
block|{
name|fResetBootMark
argument_list|(
name|pLogical
argument_list|)
expr_stmt|;
block|}
else|else
block|{
do|do
block|{
name|pVBus
operator|->
name|pVDevice
index|[
name|j
index|]
operator|=
name|pVBus
operator|->
name|pVDevice
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|j
condition|)
do|;
name|pVBus
operator|->
name|pVDevice
index|[
literal|0
index|]
operator|=
name|pLogical
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
end_function

begin_function
name|PVDevice
name|GetSpareDisk
parameter_list|(
name|_VBUS_ARG
name|PVDevice
name|pArray
parameter_list|)
block|{
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
decl_stmt|;
name|ULONG
name|capacity
decl_stmt|;
name|ULONG
name|thiscap
decl_stmt|,
name|maxcap
init|=
name|MAX_LBA_T
decl_stmt|;
name|PVDevice
name|pVDevice
decl_stmt|,
name|pFind
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|pAdapter
operator|=
operator|(
name|IAL_ADAPTER_T
operator|*
operator|)
name|pArray
operator|->
name|pVBus
operator|->
name|OsExt
expr_stmt|;
name|capacity
operator|=
name|LongDiv
argument_list|(
name|pArray
operator|->
name|VDeviceCapacity
argument_list|,
name|pArray
operator|->
name|u
operator|.
name|array
operator|.
name|bArnMember
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MV_SATA_CHANNELS_NUM
condition|;
name|i
operator|++
control|)
block|{
name|pVDevice
operator|=
operator|&
name|pAdapter
operator|->
name|VDevices
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|pVDevice
condition|)
continue|continue;
name|thiscap
operator|=
name|pArray
operator|->
name|vf_format_v2
condition|?
name|pVDevice
operator|->
name|u
operator|.
name|disk
operator|.
name|dDeRealCapacity
else|:
name|pVDevice
operator|->
name|VDeviceCapacity
expr_stmt|;
comment|/* find the smallest usable spare disk */
if|if
condition|(
name|pVDevice
operator|->
name|VDeviceType
operator|==
name|VD_SPARE
operator|&&
name|pVDevice
operator|->
name|u
operator|.
name|disk
operator|.
name|df_on_line
operator|&&
name|thiscap
operator|<
name|maxcap
operator|&&
name|thiscap
operator|>=
name|capacity
condition|)
block|{
name|maxcap
operator|=
name|pVDevice
operator|->
name|VDeviceCapacity
expr_stmt|;
name|pFind
operator|=
name|pVDevice
expr_stmt|;
block|}
block|}
return|return
name|pFind
return|;
block|}
end_function

begin_comment
comment|/******************************************************************  * IO ATA Command  *******************************************************************/
end_comment

begin_function
name|int
name|HPTLIBAPI
name|fDeReadWrite
parameter_list|(
name|PDevice
name|pDev
parameter_list|,
name|ULONG
name|Lba
parameter_list|,
name|UCHAR
name|Cmd
parameter_list|,
name|void
modifier|*
name|tmpBuffer
parameter_list|)
block|{
return|return
name|mvReadWrite
argument_list|(
name|pDev
operator|->
name|mv
argument_list|,
name|Lba
argument_list|,
name|Cmd
argument_list|,
name|tmpBuffer
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|HPTLIBAPI
name|fDeSelectMode
parameter_list|(
name|PDevice
name|pDev
parameter_list|,
name|UCHAR
name|NewMode
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|SIMULATE
name|MV_SATA_CHANNEL
modifier|*
name|pSataChannel
decl_stmt|;
name|MV_SATA_ADAPTER
modifier|*
name|pSataAdapter
decl_stmt|;
name|MV_U8
name|channelIndex
decl_stmt|;
name|UCHAR
name|mvMode
decl_stmt|;
name|pSataChannel
operator|=
name|pDev
operator|->
name|mv
expr_stmt|;
name|pSataAdapter
operator|=
name|pSataChannel
operator|->
name|mvSataAdapter
expr_stmt|;
name|channelIndex
operator|=
name|pSataChannel
operator|->
name|channelNumber
expr_stmt|;
comment|/* 508x don't use MW-DMA? */
if|if
condition|(
name|NewMode
operator|>
literal|4
operator|&&
name|NewMode
operator|<
literal|8
condition|)
name|NewMode
operator|=
literal|4
expr_stmt|;
name|pDev
operator|->
name|bDeModeSetting
operator|=
name|NewMode
expr_stmt|;
if|if
condition|(
name|NewMode
operator|<=
literal|4
condition|)
name|mvMode
operator|=
name|MV_ATA_TRANSFER_PIO_0
operator|+
name|NewMode
expr_stmt|;
else|else
name|mvMode
operator|=
name|MV_ATA_TRANSFER_UDMA_0
operator|+
operator|(
name|NewMode
operator|-
literal|8
operator|)
expr_stmt|;
comment|/*To fix 88i8030 bug*/
if|if
condition|(
name|mvMode
operator|>
name|MV_ATA_TRANSFER_UDMA_0
operator|&&
name|mvMode
operator|<
name|MV_ATA_TRANSFER_UDMA_4
condition|)
name|mvMode
operator|=
name|MV_ATA_TRANSFER_UDMA_0
expr_stmt|;
name|mvSataDisableChannelDma
argument_list|(
name|pSataAdapter
argument_list|,
name|channelIndex
argument_list|)
expr_stmt|;
comment|/* Flush pending commands */
name|mvSataFlushDmaQueue
argument_list|(
name|pSataAdapter
argument_list|,
name|channelIndex
argument_list|,
name|MV_FLUSH_TYPE_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mvStorageDevATASetFeatures
argument_list|(
name|pSataAdapter
argument_list|,
name|channelIndex
argument_list|,
name|MV_ATA_SET_FEATURES_TRANSFER
argument_list|,
name|mvMode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
name|MV_FALSE
condition|)
block|{
name|KdPrint
argument_list|(
operator|(
literal|"channel %d: Set Features failed\n"
operator|,
name|channelIndex
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Enable EDMA */
if|if
condition|(
name|mvSataEnableChannelDma
argument_list|(
name|pSataAdapter
argument_list|,
name|channelIndex
argument_list|)
operator|==
name|MV_FALSE
condition|)
name|KdPrint
argument_list|(
operator|(
literal|"Failed to enable DMA, channel=%d"
operator|,
name|channelIndex
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SUPPORT_ARRAY
end_ifdef

begin_define
define|#
directive|define
name|IdeRegisterVDevice
value|fCheckArray
end_define

begin_else
else|#
directive|else
end_else

begin_function
name|void
name|IdeRegisterVDevice
parameter_list|(
name|PDevice
name|pDev
parameter_list|)
block|{
name|PVDevice
name|pVDev
init|=
name|Map2pVDevice
argument_list|(
name|pDev
argument_list|)
decl_stmt|;
name|pVDev
operator|->
name|VDeviceType
operator|=
name|pDev
operator|->
name|df_atapi
condition|?
name|VD_ATAPI
else|:
name|pDev
operator|->
name|df_removable_drive
condition|?
name|VD_REMOVABLE
else|:
name|VD_SINGLE_DISK
expr_stmt|;
name|pVDev
operator|->
name|vf_online
operator|=
literal|1
expr_stmt|;
name|pVDev
operator|->
name|VDeviceCapacity
operator|=
name|pDev
operator|->
name|dDeRealCapacity
expr_stmt|;
name|pVDev
operator|->
name|pfnSendCommand
operator|=
name|pfnSendCommand
index|[
name|pVDev
operator|->
name|VDeviceType
index|]
expr_stmt|;
name|pVDev
operator|->
name|pfnDeviceFailed
operator|=
name|pfnDeviceFailed
index|[
name|pVDev
operator|->
name|VDeviceType
index|]
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|num_adapters
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|init_adapter
parameter_list|(
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
parameter_list|)
block|{
name|PCommand
name|pCmd
decl_stmt|;
name|pPrivCommand
name|prvCmd
decl_stmt|;
name|PVBus
name|_vbus_p
init|=
operator|&
name|pAdapter
operator|->
name|VBus
decl_stmt|;
name|MV_SATA_ADAPTER
modifier|*
name|pMvSataAdapter
decl_stmt|;
name|PUCHAR
name|PRDTable
decl_stmt|;
name|int
name|i
decl_stmt|,
name|channel
decl_stmt|,
name|rid
decl_stmt|,
name|error
decl_stmt|;
name|PVDevice
name|pVDev
decl_stmt|;
name|intrmask_t
name|oldspl
init|=
name|lock_driver
argument_list|()
decl_stmt|;
name|pAdapter
operator|->
name|next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gIal_Adapter
operator|==
literal|0
condition|)
block|{
name|gIal_Adapter
operator|=
name|pAdapter
expr_stmt|;
name|pCurAdapter
operator|=
name|gIal_Adapter
expr_stmt|;
block|}
else|else
block|{
name|pCurAdapter
operator|->
name|next
operator|=
name|pAdapter
expr_stmt|;
name|pCurAdapter
operator|=
name|pAdapter
expr_stmt|;
block|}
name|pAdapter
operator|->
name|outstandingCommands
operator|=
literal|0
expr_stmt|;
name|pMvSataAdapter
operator|=
operator|&
operator|(
name|pAdapter
operator|->
name|mvSataAdapter
operator|)
expr_stmt|;
name|_vbus_p
operator|->
name|OsExt
operator|=
operator|(
name|void
operator|*
operator|)
name|pAdapter
expr_stmt|;
name|pMvSataAdapter
operator|->
name|IALData
operator|=
name|pAdapter
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
name|MV_MAX_SEGMENTS
argument_list|,
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|pAdapter
operator|->
name|parent_dmat
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR182x: Failed to create busdma resources\n"
argument_list|)
expr_stmt|;
name|unlock_driver
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|pAdapter
operator|->
name|parent_dmat
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|REQUESTS_ARRAY_SIZE
argument_list|,
literal|1
argument_list|,
name|REQUESTS_ARRAY_SIZE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|pAdapter
operator|->
name|req_dmat
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR182x: Failed to create busdma resources\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|unregister
goto|;
block|}
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|pAdapter
operator|->
name|parent_dmat
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|RESPONSES_ARRAY_SIZE
argument_list|,
literal|1
argument_list|,
name|RESPONSES_ARRAY_SIZE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|pAdapter
operator|->
name|resp_dmat
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR182x: Failed to create busdma resources\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|unregister
goto|;
block|}
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|pAdapter
operator|->
name|parent_dmat
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|MAXBSIZE
argument_list|,
name|MV_MAX_SEGMENTS
argument_list|,
name|MAXBSIZE
argument_list|,
literal|0
argument_list|,
name|busdma_lock_mutex
argument_list|,
operator|&
name|Giant
argument_list|,
operator|&
name|pAdapter
operator|->
name|buf_dmat
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR182x: Failed to create busdma resources\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|unregister
goto|;
block|}
if|if
condition|(
name|hptmv_allocate_edma_queues
argument_list|(
name|pAdapter
argument_list|)
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR182x: Failed to allocate memory for EDMA queues\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|unregister
goto|;
block|}
comment|/* also map EPROM address */
name|rid
operator|=
literal|0x10
expr_stmt|;
if|if
condition|(
operator|(
name|pAdapter
operator|->
name|mem_res
operator|=
name|bus_alloc_resource
argument_list|(
name|pAdapter
operator|->
name|hpt_dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
name|MV_SATA_PCI_BAR0_SPACE_SIZE
operator|+
literal|0x40000
argument_list|,
name|RF_ACTIVE
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR182x: Failed to remap memory space\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|unregister
goto|;
block|}
comment|/* 	 * This field is opaque.  Abuse it so that the bus_space functions 	 * can get the info that they need when called. 	 */
name|pMvSataAdapter
operator|->
name|adapterIoBaseAddress
operator|=
name|pAdapter
expr_stmt|;
name|pAdapter
operator|->
name|mem_bsh
operator|=
name|rman_get_bushandle
argument_list|(
name|pAdapter
operator|->
name|mem_res
argument_list|)
expr_stmt|;
name|pAdapter
operator|->
name|mem_btag
operator|=
name|rman_get_bustag
argument_list|(
name|pAdapter
operator|->
name|mem_res
argument_list|)
expr_stmt|;
name|pMvSataAdapter
operator|->
name|adapterId
operator|=
name|num_adapters
operator|++
expr_stmt|;
comment|/* get the revision ID */
name|pMvSataAdapter
operator|->
name|pciConfigRevisionId
operator|=
name|pci_read_config
argument_list|(
name|pAdapter
operator|->
name|hpt_dev
argument_list|,
name|PCIR_REVID
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pMvSataAdapter
operator|->
name|pciConfigDeviceId
operator|=
name|pci_get_device
argument_list|(
name|pAdapter
operator|->
name|hpt_dev
argument_list|)
expr_stmt|;
comment|/* init RR182x */
name|pMvSataAdapter
operator|->
name|intCoalThre
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|pMvSataAdapter
operator|->
name|intCoalThre
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
name|pMvSataAdapter
operator|->
name|intTimeThre
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|pMvSataAdapter
operator|->
name|intTimeThre
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
name|pMvSataAdapter
operator|->
name|pciCommand
operator|=
literal|0x0107E371
expr_stmt|;
name|pMvSataAdapter
operator|->
name|pciSerrMask
operator|=
literal|0xd77fe6ul
expr_stmt|;
name|pMvSataAdapter
operator|->
name|pciInterruptMask
operator|=
literal|0xd77fe6ul
expr_stmt|;
name|pMvSataAdapter
operator|->
name|mvSataEventNotify
operator|=
name|hptmv_event_notify
expr_stmt|;
if|if
condition|(
name|mvSataInitAdapter
argument_list|(
name|pMvSataAdapter
argument_list|)
operator|==
name|MV_FALSE
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR182x[%d]: core failed to initialize the adapter\n"
argument_list|,
name|pMvSataAdapter
operator|->
name|adapterId
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|unregister
goto|;
block|}
name|pAdapter
operator|->
name|ver_601
operator|=
name|pMvSataAdapter
operator|->
name|pcbVersion
expr_stmt|;
ifndef|#
directive|ifndef
name|FOR_DEMO
name|set_fail_leds
argument_list|(
name|pMvSataAdapter
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* setup command blocks */
name|KdPrint
argument_list|(
operator|(
literal|"Allocate command blocks\n"
operator|)
argument_list|)
expr_stmt|;
name|_vbus_
argument_list|(
name|pFreeCommands
argument_list|)
operator|=
literal|0
expr_stmt|;
name|pAdapter
operator|->
name|pCommandBlocks
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|_Command
argument_list|)
operator|*
name|MAX_COMMAND_BLOCKS_FOR_EACH_VBUS
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|KdPrint
argument_list|(
operator|(
literal|"pCommandBlocks:%p\n"
operator|,
name|pAdapter
operator|->
name|pCommandBlocks
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Gotta cheat here.  The _Command struct only gives us a single 	 * pointer for private data, but we need to store more than that. 	 * Of course the pCommand retains no type stability, and FreeCommand 	 * is hidden in the binary object, so gotta track these on our own 	 * list. 	 */
name|pAdapter
operator|->
name|pPrivateBlocks
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|_privCommand
argument_list|)
operator|*
name|MAX_COMMAND_BLOCKS_FOR_EACH_VBUS
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|pAdapter
operator|->
name|PrivCmdTQH
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_COMMAND_BLOCKS_FOR_EACH_VBUS
condition|;
name|i
operator|++
control|)
block|{
name|pCmd
operator|=
operator|&
name|pAdapter
operator|->
name|pCommandBlocks
index|[
name|i
index|]
expr_stmt|;
name|prvCmd
operator|=
operator|&
name|pAdapter
operator|->
name|pPrivateBlocks
index|[
name|i
index|]
expr_stmt|;
name|prvCmd
operator|->
name|pAdapter
operator|=
name|pAdapter
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|pAdapter
operator|->
name|buf_dmat
argument_list|,
literal|0
argument_list|,
operator|&
name|prvCmd
operator|->
name|buf_map
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|FreeCommand
argument_list|(
name|_VBUS_P
argument_list|(
name|pCmd
argument_list|)
argument_list|)
expr_stmt|;
name|FreePrivCommand
argument_list|(
name|pAdapter
argument_list|,
name|prvCmd
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
comment|/* setup PRD Tables */
name|KdPrint
argument_list|(
operator|(
literal|"Allocate PRD Tables\n"
operator|)
argument_list|)
expr_stmt|;
name|pAdapter
operator|->
name|pFreePRDLink
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|pAdapter
operator|->
name|parent_dmat
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|PRD_ENTRIES_SIZE
operator|*
name|PRD_TABLES_FOR_VBUS
argument_list|,
literal|1
argument_list|,
name|PRD_ENTRIES_SIZE
operator|*
name|PRD_TABLES_FOR_VBUS
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|pAdapter
operator|->
name|prd_dmat
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR182x: Failed to create busdma resources\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|unregister
goto|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|pAdapter
operator|->
name|prd_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|pAdapter
operator|->
name|prdTableAddr
argument_list|,
name|BUS_DMA_WAITOK
argument_list|,
operator|&
name|pAdapter
operator|->
name|prd_map
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|unregister
goto|;
operator|(
name|void
operator|)
name|bus_dmamap_load
argument_list|(
name|pAdapter
operator|->
name|prd_dmat
argument_list|,
name|pAdapter
operator|->
name|prd_map
argument_list|,
name|pAdapter
operator|->
name|prdTableAddr
argument_list|,
name|PRD_ENTRIES_SIZE
operator|*
name|PRD_TABLES_FOR_VBUS
argument_list|,
name|hptmv_map_req
argument_list|,
operator|&
name|pAdapter
operator|->
name|prdTableDmaAddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|KdPrint
argument_list|(
operator|(
literal|"prdTableAddr:%p\n"
operator|,
name|pAdapter
operator|->
name|prdTableAddr
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pAdapter
operator|->
name|prdTableAddr
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"insufficient PRD Tables\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|unregister
goto|;
block|}
name|PRDTable
operator|=
name|pAdapter
operator|->
name|prdTableAddr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PRD_TABLES_FOR_VBUS
condition|;
name|i
operator|++
control|)
block|{
name|KdPrint
argument_list|(
operator|(
literal|"i= %d, pAdapter->pFreePRDLink= %p\n"
operator|,
name|i
operator|,
name|pAdapter
operator|->
name|pFreePRDLink
operator|)
argument_list|)
expr_stmt|;
name|FreePRDTable
argument_list|(
name|pAdapter
argument_list|,
name|PRDTable
argument_list|)
expr_stmt|;
name|PRDTable
operator|+=
name|PRD_ENTRIES_SIZE
expr_stmt|;
block|}
comment|/* enable the adapter interrupts */
comment|/* configure and start the connected channels*/
for|for
control|(
name|channel
operator|=
literal|0
init|;
name|channel
operator|<
name|MV_SATA_CHANNELS_NUM
condition|;
name|channel
operator|++
control|)
block|{
name|pAdapter
operator|->
name|mvChannel
index|[
name|channel
index|]
operator|.
name|online
operator|=
name|MV_FALSE
expr_stmt|;
if|if
condition|(
name|mvSataIsStorageDeviceConnected
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channel
argument_list|)
operator|!=
name|MV_TRUE
condition|)
continue|continue;
name|KdPrint
argument_list|(
operator|(
literal|"RR182x[%d]: channel %d is connected\n"
operator|,
name|pMvSataAdapter
operator|->
name|adapterId
operator|,
name|channel
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hptmv_init_channel
argument_list|(
name|pAdapter
argument_list|,
name|channel
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mvSataConfigureChannel
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channel
argument_list|)
operator|==
name|MV_FALSE
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR182x[%d]: Failed to configure "
literal|"channel %d\n"
argument_list|,
name|pMvSataAdapter
operator|->
name|adapterId
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|hptmv_free_channel
argument_list|(
name|pAdapter
argument_list|,
name|channel
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|start_channel
argument_list|(
name|pAdapter
argument_list|,
name|channel
argument_list|)
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR182x[%d]: Failed to start channel, "
literal|"channel=%d\n"
argument_list|,
name|pMvSataAdapter
operator|->
name|adapterId
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|hptmv_free_channel
argument_list|(
name|pAdapter
argument_list|,
name|channel
argument_list|)
expr_stmt|;
block|}
name|pAdapter
operator|->
name|mvChannel
index|[
name|channel
index|]
operator|.
name|online
operator|=
name|MV_TRUE
expr_stmt|;
if|#
directive|if
literal|0
block|mvSataChannelSetEdmaLoopBackMode( 			    pMvSataAdapter, channel, MV_TRUE);
endif|#
directive|endif
block|}
name|KdPrint
argument_list|(
operator|(
literal|"pAdapter->mvChannel[channel].online:%x, channel:%d\n"
operator|,
name|pAdapter
operator|->
name|mvChannel
index|[
name|channel
index|]
operator|.
name|online
operator|,
name|channel
operator|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SUPPORT_ARRAY
for|for
control|(
name|i
operator|=
name|MAX_ARRAY_DEVICE
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|pVDev
operator|=
name|ArrayTables
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|mArFreeArrayTable
argument_list|(
name|pVDev
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|KdPrint
argument_list|(
operator|(
literal|"Initialize Devices\n"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|channel
operator|=
literal|0
init|;
name|channel
operator|<
name|MV_SATA_CHANNELS_NUM
condition|;
name|channel
operator|++
control|)
block|{
name|MV_SATA_CHANNEL
modifier|*
name|pMvSataChannel
decl_stmt|;
name|pMvSataChannel
operator|=
name|pMvSataAdapter
operator|->
name|sataChannel
index|[
name|channel
index|]
expr_stmt|;
if|if
condition|(
name|pMvSataChannel
condition|)
block|{
name|init_vdev_params
argument_list|(
name|pAdapter
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|IdeRegisterVDevice
argument_list|(
operator|&
name|pAdapter
operator|->
name|VDevices
index|[
name|channel
index|]
operator|.
name|u
operator|.
name|disk
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|SUPPORT_ARRAY
name|CheckArrayCritical
argument_list|(
name|_VBUS_P0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|_vbus_p
operator|->
name|nInstances
operator|=
literal|1
expr_stmt|;
name|fRegisterVdevice
argument_list|(
name|pAdapter
argument_list|)
expr_stmt|;
for|for
control|(
name|channel
operator|=
literal|0
init|;
name|channel
operator|<
name|MV_SATA_CHANNELS_NUM
condition|;
name|channel
operator|++
control|)
block|{
name|pVDev
operator|=
name|_vbus_p
operator|->
name|pVDevice
index|[
name|channel
index|]
expr_stmt|;
if|if
condition|(
name|pVDev
operator|&&
name|pVDev
operator|->
name|vf_online
condition|)
name|fCheckBootable
argument_list|(
name|pVDev
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|SUPPORT_ARRAY
argument_list|)
operator|&&
name|defined
argument_list|(
name|_RAID5N_
argument_list|)
name|init_raid5_memory
argument_list|(
name|_VBUS_P0
argument_list|)
expr_stmt|;
name|_vbus_
argument_list|(
name|r5
argument_list|)
operator|.
name|enable_write_back
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"RR182x: RAID5 write-back %s\n"
argument_list|,
name|_vbus_
argument_list|(
name|r5
argument_list|)
operator|.
name|enable_write_back
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mvSataUnmaskAdapterInterrupt
argument_list|(
name|pMvSataAdapter
argument_list|)
expr_stmt|;
name|unlock_driver
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|unregister
label|:
if|if
condition|(
name|pAdapter
operator|->
name|mem_res
operator|!=
literal|0
condition|)
name|bus_release_resource
argument_list|(
name|pAdapter
operator|->
name|hpt_dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|rid
argument_list|,
name|pAdapter
operator|->
name|mem_res
argument_list|)
expr_stmt|;
name|hptmv_free_edma_queues
argument_list|(
name|pAdapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|pAdapter
operator|->
name|resp_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|pAdapter
operator|->
name|resp_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|pAdapter
operator|->
name|req_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|pAdapter
operator|->
name|req_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|pAdapter
operator|->
name|buf_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|pAdapter
operator|->
name|buf_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|pAdapter
operator|->
name|parent_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|pAdapter
operator|->
name|parent_dmat
argument_list|)
expr_stmt|;
name|unlock_driver
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|MvSataResetChannel
parameter_list|(
name|MV_SATA_ADAPTER
modifier|*
name|pMvSataAdapter
parameter_list|,
name|MV_U8
name|channel
parameter_list|)
block|{
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
init|=
operator|(
name|IAL_ADAPTER_T
operator|*
operator|)
name|pMvSataAdapter
operator|->
name|IALData
decl_stmt|;
name|mvSataDisableChannelDma
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channel
argument_list|)
expr_stmt|;
comment|/* Flush pending commands */
name|mvSataFlushDmaQueue
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channel
argument_list|,
name|MV_FLUSH_TYPE_CALLBACK
argument_list|)
expr_stmt|;
comment|/* Software reset channel */
if|if
condition|(
name|mvStorageDevATASoftResetDevice
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channel
argument_list|)
operator|==
name|MV_FALSE
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR182x [%d,%d]: failed to perform Software reset\n"
argument_list|,
name|pMvSataAdapter
operator|->
name|adapterId
argument_list|,
name|channel
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Hardware reset channel */
if|if
condition|(
name|mvSataChannelHardReset
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channel
argument_list|)
operator|==
name|MV_FALSE
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR182x [%d,%d] Failed to Hard reser the SATA "
literal|"channel\n"
argument_list|,
name|pMvSataAdapter
operator|->
name|adapterId
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|hptmv_free_channel
argument_list|(
name|pAdapter
argument_list|,
name|channel
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|mvSataIsStorageDeviceConnected
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channel
argument_list|)
operator|==
name|MV_FALSE
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"RR182x [%d,%d] Failed to Connect Device\n"
argument_list|,
name|pMvSataAdapter
operator|->
name|adapterId
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|hptmv_free_channel
argument_list|(
name|pAdapter
argument_list|,
name|channel
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
comment|/* Set transfer mode */
if|if
condition|(
operator|(
name|mvStorageDevATASetFeatures
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channel
argument_list|,
name|MV_ATA_SET_FEATURES_TRANSFER
argument_list|,
name|MV_ATA_TRANSFER_PIO_SLOW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
name|MV_FALSE
operator|)
operator|||
operator|(
name|mvStorageDevATASetFeatures
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channel
argument_list|,
name|MV_ATA_SET_FEATURES_TRANSFER
argument_list|,
name|pAdapter
operator|->
name|mvChannel
index|[
name|channel
index|]
operator|.
name|maxPioModeSupported
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
name|MV_FALSE
operator|)
operator|||
operator|(
name|mvStorageDevATASetFeatures
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channel
argument_list|,
name|MV_ATA_SET_FEATURES_TRANSFER
argument_list|,
name|pAdapter
operator|->
name|mvChannel
index|[
name|channel
index|]
operator|.
name|maxUltraDmaModeSupported
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
name|MV_FALSE
operator|)
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"channel %d: Set Features failed"
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|hptmv_free_channel
argument_list|(
name|pAdapter
argument_list|,
name|channel
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Enable EDMA */
if|if
condition|(
name|mvSataEnableChannelDma
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channel
argument_list|)
operator|==
name|MV_FALSE
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"Failed to enable DMA, channel=%d"
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|hptmv_free_channel
argument_list|(
name|pAdapter
argument_list|,
name|channel
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fResetActiveCommands
parameter_list|(
name|PVBus
name|_vbus_p
parameter_list|)
block|{
name|MV_SATA_ADAPTER
modifier|*
name|pMvSataAdapter
decl_stmt|;
name|MV_U8
name|channel
decl_stmt|;
name|int
name|rtn
init|=
literal|0
decl_stmt|;
name|pMvSataAdapter
operator|=
operator|&
operator|(
operator|(
name|IAL_ADAPTER_T
operator|*
operator|)
name|_vbus_p
operator|->
name|OsExt
operator|)
operator|->
name|mvSataAdapter
expr_stmt|;
for|for
control|(
name|channel
operator|=
literal|0
init|;
name|channel
operator|<
name|MV_SATA_CHANNELS_NUM
condition|;
name|channel
operator|++
control|)
block|{
if|if
condition|(
name|pMvSataAdapter
operator|->
name|sataChannel
index|[
name|channel
index|]
operator|&&
name|pMvSataAdapter
operator|->
name|sataChannel
index|[
name|channel
index|]
operator|->
name|outstandingCommands
condition|)
if|if
condition|(
name|MvSataResetChannel
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channel
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|rtn
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|HPT_ASSERT
argument_list|(
name|rtn
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|fCompleteAllCommandsSynchronously
parameter_list|(
name|PVBus
name|_vbus_p
parameter_list|)
block|{
name|UINT
name|cont
decl_stmt|;
name|ULONG
name|ticks
init|=
literal|0
decl_stmt|;
name|MV_U8
name|channel
decl_stmt|;
name|MV_SATA_ADAPTER
modifier|*
name|pMvSataAdapter
decl_stmt|;
name|MV_SATA_CHANNEL
modifier|*
name|pMvSataChannel
decl_stmt|;
name|pMvSataAdapter
operator|=
operator|&
operator|(
operator|(
name|IAL_ADAPTER_T
operator|*
operator|)
name|_vbus_p
operator|->
name|OsExt
operator|)
operator|->
name|mvSataAdapter
expr_stmt|;
do|do
block|{
name|check_cmds
label|:
name|cont
operator|=
literal|0
expr_stmt|;
name|CheckPendingCall
argument_list|(
name|_VBUS_P0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_RAID5N_
name|dataxfer_poll
argument_list|()
expr_stmt|;
name|xor_poll
argument_list|()
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|channel
operator|=
literal|0
init|;
name|channel
operator|<
name|MV_SATA_CHANNELS_NUM
condition|;
name|channel
operator|++
control|)
block|{
name|pMvSataChannel
operator|=
name|pMvSataAdapter
operator|->
name|sataChannel
index|[
name|channel
index|]
expr_stmt|;
if|if
condition|(
name|pMvSataChannel
operator|&&
name|pMvSataChannel
operator|->
name|outstandingCommands
condition|)
block|{
while|while
condition|(
name|pMvSataChannel
operator|->
name|outstandingCommands
condition|)
block|{
if|if
condition|(
operator|!
name|mvSataInterruptServiceRoutine
argument_list|(
name|pMvSataAdapter
argument_list|)
condition|)
block|{
name|StallExec
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|ticks
operator|++
operator|>
literal|3000
condition|)
block|{
name|MvSataResetChannel
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channel
argument_list|)
expr_stmt|;
goto|goto
name|check_cmds
goto|;
block|}
block|}
else|else
name|ticks
operator|=
literal|0
expr_stmt|;
block|}
name|cont
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|cont
condition|)
do|;
block|}
end_function

begin_function
name|void
name|fResetVBus
parameter_list|(
name|_VBUS_ARG0
parameter_list|)
block|{
name|KdPrint
argument_list|(
operator|(
literal|"fMvResetBus(%p)"
operator|,
name|_vbus_p
operator|)
argument_list|)
expr_stmt|;
comment|/* some commands may already finished. */
name|CheckPendingCall
argument_list|(
name|_VBUS_P0
argument_list|)
expr_stmt|;
name|fResetActiveCommands
argument_list|(
name|_vbus_p
argument_list|)
expr_stmt|;
comment|/*  	 * the other pending commands may still be finished successfully. 	 */
name|fCompleteAllCommandsSynchronously
argument_list|(
name|_vbus_p
argument_list|)
expr_stmt|;
comment|/* Now there should be no pending commands. No more action needed. */
name|CheckIdleCall
argument_list|(
name|_VBUS_P0
argument_list|)
expr_stmt|;
name|KdPrint
argument_list|(
operator|(
literal|"fMvResetBus() done"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fRescanAllDevice
parameter_list|(
name|_VBUS_ARG0
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|MV_BOOLEAN
name|CommandCompletionCB
parameter_list|(
name|MV_SATA_ADAPTER
modifier|*
name|pMvSataAdapter
parameter_list|,
name|MV_U8
name|channelNum
parameter_list|,
name|MV_COMPLETION_TYPE
name|comp_type
parameter_list|,
name|MV_VOID_PTR
name|commandId
parameter_list|,
name|MV_U16
name|responseFlags
parameter_list|,
name|MV_U32
name|timeStamp
parameter_list|,
name|MV_STORAGE_DEVICE_REGISTERS
modifier|*
name|registerStruct
parameter_list|)
block|{
name|PCommand
name|pCmd
init|=
operator|(
name|PCommand
operator|)
name|commandId
decl_stmt|;
name|_VBUS_INST
argument_list|(
argument|pCmd->pVDevice->pVBus
argument_list|)
if|if
condition|(
name|pCmd
operator|->
name|uScratch
operator|.
name|sata_param
operator|.
name|prdAddr
condition|)
name|FreePRDTable
argument_list|(
name|pMvSataAdapter
operator|->
name|IALData
argument_list|,
name|pCmd
operator|->
name|uScratch
operator|.
name|sata_param
operator|.
name|prdAddr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|comp_type
condition|)
block|{
case|case
name|MV_COMPLETION_TYPE_NORMAL
case|:
name|pCmd
operator|->
name|Result
operator|=
name|RETURN_SUCCESS
expr_stmt|;
break|break;
case|case
name|MV_COMPLETION_TYPE_ABORT
case|:
name|pCmd
operator|->
name|Result
operator|=
name|RETURN_BUS_RESET
expr_stmt|;
break|break;
case|case
name|MV_COMPLETION_TYPE_ERROR
case|:
name|MV_ERROR
argument_list|(
literal|"IAL: COMPLETION ERROR, adapter %d, channel %d, "
literal|"flags=%x\n"
argument_list|,
name|pMvSataAdapter
operator|->
name|adapterId
argument_list|,
name|channelNum
argument_list|,
name|responseFlags
argument_list|)
expr_stmt|;
if|if
condition|(
name|responseFlags
operator|&
literal|4
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"ATA regs: error %x, sector count %x, LBA low "
literal|"%x, LBA mid %x, LBA high %x, device %x, "
literal|"status %x\n"
argument_list|,
name|registerStruct
operator|->
name|errorRegister
argument_list|,
name|registerStruct
operator|->
name|sectorCountRegister
argument_list|,
name|registerStruct
operator|->
name|lbaLowRegister
argument_list|,
name|registerStruct
operator|->
name|lbaMidRegister
argument_list|,
name|registerStruct
operator|->
name|lbaHighRegister
argument_list|,
name|registerStruct
operator|->
name|deviceRegister
argument_list|,
name|registerStruct
operator|->
name|statusRegister
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * We can't do handleEdmaError directly here, because 		 * CommandCompletionCB is called by mv's ISR, if we retry the 		 * command, than the internel data structure may be destroyed 		 */
name|pCmd
operator|->
name|uScratch
operator|.
name|sata_param
operator|.
name|responseFlags
operator|=
name|responseFlags
expr_stmt|;
name|pCmd
operator|->
name|uScratch
operator|.
name|sata_param
operator|.
name|bIdeStatus
operator|=
name|registerStruct
operator|->
name|statusRegister
expr_stmt|;
name|pCmd
operator|->
name|uScratch
operator|.
name|sata_param
operator|.
name|errorRegister
operator|=
name|registerStruct
operator|->
name|errorRegister
expr_stmt|;
name|pCmd
operator|->
name|pVDevice
operator|->
name|u
operator|.
name|disk
operator|.
name|QueueLength
operator|--
expr_stmt|;
name|CallAfterReturn
argument_list|(
name|_VBUS_P
argument_list|(
argument|DPC_PROC
argument_list|)
name|handleEdmaError
argument_list|,
name|pCmd
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
default|default:
name|MV_ERROR
argument_list|(
literal|" Unknown completion type (%d)\n"
argument_list|,
name|comp_type
argument_list|)
expr_stmt|;
return|return
name|MV_FALSE
return|;
block|}
if|if
condition|(
name|pCmd
operator|->
name|uCmd
operator|.
name|Ide
operator|.
name|Command
operator|==
name|IDE_COMMAND_VERIFY
operator|&&
name|pCmd
operator|->
name|uScratch
operator|.
name|sata_param
operator|.
name|cmd_priv
operator|>
literal|1
condition|)
block|{
name|pCmd
operator|->
name|uScratch
operator|.
name|sata_param
operator|.
name|cmd_priv
operator|--
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|pCmd
operator|->
name|pVDevice
operator|->
name|u
operator|.
name|disk
operator|.
name|QueueLength
operator|--
expr_stmt|;
name|CallAfterReturn
argument_list|(
name|_VBUS_P
argument_list|(
argument|DPC_PROC
argument_list|)
name|pCmd
operator|->
name|pfnCompletion
argument_list|,
name|pCmd
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|void
name|fDeviceSendCommand
parameter_list|(
name|_VBUS_ARG
name|PCommand
name|pCmd
parameter_list|)
block|{
name|MV_SATA_EDMA_PRD_ENTRY
modifier|*
name|pPRDTable
init|=
literal|0
decl_stmt|;
name|MV_SATA_ADAPTER
modifier|*
name|pMvSataAdapter
decl_stmt|;
name|MV_SATA_CHANNEL
modifier|*
name|pMvSataChannel
decl_stmt|;
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
decl_stmt|;
name|MV_QUEUE_COMMAND_RESULT
name|result
decl_stmt|;
name|MV_QUEUE_COMMAND_INFO
name|commandInfo
decl_stmt|;
name|MV_UDMA_COMMAND_PARAMS
modifier|*
name|pUdmaParams
decl_stmt|;
name|MV_NONE_UDMA_COMMAND_PARAMS
modifier|*
name|pNoUdmaParams
decl_stmt|;
name|MV_BOOLEAN
name|is48bit
init|=
name|MV_FALSE
decl_stmt|;
name|PVDevice
name|pVDevice
decl_stmt|;
name|PDevice
name|pDevice
decl_stmt|;
name|ULONG
name|Lba
decl_stmt|;
name|USHORT
name|nSector
decl_stmt|;
name|MV_U8
name|channel
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|pVDevice
operator|=
name|pCmd
operator|->
name|pVDevice
expr_stmt|;
name|pDevice
operator|=
operator|&
name|pVDevice
operator|->
name|u
operator|.
name|disk
expr_stmt|;
name|Lba
operator|=
name|pCmd
operator|->
name|uCmd
operator|.
name|Ide
operator|.
name|Lba
expr_stmt|;
name|nSector
operator|=
name|pCmd
operator|->
name|uCmd
operator|.
name|Ide
operator|.
name|nSectors
expr_stmt|;
name|pUdmaParams
operator|=
operator|&
name|commandInfo
operator|.
name|commandParams
operator|.
name|udmaCommand
expr_stmt|;
name|pNoUdmaParams
operator|=
operator|&
name|commandInfo
operator|.
name|commandParams
operator|.
name|NoneUdmaCommand
expr_stmt|;
name|DECLARE_BUFFER
argument_list|(
name|FPSCAT_GATH
argument_list|,
name|tmpSg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pDevice
operator|->
name|df_on_line
condition|)
block|{
name|MV_ERROR
argument_list|(
literal|"Device is offline"
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Result
operator|=
name|RETURN_BAD_DEVICE
expr_stmt|;
name|CallAfterReturn
argument_list|(
name|_VBUS_P
argument_list|(
argument|DPC_PROC
argument_list|)
name|pCmd
operator|->
name|pfnCompletion
argument_list|,
name|pCmd
argument_list|)
expr_stmt|;
return|return;
block|}
name|pDevice
operator|->
name|HeadPosition
operator|=
name|pCmd
operator|->
name|uCmd
operator|.
name|Ide
operator|.
name|Lba
operator|+
name|pCmd
operator|->
name|uCmd
operator|.
name|Ide
operator|.
name|nSectors
expr_stmt|;
name|pMvSataChannel
operator|=
name|pDevice
operator|->
name|mv
expr_stmt|;
name|pMvSataAdapter
operator|=
name|pMvSataChannel
operator|->
name|mvSataAdapter
expr_stmt|;
name|channel
operator|=
name|pMvSataChannel
operator|->
name|channelNumber
expr_stmt|;
name|pAdapter
operator|=
name|pMvSataAdapter
operator|->
name|IALData
expr_stmt|;
comment|/* 	 * Old RAID0 has hidden lba. Remember to clear dDeHiddenLba when 	 * deleting array! 	 */
name|Lba
operator|+=
name|pDevice
operator|->
name|dDeHiddenLba
expr_stmt|;
comment|/* check LBA */
if|if
condition|(
name|Lba
operator|+
name|nSector
operator|-
literal|1
operator|>
name|pDevice
operator|->
name|dDeRealCapacity
condition|)
block|{
name|pCmd
operator|->
name|Result
operator|=
name|RETURN_INVALID_REQUEST
expr_stmt|;
name|CallAfterReturn
argument_list|(
name|_VBUS_P
argument_list|(
argument|DPC_PROC
argument_list|)
name|pCmd
operator|->
name|pfnCompletion
argument_list|,
name|pCmd
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|Lba
operator|&
literal|0xF0000000
condition|)
block|{
name|is48bit
operator|=
name|MV_TRUE
expr_stmt|;
block|}
switch|switch
condition|(
name|pCmd
operator|->
name|uCmd
operator|.
name|Ide
operator|.
name|Command
condition|)
block|{
case|case
name|IDE_COMMAND_READ
case|:
case|case
name|IDE_COMMAND_WRITE
case|:
if|if
condition|(
name|pDevice
operator|->
name|bDeModeSetting
operator|<
literal|8
condition|)
goto|goto
name|pio
goto|;
name|commandInfo
operator|.
name|type
operator|=
name|MV_QUEUED_COMMAND_TYPE_UDMA
expr_stmt|;
name|pUdmaParams
operator|->
name|isEXT
operator|=
name|is48bit
expr_stmt|;
name|pUdmaParams
operator|->
name|numOfSectors
operator|=
name|nSector
expr_stmt|;
name|pUdmaParams
operator|->
name|lowLBAAddress
operator|=
name|Lba
expr_stmt|;
name|pUdmaParams
operator|->
name|highLBAAddress
operator|=
literal|0
expr_stmt|;
name|pUdmaParams
operator|->
name|prdHighAddr
operator|=
literal|0
expr_stmt|;
name|pUdmaParams
operator|->
name|callBack
operator|=
name|CommandCompletionCB
expr_stmt|;
name|pUdmaParams
operator|->
name|commandId
operator|=
operator|(
name|MV_VOID_PTR
operator|)
name|pCmd
expr_stmt|;
if|if
condition|(
name|pCmd
operator|->
name|uCmd
operator|.
name|Ide
operator|.
name|Command
operator|==
name|IDE_COMMAND_READ
condition|)
name|pUdmaParams
operator|->
name|readWrite
operator|=
name|MV_UDMA_TYPE_READ
expr_stmt|;
else|else
name|pUdmaParams
operator|->
name|readWrite
operator|=
name|MV_UDMA_TYPE_WRITE
expr_stmt|;
if|if
condition|(
name|pCmd
operator|->
name|pSgTable
operator|&&
name|pCmd
operator|->
name|cf_physical_sg
condition|)
block|{
name|FPSCAT_GATH
name|sg1
init|=
name|tmpSg
decl_stmt|,
name|sg2
init|=
name|pCmd
operator|->
name|pSgTable
decl_stmt|;
do|do
block|{
operator|*
name|sg1
operator|++
operator|=
operator|*
name|sg2
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|sg2
operator|++
operator|->
name|wSgFlag
operator|&
name|SG_FLAG_EOT
operator|)
operator|==
literal|0
condition|)
do|;
block|}
elseif|else
if|if
condition|(
operator|!
name|pCmd
operator|->
name|pfnBuildSgl
operator|||
operator|!
name|pCmd
operator|->
name|pfnBuildSgl
argument_list|(
argument|_VBUS_P pCmd
argument_list|,
argument|tmpSg
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|pio
label|:
name|mvSataDisableChannelDma
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|mvSataFlushDmaQueue
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channel
argument_list|,
name|MV_FLUSH_TYPE_CALLBACK
argument_list|)
expr_stmt|;
if|if
condition|(
name|pCmd
operator|->
name|pSgTable
operator|&&
name|pCmd
operator|->
name|cf_physical_sg
operator|==
literal|0
condition|)
block|{
name|FPSCAT_GATH
name|sg1
init|=
name|tmpSg
decl_stmt|,
name|sg2
init|=
name|pCmd
operator|->
name|pSgTable
decl_stmt|;
do|do
block|{
operator|*
name|sg1
operator|++
operator|=
operator|*
name|sg2
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|sg2
operator|++
operator|->
name|wSgFlag
operator|&
name|SG_FLAG_EOT
operator|)
operator|==
literal|0
condition|)
do|;
block|}
elseif|else
if|if
condition|(
operator|!
name|pCmd
operator|->
name|pfnBuildSgl
operator|||
operator|!
name|pCmd
operator|->
name|pfnBuildSgl
argument_list|(
argument|_VBUS_P pCmd
argument_list|,
argument|tmpSg
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|pCmd
operator|->
name|Result
operator|=
name|RETURN_NEED_LOGICAL_SG
expr_stmt|;
goto|goto
name|finish_cmd
goto|;
block|}
do|do
block|{
name|ULONG
name|size
decl_stmt|;
name|ULONG_PTR
name|addr
init|=
name|tmpSg
operator|->
name|dSgAddress
decl_stmt|;
name|size
operator|=
name|tmpSg
operator|->
name|wSgSize
condition|?
name|tmpSg
operator|->
name|wSgSize
else|:
literal|0x10000
expr_stmt|;
if|if
condition|(
name|size
operator|&
literal|0x1ff
condition|)
block|{
name|pCmd
operator|->
name|Result
operator|=
name|RETURN_INVALID_REQUEST
expr_stmt|;
goto|goto
name|finish_cmd
goto|;
block|}
if|if
condition|(
name|mvStorageDevATAExecuteNonUDMACommand
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channel
argument_list|,
operator|(
name|pCmd
operator|->
name|cf_data_out
operator|)
condition|?
name|MV_NON_UDMA_PROTOCOL_PIO_DATA_OUT
else|:
name|MV_NON_UDMA_PROTOCOL_PIO_DATA_IN
argument_list|,
name|is48bit
argument_list|,
operator|(
name|MV_U16_PTR
operator|)
name|addr
argument_list|,
name|size
operator|>>
literal|1
argument_list|,
comment|/* count */
literal|0
argument_list|,
comment|/* features N/A */
call|(
name|MV_U16
call|)
argument_list|(
name|size
operator|>>
literal|9
argument_list|)
argument_list|,
comment|/*sector count*/
call|(
name|MV_U16
call|)
argument_list|(
operator|(
name|is48bit
condition|?
call|(
name|MV_U16
call|)
argument_list|(
operator|(
name|Lba
operator|>>
literal|16
operator|)
operator|&
literal|0xFF00
argument_list|)
else|:
literal|0
operator|)
operator||
call|(
name|UCHAR
call|)
argument_list|(
name|Lba
operator|&
literal|0xFF
argument_list|)
argument_list|)
argument_list|,
comment|/*lbalow*/
call|(
name|MV_U16
call|)
argument_list|(
operator|(
name|Lba
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
argument_list|,
comment|/* lbaMid */
call|(
name|MV_U16
call|)
argument_list|(
operator|(
name|Lba
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
argument_list|)
argument_list|,
comment|/* lbaHig */
call|(
name|MV_U8
call|)
argument_list|(
literal|0x40
operator||
operator|(
name|is48bit
condition|?
literal|0
else|:
call|(
name|UCHAR
call|)
argument_list|(
name|Lba
operator|>>
literal|24
argument_list|)
operator|&
literal|0xFF
operator|)
argument_list|)
argument_list|,
comment|/* device */
call|(
name|MV_U8
call|)
argument_list|(
name|is48bit
condition|?
operator|(
name|pCmd
operator|->
name|cf_data_in
condition|?
name|IDE_COMMAND_READ_EXT
else|:
name|IDE_COMMAND_WRITE_EXT
operator|)
else|:
name|pCmd
operator|->
name|uCmd
operator|.
name|Ide
operator|.
name|Command
argument_list|)
argument_list|)
operator|==
name|MV_FALSE
condition|)
block|{
name|pCmd
operator|->
name|Result
operator|=
name|RETURN_IDE_ERROR
expr_stmt|;
goto|goto
name|finish_cmd
goto|;
block|}
name|Lba
operator|+=
name|size
operator|>>
literal|9
expr_stmt|;
if|if
condition|(
name|Lba
operator|&
literal|0xF0000000
condition|)
name|is48bit
operator|=
name|MV_TRUE
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|tmpSg
operator|++
operator|->
name|wSgFlag
operator|&
name|SG_FLAG_EOT
operator|)
operator|==
literal|0
condition|)
do|;
name|pCmd
operator|->
name|Result
operator|=
name|RETURN_SUCCESS
expr_stmt|;
name|finish_cmd
label|:
name|mvSataEnableChannelDma
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|CallAfterReturn
argument_list|(
name|_VBUS_P
argument_list|(
argument|DPC_PROC
argument_list|)
name|pCmd
operator|->
name|pfnCompletion
argument_list|,
name|pCmd
argument_list|)
expr_stmt|;
return|return;
block|}
name|pPRDTable
operator|=
name|AllocatePRDTable
argument_list|(
name|pAdapter
argument_list|)
expr_stmt|;
name|KdPrint
argument_list|(
operator|(
literal|"pPRDTable:%p\n"
operator|,
name|pPRDTable
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pPRDTable
condition|)
block|{
name|pCmd
operator|->
name|Result
operator|=
name|RETURN_DEVICE_BUSY
expr_stmt|;
name|CallAfterReturn
argument_list|(
name|_VBUS_P
argument_list|(
argument|DPC_PROC
argument_list|)
name|pCmd
operator|->
name|pfnCompletion
argument_list|,
name|pCmd
argument_list|)
expr_stmt|;
name|HPT_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
do|do
block|{
name|pPRDTable
index|[
name|i
index|]
operator|.
name|highBaseAddr
operator|=
literal|0
expr_stmt|;
name|pPRDTable
index|[
name|i
index|]
operator|.
name|flags
operator|=
operator|(
name|MV_U16
operator|)
name|tmpSg
operator|->
name|wSgFlag
expr_stmt|;
name|pPRDTable
index|[
name|i
index|]
operator|.
name|byteCount
operator|=
operator|(
name|MV_U16
operator|)
name|tmpSg
operator|->
name|wSgSize
expr_stmt|;
name|pPRDTable
index|[
name|i
index|]
operator|.
name|lowBaseAddr
operator|=
operator|(
name|MV_U32
operator|)
name|tmpSg
operator|->
name|dSgAddress
expr_stmt|;
name|pPRDTable
index|[
name|i
index|]
operator|.
name|reserved
operator|=
literal|0
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|tmpSg
operator|++
operator|->
name|wSgFlag
operator|&
name|SG_FLAG_EOT
operator|)
operator|==
literal|0
condition|)
do|;
name|pUdmaParams
operator|->
name|prdLowAddr
operator|=
name|pAdapter
operator|->
name|prdTableDmaAddr
operator|+
operator|(
operator|(
name|ULONG
operator|)
name|pPRDTable
operator|-
operator|(
name|ULONG
operator|)
name|pAdapter
operator|->
name|prdTableAddr
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|pUdmaParams
operator|->
name|numOfSectors
operator|==
literal|256
operator|)
operator|&&
operator|(
name|pMvSataChannel
operator|->
name|lba48Address
operator|==
name|MV_FALSE
operator|)
condition|)
block|{
name|pUdmaParams
operator|->
name|numOfSectors
operator|=
literal|0
expr_stmt|;
block|}
name|pCmd
operator|->
name|uScratch
operator|.
name|sata_param
operator|.
name|prdAddr
operator|=
operator|(
name|PVOID
operator|)
name|pPRDTable
expr_stmt|;
name|result
operator|=
name|mvSataQueueCommand
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channel
argument_list|,
operator|&
name|commandInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|MV_QUEUE_COMMAND_RESULT_OK
condition|)
block|{
name|queue_failed
label|:
switch|switch
condition|(
name|result
condition|)
block|{
case|case
name|MV_QUEUE_COMMAND_RESULT_BAD_LBA_ADDRESS
case|:
name|MV_ERROR
argument_list|(
literal|"IAL Error: Edma Queue command "
literal|"failed. Bad LBA LBA[31:0](0x%08x)\n"
argument_list|,
name|pUdmaParams
operator|->
name|lowLBAAddress
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Result
operator|=
name|RETURN_IDE_ERROR
expr_stmt|;
break|break;
case|case
name|MV_QUEUE_COMMAND_RESULT_QUEUED_MODE_DISABLED
case|:
name|MV_ERROR
argument_list|(
literal|"IAL Error: Edma Queue command "
literal|"failed. EDMA disabled adapter %d "
literal|"channel %d\n"
argument_list|,
name|pMvSataAdapter
operator|->
name|adapterId
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|mvSataEnableChannelDma
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Result
operator|=
name|RETURN_IDE_ERROR
expr_stmt|;
break|break;
case|case
name|MV_QUEUE_COMMAND_RESULT_FULL
case|:
name|MV_ERROR
argument_list|(
literal|"IAL Error: Edma Queue command "
literal|"failed. Queue is Full adapter %d "
literal|"channel %d\n"
argument_list|,
name|pMvSataAdapter
operator|->
name|adapterId
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Result
operator|=
name|RETURN_DEVICE_BUSY
expr_stmt|;
break|break;
case|case
name|MV_QUEUE_COMMAND_RESULT_BAD_PARAMS
case|:
name|MV_ERROR
argument_list|(
literal|"IAL Error: Edma Queue command "
literal|"failed. (Bad Params), pMvSataAdapter:"
literal|" %p,  pSataChannel: %p.\n"
argument_list|,
name|pMvSataAdapter
argument_list|,
name|pMvSataAdapter
operator|->
name|sataChannel
index|[
name|channel
index|]
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Result
operator|=
name|RETURN_IDE_ERROR
expr_stmt|;
break|break;
default|default:
name|MV_ERROR
argument_list|(
literal|"IAL Error: Bad result value (%d) "
literal|"from queue command\n"
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Result
operator|=
name|RETURN_IDE_ERROR
expr_stmt|;
block|}
if|if
condition|(
name|pPRDTable
condition|)
name|FreePRDTable
argument_list|(
name|pAdapter
argument_list|,
name|pPRDTable
argument_list|)
expr_stmt|;
name|CallAfterReturn
argument_list|(
name|_VBUS_P
argument_list|(
argument|DPC_PROC
argument_list|)
name|pCmd
operator|->
name|pfnCompletion
argument_list|,
name|pCmd
argument_list|)
expr_stmt|;
block|}
name|pDevice
operator|->
name|QueueLength
operator|++
expr_stmt|;
return|return;
case|case
name|IDE_COMMAND_VERIFY
case|:
name|commandInfo
operator|.
name|type
operator|=
name|MV_QUEUED_COMMAND_TYPE_NONE_UDMA
expr_stmt|;
name|pNoUdmaParams
operator|->
name|bufPtr
operator|=
name|NULL
expr_stmt|;
name|pNoUdmaParams
operator|->
name|callBack
operator|=
name|CommandCompletionCB
expr_stmt|;
name|pNoUdmaParams
operator|->
name|commandId
operator|=
operator|(
name|MV_VOID_PTR
operator|)
name|pCmd
expr_stmt|;
name|pNoUdmaParams
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|pNoUdmaParams
operator|->
name|features
operator|=
literal|0
expr_stmt|;
name|pNoUdmaParams
operator|->
name|protocolType
operator|=
name|MV_NON_UDMA_PROTOCOL_NON_DATA
expr_stmt|;
name|pCmd
operator|->
name|uScratch
operator|.
name|sata_param
operator|.
name|cmd_priv
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pMvSataChannel
operator|->
name|lba48Address
operator|==
name|MV_TRUE
condition|)
block|{
name|pNoUdmaParams
operator|->
name|command
operator|=
name|MV_ATA_COMMAND_READ_VERIFY_SECTORS_EXT
expr_stmt|;
name|pNoUdmaParams
operator|->
name|isEXT
operator|=
name|MV_TRUE
expr_stmt|;
name|pNoUdmaParams
operator|->
name|lbaHigh
operator|=
call|(
name|MV_U16
call|)
argument_list|(
operator|(
name|Lba
operator|&
literal|0xff0000
operator|)
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|pNoUdmaParams
operator|->
name|lbaMid
operator|=
call|(
name|MV_U16
call|)
argument_list|(
operator|(
name|Lba
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|pNoUdmaParams
operator|->
name|lbaLow
operator|=
call|(
name|MV_U16
call|)
argument_list|(
operator|(
operator|(
name|Lba
operator|&
literal|0xff000000
operator|)
operator|>>
literal|16
operator|)
operator||
operator|(
name|Lba
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
name|pNoUdmaParams
operator|->
name|sectorCount
operator|=
name|nSector
expr_stmt|;
name|pNoUdmaParams
operator|->
name|device
operator|=
literal|0x40
expr_stmt|;
name|result
operator|=
name|mvSataQueueCommand
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channel
argument_list|,
operator|&
name|commandInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|MV_QUEUE_COMMAND_RESULT_OK
condition|)
block|{
goto|goto
name|queue_failed
goto|;
block|}
return|return;
block|}
name|pNoUdmaParams
operator|->
name|command
operator|=
name|MV_ATA_COMMAND_READ_VERIFY_SECTORS
expr_stmt|;
name|pNoUdmaParams
operator|->
name|isEXT
operator|=
name|MV_FALSE
expr_stmt|;
name|pNoUdmaParams
operator|->
name|lbaHigh
operator|=
call|(
name|MV_U16
call|)
argument_list|(
operator|(
name|Lba
operator|&
literal|0xff0000
operator|)
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|pNoUdmaParams
operator|->
name|lbaMid
operator|=
call|(
name|MV_U16
call|)
argument_list|(
operator|(
name|Lba
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|pNoUdmaParams
operator|->
name|lbaLow
operator|=
call|(
name|MV_U16
call|)
argument_list|(
name|Lba
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|pNoUdmaParams
operator|->
name|sectorCount
operator|=
literal|0xff
operator|&
name|nSector
expr_stmt|;
name|pNoUdmaParams
operator|->
name|device
operator|=
call|(
name|MV_U8
call|)
argument_list|(
literal|0x40
operator||
operator|(
operator|(
name|Lba
operator|&
literal|0xf000000
operator|)
operator|>>
literal|24
operator|)
argument_list|)
expr_stmt|;
name|pNoUdmaParams
operator|->
name|callBack
operator|=
name|CommandCompletionCB
expr_stmt|;
name|result
operator|=
name|mvSataQueueCommand
argument_list|(
name|pMvSataAdapter
argument_list|,
name|channel
argument_list|,
operator|&
name|commandInfo
argument_list|)
expr_stmt|;
comment|/* 		 * FIXME: how about the commands already queued? but marvel 		 * also forgets to consider this 		 */
if|if
condition|(
name|result
operator|!=
name|MV_QUEUE_COMMAND_RESULT_OK
condition|)
block|{
goto|goto
name|queue_failed
goto|;
block|}
break|break;
default|default:
name|pCmd
operator|->
name|Result
operator|=
name|RETURN_INVALID_REQUEST
expr_stmt|;
name|CallAfterReturn
argument_list|(
name|_VBUS_P
argument_list|(
argument|DPC_PROC
argument_list|)
name|pCmd
operator|->
name|pfnCompletion
argument_list|,
name|pCmd
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/**********************************************************  *  *	Probe the hostadapter.  *  **********************************************************/
end_comment

begin_function
specifier|static
name|int
name|hpt_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
operator|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|==
name|MV_SATA_VENDOR_ID
operator|)
operator|&&
operator|(
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|MV_SATA_DEVICE_ID_5081
ifdef|#
directive|ifdef
name|FOR_DEMO
operator|||
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|MV_SATA_DEVICE_ID_5080
endif|#
directive|endif
operator|)
condition|)
block|{
name|KdPrintI
argument_list|(
operator|(
name|CONTROLLER_NAME
literal|" found\n"
operator|)
argument_list|)
expr_stmt|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|CONTROLLER_NAME
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/***********************************************************  *  *      Auto configuration:  attach and init a host adapter.  *  ***********************************************************/
end_comment

begin_function
specifier|static
name|int
name|hpt_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|hpt_vsim
decl_stmt|;
name|printf
argument_list|(
literal|"%s Version %s\n"
argument_list|,
name|DRIVER_NAME
argument_list|,
name|DRIVER_VERSION
argument_list|)
expr_stmt|;
name|pAdapter
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pAdapter
operator|->
name|hpt_dev
operator|=
name|dev
expr_stmt|;
name|rid
operator|=
name|init_adapter
argument_list|(
name|pAdapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|rid
condition|)
return|return
name|rid
return|;
name|rid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|pAdapter
operator|->
name|hpt_irq
operator|=
name|bus_alloc_resource
argument_list|(
name|pAdapter
operator|->
name|hpt_dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0ul
argument_list|,
literal|1
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|hpt_printk
argument_list|(
operator|(
literal|"can't allocate interrupt\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|bus_setup_intr
argument_list|(
name|pAdapter
operator|->
name|hpt_dev
argument_list|,
name|pAdapter
operator|->
name|hpt_irq
argument_list|,
name|INTR_TYPE_CAM
argument_list|,
name|hpt_intr
argument_list|,
name|pAdapter
argument_list|,
operator|&
name|pAdapter
operator|->
name|hpt_intr
argument_list|)
condition|)
block|{
name|hpt_printk
argument_list|(
operator|(
literal|"can't set up interrupt\n"
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pAdapter
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|#
directive|if
literal|1
if|if
condition|(
operator|(
name|ccb
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ccb
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|pinfo
operator|.
name|priority
operator|=
literal|1
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|pinfo
operator|.
name|index
operator|=
name|CAM_UNQUEUED_INDEX
expr_stmt|;
block|}
else|else
block|{
return|return
name|ENOMEM
return|;
block|}
endif|#
directive|endif
comment|/* 	 * Create the device queue for our SIM(s). 	 */
if|if
condition|(
operator|(
name|devq
operator|=
name|cam_simq_alloc
argument_list|(
literal|8
comment|/*MAX_QUEUE_COMM*/
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|KdPrint
argument_list|(
operator|(
literal|"ENXIO\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
comment|/* 	 * Construct our SIM entry 	 */
if|if
condition|(
operator|(
name|hpt_vsim
operator|=
name|cam_sim_alloc
argument_list|(
name|hpt_action
argument_list|,
name|hpt_poll
argument_list|,
name|__str
argument_list|(
name|PROC_DIR_NAME
argument_list|)
argument_list|,
name|pAdapter
argument_list|,
name|device_get_unit
argument_list|(
name|pAdapter
operator|->
name|hpt_dev
argument_list|)
argument_list|,
comment|/*untagged*/
literal|1
argument_list|,
comment|/*tagged*/
literal|8
argument_list|,
name|devq
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|cam_simq_free
argument_list|(
name|devq
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|hpt_vsim
argument_list|,
literal|0
argument_list|)
operator|!=
name|CAM_SUCCESS
condition|)
block|{
name|cam_sim_free
argument_list|(
name|hpt_vsim
argument_list|,
comment|/*free devq*/
name|TRUE
argument_list|)
expr_stmt|;
name|hpt_vsim
operator|=
name|NULL
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|pAdapter
operator|->
name|path
argument_list|,
comment|/*periph */
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|hpt_vsim
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|hpt_vsim
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|hpt_vsim
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
name|hpt_vsim
operator|=
name|NULL
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|xpt_setup_ccb
argument_list|(
operator|&
operator|(
name|ccb
operator|->
name|ccb_h
operator|)
argument_list|,
name|pAdapter
operator|->
name|path
argument_list|,
comment|/*priority*/
literal|5
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SASYNC_CB
expr_stmt|;
name|ccb
operator|->
name|csa
operator|.
name|event_enable
operator|=
name|AC_LOST_DEVICE
expr_stmt|;
name|ccb
operator|->
name|csa
operator|.
name|callback
operator|=
name|hpt_async
expr_stmt|;
name|ccb
operator|->
name|csa
operator|.
name|callback_arg
operator|=
name|hpt_vsim
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|ccb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ccb
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
comment|/* Only do this setup for the first device. */
if|if
condition|(
name|device_get_unit
argument_list|(
name|dev
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pAdapter
operator|->
name|eh
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|shutdown_final
argument_list|,
name|hpt_shutdown
argument_list|,
name|dev
argument_list|,
name|SHUTDOWN_PRI_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|pAdapter
operator|->
name|eh
operator|!=
name|NULL
condition|)
name|launch_worker_thread
argument_list|()
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"hptmv: shutdown event registration failed\n"
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hpt_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
end_function

begin_comment
comment|/***************************************************************  * The poll function is used to simulate the interrupt when  * the interrupt subsystem is not functioning.  *  ***************************************************************/
end_comment

begin_function
specifier|static
name|void
name|hpt_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
block|{
name|hpt_intr
argument_list|(
operator|(
name|void
operator|*
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************  *	Name:	hpt_intr  *	Description:	Interrupt handler.  ****************************************************************/
end_comment

begin_function
specifier|static
name|void
name|hpt_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
init|=
operator|(
name|IAL_ADAPTER_T
operator|*
operator|)
name|arg
decl_stmt|;
name|intrmask_t
name|oldspl
decl_stmt|;
name|oldspl
operator|=
name|lock_driver
argument_list|()
expr_stmt|;
comment|/* KdPrintI(("----- Entering Isr() -----\n")); */
if|if
condition|(
name|mvSataInterruptServiceRoutine
argument_list|(
operator|&
name|pAdapter
operator|->
name|mvSataAdapter
argument_list|)
operator|==
name|MV_TRUE
condition|)
block|{
name|_VBUS_INST
argument_list|(
argument|&pAdapter->VBus
argument_list|)
name|CheckPendingCall
argument_list|(
name|_VBUS_P0
argument_list|)
expr_stmt|;
block|}
comment|/* KdPrintI(("----- Leaving Isr() -----\n")); */
name|unlock_driver
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************  * 			Asynchronous Events  *********************************************************/
end_comment

begin_if
if|#
directive|if
operator|(
operator|!
name|defined
argument_list|(
name|UNREFERENCED_PARAMETER
argument_list|)
operator|)
end_if

begin_define
define|#
directive|define
name|UNREFERENCED_PARAMETER
parameter_list|(
name|x
parameter_list|)
value|(void)(x)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|hpt_async
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|u_int32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
comment|/* debug XXXX */
name|panic
argument_list|(
literal|"Here"
argument_list|)
expr_stmt|;
name|UNREFERENCED_PARAMETER
argument_list|(
name|callback_arg
argument_list|)
expr_stmt|;
name|UNREFERENCED_PARAMETER
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|UNREFERENCED_PARAMETER
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|UNREFERENCED_PARAMETER
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|FlushAdapter
parameter_list|(
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|hpt_printk
argument_list|(
operator|(
literal|"flush all devices\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* flush all devices */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_VDEVICE_PER_VBUS
condition|;
name|i
operator|++
control|)
block|{
name|PVDevice
name|pVDev
init|=
name|pAdapter
operator|->
name|VBus
operator|.
name|pVDevice
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|pVDev
condition|)
name|fFlushVDev
argument_list|(
name|pVDev
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|hpt_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
decl_stmt|;
name|pAdapter
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|pAdapter
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|shutdown_final
argument_list|,
name|pAdapter
operator|->
name|eh
argument_list|)
expr_stmt|;
name|FlushAdapter
argument_list|(
name|pAdapter
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|Check_Idle_Call
parameter_list|(
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|_VBUS_INST
argument_list|(
argument|&pAdapter->VBus
argument_list|)
if|if
condition|(
name|mWaitingForIdle
argument_list|(
name|_VBUS_P0
argument_list|)
condition|)
block|{
name|CheckIdleCall
argument_list|(
name|_VBUS_P0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_ARRAY
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_ARRAY_PER_VBUS
condition|;
name|i
operator|++
control|)
block|{
name|PVDevice
name|pArray
decl_stmt|;
if|if
condition|(
operator|(
name|pArray
operator|=
name|ArrayTables
argument_list|(
name|i
argument_list|)
operator|)
operator|->
name|u
operator|.
name|array
operator|.
name|dArStamp
operator|==
literal|0
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|pArray
operator|->
name|u
operator|.
name|array
operator|.
name|rf_auto_rebuild
condition|)
block|{
name|KdPrint
argument_list|(
operator|(
literal|"auto rebuild.\n"
operator|)
argument_list|)
expr_stmt|;
name|pArray
operator|->
name|u
operator|.
name|array
operator|.
name|rf_auto_rebuild
operator|=
literal|0
expr_stmt|;
name|hpt_queue_dpc
argument_list|(
operator|(
name|HPT_DPC
operator|)
name|hpt_rebuild_data_block
argument_list|,
name|pAdapter
argument_list|,
name|pArray
argument_list|,
name|DUPLICATE
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
comment|/* launch the awaiting commands blocked by mWaitingForIdle */
while|while
condition|(
name|pAdapter
operator|->
name|pending_Q
operator|!=
name|NULL
condition|)
block|{
name|_VBUS_INST
argument_list|(
argument|&pAdapter->VBus
argument_list|)
name|union
name|ccb
modifier|*
name|ccb
init|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|pAdapter
operator|->
name|pending_Q
operator|->
name|ccb_h
operator|.
name|ccb_ccb_ptr
decl_stmt|;
name|hpt_free_ccb
argument_list|(
operator|&
name|pAdapter
operator|->
name|pending_Q
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
name|CallAfterReturn
argument_list|(
name|_VBUS_P
argument_list|(
argument|DPC_PROC
argument_list|)
name|OsSendCommand
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ccb_done
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
init|=
operator|(
name|IAL_ADAPTER_T
operator|*
operator|)
name|ccb
operator|->
name|ccb_adapter
decl_stmt|;
name|KdPrintI
argument_list|(
operator|(
literal|"ccb_done: ccb %p status %x"
operator|,
name|ccb
operator|,
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|)
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|pAdapter
operator|->
name|outstandingCommands
operator|--
expr_stmt|;
if|if
condition|(
name|pAdapter
operator|->
name|outstandingCommands
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|DPC_Request_Nums
operator|==
literal|0
condition|)
name|Check_Idle_Call
argument_list|(
name|pAdapter
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/****************************************************************  *	Name:	hpt_action  *	Description:	Process a queued command from the CAM layer.  *	Parameters:		sim - Pointer to SIM object  *					ccb - Pointer to SCSI command structure.  ****************************************************************/
end_comment

begin_function
name|void
name|hpt_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|intrmask_t
name|oldspl
decl_stmt|;
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
init|=
operator|(
name|IAL_ADAPTER_T
operator|*
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
decl_stmt|;
name|_VBUS_INST
argument_list|(
argument|&pAdapter->VBus
argument_list|)
name|ccb
operator|->
name|ccb_adapter
operator|=
name|pAdapter
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"hpt_action\n"
operator|)
argument_list|)
expr_stmt|;
name|KdPrint
argument_list|(
operator|(
literal|"hpt_action(%lx,%lx{%x})\n"
operator|,
operator|(
name|u_long
operator|)
name|sim
operator|,
operator|(
name|u_long
operator|)
name|ccb
operator|,
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_SCSI_IO
case|:
comment|/* Execute the requested I/O operation */
comment|/* ccb->ccb_h.path_id is not our bus id - don't check it */
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_LUN_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|>=
name|MAX_VDEVICE_PER_VBUS
operator|||
name|pAdapter
operator|->
name|VBus
operator|.
name|pVDevice
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
operator|==
literal|0
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_TID_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|oldspl
operator|=
name|lock_driver
argument_list|()
expr_stmt|;
if|if
condition|(
name|pAdapter
operator|->
name|outstandingCommands
operator|==
literal|0
operator|&&
name|DPC_Request_Nums
operator|==
literal|0
condition|)
name|Check_Idle_Call
argument_list|(
name|pAdapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|mWaitingForIdle
argument_list|(
name|_VBUS_P0
argument_list|)
condition|)
name|hpt_queue_ccb
argument_list|(
operator|&
name|pAdapter
operator|->
name|pending_Q
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
else|else
name|OsSendCommand
argument_list|(
argument|_VBUS_P ccb
argument_list|)
empty_stmt|;
name|unlock_driver
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
comment|/* KdPrint(("leave scsiio\n")); */
break|break;
case|case
name|XPT_RESET_BUS
case|:
name|KdPrint
argument_list|(
operator|(
literal|"reset bus\n"
operator|)
argument_list|)
expr_stmt|;
name|oldspl
operator|=
name|lock_driver
argument_list|()
expr_stmt|;
name|fResetVBus
argument_list|(
name|_VBUS_P0
argument_list|)
expr_stmt|;
name|unlock_driver
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_RESET_DEV
case|:
comment|/* Bus Device Reset the specified SCSI device */
case|case
name|XPT_EN_LUN
case|:
comment|/* Enable LUN as a target */
case|case
name|XPT_TARGET_IO
case|:
comment|/* Execute target I/O request */
case|case
name|XPT_ACCEPT_TARGET_IO
case|:
comment|/* Accept Host Target Mode CDB */
case|case
name|XPT_CONT_TARGET_IO
case|:
comment|/* Continue Host Target I/O Connection*/
case|case
name|XPT_ABORT
case|:
comment|/* Abort the specified CCB */
case|case
name|XPT_TERM_IO
case|:
comment|/* Terminate the I/O process */
comment|/* XXX Implement */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_GET_TRAN_SETTINGS
case|:
case|case
name|XPT_SET_TRAN_SETTINGS
case|:
comment|/* XXX Implement */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_FUNC_NOTAVAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_CALC_GEOMETRY
case|:
block|{
name|struct
name|ccb_calc_geometry
modifier|*
name|ccg
decl_stmt|;
name|u_int32_t
name|size_mb
decl_stmt|;
name|u_int32_t
name|secs_per_cylinder
decl_stmt|;
name|ccg
operator|=
operator|&
name|ccb
operator|->
name|ccg
expr_stmt|;
name|size_mb
operator|=
name|ccg
operator|->
name|volume_size
operator|/
operator|(
operator|(
literal|1024L
operator|*
literal|1024L
operator|)
operator|/
name|ccg
operator|->
name|block_size
operator|)
expr_stmt|;
if|if
condition|(
name|size_mb
operator|>
literal|1024
condition|)
block|{
name|ccg
operator|->
name|heads
operator|=
literal|255
expr_stmt|;
name|ccg
operator|->
name|secs_per_track
operator|=
literal|63
expr_stmt|;
block|}
else|else
block|{
name|ccg
operator|->
name|heads
operator|=
literal|64
expr_stmt|;
name|ccg
operator|->
name|secs_per_track
operator|=
literal|32
expr_stmt|;
block|}
name|secs_per_cylinder
operator|=
name|ccg
operator|->
name|heads
operator|*
name|ccg
operator|->
name|secs_per_track
expr_stmt|;
name|ccg
operator|->
name|cylinders
operator|=
name|ccg
operator|->
name|volume_size
operator|/
name|secs_per_cylinder
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_PATH_INQ
case|:
comment|/* Path routing inquiry */
block|{
name|struct
name|ccb_pathinq
modifier|*
name|cpi
init|=
operator|&
name|ccb
operator|->
name|cpi
decl_stmt|;
name|cpi
operator|->
name|version_num
operator|=
literal|1
expr_stmt|;
comment|/* XXX??? */
name|cpi
operator|->
name|hba_inquiry
operator|=
name|PI_SDTR_ABLE
expr_stmt|;
name|cpi
operator|->
name|target_sprt
operator|=
literal|0
expr_stmt|;
comment|/* Not necessary to reset bus */
name|cpi
operator|->
name|hba_misc
operator|=
name|PIM_NOBUSRESET
expr_stmt|;
name|cpi
operator|->
name|hba_eng_cnt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|max_target
operator|=
name|MAX_VDEVICE_PER_VBUS
expr_stmt|;
name|cpi
operator|->
name|max_lun
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|initiator_id
operator|=
name|MAX_VDEVICE_PER_VBUS
expr_stmt|;
name|cpi
operator|->
name|bus_id
operator|=
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|base_transfer_speed
operator|=
literal|3300
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|sim_vid
argument_list|,
literal|"FreeBSD"
argument_list|,
name|SIM_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|hba_vid
argument_list|,
literal|"HPT   "
argument_list|,
name|HBA_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|dev_name
argument_list|,
name|cam_sim_name
argument_list|(
name|sim
argument_list|)
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|unit_number
operator|=
name|cam_sim_unit
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|KdPrint
argument_list|(
operator|(
literal|"invalid cmd\n"
operator|)
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* KdPrint(("leave hpt_action..............\n")); */
block|}
end_function

begin_comment
comment|/* shall be called at lock_driver() */
end_comment

begin_function
specifier|static
name|void
name|hpt_queue_ccb
parameter_list|(
name|union
name|ccb
modifier|*
modifier|*
name|ccb_Q
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
if|if
condition|(
operator|*
name|ccb_Q
operator|==
name|NULL
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_ccb_ptr
operator|=
name|ccb
expr_stmt|;
else|else
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_ccb_ptr
operator|=
operator|(
operator|*
name|ccb_Q
operator|)
operator|->
name|ccb_h
operator|.
name|ccb_ccb_ptr
expr_stmt|;
operator|(
operator|*
name|ccb_Q
operator|)
operator|->
name|ccb_h
operator|.
name|ccb_ccb_ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|ccb
expr_stmt|;
block|}
operator|*
name|ccb_Q
operator|=
name|ccb
expr_stmt|;
block|}
end_function

begin_comment
comment|/* shall be called at lock_driver() */
end_comment

begin_function
specifier|static
name|void
name|hpt_free_ccb
parameter_list|(
name|union
name|ccb
modifier|*
modifier|*
name|ccb_Q
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|TempCCB
decl_stmt|;
name|TempCCB
operator|=
operator|*
name|ccb_Q
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_ccb_ptr
operator|==
name|ccb
condition|)
comment|/*it means SCpnt is the last one in CURRCMDs*/
operator|*
name|ccb_Q
operator|=
name|NULL
expr_stmt|;
else|else
block|{
while|while
condition|(
name|TempCCB
operator|->
name|ccb_h
operator|.
name|ccb_ccb_ptr
operator|!=
operator|(
name|char
operator|*
operator|)
name|ccb
condition|)
name|TempCCB
operator|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|TempCCB
operator|->
name|ccb_h
operator|.
name|ccb_ccb_ptr
expr_stmt|;
name|TempCCB
operator|->
name|ccb_h
operator|.
name|ccb_ccb_ptr
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_ccb_ptr
expr_stmt|;
if|if
condition|(
operator|*
name|ccb_Q
operator|==
name|ccb
condition|)
operator|*
name|ccb_Q
operator|=
name|TempCCB
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SUPPORT_ARRAY
end_ifdef

begin_comment
comment|/***************************************************************************  * Function:     hpt_worker_thread  * Description:  Do background rebuilding. Execute in kernel thread context.  * Returns:      None  ***************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|hpt_worker_thread
parameter_list|(
name|void
parameter_list|)
block|{
name|intrmask_t
name|oldspl
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
name|DpcQueue_First
operator|!=
name|DpcQueue_Last
condition|)
block|{
name|ST_HPT_DPC
name|p
decl_stmt|;
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
decl_stmt|;
name|PVDevice
name|pArray
decl_stmt|;
name|PVBus
name|_vbus_p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|oldspl
operator|=
name|lock_driver
argument_list|()
expr_stmt|;
name|p
operator|=
name|DpcQueue
index|[
name|DpcQueue_First
index|]
expr_stmt|;
name|DpcQueue_First
operator|++
expr_stmt|;
name|DpcQueue_First
operator|%=
name|MAX_DPC
expr_stmt|;
name|DPC_Request_Nums
operator|++
expr_stmt|;
name|unlock_driver
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
name|p
operator|.
name|dpc
argument_list|(
name|p
operator|.
name|pAdapter
argument_list|,
name|p
operator|.
name|arg
argument_list|,
name|p
operator|.
name|flags
argument_list|)
expr_stmt|;
name|oldspl
operator|=
name|lock_driver
argument_list|()
expr_stmt|;
name|DPC_Request_Nums
operator|--
expr_stmt|;
comment|/* 			 * since we may have prevented Check_Idle_Call, do it 			 * here 			 */
if|if
condition|(
name|DPC_Request_Nums
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|p
operator|.
name|pAdapter
operator|->
name|outstandingCommands
operator|==
literal|0
condition|)
block|{
name|_VBUS_INST
argument_list|(
operator|&
name|p
operator|.
name|pAdapter
operator|->
name|VBus
argument_list|)
expr_stmt|;
name|Check_Idle_Call
argument_list|(
name|p
operator|.
name|pAdapter
argument_list|)
expr_stmt|;
name|CheckPendingCall
argument_list|(
name|_VBUS_P0
argument_list|)
expr_stmt|;
block|}
block|}
name|unlock_driver
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
if|if
condition|(
name|SIGISMEMBER
argument_list|(
name|curproc
operator|->
name|p_siglist
argument_list|,
name|SIGSTOP
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* abort rebuilding process. */
name|pAdapter
operator|=
name|gIal_Adapter
expr_stmt|;
while|while
condition|(
name|pAdapter
operator|!=
literal|0
condition|)
block|{
name|_vbus_p
operator|=
operator|&
name|pAdapter
operator|->
name|VBus
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_ARRAY_PER_VBUS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|pArray
operator|=
name|ArrayTables
argument_list|(
name|i
argument_list|)
operator|)
operator|->
name|u
operator|.
name|array
operator|.
name|dArStamp
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|pArray
operator|->
name|u
operator|.
name|array
operator|.
name|rf_rebuilding
operator|||
name|pArray
operator|->
name|u
operator|.
name|array
operator|.
name|rf_verifying
operator|||
name|pArray
operator|->
name|u
operator|.
name|array
operator|.
name|rf_initializing
condition|)
block|{
name|pArray
operator|->
name|u
operator|.
name|array
operator|.
name|rf_abort_rebuild
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|pAdapter
operator|=
name|pAdapter
operator|->
name|next
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|SIGISMEMBER
argument_list|(
name|curproc
operator|->
name|p_siglist
argument_list|,
name|SIGSTOP
argument_list|)
condition|)
name|tsleep
argument_list|(
name|hpt_worker_thread
argument_list|,
name|PPAUSE
argument_list|,
literal|"hptrdy"
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|500043
operator|)
name|kthread_suspend_check
argument_list|(
name|curproc
argument_list|)
expr_stmt|;
else|#
directive|else
name|kproc_suspend_loop
argument_list|(
name|curproc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* wait for something to do */
name|tsleep
argument_list|(
name|hpt_worker_thread
argument_list|,
name|PPAUSE
argument_list|,
literal|"hptrdy"
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|proc
modifier|*
name|hptdaemonproc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|kproc_desc
name|hpt_kp
init|=
block|{
literal|"hpt_wt"
block|,
name|hpt_worker_thread
block|,
operator|&
name|hptdaemonproc
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|launch_worker_thread
parameter_list|(
name|void
parameter_list|)
block|{
name|IAL_ADAPTER_T
modifier|*
name|pAdapTemp
decl_stmt|;
name|kproc_start
argument_list|(
operator|&
name|hpt_kp
argument_list|)
expr_stmt|;
for|for
control|(
name|pAdapTemp
operator|=
name|gIal_Adapter
init|;
name|pAdapTemp
condition|;
name|pAdapTemp
operator|=
name|pAdapTemp
operator|->
name|next
control|)
block|{
name|_VBUS_INST
argument_list|(
argument|&pAdapTemp->VBus
argument_list|)
name|int
name|i
decl_stmt|;
name|PVDevice
name|pVDev
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_ARRAY_PER_VBUS
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|pVDev
operator|=
name|ArrayTables
argument_list|(
name|i
argument_list|)
operator|)
operator|->
name|u
operator|.
name|array
operator|.
name|dArStamp
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|pVDev
operator|->
name|u
operator|.
name|array
operator|.
name|rf_need_rebuild
operator|&&
operator|!
name|pVDev
operator|->
name|u
operator|.
name|array
operator|.
name|rf_rebuilding
condition|)
block|{
name|hpt_queue_dpc
argument_list|(
operator|(
name|HPT_DPC
operator|)
name|hpt_rebuild_data_block
argument_list|,
name|pAdapTemp
argument_list|,
name|pVDev
argument_list|,
call|(
name|UCHAR
call|)
argument_list|(
operator|(
name|pVDev
operator|->
name|u
operator|.
name|array
operator|.
name|CriticalMembers
operator|||
name|pVDev
operator|->
name|VDeviceType
operator|==
name|VD_RAID_1
operator|)
condition|?
name|DUPLICATE
else|:
name|REBUILD_PARITY
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * hpt_worker_thread needs to be suspended after shutdown sync, when fs 	 * sync finished. 	 */
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|<
literal|500043
operator|)
name|EVENTHANDLER_REGISTER
argument_list|(
name|shutdown_post_sync
argument_list|,
name|shutdown_kproc
argument_list|,
name|hptdaemonproc
argument_list|,
name|SHUTDOWN_PRI_FIRST
argument_list|)
expr_stmt|;
else|#
directive|else
name|EVENTHANDLER_REGISTER
argument_list|(
name|shutdown_post_sync
argument_list|,
name|kproc_shutdown
argument_list|,
name|hptdaemonproc
argument_list|,
name|SHUTDOWN_PRI_FIRST
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SUPPORT_ARRAY */
end_comment

begin_comment
comment|/* build sgl with merge function */
end_comment

begin_define
define|#
directive|define
name|ON64KBOUNDARY
parameter_list|(
name|x
parameter_list|)
value|(((ULONG_PTR)(x)& 0xFFFF) == 0)
end_define

begin_comment
comment|/* XXX */
end_comment

begin_comment
comment|/* #define NOTNEIGHBORPAGE(x, y) (max(x, y) - min(x, y)> PAGE_SIZE) */
end_comment

begin_define
define|#
directive|define
name|NOTNEIGHBORPAGE
parameter_list|(
name|highvaddr
parameter_list|,
name|lowvaddr
parameter_list|)
define|\
value|((ULONG_PTR)(highvaddr) - (ULONG_PTR)(lowvaddr) != PAGE_SIZE)
end_define

begin_comment
comment|/********************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|hptmv_buffer_callback
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|FPSCAT_GATH
name|pSg
decl_stmt|;
name|int
name|idx
decl_stmt|;
if|if
condition|(
name|error
operator|||
name|nsegs
operator|==
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"busdma bewm"
argument_list|)
expr_stmt|;
return|return;
block|}
name|pSg
operator|=
operator|*
operator|(
name|FPSCAT_GATH
operator|*
operator|)
name|arg
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|nsegs
condition|;
name|idx
operator|++
control|)
block|{
name|pSg
index|[
name|idx
index|]
operator|.
name|dSgAddress
operator|=
operator|(
name|ULONG_PTR
operator|)
name|segs
index|[
name|idx
index|]
operator|.
name|ds_addr
expr_stmt|;
name|pSg
index|[
name|idx
index|]
operator|.
name|wSgSize
operator|=
name|segs
index|[
name|idx
index|]
operator|.
name|ds_len
expr_stmt|;
name|pSg
index|[
name|idx
index|]
operator|.
name|wSgFlag
operator|=
literal|0
expr_stmt|;
block|}
name|pSg
index|[
name|idx
operator|-
literal|1
index|]
operator|.
name|wSgFlag
operator|=
name|SG_FLAG_EOT
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|HPTLIBAPI
name|fOsBuildSgl
parameter_list|(
name|_VBUS_ARG
name|PCommand
name|pCmd
parameter_list|,
name|FPSCAT_GATH
name|pSg
parameter_list|,
name|int
name|logical
parameter_list|)
block|{
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
decl_stmt|;
name|pPrivCommand
name|prvCmd
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|sgList
decl_stmt|;
name|int
name|error
decl_stmt|;
name|prvCmd
operator|=
name|pCmd
operator|->
name|pOrgCommand
expr_stmt|;
name|pAdapter
operator|=
name|prvCmd
operator|->
name|pAdapter
expr_stmt|;
name|ccb
operator|=
name|prvCmd
operator|->
name|ccb
expr_stmt|;
name|ccb_h
operator|=
operator|&
name|ccb
operator|->
name|ccb_h
expr_stmt|;
name|csio
operator|=
operator|&
name|ccb
operator|->
name|csio
expr_stmt|;
name|sgList
operator|=
operator|(
name|bus_dma_segment_t
operator|*
operator|)
operator|(
name|csio
operator|->
name|data_ptr
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_NONE
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_SCATTER_VALID
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_DATA_PHYS
operator|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
name|KMSG_LEADING
literal|"physical address unsupported!"
argument_list|)
expr_stmt|;
name|hptmv_buffer_callback
argument_list|(
operator|&
name|pSg
argument_list|,
name|sgList
argument_list|,
name|csio
operator|->
name|sglist_cnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|logical
condition|)
block|{
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_DATA_PHYS
operator|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
name|KMSG_LEADING
literal|"physical address unsupported\n"
argument_list|)
expr_stmt|;
name|pSg
operator|->
name|dSgAddress
operator|=
operator|(
name|ULONG_PTR
operator|)
name|csio
operator|->
name|data_ptr
expr_stmt|;
name|pSg
operator|->
name|wSgSize
operator|=
operator|(
name|USHORT
operator|)
name|csio
operator|->
name|dxfer_len
expr_stmt|;
name|pSg
operator|->
name|wSgFlag
operator|=
name|SG_FLAG_EOT
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|KdPrint
argument_list|(
operator|(
literal|"use sgl (physical) ...........\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * XXX Hack to make this work with PAE.  It will fail under 	 * heavy load. 	 */
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|pAdapter
operator|->
name|buf_dmat
argument_list|,
name|prvCmd
operator|->
name|buf_map
argument_list|,
name|csio
operator|->
name|data_ptr
argument_list|,
name|csio
operator|->
name|dxfer_len
argument_list|,
name|hptmv_buffer_callback
argument_list|,
operator|&
name|pSg
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"bus_dmamap_load failed error= %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/*#ifdef DEBUG 	do { 		int size, i = 0; 		KdPrintI(("sg[%d]:0x%lx %d\n", i++, pSg[i].dSgAddress, 		    pSg[i].wSgSize)); 		size = pSg->wSgSize; 		if (pSg[i].wSgFlag& SG_FLAG_EOT) 			break; 	} while (i<17); #endif*/
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|pAdapter
operator|->
name|buf_dmat
argument_list|,
name|prvCmd
operator|->
name|buf_map
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bus_dmamap_sync
argument_list|(
name|pAdapter
operator|->
name|buf_dmat
argument_list|,
name|prvCmd
operator|->
name|buf_map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|ULONG
name|HPTLIBAPI
name|GetStamp
parameter_list|(
name|void
parameter_list|)
block|{
name|ULONG
name|stamp
decl_stmt|;
comment|/*  	 * the system variable, ticks, can't be used since it hasn't yet been active  	 * when our driver starts (ticks==0, it's a invalid stamp value) 	 */
do|do
block|{
name|stamp
operator|=
name|random
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|stamp
operator|==
literal|0
condition|)
do|;
return|return
name|stamp
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|SetInquiryData
parameter_list|(
name|PINQUIRYDATA
name|inquiryData
parameter_list|,
name|PVDevice
name|pVDev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|IDENTIFY_DATA2
modifier|*
name|pIdentify
decl_stmt|;
name|pIdentify
operator|=
operator|(
name|IDENTIFY_DATA2
operator|*
operator|)
name|pVDev
operator|->
name|u
operator|.
name|disk
operator|.
name|mv
operator|->
name|identifyDevice
expr_stmt|;
name|inquiryData
operator|->
name|DeviceType
operator|=
name|T_DIRECT
expr_stmt|;
comment|/*DIRECT_ACCESS_DEVICE*/
name|inquiryData
operator|->
name|AdditionalLength
operator|=
call|(
name|UCHAR
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|INQUIRYDATA
argument_list|)
operator|-
literal|5
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SERIAL_CMDS
name|inquiryData
operator|->
name|CommandQueue
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|pVDev
operator|->
name|VDeviceType
condition|)
block|{
case|case
name|VD_SINGLE_DISK
case|:
case|case
name|VD_ATAPI
case|:
case|case
name|VD_REMOVABLE
case|:
comment|/* Set the removable bit, if applicable. */
if|if
condition|(
operator|(
name|pVDev
operator|->
name|u
operator|.
name|disk
operator|.
name|df_removable_drive
operator|)
operator|||
operator|(
name|pIdentify
operator|->
name|GeneralConfiguration
operator|&
literal|0x80
operator|)
condition|)
name|inquiryData
operator|->
name|RemovableMedia
operator|=
literal|1
expr_stmt|;
comment|/* Fill in vendor identification fields. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|inquiryData
operator|->
name|VendorId
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|PUCHAR
operator|)
name|pIdentify
operator|->
name|ModelNumber
operator|)
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|inquiryData
operator|->
name|VendorId
index|[
name|i
operator|+
literal|1
index|]
operator|=
operator|(
operator|(
name|PUCHAR
operator|)
name|pIdentify
operator|->
name|ModelNumber
operator|)
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* Initialize unused portion of product id. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|inquiryData
operator|->
name|ProductId
index|[
literal|12
operator|+
name|i
index|]
operator|=
literal|' '
expr_stmt|;
comment|/* firmware revision */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|inquiryData
operator|->
name|ProductRevisionLevel
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|PUCHAR
operator|)
name|pIdentify
operator|->
name|FirmwareRevision
operator|)
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|inquiryData
operator|->
name|ProductRevisionLevel
index|[
name|i
operator|+
literal|1
index|]
operator|=
operator|(
operator|(
name|PUCHAR
operator|)
name|pIdentify
operator|->
name|FirmwareRevision
operator|)
index|[
name|i
index|]
expr_stmt|;
block|}
break|break;
default|default:
name|memcpy
argument_list|(
operator|&
name|inquiryData
operator|->
name|VendorId
argument_list|,
literal|"RR182x  "
argument_list|,
literal|8
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_ARRAY
switch|switch
condition|(
name|pVDev
operator|->
name|VDeviceType
condition|)
block|{
case|case
name|VD_RAID_0
case|:
if|if
condition|(
operator|(
name|pVDev
operator|->
name|u
operator|.
name|array
operator|.
name|pMember
index|[
literal|0
index|]
operator|&&
name|mIsArray
argument_list|(
name|pVDev
operator|->
name|u
operator|.
name|array
operator|.
name|pMember
index|[
literal|0
index|]
argument_list|)
operator|)
operator|||
operator|(
name|pVDev
operator|->
name|u
operator|.
name|array
operator|.
name|pMember
index|[
literal|1
index|]
operator|&&
name|mIsArray
argument_list|(
name|pVDev
operator|->
name|u
operator|.
name|array
operator|.
name|pMember
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
name|memcpy
argument_list|(
operator|&
name|inquiryData
operator|->
name|ProductId
argument_list|,
literal|"RAID 1/0 Array  "
argument_list|,
literal|16
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
operator|&
name|inquiryData
operator|->
name|ProductId
argument_list|,
literal|"RAID 0 Array    "
argument_list|,
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
name|VD_RAID_1
case|:
if|if
condition|(
operator|(
name|pVDev
operator|->
name|u
operator|.
name|array
operator|.
name|pMember
index|[
literal|0
index|]
operator|&&
name|mIsArray
argument_list|(
name|pVDev
operator|->
name|u
operator|.
name|array
operator|.
name|pMember
index|[
literal|0
index|]
argument_list|)
operator|)
operator|||
operator|(
name|pVDev
operator|->
name|u
operator|.
name|array
operator|.
name|pMember
index|[
literal|1
index|]
operator|&&
name|mIsArray
argument_list|(
name|pVDev
operator|->
name|u
operator|.
name|array
operator|.
name|pMember
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
name|memcpy
argument_list|(
operator|&
name|inquiryData
operator|->
name|ProductId
argument_list|,
literal|"RAID 0/1 Array  "
argument_list|,
literal|16
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
operator|&
name|inquiryData
operator|->
name|ProductId
argument_list|,
literal|"RAID 1 Array    "
argument_list|,
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
name|VD_RAID_5
case|:
name|memcpy
argument_list|(
operator|&
name|inquiryData
operator|->
name|ProductId
argument_list|,
literal|"RAID 5 Array    "
argument_list|,
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
name|VD_JBOD
case|:
name|memcpy
argument_list|(
operator|&
name|inquiryData
operator|->
name|ProductId
argument_list|,
literal|"JBOD Array      "
argument_list|,
literal|16
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
name|memcpy
argument_list|(
operator|&
name|inquiryData
operator|->
name|ProductRevisionLevel
argument_list|,
literal|"3.00"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hpt_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|_VBUS_INST
argument_list|(
argument|&((IAL_ADAPTER_T*)((union ccb *)arg)->ccb_adapter)->VBus
argument_list|)
name|intrmask_t
name|oldspl
decl_stmt|;
name|oldspl
operator|=
name|lock_driver
argument_list|()
expr_stmt|;
name|fResetVBus
argument_list|(
name|_VBUS_P0
argument_list|)
expr_stmt|;
name|unlock_driver
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|HPTLIBAPI
name|OsSendCommand
parameter_list|(
name|_VBUS_ARG
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|PVDevice
name|pVDev
decl_stmt|;
name|pAdapter
operator|=
operator|(
name|IAL_ADAPTER_T
operator|*
operator|)
name|ccb
operator|->
name|ccb_adapter
expr_stmt|;
name|ccb_h
operator|=
operator|&
name|ccb
operator|->
name|ccb_h
expr_stmt|;
name|csio
operator|=
operator|&
name|ccb
operator|->
name|csio
expr_stmt|;
name|pVDev
operator|=
name|pAdapter
operator|->
name|VBus
operator|.
name|pVDevice
index|[
name|ccb_h
operator|->
name|target_id
index|]
expr_stmt|;
name|KdPrintI
argument_list|(
operator|(
literal|"OsSendCommand: ccb %p cdb %x-%x-%x\n"
operator|,
name|ccb
operator|,
operator|*
operator|(
name|ULONG
operator|*
operator|)
operator|&
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
operator|,
operator|*
operator|(
name|ULONG
operator|*
operator|)
operator|&
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|4
index|]
operator|,
operator|*
operator|(
name|ULONG
operator|*
operator|)
operator|&
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|8
index|]
operator|)
argument_list|)
expr_stmt|;
name|pAdapter
operator|->
name|outstandingCommands
operator|++
expr_stmt|;
if|if
condition|(
name|pVDev
operator|==
name|NULL
operator|||
name|pVDev
operator|->
name|vf_online
operator|==
literal|0
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|ccb_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
goto|goto
name|Command_Complished
goto|;
block|}
switch|switch
condition|(
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
condition|)
block|{
case|case
name|TEST_UNIT_READY
case|:
case|case
name|START_STOP_UNIT
case|:
case|case
name|SYNCHRONIZE_CACHE
case|:
comment|/* FALLTHROUGH */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
case|case
name|INQUIRY
case|:
name|ZeroMemory
argument_list|(
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
argument_list|)
expr_stmt|;
name|SetInquiryData
argument_list|(
operator|(
name|PINQUIRYDATA
operator|)
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
argument_list|,
name|pVDev
argument_list|)
expr_stmt|;
name|ccb_h
operator|->
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
case|case
name|READ_CAPACITY
case|:
block|{
name|UCHAR
name|swip
index|[
literal|4
index|]
decl_stmt|;
comment|/* Claim 512 byte blocks (big-endian). */
operator|(
operator|(
name|PREAD_CAPACITY_DATA
operator|)
name|csio
operator|->
name|data_ptr
operator|)
operator|->
name|BytesPerBlock
operator|=
literal|0x20000
expr_stmt|;
operator|*
operator|(
name|ULONG
operator|*
operator|)
name|swip
operator|=
name|pVDev
operator|->
name|VDeviceCapacity
operator|-
literal|1
expr_stmt|;
operator|(
operator|(
name|PREAD_CAPACITY_DATA
operator|)
name|csio
operator|->
name|data_ptr
operator|)
operator|->
name|LogicalBlockAddress
operator|=
operator|(
name|swip
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|swip
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|swip
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
name|swip
index|[
literal|3
index|]
expr_stmt|;
name|ccb_h
operator|->
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
block|}
case|case
name|READ_6
case|:
case|case
name|WRITE_6
case|:
case|case
name|READ_10
case|:
case|case
name|WRITE_10
case|:
case|case
literal|0x13
case|:
case|case
literal|0x2f
case|:
block|{
name|UCHAR
name|Cdb
index|[
literal|16
index|]
decl_stmt|;
name|UCHAR
name|CdbLength
decl_stmt|;
name|_VBUS_INST
argument_list|(
argument|pVDev->pVBus
argument_list|)
name|PCommand
name|pCmd
decl_stmt|;
name|pCmd
operator|=
name|AllocateCommand
argument_list|(
name|_VBUS_P0
argument_list|)
expr_stmt|;
name|HPT_ASSERT
argument_list|(
name|pCmd
argument_list|)
expr_stmt|;
name|CdbLength
operator|=
name|csio
operator|->
name|cdb_len
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_POINTER
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_PHYS
operator|)
operator|==
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_ptr
argument_list|,
name|Cdb
argument_list|,
name|CdbLength
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|KdPrintE
argument_list|(
operator|(
literal|"ERROR!!!\n"
operator|)
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|bcopy
argument_list|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
name|Cdb
argument_list|,
name|CdbLength
argument_list|)
expr_stmt|;
block|}
name|pCmd
operator|->
name|pOrgCommand
operator|=
name|AllocPrivCommand
argument_list|(
name|pAdapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|pCmd
operator|->
name|pOrgCommand
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"command leak!"
argument_list|)
expr_stmt|;
operator|(
call|(
name|pPrivCommand
call|)
argument_list|(
name|pCmd
operator|->
name|pOrgCommand
argument_list|)
operator|)
operator|->
name|ccb
operator|=
name|ccb
expr_stmt|;
name|pCmd
operator|->
name|pVDevice
operator|=
name|pVDev
expr_stmt|;
name|pCmd
operator|->
name|pfnCompletion
operator|=
name|fOsCommandDone
expr_stmt|;
name|pCmd
operator|->
name|pfnBuildSgl
operator|=
name|fOsBuildSgl
expr_stmt|;
switch|switch
condition|(
name|Cdb
index|[
literal|0
index|]
condition|)
block|{
case|case
name|READ_6
case|:
case|case
name|WRITE_6
case|:
case|case
literal|0x13
case|:
name|pCmd
operator|->
name|uCmd
operator|.
name|Ide
operator|.
name|Lba
operator|=
operator|(
operator|(
name|ULONG
operator|)
name|Cdb
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|ULONG
operator|)
name|Cdb
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|ULONG
operator|)
name|Cdb
index|[
literal|3
index|]
expr_stmt|;
name|pCmd
operator|->
name|uCmd
operator|.
name|Ide
operator|.
name|nSectors
operator|=
operator|(
name|USHORT
operator|)
name|Cdb
index|[
literal|4
index|]
expr_stmt|;
break|break;
default|default:
name|pCmd
operator|->
name|uCmd
operator|.
name|Ide
operator|.
name|Lba
operator|=
operator|(
name|ULONG
operator|)
name|Cdb
index|[
literal|5
index|]
operator||
operator|(
operator|(
name|ULONG
operator|)
name|Cdb
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|ULONG
operator|)
name|Cdb
index|[
literal|3
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|ULONG
operator|)
name|Cdb
index|[
literal|2
index|]
operator|<<
literal|24
operator|)
expr_stmt|;
name|pCmd
operator|->
name|uCmd
operator|.
name|Ide
operator|.
name|nSectors
operator|=
operator|(
name|USHORT
operator|)
name|Cdb
index|[
literal|8
index|]
operator||
operator|(
operator|(
name|USHORT
operator|)
name|Cdb
index|[
literal|7
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|Cdb
index|[
literal|0
index|]
condition|)
block|{
case|case
name|READ_6
case|:
case|case
name|READ_10
case|:
name|pCmd
operator|->
name|uCmd
operator|.
name|Ide
operator|.
name|Command
operator|=
name|IDE_COMMAND_READ
expr_stmt|;
name|pCmd
operator|->
name|cf_data_in
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|WRITE_6
case|:
case|case
name|WRITE_10
case|:
name|pCmd
operator|->
name|uCmd
operator|.
name|Ide
operator|.
name|Command
operator|=
name|IDE_COMMAND_WRITE
expr_stmt|;
name|pCmd
operator|->
name|cf_data_out
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|0x13
case|:
case|case
literal|0x2f
case|:
name|pCmd
operator|->
name|uCmd
operator|.
name|Ide
operator|.
name|Command
operator|=
name|IDE_COMMAND_VERIFY
expr_stmt|;
break|break;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|hpt_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ccb
argument_list|,
literal|20
operator|*
name|hz
argument_list|)
expr_stmt|;
name|pVDev
operator|->
name|pfnSendCommand
argument_list|(
argument|_VBUS_P pCmd
argument_list|)
expr_stmt|;
goto|goto
name|Command_Complished
goto|;
block|}
default|default:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
break|break;
block|}
name|ccb_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|Command_Complished
label|:
name|CheckPendingCall
argument_list|(
name|_VBUS_P0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|HPTLIBAPI
name|fOsCommandDone
parameter_list|(
name|_VBUS_ARG
name|PCommand
name|pCmd
parameter_list|)
block|{
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
decl_stmt|;
name|pPrivCommand
name|prvCmd
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|prvCmd
operator|=
name|pCmd
operator|->
name|pOrgCommand
expr_stmt|;
name|pAdapter
operator|=
name|prvCmd
operator|->
name|pAdapter
expr_stmt|;
name|ccb
operator|=
name|prvCmd
operator|->
name|ccb
expr_stmt|;
name|KdPrint
argument_list|(
operator|(
literal|"fOsCommandDone(%p, %d)"
operator|,
name|pCmd
operator|,
name|pCmd
operator|->
name|Result
operator|)
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|hpt_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ccb
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pCmd
operator|->
name|Result
condition|)
block|{
case|case
name|RETURN_SUCCESS
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
case|case
name|RETURN_BAD_DEVICE
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_DEV_NOT_THERE
expr_stmt|;
break|break;
case|case
name|RETURN_DEVICE_BUSY
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_BUSY
expr_stmt|;
break|break;
case|case
name|RETURN_INVALID_REQUEST
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
break|break;
case|case
name|RETURN_SELECTION_TIMEOUT
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SEL_TIMEOUT
expr_stmt|;
break|break;
case|case
name|RETURN_RETRY
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_BUSY
expr_stmt|;
break|break;
default|default:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SCSI_STATUS_ERROR
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|pAdapter
operator|->
name|buf_dmat
argument_list|,
name|prvCmd
operator|->
name|buf_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bus_dmamap_sync
argument_list|(
name|pAdapter
operator|->
name|buf_dmat
argument_list|,
name|prvCmd
operator|->
name|buf_map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_unload
argument_list|(
name|pAdapter
operator|->
name|buf_dmat
argument_list|,
name|prvCmd
operator|->
name|buf_map
argument_list|)
expr_stmt|;
name|FreePrivCommand
argument_list|(
name|pAdapter
argument_list|,
name|prvCmd
argument_list|)
expr_stmt|;
name|FreeCommand
argument_list|(
argument|_VBUS_P pCmd
argument_list|)
empty_stmt|;
name|ccb_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|hpt_queue_dpc
parameter_list|(
name|HPT_DPC
name|dpc
parameter_list|,
name|IAL_ADAPTER_T
modifier|*
name|pAdapter
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|UCHAR
name|flags
parameter_list|)
block|{
name|int
name|p
decl_stmt|;
name|p
operator|=
operator|(
name|DpcQueue_Last
operator|+
literal|1
operator|)
operator|%
name|MAX_DPC
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|DpcQueue_First
condition|)
block|{
name|KdPrint
argument_list|(
operator|(
literal|"DPC Queue full!\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|DpcQueue
index|[
name|DpcQueue_Last
index|]
operator|.
name|dpc
operator|=
name|dpc
expr_stmt|;
name|DpcQueue
index|[
name|DpcQueue_Last
index|]
operator|.
name|pAdapter
operator|=
name|pAdapter
expr_stmt|;
name|DpcQueue
index|[
name|DpcQueue_Last
index|]
operator|.
name|arg
operator|=
name|arg
expr_stmt|;
name|DpcQueue
index|[
name|DpcQueue_Last
index|]
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
name|DpcQueue_Last
operator|=
name|p
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_RAID5N_
end_ifdef

begin_comment
comment|/*   * Allocate memory above 16M, otherwise we may eat all low memory for ISA  * devices.  *  * Busdma should be used here, not contigmalloc/free.  However, this API  * will need to be changed to use it effective.  */
end_comment

begin_function
name|void
modifier|*
name|os_alloc_page
parameter_list|(
name|_VBUS_ARG0
parameter_list|)
block|{
return|return
operator|(
name|void
operator|*
operator|)
name|contigmalloc
argument_list|(
literal|0x1000
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|,
literal|0x1000000
argument_list|,
literal|0xffffffff
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|os_alloc_dma_page
parameter_list|(
name|_VBUS_ARG0
parameter_list|)
block|{
return|return
operator|(
name|void
operator|*
operator|)
name|contigmalloc
argument_list|(
literal|0x1000
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|,
literal|0x1000000
argument_list|,
literal|0xffffffff
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * The next two are not used right now.  */
end_comment

begin_function
name|void
name|os_free_page
parameter_list|(
name|_VBUS_ARG
name|void
modifier|*
name|p
parameter_list|)
block|{
name|contigfree
argument_list|(
name|p
argument_list|,
literal|0x1000
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|os_free_dma_page
parameter_list|(
name|_VBUS_ARG
name|void
modifier|*
name|p
parameter_list|)
block|{
name|contigfree
argument_list|(
name|p
argument_list|,
literal|0x1000
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|DoXor1
parameter_list|(
name|ULONG
modifier|*
name|p0
parameter_list|,
name|ULONG
modifier|*
name|p1
parameter_list|,
name|ULONG
modifier|*
name|p2
parameter_list|,
name|UINT
name|nBytes
parameter_list|)
block|{
name|UINT
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nBytes
operator|/
literal|4
condition|;
name|i
operator|++
control|)
operator|*
name|p0
operator|++
operator|=
operator|*
name|p1
operator|++
operator|^
operator|*
name|p2
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|DoXor2
parameter_list|(
name|ULONG
modifier|*
name|p0
parameter_list|,
name|ULONG
modifier|*
name|p2
parameter_list|,
name|UINT
name|nBytes
parameter_list|)
block|{
name|UINT
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nBytes
operator|/
literal|4
condition|;
name|i
operator|++
control|)
operator|*
name|p0
operator|++
operator|^=
operator|*
name|p2
operator|++
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

