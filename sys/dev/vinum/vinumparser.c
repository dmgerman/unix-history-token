begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1997, 1998  *	Nan Yang Computer Services Limited.  All rights reserved.  *  *  This software is distributed under the so-called ``Berkeley  *  License'':  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Nan Yang Computer  *      Services Limited.  * 4. Neither the name of the Company nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * This software is provided ``as is'', and any express or implied  * warranties, including, but not limited to, the implied warranties of  * merchantability and fitness for a particular purpose are disclaimed.  * In no event shall the company or contributors be liable for any  * direct, indirect, incidental, special, exemplary, or consequential  * damages (including, but not limited to, procurement of substitute  * goods or services; loss of use, data, or profits; or business  * interruption) however caused and on any theory of liability, whether  * in contract, strict liability, or tort (including negligence or  * otherwise) arising in any way out of the use of this software, even if  * advised of the possibility of such damage.  *  * $Id: vinumparser.c,v 1.21 2000/12/20 03:44:13 grog Exp grog $  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * This file contains the parser for the configuration routines.  It's used  * both in the kernel and in the user interface program, thus the separate file.  */
end_comment

begin_comment
comment|/*  * Go through a text and split up into text tokens.  These are either non-blank  * sequences, or any sequence (except \0) enclosed in ' or ".  Embedded ' or  * " characters may be escaped by \, which otherwise has no special meaning.  *  * Delimit by following with a \0, and return pointers to the starts at token [].  * Return the number of tokens found as the return value.  *  * This method has the restriction that a closing " or ' must be followed by  * grey space.  *  * Error conditions are end of line before end of quote, or no space after  * a closing quote.  In this case, tokenize() returns -1.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<dev/vinum/vinumkw.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<machine/setjmp.h>
end_include

begin_comment
comment|/* All this mess for a single struct definition */
end_comment

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<dev/vinum/vinumvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/vinum/vinumio.h>
end_include

begin_include
include|#
directive|include
file|<dev/vinum/vinumext.h>
end_include

begin_define
define|#
directive|define
name|iswhite
parameter_list|(
name|c
parameter_list|)
value|((c == ' ') || (c == '\t'))
end_define

begin_comment
comment|/* check for white space */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* userland */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_define
define|#
directive|define
name|iswhite
value|isspace
end_define

begin_comment
comment|/* use the ctype macro */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* enum keyword is defined in vinumvar.h */
end_comment

begin_define
define|#
directive|define
name|keypair
parameter_list|(
name|x
parameter_list|)
value|{ #x, kw_##x }
end_define

begin_comment
comment|/* create pair "foo", kw_foo */
end_comment

begin_define
define|#
directive|define
name|flagkeypair
parameter_list|(
name|x
parameter_list|)
value|{ "-"#x, kw_##x }
end_define

begin_comment
comment|/* create pair "-foo", kw_foo */
end_comment

begin_define
define|#
directive|define
name|KEYWORDSET
parameter_list|(
name|x
parameter_list|)
value|{sizeof (x) / sizeof (struct _keywords), x}
end_define

begin_comment
comment|/* Normal keywords.  These are all the words that vinum knows. */
end_comment

begin_decl_stmt
name|struct
name|_keywords
name|keywords
index|[]
init|=
block|{
name|keypair
argument_list|(
name|drive
argument_list|)
block|,
name|keypair
argument_list|(
name|partition
argument_list|)
block|,
name|keypair
argument_list|(
name|sd
argument_list|)
block|,
name|keypair
argument_list|(
name|subdisk
argument_list|)
block|,
name|keypair
argument_list|(
name|plex
argument_list|)
block|,
name|keypair
argument_list|(
name|volume
argument_list|)
block|,
name|keypair
argument_list|(
name|vol
argument_list|)
block|,
name|keypair
argument_list|(
name|setupstate
argument_list|)
block|,
name|keypair
argument_list|(
name|readpol
argument_list|)
block|,
name|keypair
argument_list|(
name|org
argument_list|)
block|,
name|keypair
argument_list|(
name|name
argument_list|)
block|,
name|keypair
argument_list|(
name|writethrough
argument_list|)
block|,
name|keypair
argument_list|(
name|writeback
argument_list|)
block|,
name|keypair
argument_list|(
name|raw
argument_list|)
block|,
name|keypair
argument_list|(
name|device
argument_list|)
block|,
name|keypair
argument_list|(
name|concat
argument_list|)
block|,
name|keypair
argument_list|(
name|raid4
argument_list|)
block|,
name|keypair
argument_list|(
name|raid5
argument_list|)
block|,
name|keypair
argument_list|(
name|striped
argument_list|)
block|,
name|keypair
argument_list|(
name|plexoffset
argument_list|)
block|,
name|keypair
argument_list|(
name|driveoffset
argument_list|)
block|,
name|keypair
argument_list|(
name|length
argument_list|)
block|,
name|keypair
argument_list|(
name|len
argument_list|)
block|,
name|keypair
argument_list|(
name|size
argument_list|)
block|,
name|keypair
argument_list|(
name|state
argument_list|)
block|,
name|keypair
argument_list|(
name|round
argument_list|)
block|,
name|keypair
argument_list|(
name|prefer
argument_list|)
block|,
name|keypair
argument_list|(
name|rename
argument_list|)
block|,
name|keypair
argument_list|(
name|detached
argument_list|)
block|,
ifndef|#
directive|ifndef
name|_KERNEL
comment|/* for vinum(8) only */
ifdef|#
directive|ifdef
name|VINUMDEBUG
name|keypair
argument_list|(
name|debug
argument_list|)
block|,
endif|#
directive|endif
name|keypair
argument_list|(
name|stripe
argument_list|)
block|,
name|keypair
argument_list|(
name|mirror
argument_list|)
block|,
endif|#
directive|endif
name|keypair
argument_list|(
name|attach
argument_list|)
block|,
name|keypair
argument_list|(
name|detach
argument_list|)
block|,
name|keypair
argument_list|(
name|printconfig
argument_list|)
block|,
name|keypair
argument_list|(
name|saveconfig
argument_list|)
block|,
name|keypair
argument_list|(
name|replace
argument_list|)
block|,
name|keypair
argument_list|(
name|create
argument_list|)
block|,
name|keypair
argument_list|(
name|read
argument_list|)
block|,
name|keypair
argument_list|(
name|modify
argument_list|)
block|,
name|keypair
argument_list|(
name|list
argument_list|)
block|,
name|keypair
argument_list|(
name|l
argument_list|)
block|,
name|keypair
argument_list|(
name|ld
argument_list|)
block|,
name|keypair
argument_list|(
name|ls
argument_list|)
block|,
name|keypair
argument_list|(
name|lp
argument_list|)
block|,
name|keypair
argument_list|(
name|lv
argument_list|)
block|,
name|keypair
argument_list|(
name|info
argument_list|)
block|,
name|keypair
argument_list|(
name|set
argument_list|)
block|,
name|keypair
argument_list|(
name|rm
argument_list|)
block|,
name|keypair
argument_list|(
name|mv
argument_list|)
block|,
name|keypair
argument_list|(
name|move
argument_list|)
block|,
name|keypair
argument_list|(
name|init
argument_list|)
block|,
name|keypair
argument_list|(
name|label
argument_list|)
block|,
name|keypair
argument_list|(
name|resetconfig
argument_list|)
block|,
name|keypair
argument_list|(
name|start
argument_list|)
block|,
name|keypair
argument_list|(
name|stop
argument_list|)
block|,
name|keypair
argument_list|(
name|makedev
argument_list|)
block|,
name|keypair
argument_list|(
name|help
argument_list|)
block|,
name|keypair
argument_list|(
name|quit
argument_list|)
block|,
name|keypair
argument_list|(
name|setdaemon
argument_list|)
block|,
name|keypair
argument_list|(
name|getdaemon
argument_list|)
block|,
name|keypair
argument_list|(
name|max
argument_list|)
block|,
name|keypair
argument_list|(
name|replace
argument_list|)
block|,
name|keypair
argument_list|(
name|readpol
argument_list|)
block|,
name|keypair
argument_list|(
name|resetstats
argument_list|)
block|,
name|keypair
argument_list|(
name|setstate
argument_list|)
block|,
name|keypair
argument_list|(
name|checkparity
argument_list|)
block|,
name|keypair
argument_list|(
name|rebuildparity
argument_list|)
block|,
name|keypair
argument_list|(
name|dumpconfig
argument_list|)
block|,
name|keypair
argument_list|(
argument|retryerrors
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|keywordset
name|keyword_set
init|=
name|KEYWORDSET
argument_list|(
name|keywords
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|_KERNEL
end_ifndef

begin_decl_stmt
name|struct
name|_keywords
name|flag_keywords
index|[]
init|=
block|{
name|flagkeypair
argument_list|(
name|f
argument_list|)
block|,
name|flagkeypair
argument_list|(
name|d
argument_list|)
block|,
name|flagkeypair
argument_list|(
name|v
argument_list|)
block|,
name|flagkeypair
argument_list|(
name|s
argument_list|)
block|,
name|flagkeypair
argument_list|(
name|r
argument_list|)
block|,
name|flagkeypair
argument_list|(
argument|w
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|keywordset
name|flag_set
init|=
name|KEYWORDSET
argument_list|(
name|flag_keywords
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Take a blank separated list of tokens and turn it into a list of  * individual nul-delimited strings.  Build a list of pointers at  * token, which must have enough space for the tokens.  Return the  * number of tokens, or -1 on error (typically a missing string  * delimiter).  */
end_comment

begin_function
name|int
name|tokenize
parameter_list|(
name|char
modifier|*
name|cptr
parameter_list|,
name|char
modifier|*
name|token
index|[]
parameter_list|)
block|{
name|char
name|delim
decl_stmt|;
comment|/* delimiter for searching for the partner */
name|int
name|tokennr
decl_stmt|;
comment|/* index of this token */
name|tokennr
operator|=
literal|0
expr_stmt|;
comment|/* none found yet */
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
name|iswhite
argument_list|(
operator|*
name|cptr
argument_list|)
condition|)
name|cptr
operator|++
expr_stmt|;
comment|/* skip initial white space */
if|if
condition|(
operator|(
operator|*
name|cptr
operator|==
literal|'\0'
operator|)
operator|||
operator|(
operator|*
name|cptr
operator|==
literal|'\n'
operator|)
operator|||
operator|(
operator|*
name|cptr
operator|==
literal|'#'
operator|)
condition|)
comment|/* end of line */
return|return
name|tokennr
return|;
comment|/* return number of tokens found */
name|delim
operator|=
operator|*
name|cptr
expr_stmt|;
name|token
index|[
name|tokennr
index|]
operator|=
name|cptr
expr_stmt|;
comment|/* point to it */
name|tokennr
operator|++
expr_stmt|;
comment|/* one more */
comment|/* XXX this is broken.  It leaves superfluous \\ characters in the text */
if|if
condition|(
operator|(
name|delim
operator|==
literal|'\''
operator|)
operator|||
operator|(
name|delim
operator|==
literal|'"'
operator|)
condition|)
block|{
comment|/* delimitered */
for|for
control|(
init|;
condition|;
control|)
block|{
name|cptr
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|cptr
operator|==
name|delim
operator|)
operator|&&
operator|(
name|cptr
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\\'
operator|)
condition|)
block|{
comment|/* found the partner */
name|cptr
operator|++
expr_stmt|;
comment|/* move on past */
if|if
condition|(
operator|!
name|iswhite
argument_list|(
operator|*
name|cptr
argument_list|)
condition|)
comment|/* error, no space after closing quote */
return|return
operator|-
literal|1
return|;
operator|*
name|cptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* delimit */
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|cptr
operator|==
literal|'\0'
operator|)
operator|||
operator|(
operator|*
name|cptr
operator|==
literal|'\n'
operator|)
condition|)
comment|/* end of line */
return|return
operator|-
literal|1
return|;
block|}
block|}
else|else
block|{
comment|/* not quoted */
while|while
condition|(
operator|(
operator|*
name|cptr
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
operator|!
name|iswhite
argument_list|(
operator|*
name|cptr
argument_list|)
operator|)
operator|&&
operator|(
operator|*
name|cptr
operator|!=
literal|'\n'
operator|)
condition|)
name|cptr
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cptr
operator|!=
literal|'\0'
condition|)
comment|/* not end of the line, */
operator|*
name|cptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* delimit and move to the next */
block|}
block|}
block|}
end_function

begin_comment
comment|/* Find a keyword and return an index */
end_comment

begin_function
name|enum
name|keyword
name|get_keyword
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|keywordset
modifier|*
name|keywordset
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|_keywords
modifier|*
name|keywords
init|=
name|keywordset
operator|->
name|k
decl_stmt|;
comment|/* point to the keywords */
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
block|{
comment|/* parameter exists */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|keywordset
operator|->
name|size
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|keywords
index|[
name|i
index|]
operator|.
name|name
argument_list|)
condition|)
return|return
operator|(
expr|enum
name|keyword
operator|)
name|keywords
index|[
name|i
index|]
operator|.
name|keyword
return|;
block|}
return|return
name|kw_invalid_keyword
return|;
block|}
end_function

end_unit

