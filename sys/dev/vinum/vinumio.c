begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1997, 1998  *	Nan Yang Computer Services Limited.  All rights reserved.  *  *  This software is distributed under the so-called ``Berkeley  *  License'':  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Nan Yang Computer  *      Services Limited.  * 4. Neither the name of the Company nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * This software is provided ``as is'', and any express or implied  * warranties, including, but not limited to, the implied warranties of  * merchantability and fitness for a particular purpose are disclaimed.  * In no event shall the company or contributors be liable for any  * direct, indirect, incidental, special, exemplary, or consequential  * damages (including, but not limited to, procurement of substitute  * goods or services; loss of use, data, or profits; or business  * interruption) however caused and on any theory of liability, whether  * in contract, strict liability, or tort (including negligence or  * otherwise) arising in any way out of the use of this software, even if  * advised of the possibility of such damage.  *  * $Id: vinumio.c,v 1.39 2003/05/23 00:59:53 grog Exp grog $  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<dev/vinum/vinumhdr.h>
end_include

begin_include
include|#
directive|include
file|<dev/vinum/request.h>
end_include

begin_function_decl
specifier|static
name|char
modifier|*
name|sappend
parameter_list|(
name|char
modifier|*
name|txt
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|drivecmp
parameter_list|(
specifier|const
name|void
modifier|*
name|va
parameter_list|,
specifier|const
name|void
modifier|*
name|vb
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Open the device associated with the drive, and  * set drive's vp.  Return an error number.  */
end_comment

begin_function
name|int
name|open_drive
parameter_list|(
name|struct
name|drive
modifier|*
name|drive
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
name|struct
name|cdevsw
modifier|*
name|dsw
decl_stmt|;
comment|/* pointer to cdevsw entry */
if|if
condition|(
name|drive
operator|->
name|flags
operator|&
name|VF_OPEN
condition|)
comment|/* open already, */
return|return
name|EBUSY
return|;
comment|/* don't do it again */
name|drive
operator|->
name|dev
operator|=
name|getdiskbyname
argument_list|(
name|drive
operator|->
name|devicename
argument_list|)
expr_stmt|;
if|if
condition|(
name|drive
operator|->
name|dev
operator|==
name|NULL
condition|)
comment|/* didn't find anything */
return|return
name|ENOENT
return|;
name|dev_ref
argument_list|(
name|drive
operator|->
name|dev
argument_list|)
expr_stmt|;
name|drive
operator|->
name|dev
operator|->
name|si_iosize_max
operator|=
name|DFLTPHYS
expr_stmt|;
name|dsw
operator|=
name|devsw
argument_list|(
name|drive
operator|->
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsw
operator|==
name|NULL
condition|)
comment|/* sanity, should not happen */
name|drive
operator|->
name|lasterror
operator|=
name|ENOENT
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|dsw
operator|->
name|d_flags
operator|&
name|D_DISK
operator|)
operator|==
literal|0
condition|)
name|drive
operator|->
name|lasterror
operator|=
name|ENOTBLK
expr_stmt|;
else|else
block|{
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|drive
operator|->
name|lasterror
operator|=
call|(
name|dsw
operator|->
name|d_open
call|)
argument_list|(
name|drive
operator|->
name|dev
argument_list|,
name|FWRITE
operator||
name|FREAD
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|drive
operator|->
name|lasterror
operator|!=
literal|0
condition|)
block|{
comment|/* failed */
name|drive
operator|->
name|state
operator|=
name|drive_down
expr_stmt|;
comment|/* just force it down */
if|if
condition|(
name|verbose
condition|)
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"vinum open_drive %s: failed with error %d\n"
argument_list|,
name|drive
operator|->
name|devicename
argument_list|,
name|drive
operator|->
name|lasterror
argument_list|)
expr_stmt|;
block|}
else|else
name|drive
operator|->
name|flags
operator||=
name|VF_OPEN
expr_stmt|;
comment|/* we're open now */
return|return
name|drive
operator|->
name|lasterror
return|;
block|}
end_function

begin_comment
comment|/*  * Set some variables in the drive struct in more  * convenient form.  Return error indication.  */
end_comment

begin_function
name|int
name|set_drive_parms
parameter_list|(
name|struct
name|drive
modifier|*
name|drive
parameter_list|)
block|{
name|drive
operator|->
name|blocksize
operator|=
name|BLKDEV_IOSIZE
expr_stmt|;
comment|/* do we need this? */
name|drive
operator|->
name|secsperblock
operator|=
name|drive
operator|->
name|blocksize
comment|/* number of sectors per block */
operator|/
name|drive
operator|->
name|sectorsize
expr_stmt|;
comment|/* Now update the label part */
name|bcopy
argument_list|(
name|hostname
argument_list|,
name|drive
operator|->
name|label
operator|.
name|sysname
argument_list|,
name|VINUMHOSTNAMELEN
argument_list|)
expr_stmt|;
comment|/* put in host name */
name|microtime
argument_list|(
operator|&
name|drive
operator|->
name|label
operator|.
name|date_of_birth
argument_list|)
expr_stmt|;
comment|/* and current time */
name|drive
operator|->
name|label
operator|.
name|drive_size
operator|=
name|drive
operator|->
name|mediasize
expr_stmt|;
comment|/* size of the drive in bytes */
ifdef|#
directive|ifdef
name|VINUMDEBUG
if|if
condition|(
name|debug
operator|&
name|DEBUG_BIGDRIVE
condition|)
comment|/* pretend we're 100 times as big */
name|drive
operator|->
name|label
operator|.
name|drive_size
operator|*=
literal|100
expr_stmt|;
endif|#
directive|endif
comment|/* number of sectors available for subdisks */
name|drive
operator|->
name|sectors_available
operator|=
name|drive
operator|->
name|label
operator|.
name|drive_size
operator|/
name|DEV_BSIZE
operator|-
name|DATASTART
expr_stmt|;
comment|/*      * Bug in 3.0 as of January 1998: you can open      * non-existent slices.  They have a length of 0.      */
if|if
condition|(
name|drive
operator|->
name|label
operator|.
name|drive_size
operator|<
name|MINVINUMSLICE
condition|)
block|{
comment|/* too small to worry about */
name|set_drive_state
argument_list|(
name|drive
operator|->
name|driveno
argument_list|,
name|drive_down
argument_list|,
name|setstate_force
argument_list|)
expr_stmt|;
name|drive
operator|->
name|lasterror
operator|=
name|ENOSPC
expr_stmt|;
return|return
name|ENOSPC
return|;
block|}
name|drive
operator|->
name|freelist_size
operator|=
name|INITIAL_DRIVE_FREELIST
expr_stmt|;
comment|/* initial number of entries */
name|drive
operator|->
name|freelist
operator|=
operator|(
expr|struct
name|drive_freelist
operator|*
operator|)
name|Malloc
argument_list|(
name|INITIAL_DRIVE_FREELIST
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|drive_freelist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|drive
operator|->
name|freelist
operator|==
name|NULL
condition|)
comment|/* can't malloc, dammit */
return|return
name|ENOSPC
return|;
name|drive
operator|->
name|freelist_entries
operator|=
literal|1
expr_stmt|;
comment|/* just (almost) the complete drive */
name|drive
operator|->
name|freelist
index|[
literal|0
index|]
operator|.
name|offset
operator|=
name|DATASTART
expr_stmt|;
comment|/* starts here */
name|drive
operator|->
name|freelist
index|[
literal|0
index|]
operator|.
name|sectors
operator|=
operator|(
name|drive
operator|->
name|label
operator|.
name|drive_size
operator|>>
name|DEV_BSHIFT
operator|)
operator|-
name|DATASTART
expr_stmt|;
comment|/* and it's this long */
if|if
condition|(
name|drive
operator|->
name|label
operator|.
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
comment|/* got a name */
name|set_drive_state
argument_list|(
name|drive
operator|->
name|driveno
argument_list|,
name|drive_up
argument_list|,
name|setstate_force
argument_list|)
expr_stmt|;
comment|/* our drive is accessible */
else|else
comment|/* we know about it, but that's all */
name|drive
operator|->
name|state
operator|=
name|drive_referenced
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize a drive: open the device and add  * device information.  */
end_comment

begin_function
name|int
name|init_drive
parameter_list|(
name|struct
name|drive
modifier|*
name|drive
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
name|drive
operator|->
name|lasterror
operator|=
name|open_drive
argument_list|(
name|drive
argument_list|,
name|curthread
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
comment|/* open the drive */
if|if
condition|(
name|drive
operator|->
name|lasterror
condition|)
return|return
name|drive
operator|->
name|lasterror
return|;
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|drive
operator|->
name|lasterror
operator|=
operator|(
operator|*
name|devsw
argument_list|(
name|drive
operator|->
name|dev
argument_list|)
operator|->
name|d_ioctl
operator|)
operator|(
name|drive
operator|->
name|dev
operator|,
name|DIOCGSECTORSIZE
operator|,
operator|(
name|caddr_t
operator|)
operator|&
name|drive
operator|->
name|sectorsize
operator|,
name|FREAD
operator|,
name|curthread
operator|)
expr_stmt|;
if|if
condition|(
name|drive
operator|->
name|lasterror
operator|==
literal|0
condition|)
name|drive
operator|->
name|lasterror
operator|=
operator|(
operator|*
name|devsw
argument_list|(
name|drive
operator|->
name|dev
argument_list|)
operator|->
name|d_ioctl
operator|)
operator|(
name|drive
operator|->
name|dev
operator|,
name|DIOCGMEDIASIZE
operator|,
operator|(
name|caddr_t
operator|)
operator|&
name|drive
operator|->
name|mediasize
operator|,
name|FREAD
operator|,
name|curthread
operator|)
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
if|if
condition|(
name|drive
operator|->
name|lasterror
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"vinum: Can't get drive dimensions for %s: error %d\n"
argument_list|,
name|drive
operator|->
name|devicename
argument_list|,
name|drive
operator|->
name|lasterror
argument_list|)
expr_stmt|;
name|close_drive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
return|return
name|drive
operator|->
name|lasterror
return|;
block|}
return|return
name|set_drive_parms
argument_list|(
name|drive
argument_list|)
return|;
comment|/* set various odds and ends */
block|}
end_function

begin_comment
comment|/* Close a drive if it's open. */
end_comment

begin_function
name|void
name|close_drive
parameter_list|(
name|struct
name|drive
modifier|*
name|drive
parameter_list|)
block|{
name|LOCKDRIVE
argument_list|(
name|drive
argument_list|)
expr_stmt|;
comment|/* keep the daemon out */
if|if
condition|(
name|drive
operator|->
name|flags
operator|&
name|VF_OPEN
condition|)
name|close_locked_drive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
comment|/* and close it */
if|if
condition|(
name|drive
operator|->
name|state
operator|>
name|drive_down
condition|)
comment|/* if it's up */
name|drive
operator|->
name|state
operator|=
name|drive_down
expr_stmt|;
comment|/* make sure it's down */
name|unlockdrive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Real drive close code, called with drive already locked.  * We have also checked that the drive is open.  No errors.  */
end_comment

begin_function
name|void
name|close_locked_drive
parameter_list|(
name|struct
name|drive
modifier|*
name|drive
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
comment|/*      * If we can't access the drive, we can't flush      * the queues, which spec_close() will try to      * do.  Get rid of them here first.      */
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|error
operator|=
operator|(
operator|*
name|devsw
argument_list|(
name|drive
operator|->
name|dev
argument_list|)
operator|->
name|d_close
operator|)
operator|(
name|drive
operator|->
name|dev
operator|,
name|FWRITE
operator||
name|FREAD
operator|,
literal|0
operator|,
name|NULL
operator|)
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
name|drive
operator|->
name|flags
operator|&=
operator|~
name|VF_OPEN
expr_stmt|;
comment|/* no longer open */
if|if
condition|(
name|drive
operator|->
name|lasterror
operator|==
literal|0
condition|)
name|drive
operator|->
name|lasterror
operator|=
name|error
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove drive from the configuration.  * Caller must ensure that it isn't active.  */
end_comment

begin_function
name|void
name|remove_drive
parameter_list|(
name|int
name|driveno
parameter_list|)
block|{
name|struct
name|drive
modifier|*
name|drive
init|=
operator|&
name|vinum_conf
operator|.
name|drive
index|[
name|driveno
index|]
decl_stmt|;
name|struct
name|vinum_hdr
modifier|*
name|vhdr
decl_stmt|;
comment|/* buffer for header */
name|int
name|error
decl_stmt|;
if|if
condition|(
name|drive
operator|->
name|state
operator|>
name|drive_referenced
condition|)
block|{
comment|/* real drive */
if|if
condition|(
name|drive
operator|->
name|state
operator|==
name|drive_up
condition|)
block|{
name|vhdr
operator|=
operator|(
expr|struct
name|vinum_hdr
operator|*
operator|)
name|Malloc
argument_list|(
name|VINUMHEADERLEN
argument_list|)
expr_stmt|;
comment|/* allocate buffer */
name|CHECKALLOC
argument_list|(
name|vhdr
argument_list|,
literal|"Can't allocate memory"
argument_list|)
expr_stmt|;
name|error
operator|=
name|read_drive
argument_list|(
name|drive
argument_list|,
operator|(
name|void
operator|*
operator|)
name|vhdr
argument_list|,
name|VINUMHEADERLEN
argument_list|,
name|VINUM_LABEL_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|drive
operator|->
name|lasterror
operator|=
name|error
expr_stmt|;
else|else
block|{
name|vhdr
operator|->
name|magic
operator|=
name|VINUM_NOMAGIC
expr_stmt|;
comment|/* obliterate the magic, but leave the rest */
name|write_drive
argument_list|(
name|drive
argument_list|,
operator|(
name|void
operator|*
operator|)
name|vhdr
argument_list|,
name|VINUMHEADERLEN
argument_list|,
name|VINUM_LABEL_OFFSET
argument_list|)
expr_stmt|;
block|}
name|Free
argument_list|(
name|vhdr
argument_list|)
expr_stmt|;
block|}
name|free_drive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
comment|/* close it and free resources */
name|save_config
argument_list|()
expr_stmt|;
comment|/* and save the updated configuration */
block|}
block|}
end_function

begin_comment
comment|/*  * Transfer drive data.  Usually called from one of these defines;  * #define read_drive(a, b, c, d) driveio (a, b, c, d, B_READ)  * #define write_drive(a, b, c, d) driveio (a, b, c, d, B_WRITE)  *  * length and offset are in bytes, but must be multiples of sector  * size.  The function *does not check* for this condition, and  * truncates ruthlessly.  * Return error number.  */
end_comment

begin_function
name|int
name|driveio
parameter_list|(
name|struct
name|drive
modifier|*
name|drive
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|length
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* to keep the compiler happy */
while|while
condition|(
name|length
condition|)
block|{
comment|/* divide into small enough blocks */
name|int
name|len
init|=
name|min
argument_list|(
name|length
argument_list|,
name|MAXBSIZE
argument_list|)
decl_stmt|;
comment|/* maximum block device transfer is MAXBSIZE */
name|bp
operator|=
name|geteblk
argument_list|(
name|len
argument_list|)
expr_stmt|;
comment|/* get a buffer header */
name|bp
operator|->
name|b_flags
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_iocmd
operator|=
name|flag
expr_stmt|;
name|bp
operator|->
name|b_dev
operator|=
name|drive
operator|->
name|dev
expr_stmt|;
comment|/* device */
name|bp
operator|->
name|b_blkno
operator|=
name|offset
operator|/
name|drive
operator|->
name|sectorsize
expr_stmt|;
comment|/* block number */
name|bp
operator|->
name|b_offset
operator|=
name|offset
expr_stmt|;
name|bp
operator|->
name|b_iooffset
operator|=
name|offset
expr_stmt|;
name|bp
operator|->
name|b_saveaddr
operator|=
name|bp
operator|->
name|b_data
expr_stmt|;
name|bp
operator|->
name|b_data
operator|=
name|buf
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
name|len
expr_stmt|;
name|DEV_STRATEGY
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* initiate the transfer */
name|error
operator|=
name|bufwait
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_data
operator|=
name|bp
operator|->
name|b_saveaddr
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_INVAL
operator||
name|B_AGE
expr_stmt|;
name|bp
operator|->
name|b_ioflags
operator|&=
operator|~
name|BIO_ERROR
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|length
operator|-=
name|len
expr_stmt|;
comment|/* update pointers */
name|buf
operator|+=
name|len
expr_stmt|;
name|offset
operator|+=
name|len
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Check a drive for a vinum header.  If found,  * update the drive information.  We come here  * with a partially populated drive structure  * which includes the device name.  *  * Return information on what we found.  *  * This function is called from two places: check_drive,  * which wants to find out whether the drive is a  * Vinum drive, and config_drive, which asserts that  * it is a vinum drive.  In the first case, we don't  * print error messages (verbose==0), in the second  * we do (verbose==1).  */
end_comment

begin_function
name|enum
name|drive_label_info
name|read_drive_label
parameter_list|(
name|struct
name|drive
modifier|*
name|drive
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|result
decl_stmt|;
comment|/* result of our search */
name|struct
name|vinum_hdr
modifier|*
name|vhdr
decl_stmt|;
comment|/* and as header */
name|error
operator|=
name|init_drive
argument_list|(
name|drive
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* find the drive */
if|if
condition|(
name|error
condition|)
comment|/* find the drive */
return|return
name|DL_CANT_OPEN
return|;
comment|/* not ours */
name|vhdr
operator|=
operator|(
expr|struct
name|vinum_hdr
operator|*
operator|)
name|Malloc
argument_list|(
name|VINUMHEADERLEN
argument_list|)
expr_stmt|;
comment|/* allocate buffers */
name|CHECKALLOC
argument_list|(
name|vhdr
argument_list|,
literal|"Can't allocate memory"
argument_list|)
expr_stmt|;
name|drive
operator|->
name|state
operator|=
name|drive_up
expr_stmt|;
comment|/* be optimistic */
name|error
operator|=
name|read_drive
argument_list|(
name|drive
argument_list|,
operator|(
name|void
operator|*
operator|)
name|vhdr
argument_list|,
name|VINUMHEADERLEN
argument_list|,
name|VINUM_LABEL_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|vhdr
operator|->
name|magic
operator|==
name|VINUM_MAGIC
condition|)
block|{
comment|/* ours! */
if|if
condition|(
name|drive
operator|->
name|label
operator|.
name|name
index|[
literal|0
index|]
comment|/* we have a name for this drive */
operator|&&
operator|(
name|strcmp
argument_list|(
name|drive
operator|->
name|label
operator|.
name|name
argument_list|,
name|vhdr
operator|->
name|label
operator|.
name|name
argument_list|)
operator|)
condition|)
block|{
comment|/* but it doesn't match the real name */
name|drive
operator|->
name|lasterror
operator|=
name|EINVAL
expr_stmt|;
name|result
operator|=
name|DL_WRONG_DRIVE
expr_stmt|;
comment|/* it's the wrong drive */
name|drive
operator|->
name|state
operator|=
name|drive_unallocated
expr_stmt|;
comment|/* put it back, it's not ours */
block|}
else|else
name|result
operator|=
name|DL_OURS
expr_stmt|;
comment|/* 	 * We copy the drive anyway so that we have 	 * the correct name in the drive info.  This 	 * may not be the name specified 	 */
name|drive
operator|->
name|label
operator|=
name|vhdr
operator|->
name|label
expr_stmt|;
comment|/* put in the label information */
block|}
elseif|else
if|if
condition|(
name|vhdr
operator|->
name|magic
operator|==
name|VINUM_NOMAGIC
condition|)
comment|/* was ours, but we gave it away */
name|result
operator|=
name|DL_DELETED_LABEL
expr_stmt|;
comment|/* and return the info */
else|else
name|result
operator|=
name|DL_NOT_OURS
expr_stmt|;
comment|/* we could have it, but we don't yet */
name|Free
argument_list|(
name|vhdr
argument_list|)
expr_stmt|;
comment|/* that's all. */
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * Check a drive for a vinum header.  If found,  * read configuration information from the drive and  * incorporate the data into the configuration.  *  * Return drive number.  */
end_comment

begin_function
name|struct
name|drive
modifier|*
name|check_drive
parameter_list|(
name|char
modifier|*
name|devicename
parameter_list|)
block|{
name|int
name|driveno
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|drive
modifier|*
name|drive
decl_stmt|;
name|driveno
operator|=
name|find_drive_by_name
argument_list|(
name|devicename
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* if entry doesn't exist, create it */
name|drive
operator|=
operator|&
name|vinum_conf
operator|.
name|drive
index|[
name|driveno
index|]
expr_stmt|;
comment|/* and get a pointer */
if|if
condition|(
name|drive
operator|->
name|state
operator|>=
name|drive_down
condition|)
comment|/* up or down, we know it */
return|return
name|drive
return|;
if|if
condition|(
name|read_drive_label
argument_list|(
name|drive
argument_list|,
literal|0
argument_list|)
operator|==
name|DL_OURS
condition|)
block|{
comment|/* one of ours */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vinum_conf
operator|.
name|drives_allocated
condition|;
name|i
operator|++
control|)
block|{
comment|/* see if the name already exists */
if|if
condition|(
operator|(
name|i
operator|!=
name|driveno
operator|)
comment|/* not this drive */
operator|&&
operator|(
name|DRIVE
index|[
name|i
index|]
operator|.
name|state
operator|!=
name|drive_unallocated
operator|)
comment|/* and it's allocated */
operator|&&
operator|(
name|strcmp
argument_list|(
name|DRIVE
index|[
name|i
index|]
operator|.
name|label
operator|.
name|name
argument_list|,
name|DRIVE
index|[
name|driveno
index|]
operator|.
name|label
operator|.
name|name
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* and it has the same name */
name|struct
name|drive
modifier|*
name|mydrive
init|=
operator|&
name|DRIVE
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|mydrive
operator|->
name|devicename
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
comment|/* we know a device name for it */
comment|/* 		     * set an error, but don't take the 		     * drive down: that would cause unneeded 		     * error messages. 		     */
name|drive
operator|->
name|lasterror
operator|=
name|EEXIST
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/* it's just a place holder, */
name|int
name|sdno
decl_stmt|;
for|for
control|(
name|sdno
operator|=
literal|0
init|;
name|sdno
operator|<
name|vinum_conf
operator|.
name|subdisks_allocated
condition|;
name|sdno
operator|++
control|)
block|{
comment|/* look at each subdisk */
if|if
condition|(
operator|(
name|SD
index|[
name|sdno
index|]
operator|.
name|driveno
operator|==
name|i
operator|)
comment|/* it's pointing to this one, */
operator|&&
operator|(
name|SD
index|[
name|sdno
index|]
operator|.
name|state
operator|!=
name|sd_unallocated
operator|)
condition|)
block|{
comment|/* and it's a real subdisk */
name|SD
index|[
name|sdno
index|]
operator|.
name|driveno
operator|=
name|drive
operator|->
name|driveno
expr_stmt|;
comment|/* point to the one we found */
name|update_sd_state
argument_list|(
name|sdno
argument_list|)
expr_stmt|;
comment|/* and update its state */
block|}
block|}
name|bzero
argument_list|(
name|mydrive
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|drive
argument_list|)
argument_list|)
expr_stmt|;
comment|/* don't deallocate it, just remove it */
block|}
block|}
block|}
return|return
name|drive
return|;
block|}
else|else
block|{
comment|/* not ours, */
name|close_drive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
name|free_drive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
comment|/* get rid of it */
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|sappend
parameter_list|(
name|char
modifier|*
name|txt
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
block|{
while|while
condition|(
operator|(
operator|*
name|s
operator|++
operator|=
operator|*
name|txt
operator|++
operator|)
operator|!=
literal|0
condition|)
empty_stmt|;
return|return
name|s
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|void
name|format_config
parameter_list|(
name|char
modifier|*
name|config
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|config
decl_stmt|;
name|char
modifier|*
name|configend
init|=
operator|&
name|config
index|[
name|len
index|]
decl_stmt|;
name|bzero
argument_list|(
name|config
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* First write the volume configuration */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vinum_conf
operator|.
name|volumes_allocated
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|volume
modifier|*
name|vol
decl_stmt|;
name|vol
operator|=
operator|&
name|vinum_conf
operator|.
name|volume
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|vol
operator|->
name|state
operator|>
name|volume_uninit
operator|)
operator|&&
operator|(
name|vol
operator|->
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|)
condition|)
block|{
comment|/* paranoia */
name|snprintf
argument_list|(
name|s
argument_list|,
name|configend
operator|-
name|s
argument_list|,
literal|"volume %s state %s"
argument_list|,
name|vol
operator|->
name|name
argument_list|,
name|volume_state
argument_list|(
name|vol
operator|->
name|state
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
name|s
operator|++
expr_stmt|;
comment|/* find the end */
name|s
operator|=
name|sappend
argument_list|(
literal|"\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Then the plex configuration */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vinum_conf
operator|.
name|plexes_allocated
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|plex
modifier|*
name|plex
decl_stmt|;
name|struct
name|volume
modifier|*
name|vol
decl_stmt|;
name|plex
operator|=
operator|&
name|vinum_conf
operator|.
name|plex
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|plex
operator|->
name|state
operator|>
name|plex_referenced
operator|)
operator|&&
operator|(
name|plex
operator|->
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|)
condition|)
block|{
comment|/* paranoia */
name|snprintf
argument_list|(
name|s
argument_list|,
name|configend
operator|-
name|s
argument_list|,
literal|"plex name %s state %s org %s "
argument_list|,
name|plex
operator|->
name|name
argument_list|,
name|plex_state
argument_list|(
name|plex
operator|->
name|state
argument_list|)
argument_list|,
name|plex_org
argument_list|(
name|plex
operator|->
name|organization
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
name|s
operator|++
expr_stmt|;
comment|/* find the end */
if|if
condition|(
name|isstriped
argument_list|(
name|plex
argument_list|)
condition|)
block|{
name|snprintf
argument_list|(
name|s
argument_list|,
name|configend
operator|-
name|s
argument_list|,
literal|"%ds "
argument_list|,
operator|(
name|int
operator|)
name|plex
operator|->
name|stripesize
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
name|s
operator|++
expr_stmt|;
comment|/* find the end */
block|}
if|if
condition|(
name|plex
operator|->
name|volno
operator|>=
literal|0
condition|)
block|{
comment|/* we have a volume */
name|vol
operator|=
operator|&
name|VOL
index|[
name|plex
operator|->
name|volno
index|]
expr_stmt|;
name|snprintf
argument_list|(
name|s
argument_list|,
name|configend
operator|-
name|s
argument_list|,
literal|"vol %s "
argument_list|,
name|vol
operator|->
name|name
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
name|s
operator|++
expr_stmt|;
comment|/* find the end */
if|if
condition|(
operator|(
name|vol
operator|->
name|preferred_plex
operator|>=
literal|0
operator|)
comment|/* has a preferred plex */
operator|&&
name|vol
operator|->
name|plex
index|[
name|vol
operator|->
name|preferred_plex
index|]
operator|==
name|i
condition|)
comment|/* and it's us */
name|snprintf
argument_list|(
name|s
argument_list|,
name|configend
operator|-
name|s
argument_list|,
literal|"preferred "
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
name|s
operator|++
expr_stmt|;
comment|/* find the end */
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|plex
operator|->
name|subdisks
condition|;
name|j
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|s
argument_list|,
name|configend
operator|-
name|s
argument_list|,
literal|" sd %s"
argument_list|,
name|vinum_conf
operator|.
name|sd
index|[
name|plex
operator|->
name|sdnos
index|[
name|j
index|]
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|sappend
argument_list|(
literal|"\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* And finally the subdisk configuration */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vinum_conf
operator|.
name|subdisks_allocated
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|sd
modifier|*
name|sd
decl_stmt|;
name|char
modifier|*
name|drivename
decl_stmt|;
name|sd
operator|=
operator|&
name|SD
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|sd
operator|->
name|state
operator|!=
name|sd_referenced
operator|)
operator|&&
operator|(
name|sd
operator|->
name|state
operator|!=
name|sd_unallocated
operator|)
operator|&&
operator|(
name|sd
operator|->
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|)
condition|)
block|{
comment|/* paranoia */
name|drivename
operator|=
name|vinum_conf
operator|.
name|drive
index|[
name|sd
operator|->
name|driveno
index|]
operator|.
name|label
operator|.
name|name
expr_stmt|;
comment|/* 	     * XXX We've seen cases of dead subdisks 	     * which don't have a drive.  If we let them 	     * through here, the drive name is null, so 	     * they get the drive named 'plex'. 	     * 	     * This is a breakage limiter, not a fix. 	     */
if|if
condition|(
name|drivename
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|drivename
operator|=
literal|"*invalid*"
expr_stmt|;
name|snprintf
argument_list|(
name|s
argument_list|,
name|configend
operator|-
name|s
argument_list|,
literal|"sd name %s drive %s len %llus driveoffset %llus state %s"
argument_list|,
name|sd
operator|->
name|name
argument_list|,
name|drivename
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|sd
operator|->
name|sectors
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|sd
operator|->
name|driveoffset
argument_list|,
name|sd_state
argument_list|(
name|sd
operator|->
name|state
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
name|s
operator|++
expr_stmt|;
comment|/* find the end */
if|if
condition|(
name|sd
operator|->
name|plexno
operator|>=
literal|0
condition|)
name|snprintf
argument_list|(
name|s
argument_list|,
name|configend
operator|-
name|s
argument_list|,
literal|" plex %s plexoffset %llds"
argument_list|,
name|vinum_conf
operator|.
name|plex
index|[
name|sd
operator|->
name|plexno
index|]
operator|.
name|name
argument_list|,
operator|(
name|long
name|long
operator|)
name|sd
operator|->
name|plexoffset
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|s
argument_list|,
name|configend
operator|-
name|s
argument_list|,
literal|" detached"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
name|s
operator|++
expr_stmt|;
comment|/* find the end */
if|if
condition|(
name|sd
operator|->
name|flags
operator|&
name|VF_RETRYERRORS
condition|)
block|{
name|snprintf
argument_list|(
name|s
argument_list|,
name|configend
operator|-
name|s
argument_list|,
literal|" retryerrors"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
name|s
operator|++
expr_stmt|;
comment|/* find the end */
block|}
name|snprintf
argument_list|(
name|s
argument_list|,
name|configend
operator|-
name|s
argument_list|,
literal|" \n"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
name|s
operator|++
expr_stmt|;
comment|/* find the end */
block|}
block|}
if|if
condition|(
name|s
operator|>
operator|&
name|config
index|[
name|len
operator|-
literal|2
index|]
condition|)
name|panic
argument_list|(
literal|"vinum: configuration data overflow"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * issue a save config request to the dæmon.  The actual work  * is done in process context by daemon_save_config.  */
end_comment

begin_function
name|void
name|save_config
parameter_list|(
name|void
parameter_list|)
block|{
name|queue_daemon_request
argument_list|(
name|daemonrq_saveconfig
argument_list|,
operator|(
expr|union
name|daemoninfo
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write the configuration to all vinum slices.  This  * is performed by the daemon only.  */
end_comment

begin_function
name|void
name|daemon_save_config
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|written_config
decl_stmt|;
comment|/* set when we first write the config to disk */
name|int
name|driveno
decl_stmt|;
name|struct
name|drive
modifier|*
name|drive
decl_stmt|;
comment|/* point to current drive info */
name|struct
name|vinum_hdr
modifier|*
name|vhdr
decl_stmt|;
comment|/* and as header */
name|char
modifier|*
name|config
decl_stmt|;
comment|/* point to config data */
comment|/* don't save the configuration while we're still working on it */
if|if
condition|(
name|vinum_conf
operator|.
name|flags
operator|&
name|VF_CONFIGURING
condition|)
return|return;
name|written_config
operator|=
literal|0
expr_stmt|;
comment|/* no config written yet */
comment|/* Build a volume header */
name|vhdr
operator|=
operator|(
expr|struct
name|vinum_hdr
operator|*
operator|)
name|Malloc
argument_list|(
name|VINUMHEADERLEN
argument_list|)
expr_stmt|;
comment|/* get space for the config data */
name|CHECKALLOC
argument_list|(
name|vhdr
argument_list|,
literal|"Can't allocate config data"
argument_list|)
expr_stmt|;
name|vhdr
operator|->
name|magic
operator|=
name|VINUM_MAGIC
expr_stmt|;
comment|/* magic number */
name|vhdr
operator|->
name|config_length
operator|=
name|MAXCONFIG
expr_stmt|;
comment|/* length of following config info */
name|config
operator|=
name|Malloc
argument_list|(
name|MAXCONFIG
argument_list|)
expr_stmt|;
comment|/* get space for the config data */
name|CHECKALLOC
argument_list|(
name|config
argument_list|,
literal|"Can't allocate config data"
argument_list|)
expr_stmt|;
name|format_config
argument_list|(
name|config
argument_list|,
name|MAXCONFIG
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* no errors yet */
for|for
control|(
name|driveno
operator|=
literal|0
init|;
name|driveno
operator|<
name|vinum_conf
operator|.
name|drives_allocated
condition|;
name|driveno
operator|++
control|)
block|{
name|drive
operator|=
operator|&
name|vinum_conf
operator|.
name|drive
index|[
name|driveno
index|]
expr_stmt|;
comment|/* point to drive */
if|if
condition|(
name|drive
operator|->
name|state
operator|>
name|drive_referenced
condition|)
block|{
name|LOCKDRIVE
argument_list|(
name|drive
argument_list|)
expr_stmt|;
comment|/* don't let it change */
comment|/* 	     * First, do some drive consistency checks.  Some 	     * of these are kludges, others require a process 	     * context and couldn't be done before. 	     */
if|if
condition|(
operator|(
name|drive
operator|->
name|devicename
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
operator|||
operator|(
name|drive
operator|->
name|label
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
name|unlockdrive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
name|free_drive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
comment|/* get rid of it */
break|break;
block|}
if|if
condition|(
operator|(
operator|(
name|drive
operator|->
name|flags
operator|&
name|VF_OPEN
operator|)
operator|==
literal|0
operator|)
comment|/* drive not open */
operator|&&
operator|(
name|drive
operator|->
name|state
operator|>
name|drive_down
operator|)
condition|)
block|{
comment|/* and it thinks it's not down */
name|unlockdrive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
name|set_drive_state
argument_list|(
name|driveno
argument_list|,
name|drive_down
argument_list|,
name|setstate_force
argument_list|)
expr_stmt|;
comment|/* tell it what's what */
continue|continue;
block|}
if|if
condition|(
operator|(
name|drive
operator|->
name|state
operator|==
name|drive_down
operator|)
comment|/* it's down */
operator|&&
operator|(
name|drive
operator|->
name|flags
operator|&
name|VF_OPEN
operator|)
condition|)
block|{
comment|/* but open, */
name|unlockdrive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
name|close_drive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
comment|/* close it */
block|}
elseif|else
if|if
condition|(
name|drive
operator|->
name|state
operator|>
name|drive_down
condition|)
block|{
name|microtime
argument_list|(
operator|&
name|drive
operator|->
name|label
operator|.
name|last_update
argument_list|)
expr_stmt|;
comment|/* time of last update is now */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|drive
operator|->
name|label
argument_list|,
comment|/* and the label info from the drive structure */
operator|(
name|char
operator|*
operator|)
operator|&
name|vhdr
operator|->
name|label
argument_list|,
sizeof|sizeof
argument_list|(
name|vhdr
operator|->
name|label
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|drive
operator|->
name|state
operator|!=
name|drive_unallocated
operator|)
operator|&&
operator|(
name|drive
operator|->
name|state
operator|!=
name|drive_referenced
operator|)
condition|)
block|{
comment|/* and it's a real drive */
name|error
operator|=
name|write_drive
argument_list|(
name|drive
argument_list|,
operator|(
name|char
operator|*
operator|)
name|vhdr
argument_list|,
name|VINUMHEADERLEN
argument_list|,
name|VINUM_LABEL_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
comment|/* first config copy */
name|error
operator|=
name|write_drive
argument_list|(
name|drive
argument_list|,
name|config
argument_list|,
name|MAXCONFIG
argument_list|,
name|VINUM_CONFIG_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|write_drive
argument_list|(
name|drive
argument_list|,
comment|/* second copy */
name|config
argument_list|,
name|MAXCONFIG
argument_list|,
name|VINUM_CONFIG_OFFSET
operator|+
name|MAXCONFIG
argument_list|)
expr_stmt|;
name|unlockdrive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"vinum: Can't write config to %s, error %d\n"
argument_list|,
name|drive
operator|->
name|devicename
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|set_drive_state
argument_list|(
name|drive
operator|->
name|driveno
argument_list|,
name|drive_down
argument_list|,
name|setstate_force
argument_list|)
expr_stmt|;
block|}
else|else
name|written_config
operator|=
literal|1
expr_stmt|;
comment|/* we've written it on at least one drive */
block|}
block|}
else|else
comment|/* not worth looking at, */
name|unlockdrive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
comment|/* just unlock it again */
block|}
block|}
name|Free
argument_list|(
name|vhdr
argument_list|)
expr_stmt|;
name|Free
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Search disks on system for vinum slices and add  * them to the configuuration if they're not  * there already.  devicename is a blank-separate  * list of device names.  If not provided, use  * sysctl to get a list of all disks on the  * system.  *  * Return an error indication.  */
end_comment

begin_function
name|int
name|vinum_scandisk
parameter_list|(
name|char
modifier|*
name|devicename
parameter_list|)
block|{
name|struct
name|drive
modifier|*
specifier|volatile
name|drive
decl_stmt|;
specifier|volatile
name|int
name|driveno
decl_stmt|;
name|int
name|firstdrive
decl_stmt|;
comment|/* first drive in this list */
specifier|volatile
name|int
name|gooddrives
decl_stmt|;
comment|/* number of usable drives found */
name|int
name|firsttime
decl_stmt|;
comment|/* set if we have never configured before */
name|int
name|error
decl_stmt|;
name|char
modifier|*
name|config_text
decl_stmt|;
comment|/* read the config info from disk into here */
name|char
modifier|*
specifier|volatile
name|cptr
decl_stmt|;
comment|/* pointer into config information */
name|char
modifier|*
name|eptr
decl_stmt|;
comment|/* end pointer into config information */
name|char
modifier|*
name|config_line
decl_stmt|;
comment|/* copy the config line to */
specifier|volatile
name|int
name|status
decl_stmt|;
name|int
modifier|*
name|drivelist
decl_stmt|;
comment|/* list of drive indices */
name|char
modifier|*
name|partname
decl_stmt|;
comment|/* for creating partition names */
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* pointer to start of disk name */
name|char
modifier|*
name|ep
decl_stmt|;
comment|/* and to first char after name */
name|char
modifier|*
name|np
decl_stmt|;
comment|/* name pointer in naem we build */
name|size_t
name|alloclen
decl_stmt|;
name|int
name|malloced
decl_stmt|;
name|int
name|partnamelen
decl_stmt|;
comment|/* length of partition name */
name|int
name|drives
decl_stmt|;
name|int
name|goodpart
decl_stmt|;
comment|/* good vinum drives on this disk */
name|malloced
operator|=
literal|0
expr_stmt|;
comment|/* devicename not malloced */
if|if
condition|(
name|devicename
operator|==
name|NULL
condition|)
block|{
comment|/* no devices specified, */
comment|/* get a list of all disks in the system */
comment|/* Get size of disk list */
name|error
operator|=
name|kernel_sysctlbyname
argument_list|(
operator|&
name|thread0
argument_list|,
literal|"kern.disks"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|alloclen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"vinum: can't get disk list: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|devicename
operator|=
name|Malloc
argument_list|(
name|alloclen
argument_list|)
expr_stmt|;
if|if
condition|(
name|devicename
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"vinum: can't allocate memory for drive list"
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
else|else
name|malloced
operator|=
literal|1
expr_stmt|;
comment|/* Now get the list of disks */
name|kernel_sysctlbyname
argument_list|(
operator|&
name|thread0
argument_list|,
literal|"kern.disks"
argument_list|,
name|devicename
argument_list|,
operator|&
name|alloclen
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|status
operator|=
literal|0
expr_stmt|;
comment|/* success indication */
name|vinum_conf
operator|.
name|flags
operator||=
name|VF_READING_CONFIG
expr_stmt|;
comment|/* reading config from disk */
name|partname
operator|=
name|Malloc
argument_list|(
name|MAXPATHLEN
argument_list|)
expr_stmt|;
comment|/* extract name of disk here */
if|if
condition|(
name|partname
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"vinum_scandisk: can't allocate memory for drive name"
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|gooddrives
operator|=
literal|0
expr_stmt|;
comment|/* number of usable drives found */
name|firstdrive
operator|=
name|vinum_conf
operator|.
name|drives_used
expr_stmt|;
comment|/* the first drive */
name|firsttime
operator|=
name|vinum_conf
operator|.
name|drives_used
operator|==
literal|0
expr_stmt|;
comment|/* are we a virgin? */
comment|/* allocate a drive pointer list */
name|drives
operator|=
literal|256
expr_stmt|;
comment|/* should be enough for most cases */
name|drivelist
operator|=
operator|(
name|int
operator|*
operator|)
name|Malloc
argument_list|(
name|drives
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|CHECKALLOC
argument_list|(
name|drivelist
argument_list|,
literal|"Can't allocate memory"
argument_list|)
expr_stmt|;
name|error
operator|=
name|lock_config
argument_list|()
expr_stmt|;
comment|/* make sure we're alone here */
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|error
operator|=
name|setjmp
argument_list|(
name|command_fail
argument_list|)
expr_stmt|;
comment|/* come back here on error */
if|if
condition|(
name|error
condition|)
comment|/* longjmped out */
return|return
name|error
return|;
comment|/* Open all drives and find which was modified most recently */
for|for
control|(
name|cp
operator|=
name|devicename
init|;
operator|*
name|cp
condition|;
name|cp
operator|=
name|ep
control|)
block|{
name|char
name|part
decl_stmt|;
comment|/* UNIX partition */
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
name|int
name|slice
decl_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|*
name|cp
operator|==
literal|' '
condition|)
name|cp
operator|++
expr_stmt|;
comment|/* find start of name */
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
comment|/* done, */
break|break;
name|ep
operator|=
name|cp
expr_stmt|;
while|while
condition|(
operator|*
name|ep
operator|&&
operator|(
operator|*
name|ep
operator|!=
literal|' '
operator|)
condition|)
comment|/* find end of name */
name|ep
operator|++
expr_stmt|;
name|np
operator|=
name|partname
expr_stmt|;
comment|/* start building up a name here */
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'/'
condition|)
block|{
comment|/* name doesn't start with /, */
name|strcpy
argument_list|(
name|np
argument_list|,
literal|"/dev/"
argument_list|)
expr_stmt|;
comment|/* assume /dev */
name|np
operator|+=
name|strlen
argument_list|(
literal|"/dev/"
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
name|ep
operator|-
name|cp
argument_list|)
expr_stmt|;
comment|/* put in name */
name|np
operator|+=
name|ep
operator|-
name|cp
expr_stmt|;
comment|/* and point past */
name|goodpart
operator|=
literal|0
expr_stmt|;
comment|/* no partitions on this disk yet */
name|partnamelen
operator|=
name|MAXPATHLEN
operator|+
name|np
operator|-
name|partname
expr_stmt|;
comment|/* remaining length in partition name */
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
comment|/* first try the partition table */
for|for
control|(
name|slice
operator|=
literal|1
init|;
name|slice
operator|<
literal|5
condition|;
name|slice
operator|++
control|)
for|for
control|(
name|part
operator|=
literal|'a'
init|;
name|part
operator|<
literal|'i'
condition|;
name|part
operator|++
control|)
block|{
if|if
condition|(
name|part
operator|!=
literal|'c'
condition|)
block|{
comment|/* don't do the c partition */
name|snprintf
argument_list|(
name|np
argument_list|,
name|partnamelen
argument_list|,
literal|"s%d%c"
argument_list|,
name|slice
argument_list|,
name|part
argument_list|)
expr_stmt|;
name|drive
operator|=
name|check_drive
argument_list|(
name|partname
argument_list|)
expr_stmt|;
comment|/* try to open it */
if|if
condition|(
name|drive
condition|)
block|{
comment|/* got something, */
if|if
condition|(
name|drive
operator|->
name|flags
operator|&
name|VF_CONFIGURED
condition|)
comment|/* already read this config, */
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"vinum: already read config from %s\n"
argument_list|,
comment|/* say so */
name|drive
operator|->
name|label
operator|.
name|name
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|gooddrives
operator|==
name|drives
condition|)
comment|/* ran out of entries */
name|EXPAND
argument_list|(
name|drivelist
argument_list|,
name|int
argument_list|,
name|drives
argument_list|,
name|drives
argument_list|)
expr_stmt|;
comment|/* double the size */
name|drivelist
index|[
name|gooddrives
index|]
operator|=
name|drive
operator|->
name|driveno
expr_stmt|;
comment|/* keep the drive index */
name|drive
operator|->
name|flags
operator|&=
operator|~
name|VF_NEWBORN
expr_stmt|;
comment|/* which is no longer newly born */
name|gooddrives
operator|++
expr_stmt|;
name|goodpart
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
endif|#
directive|endif
comment|/* 	 * If the machine doesn't have a BIOS 	 * partition table, try normal devices. 	 */
if|if
condition|(
name|goodpart
operator|==
literal|0
condition|)
block|{
comment|/* didn't find anything, */
for|for
control|(
name|part
operator|=
literal|'a'
init|;
name|part
operator|<
literal|'i'
condition|;
name|part
operator|++
control|)
comment|/* try the compatibility partition */
if|if
condition|(
name|part
operator|!=
literal|'c'
condition|)
block|{
comment|/* don't do the c partition */
name|snprintf
argument_list|(
name|np
argument_list|,
name|partnamelen
argument_list|,
literal|"%c"
argument_list|,
name|part
argument_list|)
expr_stmt|;
name|drive
operator|=
name|check_drive
argument_list|(
name|partname
argument_list|)
expr_stmt|;
comment|/* try to open it */
if|if
condition|(
name|drive
condition|)
block|{
comment|/* got something, */
if|if
condition|(
name|drive
operator|->
name|flags
operator|&
name|VF_CONFIGURED
condition|)
comment|/* already read this config, */
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"vinum: already read config from %s\n"
argument_list|,
comment|/* say so */
name|drive
operator|->
name|label
operator|.
name|name
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|gooddrives
operator|==
name|drives
condition|)
comment|/* ran out of entries */
name|EXPAND
argument_list|(
name|drivelist
argument_list|,
name|int
argument_list|,
name|drives
argument_list|,
name|drives
argument_list|)
expr_stmt|;
comment|/* double the size */
name|drivelist
index|[
name|gooddrives
index|]
operator|=
name|drive
operator|->
name|driveno
expr_stmt|;
comment|/* keep the drive index */
name|drive
operator|->
name|flags
operator|&=
operator|~
name|VF_NEWBORN
expr_stmt|;
comment|/* which is no longer newly born */
name|gooddrives
operator|++
expr_stmt|;
name|goodpart
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|Free
argument_list|(
name|partname
argument_list|)
expr_stmt|;
if|if
condition|(
name|gooddrives
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|firsttime
condition|)
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"vinum: no drives found\n"
argument_list|)
expr_stmt|;
else|else
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"vinum: no additional drives found\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|malloced
condition|)
name|Free
argument_list|(
name|devicename
argument_list|)
expr_stmt|;
name|unlock_config
argument_list|()
expr_stmt|;
return|return
name|ENOENT
return|;
block|}
comment|/*      * We now have at least one drive open.  Sort      * them in order of config time and merge the      * config info with what we have already.      */
name|qsort
argument_list|(
name|drivelist
argument_list|,
name|gooddrives
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|drivecmp
argument_list|)
expr_stmt|;
name|config_text
operator|=
operator|(
name|char
operator|*
operator|)
name|Malloc
argument_list|(
name|MAXCONFIG
operator|*
literal|2
argument_list|)
expr_stmt|;
comment|/* allocate buffers */
name|CHECKALLOC
argument_list|(
name|config_text
argument_list|,
literal|"Can't allocate memory"
argument_list|)
expr_stmt|;
name|config_line
operator|=
operator|(
name|char
operator|*
operator|)
name|Malloc
argument_list|(
name|MAXCONFIGLINE
operator|*
literal|2
argument_list|)
expr_stmt|;
comment|/* allocate buffers */
name|CHECKALLOC
argument_list|(
name|config_line
argument_list|,
literal|"Can't allocate memory"
argument_list|)
expr_stmt|;
for|for
control|(
name|driveno
operator|=
literal|0
init|;
name|driveno
operator|<
name|gooddrives
condition|;
name|driveno
operator|++
control|)
block|{
comment|/* now include the config */
name|drive
operator|=
operator|&
name|DRIVE
index|[
name|drivelist
index|[
name|driveno
index|]
index|]
expr_stmt|;
comment|/* point to the drive */
if|if
condition|(
name|firsttime
operator|&&
operator|(
name|driveno
operator|==
literal|0
operator|)
condition|)
comment|/* we've never configured before, */
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"vinum: reading configuration from %s\n"
argument_list|,
name|drive
operator|->
name|devicename
argument_list|)
expr_stmt|;
else|else
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"vinum: updating configuration from %s\n"
argument_list|,
name|drive
operator|->
name|devicename
argument_list|)
expr_stmt|;
if|if
condition|(
name|drive
operator|->
name|state
operator|==
name|drive_up
condition|)
comment|/* Read in both copies of the configuration information */
name|error
operator|=
name|read_drive
argument_list|(
name|drive
argument_list|,
name|config_text
argument_list|,
name|MAXCONFIG
operator|*
literal|2
argument_list|,
name|VINUM_CONFIG_OFFSET
argument_list|)
expr_stmt|;
else|else
block|{
name|error
operator|=
name|EIO
expr_stmt|;
name|printf
argument_list|(
literal|"vinum_scandisk: %s is %s\n"
argument_list|,
name|drive
operator|->
name|devicename
argument_list|,
name|drive_state
argument_list|(
name|drive
operator|->
name|state
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"vinum: Can't read device %s, error %d\n"
argument_list|,
name|drive
operator|->
name|devicename
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|free_drive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
comment|/* give it back */
name|status
operator|=
name|error
expr_stmt|;
block|}
comment|/* 	 * At this point, check that the two copies 	 * are the same, and do something useful if 	 * not.  In particular, consider which is 	 * newer, and what this means for the 	 * integrity of the data on the drive. 	 */
else|else
block|{
name|vinum_conf
operator|.
name|drives_used
operator|++
expr_stmt|;
comment|/* another drive in use */
comment|/* Parse the configuration, and add it to the global configuration */
for|for
control|(
name|cptr
operator|=
name|config_text
init|;
operator|*
name|cptr
operator|!=
literal|'\0'
condition|;
control|)
block|{
comment|/* love this style(9) */
specifier|volatile
name|int
name|parse_status
decl_stmt|;
comment|/* return value from parse_config */
for|for
control|(
name|eptr
operator|=
name|config_line
init|;
operator|(
operator|*
name|cptr
operator|!=
literal|'\n'
operator|)
operator|&&
operator|(
operator|*
name|cptr
operator|!=
literal|'\0'
operator|)
condition|;
control|)
comment|/* until the end of the line */
operator|*
name|eptr
operator|++
operator|=
operator|*
name|cptr
operator|++
expr_stmt|;
operator|*
name|eptr
operator|=
literal|'\0'
expr_stmt|;
comment|/* and delimit */
if|if
condition|(
name|setjmp
argument_list|(
name|command_fail
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* come back here on error and continue */
name|parse_status
operator|=
name|parse_config
argument_list|(
name|config_line
argument_list|,
operator|&
name|keyword_set
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* parse the config line */
comment|/* 		     * parse_config recognizes referenced 		     * drives and builds a drive entry for 		     * them.  This may expand the drive 		     * table, thus invalidating the pointer. 		     */
name|drive
operator|=
operator|&
name|DRIVE
index|[
name|drivelist
index|[
name|driveno
index|]
index|]
expr_stmt|;
comment|/* point to the drive */
if|if
condition|(
name|parse_status
operator|<
literal|0
condition|)
block|{
comment|/* error in config */
comment|/* 			   * This config should have been parsed 			   * in user space.  If we run into 			   * problems here, something serious is 			   * afoot.  Complain and let the user 			   * snarf the config to see what's 			   * wrong. 			 */
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"vinum: Config error on %s, aborting integration\n"
argument_list|,
name|drive
operator|->
name|devicename
argument_list|)
expr_stmt|;
name|free_drive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
comment|/* give it back */
name|status
operator|=
name|EINVAL
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|*
name|cptr
operator|==
literal|'\n'
condition|)
name|cptr
operator|++
expr_stmt|;
comment|/* skip to next line */
block|}
block|}
name|drive
operator|->
name|flags
operator||=
name|VF_CONFIGURED
expr_stmt|;
comment|/* this drive's configuration is complete */
block|}
name|Free
argument_list|(
name|config_line
argument_list|)
expr_stmt|;
name|Free
argument_list|(
name|config_text
argument_list|)
expr_stmt|;
name|Free
argument_list|(
name|drivelist
argument_list|)
expr_stmt|;
name|vinum_conf
operator|.
name|flags
operator|&=
operator|~
name|VF_READING_CONFIG
expr_stmt|;
comment|/* no longer reading from disk */
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"vinum: couldn't read configuration"
argument_list|)
expr_stmt|;
else|else
name|updateconfig
argument_list|(
name|VF_READING_CONFIG
argument_list|)
expr_stmt|;
comment|/* update from disk config */
if|if
condition|(
name|malloced
condition|)
name|Free
argument_list|(
name|devicename
argument_list|)
expr_stmt|;
name|unlock_config
argument_list|()
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/*  * Compare the modification dates of the drives, for qsort.  * Return 1 if a< b, 0 if a == b, 01 if a> b: in other  * words, sort backwards.  */
end_comment

begin_function
name|int
name|drivecmp
parameter_list|(
specifier|const
name|void
modifier|*
name|va
parameter_list|,
specifier|const
name|void
modifier|*
name|vb
parameter_list|)
block|{
specifier|const
name|struct
name|drive
modifier|*
name|a
init|=
operator|&
name|DRIVE
index|[
operator|*
operator|(
specifier|const
name|int
operator|*
operator|)
name|va
index|]
decl_stmt|;
specifier|const
name|struct
name|drive
modifier|*
name|b
init|=
operator|&
name|DRIVE
index|[
operator|*
operator|(
specifier|const
name|int
operator|*
operator|)
name|vb
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|a
operator|->
name|label
operator|.
name|last_update
operator|.
name|tv_sec
operator|==
name|b
operator|->
name|label
operator|.
name|last_update
operator|.
name|tv_sec
operator|)
operator|&&
operator|(
name|a
operator|->
name|label
operator|.
name|last_update
operator|.
name|tv_usec
operator|==
name|b
operator|->
name|label
operator|.
name|last_update
operator|.
name|tv_usec
operator|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
operator|(
name|a
operator|->
name|label
operator|.
name|last_update
operator|.
name|tv_sec
operator|>
name|b
operator|->
name|label
operator|.
name|last_update
operator|.
name|tv_sec
operator|)
operator|||
operator|(
operator|(
name|a
operator|->
name|label
operator|.
name|last_update
operator|.
name|tv_sec
operator|==
name|b
operator|->
name|label
operator|.
name|last_update
operator|.
name|tv_sec
operator|)
operator|&&
operator|(
name|a
operator|->
name|label
operator|.
name|last_update
operator|.
name|tv_usec
operator|>
name|b
operator|->
name|label
operator|.
name|last_update
operator|.
name|tv_usec
operator|)
operator|)
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Local Variables: */
end_comment

begin_comment
comment|/* fill-column: 50 */
end_comment

begin_comment
comment|/* End: */
end_comment

end_unit

