begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1997, 1998  *	Nan Yang Computer Services Limited.  All rights reserved.  *  *  This software is distributed under the so-called ``Berkeley  *  License'':  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Nan Yang Computer  *      Services Limited.  * 4. Neither the name of the Company nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * This software is provided ``as is'', and any express or implied  * warranties, including, but not limited to, the implied warranties of  * merchantability and fitness for a particular purpose are disclaimed.  * In no event shall the company or contributors be liable for any  * direct, indirect, incidental, special, exemplary, or consequential  * damages (including, but not limited to, procurement of substitute  * goods or services; loss of use, data, or profits; or business  * interruption) however caused and on any theory of liability, whether  * in contract, strict liability, or tort (including negligence or  * otherwise) arising in any way out of the use of this software, even if  * advised of the possibility of such damage.  *  * $Id: vinumio.c,v 1.32 2001/05/23 23:03:45 grog Exp grog $  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<dev/vinum/vinumhdr.h>
end_include

begin_include
include|#
directive|include
file|<dev/vinum/request.h>
end_include

begin_function_decl
specifier|static
name|char
modifier|*
name|sappend
parameter_list|(
name|char
modifier|*
name|txt
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|drivecmp
parameter_list|(
specifier|const
name|void
modifier|*
name|va
parameter_list|,
specifier|const
name|void
modifier|*
name|vb
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Open the device associated with the drive, and set drive's vp.  * Return an error number  */
end_comment

begin_function
name|int
name|open_drive
parameter_list|(
name|struct
name|drive
modifier|*
name|drive
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
name|int
name|devmajor
decl_stmt|;
comment|/* major devs for disk device */
name|int
name|devminor
decl_stmt|;
comment|/* minor devs for disk device */
name|int
name|unit
decl_stmt|;
name|char
modifier|*
name|dname
decl_stmt|;
name|struct
name|cdevsw
modifier|*
name|dsw
decl_stmt|;
comment|/* pointer to cdevsw entry */
if|if
condition|(
name|bcmp
argument_list|(
name|drive
operator|->
name|devicename
argument_list|,
literal|"/dev/"
argument_list|,
literal|5
argument_list|)
condition|)
comment|/* device name doesn't start with /dev */
return|return
name|ENOENT
return|;
comment|/* give up */
if|if
condition|(
name|drive
operator|->
name|flags
operator|&
name|VF_OPEN
condition|)
comment|/* open already, */
return|return
name|EBUSY
return|;
comment|/* don't do it again */
comment|/*      * Yes, Bruce, I know this is horrible, but we      * don't have a root file system when we first      * try to do this.  If you can come up with a      * better solution, I'd really like it.  I'm      * just putting it in now to add ammuntion to      * moving the system to devfs.      */
name|dname
operator|=
operator|&
name|drive
operator|->
name|devicename
index|[
literal|5
index|]
expr_stmt|;
name|drive
operator|->
name|dev
operator|=
name|NULL
expr_stmt|;
comment|/* no device yet */
comment|/* Find the device */
if|if
condition|(
name|bcmp
argument_list|(
name|dname
argument_list|,
literal|"ad"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
comment|/* IDE disk */
name|devmajor
operator|=
literal|116
expr_stmt|;
elseif|else
if|if
condition|(
name|bcmp
argument_list|(
name|dname
argument_list|,
literal|"wd"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
comment|/* IDE disk */
name|devmajor
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|bcmp
argument_list|(
name|dname
argument_list|,
literal|"da"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
name|devmajor
operator|=
literal|13
expr_stmt|;
elseif|else
if|if
condition|(
name|bcmp
argument_list|(
name|dname
argument_list|,
literal|"vn"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
name|devmajor
operator|=
literal|43
expr_stmt|;
elseif|else
if|if
condition|(
name|bcmp
argument_list|(
name|dname
argument_list|,
literal|"md"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
name|devmajor
operator|=
literal|95
expr_stmt|;
elseif|else
if|if
condition|(
name|bcmp
argument_list|(
name|dname
argument_list|,
literal|"ar"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
name|devmajor
operator|=
literal|157
expr_stmt|;
elseif|else
if|if
condition|(
name|bcmp
argument_list|(
name|dname
argument_list|,
literal|"amrd"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|devmajor
operator|=
literal|133
expr_stmt|;
name|dname
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bcmp
argument_list|(
name|dname
argument_list|,
literal|"mlxd"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|devmajor
operator|=
literal|131
expr_stmt|;
name|dname
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bcmp
argument_list|(
name|dname
argument_list|,
literal|"idad"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|devmajor
operator|=
literal|109
expr_stmt|;
name|dname
operator|+=
literal|2
expr_stmt|;
block|}
else|else
return|return
name|ENODEV
return|;
name|dname
operator|+=
literal|2
expr_stmt|;
comment|/* point past */
comment|/*      * Found the device.  We can expect one of      * two formats for the rest: a unit number,      * then either a partition letter for the      * compatiblity partition (e.g. h) or a      * slice ID and partition (e.g. s2e).      * Create a minor number for each of them.      */
name|unit
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|dname
operator|>=
literal|'0'
operator|)
comment|/* unit number */
operator|&&
operator|(
operator|*
name|dname
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|unit
operator|=
name|unit
operator|*
literal|10
operator|+
operator|*
name|dname
operator|-
literal|'0'
expr_stmt|;
name|dname
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|dname
operator|==
literal|'s'
condition|)
block|{
comment|/* slice */
if|if
condition|(
operator|(
operator|(
name|dname
index|[
literal|1
index|]
operator|<
literal|'1'
operator|)
operator|||
operator|(
name|dname
index|[
literal|1
index|]
operator|>
literal|'4'
operator|)
operator|)
comment|/* invalid slice */
operator|||
operator|(
operator|(
name|dname
index|[
literal|2
index|]
operator|<
literal|'a'
operator|)
operator|||
operator|(
name|dname
index|[
literal|2
index|]
operator|>
literal|'h'
operator|)
operator|)
condition|)
comment|/* or invalid partition */
return|return
name|ENODEV
return|;
name|devminor
operator|=
operator|(
operator|(
name|unit
operator|&
literal|31
operator|)
operator|<<
literal|3
operator|)
comment|/* unit */
operator|+
operator|(
name|dname
index|[
literal|2
index|]
operator|-
literal|'a'
operator|)
comment|/* partition */
operator|+
operator|(
operator|(
name|dname
index|[
literal|1
index|]
operator|-
literal|'0'
operator|+
literal|1
operator|)
operator|<<
literal|16
operator|)
comment|/* slice */
operator|+
operator|(
operator|(
name|unit
operator|&
operator|~
literal|31
operator|)
operator|<<
literal|16
operator|)
expr_stmt|;
comment|/* high-order unit bits */
block|}
else|else
block|{
comment|/* compatibility partition */
if|if
condition|(
operator|(
operator|*
name|dname
operator|<
literal|'a'
operator|)
operator|||
operator|(
operator|*
name|dname
operator|>
literal|'h'
operator|)
condition|)
comment|/* or invalid partition */
return|return
name|ENODEV
return|;
name|devminor
operator|=
operator|(
operator|*
name|dname
operator|-
literal|'a'
operator|)
comment|/* partition */
operator|+
operator|(
operator|(
name|unit
operator|&
literal|31
operator|)
operator|<<
literal|3
operator|)
comment|/* unit */
operator|+
operator|(
operator|(
name|unit
operator|&
operator|~
literal|31
operator|)
operator|<<
literal|16
operator|)
expr_stmt|;
comment|/* high-order unit bits */
block|}
if|if
condition|(
operator|(
name|devminor
operator|&
literal|7
operator|)
operator|==
literal|2
condition|)
comment|/* partition c */
return|return
name|ENOTTY
return|;
comment|/* not buying that */
name|drive
operator|->
name|dev
operator|=
name|makedev
argument_list|(
name|devmajor
argument_list|,
name|devminor
argument_list|)
expr_stmt|;
comment|/* find the device */
if|if
condition|(
name|drive
operator|->
name|dev
operator|==
name|NULL
condition|)
comment|/* didn't find anything */
return|return
name|ENODEV
return|;
name|drive
operator|->
name|dev
operator|->
name|si_iosize_max
operator|=
name|DFLTPHYS
expr_stmt|;
name|dsw
operator|=
name|devsw
argument_list|(
name|drive
operator|->
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsw
operator|==
name|NULL
condition|)
name|drive
operator|->
name|lasterror
operator|=
name|ENOENT
expr_stmt|;
else|else
name|drive
operator|->
name|lasterror
operator|=
call|(
name|dsw
operator|->
name|d_open
call|)
argument_list|(
name|drive
operator|->
name|dev
argument_list|,
name|FWRITE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|drive
operator|->
name|lasterror
operator|!=
literal|0
condition|)
block|{
comment|/* failed */
name|drive
operator|->
name|state
operator|=
name|drive_down
expr_stmt|;
comment|/* just force it down */
if|if
condition|(
name|verbose
condition|)
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"vinum open_drive %s: failed with error %d\n"
argument_list|,
name|drive
operator|->
name|devicename
argument_list|,
name|drive
operator|->
name|lasterror
argument_list|)
expr_stmt|;
block|}
else|else
name|drive
operator|->
name|flags
operator||=
name|VF_OPEN
expr_stmt|;
comment|/* we're open now */
return|return
name|drive
operator|->
name|lasterror
return|;
block|}
end_function

begin_comment
comment|/*  * Set some variables in the drive struct  * in more convenient form.  Return error indication  */
end_comment

begin_function
name|int
name|set_drive_parms
parameter_list|(
name|struct
name|drive
modifier|*
name|drive
parameter_list|)
block|{
name|drive
operator|->
name|blocksize
operator|=
name|BLKDEV_IOSIZE
expr_stmt|;
comment|/* do we need this? */
name|drive
operator|->
name|secsperblock
operator|=
name|drive
operator|->
name|blocksize
comment|/* number of sectors per block */
operator|/
name|drive
operator|->
name|sectorsize
expr_stmt|;
comment|/* Now update the label part */
name|bcopy
argument_list|(
name|hostname
argument_list|,
name|drive
operator|->
name|label
operator|.
name|sysname
argument_list|,
name|VINUMHOSTNAMELEN
argument_list|)
expr_stmt|;
comment|/* put in host name */
name|getmicrotime
argument_list|(
operator|&
name|drive
operator|->
name|label
operator|.
name|date_of_birth
argument_list|)
expr_stmt|;
comment|/* and current time */
name|drive
operator|->
name|label
operator|.
name|drive_size
operator|=
name|drive
operator|->
name|mediasize
expr_stmt|;
ifdef|#
directive|ifdef
name|VINUMDEBUG
if|if
condition|(
name|debug
operator|&
name|DEBUG_BIGDRIVE
condition|)
comment|/* pretend we're 100 times as big */
name|drive
operator|->
name|label
operator|.
name|drive_size
operator|*=
literal|100
expr_stmt|;
endif|#
directive|endif
comment|/* number of sectors available for subdisks */
name|drive
operator|->
name|sectors_available
operator|=
name|drive
operator|->
name|label
operator|.
name|drive_size
operator|/
name|DEV_BSIZE
operator|-
name|DATASTART
expr_stmt|;
comment|/*      * Bug in 3.0 as of January 1998: you can open      * non-existent slices.  They have a length of 0.      */
if|if
condition|(
name|drive
operator|->
name|label
operator|.
name|drive_size
operator|<
name|MINVINUMSLICE
condition|)
block|{
comment|/* too small to worry about */
name|set_drive_state
argument_list|(
name|drive
operator|->
name|driveno
argument_list|,
name|drive_down
argument_list|,
name|setstate_force
argument_list|)
expr_stmt|;
name|drive
operator|->
name|lasterror
operator|=
name|ENOSPC
expr_stmt|;
return|return
name|ENOSPC
return|;
block|}
name|drive
operator|->
name|freelist_size
operator|=
name|INITIAL_DRIVE_FREELIST
expr_stmt|;
comment|/* initial number of entries */
name|drive
operator|->
name|freelist
operator|=
operator|(
expr|struct
name|drive_freelist
operator|*
operator|)
name|Malloc
argument_list|(
name|INITIAL_DRIVE_FREELIST
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|drive_freelist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|drive
operator|->
name|freelist
operator|==
name|NULL
condition|)
comment|/* can't malloc, dammit */
return|return
name|ENOSPC
return|;
name|drive
operator|->
name|freelist_entries
operator|=
literal|1
expr_stmt|;
comment|/* just (almost) the complete drive */
name|drive
operator|->
name|freelist
index|[
literal|0
index|]
operator|.
name|offset
operator|=
name|DATASTART
expr_stmt|;
comment|/* starts here */
name|drive
operator|->
name|freelist
index|[
literal|0
index|]
operator|.
name|sectors
operator|=
operator|(
name|drive
operator|->
name|label
operator|.
name|drive_size
operator|>>
name|DEV_BSHIFT
operator|)
operator|-
name|DATASTART
expr_stmt|;
comment|/* and it's this long */
if|if
condition|(
name|drive
operator|->
name|label
operator|.
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
comment|/* got a name */
name|set_drive_state
argument_list|(
name|drive
operator|->
name|driveno
argument_list|,
name|drive_up
argument_list|,
name|setstate_force
argument_list|)
expr_stmt|;
comment|/* our drive is accessible */
else|else
comment|/* we know about it, but that's all */
name|drive
operator|->
name|state
operator|=
name|drive_referenced
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize a drive: open the device and add device  * information  */
end_comment

begin_function
name|int
name|init_drive
parameter_list|(
name|struct
name|drive
modifier|*
name|drive
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
if|if
condition|(
name|drive
operator|->
name|devicename
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
block|{
name|drive
operator|->
name|lasterror
operator|=
name|EINVAL
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"vinum: Can't open drive without drive name\n"
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|drive
operator|->
name|lasterror
operator|=
name|open_drive
argument_list|(
name|drive
argument_list|,
name|curthread
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
comment|/* open the drive */
if|if
condition|(
name|drive
operator|->
name|lasterror
condition|)
return|return
name|drive
operator|->
name|lasterror
return|;
name|drive
operator|->
name|lasterror
operator|=
operator|(
operator|*
name|devsw
argument_list|(
name|drive
operator|->
name|dev
argument_list|)
operator|->
name|d_ioctl
operator|)
operator|(
name|drive
operator|->
name|dev
operator|,
name|DIOCGSECTORSIZE
operator|,
operator|(
name|caddr_t
operator|)
operator|&
name|drive
operator|->
name|sectorsize
operator|,
name|FREAD
operator|,
name|curthread
operator|)
expr_stmt|;
if|if
condition|(
name|drive
operator|->
name|lasterror
operator|==
literal|0
condition|)
name|drive
operator|->
name|lasterror
operator|=
operator|(
operator|*
name|devsw
argument_list|(
name|drive
operator|->
name|dev
argument_list|)
operator|->
name|d_ioctl
operator|)
operator|(
name|drive
operator|->
name|dev
operator|,
name|DIOCGMEDIASIZE
operator|,
operator|(
name|caddr_t
operator|)
operator|&
name|drive
operator|->
name|mediasize
operator|,
name|FREAD
operator|,
name|curthread
operator|)
expr_stmt|;
if|if
condition|(
name|drive
operator|->
name|lasterror
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"vinum open_drive %s: Can't get partition information, drive->lasterror %d\n"
argument_list|,
name|drive
operator|->
name|devicename
argument_list|,
name|drive
operator|->
name|lasterror
argument_list|)
expr_stmt|;
name|close_drive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
return|return
name|drive
operator|->
name|lasterror
return|;
block|}
if|#
directive|if
literal|0
comment|/*      * XXX: this check is bogus and needs to be rewitten, we cannot guarantee      * XXX: that there will be a label with a typefield on all platforms.      */
block|if (drive->partinfo.part->p_fstype != FS_VINUM) {
comment|/* not Vinum */
block|drive->lasterror = EFTYPE; 	if (verbose) 	    log(LOG_WARNING, 		"vinum open_drive %s: Wrong partition type for vinum\n", 		drive->devicename); 	close_drive(drive); 	return EFTYPE;     }
endif|#
directive|endif
return|return
name|set_drive_parms
argument_list|(
name|drive
argument_list|)
return|;
comment|/* set various odds and ends */
block|}
end_function

begin_comment
comment|/* Close a drive if it's open. */
end_comment

begin_function
name|void
name|close_drive
parameter_list|(
name|struct
name|drive
modifier|*
name|drive
parameter_list|)
block|{
name|LOCKDRIVE
argument_list|(
name|drive
argument_list|)
expr_stmt|;
comment|/* keep the daemon out */
if|if
condition|(
name|drive
operator|->
name|flags
operator|&
name|VF_OPEN
condition|)
name|close_locked_drive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
comment|/* and close it */
if|if
condition|(
name|drive
operator|->
name|state
operator|>
name|drive_down
condition|)
comment|/* if it's up */
name|drive
operator|->
name|state
operator|=
name|drive_down
expr_stmt|;
comment|/* make sure it's down */
name|unlockdrive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Real drive close code, called with drive already locked.  * We have also checked that the drive is open.  No errors.  */
end_comment

begin_function
name|void
name|close_locked_drive
parameter_list|(
name|struct
name|drive
modifier|*
name|drive
parameter_list|)
block|{
comment|/*      * If we can't access the drive, we can't flush      * the queues, which spec_close() will try to      * do.  Get rid of them here first.      */
name|drive
operator|->
name|lasterror
operator|=
operator|(
operator|*
name|devsw
argument_list|(
name|drive
operator|->
name|dev
argument_list|)
operator|->
name|d_close
operator|)
operator|(
name|drive
operator|->
name|dev
operator|,
literal|0
operator|,
literal|0
operator|,
name|NULL
operator|)
expr_stmt|;
name|drive
operator|->
name|flags
operator|&=
operator|~
name|VF_OPEN
expr_stmt|;
comment|/* no longer open */
block|}
end_function

begin_comment
comment|/*  * Remove drive from the configuration.  * Caller must ensure that it isn't active.  */
end_comment

begin_function
name|void
name|remove_drive
parameter_list|(
name|int
name|driveno
parameter_list|)
block|{
name|struct
name|drive
modifier|*
name|drive
init|=
operator|&
name|vinum_conf
operator|.
name|drive
index|[
name|driveno
index|]
decl_stmt|;
name|struct
name|vinum_hdr
modifier|*
name|vhdr
decl_stmt|;
comment|/* buffer for header */
name|int
name|error
decl_stmt|;
if|if
condition|(
name|drive
operator|->
name|state
operator|>
name|drive_referenced
condition|)
block|{
comment|/* real drive */
if|if
condition|(
name|drive
operator|->
name|state
operator|==
name|drive_up
condition|)
block|{
name|vhdr
operator|=
operator|(
expr|struct
name|vinum_hdr
operator|*
operator|)
name|Malloc
argument_list|(
name|VINUMHEADERLEN
argument_list|)
expr_stmt|;
comment|/* allocate buffer */
name|CHECKALLOC
argument_list|(
name|vhdr
argument_list|,
literal|"Can't allocate memory"
argument_list|)
expr_stmt|;
name|error
operator|=
name|read_drive
argument_list|(
name|drive
argument_list|,
operator|(
name|void
operator|*
operator|)
name|vhdr
argument_list|,
name|VINUMHEADERLEN
argument_list|,
name|VINUM_LABEL_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|drive
operator|->
name|lasterror
operator|=
name|error
expr_stmt|;
else|else
block|{
name|vhdr
operator|->
name|magic
operator|=
name|VINUM_NOMAGIC
expr_stmt|;
comment|/* obliterate the magic, but leave the rest */
name|write_drive
argument_list|(
name|drive
argument_list|,
operator|(
name|void
operator|*
operator|)
name|vhdr
argument_list|,
name|VINUMHEADERLEN
argument_list|,
name|VINUM_LABEL_OFFSET
argument_list|)
expr_stmt|;
block|}
name|Free
argument_list|(
name|vhdr
argument_list|)
expr_stmt|;
block|}
name|free_drive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
comment|/* close it and free resources */
name|save_config
argument_list|()
expr_stmt|;
comment|/* and save the updated configuration */
block|}
block|}
end_function

begin_comment
comment|/*  * Transfer drive data.  Usually called from one of these defines;  * #define read_drive(a, b, c, d) driveio (a, b, c, d, B_READ)  * #define write_drive(a, b, c, d) driveio (a, b, c, d, B_WRITE)  *  * length and offset are in bytes, but must be multiples of sector  * size.  The function *does not check* for this condition, and  * truncates ruthlessly.  * Return error number  */
end_comment

begin_function
name|int
name|driveio
parameter_list|(
name|struct
name|drive
modifier|*
name|drive
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|length
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* to keep the compiler happy */
while|while
condition|(
name|length
condition|)
block|{
comment|/* divide into small enough blocks */
name|int
name|len
init|=
name|min
argument_list|(
name|length
argument_list|,
name|MAXBSIZE
argument_list|)
decl_stmt|;
comment|/* maximum block device transfer is MAXBSIZE */
name|bp
operator|=
name|geteblk
argument_list|(
name|len
argument_list|)
expr_stmt|;
comment|/* get a buffer header */
name|bp
operator|->
name|b_flags
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_iocmd
operator|=
name|flag
expr_stmt|;
name|bp
operator|->
name|b_dev
operator|=
name|drive
operator|->
name|dev
expr_stmt|;
comment|/* device */
name|bp
operator|->
name|b_blkno
operator|=
name|offset
operator|/
name|drive
operator|->
name|sectorsize
expr_stmt|;
comment|/* block number */
name|bp
operator|->
name|b_saveaddr
operator|=
name|bp
operator|->
name|b_data
expr_stmt|;
name|bp
operator|->
name|b_data
operator|=
name|buf
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
name|len
expr_stmt|;
name|DEV_STRATEGY
argument_list|(
name|bp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* initiate the transfer */
name|error
operator|=
name|bufwait
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_data
operator|=
name|bp
operator|->
name|b_saveaddr
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_INVAL
operator||
name|B_AGE
expr_stmt|;
name|bp
operator|->
name|b_ioflags
operator|&=
operator|~
name|BIO_ERROR
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|length
operator|-=
name|len
expr_stmt|;
comment|/* update pointers */
name|buf
operator|+=
name|len
expr_stmt|;
name|offset
operator|+=
name|len
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Check a drive for a vinum header.  If found,  * update the drive information.  We come here  * with a partially populated drive structure  * which includes the device name.  *  * Return information on what we found.  *  * This function is called from two places: check_drive,  * which wants to find out whether the drive is a  * Vinum drive, and config_drive, which asserts that  * it is a vinum drive.  In the first case, we don't  * print error messages (verbose==0), in the second  * we do (verbose==1).  */
end_comment

begin_function
name|enum
name|drive_label_info
name|read_drive_label
parameter_list|(
name|struct
name|drive
modifier|*
name|drive
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|result
decl_stmt|;
comment|/* result of our search */
name|struct
name|vinum_hdr
modifier|*
name|vhdr
decl_stmt|;
comment|/* and as header */
name|error
operator|=
name|init_drive
argument_list|(
name|drive
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* find the drive */
if|if
condition|(
name|error
condition|)
comment|/* find the drive */
return|return
name|DL_CANT_OPEN
return|;
comment|/* not ours */
name|vhdr
operator|=
operator|(
expr|struct
name|vinum_hdr
operator|*
operator|)
name|Malloc
argument_list|(
name|VINUMHEADERLEN
argument_list|)
expr_stmt|;
comment|/* allocate buffers */
name|CHECKALLOC
argument_list|(
name|vhdr
argument_list|,
literal|"Can't allocate memory"
argument_list|)
expr_stmt|;
name|drive
operator|->
name|state
operator|=
name|drive_up
expr_stmt|;
comment|/* be optimistic */
name|error
operator|=
name|read_drive
argument_list|(
name|drive
argument_list|,
operator|(
name|void
operator|*
operator|)
name|vhdr
argument_list|,
name|VINUMHEADERLEN
argument_list|,
name|VINUM_LABEL_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|vhdr
operator|->
name|magic
operator|==
name|VINUM_MAGIC
condition|)
block|{
comment|/* ours! */
if|if
condition|(
name|drive
operator|->
name|label
operator|.
name|name
index|[
literal|0
index|]
comment|/* we have a name for this drive */
operator|&&
operator|(
name|strcmp
argument_list|(
name|drive
operator|->
name|label
operator|.
name|name
argument_list|,
name|vhdr
operator|->
name|label
operator|.
name|name
argument_list|)
operator|)
condition|)
block|{
comment|/* but it doesn't match the real name */
name|drive
operator|->
name|lasterror
operator|=
name|EINVAL
expr_stmt|;
name|result
operator|=
name|DL_WRONG_DRIVE
expr_stmt|;
comment|/* it's the wrong drive */
name|drive
operator|->
name|state
operator|=
name|drive_unallocated
expr_stmt|;
comment|/* put it back, it's not ours */
block|}
else|else
name|result
operator|=
name|DL_OURS
expr_stmt|;
comment|/* 	 * We copy the drive anyway so that we have 	 * the correct name in the drive info.  This 	 * may not be the name specified 	 */
name|drive
operator|->
name|label
operator|=
name|vhdr
operator|->
name|label
expr_stmt|;
comment|/* put in the label information */
block|}
elseif|else
if|if
condition|(
name|vhdr
operator|->
name|magic
operator|==
name|VINUM_NOMAGIC
condition|)
comment|/* was ours, but we gave it away */
name|result
operator|=
name|DL_DELETED_LABEL
expr_stmt|;
comment|/* and return the info */
else|else
name|result
operator|=
name|DL_NOT_OURS
expr_stmt|;
comment|/* we could have it, but we don't yet */
name|Free
argument_list|(
name|vhdr
argument_list|)
expr_stmt|;
comment|/* that's all. */
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * Check a drive for a vinum header.  If found,  * read configuration information from the drive and  * incorporate the data into the configuration.  *  * Return drive number.  */
end_comment

begin_function
name|struct
name|drive
modifier|*
name|check_drive
parameter_list|(
name|char
modifier|*
name|devicename
parameter_list|)
block|{
name|int
name|driveno
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|drive
modifier|*
name|drive
decl_stmt|;
name|driveno
operator|=
name|find_drive_by_dev
argument_list|(
name|devicename
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* if entry doesn't exist, create it */
name|drive
operator|=
operator|&
name|vinum_conf
operator|.
name|drive
index|[
name|driveno
index|]
expr_stmt|;
comment|/* and get a pointer */
if|if
condition|(
name|read_drive_label
argument_list|(
name|drive
argument_list|,
literal|0
argument_list|)
operator|==
name|DL_OURS
condition|)
block|{
comment|/* one of ours */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vinum_conf
operator|.
name|drives_allocated
condition|;
name|i
operator|++
control|)
block|{
comment|/* see if the name already exists */
if|if
condition|(
operator|(
name|i
operator|!=
name|driveno
operator|)
comment|/* not this drive */
operator|&&
operator|(
name|DRIVE
index|[
name|i
index|]
operator|.
name|state
operator|!=
name|drive_unallocated
operator|)
comment|/* and it's allocated */
operator|&&
operator|(
name|strcmp
argument_list|(
name|DRIVE
index|[
name|i
index|]
operator|.
name|label
operator|.
name|name
argument_list|,
name|DRIVE
index|[
name|driveno
index|]
operator|.
name|label
operator|.
name|name
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* and it has the same name */
name|struct
name|drive
modifier|*
name|mydrive
init|=
operator|&
name|DRIVE
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|mydrive
operator|->
name|devicename
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
comment|/* we know a device name for it */
comment|/* 		     * set an error, but don't take the 		     * drive down: that would cause unneeded 		     * error messages. 		     */
name|drive
operator|->
name|lasterror
operator|=
name|EEXIST
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/* it's just a place holder, */
name|int
name|sdno
decl_stmt|;
for|for
control|(
name|sdno
operator|=
literal|0
init|;
name|sdno
operator|<
name|vinum_conf
operator|.
name|subdisks_allocated
condition|;
name|sdno
operator|++
control|)
block|{
comment|/* look at each subdisk */
if|if
condition|(
operator|(
name|SD
index|[
name|sdno
index|]
operator|.
name|driveno
operator|==
name|i
operator|)
comment|/* it's pointing to this one, */
operator|&&
operator|(
name|SD
index|[
name|sdno
index|]
operator|.
name|state
operator|!=
name|sd_unallocated
operator|)
condition|)
block|{
comment|/* and it's a real subdisk */
name|SD
index|[
name|sdno
index|]
operator|.
name|driveno
operator|=
name|drive
operator|->
name|driveno
expr_stmt|;
comment|/* point to the one we found */
name|update_sd_state
argument_list|(
name|sdno
argument_list|)
expr_stmt|;
comment|/* and update its state */
block|}
block|}
name|bzero
argument_list|(
name|mydrive
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|drive
argument_list|)
argument_list|)
expr_stmt|;
comment|/* don't deallocate it, just remove it */
block|}
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|drive
operator|->
name|lasterror
operator|==
literal|0
condition|)
name|drive
operator|->
name|lasterror
operator|=
name|ENODEV
expr_stmt|;
name|close_drive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
name|drive
operator|->
name|state
operator|=
name|drive_down
expr_stmt|;
block|}
return|return
name|drive
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|sappend
parameter_list|(
name|char
modifier|*
name|txt
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
block|{
while|while
condition|(
operator|(
operator|*
name|s
operator|++
operator|=
operator|*
name|txt
operator|++
operator|)
operator|!=
literal|0
condition|)
empty_stmt|;
return|return
name|s
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|void
name|format_config
parameter_list|(
name|char
modifier|*
name|config
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|config
decl_stmt|;
name|char
modifier|*
name|configend
init|=
operator|&
name|config
index|[
name|len
index|]
decl_stmt|;
name|bzero
argument_list|(
name|config
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* First write the volume configuration */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vinum_conf
operator|.
name|volumes_allocated
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|volume
modifier|*
name|vol
decl_stmt|;
name|vol
operator|=
operator|&
name|vinum_conf
operator|.
name|volume
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|vol
operator|->
name|state
operator|>
name|volume_uninit
operator|)
operator|&&
operator|(
name|vol
operator|->
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|)
condition|)
block|{
comment|/* paranoia */
name|snprintf
argument_list|(
name|s
argument_list|,
name|configend
operator|-
name|s
argument_list|,
literal|"volume %s state %s"
argument_list|,
name|vol
operator|->
name|name
argument_list|,
name|volume_state
argument_list|(
name|vol
operator|->
name|state
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
name|s
operator|++
expr_stmt|;
comment|/* find the end */
if|if
condition|(
name|vol
operator|->
name|preferred_plex
operator|>=
literal|0
condition|)
comment|/* preferences, */
name|snprintf
argument_list|(
name|s
argument_list|,
name|configend
operator|-
name|s
argument_list|,
literal|" readpol prefer %s"
argument_list|,
name|vinum_conf
operator|.
name|plex
index|[
name|vol
operator|->
name|preferred_plex
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
name|s
operator|++
expr_stmt|;
comment|/* find the end */
name|s
operator|=
name|sappend
argument_list|(
literal|"\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Then the plex configuration */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vinum_conf
operator|.
name|plexes_allocated
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|plex
modifier|*
name|plex
decl_stmt|;
name|plex
operator|=
operator|&
name|vinum_conf
operator|.
name|plex
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|plex
operator|->
name|state
operator|>
name|plex_referenced
operator|)
operator|&&
operator|(
name|plex
operator|->
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|)
condition|)
block|{
comment|/* paranoia */
name|snprintf
argument_list|(
name|s
argument_list|,
name|configend
operator|-
name|s
argument_list|,
literal|"plex name %s state %s org %s "
argument_list|,
name|plex
operator|->
name|name
argument_list|,
name|plex_state
argument_list|(
name|plex
operator|->
name|state
argument_list|)
argument_list|,
name|plex_org
argument_list|(
name|plex
operator|->
name|organization
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
name|s
operator|++
expr_stmt|;
comment|/* find the end */
if|if
condition|(
name|isstriped
argument_list|(
name|plex
argument_list|)
condition|)
block|{
name|snprintf
argument_list|(
name|s
argument_list|,
name|configend
operator|-
name|s
argument_list|,
literal|"%ds "
argument_list|,
operator|(
name|int
operator|)
name|plex
operator|->
name|stripesize
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
name|s
operator|++
expr_stmt|;
comment|/* find the end */
block|}
if|if
condition|(
name|plex
operator|->
name|volno
operator|>=
literal|0
condition|)
comment|/* we have a volume */
name|snprintf
argument_list|(
name|s
argument_list|,
name|configend
operator|-
name|s
argument_list|,
literal|"vol %s "
argument_list|,
name|vinum_conf
operator|.
name|volume
index|[
name|plex
operator|->
name|volno
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
name|s
operator|++
expr_stmt|;
comment|/* find the end */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|plex
operator|->
name|subdisks
condition|;
name|j
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|s
argument_list|,
name|configend
operator|-
name|s
argument_list|,
literal|" sd %s"
argument_list|,
name|vinum_conf
operator|.
name|sd
index|[
name|plex
operator|->
name|sdnos
index|[
name|j
index|]
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|sappend
argument_list|(
literal|"\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* And finally the subdisk configuration */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vinum_conf
operator|.
name|subdisks_allocated
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|sd
modifier|*
name|sd
decl_stmt|;
name|char
modifier|*
name|drivename
decl_stmt|;
name|sd
operator|=
operator|&
name|SD
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|sd
operator|->
name|state
operator|!=
name|sd_referenced
operator|)
operator|&&
operator|(
name|sd
operator|->
name|state
operator|!=
name|sd_unallocated
operator|)
operator|&&
operator|(
name|sd
operator|->
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|)
condition|)
block|{
comment|/* paranoia */
name|drivename
operator|=
name|vinum_conf
operator|.
name|drive
index|[
name|sd
operator|->
name|driveno
index|]
operator|.
name|label
operator|.
name|name
expr_stmt|;
comment|/* 	     * XXX We've seen cases of dead subdisks 	     * which don't have a drive.  If we let them 	     * through here, the drive name is null, so 	     * they get the drive named 'plex'. 	     * 	     * This is a breakage limiter, not a fix. 	     */
if|if
condition|(
name|drivename
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|drivename
operator|=
literal|"*invalid*"
expr_stmt|;
name|snprintf
argument_list|(
name|s
argument_list|,
name|configend
operator|-
name|s
argument_list|,
literal|"sd name %s drive %s plex %s len %llus driveoffset %llus state %s"
argument_list|,
name|sd
operator|->
name|name
argument_list|,
name|drivename
argument_list|,
name|vinum_conf
operator|.
name|plex
index|[
name|sd
operator|->
name|plexno
index|]
operator|.
name|name
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|sd
operator|->
name|sectors
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|sd
operator|->
name|driveoffset
argument_list|,
name|sd_state
argument_list|(
name|sd
operator|->
name|state
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
name|s
operator|++
expr_stmt|;
comment|/* find the end */
if|if
condition|(
name|sd
operator|->
name|plexno
operator|>=
literal|0
condition|)
name|snprintf
argument_list|(
name|s
argument_list|,
name|configend
operator|-
name|s
argument_list|,
literal|" plexoffset %llds"
argument_list|,
operator|(
name|long
name|long
operator|)
name|sd
operator|->
name|plexoffset
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|s
argument_list|,
name|configend
operator|-
name|s
argument_list|,
literal|" detached"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
name|s
operator|++
expr_stmt|;
comment|/* find the end */
if|if
condition|(
name|sd
operator|->
name|flags
operator|&
name|VF_RETRYERRORS
condition|)
block|{
name|snprintf
argument_list|(
name|s
argument_list|,
name|configend
operator|-
name|s
argument_list|,
literal|" retryerrors"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
name|s
operator|++
expr_stmt|;
comment|/* find the end */
block|}
name|snprintf
argument_list|(
name|s
argument_list|,
name|configend
operator|-
name|s
argument_list|,
literal|" \n"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
name|s
operator|++
expr_stmt|;
comment|/* find the end */
block|}
block|}
if|if
condition|(
name|s
operator|>
operator|&
name|config
index|[
name|len
operator|-
literal|2
index|]
condition|)
name|panic
argument_list|(
literal|"vinum: configuration data overflow"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * issue a save config request to the dæmon.  The actual work  * is done in process context by daemon_save_config  */
end_comment

begin_function
name|void
name|save_config
parameter_list|(
name|void
parameter_list|)
block|{
name|queue_daemon_request
argument_list|(
name|daemonrq_saveconfig
argument_list|,
operator|(
expr|union
name|daemoninfo
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write the configuration to all vinum slices.  This  * is performed by the dæmon only  */
end_comment

begin_function
name|void
name|daemon_save_config
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|written_config
decl_stmt|;
comment|/* set when we first write the config to disk */
name|int
name|driveno
decl_stmt|;
name|struct
name|drive
modifier|*
name|drive
decl_stmt|;
comment|/* point to current drive info */
name|struct
name|vinum_hdr
modifier|*
name|vhdr
decl_stmt|;
comment|/* and as header */
name|char
modifier|*
name|config
decl_stmt|;
comment|/* point to config data */
name|int
name|wlabel_on
decl_stmt|;
comment|/* to set writing label on/off */
comment|/* don't save the configuration while we're still working on it */
if|if
condition|(
name|vinum_conf
operator|.
name|flags
operator|&
name|VF_CONFIGURING
condition|)
return|return;
name|written_config
operator|=
literal|0
expr_stmt|;
comment|/* no config written yet */
comment|/* Build a volume header */
name|vhdr
operator|=
operator|(
expr|struct
name|vinum_hdr
operator|*
operator|)
name|Malloc
argument_list|(
name|VINUMHEADERLEN
argument_list|)
expr_stmt|;
comment|/* get space for the config data */
name|CHECKALLOC
argument_list|(
name|vhdr
argument_list|,
literal|"Can't allocate config data"
argument_list|)
expr_stmt|;
name|vhdr
operator|->
name|magic
operator|=
name|VINUM_MAGIC
expr_stmt|;
comment|/* magic number */
name|vhdr
operator|->
name|config_length
operator|=
name|MAXCONFIG
expr_stmt|;
comment|/* length of following config info */
name|config
operator|=
name|Malloc
argument_list|(
name|MAXCONFIG
argument_list|)
expr_stmt|;
comment|/* get space for the config data */
name|CHECKALLOC
argument_list|(
name|config
argument_list|,
literal|"Can't allocate config data"
argument_list|)
expr_stmt|;
name|format_config
argument_list|(
name|config
argument_list|,
name|MAXCONFIG
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* no errors yet */
for|for
control|(
name|driveno
operator|=
literal|0
init|;
name|driveno
operator|<
name|vinum_conf
operator|.
name|drives_allocated
condition|;
name|driveno
operator|++
control|)
block|{
name|drive
operator|=
operator|&
name|vinum_conf
operator|.
name|drive
index|[
name|driveno
index|]
expr_stmt|;
comment|/* point to drive */
if|if
condition|(
name|drive
operator|->
name|state
operator|>
name|drive_referenced
condition|)
block|{
name|LOCKDRIVE
argument_list|(
name|drive
argument_list|)
expr_stmt|;
comment|/* don't let it change */
comment|/* 	     * First, do some drive consistency checks.  Some 	     * of these are kludges, others require a process 	     * context and couldn't be done before 	     */
if|if
condition|(
operator|(
name|drive
operator|->
name|devicename
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
operator|||
operator|(
name|drive
operator|->
name|label
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
name|unlockdrive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
name|free_drive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
comment|/* get rid of it */
break|break;
block|}
if|if
condition|(
operator|(
operator|(
name|drive
operator|->
name|flags
operator|&
name|VF_OPEN
operator|)
operator|==
literal|0
operator|)
comment|/* drive not open */
operator|&&
operator|(
name|drive
operator|->
name|state
operator|>
name|drive_down
operator|)
condition|)
block|{
comment|/* and it thinks it's not down */
name|unlockdrive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
name|set_drive_state
argument_list|(
name|driveno
argument_list|,
name|drive_down
argument_list|,
name|setstate_force
argument_list|)
expr_stmt|;
comment|/* tell it what's what */
continue|continue;
block|}
if|if
condition|(
operator|(
name|drive
operator|->
name|state
operator|==
name|drive_down
operator|)
comment|/* it's down */
operator|&&
operator|(
name|drive
operator|->
name|flags
operator|&
name|VF_OPEN
operator|)
condition|)
block|{
comment|/* but open, */
name|unlockdrive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
name|close_drive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
comment|/* close it */
block|}
elseif|else
if|if
condition|(
name|drive
operator|->
name|state
operator|>
name|drive_down
condition|)
block|{
name|getmicrotime
argument_list|(
operator|&
name|drive
operator|->
name|label
operator|.
name|last_update
argument_list|)
expr_stmt|;
comment|/* time of last update is now */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|drive
operator|->
name|label
argument_list|,
comment|/* and the label info from the drive structure */
operator|(
name|char
operator|*
operator|)
operator|&
name|vhdr
operator|->
name|label
argument_list|,
sizeof|sizeof
argument_list|(
name|vhdr
operator|->
name|label
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|drive
operator|->
name|state
operator|!=
name|drive_unallocated
operator|)
operator|&&
operator|(
name|drive
operator|->
name|state
operator|!=
name|drive_referenced
operator|)
condition|)
block|{
comment|/* and it's a real drive */
name|wlabel_on
operator|=
literal|1
expr_stmt|;
comment|/* enable writing the label */
name|error
operator|=
operator|(
operator|*
name|devsw
argument_list|(
name|drive
operator|->
name|dev
argument_list|)
operator|->
name|d_ioctl
operator|)
operator|(
name|drive
operator|->
name|dev
operator|,
comment|/* make the label writeable */
name|DIOCWLABEL
operator|,
operator|(
name|caddr_t
operator|)
operator|&
name|wlabel_on
operator|,
name|FWRITE
operator|,
name|curthread
operator|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|write_drive
argument_list|(
name|drive
argument_list|,
operator|(
name|char
operator|*
operator|)
name|vhdr
argument_list|,
name|VINUMHEADERLEN
argument_list|,
name|VINUM_LABEL_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|write_drive
argument_list|(
name|drive
argument_list|,
name|config
argument_list|,
name|MAXCONFIG
argument_list|,
name|VINUM_CONFIG_OFFSET
argument_list|)
expr_stmt|;
comment|/* first config copy */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|write_drive
argument_list|(
name|drive
argument_list|,
name|config
argument_list|,
name|MAXCONFIG
argument_list|,
name|VINUM_CONFIG_OFFSET
operator|+
name|MAXCONFIG
argument_list|)
expr_stmt|;
comment|/* second copy */
name|wlabel_on
operator|=
literal|0
expr_stmt|;
comment|/* enable writing the label */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
operator|(
operator|*
name|devsw
argument_list|(
name|drive
operator|->
name|dev
argument_list|)
operator|->
name|d_ioctl
operator|)
operator|(
name|drive
operator|->
name|dev
operator|,
comment|/* make the label non-writeable again */
name|DIOCWLABEL
operator|,
operator|(
name|caddr_t
operator|)
operator|&
name|wlabel_on
operator|,
name|FWRITE
operator|,
name|curthread
operator|)
expr_stmt|;
name|unlockdrive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"vinum: Can't write config to %s, error %d\n"
argument_list|,
name|drive
operator|->
name|devicename
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|set_drive_state
argument_list|(
name|drive
operator|->
name|driveno
argument_list|,
name|drive_down
argument_list|,
name|setstate_force
argument_list|)
expr_stmt|;
block|}
else|else
name|written_config
operator|=
literal|1
expr_stmt|;
comment|/* we've written it on at least one drive */
block|}
block|}
else|else
comment|/* not worth looking at, */
name|unlockdrive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
comment|/* just unlock it again */
block|}
block|}
name|Free
argument_list|(
name|vhdr
argument_list|)
expr_stmt|;
name|Free
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Disk labels are a mess.  The correct way to  * access them is with the DIOC[GSW]DINFO ioctls,  * but some programs, such as newfs, access the  * disk directly, so we have to write things  * there.  We do this only on request.  If a user  * request tries to read it directly, we fake up  * one on the fly.  */
end_comment

begin_comment
comment|/*  * get_volume_label returns a label structure to lp, which  * is allocated by the caller  */
end_comment

begin_function
name|void
name|get_volume_label
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|plexes
parameter_list|,
name|u_int64_t
name|size
parameter_list|,
name|struct
name|disklabel
modifier|*
name|lp
parameter_list|)
block|{
name|bzero
argument_list|(
name|lp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|disklabel
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|lp
operator|->
name|d_typename
argument_list|,
literal|"vinum"
argument_list|,
sizeof|sizeof
argument_list|(
name|lp
operator|->
name|d_typename
argument_list|)
argument_list|)
expr_stmt|;
name|lp
operator|->
name|d_type
operator|=
name|DTYPE_VINUM
expr_stmt|;
name|strncpy
argument_list|(
name|lp
operator|->
name|d_packname
argument_list|,
name|name
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|lp
operator|->
name|d_packname
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|lp
operator|->
name|d_rpm
operator|=
literal|14400
operator|*
name|plexes
expr_stmt|;
comment|/* to keep them guessing */
name|lp
operator|->
name|d_interleave
operator|=
literal|1
expr_stmt|;
name|lp
operator|->
name|d_flags
operator|=
literal|0
expr_stmt|;
comment|/*      * A Vinum volume has a single track with all      * its sectors.      */
name|lp
operator|->
name|d_secsize
operator|=
name|DEV_BSIZE
expr_stmt|;
comment|/* bytes per sector */
name|lp
operator|->
name|d_nsectors
operator|=
name|size
expr_stmt|;
comment|/* data sectors per track */
name|lp
operator|->
name|d_ntracks
operator|=
literal|1
expr_stmt|;
comment|/* tracks per cylinder */
name|lp
operator|->
name|d_ncylinders
operator|=
literal|1
expr_stmt|;
comment|/* data cylinders per unit */
name|lp
operator|->
name|d_secpercyl
operator|=
name|size
expr_stmt|;
comment|/* data sectors per cylinder */
name|lp
operator|->
name|d_secperunit
operator|=
name|size
expr_stmt|;
comment|/* data sectors per unit */
name|lp
operator|->
name|d_bbsize
operator|=
name|BBSIZE
expr_stmt|;
name|lp
operator|->
name|d_sbsize
operator|=
name|SBSIZE
expr_stmt|;
name|lp
operator|->
name|d_magic
operator|=
name|DISKMAGIC
expr_stmt|;
name|lp
operator|->
name|d_magic2
operator|=
name|DISKMAGIC
expr_stmt|;
comment|/*      * Set up partitions a, b and c to be identical      * and the size of the volume.  a is UFS, b is      * swap, c is nothing.      */
name|lp
operator|->
name|d_partitions
index|[
literal|0
index|]
operator|.
name|p_size
operator|=
name|size
expr_stmt|;
name|lp
operator|->
name|d_partitions
index|[
literal|0
index|]
operator|.
name|p_fsize
operator|=
literal|1024
expr_stmt|;
name|lp
operator|->
name|d_partitions
index|[
literal|0
index|]
operator|.
name|p_fstype
operator|=
name|FS_BSDFFS
expr_stmt|;
comment|/* FreeBSD File System :-) */
name|lp
operator|->
name|d_partitions
index|[
literal|0
index|]
operator|.
name|p_fsize
operator|=
literal|1024
expr_stmt|;
comment|/* FS fragment size */
name|lp
operator|->
name|d_partitions
index|[
literal|0
index|]
operator|.
name|p_frag
operator|=
literal|8
expr_stmt|;
comment|/* and fragments per block */
name|lp
operator|->
name|d_partitions
index|[
name|SWAP_PART
index|]
operator|.
name|p_size
operator|=
name|size
expr_stmt|;
name|lp
operator|->
name|d_partitions
index|[
name|SWAP_PART
index|]
operator|.
name|p_fstype
operator|=
name|FS_SWAP
expr_stmt|;
comment|/* swap partition */
name|lp
operator|->
name|d_partitions
index|[
name|LABEL_PART
index|]
operator|.
name|p_size
operator|=
name|size
expr_stmt|;
name|lp
operator|->
name|d_npartitions
operator|=
name|LABEL_PART
operator|+
literal|1
expr_stmt|;
name|strncpy
argument_list|(
name|lp
operator|->
name|d_packname
argument_list|,
name|name
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|lp
operator|->
name|d_packname
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|lp
operator|->
name|d_checksum
operator|=
name|dkcksum
argument_list|(
name|lp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write a volume label.  This implements the VINUM_LABEL ioctl. */
end_comment

begin_function
name|int
name|write_volume_label
parameter_list|(
name|int
name|volno
parameter_list|)
block|{
name|struct
name|disklabel
modifier|*
name|lp
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|disklabel
modifier|*
name|dlp
decl_stmt|;
name|struct
name|volume
modifier|*
name|vol
decl_stmt|;
name|int
name|error
decl_stmt|;
name|lp
operator|=
operator|(
expr|struct
name|disklabel
operator|*
operator|)
name|Malloc
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|disklabel
argument_list|)
operator|+
operator|(
name|DEV_BSIZE
operator|-
literal|1
operator|)
operator|)
operator|&
operator|(
name|DEV_BSIZE
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
operator|==
literal|0
condition|)
return|return
name|ENOMEM
return|;
if|if
condition|(
call|(
name|unsigned
call|)
argument_list|(
name|volno
argument_list|)
operator|>=
operator|(
name|unsigned
operator|)
name|vinum_conf
operator|.
name|volumes_allocated
condition|)
comment|/* invalid volume */
return|return
name|ENOENT
return|;
name|vol
operator|=
operator|&
name|VOL
index|[
name|volno
index|]
expr_stmt|;
comment|/* volume in question */
if|if
condition|(
name|vol
operator|->
name|state
operator|<=
name|volume_uninit
condition|)
comment|/* nothing there */
return|return
name|ENXIO
return|;
elseif|else
if|if
condition|(
name|vol
operator|->
name|state
operator|<
name|volume_up
condition|)
comment|/* not accessible */
return|return
name|EIO
return|;
comment|/* I/O error */
name|get_volume_label
argument_list|(
name|vol
operator|->
name|name
argument_list|,
name|vol
operator|->
name|plexes
argument_list|,
name|vol
operator|->
name|size
argument_list|,
name|lp
argument_list|)
expr_stmt|;
comment|/* get the label */
comment|/*      * Now write to disk.  This code is derived from the      * system writedisklabel (), which does silly things      * like reading the label and refusing to write      * unless it's already there.      */
name|bp
operator|=
name|geteblk
argument_list|(
operator|(
name|int
operator|)
name|lp
operator|->
name|d_secsize
argument_list|)
expr_stmt|;
comment|/* get a buffer */
name|bp
operator|->
name|b_dev
operator|=
name|makedev
argument_list|(
name|VINUM_CDEV_MAJOR
argument_list|,
name|vol
operator|->
name|volno
argument_list|)
expr_stmt|;
comment|/* our own raw volume */
name|bp
operator|->
name|b_blkno
operator|=
name|LABELSECTOR
operator|*
operator|(
operator|(
name|int
operator|)
name|lp
operator|->
name|d_secsize
operator|/
name|DEV_BSIZE
operator|)
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
name|lp
operator|->
name|d_secsize
expr_stmt|;
name|bzero
argument_list|(
name|bp
operator|->
name|b_data
argument_list|,
name|lp
operator|->
name|d_secsize
argument_list|)
expr_stmt|;
name|dlp
operator|=
operator|(
expr|struct
name|disklabel
operator|*
operator|)
name|bp
operator|->
name|b_data
expr_stmt|;
operator|*
name|dlp
operator|=
operator|*
name|lp
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_INVAL
expr_stmt|;
name|bp
operator|->
name|b_iocmd
operator|=
name|BIO_WRITE
expr_stmt|;
comment|/*      * This should read:      *      *       vinumstrategy (bp);      *      * Negotiate with phk to get it fixed.      */
name|DEV_STRATEGY
argument_list|(
name|bp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|bufwait
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_INVAL
operator||
name|B_AGE
expr_stmt|;
name|bp
operator|->
name|b_ioflags
operator|&=
operator|~
name|BIO_ERROR
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* Look at all disks on the system for vinum slices */
end_comment

begin_function
name|int
name|vinum_scandisk
parameter_list|(
name|char
modifier|*
name|devicename
index|[]
parameter_list|,
name|int
name|drives
parameter_list|)
block|{
name|struct
name|drive
modifier|*
specifier|volatile
name|drive
decl_stmt|;
specifier|volatile
name|int
name|driveno
decl_stmt|;
name|int
name|firstdrive
decl_stmt|;
comment|/* first drive in this list */
specifier|volatile
name|int
name|gooddrives
decl_stmt|;
comment|/* number of usable drives found */
name|int
name|firsttime
decl_stmt|;
comment|/* set if we have never configured before */
name|int
name|error
decl_stmt|;
name|char
modifier|*
name|config_text
decl_stmt|;
comment|/* read the config info from disk into here */
name|char
modifier|*
specifier|volatile
name|cptr
decl_stmt|;
comment|/* pointer into config information */
name|char
modifier|*
name|eptr
decl_stmt|;
comment|/* end pointer into config information */
name|char
modifier|*
name|config_line
decl_stmt|;
comment|/* copy the config line to */
specifier|volatile
name|int
name|status
decl_stmt|;
name|int
modifier|*
specifier|volatile
name|drivelist
decl_stmt|;
comment|/* list of drive indices */
define|#
directive|define
name|DRIVENAMELEN
value|64
define|#
directive|define
name|DRIVEPARTS
value|35
comment|/* max partitions per drive, excluding c */
name|char
name|partname
index|[
name|DRIVENAMELEN
index|]
decl_stmt|;
comment|/* for creating partition names */
name|status
operator|=
literal|0
expr_stmt|;
comment|/* success indication */
name|vinum_conf
operator|.
name|flags
operator||=
name|VF_READING_CONFIG
expr_stmt|;
comment|/* reading config from disk */
name|gooddrives
operator|=
literal|0
expr_stmt|;
comment|/* number of usable drives found */
name|firstdrive
operator|=
name|vinum_conf
operator|.
name|drives_used
expr_stmt|;
comment|/* the first drive */
name|firsttime
operator|=
name|vinum_conf
operator|.
name|drives_used
operator|==
literal|0
expr_stmt|;
comment|/* are we a virgin? */
comment|/* allocate a drive pointer list */
name|drivelist
operator|=
operator|(
name|int
operator|*
operator|)
name|Malloc
argument_list|(
name|drives
operator|*
name|DRIVEPARTS
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|CHECKALLOC
argument_list|(
name|drivelist
argument_list|,
literal|"Can't allocate memory"
argument_list|)
expr_stmt|;
comment|/* Open all drives and find which was modified most recently */
for|for
control|(
name|driveno
operator|=
literal|0
init|;
name|driveno
operator|<
name|drives
condition|;
name|driveno
operator|++
control|)
block|{
name|char
name|part
decl_stmt|;
comment|/* UNIX partition */
name|int
name|slice
decl_stmt|;
name|int
name|founddrive
decl_stmt|;
comment|/* flag when we find a vinum drive */
name|founddrive
operator|=
literal|0
expr_stmt|;
comment|/* no vinum drive found yet on this spindle */
comment|/* first try the partition table */
for|for
control|(
name|slice
operator|=
literal|1
init|;
name|slice
operator|<
literal|5
condition|;
name|slice
operator|++
control|)
for|for
control|(
name|part
operator|=
literal|'a'
init|;
name|part
operator|<
literal|'i'
condition|;
name|part
operator|++
control|)
block|{
if|if
condition|(
name|part
operator|!=
literal|'c'
condition|)
block|{
comment|/* don't do the c partition */
name|snprintf
argument_list|(
name|partname
argument_list|,
name|DRIVENAMELEN
argument_list|,
literal|"%ss%d%c"
argument_list|,
name|devicename
index|[
name|driveno
index|]
argument_list|,
name|slice
argument_list|,
name|part
argument_list|)
expr_stmt|;
name|drive
operator|=
name|check_drive
argument_list|(
name|partname
argument_list|)
expr_stmt|;
comment|/* try to open it */
if|if
condition|(
operator|(
name|drive
operator|->
name|lasterror
operator|!=
literal|0
operator|)
comment|/* didn't work, */
operator|||
operator|(
name|drive
operator|->
name|state
operator|!=
name|drive_up
operator|)
condition|)
name|free_drive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
comment|/* get rid of it */
elseif|else
if|if
condition|(
name|drive
operator|->
name|flags
operator|&
name|VF_CONFIGURED
condition|)
comment|/* already read this config, */
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"vinum: already read config from %s\n"
argument_list|,
comment|/* say so */
name|drive
operator|->
name|label
operator|.
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|drivelist
index|[
name|gooddrives
index|]
operator|=
name|drive
operator|->
name|driveno
expr_stmt|;
comment|/* keep the drive index */
name|drive
operator|->
name|flags
operator|&=
operator|~
name|VF_NEWBORN
expr_stmt|;
comment|/* which is no longer newly born */
name|gooddrives
operator|++
expr_stmt|;
name|founddrive
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|founddrive
operator|==
literal|0
condition|)
block|{
comment|/* didn't find anything, */
for|for
control|(
name|part
operator|=
literal|'a'
init|;
name|part
operator|<
literal|'i'
condition|;
name|part
operator|++
control|)
comment|/* try the compatibility partition */
if|if
condition|(
name|part
operator|!=
literal|'c'
condition|)
block|{
comment|/* don't do the c partition */
name|snprintf
argument_list|(
name|partname
argument_list|,
comment|/* /dev/sd0a */
name|DRIVENAMELEN
argument_list|,
literal|"%s%c"
argument_list|,
name|devicename
index|[
name|driveno
index|]
argument_list|,
name|part
argument_list|)
expr_stmt|;
name|drive
operator|=
name|check_drive
argument_list|(
name|partname
argument_list|)
expr_stmt|;
comment|/* try to open it */
if|if
condition|(
operator|(
name|drive
operator|->
name|lasterror
operator|!=
literal|0
operator|)
comment|/* didn't work, */
operator|||
operator|(
name|drive
operator|->
name|state
operator|!=
name|drive_up
operator|)
condition|)
name|free_drive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
comment|/* get rid of it */
elseif|else
if|if
condition|(
name|drive
operator|->
name|flags
operator|&
name|VF_CONFIGURED
condition|)
comment|/* already read this config, */
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"vinum: already read config from %s\n"
argument_list|,
comment|/* say so */
name|drive
operator|->
name|label
operator|.
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|drivelist
index|[
name|gooddrives
index|]
operator|=
name|drive
operator|->
name|driveno
expr_stmt|;
comment|/* keep the drive index */
name|drive
operator|->
name|flags
operator|&=
operator|~
name|VF_NEWBORN
expr_stmt|;
comment|/* which is no longer newly born */
name|gooddrives
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|gooddrives
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|firsttime
condition|)
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"vinum: no drives found\n"
argument_list|)
expr_stmt|;
else|else
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"vinum: no additional drives found\n"
argument_list|)
expr_stmt|;
return|return
name|ENOENT
return|;
block|}
comment|/*      * We now have at least one drive      * open.  Sort them in order of config time      * and merge the config info with what we      * have already.      */
name|qsort
argument_list|(
name|drivelist
argument_list|,
name|gooddrives
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|drivecmp
argument_list|)
expr_stmt|;
name|config_text
operator|=
operator|(
name|char
operator|*
operator|)
name|Malloc
argument_list|(
name|MAXCONFIG
operator|*
literal|2
argument_list|)
expr_stmt|;
comment|/* allocate buffers */
name|CHECKALLOC
argument_list|(
name|config_text
argument_list|,
literal|"Can't allocate memory"
argument_list|)
expr_stmt|;
name|config_line
operator|=
operator|(
name|char
operator|*
operator|)
name|Malloc
argument_list|(
name|MAXCONFIGLINE
operator|*
literal|2
argument_list|)
expr_stmt|;
comment|/* allocate buffers */
name|CHECKALLOC
argument_list|(
name|config_line
argument_list|,
literal|"Can't allocate memory"
argument_list|)
expr_stmt|;
for|for
control|(
name|driveno
operator|=
literal|0
init|;
name|driveno
operator|<
name|gooddrives
condition|;
name|driveno
operator|++
control|)
block|{
comment|/* now include the config */
name|drive
operator|=
operator|&
name|DRIVE
index|[
name|drivelist
index|[
name|driveno
index|]
index|]
expr_stmt|;
comment|/* point to the drive */
if|if
condition|(
name|firsttime
operator|&&
operator|(
name|driveno
operator|==
literal|0
operator|)
condition|)
comment|/* we've never configured before, */
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"vinum: reading configuration from %s\n"
argument_list|,
name|drive
operator|->
name|devicename
argument_list|)
expr_stmt|;
else|else
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"vinum: updating configuration from %s\n"
argument_list|,
name|drive
operator|->
name|devicename
argument_list|)
expr_stmt|;
if|if
condition|(
name|drive
operator|->
name|state
operator|==
name|drive_up
condition|)
comment|/* Read in both copies of the configuration information */
name|error
operator|=
name|read_drive
argument_list|(
name|drive
argument_list|,
name|config_text
argument_list|,
name|MAXCONFIG
operator|*
literal|2
argument_list|,
name|VINUM_CONFIG_OFFSET
argument_list|)
expr_stmt|;
else|else
block|{
name|error
operator|=
name|EIO
expr_stmt|;
name|printf
argument_list|(
literal|"vinum_scandisk: %s is %s\n"
argument_list|,
name|drive
operator|->
name|devicename
argument_list|,
name|drive_state
argument_list|(
name|drive
operator|->
name|state
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"vinum: Can't read device %s, error %d\n"
argument_list|,
name|drive
operator|->
name|devicename
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|free_drive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
comment|/* give it back */
name|status
operator|=
name|error
expr_stmt|;
block|}
comment|/* 	 * At this point, check that the two copies 	 * are the same, and do something useful if 	 * not.  In particular, consider which is 	 * newer, and what this means for the 	 * integrity of the data on the drive. 	 */
else|else
block|{
name|vinum_conf
operator|.
name|drives_used
operator|++
expr_stmt|;
comment|/* another drive in use */
comment|/* Parse the configuration, and add it to the global configuration */
for|for
control|(
name|cptr
operator|=
name|config_text
init|;
operator|*
name|cptr
operator|!=
literal|'\0'
condition|;
control|)
block|{
comment|/* love this style(9) */
specifier|volatile
name|int
name|parse_status
decl_stmt|;
comment|/* return value from parse_config */
for|for
control|(
name|eptr
operator|=
name|config_line
init|;
operator|(
operator|*
name|cptr
operator|!=
literal|'\n'
operator|)
operator|&&
operator|(
operator|*
name|cptr
operator|!=
literal|'\0'
operator|)
condition|;
control|)
comment|/* until the end of the line */
operator|*
name|eptr
operator|++
operator|=
operator|*
name|cptr
operator|++
expr_stmt|;
operator|*
name|eptr
operator|=
literal|'\0'
expr_stmt|;
comment|/* and delimit */
if|if
condition|(
name|setjmp
argument_list|(
name|command_fail
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* come back here on error and continue */
name|parse_status
operator|=
name|parse_config
argument_list|(
name|config_line
argument_list|,
operator|&
name|keyword_set
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* parse the config line */
if|if
condition|(
name|parse_status
operator|<
literal|0
condition|)
block|{
comment|/* error in config */
comment|/* 			   * This config should have been parsed in user 			   * space.  If we run into problems here, something 			   * serious is afoot.  Complain and let the user 			   * snarf the config to see what's wrong. 			 */
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"vinum: Config error on %s, aborting integration\n"
argument_list|,
name|drive
operator|->
name|devicename
argument_list|)
expr_stmt|;
name|free_drive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
comment|/* give it back */
name|status
operator|=
name|EINVAL
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|*
name|cptr
operator|==
literal|'\n'
condition|)
name|cptr
operator|++
expr_stmt|;
comment|/* skip to next line */
block|}
block|}
name|drive
operator|->
name|flags
operator||=
name|VF_CONFIGURED
expr_stmt|;
comment|/* read this drive's configuration */
block|}
name|Free
argument_list|(
name|config_text
argument_list|)
expr_stmt|;
name|Free
argument_list|(
name|drivelist
argument_list|)
expr_stmt|;
name|vinum_conf
operator|.
name|flags
operator|&=
operator|~
name|VF_READING_CONFIG
expr_stmt|;
comment|/* no longer reading from disk */
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"vinum: couldn't read configuration"
argument_list|)
expr_stmt|;
else|else
name|updateconfig
argument_list|(
name|VF_READING_CONFIG
argument_list|)
expr_stmt|;
comment|/* update from disk config */
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/*  * Compare the modification dates of the drives, for qsort.  * Return 1 if a< b, 0 if a == b, 01 if a> b: in other  * words, sort backwards.  */
end_comment

begin_function
name|int
name|drivecmp
parameter_list|(
specifier|const
name|void
modifier|*
name|va
parameter_list|,
specifier|const
name|void
modifier|*
name|vb
parameter_list|)
block|{
specifier|const
name|struct
name|drive
modifier|*
name|a
init|=
operator|&
name|DRIVE
index|[
operator|*
operator|(
specifier|const
name|int
operator|*
operator|)
name|va
index|]
decl_stmt|;
specifier|const
name|struct
name|drive
modifier|*
name|b
init|=
operator|&
name|DRIVE
index|[
operator|*
operator|(
specifier|const
name|int
operator|*
operator|)
name|vb
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|a
operator|->
name|label
operator|.
name|last_update
operator|.
name|tv_sec
operator|==
name|b
operator|->
name|label
operator|.
name|last_update
operator|.
name|tv_sec
operator|)
operator|&&
operator|(
name|a
operator|->
name|label
operator|.
name|last_update
operator|.
name|tv_usec
operator|==
name|b
operator|->
name|label
operator|.
name|last_update
operator|.
name|tv_usec
operator|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
operator|(
name|a
operator|->
name|label
operator|.
name|last_update
operator|.
name|tv_sec
operator|>
name|b
operator|->
name|label
operator|.
name|last_update
operator|.
name|tv_sec
operator|)
operator|||
operator|(
operator|(
name|a
operator|->
name|label
operator|.
name|last_update
operator|.
name|tv_sec
operator|==
name|b
operator|->
name|label
operator|.
name|last_update
operator|.
name|tv_sec
operator|)
operator|&&
operator|(
name|a
operator|->
name|label
operator|.
name|last_update
operator|.
name|tv_usec
operator|>
name|b
operator|->
name|label
operator|.
name|last_update
operator|.
name|tv_usec
operator|)
operator|)
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Local Variables: */
end_comment

begin_comment
comment|/* fill-column: 50 */
end_comment

begin_comment
comment|/* End: */
end_comment

end_unit

