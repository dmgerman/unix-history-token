begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* interrupt.c: bottom half of the driver */
end_comment

begin_comment
comment|/*-  * Copyright (c) 1997, 1998  *	Nan Yang Computer Services Limited.  All rights reserved.  *  *  This software is distributed under the so-called ``Berkeley  *  License'':  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Nan Yang Computer  *      Services Limited.  * 4. Neither the name of the Company nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * This software is provided ``as is'', and any express or implied  * warranties, including, but not limited to, the implied warranties of  * merchantability and fitness for a particular purpose are disclaimed.  * In no event shall the company or contributors be liable for any  * direct, indirect, incidental, special, exemplary, or consequential  * damages (including, but not limited to, procurement of substitute  * goods or services; loss of use, data, or profits; or business  * interruption) however caused and on any theory of liability, whether  * in contract, strict liability, or tort (including negligence or  * otherwise) arising in any way out of the use of this software, even if  * advised of the possibility of such damage.  *  * $Id: vinuminterrupt.c,v 1.4 1999/01/12 04:30:12 grog Exp grog $  */
end_comment

begin_define
define|#
directive|define
name|REALLYKERNEL
end_define

begin_include
include|#
directive|include
file|"opt_vinum.h"
end_include

begin_include
include|#
directive|include
file|<dev/vinum/vinumhdr.h>
end_include

begin_include
include|#
directive|include
file|<dev/vinum/request.h>
end_include

begin_include
include|#
directive|include
file|<miscfs/specfs/specdev.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_function_decl
name|void
name|complete_raid5_write
parameter_list|(
name|struct
name|rqelement
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|freerq
parameter_list|(
name|struct
name|request
modifier|*
name|rq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|free_rqg
parameter_list|(
name|struct
name|rqgroup
modifier|*
name|rqg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|complete_rqe
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|sdio_done
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Take a completed buffer, transfer the data back if  * it's a read, and complete the high-level request  * if this is the last subrequest.  *  * The bp parameter is in fact a struct rqelement, which  * includes a couple of extras at the end.  */
end_comment

begin_function
name|void
name|complete_rqe
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|rqelement
modifier|*
name|rqe
decl_stmt|;
name|struct
name|request
modifier|*
name|rq
decl_stmt|;
name|struct
name|rqgroup
modifier|*
name|rqg
decl_stmt|;
name|struct
name|buf
modifier|*
name|ubp
decl_stmt|;
comment|/* user buffer */
name|rqe
operator|=
operator|(
expr|struct
name|rqelement
operator|*
operator|)
name|bp
expr_stmt|;
comment|/* point to the element element that completed */
name|rqg
operator|=
name|rqe
operator|->
name|rqg
expr_stmt|;
comment|/* and the request group */
name|rq
operator|=
name|rqg
operator|->
name|rq
expr_stmt|;
comment|/* and the complete request */
name|ubp
operator|=
name|rq
operator|->
name|bp
expr_stmt|;
comment|/* user buffer */
ifdef|#
directive|ifdef
name|VINUMDEBUG
if|if
condition|(
name|debug
operator|&
name|DEBUG_LASTREQS
condition|)
name|logrq
argument_list|(
name|loginfo_iodone
argument_list|,
name|rqe
argument_list|,
name|ubp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ERROR
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* transfer in error */
if|if
condition|(
name|bp
operator|->
name|b_error
operator|!=
literal|0
condition|)
comment|/* did it return a number? */
name|rq
operator|->
name|error
operator|=
name|bp
operator|->
name|b_error
expr_stmt|;
comment|/* yes, put it in. */
elseif|else
if|if
condition|(
name|rq
operator|->
name|error
operator|==
literal|0
condition|)
comment|/* no: do we have one already? */
name|rq
operator|->
name|error
operator|=
name|EIO
expr_stmt|;
comment|/* no: catchall "I/O error" */
name|SD
index|[
name|rqe
operator|->
name|sdno
index|]
operator|.
name|lasterror
operator|=
name|rq
operator|->
name|error
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
block|{
name|printf
argument_list|(
literal|"%s: fatal read I/O error\n"
argument_list|,
name|SD
index|[
name|rqe
operator|->
name|sdno
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|set_sd_state
argument_list|(
name|rqe
operator|->
name|sdno
argument_list|,
name|sd_crashed
argument_list|,
name|setstate_force
argument_list|)
expr_stmt|;
comment|/* subdisk is crashed */
block|}
else|else
block|{
comment|/* write operation */
name|printf
argument_list|(
literal|"%s: fatal write I/O error\n"
argument_list|,
name|SD
index|[
name|rqe
operator|->
name|sdno
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|set_sd_state
argument_list|(
name|rqe
operator|->
name|sdno
argument_list|,
name|sd_stale
argument_list|,
name|setstate_force
argument_list|)
expr_stmt|;
comment|/* subdisk is stale */
block|}
if|if
condition|(
name|rq
operator|->
name|error
operator|==
name|ENXIO
condition|)
block|{
comment|/* the drive's down too */
name|printf
argument_list|(
literal|"%s: fatal drive I/O error\n"
argument_list|,
name|DRIVE
index|[
name|rqe
operator|->
name|driveno
index|]
operator|.
name|label
operator|.
name|name
argument_list|)
expr_stmt|;
name|DRIVE
index|[
name|rqe
operator|->
name|driveno
index|]
operator|.
name|lasterror
operator|=
name|rq
operator|->
name|error
expr_stmt|;
name|set_drive_state
argument_list|(
name|rqe
operator|->
name|driveno
argument_list|,
comment|/* take the drive down */
name|drive_down
argument_list|,
name|setstate_force
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now update the statistics */
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
block|{
comment|/* read operation */
name|DRIVE
index|[
name|rqe
operator|->
name|driveno
index|]
operator|.
name|reads
operator|++
expr_stmt|;
name|DRIVE
index|[
name|rqe
operator|->
name|driveno
index|]
operator|.
name|bytes_read
operator|+=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|SD
index|[
name|rqe
operator|->
name|sdno
index|]
operator|.
name|reads
operator|++
expr_stmt|;
name|SD
index|[
name|rqe
operator|->
name|sdno
index|]
operator|.
name|bytes_read
operator|+=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|PLEX
index|[
name|rqe
operator|->
name|rqg
operator|->
name|plexno
index|]
operator|.
name|reads
operator|++
expr_stmt|;
name|PLEX
index|[
name|rqe
operator|->
name|rqg
operator|->
name|plexno
index|]
operator|.
name|bytes_read
operator|+=
name|bp
operator|->
name|b_bcount
expr_stmt|;
block|}
else|else
block|{
comment|/* write operation */
name|DRIVE
index|[
name|rqe
operator|->
name|driveno
index|]
operator|.
name|writes
operator|++
expr_stmt|;
name|DRIVE
index|[
name|rqe
operator|->
name|driveno
index|]
operator|.
name|bytes_written
operator|+=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|SD
index|[
name|rqe
operator|->
name|sdno
index|]
operator|.
name|writes
operator|++
expr_stmt|;
name|SD
index|[
name|rqe
operator|->
name|sdno
index|]
operator|.
name|bytes_written
operator|+=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|PLEX
index|[
name|rqe
operator|->
name|rqg
operator|->
name|plexno
index|]
operator|.
name|writes
operator|++
expr_stmt|;
name|PLEX
index|[
name|rqe
operator|->
name|rqg
operator|->
name|plexno
index|]
operator|.
name|bytes_written
operator|+=
name|bp
operator|->
name|b_bcount
expr_stmt|;
block|}
name|rqg
operator|->
name|active
operator|--
expr_stmt|;
comment|/* one less request active */
if|if
condition|(
name|rqg
operator|->
name|active
operator|==
literal|0
condition|)
comment|/* request group finished, */
name|rq
operator|->
name|active
operator|--
expr_stmt|;
comment|/* one less */
if|if
condition|(
name|rq
operator|->
name|active
operator|==
literal|0
condition|)
block|{
comment|/* request finished, */
if|#
directive|if
name|VINUMDEBUG
if|if
condition|(
name|debug
operator|&
name|DEBUG_RESID
condition|)
block|{
if|if
condition|(
name|ubp
operator|->
name|b_resid
operator|!=
literal|0
condition|)
comment|/* still something to transfer? */
name|Debugger
argument_list|(
literal|"resid"
argument_list|)
expr_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ubp
operator|->
name|b_bcount
condition|;
name|i
operator|+=
literal|512
control|)
comment|/* XXX debug */
if|if
condition|(
operator|(
operator|(
name|char
operator|*
operator|)
name|ubp
operator|->
name|b_data
operator|)
index|[
name|i
index|]
operator|!=
literal|'<'
condition|)
block|{
comment|/* and not what we expected */
name|printf
argument_list|(
literal|"At 0x%x (offset 0x%x): '%c' (0x%x)\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|ubp
operator|->
name|b_data
operator|)
index|[
name|i
index|]
argument_list|)
argument_list|,
name|i
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|ubp
operator|->
name|b_data
operator|)
index|[
name|i
index|]
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|ubp
operator|->
name|b_data
operator|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|Debugger
argument_list|(
literal|"complete_request checksum"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|rq
operator|->
name|error
condition|)
block|{
comment|/* did we have an error? */
if|if
condition|(
name|rq
operator|->
name|isplex
condition|)
block|{
comment|/* plex operation, */
name|ubp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
comment|/* yes, propagate to user */
name|ubp
operator|->
name|b_error
operator|=
name|rq
operator|->
name|error
expr_stmt|;
block|}
else|else
comment|/* try to recover */
name|queue_daemon_request
argument_list|(
name|daemonrq_ioerror
argument_list|,
name|rq
argument_list|)
expr_stmt|;
comment|/* let the daemon complete */
block|}
else|else
block|{
name|ubp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
comment|/* completed our transfer */
if|if
condition|(
name|rq
operator|->
name|isplex
operator|==
literal|0
condition|)
comment|/* volume request, */
name|VOL
index|[
name|rq
operator|->
name|volplex
operator|.
name|volno
index|]
operator|.
name|active
operator|--
expr_stmt|;
comment|/* another request finished */
name|biodone
argument_list|(
name|ubp
argument_list|)
expr_stmt|;
comment|/* top level buffer completed */
name|freerq
argument_list|(
name|rq
argument_list|)
expr_stmt|;
comment|/* return the request storage */
block|}
block|}
block|}
end_function

begin_comment
comment|/* Free a request block and anything hanging off it */
end_comment

begin_function
name|void
name|freerq
parameter_list|(
name|struct
name|request
modifier|*
name|rq
parameter_list|)
block|{
name|struct
name|rqgroup
modifier|*
name|rqg
decl_stmt|;
name|struct
name|rqgroup
modifier|*
name|nrqg
decl_stmt|;
comment|/* next in chain */
name|int
name|rqno
decl_stmt|;
for|for
control|(
name|rqg
operator|=
name|rq
operator|->
name|rqg
init|;
name|rqg
operator|!=
name|NULL
condition|;
name|rqg
operator|=
name|nrqg
control|)
block|{
comment|/* through the whole request chain */
for|for
control|(
name|rqno
operator|=
literal|0
init|;
name|rqno
operator|<
name|rqg
operator|->
name|count
condition|;
name|rqno
operator|++
control|)
if|if
condition|(
operator|(
name|rqg
operator|->
name|rqe
index|[
name|rqno
index|]
operator|.
name|flags
operator|&
name|XFR_MALLOCED
operator|)
comment|/* data buffer was malloced, */
operator|&&
name|rqg
operator|->
name|rqe
index|[
name|rqno
index|]
operator|.
name|b
operator|.
name|b_data
condition|)
comment|/* and the allocation succeeded */
name|Free
argument_list|(
name|rqg
operator|->
name|rqe
index|[
name|rqno
index|]
operator|.
name|b
operator|.
name|b_data
argument_list|)
expr_stmt|;
comment|/* free it */
name|nrqg
operator|=
name|rqg
operator|->
name|next
expr_stmt|;
comment|/* note the next one */
name|Free
argument_list|(
name|rqg
argument_list|)
expr_stmt|;
comment|/* and free this one */
block|}
name|Free
argument_list|(
name|rq
argument_list|)
expr_stmt|;
comment|/* free the request itself */
block|}
end_function

begin_function
name|void
name|free_rqg
parameter_list|(
name|struct
name|rqgroup
modifier|*
name|rqg
parameter_list|)
block|{
if|if
condition|(
operator|(
name|rqg
operator|->
name|flags
operator|&
name|XFR_GROUPOP
operator|)
comment|/* RAID 5 request */
operator|&&
operator|(
name|rqg
operator|->
name|rqe
operator|)
comment|/* got a buffer structure */
operator|&&
operator|(
name|rqg
operator|->
name|rqe
operator|->
name|b
operator|.
name|b_data
operator|)
condition|)
comment|/* and it has a buffer allocated */
name|Free
argument_list|(
name|rqg
operator|->
name|rqe
operator|->
name|b
operator|.
name|b_data
argument_list|)
expr_stmt|;
comment|/* free it */
block|}
end_function

begin_comment
comment|/* I/O on subdisk completed */
end_comment

begin_function
name|void
name|sdio_done
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|sdbuf
modifier|*
name|sbp
decl_stmt|;
name|sbp
operator|=
operator|(
expr|struct
name|sdbuf
operator|*
operator|)
name|bp
expr_stmt|;
if|if
condition|(
name|sbp
operator|->
name|b
operator|.
name|b_flags
operator|&
name|B_ERROR
condition|)
block|{
comment|/* had an error */
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|sbp
operator|->
name|b
operator|.
name|b_error
expr_stmt|;
block|}
name|bp
operator|->
name|b_resid
operator|=
name|sbp
operator|->
name|b
operator|.
name|b_resid
expr_stmt|;
name|biodone
argument_list|(
name|sbp
operator|->
name|bp
argument_list|)
expr_stmt|;
comment|/* complete the caller's I/O */
comment|/* Now update the statistics */
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
block|{
comment|/* read operation */
name|DRIVE
index|[
name|sbp
operator|->
name|driveno
index|]
operator|.
name|reads
operator|++
expr_stmt|;
name|DRIVE
index|[
name|sbp
operator|->
name|driveno
index|]
operator|.
name|bytes_read
operator|+=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|SD
index|[
name|sbp
operator|->
name|sdno
index|]
operator|.
name|reads
operator|++
expr_stmt|;
name|SD
index|[
name|sbp
operator|->
name|sdno
index|]
operator|.
name|bytes_read
operator|+=
name|bp
operator|->
name|b_bcount
expr_stmt|;
block|}
else|else
block|{
comment|/* write operation */
name|DRIVE
index|[
name|sbp
operator|->
name|driveno
index|]
operator|.
name|writes
operator|++
expr_stmt|;
name|DRIVE
index|[
name|sbp
operator|->
name|driveno
index|]
operator|.
name|bytes_written
operator|+=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|SD
index|[
name|sbp
operator|->
name|sdno
index|]
operator|.
name|writes
operator|++
expr_stmt|;
name|SD
index|[
name|sbp
operator|->
name|sdno
index|]
operator|.
name|bytes_written
operator|+=
name|bp
operator|->
name|b_bcount
expr_stmt|;
block|}
name|Free
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

