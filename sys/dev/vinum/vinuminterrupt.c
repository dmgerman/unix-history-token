begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* vinuminterrupt.c: bottom half of the driver */
end_comment

begin_comment
comment|/*-  * Copyright (c) 1997, 1998, 1999  *	Nan Yang Computer Services Limited.  All rights reserved.  *  *  Parts copyright (c) 1997, 1998 Cybernet Corporation, NetMAX project.  *  *  Written by Greg Lehey  *  *  This software is distributed under the so-called ``Berkeley  *  License'':  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Nan Yang Computer  *      Services Limited.  * 4. Neither the name of the Company nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * This software is provided ``as is'', and any express or implied  * warranties, including, but not limited to, the implied warranties of  * merchantability and fitness for a particular purpose are disclaimed.  * In no event shall the company or contributors be liable for any  * direct, indirect, incidental, special, exemplary, or consequential  * damages (including, but not limited to, procurement of substitute  * goods or services; loss of use, data, or profits; or business  * interruption) however caused and on any theory of liability, whether  * in contract, strict liability, or tort (including negligence or  * otherwise) arising in any way out of the use of this software, even if  * advised of the possibility of such damage.  *  * $Id: vinuminterrupt.c,v 1.14 2001/05/23 23:03:37 grog Exp grog $  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<dev/vinum/vinumhdr.h>
end_include

begin_include
include|#
directive|include
file|<dev/vinum/request.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_function_decl
name|void
name|complete_raid5_write
parameter_list|(
name|struct
name|rqelement
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|complete_rqe
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|sdio_done
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Take a completed buffer, transfer the data back if  * it's a read, and complete the high-level request  * if this is the last subrequest.  *  * The bp parameter is in fact a struct rqelement, which  * includes a couple of extras at the end.  */
end_comment

begin_function
name|void
name|complete_rqe
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|rqelement
modifier|*
name|rqe
decl_stmt|;
name|struct
name|request
modifier|*
name|rq
decl_stmt|;
name|struct
name|rqgroup
modifier|*
name|rqg
decl_stmt|;
name|struct
name|buf
modifier|*
name|ubp
decl_stmt|;
comment|/* user buffer */
name|struct
name|drive
modifier|*
name|drive
decl_stmt|;
name|struct
name|sd
modifier|*
name|sd
decl_stmt|;
name|char
modifier|*
name|gravity
decl_stmt|;
comment|/* for error messages */
name|rqe
operator|=
operator|(
expr|struct
name|rqelement
operator|*
operator|)
name|bp
expr_stmt|;
comment|/* point to the element element that completed */
name|rqg
operator|=
name|rqe
operator|->
name|rqg
expr_stmt|;
comment|/* and the request group */
name|rq
operator|=
name|rqg
operator|->
name|rq
expr_stmt|;
comment|/* and the complete request */
name|ubp
operator|=
name|rq
operator|->
name|bp
expr_stmt|;
comment|/* user buffer */
ifdef|#
directive|ifdef
name|VINUMDEBUG
if|if
condition|(
name|debug
operator|&
name|DEBUG_LASTREQS
condition|)
name|logrq
argument_list|(
name|loginfo_iodone
argument_list|,
operator|(
expr|union
name|rqinfou
operator|)
name|rqe
argument_list|,
name|ubp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|drive
operator|=
operator|&
name|DRIVE
index|[
name|rqe
operator|->
name|driveno
index|]
expr_stmt|;
name|drive
operator|->
name|active
operator|--
expr_stmt|;
comment|/* one less outstanding I/O on this drive */
name|vinum_conf
operator|.
name|active
operator|--
expr_stmt|;
comment|/* one less outstanding I/O globally */
if|if
condition|(
operator|(
name|drive
operator|->
name|active
operator|==
operator|(
name|DRIVE_MAXACTIVE
operator|-
literal|1
operator|)
operator|)
comment|/* we were at the drive limit */
operator|||
operator|(
name|vinum_conf
operator|.
name|active
operator|==
name|VINUM_MAXACTIVE
operator|)
condition|)
comment|/* or the global limit */
name|wakeup
argument_list|(
operator|&
name|launch_requests
argument_list|)
expr_stmt|;
comment|/* let another one at it */
if|if
condition|(
operator|(
name|bp
operator|->
name|b_io
operator|.
name|bio_flags
operator|&
name|BIO_ERROR
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* transfer in error */
name|gravity
operator|=
literal|""
expr_stmt|;
name|sd
operator|=
operator|&
name|SD
index|[
name|rqe
operator|->
name|sdno
index|]
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_error
operator|!=
literal|0
condition|)
comment|/* did it return a number? */
name|rq
operator|->
name|error
operator|=
name|bp
operator|->
name|b_error
expr_stmt|;
comment|/* yes, put it in. */
elseif|else
if|if
condition|(
name|rq
operator|->
name|error
operator|==
literal|0
condition|)
comment|/* no: do we have one already? */
name|rq
operator|->
name|error
operator|=
name|EIO
expr_stmt|;
comment|/* no: catchall "I/O error" */
name|sd
operator|->
name|lasterror
operator|=
name|rq
operator|->
name|error
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_iocmd
operator|==
name|BIO_READ
condition|)
block|{
comment|/* read operation */
if|if
condition|(
operator|(
name|rq
operator|->
name|error
operator|==
name|ENXIO
operator|)
operator|||
operator|(
name|sd
operator|->
name|flags
operator|&
name|VF_RETRYERRORS
operator|)
operator|==
literal|0
condition|)
block|{
name|gravity
operator|=
literal|" fatal"
expr_stmt|;
name|set_sd_state
argument_list|(
name|rqe
operator|->
name|sdno
argument_list|,
name|sd_crashed
argument_list|,
name|setstate_force
argument_list|)
expr_stmt|;
comment|/* subdisk is crashed */
block|}
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s:%s read error, block %lld for %ld bytes\n"
argument_list|,
name|gravity
argument_list|,
name|sd
operator|->
name|name
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* write operation */
if|if
condition|(
operator|(
name|rq
operator|->
name|error
operator|==
name|ENXIO
operator|)
operator|||
operator|(
name|sd
operator|->
name|flags
operator|&
name|VF_RETRYERRORS
operator|)
operator|==
literal|0
condition|)
block|{
name|gravity
operator|=
literal|"fatal "
expr_stmt|;
name|set_sd_state
argument_list|(
name|rqe
operator|->
name|sdno
argument_list|,
name|sd_stale
argument_list|,
name|setstate_force
argument_list|)
expr_stmt|;
comment|/* subdisk is stale */
block|}
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s:%s write error, block %lld for %ld bytes\n"
argument_list|,
name|gravity
argument_list|,
name|sd
operator|->
name|name
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|)
expr_stmt|;
block|}
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: user buffer block %lld for %ld bytes\n"
argument_list|,
name|sd
operator|->
name|name
argument_list|,
name|ubp
operator|->
name|b_blkno
argument_list|,
name|ubp
operator|->
name|b_bcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|rq
operator|->
name|error
operator|==
name|ENXIO
condition|)
block|{
comment|/* the drive's down too */
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: fatal drive I/O error, block %lld for %ld bytes\n"
argument_list|,
name|DRIVE
index|[
name|rqe
operator|->
name|driveno
index|]
operator|.
name|label
operator|.
name|name
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|)
expr_stmt|;
name|DRIVE
index|[
name|rqe
operator|->
name|driveno
index|]
operator|.
name|lasterror
operator|=
name|rq
operator|->
name|error
expr_stmt|;
name|set_drive_state
argument_list|(
name|rqe
operator|->
name|driveno
argument_list|,
comment|/* take the drive down */
name|drive_down
argument_list|,
name|setstate_force
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now update the statistics */
if|if
condition|(
name|bp
operator|->
name|b_iocmd
operator|==
name|BIO_READ
condition|)
block|{
comment|/* read operation */
name|DRIVE
index|[
name|rqe
operator|->
name|driveno
index|]
operator|.
name|reads
operator|++
expr_stmt|;
name|DRIVE
index|[
name|rqe
operator|->
name|driveno
index|]
operator|.
name|bytes_read
operator|+=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|SD
index|[
name|rqe
operator|->
name|sdno
index|]
operator|.
name|reads
operator|++
expr_stmt|;
name|SD
index|[
name|rqe
operator|->
name|sdno
index|]
operator|.
name|bytes_read
operator|+=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|PLEX
index|[
name|rqe
operator|->
name|rqg
operator|->
name|plexno
index|]
operator|.
name|reads
operator|++
expr_stmt|;
name|PLEX
index|[
name|rqe
operator|->
name|rqg
operator|->
name|plexno
index|]
operator|.
name|bytes_read
operator|+=
name|bp
operator|->
name|b_bcount
expr_stmt|;
if|if
condition|(
name|PLEX
index|[
name|rqe
operator|->
name|rqg
operator|->
name|plexno
index|]
operator|.
name|volno
operator|>=
literal|0
condition|)
block|{
comment|/* volume I/O, not plex */
name|VOL
index|[
name|PLEX
index|[
name|rqe
operator|->
name|rqg
operator|->
name|plexno
index|]
operator|.
name|volno
index|]
operator|.
name|reads
operator|++
expr_stmt|;
name|VOL
index|[
name|PLEX
index|[
name|rqe
operator|->
name|rqg
operator|->
name|plexno
index|]
operator|.
name|volno
index|]
operator|.
name|bytes_read
operator|+=
name|bp
operator|->
name|b_bcount
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* write operation */
name|DRIVE
index|[
name|rqe
operator|->
name|driveno
index|]
operator|.
name|writes
operator|++
expr_stmt|;
name|DRIVE
index|[
name|rqe
operator|->
name|driveno
index|]
operator|.
name|bytes_written
operator|+=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|SD
index|[
name|rqe
operator|->
name|sdno
index|]
operator|.
name|writes
operator|++
expr_stmt|;
name|SD
index|[
name|rqe
operator|->
name|sdno
index|]
operator|.
name|bytes_written
operator|+=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|PLEX
index|[
name|rqe
operator|->
name|rqg
operator|->
name|plexno
index|]
operator|.
name|writes
operator|++
expr_stmt|;
name|PLEX
index|[
name|rqe
operator|->
name|rqg
operator|->
name|plexno
index|]
operator|.
name|bytes_written
operator|+=
name|bp
operator|->
name|b_bcount
expr_stmt|;
if|if
condition|(
name|PLEX
index|[
name|rqe
operator|->
name|rqg
operator|->
name|plexno
index|]
operator|.
name|volno
operator|>=
literal|0
condition|)
block|{
comment|/* volume I/O, not plex */
name|VOL
index|[
name|PLEX
index|[
name|rqe
operator|->
name|rqg
operator|->
name|plexno
index|]
operator|.
name|volno
index|]
operator|.
name|writes
operator|++
expr_stmt|;
name|VOL
index|[
name|PLEX
index|[
name|rqe
operator|->
name|rqg
operator|->
name|plexno
index|]
operator|.
name|volno
index|]
operator|.
name|bytes_written
operator|+=
name|bp
operator|->
name|b_bcount
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rqg
operator|->
name|flags
operator|&
name|XFR_RECOVERY_READ
condition|)
block|{
comment|/* recovery read, */
name|int
modifier|*
name|sdata
decl_stmt|;
comment|/* source */
name|int
modifier|*
name|data
decl_stmt|;
comment|/* and group data */
name|int
name|length
decl_stmt|;
comment|/* and count involved */
name|int
name|count
decl_stmt|;
comment|/* loop counter */
name|struct
name|rqelement
modifier|*
name|urqe
init|=
operator|&
name|rqg
operator|->
name|rqe
index|[
name|rqg
operator|->
name|badsdno
index|]
decl_stmt|;
comment|/* rqe of the bad subdisk */
comment|/* XOR destination is the user data */
name|sdata
operator|=
operator|(
name|int
operator|*
operator|)
operator|&
name|rqe
operator|->
name|b
operator|.
name|b_data
index|[
name|rqe
operator|->
name|groupoffset
operator|<<
name|DEV_BSHIFT
index|]
expr_stmt|;
comment|/* old data contents */
name|data
operator|=
operator|(
name|int
operator|*
operator|)
operator|&
name|urqe
operator|->
name|b
operator|.
name|b_data
index|[
name|urqe
operator|->
name|groupoffset
operator|<<
name|DEV_BSHIFT
index|]
expr_stmt|;
comment|/* destination */
name|length
operator|=
name|urqe
operator|->
name|grouplen
operator|*
operator|(
name|DEV_BSIZE
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
expr_stmt|;
comment|/* and number of ints */
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|length
condition|;
name|count
operator|++
control|)
name|data
index|[
name|count
index|]
operator|^=
name|sdata
index|[
name|count
index|]
expr_stmt|;
comment|/* 	 * In a normal read, we will normally read directly 	 * into the user buffer.  This doesn't work if 	 * we're also doing a recovery, so we have to 	 * copy it 	 */
if|if
condition|(
name|rqe
operator|->
name|flags
operator|&
name|XFR_NORMAL_READ
condition|)
block|{
comment|/* normal read as well, */
name|char
modifier|*
name|src
init|=
operator|&
name|rqe
operator|->
name|b
operator|.
name|b_data
index|[
name|rqe
operator|->
name|dataoffset
operator|<<
name|DEV_BSHIFT
index|]
decl_stmt|;
comment|/* read data is here */
name|char
modifier|*
name|dst
decl_stmt|;
name|dst
operator|=
operator|(
name|char
operator|*
operator|)
name|ubp
operator|->
name|b_data
operator|+
operator|(
name|rqe
operator|->
name|useroffset
operator|<<
name|DEV_BSHIFT
operator|)
expr_stmt|;
comment|/* where to put it in user buffer */
name|length
operator|=
name|rqe
operator|->
name|datalen
operator|<<
name|DEV_BSHIFT
expr_stmt|;
comment|/* and count involved */
name|bcopy
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|length
argument_list|)
expr_stmt|;
comment|/* move it */
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|rqg
operator|->
name|flags
operator|&
operator|(
name|XFR_NORMAL_WRITE
operator||
name|XFR_DEGRADED_WRITE
operator|)
operator|)
comment|/* RAID 4/5 group write operation  */
operator|&&
operator|(
name|rqg
operator|->
name|active
operator|==
literal|1
operator|)
condition|)
comment|/* and this is the last active request */
name|complete_raid5_write
argument_list|(
name|rqe
argument_list|)
expr_stmt|;
comment|/*      * This is the earliest place where we can be      * sure that the request has really finished,      * since complete_raid5_write can issue new      * requests.      */
name|rqg
operator|->
name|active
operator|--
expr_stmt|;
comment|/* this request now finished */
if|if
condition|(
name|rqg
operator|->
name|active
operator|==
literal|0
condition|)
block|{
comment|/* request group finished, */
name|rq
operator|->
name|active
operator|--
expr_stmt|;
comment|/* one less */
if|if
condition|(
name|rqg
operator|->
name|lock
condition|)
block|{
comment|/* got a lock? */
name|unlockrange
argument_list|(
name|rqg
operator|->
name|plexno
argument_list|,
name|rqg
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* yes, free it */
name|rqg
operator|->
name|lock
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rq
operator|->
name|active
operator|==
literal|0
condition|)
block|{
comment|/* request finished, */
ifdef|#
directive|ifdef
name|VINUMDEBUG
if|if
condition|(
name|debug
operator|&
name|DEBUG_RESID
condition|)
block|{
if|if
condition|(
name|ubp
operator|->
name|b_resid
operator|!=
literal|0
condition|)
comment|/* still something to transfer? */
name|Debugger
argument_list|(
literal|"resid"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|rq
operator|->
name|error
condition|)
block|{
comment|/* did we have an error? */
if|if
condition|(
name|rq
operator|->
name|isplex
condition|)
block|{
comment|/* plex operation, */
name|ubp
operator|->
name|b_io
operator|.
name|bio_flags
operator||=
name|BIO_ERROR
expr_stmt|;
comment|/* yes, propagate to user */
name|ubp
operator|->
name|b_error
operator|=
name|rq
operator|->
name|error
expr_stmt|;
block|}
else|else
comment|/* try to recover */
name|queue_daemon_request
argument_list|(
name|daemonrq_ioerror
argument_list|,
operator|(
expr|union
name|daemoninfo
operator|)
name|rq
argument_list|)
expr_stmt|;
comment|/* let the daemon complete */
block|}
else|else
block|{
name|ubp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
comment|/* completed our transfer */
if|if
condition|(
name|rq
operator|->
name|isplex
operator|==
literal|0
condition|)
comment|/* volume request, */
name|VOL
index|[
name|rq
operator|->
name|volplex
operator|.
name|volno
index|]
operator|.
name|active
operator|--
expr_stmt|;
comment|/* another request finished */
if|if
condition|(
name|rq
operator|->
name|flags
operator|&
name|XFR_COPYBUF
condition|)
block|{
name|Free
argument_list|(
name|ubp
operator|->
name|b_data
argument_list|)
expr_stmt|;
name|ubp
operator|->
name|b_data
operator|=
name|rq
operator|->
name|save_data
expr_stmt|;
block|}
name|bufdone
argument_list|(
name|ubp
argument_list|)
expr_stmt|;
comment|/* top level buffer completed */
name|freerq
argument_list|(
name|rq
argument_list|)
expr_stmt|;
comment|/* return the request storage */
block|}
block|}
block|}
end_function

begin_comment
comment|/* Free a request block and anything hanging off it */
end_comment

begin_function
name|void
name|freerq
parameter_list|(
name|struct
name|request
modifier|*
name|rq
parameter_list|)
block|{
name|struct
name|rqgroup
modifier|*
name|rqg
decl_stmt|;
name|struct
name|rqgroup
modifier|*
name|nrqg
decl_stmt|;
comment|/* next in chain */
name|int
name|rqno
decl_stmt|;
for|for
control|(
name|rqg
operator|=
name|rq
operator|->
name|rqg
init|;
name|rqg
operator|!=
name|NULL
condition|;
name|rqg
operator|=
name|nrqg
control|)
block|{
comment|/* through the whole request chain */
if|if
condition|(
name|rqg
operator|->
name|lock
condition|)
comment|/* got a lock? */
name|unlockrange
argument_list|(
name|rqg
operator|->
name|plexno
argument_list|,
name|rqg
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* yes, free it */
for|for
control|(
name|rqno
operator|=
literal|0
init|;
name|rqno
operator|<
name|rqg
operator|->
name|count
condition|;
name|rqno
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|rqg
operator|->
name|rqe
index|[
name|rqno
index|]
operator|.
name|flags
operator|&
name|XFR_MALLOCED
operator|)
comment|/* data buffer was malloced, */
operator|&&
name|rqg
operator|->
name|rqe
index|[
name|rqno
index|]
operator|.
name|b
operator|.
name|b_data
condition|)
comment|/* and the allocation succeeded */
name|Free
argument_list|(
name|rqg
operator|->
name|rqe
index|[
name|rqno
index|]
operator|.
name|b
operator|.
name|b_data
argument_list|)
expr_stmt|;
comment|/* free it */
if|if
condition|(
name|rqg
operator|->
name|rqe
index|[
name|rqno
index|]
operator|.
name|flags
operator|&
name|XFR_BUFLOCKED
condition|)
block|{
comment|/* locked this buffer, */
name|BUF_UNLOCK
argument_list|(
operator|&
name|rqg
operator|->
name|rqe
index|[
name|rqno
index|]
operator|.
name|b
argument_list|)
expr_stmt|;
comment|/* unlock it again */
name|BUF_LOCKFREE
argument_list|(
operator|&
name|rqg
operator|->
name|rqe
index|[
name|rqno
index|]
operator|.
name|b
argument_list|)
expr_stmt|;
block|}
block|}
name|nrqg
operator|=
name|rqg
operator|->
name|next
expr_stmt|;
comment|/* note the next one */
name|Free
argument_list|(
name|rqg
argument_list|)
expr_stmt|;
comment|/* and free this one */
block|}
name|Free
argument_list|(
name|rq
argument_list|)
expr_stmt|;
comment|/* free the request itself */
block|}
end_function

begin_comment
comment|/* I/O on subdisk completed */
end_comment

begin_function
name|void
name|sdio_done
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|sdbuf
modifier|*
name|sbp
decl_stmt|;
name|sbp
operator|=
operator|(
expr|struct
name|sdbuf
operator|*
operator|)
name|bp
expr_stmt|;
if|if
condition|(
name|sbp
operator|->
name|b
operator|.
name|b_io
operator|.
name|bio_flags
operator|&
name|BIO_ERROR
condition|)
block|{
comment|/* had an error */
name|sbp
operator|->
name|bp
operator|->
name|b_io
operator|.
name|bio_flags
operator||=
name|BIO_ERROR
expr_stmt|;
comment|/* propagate upwards */
name|sbp
operator|->
name|bp
operator|->
name|b_error
operator|=
name|sbp
operator|->
name|b
operator|.
name|b_error
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|VINUMDEBUG
if|if
condition|(
name|debug
operator|&
name|DEBUG_LASTREQS
condition|)
name|logrq
argument_list|(
name|loginfo_sdiodone
argument_list|,
operator|(
expr|union
name|rqinfou
operator|)
name|bp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sbp
operator|->
name|bp
operator|->
name|b_resid
operator|=
name|sbp
operator|->
name|b
operator|.
name|b_resid
expr_stmt|;
comment|/* copy the resid field */
comment|/* Now update the statistics */
if|if
condition|(
name|bp
operator|->
name|b_iocmd
operator|==
name|BIO_READ
condition|)
block|{
comment|/* read operation */
name|DRIVE
index|[
name|sbp
operator|->
name|driveno
index|]
operator|.
name|reads
operator|++
expr_stmt|;
name|DRIVE
index|[
name|sbp
operator|->
name|driveno
index|]
operator|.
name|bytes_read
operator|+=
name|sbp
operator|->
name|b
operator|.
name|b_bcount
expr_stmt|;
name|SD
index|[
name|sbp
operator|->
name|sdno
index|]
operator|.
name|reads
operator|++
expr_stmt|;
name|SD
index|[
name|sbp
operator|->
name|sdno
index|]
operator|.
name|bytes_read
operator|+=
name|sbp
operator|->
name|b
operator|.
name|b_bcount
expr_stmt|;
block|}
else|else
block|{
comment|/* write operation */
name|DRIVE
index|[
name|sbp
operator|->
name|driveno
index|]
operator|.
name|writes
operator|++
expr_stmt|;
name|DRIVE
index|[
name|sbp
operator|->
name|driveno
index|]
operator|.
name|bytes_written
operator|+=
name|sbp
operator|->
name|b
operator|.
name|b_bcount
expr_stmt|;
name|SD
index|[
name|sbp
operator|->
name|sdno
index|]
operator|.
name|writes
operator|++
expr_stmt|;
name|SD
index|[
name|sbp
operator|->
name|sdno
index|]
operator|.
name|bytes_written
operator|+=
name|sbp
operator|->
name|b
operator|.
name|b_bcount
expr_stmt|;
block|}
name|bufdone
argument_list|(
name|sbp
operator|->
name|bp
argument_list|)
expr_stmt|;
comment|/* complete the caller's I/O */
name|BUF_UNLOCK
argument_list|(
operator|&
name|sbp
operator|->
name|b
argument_list|)
expr_stmt|;
name|BUF_LOCKFREE
argument_list|(
operator|&
name|sbp
operator|->
name|b
argument_list|)
expr_stmt|;
name|Free
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start the second phase of a RAID-4 or RAID-5 group write operation. */
end_comment

begin_function
name|void
name|complete_raid5_write
parameter_list|(
name|struct
name|rqelement
modifier|*
name|rqe
parameter_list|)
block|{
name|int
modifier|*
name|sdata
decl_stmt|;
comment|/* source */
name|int
modifier|*
name|pdata
decl_stmt|;
comment|/* and parity block data */
name|int
name|length
decl_stmt|;
comment|/* and count involved */
name|int
name|count
decl_stmt|;
comment|/* loop counter */
name|int
name|rqno
decl_stmt|;
comment|/* request index */
name|int
name|rqoffset
decl_stmt|;
comment|/* offset of request data from parity data */
name|struct
name|buf
modifier|*
name|ubp
decl_stmt|;
comment|/* user buffer header */
name|struct
name|request
modifier|*
name|rq
decl_stmt|;
comment|/* pointer to our request */
name|struct
name|rqgroup
modifier|*
name|rqg
decl_stmt|;
comment|/* and to the request group */
name|struct
name|rqelement
modifier|*
name|prqe
decl_stmt|;
comment|/* point to the parity block */
name|struct
name|drive
modifier|*
name|drive
decl_stmt|;
comment|/* drive to access */
name|rqg
operator|=
name|rqe
operator|->
name|rqg
expr_stmt|;
comment|/* and to our request group */
name|rq
operator|=
name|rqg
operator|->
name|rq
expr_stmt|;
comment|/* point to our request */
name|ubp
operator|=
name|rq
operator|->
name|bp
expr_stmt|;
comment|/* user's buffer header */
name|prqe
operator|=
operator|&
name|rqg
operator|->
name|rqe
index|[
literal|0
index|]
expr_stmt|;
comment|/* point to the parity block */
comment|/*      * If we get to this function, we have normal or      * degraded writes, or a combination of both.  We do      * the same thing in each case: we perform an      * exclusive or to the parity block.  The only      * difference is the origin of the data and the      * address range.      */
if|if
condition|(
name|rqe
operator|->
name|flags
operator|&
name|XFR_DEGRADED_WRITE
condition|)
block|{
comment|/* do the degraded write stuff */
name|pdata
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
operator|&
name|prqe
operator|->
name|b
operator|.
name|b_data
index|[
operator|(
name|prqe
operator|->
name|groupoffset
operator|)
operator|<<
name|DEV_BSHIFT
index|]
operator|)
expr_stmt|;
comment|/* parity data pointer */
name|bzero
argument_list|(
name|pdata
argument_list|,
name|prqe
operator|->
name|grouplen
operator|<<
name|DEV_BSHIFT
argument_list|)
expr_stmt|;
comment|/* start with nothing in the parity block */
comment|/* Now get what data we need from each block */
for|for
control|(
name|rqno
operator|=
literal|1
init|;
name|rqno
operator|<
name|rqg
operator|->
name|count
condition|;
name|rqno
operator|++
control|)
block|{
comment|/* for all the data blocks */
name|rqe
operator|=
operator|&
name|rqg
operator|->
name|rqe
index|[
name|rqno
index|]
expr_stmt|;
comment|/* this request */
name|sdata
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
operator|&
name|rqe
operator|->
name|b
operator|.
name|b_data
index|[
name|rqe
operator|->
name|groupoffset
operator|<<
name|DEV_BSHIFT
index|]
operator|)
expr_stmt|;
comment|/* old data */
name|length
operator|=
name|rqe
operator|->
name|grouplen
operator|<<
operator|(
name|DEV_BSHIFT
operator|-
literal|2
operator|)
expr_stmt|;
comment|/* and count involved */
comment|/* 	     * Add the data block to the parity block.  Before 	     * we started the request, we zeroed the parity 	     * block, so the result of adding all the other 	     * blocks and the block we want to write will be 	     * the correct parity block. 	     */
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|length
condition|;
name|count
operator|++
control|)
name|pdata
index|[
name|count
index|]
operator|^=
name|sdata
index|[
name|count
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|rqe
operator|->
name|flags
operator|&
name|XFR_MALLOCED
operator|)
comment|/* the buffer was malloced, */
operator|&&
operator|(
operator|(
name|rqg
operator|->
name|flags
operator|&
name|XFR_NORMAL_WRITE
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* and we have no normal write, */
name|Free
argument_list|(
name|rqe
operator|->
name|b
operator|.
name|b_data
argument_list|)
expr_stmt|;
comment|/* free it now */
name|rqe
operator|->
name|flags
operator|&=
operator|~
name|XFR_MALLOCED
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|rqg
operator|->
name|flags
operator|&
name|XFR_NORMAL_WRITE
condition|)
block|{
comment|/* do normal write stuff */
comment|/* Get what data we need from each block */
for|for
control|(
name|rqno
operator|=
literal|1
init|;
name|rqno
operator|<
name|rqg
operator|->
name|count
condition|;
name|rqno
operator|++
control|)
block|{
comment|/* for all the data blocks */
name|rqe
operator|=
operator|&
name|rqg
operator|->
name|rqe
index|[
name|rqno
index|]
expr_stmt|;
comment|/* this request */
if|if
condition|(
operator|(
name|rqe
operator|->
name|flags
operator|&
operator|(
name|XFR_DATA_BLOCK
operator||
name|XFR_BAD_SUBDISK
operator||
name|XFR_NORMAL_WRITE
operator|)
operator|)
operator|==
operator|(
name|XFR_DATA_BLOCK
operator||
name|XFR_NORMAL_WRITE
operator|)
condition|)
block|{
comment|/* good data block to write */
name|sdata
operator|=
operator|(
name|int
operator|*
operator|)
operator|&
name|rqe
operator|->
name|b
operator|.
name|b_data
index|[
name|rqe
operator|->
name|dataoffset
operator|<<
name|DEV_BSHIFT
index|]
expr_stmt|;
comment|/* old data contents */
name|rqoffset
operator|=
name|rqe
operator|->
name|dataoffset
operator|+
name|rqe
operator|->
name|sdoffset
operator|-
name|prqe
operator|->
name|sdoffset
expr_stmt|;
comment|/* corresponding parity block offset */
name|pdata
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
operator|&
name|prqe
operator|->
name|b
operator|.
name|b_data
index|[
name|rqoffset
operator|<<
name|DEV_BSHIFT
index|]
operator|)
expr_stmt|;
comment|/* parity data pointer */
name|length
operator|=
name|rqe
operator|->
name|datalen
operator|*
operator|(
name|DEV_BSIZE
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
expr_stmt|;
comment|/* and number of ints */
comment|/* 		 * "remove" the old data block 		 * from the parity block 		 */
if|if
condition|(
operator|(
name|pdata
operator|<
operator|(
operator|(
name|int
operator|*
operator|)
name|prqe
operator|->
name|b
operator|.
name|b_data
operator|)
operator|)
operator|||
operator|(
operator|&
name|pdata
index|[
name|length
index|]
operator|>
operator|(
operator|(
name|int
operator|*
operator|)
operator|(
name|prqe
operator|->
name|b
operator|.
name|b_data
operator|+
name|prqe
operator|->
name|b
operator|.
name|b_bcount
operator|)
operator|)
operator|)
operator|||
operator|(
name|sdata
operator|<
operator|(
operator|(
name|int
operator|*
operator|)
name|rqe
operator|->
name|b
operator|.
name|b_data
operator|)
operator|)
operator|||
operator|(
operator|&
name|sdata
index|[
name|length
index|]
operator|>
operator|(
operator|(
name|int
operator|*
operator|)
operator|(
name|rqe
operator|->
name|b
operator|.
name|b_data
operator|+
name|rqe
operator|->
name|b
operator|.
name|b_bcount
operator|)
operator|)
operator|)
condition|)
name|panic
argument_list|(
literal|"complete_raid5_write: bounds overflow"
argument_list|)
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|length
condition|;
name|count
operator|++
control|)
name|pdata
index|[
name|count
index|]
operator|^=
name|sdata
index|[
name|count
index|]
expr_stmt|;
comment|/* "add" the new data block */
name|sdata
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
operator|&
name|ubp
operator|->
name|b_data
index|[
name|rqe
operator|->
name|useroffset
operator|<<
name|DEV_BSHIFT
index|]
operator|)
expr_stmt|;
comment|/* new data */
if|if
condition|(
operator|(
name|sdata
operator|<
operator|(
operator|(
name|int
operator|*
operator|)
name|ubp
operator|->
name|b_data
operator|)
operator|)
operator|||
operator|(
operator|&
name|sdata
index|[
name|length
index|]
operator|>
operator|(
operator|(
name|int
operator|*
operator|)
operator|(
name|ubp
operator|->
name|b_data
operator|+
name|ubp
operator|->
name|b_bcount
operator|)
operator|)
operator|)
condition|)
name|panic
argument_list|(
literal|"complete_raid5_write: bounds overflow"
argument_list|)
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|length
condition|;
name|count
operator|++
control|)
name|pdata
index|[
name|count
index|]
operator|^=
name|sdata
index|[
name|count
index|]
expr_stmt|;
comment|/* Free the malloced buffer */
if|if
condition|(
name|rqe
operator|->
name|flags
operator|&
name|XFR_MALLOCED
condition|)
block|{
comment|/* the buffer was malloced, */
name|Free
argument_list|(
name|rqe
operator|->
name|b
operator|.
name|b_data
argument_list|)
expr_stmt|;
comment|/* free it */
name|rqe
operator|->
name|flags
operator|&=
operator|~
name|XFR_MALLOCED
expr_stmt|;
block|}
else|else
name|panic
argument_list|(
literal|"complete_raid5_write: malloc conflict"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rqe
operator|->
name|b
operator|.
name|b_iocmd
operator|==
name|BIO_READ
operator|)
comment|/* this was a read */
operator|&&
operator|(
operator|(
name|rqe
operator|->
name|flags
operator|&
name|XFR_BAD_SUBDISK
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* and we can write this block */
name|rqe
operator|->
name|b
operator|.
name|b_flags
operator|&=
operator|~
name|B_DONE
expr_stmt|;
comment|/* start a new request */
name|rqe
operator|->
name|b
operator|.
name|b_iocmd
operator|=
name|BIO_WRITE
expr_stmt|;
comment|/* we're writing now */
name|rqe
operator|->
name|b
operator|.
name|b_iodone
operator|=
name|complete_rqe
expr_stmt|;
comment|/* call us here when done */
name|rqe
operator|->
name|flags
operator|&=
operator|~
name|XFR_PARITYOP
expr_stmt|;
comment|/* reset flags that brought us here */
name|rqe
operator|->
name|b
operator|.
name|b_data
operator|=
operator|&
name|ubp
operator|->
name|b_data
index|[
name|rqe
operator|->
name|useroffset
operator|<<
name|DEV_BSHIFT
index|]
expr_stmt|;
comment|/* point to the user data */
name|rqe
operator|->
name|b
operator|.
name|b_bcount
operator|=
name|rqe
operator|->
name|datalen
operator|<<
name|DEV_BSHIFT
expr_stmt|;
comment|/* length to write */
name|rqe
operator|->
name|b
operator|.
name|b_bufsize
operator|=
name|rqe
operator|->
name|b
operator|.
name|b_bcount
expr_stmt|;
comment|/* don't claim more */
name|rqe
operator|->
name|b
operator|.
name|b_resid
operator|=
name|rqe
operator|->
name|b
operator|.
name|b_bcount
expr_stmt|;
comment|/* nothing transferred */
name|rqe
operator|->
name|b
operator|.
name|b_blkno
operator|+=
name|rqe
operator|->
name|dataoffset
expr_stmt|;
comment|/* point to the correct block */
name|rqg
operator|->
name|active
operator|++
expr_stmt|;
comment|/* another active request */
name|drive
operator|=
operator|&
name|DRIVE
index|[
name|rqe
operator|->
name|driveno
index|]
expr_stmt|;
comment|/* drive to access */
comment|/* We can't sleep here, so we just increment the counters. */
name|drive
operator|->
name|active
operator|++
expr_stmt|;
if|if
condition|(
name|drive
operator|->
name|active
operator|>=
name|drive
operator|->
name|maxactive
condition|)
name|drive
operator|->
name|maxactive
operator|=
name|drive
operator|->
name|active
expr_stmt|;
name|vinum_conf
operator|.
name|active
operator|++
expr_stmt|;
if|if
condition|(
name|vinum_conf
operator|.
name|active
operator|>=
name|vinum_conf
operator|.
name|maxactive
condition|)
name|vinum_conf
operator|.
name|maxactive
operator|=
name|vinum_conf
operator|.
name|active
expr_stmt|;
ifdef|#
directive|ifdef
name|VINUMDEBUG
if|if
condition|(
name|debug
operator|&
name|DEBUG_ADDRESSES
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"  %s dev %d.%d, sd %d, offset 0x%x, devoffset 0x%llx, length %ld\n"
argument_list|,
name|rqe
operator|->
name|b
operator|.
name|b_iocmd
operator|==
name|BIO_READ
condition|?
literal|"Read"
else|:
literal|"Write"
argument_list|,
name|major
argument_list|(
name|rqe
operator|->
name|b
operator|.
name|b_dev
argument_list|)
argument_list|,
name|minor
argument_list|(
name|rqe
operator|->
name|b
operator|.
name|b_dev
argument_list|)
argument_list|,
name|rqe
operator|->
name|sdno
argument_list|,
call|(
name|u_int
call|)
argument_list|(
name|rqe
operator|->
name|b
operator|.
name|b_blkno
operator|-
name|SD
index|[
name|rqe
operator|->
name|sdno
index|]
operator|.
name|driveoffset
argument_list|)
argument_list|,
name|rqe
operator|->
name|b
operator|.
name|b_blkno
argument_list|,
name|rqe
operator|->
name|b
operator|.
name|b_bcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|&
name|DEBUG_LASTREQS
condition|)
name|logrq
argument_list|(
name|loginfo_raid5_data
argument_list|,
operator|(
expr|union
name|rqinfou
operator|)
name|rqe
argument_list|,
name|ubp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DEV_STRATEGY
argument_list|(
operator|&
name|rqe
operator|->
name|b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Finally, write the parity block */
name|rqe
operator|=
operator|&
name|rqg
operator|->
name|rqe
index|[
literal|0
index|]
expr_stmt|;
name|rqe
operator|->
name|b
operator|.
name|b_flags
operator|&=
operator|~
name|B_DONE
expr_stmt|;
comment|/* we're not done */
name|rqe
operator|->
name|b
operator|.
name|b_iocmd
operator|=
name|BIO_WRITE
expr_stmt|;
comment|/* we're writing now */
name|rqe
operator|->
name|b
operator|.
name|b_iodone
operator|=
name|complete_rqe
expr_stmt|;
comment|/* call us here when done */
name|rqg
operator|->
name|flags
operator|&=
operator|~
name|XFR_PARITYOP
expr_stmt|;
comment|/* reset flags that brought us here */
name|rqe
operator|->
name|b
operator|.
name|b_bcount
operator|=
name|rqe
operator|->
name|buflen
operator|<<
name|DEV_BSHIFT
expr_stmt|;
comment|/* length to write */
name|rqe
operator|->
name|b
operator|.
name|b_bufsize
operator|=
name|rqe
operator|->
name|b
operator|.
name|b_bcount
expr_stmt|;
comment|/* don't claim we have more */
name|rqe
operator|->
name|b
operator|.
name|b_resid
operator|=
name|rqe
operator|->
name|b
operator|.
name|b_bcount
expr_stmt|;
comment|/* nothing transferred */
name|rqg
operator|->
name|active
operator|++
expr_stmt|;
comment|/* another active request */
name|drive
operator|=
operator|&
name|DRIVE
index|[
name|rqe
operator|->
name|driveno
index|]
expr_stmt|;
comment|/* drive to access */
comment|/* We can't sleep here, so we just increment the counters. */
name|drive
operator|->
name|active
operator|++
expr_stmt|;
if|if
condition|(
name|drive
operator|->
name|active
operator|>=
name|drive
operator|->
name|maxactive
condition|)
name|drive
operator|->
name|maxactive
operator|=
name|drive
operator|->
name|active
expr_stmt|;
name|vinum_conf
operator|.
name|active
operator|++
expr_stmt|;
if|if
condition|(
name|vinum_conf
operator|.
name|active
operator|>=
name|vinum_conf
operator|.
name|maxactive
condition|)
name|vinum_conf
operator|.
name|maxactive
operator|=
name|vinum_conf
operator|.
name|active
expr_stmt|;
ifdef|#
directive|ifdef
name|VINUMDEBUG
if|if
condition|(
name|debug
operator|&
name|DEBUG_ADDRESSES
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"  %s dev %d.%d, sd %d, offset 0x%x, devoffset 0x%llx, length %ld\n"
argument_list|,
name|rqe
operator|->
name|b
operator|.
name|b_iocmd
operator|==
name|BIO_READ
condition|?
literal|"Read"
else|:
literal|"Write"
argument_list|,
name|major
argument_list|(
name|rqe
operator|->
name|b
operator|.
name|b_dev
argument_list|)
argument_list|,
name|minor
argument_list|(
name|rqe
operator|->
name|b
operator|.
name|b_dev
argument_list|)
argument_list|,
name|rqe
operator|->
name|sdno
argument_list|,
call|(
name|u_int
call|)
argument_list|(
name|rqe
operator|->
name|b
operator|.
name|b_blkno
operator|-
name|SD
index|[
name|rqe
operator|->
name|sdno
index|]
operator|.
name|driveoffset
argument_list|)
argument_list|,
name|rqe
operator|->
name|b
operator|.
name|b_blkno
argument_list|,
name|rqe
operator|->
name|b
operator|.
name|b_bcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|&
name|DEBUG_LASTREQS
condition|)
name|logrq
argument_list|(
name|loginfo_raid5_parity
argument_list|,
operator|(
expr|union
name|rqinfou
operator|)
name|rqe
argument_list|,
name|ubp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DEV_STRATEGY
argument_list|(
operator|&
name|rqe
operator|->
name|b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Local Variables: */
end_comment

begin_comment
comment|/* fill-column: 50 */
end_comment

begin_comment
comment|/* End: */
end_comment

end_unit

