begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1997, 1998  *	Nan Yang Computer Services Limited.  All rights reserved.  *  *  This software is distributed under the so-called ``Berkeley  *  License'':  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Nan Yang Computer  *      Services Limited.  * 4. Neither the name of the Company nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * This software is provided ``as is'', and any express or implied  * warranties, including, but not limited to, the implied warranties of  * merchantability and fitness for a particular purpose are disclaimed.  * In no event shall the company or contributors be liable for any  * direct, indirect, incidental, special, exemplary, or consequential  * damages (including, but not limited to, procurement of substitute  * goods or services; loss of use, data, or profits; or business  * interruption) however caused and on any theory of liability, whether  * in contract, strict liability, or tort (including negligence or  * otherwise) arising in any way out of the use of this software, even if  * advised of the possibility of such damage.  *  * $Id: vinumstate.c,v 2.11 1999/03/13 04:47:09 grog Exp grog $  */
end_comment

begin_define
define|#
directive|define
name|REALLYKERNEL
end_define

begin_include
include|#
directive|include
file|"opt_vinum.h"
end_include

begin_include
include|#
directive|include
file|<dev/vinum/vinumhdr.h>
end_include

begin_include
include|#
directive|include
file|<dev/vinum/request.h>
end_include

begin_comment
comment|/* Update drive state */
end_comment

begin_comment
comment|/* Return 1 if the state changes, otherwise 0 */
end_comment

begin_function
name|int
name|set_drive_state
parameter_list|(
name|int
name|driveno
parameter_list|,
name|enum
name|drivestate
name|newstate
parameter_list|,
name|enum
name|setstateflags
name|flags
parameter_list|)
block|{
name|struct
name|drive
modifier|*
name|drive
init|=
operator|&
name|DRIVE
index|[
name|driveno
index|]
decl_stmt|;
name|int
name|oldstate
init|=
name|drive
operator|->
name|state
decl_stmt|;
name|int
name|sdno
decl_stmt|;
if|if
condition|(
name|drive
operator|->
name|state
operator|==
name|drive_unallocated
condition|)
comment|/* no drive to do anything with, */
return|return
literal|0
return|;
if|if
condition|(
name|newstate
operator|!=
name|oldstate
condition|)
block|{
comment|/* don't change it if it's not different */
if|if
condition|(
operator|(
name|newstate
operator|==
name|drive_down
operator|)
comment|/* the drive's going down */
operator|&&
operator|(
operator|!
operator|(
name|flags
operator|&
name|setstate_force
operator|)
operator|)
operator|&&
operator|(
name|drive
operator|->
name|opencount
operator|!=
literal|0
operator|)
condition|)
comment|/* we can't do it */
return|return
literal|0
return|;
comment|/* don't do it */
name|drive
operator|->
name|state
operator|=
name|newstate
expr_stmt|;
comment|/* set the state */
if|if
condition|(
name|drive
operator|->
name|label
operator|.
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
comment|/* we have a name, */
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"vinum: drive %s is %s\n"
argument_list|,
name|drive
operator|->
name|label
operator|.
name|name
argument_list|,
name|drive_state
argument_list|(
name|drive
operator|->
name|state
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|drive
operator|->
name|state
operator|==
name|drive_up
operator|)
operator|&&
operator|(
name|drive
operator|->
name|vp
operator|==
name|NULL
operator|)
condition|)
comment|/* should be open, but we're not */
name|init_drive
argument_list|(
name|drive
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* which changes the state again */
if|if
condition|(
name|newstate
operator|!=
name|oldstate
condition|)
block|{
comment|/* state has changed */
for|for
control|(
name|sdno
operator|=
literal|0
init|;
name|sdno
operator|<
name|vinum_conf
operator|.
name|subdisks_used
condition|;
name|sdno
operator|++
control|)
block|{
comment|/* find this drive's subdisks */
if|if
condition|(
name|SD
index|[
name|sdno
index|]
operator|.
name|driveno
operator|==
name|driveno
condition|)
comment|/* belongs to this drive */
name|update_sd_state
argument_list|(
name|sdno
argument_list|)
expr_stmt|;
comment|/* update the state */
block|}
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|setstate_configuring
operator|)
operator|==
literal|0
condition|)
comment|/* configuring? */
name|save_config
argument_list|()
expr_stmt|;
comment|/* no: save the updated configuration now */
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Try to set the subdisk state.  Return 1 if state changed to  * what we wanted, -1 if it changed to something else, and 0  * if no change.  *  * This routine is called both from the user (up, down states  * only) and internally.  */
end_comment

begin_function
name|int
name|set_sd_state
parameter_list|(
name|int
name|sdno
parameter_list|,
name|enum
name|sdstate
name|newstate
parameter_list|,
name|enum
name|setstateflags
name|flags
parameter_list|)
block|{
name|struct
name|sd
modifier|*
name|sd
init|=
operator|&
name|SD
index|[
name|sdno
index|]
decl_stmt|;
name|struct
name|plex
modifier|*
name|plex
decl_stmt|;
name|struct
name|volume
modifier|*
name|vol
decl_stmt|;
name|int
name|oldstate
init|=
name|sd
operator|->
name|state
decl_stmt|;
name|int
name|status
init|=
literal|1
decl_stmt|;
comment|/* status to return */
if|if
condition|(
operator|(
name|newstate
operator|==
name|oldstate
operator|)
operator|||
operator|(
name|sd
operator|->
name|state
operator|==
name|sd_unallocated
operator|)
condition|)
comment|/* no subdisk to do anything with, */
return|return
literal|0
return|;
if|if
condition|(
name|sd
operator|->
name|driveoffset
operator|<
literal|0
condition|)
block|{
comment|/* not allocated space */
name|sd
operator|->
name|state
operator|=
name|sd_down
expr_stmt|;
if|if
condition|(
name|newstate
operator|!=
name|sd_down
condition|)
block|{
if|if
condition|(
name|sd
operator|->
name|plexno
operator|>=
literal|0
condition|)
name|sdstatemap
argument_list|(
operator|&
name|PLEX
index|[
name|sd
operator|->
name|plexno
index|]
argument_list|)
expr_stmt|;
comment|/* count up subdisks */
return|return
operator|-
literal|1
return|;
block|}
block|}
else|else
block|{
comment|/*  space allocated */
switch|switch
condition|(
name|newstate
condition|)
block|{
case|case
name|sd_down
case|:
comment|/* take it down? */
comment|/* 	     * If we're attached to a plex, and we're 	     * not reborn, we won't go down without 	     * use of force. 	     */
if|if
condition|(
operator|(
operator|!
name|flags
operator|&
name|setstate_force
operator|)
operator|&&
operator|(
name|sd
operator|->
name|plexno
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|sd
operator|->
name|state
operator|!=
name|sd_reborn
operator|)
condition|)
return|return
literal|0
return|;
comment|/* don't do it */
break|break;
case|case
name|sd_up
case|:
if|if
condition|(
name|DRIVE
index|[
name|sd
operator|->
name|driveno
index|]
operator|.
name|state
operator|!=
name|drive_up
condition|)
comment|/* can't bring the sd up if the drive isn't, */
return|return
literal|0
return|;
comment|/* not even by force */
switch|switch
condition|(
name|sd
operator|->
name|state
condition|)
block|{
case|case
name|sd_crashed
case|:
case|case
name|sd_down
case|:
comment|/* been down, no data lost */
comment|/* 		 * If we're associated with a plex, and 		 * the plex isn't up, or we're the only 		 * subdisk in the plex, we can do it 		 */
if|if
condition|(
operator|(
name|sd
operator|->
name|plexno
operator|>=
literal|0
operator|)
operator|&&
operator|(
operator|(
operator|(
name|PLEX
index|[
name|sd
operator|->
name|plexno
index|]
operator|.
name|state
operator|<
name|plex_firstup
operator|)
operator|||
operator|(
name|PLEX
index|[
name|sd
operator|->
name|plexno
index|]
operator|.
name|subdisks
operator|>
literal|1
operator|)
operator|)
operator|)
condition|)
break|break;
comment|/* do it */
comment|/* 		 * XXX Get this right: make sure that other plexes in 		 * the volume cover this address space, otherwise 		 * we make this one sd_up. 		 * 		 * Do we even want this any more? 		 */
name|sd
operator|->
name|state
operator|=
name|sd_reborn
expr_stmt|;
comment|/* here it is again */
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"vinum: subdisk %s is %s, not %s\n"
argument_list|,
name|sd
operator|->
name|name
argument_list|,
name|sd_state
argument_list|(
name|sd
operator|->
name|state
argument_list|)
argument_list|,
name|sd_state
argument_list|(
name|newstate
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|sd_init
case|:
comment|/* brand new */
if|if
condition|(
name|flags
operator|&
name|setstate_configuring
condition|)
comment|/* we're doing this while configuring */
break|break;
comment|/* otherwise it's like being empty */
comment|/* FALLTHROUGH */
case|case
name|sd_empty
case|:
comment|/* 		 * If we're associated with a plex which 		 * is down, or which is the only one in the 		 * volume, and we're not a RAID-5 plex, we 		 * can come up without being inconsistent. 		 * Internally, we use the force flag to bring 		 * up a RAID-5 plex after initialization. 		 */
if|if
condition|(
operator|(
name|sd
operator|->
name|plexno
operator|>=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|PLEX
index|[
name|sd
operator|->
name|plexno
index|]
operator|.
name|organization
operator|!=
name|plex_raid5
operator|)
operator|||
operator|(
name|flags
operator|&
name|setstate_force
operator|)
operator|)
operator|&&
operator|(
operator|(
operator|(
name|PLEX
index|[
name|sd
operator|->
name|plexno
index|]
operator|.
name|state
operator|<
name|plex_firstup
operator|)
operator|||
operator|(
name|PLEX
index|[
name|sd
operator|->
name|plexno
index|]
operator|.
name|subdisks
operator|>
literal|1
operator|)
operator|)
operator|)
condition|)
break|break;
comment|/* Otherwise it's just out of date */
comment|/* FALLTHROUGH */
case|case
name|sd_stale
case|:
comment|/* out of date info, need reviving */
case|case
name|sd_obsolete
case|:
comment|/* 		 * 1.  If the subdisk is not part of a plex, bring it up, don't revive. 		 * 		 * 2.  If the subdisk is part of a one-plex volume or an unattached plex, 		 *     and it's not RAID-5, we *can't revive*.  The subdisk doesn't 		 *     change its state. 		 * 		 * 3.  If the subdisk is part of a one-plex volume or an unattached plex, 		 *     and it's RAID-5, but more than one subdisk is down, we *still 		 *     can't revive*.  The subdisk doesn't change its state. 		 * 		 * 4.  If the subdisk is part of a multi-plex volume, we'll change to 		 *     reviving and let the revive routines find out whether it will work 		 *     or not.  If they don't, the revive stops with an error message, 		 *     but the state doesn't change (FWIW). 		 */
if|if
condition|(
name|sd
operator|->
name|plexno
operator|<
literal|0
condition|)
comment|/* no plex associated, */
break|break;
comment|/* bring it up */
name|plex
operator|=
operator|&
name|PLEX
index|[
name|sd
operator|->
name|plexno
index|]
expr_stmt|;
if|if
condition|(
name|plex
operator|->
name|volno
operator|>=
literal|0
condition|)
comment|/* have a volume */
name|vol
operator|=
operator|&
name|VOL
index|[
name|plex
operator|->
name|volno
index|]
expr_stmt|;
else|else
name|vol
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * We can't do it if: 		 * 		 * 1: we don't have a volume 		 * 2: we're the only plex in the volume 		 * 3: we're a RAID-5 plex, and more than one subdisk is down. 		 */
if|if
condition|(
operator|(
operator|(
name|vol
operator|==
name|NULL
operator|)
operator|||
operator|(
name|vol
operator|->
name|plexes
operator|==
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|plex
operator|->
name|organization
operator|!=
name|plex_raid5
operator|)
operator|||
operator|(
name|plex
operator|->
name|sddowncount
operator|>
literal|1
operator|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* can't do it */
name|sd
operator|->
name|state
operator|=
name|sd_reviving
expr_stmt|;
comment|/* put in reviving state */
name|sd
operator|->
name|revived
operator|=
literal|0
expr_stmt|;
comment|/* nothing done yet */
name|status
operator|=
name|EAGAIN
expr_stmt|;
comment|/* need to repeat */
break|break;
comment|/* 		 * XXX This is silly.  We need to be able to 		 * bring the subdisk up when it's finished 		 * initializing, but not from the user.  We 		 * use the same ioctl in each case, but Vinum(8) 		 * doesn't supply the -f flag, so we use that 		 * to decide whether to do it or not 		 */
case|case
name|sd_initializing
case|:
if|if
condition|(
name|flags
operator|&
name|setstate_force
condition|)
break|break;
comment|/* do it if we have to */
return|return
literal|0
return|;
comment|/* no */
case|case
name|sd_reviving
case|:
if|if
condition|(
name|flags
operator|&
name|setstate_force
condition|)
comment|/* insist, */
break|break;
return|return
name|EAGAIN
return|;
comment|/* no, try again */
default|default:
comment|/* can't do it */
comment|/* 		 * There's no way to bring subdisks up directly from 		 * other states.  First they need to be initialized 		 * or revived 		 */
return|return
literal|0
return|;
block|}
break|break;
default|default:
comment|/* other ones, only internal with force */
if|if
condition|(
operator|(
name|flags
operator|&
name|setstate_force
operator|)
operator|==
literal|0
condition|)
comment|/* no force?  What's this? */
return|return
literal|0
return|;
comment|/* don't do it */
block|}
block|}
if|if
condition|(
name|status
operator|==
literal|1
condition|)
block|{
comment|/* we can do it, */
name|sd
operator|->
name|state
operator|=
name|newstate
expr_stmt|;
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"vinum: %s is %s\n"
argument_list|,
name|sd
operator|->
name|name
argument_list|,
name|sd_state
argument_list|(
name|sd
operator|->
name|state
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* we don't get here with status 0 */
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"vinum: %s is %s, not %s\n"
argument_list|,
name|sd
operator|->
name|name
argument_list|,
name|sd_state
argument_list|(
name|sd
operator|->
name|state
argument_list|)
argument_list|,
name|sd_state
argument_list|(
name|newstate
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|plexno
operator|>=
literal|0
condition|)
comment|/* we belong to a plex */
name|update_plex_state
argument_list|(
name|sd
operator|->
name|plexno
argument_list|)
expr_stmt|;
comment|/* update plex state */
if|if
condition|(
operator|(
name|flags
operator|&
name|setstate_configuring
operator|)
operator|==
literal|0
condition|)
comment|/* save config now */
name|save_config
argument_list|()
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/*  * Set the state of a plex dependent on its subdisks.  * This time round, we'll let plex state just reflect  * aggregate subdisk state, so this becomes an order of  * magnitude less complicated.  In particular, ignore  * the requested state.  */
end_comment

begin_function
name|int
name|set_plex_state
parameter_list|(
name|int
name|plexno
parameter_list|,
name|enum
name|plexstate
name|state
parameter_list|,
name|enum
name|setstateflags
name|flags
parameter_list|)
block|{
name|struct
name|plex
modifier|*
name|plex
decl_stmt|;
comment|/* point to our plex */
name|enum
name|plexstate
name|oldstate
decl_stmt|;
name|enum
name|volplexstate
name|vps
decl_stmt|;
comment|/* how do we compare with the other plexes? */
name|plex
operator|=
operator|&
name|PLEX
index|[
name|plexno
index|]
expr_stmt|;
comment|/* point to our plex */
name|oldstate
operator|=
name|plex
operator|->
name|state
expr_stmt|;
comment|/*      * If the plex isn't allocated,      * or it's already in the the state we want,      * and it's not up, just return.  If it's up,      * we still need to do some housekeeping.      */
if|if
condition|(
operator|(
name|plex
operator|->
name|state
operator|==
name|plex_unallocated
operator|)
operator|||
operator|(
operator|(
name|state
operator|==
name|oldstate
operator|)
operator|&&
operator|(
name|state
operator|!=
name|plex_up
operator|)
operator|)
condition|)
return|return
literal|0
return|;
name|vps
operator|=
name|vpstate
argument_list|(
name|plex
argument_list|)
expr_stmt|;
comment|/* how do we compare with the other plexes? */
switch|switch
condition|(
name|state
condition|)
block|{
comment|/* 	 * We can't bring the plex up, even by force, 	 * unless it's ready.  update_plex_state 	 * checks that 	 */
case|case
name|plex_up
case|:
comment|/* bring the plex up */
name|update_plex_state
argument_list|(
name|plex
operator|->
name|plexno
argument_list|)
expr_stmt|;
comment|/* it'll come up if it can */
break|break;
case|case
name|plex_down
case|:
comment|/* want to take it down */
comment|/* 	 * If we're the only one, or the only one 	 * which is up, we need force to do it. 	 */
if|if
condition|(
operator|(
operator|(
name|vps
operator|==
name|volplex_onlyus
operator|)
operator|||
operator|(
name|vps
operator|==
name|volplex_onlyusup
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|flags
operator|&
name|setstate_force
operator|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* can't do it */
name|plex
operator|->
name|state
operator|=
name|state
expr_stmt|;
comment|/* do it */
name|invalidate_subdisks
argument_list|(
name|plex
argument_list|,
name|sd_down
argument_list|)
expr_stmt|;
comment|/* and down all up subdisks */
break|break;
comment|/* 	 * This is only requested internally. 	 * Trust ourselves 	 */
case|case
name|plex_faulty
case|:
name|plex
operator|->
name|state
operator|=
name|state
expr_stmt|;
comment|/* do it */
name|invalidate_subdisks
argument_list|(
name|plex
argument_list|,
name|sd_crashed
argument_list|)
expr_stmt|;
comment|/* and crash all up subdisks */
break|break;
case|case
name|plex_initializing
case|:
comment|/* XXX consider what safeguards we need here */
if|if
condition|(
operator|(
name|flags
operator|&
name|setstate_force
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|plex
operator|->
name|state
operator|=
name|state
expr_stmt|;
comment|/* do it */
break|break;
comment|/* What's this? */
default|default:
return|return
literal|0
return|;
block|}
if|if
condition|(
name|plex
operator|->
name|state
operator|!=
name|oldstate
condition|)
comment|/* we've changed, */
name|log
argument_list|(
name|LOG_INFO
argument_list|,
comment|/* tell them about it */
literal|"vinum: %s is %s\n"
argument_list|,
name|plex
operator|->
name|name
argument_list|,
name|plex_state
argument_list|(
name|plex
operator|->
name|state
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * Now see what we have left, and whether      * we're taking the volume down      */
if|if
condition|(
name|plex
operator|->
name|volno
operator|>=
literal|0
condition|)
comment|/* we have a volume */
name|update_volume_state
argument_list|(
name|plex
operator|->
name|volno
argument_list|)
expr_stmt|;
comment|/* update its state */
if|if
condition|(
operator|(
name|flags
operator|&
name|setstate_configuring
operator|)
operator|==
literal|0
condition|)
comment|/* save config now */
name|save_config
argument_list|()
expr_stmt|;
comment|/* yes: save the updated configuration */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Update the state of a plex dependent on its plexes. */
end_comment

begin_function
name|int
name|set_volume_state
parameter_list|(
name|int
name|volno
parameter_list|,
name|enum
name|volumestate
name|state
parameter_list|,
name|enum
name|setstateflags
name|flags
parameter_list|)
block|{
name|struct
name|volume
modifier|*
name|vol
init|=
operator|&
name|VOL
index|[
name|volno
index|]
decl_stmt|;
comment|/* point to our volume */
if|if
condition|(
operator|(
name|vol
operator|->
name|state
operator|==
name|state
operator|)
comment|/* we're there already */
operator|||
operator|(
name|vol
operator|->
name|state
operator|==
name|volume_unallocated
operator|)
condition|)
comment|/* or no volume to do anything with, */
return|return
literal|0
return|;
if|if
condition|(
name|state
operator|==
name|volume_up
condition|)
comment|/* want to come up */
name|update_volume_state
argument_list|(
name|volno
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|state
operator|==
name|volume_down
condition|)
block|{
comment|/* want to go down */
if|if
condition|(
operator|(
operator|(
name|vol
operator|->
name|flags
operator|&
name|VF_OPEN
operator|)
operator|==
literal|0
operator|)
comment|/* not open */
operator|||
operator|(
operator|(
name|flags
operator|&
name|setstate_force
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* or we're forcing */
name|vol
operator|->
name|state
operator|=
name|volume_down
expr_stmt|;
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"vinum: volume %s is %s\n"
argument_list|,
name|vol
operator|->
name|name
argument_list|,
name|volume_state
argument_list|(
name|vol
operator|->
name|state
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|setstate_configuring
operator|)
operator|==
literal|0
condition|)
comment|/* save config now */
name|save_config
argument_list|()
expr_stmt|;
comment|/* yes: save the updated configuration */
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
comment|/* no change */
block|}
end_function

begin_comment
comment|/* Set the state of a subdisk based on its environment */
end_comment

begin_function
name|void
name|update_sd_state
parameter_list|(
name|int
name|sdno
parameter_list|)
block|{
name|struct
name|sd
modifier|*
name|sd
decl_stmt|;
name|struct
name|drive
modifier|*
name|drive
decl_stmt|;
name|enum
name|sdstate
name|oldstate
decl_stmt|;
name|sd
operator|=
operator|&
name|SD
index|[
name|sdno
index|]
expr_stmt|;
name|oldstate
operator|=
name|sd
operator|->
name|state
expr_stmt|;
name|drive
operator|=
operator|&
name|DRIVE
index|[
name|sd
operator|->
name|driveno
index|]
expr_stmt|;
if|if
condition|(
name|drive
operator|->
name|state
operator|==
name|drive_up
condition|)
block|{
switch|switch
condition|(
name|sd
operator|->
name|state
condition|)
block|{
case|case
name|sd_down
case|:
case|case
name|sd_crashed
case|:
name|sd
operator|->
name|state
operator|=
name|sd_reborn
expr_stmt|;
comment|/* back up again with no loss */
break|break;
default|default:
break|break;
block|}
block|}
else|else
block|{
comment|/* down or worse */
switch|switch
condition|(
name|sd
operator|->
name|state
condition|)
block|{
case|case
name|sd_up
case|:
case|case
name|sd_reborn
case|:
case|case
name|sd_reviving
case|:
name|sd
operator|->
name|state
operator|=
name|sd_crashed
expr_stmt|;
comment|/* lost our drive */
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|sd
operator|->
name|state
operator|!=
name|oldstate
condition|)
comment|/* state has changed, */
name|log
argument_list|(
name|LOG_INFO
argument_list|,
comment|/* say so */
literal|"vinum: %s is %s\n"
argument_list|,
name|sd
operator|->
name|name
argument_list|,
name|sd_state
argument_list|(
name|sd
operator|->
name|state
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|plexno
operator|>=
literal|0
condition|)
comment|/* we're part of a plex, */
name|update_plex_state
argument_list|(
name|sd
operator|->
name|plexno
argument_list|)
expr_stmt|;
comment|/* update its state */
block|}
end_function

begin_comment
comment|/*  * Force a plex and all its subdisks  * into an 'up' state.  This is a helper  * for update_plex_state.  */
end_comment

begin_function
name|void
name|forceup
parameter_list|(
name|int
name|plexno
parameter_list|)
block|{
name|struct
name|plex
modifier|*
name|plex
decl_stmt|;
name|int
name|sdno
decl_stmt|;
name|plex
operator|=
operator|&
name|PLEX
index|[
name|plexno
index|]
expr_stmt|;
comment|/* point to the plex */
name|plex
operator|->
name|state
operator|=
name|plex_up
expr_stmt|;
comment|/* and bring it up */
comment|/* change the subdisks to up state */
for|for
control|(
name|sdno
operator|=
literal|0
init|;
name|sdno
operator|<
name|plex
operator|->
name|subdisks
condition|;
name|sdno
operator|++
control|)
block|{
name|SD
index|[
name|plex
operator|->
name|sdnos
index|[
name|sdno
index|]
index|]
operator|.
name|state
operator|=
name|sd_up
expr_stmt|;
name|log
argument_list|(
name|LOG_INFO
argument_list|,
comment|/* tell them about it */
literal|"vinum: %s is up\n"
argument_list|,
name|SD
index|[
name|plex
operator|->
name|sdnos
index|[
name|sdno
index|]
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set the state of a plex based on its environment */
end_comment

begin_function
name|void
name|update_plex_state
parameter_list|(
name|int
name|plexno
parameter_list|)
block|{
name|struct
name|plex
modifier|*
name|plex
decl_stmt|;
comment|/* point to our plex */
name|enum
name|plexstate
name|oldstate
decl_stmt|;
name|enum
name|sdstates
name|statemap
decl_stmt|;
comment|/* get a map of the subdisk states */
name|enum
name|volplexstate
name|vps
decl_stmt|;
comment|/* how do we compare with the other plexes? */
name|plex
operator|=
operator|&
name|PLEX
index|[
name|plexno
index|]
expr_stmt|;
comment|/* point to our plex */
name|oldstate
operator|=
name|plex
operator|->
name|state
expr_stmt|;
name|statemap
operator|=
name|sdstatemap
argument_list|(
name|plex
argument_list|)
expr_stmt|;
comment|/* get a map of the subdisk states */
name|vps
operator|=
name|vpstate
argument_list|(
name|plex
argument_list|)
expr_stmt|;
comment|/* how do we compare with the other plexes? */
if|if
condition|(
operator|(
name|statemap
operator|==
name|sd_emptystate
operator|)
comment|/* all subdisks empty */
operator|&&
operator|(
operator|(
name|vps
operator|&
name|volplex_otherup
operator|)
operator|==
literal|0
operator|)
comment|/* and no other plex is up */
operator|&&
operator|(
operator|(
name|plex
operator|->
name|organization
operator|==
name|plex_concat
operator|)
comment|/* and we're not RAID-5 */
operator|||
operator|(
name|plex
operator|->
name|organization
operator|==
name|plex_striped
operator|)
operator|)
condition|)
block|{
name|struct
name|volume
modifier|*
name|vol
init|=
operator|&
name|VOL
index|[
name|plex
operator|->
name|volno
index|]
decl_stmt|;
comment|/* possible volume to which it points */
comment|/* 	 * If we're a striped or concat plex associated with a 	 * volume, none of whose plexes are up, and we're new and 	 * untested, and the volume has the setupstate bit set, we 	 * can pretend to be in a consistent state. 	 * 	 * We need to do this in one swell foop: on the next call 	 * we will no longer be just empty. 	 * 	 * This code assumes that all the other plexes are also 	 * capable of coming up (i.e. all the sds are up), but 	 * that's OK: we'll come back to this function for the 	 * remaining plexes in the volume. 	 */
if|if
condition|(
operator|(
name|plex
operator|->
name|state
operator|==
name|plex_init
operator|)
operator|&&
operator|(
name|plex
operator|->
name|volno
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|vol
operator|->
name|flags
operator|&
name|VF_CONFIG_SETUPSTATE
operator|)
condition|)
block|{
for|for
control|(
name|plexno
operator|=
literal|0
init|;
name|plexno
operator|<
name|vol
operator|->
name|plexes
condition|;
name|plexno
operator|++
control|)
name|forceup
argument_list|(
name|VOL
index|[
name|plex
operator|->
name|volno
index|]
operator|.
name|plex
index|[
name|plexno
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|forceup
argument_list|(
name|plexno
argument_list|)
expr_stmt|;
comment|/* we'll do it */
block|}
elseif|else
if|if
condition|(
name|statemap
operator|==
name|sd_upstate
condition|)
comment|/* 	 * All the subdisks are up.  This also means that 	 * they are consistent, so we can just bring 	 * the plex up 	 */
name|plex
operator|->
name|state
operator|=
name|plex_up
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|statemap
operator|&
operator|(
name|sd_upstate
operator||
name|sd_rebornstate
operator|)
operator|)
operator|==
name|statemap
condition|)
comment|/* all up or reborn */
name|plex
operator|->
name|state
operator|=
name|plex_flaky
expr_stmt|;
elseif|else
if|if
condition|(
name|statemap
operator|&
operator|(
name|sd_upstate
operator||
name|sd_rebornstate
operator|)
condition|)
comment|/* some up or reborn */
name|plex
operator|->
name|state
operator|=
name|plex_corrupt
expr_stmt|;
comment|/* corrupt */
elseif|else
if|if
condition|(
name|statemap
operator|&
operator|(
name|sd_initstate
operator||
name|sd_emptystate
operator|)
condition|)
comment|/* some subdisks empty or initializing */
name|plex
operator|->
name|state
operator|=
name|plex_initializing
expr_stmt|;
else|else
comment|/* nothing at all up */
name|plex
operator|->
name|state
operator|=
name|plex_faulty
expr_stmt|;
if|if
condition|(
name|plex
operator|->
name|state
operator|!=
name|oldstate
condition|)
comment|/* state has changed, */
name|log
argument_list|(
name|LOG_INFO
argument_list|,
comment|/* tell them about it */
literal|"vinum: %s is %s\n"
argument_list|,
name|plex
operator|->
name|name
argument_list|,
name|plex_state
argument_list|(
name|plex
operator|->
name|state
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|plex
operator|->
name|volno
operator|>=
literal|0
condition|)
comment|/* we're part of a volume, */
name|update_volume_state
argument_list|(
name|plex
operator|->
name|volno
argument_list|)
expr_stmt|;
comment|/* update its state */
block|}
end_function

begin_comment
comment|/* Set volume state based on its components */
end_comment

begin_function
name|void
name|update_volume_state
parameter_list|(
name|int
name|volno
parameter_list|)
block|{
name|struct
name|volume
modifier|*
name|vol
decl_stmt|;
comment|/* our volume */
name|int
name|plexno
decl_stmt|;
name|enum
name|volumestate
name|oldstate
decl_stmt|;
name|vol
operator|=
operator|&
name|VOL
index|[
name|volno
index|]
expr_stmt|;
comment|/* point to our volume */
name|oldstate
operator|=
name|vol
operator|->
name|state
expr_stmt|;
for|for
control|(
name|plexno
operator|=
literal|0
init|;
name|plexno
operator|<
name|vol
operator|->
name|plexes
condition|;
name|plexno
operator|++
control|)
block|{
name|struct
name|plex
modifier|*
name|plex
init|=
operator|&
name|PLEX
index|[
name|vol
operator|->
name|plex
index|[
name|plexno
index|]
index|]
decl_stmt|;
comment|/* point to the plex */
if|if
condition|(
name|plex
operator|->
name|state
operator|>=
name|plex_corrupt
condition|)
block|{
comment|/* something accessible, */
name|vol
operator|->
name|state
operator|=
name|volume_up
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|plexno
operator|==
name|vol
operator|->
name|plexes
condition|)
comment|/* didn't find an up plex */
name|vol
operator|->
name|state
operator|=
name|volume_down
expr_stmt|;
if|if
condition|(
name|vol
operator|->
name|state
operator|!=
name|oldstate
condition|)
block|{
comment|/* state changed */
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"vinum: %s is %s\n"
argument_list|,
name|vol
operator|->
name|name
argument_list|,
name|volume_state
argument_list|(
name|vol
operator|->
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|save_config
argument_list|()
expr_stmt|;
comment|/* save the updated configuration */
block|}
block|}
end_function

begin_comment
comment|/*  * Called from request routines when they find  * a subdisk which is not kosher.  Decide whether  * it warrants changing the state.  Return  * REQUEST_DOWN if we can't use the subdisk,  * REQUEST_OK if we can.  */
end_comment

begin_comment
comment|/*  * A prior version of this function checked the plex  * state as well.  At the moment, consider plex states  * information for the user only.  We'll ignore them  * and use the subdisk state only.  The last version of  * this file with the old logic was 2.7. XXX  */
end_comment

begin_function
name|enum
name|requeststatus
name|checksdstate
parameter_list|(
name|struct
name|sd
modifier|*
name|sd
parameter_list|,
name|struct
name|request
modifier|*
name|rq
parameter_list|,
name|daddr_t
name|diskaddr
parameter_list|,
name|daddr_t
name|diskend
parameter_list|)
block|{
name|struct
name|plex
modifier|*
name|plex
init|=
operator|&
name|PLEX
index|[
name|sd
operator|->
name|plexno
index|]
decl_stmt|;
name|int
name|writeop
init|=
operator|(
name|rq
operator|->
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|==
literal|0
decl_stmt|;
comment|/* note if we're writing */
switch|switch
condition|(
name|sd
operator|->
name|state
condition|)
block|{
comment|/* We shouldn't get called if the subdisk is up */
case|case
name|sd_up
case|:
return|return
name|REQUEST_OK
return|;
case|case
name|sd_reviving
case|:
comment|/* 	 * Access to a reviving subdisk depends on the 	 * organization of the plex:  	 * - If it's concatenated, access the subdisk up to its current 	 *   revive point.  If we want to write to the subdisk overlapping the 	 *   current revive block, set the conflict flag in the request, asking 	 *   the caller to put the request on the wait list, which will be 	 *   attended to by revive_block when it's done. 	 * - if it's striped, we can't do it (we could do some hairy 	 *   calculations, but it's unlikely to work). 	 * - if it's RAID-5, we can do it as long as only one 	 *   subdisk is down 	 */
if|if
condition|(
name|plex
operator|->
name|state
operator|==
name|plex_striped
condition|)
comment|/* plex is striped, */
return|return
name|REQUEST_DOWN
return|;
comment|/* can't access it now */
if|if
condition|(
name|diskaddr
operator|>
operator|(
name|sd
operator|->
name|revived
operator|+
name|sd
operator|->
name|plexoffset
operator|+
operator|(
name|sd
operator|->
name|revive_blocksize
operator|>>
name|DEV_BSHIFT
operator|)
operator|)
condition|)
comment|/* we're beyond the end */
return|return
name|REQUEST_DOWN
return|;
comment|/* don't take the sd down again... */
elseif|else
if|if
condition|(
name|diskend
operator|>
operator|(
name|sd
operator|->
name|revived
operator|+
name|sd
operator|->
name|plexoffset
operator|)
condition|)
block|{
comment|/* we finish beyond the end */
if|if
condition|(
name|writeop
condition|)
block|{
name|rq
operator|->
name|flags
operator||=
name|XFR_REVIVECONFLICT
expr_stmt|;
comment|/* note a potential conflict */
name|rq
operator|->
name|sdno
operator|=
name|sd
operator|->
name|sdno
expr_stmt|;
comment|/* and which sd last caused it */
block|}
else|else
return|return
name|REQUEST_DOWN
return|;
comment|/* can't read this yet */
block|}
return|return
name|REQUEST_OK
return|;
case|case
name|sd_reborn
case|:
if|if
condition|(
name|writeop
condition|)
return|return
name|REQUEST_OK
return|;
comment|/* always write to a reborn disk */
else|else
comment|/* don't allow a read */
comment|/* 	       * Handle the mapping.  We don't want to reject 	       * a read request to a reborn subdisk if that's 	       * all we have. XXX 	     */
return|return
name|REQUEST_DOWN
return|;
case|case
name|sd_down
case|:
if|if
condition|(
name|writeop
condition|)
comment|/* writing to a consistent down disk */
name|set_sd_state
argument_list|(
name|sd
operator|->
name|sdno
argument_list|,
name|sd_obsolete
argument_list|,
name|setstate_force
argument_list|)
expr_stmt|;
comment|/* it's not consistent now */
return|return
name|REQUEST_DOWN
return|;
comment|/* and it's down one way or another */
case|case
name|sd_crashed
case|:
if|if
condition|(
name|writeop
condition|)
comment|/* writing to a consistent down disk */
name|set_sd_state
argument_list|(
name|sd
operator|->
name|sdno
argument_list|,
name|sd_stale
argument_list|,
name|setstate_force
argument_list|)
expr_stmt|;
comment|/* it's not consistent now */
return|return
name|REQUEST_DOWN
return|;
comment|/* and it's down one way or another */
default|default:
return|return
name|REQUEST_DOWN
return|;
block|}
block|}
end_function

begin_comment
comment|/* return a state map for the subdisks of a plex */
end_comment

begin_function
name|enum
name|sdstates
name|sdstatemap
parameter_list|(
name|struct
name|plex
modifier|*
name|plex
parameter_list|)
block|{
name|int
name|sdno
decl_stmt|;
name|enum
name|sdstates
name|statemap
init|=
literal|0
decl_stmt|;
comment|/* note the states we find */
name|plex
operator|->
name|sddowncount
operator|=
literal|0
expr_stmt|;
comment|/* no subdisks down yet */
for|for
control|(
name|sdno
operator|=
literal|0
init|;
name|sdno
operator|<
name|plex
operator|->
name|subdisks
condition|;
name|sdno
operator|++
control|)
block|{
name|struct
name|sd
modifier|*
name|sd
init|=
operator|&
name|SD
index|[
name|plex
operator|->
name|sdnos
index|[
name|sdno
index|]
index|]
decl_stmt|;
comment|/* point to the subdisk */
switch|switch
condition|(
name|sd
operator|->
name|state
condition|)
block|{
case|case
name|sd_empty
case|:
name|statemap
operator||=
name|sd_emptystate
expr_stmt|;
operator|(
name|plex
operator|->
name|sddowncount
operator|)
operator|++
expr_stmt|;
comment|/* another unusable subdisk */
break|break;
case|case
name|sd_init
case|:
name|statemap
operator||=
name|sd_initstate
expr_stmt|;
operator|(
name|plex
operator|->
name|sddowncount
operator|)
operator|++
expr_stmt|;
comment|/* another unusable subdisk */
break|break;
case|case
name|sd_down
case|:
name|statemap
operator||=
name|sd_downstate
expr_stmt|;
operator|(
name|plex
operator|->
name|sddowncount
operator|)
operator|++
expr_stmt|;
comment|/* another unusable subdisk */
break|break;
case|case
name|sd_crashed
case|:
name|statemap
operator||=
name|sd_crashedstate
expr_stmt|;
operator|(
name|plex
operator|->
name|sddowncount
operator|)
operator|++
expr_stmt|;
comment|/* another unusable subdisk */
break|break;
case|case
name|sd_obsolete
case|:
name|statemap
operator||=
name|sd_obsolete
expr_stmt|;
operator|(
name|plex
operator|->
name|sddowncount
operator|)
operator|++
expr_stmt|;
comment|/* another unusable subdisk */
break|break;
case|case
name|sd_stale
case|:
name|statemap
operator||=
name|sd_stalestate
expr_stmt|;
operator|(
name|plex
operator|->
name|sddowncount
operator|)
operator|++
expr_stmt|;
comment|/* another unusable subdisk */
break|break;
case|case
name|sd_reborn
case|:
name|statemap
operator||=
name|sd_rebornstate
expr_stmt|;
break|break;
case|case
name|sd_up
case|:
name|statemap
operator||=
name|sd_upstate
expr_stmt|;
break|break;
case|case
name|sd_initializing
case|:
name|statemap
operator||=
name|sd_initstate
expr_stmt|;
operator|(
name|plex
operator|->
name|sddowncount
operator|)
operator|++
expr_stmt|;
comment|/* another unusable subdisk */
break|break;
case|case
name|sd_unallocated
case|:
case|case
name|sd_uninit
case|:
case|case
name|sd_reviving
case|:
case|case
name|sd_referenced
case|:
name|statemap
operator||=
name|sd_otherstate
expr_stmt|;
operator|(
name|plex
operator|->
name|sddowncount
operator|)
operator|++
expr_stmt|;
comment|/* another unusable subdisk */
block|}
block|}
return|return
name|statemap
return|;
block|}
end_function

begin_comment
comment|/* determine the state of the volume relative to this plex */
end_comment

begin_function
name|enum
name|volplexstate
name|vpstate
parameter_list|(
name|struct
name|plex
modifier|*
name|plex
parameter_list|)
block|{
name|struct
name|volume
modifier|*
name|vol
decl_stmt|;
name|enum
name|volplexstate
name|state
init|=
name|volplex_onlyusdown
decl_stmt|;
comment|/* state to return */
name|int
name|plexno
decl_stmt|;
if|if
condition|(
name|plex
operator|->
name|volno
operator|<
literal|0
condition|)
comment|/* not associated with a volume */
return|return
name|volplex_onlyusdown
return|;
comment|/* assume the worst */
name|vol
operator|=
operator|&
name|VOL
index|[
name|plex
operator|->
name|volno
index|]
expr_stmt|;
comment|/* point to our volume */
for|for
control|(
name|plexno
operator|=
literal|0
init|;
name|plexno
operator|<
name|vol
operator|->
name|plexes
condition|;
name|plexno
operator|++
control|)
block|{
if|if
condition|(
operator|&
name|PLEX
index|[
name|vol
operator|->
name|plex
index|[
name|plexno
index|]
index|]
operator|==
name|plex
condition|)
block|{
comment|/* us */
if|if
condition|(
name|PLEX
index|[
name|vol
operator|->
name|plex
index|[
name|plexno
index|]
index|]
operator|.
name|state
operator|>=
name|plex_flaky
condition|)
comment|/* are we up? */
name|state
operator||=
name|volplex_onlyus
expr_stmt|;
comment|/* yes */
block|}
else|else
block|{
if|if
condition|(
name|PLEX
index|[
name|vol
operator|->
name|plex
index|[
name|plexno
index|]
index|]
operator|.
name|state
operator|>=
name|plex_flaky
condition|)
comment|/* not us */
name|state
operator||=
name|volplex_otherup
expr_stmt|;
comment|/* and when they were up, they were up */
else|else
name|state
operator||=
name|volplex_alldown
expr_stmt|;
comment|/* and when they were down, they were down */
block|}
block|}
return|return
name|state
return|;
comment|/* and when they were only halfway up */
block|}
end_function

begin_comment
comment|/* they were neither up nor down */
end_comment

begin_comment
comment|/* Check if all bits b are set in a */
end_comment

begin_function_decl
name|int
name|allset
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|allset
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
operator|(
name|a
operator|&
name|b
operator|)
operator|==
name|b
return|;
block|}
end_function

begin_comment
comment|/* Invalidate the subdisks belonging to a plex */
end_comment

begin_function
name|void
name|invalidate_subdisks
parameter_list|(
name|struct
name|plex
modifier|*
name|plex
parameter_list|,
name|enum
name|sdstate
name|state
parameter_list|)
block|{
name|int
name|sdno
decl_stmt|;
for|for
control|(
name|sdno
operator|=
literal|0
init|;
name|sdno
operator|<
name|plex
operator|->
name|subdisks
condition|;
name|sdno
operator|++
control|)
block|{
comment|/* for each subdisk */
name|struct
name|sd
modifier|*
name|sd
init|=
operator|&
name|SD
index|[
name|plex
operator|->
name|sdnos
index|[
name|sdno
index|]
index|]
decl_stmt|;
switch|switch
condition|(
name|sd
operator|->
name|state
condition|)
block|{
case|case
name|sd_unallocated
case|:
case|case
name|sd_uninit
case|:
case|case
name|sd_init
case|:
case|case
name|sd_initializing
case|:
case|case
name|sd_empty
case|:
case|case
name|sd_obsolete
case|:
case|case
name|sd_stale
case|:
case|case
name|sd_crashed
case|:
case|case
name|sd_down
case|:
case|case
name|sd_referenced
case|:
break|break;
case|case
name|sd_reviving
case|:
case|case
name|sd_reborn
case|:
case|case
name|sd_up
case|:
name|set_sd_state
argument_list|(
name|plex
operator|->
name|sdnos
index|[
name|sdno
index|]
argument_list|,
name|state
argument_list|,
name|setstate_force
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Start an object, in other words do what we can to get it up.  * This is called from vinumioctl (VINUMSTART).  * Return error indications via ioctl_reply  */
end_comment

begin_function
name|void
name|start_object
parameter_list|(
name|struct
name|vinum_ioctl_msg
modifier|*
name|data
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|int
name|objindex
init|=
name|data
operator|->
name|index
decl_stmt|;
comment|/* data gets overwritten */
name|struct
name|_ioctl_reply
modifier|*
name|ioctl_reply
init|=
operator|(
expr|struct
name|_ioctl_reply
operator|*
operator|)
name|data
decl_stmt|;
comment|/* format for returning replies */
name|enum
name|setstateflags
name|flags
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|force
operator|!=
literal|0
condition|)
comment|/* are we going to use force? */
name|flags
operator|=
name|setstate_force
expr_stmt|;
comment|/* yes */
else|else
name|flags
operator|=
name|setstate_none
expr_stmt|;
comment|/* no */
switch|switch
condition|(
name|data
operator|->
name|type
condition|)
block|{
case|case
name|drive_object
case|:
name|status
operator|=
name|set_drive_state
argument_list|(
name|objindex
argument_list|,
name|drive_up
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|DRIVE
index|[
name|objindex
index|]
operator|.
name|state
operator|!=
name|drive_up
condition|)
comment|/* set status on whether we really did it */
name|ioctl_reply
operator|->
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
name|ioctl_reply
operator|->
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|sd_object
case|:
if|if
condition|(
name|SD
index|[
name|objindex
index|]
operator|.
name|state
operator|==
name|sd_reviving
condition|)
block|{
comment|/* reviving, */
name|ioctl_reply
operator|->
name|error
operator|=
name|revive_block
argument_list|(
name|objindex
argument_list|)
expr_stmt|;
comment|/* revive another block */
name|ioctl_reply
operator|->
name|msg
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* no comment */
return|return;
block|}
name|status
operator|=
name|set_sd_state
argument_list|(
name|objindex
argument_list|,
name|sd_up
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* set state */
if|if
condition|(
name|status
operator|==
name|EAGAIN
condition|)
block|{
comment|/* first revive, */
name|ioctl_reply
operator|->
name|error
operator|=
name|revive_block
argument_list|(
name|objindex
argument_list|)
expr_stmt|;
comment|/* revive the first block */
name|ioctl_reply
operator|->
name|error
operator|=
name|EAGAIN
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|SD
index|[
name|objindex
index|]
operator|.
name|state
operator|!=
name|sd_up
condition|)
comment|/* set status on whether we really did it */
name|ioctl_reply
operator|->
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
name|ioctl_reply
operator|->
name|error
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|plex_object
case|:
name|status
operator|=
name|set_plex_state
argument_list|(
name|objindex
argument_list|,
name|plex_up
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|PLEX
index|[
name|objindex
index|]
operator|.
name|state
operator|!=
name|plex_up
condition|)
comment|/* set status on whether we really did it */
name|ioctl_reply
operator|->
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
name|ioctl_reply
operator|->
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|volume_object
case|:
name|status
operator|=
name|set_volume_state
argument_list|(
name|objindex
argument_list|,
name|volume_up
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|VOL
index|[
name|objindex
index|]
operator|.
name|state
operator|!=
name|volume_up
condition|)
comment|/* set status on whether we really did it */
name|ioctl_reply
operator|->
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
name|ioctl_reply
operator|->
name|error
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|ioctl_reply
operator|->
name|error
operator|=
name|EINVAL
expr_stmt|;
name|strcpy
argument_list|(
name|ioctl_reply
operator|->
name|msg
argument_list|,
literal|"Invalid object type"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*      * There's no point in saying anything here:      * the userland program does it better      */
name|ioctl_reply
operator|->
name|msg
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Stop an object, in other words do what we can to get it down  * This is called from vinumioctl (VINUMSTOP).  * Return error indications via ioctl_reply.  */
end_comment

begin_function
name|void
name|stop_object
parameter_list|(
name|struct
name|vinum_ioctl_msg
modifier|*
name|data
parameter_list|)
block|{
name|int
name|status
init|=
literal|1
decl_stmt|;
name|int
name|objindex
init|=
name|data
operator|->
name|index
decl_stmt|;
comment|/* save the number from change */
name|struct
name|_ioctl_reply
modifier|*
name|ioctl_reply
init|=
operator|(
expr|struct
name|_ioctl_reply
operator|*
operator|)
name|data
decl_stmt|;
comment|/* format for returning replies */
switch|switch
condition|(
name|data
operator|->
name|type
condition|)
block|{
case|case
name|drive_object
case|:
name|status
operator|=
name|set_drive_state
argument_list|(
name|objindex
argument_list|,
name|drive_down
argument_list|,
name|data
operator|->
name|force
argument_list|)
expr_stmt|;
break|break;
case|case
name|sd_object
case|:
name|status
operator|=
name|set_sd_state
argument_list|(
name|objindex
argument_list|,
name|sd_down
argument_list|,
name|data
operator|->
name|force
argument_list|)
expr_stmt|;
break|break;
case|case
name|plex_object
case|:
name|status
operator|=
name|set_plex_state
argument_list|(
name|objindex
argument_list|,
name|plex_down
argument_list|,
name|data
operator|->
name|force
argument_list|)
expr_stmt|;
break|break;
case|case
name|volume_object
case|:
name|status
operator|=
name|set_volume_state
argument_list|(
name|objindex
argument_list|,
name|volume_down
argument_list|,
name|data
operator|->
name|force
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ioctl_reply
operator|->
name|error
operator|=
name|EINVAL
expr_stmt|;
name|strcpy
argument_list|(
name|ioctl_reply
operator|->
name|msg
argument_list|,
literal|"Invalid object type"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ioctl_reply
operator|->
name|msg
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
comment|/* couldn't do it */
name|ioctl_reply
operator|->
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
name|ioctl_reply
operator|->
name|error
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * VINUM_SETSTATE ioctl: set an object state  * msg is the message passed by the user  */
end_comment

begin_function
name|void
name|setstate
parameter_list|(
name|struct
name|vinum_ioctl_msg
modifier|*
name|msg
parameter_list|)
block|{
name|int
name|sdno
decl_stmt|;
name|struct
name|sd
modifier|*
name|sd
decl_stmt|;
name|struct
name|plex
modifier|*
name|plex
decl_stmt|;
name|struct
name|_ioctl_reply
modifier|*
name|ioctl_reply
init|=
operator|(
expr|struct
name|_ioctl_reply
operator|*
operator|)
name|msg
decl_stmt|;
comment|/* format for returning replies */
switch|switch
condition|(
name|msg
operator|->
name|state
condition|)
block|{
case|case
name|object_down
case|:
name|stop_object
argument_list|(
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|object_initializing
case|:
switch|switch
condition|(
name|msg
operator|->
name|type
condition|)
block|{
case|case
name|sd_object
case|:
name|sd
operator|=
operator|&
name|SD
index|[
name|msg
operator|->
name|index
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|msg
operator|->
name|index
operator|>=
name|vinum_conf
operator|.
name|subdisks_used
operator|)
operator|||
operator|(
name|sd
operator|->
name|state
operator|==
name|sd_unallocated
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|ioctl_reply
operator|->
name|msg
argument_list|,
literal|"Invalid subdisk %d"
argument_list|,
name|msg
operator|->
name|index
argument_list|)
expr_stmt|;
name|ioctl_reply
operator|->
name|error
operator|=
name|EFAULT
expr_stmt|;
return|return;
block|}
name|set_sd_state
argument_list|(
name|msg
operator|->
name|index
argument_list|,
name|sd_initializing
argument_list|,
name|msg
operator|->
name|force
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|state
operator|!=
name|sd_initializing
condition|)
block|{
name|strcpy
argument_list|(
name|ioctl_reply
operator|->
name|msg
argument_list|,
literal|"Can't set state"
argument_list|)
expr_stmt|;
name|ioctl_reply
operator|->
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
name|ioctl_reply
operator|->
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|plex_object
case|:
name|plex
operator|=
operator|&
name|PLEX
index|[
name|msg
operator|->
name|index
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|msg
operator|->
name|index
operator|>=
name|vinum_conf
operator|.
name|plexes_used
operator|)
operator|||
operator|(
name|plex
operator|->
name|state
operator|==
name|plex_unallocated
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|ioctl_reply
operator|->
name|msg
argument_list|,
literal|"Invalid plex %d"
argument_list|,
name|msg
operator|->
name|index
argument_list|)
expr_stmt|;
name|ioctl_reply
operator|->
name|error
operator|=
name|EFAULT
expr_stmt|;
return|return;
block|}
name|set_plex_state
argument_list|(
name|msg
operator|->
name|index
argument_list|,
name|plex_initializing
argument_list|,
name|msg
operator|->
name|force
argument_list|)
expr_stmt|;
if|if
condition|(
name|plex
operator|->
name|state
operator|!=
name|plex_initializing
condition|)
block|{
name|strcpy
argument_list|(
name|ioctl_reply
operator|->
name|msg
argument_list|,
literal|"Can't set state"
argument_list|)
expr_stmt|;
name|ioctl_reply
operator|->
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|ioctl_reply
operator|->
name|error
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sdno
operator|=
literal|0
init|;
name|sdno
operator|<
name|plex
operator|->
name|subdisks
condition|;
name|sdno
operator|++
control|)
block|{
name|sd
operator|=
operator|&
name|SD
index|[
name|plex
operator|->
name|sdnos
index|[
name|sdno
index|]
index|]
expr_stmt|;
name|set_sd_state
argument_list|(
name|plex
operator|->
name|sdnos
index|[
name|sdno
index|]
argument_list|,
name|sd_initializing
argument_list|,
name|msg
operator|->
name|force
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|state
operator|!=
name|sd_initializing
condition|)
block|{
name|strcpy
argument_list|(
name|ioctl_reply
operator|->
name|msg
argument_list|,
literal|"Can't set state"
argument_list|)
expr_stmt|;
name|ioctl_reply
operator|->
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
block|}
block|}
break|break;
default|default:
name|strcpy
argument_list|(
name|ioctl_reply
operator|->
name|msg
argument_list|,
literal|"Invalid object"
argument_list|)
expr_stmt|;
name|ioctl_reply
operator|->
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
case|case
name|object_up
case|:
name|start_object
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

