begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1997, 1998, 1999  *	Nan Yang Computer Services Limited.  All rights reserved.  *  *  Parts copyright (c) 1997, 1998 Cybernet Corporation, NetMAX project.  *  *  Written by Greg Lehey  *  *  This software is distributed under the so-called ``Berkeley  *  License'':  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Nan Yang Computer  *      Services Limited.  * 4. Neither the name of the Company nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * This software is provided ``as is'', and any express or implied  * warranties, including, but not limited to, the implied warranties of  * merchantability and fitness for a particular purpose are disclaimed.  * In no event shall the company or contributors be liable for any  * direct, indirect, incidental, special, exemplary, or consequential  * damages (including, but not limited to, procurement of substitute  * goods or services; loss of use, data, or profits; or business  * interruption) however caused and on any theory of liability, whether  * in contract, strict liability, or tort (including negligence or  * otherwise) arising in any way out of the use of this software, even if  * advised of the possibility of such damage.  *  * $Id: vinumstate.c,v 2.18 2000/05/10 07:30:50 grog Exp grog $  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<dev/vinum/vinumhdr.h>
end_include

begin_include
include|#
directive|include
file|<dev/vinum/request.h>
end_include

begin_comment
comment|/* Update drive state */
end_comment

begin_comment
comment|/* Return 1 if the state changes, otherwise 0 */
end_comment

begin_function
name|int
name|set_drive_state
parameter_list|(
name|int
name|driveno
parameter_list|,
name|enum
name|drivestate
name|newstate
parameter_list|,
name|enum
name|setstateflags
name|flags
parameter_list|)
block|{
name|struct
name|drive
modifier|*
name|drive
init|=
operator|&
name|DRIVE
index|[
name|driveno
index|]
decl_stmt|;
name|int
name|oldstate
init|=
name|drive
operator|->
name|state
decl_stmt|;
name|int
name|sdno
decl_stmt|;
if|if
condition|(
name|drive
operator|->
name|state
operator|==
name|drive_unallocated
condition|)
comment|/* no drive to do anything with, */
return|return
literal|0
return|;
if|if
condition|(
name|newstate
operator|==
name|oldstate
condition|)
comment|/* don't change it if it's not different */
return|return
literal|1
return|;
comment|/* all OK */
if|if
condition|(
operator|(
name|newstate
operator|==
name|drive_down
operator|)
comment|/* the drive's going down */
operator|&&
operator|(
operator|!
operator|(
name|flags
operator|&
name|setstate_force
operator|)
operator|)
operator|&&
operator|(
name|drive
operator|->
name|opencount
operator|!=
literal|0
operator|)
condition|)
comment|/* we can't do it */
return|return
literal|0
return|;
comment|/* don't do it */
name|drive
operator|->
name|state
operator|=
name|newstate
expr_stmt|;
comment|/* set the state */
if|if
condition|(
name|drive
operator|->
name|label
operator|.
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
comment|/* we have a name, */
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"vinum: drive %s is %s\n"
argument_list|,
name|drive
operator|->
name|label
operator|.
name|name
argument_list|,
name|drive_state
argument_list|(
name|drive
operator|->
name|state
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|drive
operator|->
name|state
operator|!=
name|oldstate
condition|)
block|{
comment|/* state has changed */
for|for
control|(
name|sdno
operator|=
literal|0
init|;
name|sdno
operator|<
name|vinum_conf
operator|.
name|subdisks_allocated
condition|;
name|sdno
operator|++
control|)
block|{
comment|/* find this drive's subdisks */
if|if
condition|(
operator|(
name|SD
index|[
name|sdno
index|]
operator|.
name|state
operator|>=
name|sd_referenced
operator|)
operator|&&
operator|(
name|SD
index|[
name|sdno
index|]
operator|.
name|driveno
operator|==
name|driveno
operator|)
condition|)
comment|/* belongs to this drive */
name|update_sd_state
argument_list|(
name|sdno
argument_list|)
expr_stmt|;
comment|/* update the state */
block|}
block|}
if|if
condition|(
name|newstate
operator|==
name|drive_up
condition|)
block|{
comment|/* want to bring it up */
if|if
condition|(
operator|(
name|drive
operator|->
name|flags
operator|&
name|VF_OPEN
operator|)
operator|==
literal|0
condition|)
comment|/* should be open, but we're not */
name|init_drive
argument_list|(
name|drive
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* which changes the state again */
block|}
else|else
comment|/* taking it down or worse */
name|queue_daemon_request
argument_list|(
name|daemonrq_closedrive
argument_list|,
comment|/* get the daemon to close it */
operator|(
expr|union
name|daemoninfo
operator|)
name|drive
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|setstate_configuring
operator|)
operator|==
literal|0
condition|)
comment|/* configuring? */
name|save_config
argument_list|()
expr_stmt|;
comment|/* no: save the updated configuration now */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Try to set the subdisk state.  Return 1 if state changed to  * what we wanted, -1 if it changed to something else, and 0  * if no change.  *  * This routine is called both from the user (up, down states only)  * and internally.  *  * The setstate_force bit in the flags enables the state change even  * if it could be dangerous to data consistency.  It shouldn't allow  * nonsense.  */
end_comment

begin_function
name|int
name|set_sd_state
parameter_list|(
name|int
name|sdno
parameter_list|,
name|enum
name|sdstate
name|newstate
parameter_list|,
name|enum
name|setstateflags
name|flags
parameter_list|)
block|{
name|struct
name|sd
modifier|*
name|sd
init|=
operator|&
name|SD
index|[
name|sdno
index|]
decl_stmt|;
name|struct
name|plex
modifier|*
name|plex
decl_stmt|;
name|struct
name|volume
modifier|*
name|vol
decl_stmt|;
name|int
name|oldstate
init|=
name|sd
operator|->
name|state
decl_stmt|;
name|int
name|status
init|=
literal|1
decl_stmt|;
comment|/* status to return */
if|if
condition|(
name|newstate
operator|==
name|oldstate
condition|)
comment|/* already there, */
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|sd
operator|->
name|state
operator|==
name|sd_unallocated
condition|)
comment|/* no subdisk to do anything with, */
return|return
literal|0
return|;
comment|/* can't do it */
if|if
condition|(
name|sd
operator|->
name|driveoffset
operator|<
literal|0
condition|)
block|{
comment|/* not allocated space */
name|sd
operator|->
name|state
operator|=
name|sd_down
expr_stmt|;
if|if
condition|(
name|newstate
operator|!=
name|sd_down
condition|)
block|{
if|if
condition|(
name|sd
operator|->
name|plexno
operator|>=
literal|0
condition|)
name|sdstatemap
argument_list|(
operator|&
name|PLEX
index|[
name|sd
operator|->
name|plexno
index|]
argument_list|)
expr_stmt|;
comment|/* count up subdisks */
return|return
operator|-
literal|1
return|;
block|}
block|}
else|else
block|{
comment|/* space allocated */
switch|switch
condition|(
name|newstate
condition|)
block|{
case|case
name|sd_down
case|:
comment|/* take it down? */
comment|/* 	     * If we're attached to a plex, and we're 	     * not reborn, we won't go down without 	     * use of force. 	     */
if|if
condition|(
operator|(
operator|!
name|flags
operator|&
name|setstate_force
operator|)
operator|&&
operator|(
name|sd
operator|->
name|plexno
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|sd
operator|->
name|state
operator|!=
name|sd_reborn
operator|)
condition|)
return|return
literal|0
return|;
comment|/* don't do it */
break|break;
case|case
name|sd_initialized
case|:
if|if
condition|(
operator|(
name|sd
operator|->
name|state
operator|==
name|sd_initializing
operator|)
comment|/* we were initializing */
operator|||
operator|(
name|flags
operator|&
name|setstate_force
operator|)
condition|)
comment|/* or we forced it */
break|break;
return|return
literal|0
return|;
comment|/* can't do it otherwise */
case|case
name|sd_up
case|:
if|if
condition|(
name|DRIVE
index|[
name|sd
operator|->
name|driveno
index|]
operator|.
name|state
operator|!=
name|drive_up
condition|)
comment|/* can't bring the sd up if the drive isn't, */
return|return
literal|0
return|;
comment|/* not even by force */
if|if
condition|(
name|flags
operator|&
name|setstate_force
condition|)
comment|/* forcing it, */
break|break;
comment|/* just do it, and damn the consequences */
switch|switch
condition|(
name|sd
operator|->
name|state
condition|)
block|{
comment|/* 		 * Perform the necessary tests.  To allow 		 * the state transition, just break out of 		 * the switch. 		 */
case|case
name|sd_crashed
case|:
case|case
name|sd_reborn
case|:
case|case
name|sd_down
case|:
comment|/* been down, no data lost */
comment|/* 		 * If we're associated with a plex, and 		 * the plex isn't up, or we're the only 		 * subdisk in the plex, we can do it. 		 */
if|if
condition|(
operator|(
name|sd
operator|->
name|plexno
operator|>=
literal|0
operator|)
operator|&&
operator|(
operator|(
operator|(
name|PLEX
index|[
name|sd
operator|->
name|plexno
index|]
operator|.
name|state
operator|<
name|plex_firstup
operator|)
operator|||
operator|(
name|PLEX
index|[
name|sd
operator|->
name|plexno
index|]
operator|.
name|subdisks
operator|>
literal|1
operator|)
operator|)
operator|)
condition|)
break|break;
comment|/* do it */
if|if
condition|(
name|oldstate
operator|!=
name|sd_reborn
condition|)
block|{
name|sd
operator|->
name|state
operator|=
name|sd_reborn
expr_stmt|;
comment|/* here it is again */
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"vinum: %s is %s, not %s\n"
argument_list|,
name|sd
operator|->
name|name
argument_list|,
name|sd_state
argument_list|(
name|sd
operator|->
name|state
argument_list|)
argument_list|,
name|sd_state
argument_list|(
name|newstate
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|status
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|sd_init
case|:
comment|/* brand new */
if|if
condition|(
name|flags
operator|&
name|setstate_configuring
condition|)
comment|/* we're doing this while configuring */
break|break;
comment|/* otherwise it's like being empty */
comment|/* FALLTHROUGH */
case|case
name|sd_empty
case|:
case|case
name|sd_initialized
case|:
comment|/* 		 * If we're not part of a plex, or the 		 * plex is not part of a volume with other 		 * plexes which are up, we can come up 		 * without being inconsistent. 		 * 		 * If we're part of a parity plex, we'll 		 * come up if the caller uses force.  This 		 * is the way we bring them up after 		 * initialization. 		 */
if|if
condition|(
operator|(
name|sd
operator|->
name|plexno
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|vpstate
argument_list|(
operator|&
name|PLEX
index|[
name|sd
operator|->
name|plexno
index|]
argument_list|)
operator|&
name|volplex_otherup
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|isparity
argument_list|(
operator|(
operator|&
name|PLEX
index|[
name|sd
operator|->
name|plexno
index|]
operator|)
argument_list|)
operator|&&
operator|(
name|flags
operator|&
name|setstate_force
operator|)
operator|)
condition|)
break|break;
comment|/* Otherwise it's just out of date */
comment|/* FALLTHROUGH */
case|case
name|sd_stale
case|:
comment|/* out of date info, need reviving */
case|case
name|sd_obsolete
case|:
comment|/*  		 * 1.  If the subdisk is not part of a 		 *     plex, bring it up, don't revive. 		 * 		 * 2.  If the subdisk is part of a 		 *     one-plex volume or an unattached 		 *     plex, and it's not RAID-4 or 		 *     RAID-5, we *can't revive*.  The 		 *     subdisk doesn't change its state. 		 * 		 * 3.  If the subdisk is part of a 		 *     one-plex volume or an unattached 		 *     plex, and it's RAID-4 or RAID-5, 		 *     but more than one subdisk is down, 		 *     we *still can't revive*.  The 		 *     subdisk doesn't change its state. 		 * 		 * 4.  If the subdisk is part of a 		 *     multi-plex volume, we'll change to 		 *     reviving and let the revive 		 *     routines find out whether it will 		 *     work or not.  If they don't, the 		 *     revive stops with an error message, 		 *     but the state doesn't change 		 *     (FWIW). 		 */
if|if
condition|(
name|sd
operator|->
name|plexno
operator|<
literal|0
condition|)
comment|/* no plex associated, */
break|break;
comment|/* bring it up */
name|plex
operator|=
operator|&
name|PLEX
index|[
name|sd
operator|->
name|plexno
index|]
expr_stmt|;
if|if
condition|(
name|plex
operator|->
name|volno
operator|>=
literal|0
condition|)
comment|/* have a volume */
name|vol
operator|=
operator|&
name|VOL
index|[
name|plex
operator|->
name|volno
index|]
expr_stmt|;
else|else
name|vol
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * We can't do it if: 		 * 		 * 1: we don't have a volume 		 * 2: we're the only plex in the volume 		 * 3: we're a RAID-4 or RAID-5 plex, and 		 *    more than one subdisk is down. 		 */
if|if
condition|(
operator|(
operator|(
name|vol
operator|==
name|NULL
operator|)
operator|||
operator|(
name|vol
operator|->
name|plexes
operator|==
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
operator|!
name|isparity
argument_list|(
name|plex
argument_list|)
operator|)
operator|||
operator|(
name|plex
operator|->
name|sddowncount
operator|>
literal|1
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|sd
operator|->
name|state
operator|==
name|sd_initializing
condition|)
comment|/* it's finished initializing  */
name|sd
operator|->
name|state
operator|=
name|sd_initialized
expr_stmt|;
else|else
return|return
literal|0
return|;
comment|/* can't do it */
block|}
else|else
block|{
name|sd
operator|->
name|state
operator|=
name|sd_reviving
expr_stmt|;
comment|/* put in reviving state */
name|sd
operator|->
name|revived
operator|=
literal|0
expr_stmt|;
comment|/* nothing done yet */
name|status
operator|=
name|EAGAIN
expr_stmt|;
comment|/* need to repeat */
block|}
break|break;
case|case
name|sd_reviving
case|:
if|if
condition|(
name|flags
operator|&
name|setstate_force
condition|)
comment|/* insist, */
break|break;
return|return
name|EAGAIN
return|;
comment|/* no, try again */
default|default:
comment|/* can't do it */
comment|/* 		 * There's no way to bring subdisks up directly from 		 * other states.  First they need to be initialized 		 * or revived. 		 */
return|return
literal|0
return|;
block|}
break|break;
default|default:
comment|/* other ones, only internal with force */
if|if
condition|(
operator|(
name|flags
operator|&
name|setstate_force
operator|)
operator|==
literal|0
condition|)
comment|/* no force?  What's this? */
return|return
literal|0
return|;
comment|/* don't do it */
block|}
block|}
if|if
condition|(
name|status
operator|==
literal|1
condition|)
block|{
comment|/* we can do it, */
name|sd
operator|->
name|state
operator|=
name|newstate
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|setstate_force
condition|)
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"vinum: %s is %s by force\n"
argument_list|,
name|sd
operator|->
name|name
argument_list|,
name|sd_state
argument_list|(
name|sd
operator|->
name|state
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"vinum: %s is %s\n"
argument_list|,
name|sd
operator|->
name|name
argument_list|,
name|sd_state
argument_list|(
name|sd
operator|->
name|state
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* we don't get here with status 0 */
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"vinum: %s is %s, not %s\n"
argument_list|,
name|sd
operator|->
name|name
argument_list|,
name|sd_state
argument_list|(
name|sd
operator|->
name|state
argument_list|)
argument_list|,
name|sd_state
argument_list|(
name|newstate
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|plexno
operator|>=
literal|0
condition|)
comment|/* we belong to a plex */
name|update_plex_state
argument_list|(
name|sd
operator|->
name|plexno
argument_list|)
expr_stmt|;
comment|/* update plex state */
if|if
condition|(
operator|(
name|flags
operator|&
name|setstate_configuring
operator|)
operator|==
literal|0
condition|)
comment|/* save config now */
name|save_config
argument_list|()
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/*  * Set the state of a plex dependent on its subdisks.  * This time round, we'll let plex state just reflect  * aggregate subdisk state, so this becomes an order of  * magnitude less complicated.  In particular, ignore  * the requested state.  */
end_comment

begin_function
name|int
name|set_plex_state
parameter_list|(
name|int
name|plexno
parameter_list|,
name|enum
name|plexstate
name|state
parameter_list|,
name|enum
name|setstateflags
name|flags
parameter_list|)
block|{
name|struct
name|plex
modifier|*
name|plex
decl_stmt|;
comment|/* point to our plex */
name|enum
name|plexstate
name|oldstate
decl_stmt|;
name|enum
name|volplexstate
name|vps
decl_stmt|;
comment|/* how do we compare with the other plexes? */
name|plex
operator|=
operator|&
name|PLEX
index|[
name|plexno
index|]
expr_stmt|;
comment|/* point to our plex */
name|oldstate
operator|=
name|plex
operator|->
name|state
expr_stmt|;
comment|/* If the plex isn't allocated, we can't do it. */
if|if
condition|(
name|plex
operator|->
name|state
operator|==
name|plex_unallocated
condition|)
return|return
literal|0
return|;
comment|/*      * If it's already in the the state we want,      * and it's not up, just return.  If it's up,      * we still need to do some housekeeping.      */
if|if
condition|(
operator|(
name|state
operator|==
name|oldstate
operator|)
operator|&&
operator|(
name|state
operator|!=
name|plex_up
operator|)
condition|)
return|return
literal|1
return|;
name|vps
operator|=
name|vpstate
argument_list|(
name|plex
argument_list|)
expr_stmt|;
comment|/* how do we compare with the other plexes? */
switch|switch
condition|(
name|state
condition|)
block|{
comment|/* 	 * We can't bring the plex up, even by force, 	 * unless it's ready.  update_plex_state 	 * checks that. 	 */
case|case
name|plex_up
case|:
comment|/* bring the plex up */
name|update_plex_state
argument_list|(
name|plex
operator|->
name|plexno
argument_list|)
expr_stmt|;
comment|/* it'll come up if it can */
break|break;
case|case
name|plex_down
case|:
comment|/* want to take it down */
comment|/* 	 * If we're the only one, or the only one 	 * which is up, we need force to do it. 	 */
if|if
condition|(
operator|(
operator|(
name|vps
operator|==
name|volplex_onlyus
operator|)
operator|||
operator|(
name|vps
operator|==
name|volplex_onlyusup
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|flags
operator|&
name|setstate_force
operator|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* can't do it */
name|plex
operator|->
name|state
operator|=
name|state
expr_stmt|;
comment|/* do it */
name|invalidate_subdisks
argument_list|(
name|plex
argument_list|,
name|sd_down
argument_list|)
expr_stmt|;
comment|/* and down all up subdisks */
break|break;
comment|/* 	 * This is only requested internally. 	 * Trust ourselves 	 */
case|case
name|plex_faulty
case|:
name|plex
operator|->
name|state
operator|=
name|state
expr_stmt|;
comment|/* do it */
name|invalidate_subdisks
argument_list|(
name|plex
argument_list|,
name|sd_crashed
argument_list|)
expr_stmt|;
comment|/* and crash all up subdisks */
break|break;
case|case
name|plex_initializing
case|:
comment|/* XXX consider what safeguards we need here */
if|if
condition|(
operator|(
name|flags
operator|&
name|setstate_force
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|plex
operator|->
name|state
operator|=
name|state
expr_stmt|;
comment|/* do it */
break|break;
comment|/* What's this? */
default|default:
return|return
literal|0
return|;
block|}
if|if
condition|(
name|plex
operator|->
name|state
operator|!=
name|oldstate
condition|)
comment|/* we've changed, */
name|log
argument_list|(
name|LOG_INFO
argument_list|,
comment|/* tell them about it */
literal|"vinum: %s is %s\n"
argument_list|,
name|plex
operator|->
name|name
argument_list|,
name|plex_state
argument_list|(
name|plex
operator|->
name|state
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * Now see what we have left, and whether      * we're taking the volume down      */
if|if
condition|(
name|plex
operator|->
name|volno
operator|>=
literal|0
condition|)
comment|/* we have a volume */
name|update_volume_state
argument_list|(
name|plex
operator|->
name|volno
argument_list|)
expr_stmt|;
comment|/* update its state */
if|if
condition|(
operator|(
name|flags
operator|&
name|setstate_configuring
operator|)
operator|==
literal|0
condition|)
comment|/* save config now */
name|save_config
argument_list|()
expr_stmt|;
comment|/* yes: save the updated configuration */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Update the state of a plex dependent on its plexes. */
end_comment

begin_function
name|int
name|set_volume_state
parameter_list|(
name|int
name|volno
parameter_list|,
name|enum
name|volumestate
name|state
parameter_list|,
name|enum
name|setstateflags
name|flags
parameter_list|)
block|{
name|struct
name|volume
modifier|*
name|vol
init|=
operator|&
name|VOL
index|[
name|volno
index|]
decl_stmt|;
comment|/* point to our volume */
if|if
condition|(
name|vol
operator|->
name|state
operator|==
name|volume_unallocated
condition|)
comment|/* no volume to do anything with, */
return|return
literal|0
return|;
if|if
condition|(
name|vol
operator|->
name|state
operator|==
name|state
condition|)
comment|/* we're there already */
return|return
literal|1
return|;
if|if
condition|(
name|state
operator|==
name|volume_up
condition|)
comment|/* want to come up */
name|update_volume_state
argument_list|(
name|volno
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|state
operator|==
name|volume_down
condition|)
block|{
comment|/* want to go down */
if|if
condition|(
operator|(
operator|(
name|vol
operator|->
name|flags
operator|&
name|VF_OPEN
operator|)
operator|==
literal|0
operator|)
comment|/* not open */
operator|||
operator|(
operator|(
name|flags
operator|&
name|setstate_force
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* or we're forcing */
name|vol
operator|->
name|state
operator|=
name|volume_down
expr_stmt|;
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"vinum: volume %s is %s\n"
argument_list|,
name|vol
operator|->
name|name
argument_list|,
name|volume_state
argument_list|(
name|vol
operator|->
name|state
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|setstate_configuring
operator|)
operator|==
literal|0
condition|)
comment|/* save config now */
name|save_config
argument_list|()
expr_stmt|;
comment|/* yes: save the updated configuration */
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
comment|/* no change */
block|}
end_function

begin_comment
comment|/* Set the state of a subdisk based on its environment */
end_comment

begin_function
name|void
name|update_sd_state
parameter_list|(
name|int
name|sdno
parameter_list|)
block|{
name|struct
name|sd
modifier|*
name|sd
decl_stmt|;
name|struct
name|drive
modifier|*
name|drive
decl_stmt|;
name|enum
name|sdstate
name|oldstate
decl_stmt|;
name|sd
operator|=
operator|&
name|SD
index|[
name|sdno
index|]
expr_stmt|;
name|oldstate
operator|=
name|sd
operator|->
name|state
expr_stmt|;
name|drive
operator|=
operator|&
name|DRIVE
index|[
name|sd
operator|->
name|driveno
index|]
expr_stmt|;
if|if
condition|(
name|drive
operator|->
name|state
operator|==
name|drive_up
condition|)
block|{
switch|switch
condition|(
name|sd
operator|->
name|state
condition|)
block|{
case|case
name|sd_down
case|:
case|case
name|sd_crashed
case|:
name|sd
operator|->
name|state
operator|=
name|sd_reborn
expr_stmt|;
comment|/* back up again with no loss */
break|break;
default|default:
break|break;
block|}
block|}
else|else
block|{
comment|/* down or worse */
switch|switch
condition|(
name|sd
operator|->
name|state
condition|)
block|{
case|case
name|sd_up
case|:
case|case
name|sd_reborn
case|:
case|case
name|sd_reviving
case|:
case|case
name|sd_empty
case|:
name|sd
operator|->
name|state
operator|=
name|sd_crashed
expr_stmt|;
comment|/* lost our drive */
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|sd
operator|->
name|state
operator|!=
name|oldstate
condition|)
comment|/* state has changed, */
name|log
argument_list|(
name|LOG_INFO
argument_list|,
comment|/* say so */
literal|"vinum: %s is %s\n"
argument_list|,
name|sd
operator|->
name|name
argument_list|,
name|sd_state
argument_list|(
name|sd
operator|->
name|state
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|plexno
operator|>=
literal|0
condition|)
comment|/* we're part of a plex, */
name|update_plex_state
argument_list|(
name|sd
operator|->
name|plexno
argument_list|)
expr_stmt|;
comment|/* update its state */
block|}
end_function

begin_comment
comment|/*  * Force a plex and all its subdisks  * into an 'up' state.  This is a helper  * for update_plex_state.  */
end_comment

begin_function
name|void
name|forceup
parameter_list|(
name|int
name|plexno
parameter_list|)
block|{
name|struct
name|plex
modifier|*
name|plex
decl_stmt|;
name|int
name|sdno
decl_stmt|;
name|plex
operator|=
operator|&
name|PLEX
index|[
name|plexno
index|]
expr_stmt|;
comment|/* point to the plex */
name|plex
operator|->
name|state
operator|=
name|plex_up
expr_stmt|;
comment|/* and bring it up */
comment|/* change the subdisks to up state */
for|for
control|(
name|sdno
operator|=
literal|0
init|;
name|sdno
operator|<
name|plex
operator|->
name|subdisks
condition|;
name|sdno
operator|++
control|)
block|{
name|SD
index|[
name|plex
operator|->
name|sdnos
index|[
name|sdno
index|]
index|]
operator|.
name|state
operator|=
name|sd_up
expr_stmt|;
name|log
argument_list|(
name|LOG_INFO
argument_list|,
comment|/* tell them about it */
literal|"vinum: %s is up\n"
argument_list|,
name|SD
index|[
name|plex
operator|->
name|sdnos
index|[
name|sdno
index|]
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set the state of a plex based on its environment */
end_comment

begin_function
name|void
name|update_plex_state
parameter_list|(
name|int
name|plexno
parameter_list|)
block|{
name|struct
name|plex
modifier|*
name|plex
decl_stmt|;
comment|/* point to our plex */
name|enum
name|plexstate
name|oldstate
decl_stmt|;
name|enum
name|sdstates
name|statemap
decl_stmt|;
comment|/* get a map of the subdisk states */
name|enum
name|volplexstate
name|vps
decl_stmt|;
comment|/* how do we compare with the other plexes? */
name|plex
operator|=
operator|&
name|PLEX
index|[
name|plexno
index|]
expr_stmt|;
comment|/* point to our plex */
name|oldstate
operator|=
name|plex
operator|->
name|state
expr_stmt|;
name|statemap
operator|=
name|sdstatemap
argument_list|(
name|plex
argument_list|)
expr_stmt|;
comment|/* get a map of the subdisk states */
name|vps
operator|=
name|vpstate
argument_list|(
name|plex
argument_list|)
expr_stmt|;
comment|/* how do we compare with the other plexes? */
if|if
condition|(
name|statemap
operator|&
name|sd_initstate
condition|)
comment|/* something initializing? */
name|plex
operator|->
name|state
operator|=
name|plex_initializing
expr_stmt|;
comment|/* yup, that makes the plex the same */
elseif|else
if|if
condition|(
name|statemap
operator|==
name|sd_upstate
condition|)
comment|/* 	 * All the subdisks are up.  This also means that 	 * they are consistent, so we can just bring 	 * the plex up 	 */
name|plex
operator|->
name|state
operator|=
name|plex_up
expr_stmt|;
elseif|else
if|if
condition|(
name|isparity
argument_list|(
name|plex
argument_list|)
comment|/* RAID-4 or RAID-5 plex */
operator|&&
operator|(
name|plex
operator|->
name|sddowncount
operator|==
literal|1
operator|)
condition|)
comment|/* and exactly one subdisk down */
name|plex
operator|->
name|state
operator|=
name|plex_degraded
expr_stmt|;
comment|/* limping a bit */
elseif|else
if|if
condition|(
operator|(
operator|(
name|statemap
operator|&
operator|~
name|sd_downstate
operator|)
operator|==
name|sd_emptystate
operator|)
comment|/* all subdisks empty */
operator|||
operator|(
operator|(
name|statemap
operator|&
operator|~
name|sd_downstate
operator|)
operator|==
operator|(
name|statemap
operator|&
operator|~
name|sd_downstate
operator|&
operator|(
name|sd_initializedstate
operator||
name|sd_upstate
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|vps
operator|&
name|volplex_otherup
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* no other plex is up */
name|struct
name|volume
modifier|*
name|vol
init|=
operator|&
name|VOL
index|[
name|plex
operator|->
name|volno
index|]
decl_stmt|;
comment|/* possible volume to which it points */
comment|/* 	     * If we're a striped or concat plex 	     * associated with a volume, none of whose 	     * plexes are up, and we're new and untested, 	     * and the volume has the setupstate bit set, 	     * we can pretend to be in a consistent state. 	     * 	     * We need to do this in one swell foop: on 	     * the next call we will no longer be just 	     * empty. 	     * 	     * This code assumes that all the other plexes 	     * are also capable of coming up (i.e. all the 	     * sds are up), but that's OK: we'll come back 	     * to this function for the remaining plexes 	     * in the volume. 	     */
if|if
condition|(
operator|(
name|plex
operator|->
name|state
operator|==
name|plex_init
operator|)
operator|&&
operator|(
name|plex
operator|->
name|volno
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|vol
operator|->
name|flags
operator|&
name|VF_CONFIG_SETUPSTATE
operator|)
condition|)
block|{
for|for
control|(
name|plexno
operator|=
literal|0
init|;
name|plexno
operator|<
name|vol
operator|->
name|plexes
condition|;
name|plexno
operator|++
control|)
name|forceup
argument_list|(
name|VOL
index|[
name|plex
operator|->
name|volno
index|]
operator|.
name|plex
index|[
name|plexno
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|statemap
operator|==
name|sd_initializedstate
operator|)
comment|/* if it's initialized (not empty) */
operator|||
operator|(
name|plex
operator|->
name|organization
operator|==
name|plex_concat
operator|)
comment|/* and we're not RAID-4 or RAID-5 */
operator|||
operator|(
name|plex
operator|->
name|organization
operator|==
name|plex_striped
operator|)
condition|)
name|forceup
argument_list|(
name|plexno
argument_list|)
expr_stmt|;
comment|/* we'll do it */
comment|/* 	     * This leaves a case where things don't get 	     * done: the plex is RAID-4 or RAID-5, and 	     * the subdisks are all empty.  They need to 	     * be initialized first. 	     */
block|}
else|else
block|{
if|if
condition|(
name|statemap
operator|==
name|sd_upstate
condition|)
comment|/* all subdisks up */
name|plex
operator|->
name|state
operator|=
name|plex_up
expr_stmt|;
comment|/* we can come up too */
else|else
name|plex
operator|->
name|state
operator|=
name|plex_faulty
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|statemap
operator|&
operator|(
name|sd_upstate
operator||
name|sd_rebornstate
operator|)
operator|)
operator|==
name|statemap
condition|)
comment|/* all up or reborn */
name|plex
operator|->
name|state
operator|=
name|plex_flaky
expr_stmt|;
elseif|else
if|if
condition|(
name|statemap
operator|&
operator|(
name|sd_upstate
operator||
name|sd_rebornstate
operator|)
condition|)
comment|/* some up or reborn */
name|plex
operator|->
name|state
operator|=
name|plex_corrupt
expr_stmt|;
comment|/* corrupt */
elseif|else
if|if
condition|(
name|statemap
operator|&
operator|(
name|sd_initstate
operator||
name|sd_emptystate
operator|)
condition|)
comment|/* some subdisks empty or initializing */
name|plex
operator|->
name|state
operator|=
name|plex_initializing
expr_stmt|;
else|else
comment|/* nothing at all up */
name|plex
operator|->
name|state
operator|=
name|plex_faulty
expr_stmt|;
if|if
condition|(
name|plex
operator|->
name|state
operator|!=
name|oldstate
condition|)
comment|/* state has changed, */
name|log
argument_list|(
name|LOG_INFO
argument_list|,
comment|/* tell them about it */
literal|"vinum: %s is %s\n"
argument_list|,
name|plex
operator|->
name|name
argument_list|,
name|plex_state
argument_list|(
name|plex
operator|->
name|state
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|plex
operator|->
name|volno
operator|>=
literal|0
condition|)
comment|/* we're part of a volume, */
name|update_volume_state
argument_list|(
name|plex
operator|->
name|volno
argument_list|)
expr_stmt|;
comment|/* update its state */
block|}
end_function

begin_comment
comment|/* Set volume state based on its components */
end_comment

begin_function
name|void
name|update_volume_state
parameter_list|(
name|int
name|volno
parameter_list|)
block|{
name|struct
name|volume
modifier|*
name|vol
decl_stmt|;
comment|/* our volume */
name|int
name|plexno
decl_stmt|;
name|enum
name|volumestate
name|oldstate
decl_stmt|;
name|vol
operator|=
operator|&
name|VOL
index|[
name|volno
index|]
expr_stmt|;
comment|/* point to our volume */
name|oldstate
operator|=
name|vol
operator|->
name|state
expr_stmt|;
for|for
control|(
name|plexno
operator|=
literal|0
init|;
name|plexno
operator|<
name|vol
operator|->
name|plexes
condition|;
name|plexno
operator|++
control|)
block|{
name|struct
name|plex
modifier|*
name|plex
init|=
operator|&
name|PLEX
index|[
name|vol
operator|->
name|plex
index|[
name|plexno
index|]
index|]
decl_stmt|;
comment|/* point to the plex */
if|if
condition|(
name|plex
operator|->
name|state
operator|>=
name|plex_corrupt
condition|)
block|{
comment|/* something accessible, */
name|vol
operator|->
name|state
operator|=
name|volume_up
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|plexno
operator|==
name|vol
operator|->
name|plexes
condition|)
comment|/* didn't find an up plex */
name|vol
operator|->
name|state
operator|=
name|volume_down
expr_stmt|;
if|if
condition|(
name|vol
operator|->
name|state
operator|!=
name|oldstate
condition|)
block|{
comment|/* state changed */
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"vinum: %s is %s\n"
argument_list|,
name|vol
operator|->
name|name
argument_list|,
name|volume_state
argument_list|(
name|vol
operator|->
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|save_config
argument_list|()
expr_stmt|;
comment|/* save the updated configuration */
block|}
block|}
end_function

begin_comment
comment|/*  * Called from request routines when they find  * a subdisk which is not kosher.  Decide whether  * it warrants changing the state.  Return  * REQUEST_DOWN if we can't use the subdisk,  * REQUEST_OK if we can.  */
end_comment

begin_comment
comment|/*  * A prior version of this function checked the plex  * state as well.  At the moment, consider plex states  * information for the user only.  We'll ignore them  * and use the subdisk state only.  The last version of  * this file with the old logic was 2.7. XXX  */
end_comment

begin_function
name|enum
name|requeststatus
name|checksdstate
parameter_list|(
name|struct
name|sd
modifier|*
name|sd
parameter_list|,
name|struct
name|request
modifier|*
name|rq
parameter_list|,
name|daddr_t
name|diskaddr
parameter_list|,
name|daddr_t
name|diskend
parameter_list|)
block|{
name|struct
name|plex
modifier|*
name|plex
init|=
operator|&
name|PLEX
index|[
name|sd
operator|->
name|plexno
index|]
decl_stmt|;
name|int
name|writeop
init|=
operator|(
name|rq
operator|->
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|==
literal|0
decl_stmt|;
comment|/* note if we're writing */
switch|switch
condition|(
name|sd
operator|->
name|state
condition|)
block|{
comment|/* We shouldn't get called if the subdisk is up */
case|case
name|sd_up
case|:
return|return
name|REQUEST_OK
return|;
case|case
name|sd_reviving
case|:
comment|/* 	 * Access to a reviving subdisk depends on the 	 * organization of the plex: 	 * 	 * - If it's concatenated, access the subdisk 	 *   up to its current revive point.  If we 	 *   want to write to the subdisk overlapping 	 *   the current revive block, set the 	 *   conflict flag in the request, asking the 	 *   caller to put the request on the wait 	 *   list, which will be attended to by 	 *   revive_block when it's done. 	 * - if it's striped, we can't do it (we could 	 *   do some hairy calculations, but it's 	 *   unlikely to work). 	 * - if it's RAID-4 or RAID-5, we can do it as 	 *   long as only one subdisk is down 	 */
if|if
condition|(
name|plex
operator|->
name|organization
operator|==
name|plex_striped
condition|)
comment|/* plex is striped, */
return|return
name|REQUEST_DOWN
return|;
elseif|else
if|if
condition|(
name|isparity
argument_list|(
name|plex
argument_list|)
condition|)
block|{
comment|/* RAID-4 or RAID-5 plex */
if|if
condition|(
name|plex
operator|->
name|sddowncount
operator|>
literal|1
condition|)
comment|/* with more than one sd down, */
return|return
name|REQUEST_DOWN
return|;
else|else
comment|/* 		 * XXX We shouldn't do this if we can find a 		 * better way.  Check the other plexes 		 * first, and return a DOWN if another 		 * plex will do it better 		 */
return|return
name|REQUEST_OK
return|;
comment|/* OK, we'll find a way */
block|}
if|if
condition|(
name|diskaddr
operator|>
operator|(
name|sd
operator|->
name|revived
operator|+
name|sd
operator|->
name|plexoffset
operator|+
operator|(
name|sd
operator|->
name|revive_blocksize
operator|>>
name|DEV_BSHIFT
operator|)
operator|)
condition|)
comment|/* we're beyond the end */
return|return
name|REQUEST_DOWN
return|;
elseif|else
if|if
condition|(
name|diskend
operator|>
operator|(
name|sd
operator|->
name|revived
operator|+
name|sd
operator|->
name|plexoffset
operator|)
condition|)
block|{
comment|/* we finish beyond the end */
if|if
condition|(
name|writeop
condition|)
block|{
name|rq
operator|->
name|flags
operator||=
name|XFR_REVIVECONFLICT
expr_stmt|;
comment|/* note a potential conflict */
name|rq
operator|->
name|sdno
operator|=
name|sd
operator|->
name|sdno
expr_stmt|;
comment|/* and which sd last caused it */
block|}
else|else
return|return
name|REQUEST_DOWN
return|;
block|}
return|return
name|REQUEST_OK
return|;
case|case
name|sd_reborn
case|:
if|if
condition|(
name|writeop
condition|)
return|return
name|REQUEST_OK
return|;
comment|/* always write to a reborn disk */
else|else
comment|/* don't allow a read */
comment|/* 	       * Handle the mapping.  We don't want to reject 	       * a read request to a reborn subdisk if that's 	       * all we have. XXX 	     */
return|return
name|REQUEST_DOWN
return|;
case|case
name|sd_down
case|:
if|if
condition|(
name|writeop
condition|)
comment|/* writing to a consistent down disk */
name|set_sd_state
argument_list|(
name|sd
operator|->
name|sdno
argument_list|,
name|sd_obsolete
argument_list|,
name|setstate_force
argument_list|)
expr_stmt|;
comment|/* it's not consistent now */
return|return
name|REQUEST_DOWN
return|;
case|case
name|sd_crashed
case|:
if|if
condition|(
name|writeop
condition|)
comment|/* writing to a consistent down disk */
name|set_sd_state
argument_list|(
name|sd
operator|->
name|sdno
argument_list|,
name|sd_stale
argument_list|,
name|setstate_force
argument_list|)
expr_stmt|;
comment|/* it's not consistent now */
return|return
name|REQUEST_DOWN
return|;
default|default:
return|return
name|REQUEST_DOWN
return|;
block|}
block|}
end_function

begin_comment
comment|/* return a state map for the subdisks of a plex */
end_comment

begin_function
name|enum
name|sdstates
name|sdstatemap
parameter_list|(
name|struct
name|plex
modifier|*
name|plex
parameter_list|)
block|{
name|int
name|sdno
decl_stmt|;
name|enum
name|sdstates
name|statemap
init|=
literal|0
decl_stmt|;
comment|/* note the states we find */
name|plex
operator|->
name|sddowncount
operator|=
literal|0
expr_stmt|;
comment|/* no subdisks down yet */
for|for
control|(
name|sdno
operator|=
literal|0
init|;
name|sdno
operator|<
name|plex
operator|->
name|subdisks
condition|;
name|sdno
operator|++
control|)
block|{
name|struct
name|sd
modifier|*
name|sd
init|=
operator|&
name|SD
index|[
name|plex
operator|->
name|sdnos
index|[
name|sdno
index|]
index|]
decl_stmt|;
comment|/* point to the subdisk */
switch|switch
condition|(
name|sd
operator|->
name|state
condition|)
block|{
case|case
name|sd_empty
case|:
name|statemap
operator||=
name|sd_emptystate
expr_stmt|;
operator|(
name|plex
operator|->
name|sddowncount
operator|)
operator|++
expr_stmt|;
comment|/* another unusable subdisk */
break|break;
case|case
name|sd_init
case|:
name|statemap
operator||=
name|sd_initstate
expr_stmt|;
operator|(
name|plex
operator|->
name|sddowncount
operator|)
operator|++
expr_stmt|;
comment|/* another unusable subdisk */
break|break;
case|case
name|sd_down
case|:
name|statemap
operator||=
name|sd_downstate
expr_stmt|;
operator|(
name|plex
operator|->
name|sddowncount
operator|)
operator|++
expr_stmt|;
comment|/* another unusable subdisk */
break|break;
case|case
name|sd_crashed
case|:
name|statemap
operator||=
name|sd_crashedstate
expr_stmt|;
operator|(
name|plex
operator|->
name|sddowncount
operator|)
operator|++
expr_stmt|;
comment|/* another unusable subdisk */
break|break;
case|case
name|sd_obsolete
case|:
name|statemap
operator||=
name|sd_obsoletestate
expr_stmt|;
operator|(
name|plex
operator|->
name|sddowncount
operator|)
operator|++
expr_stmt|;
comment|/* another unusable subdisk */
break|break;
case|case
name|sd_stale
case|:
name|statemap
operator||=
name|sd_stalestate
expr_stmt|;
operator|(
name|plex
operator|->
name|sddowncount
operator|)
operator|++
expr_stmt|;
comment|/* another unusable subdisk */
break|break;
case|case
name|sd_reborn
case|:
name|statemap
operator||=
name|sd_rebornstate
expr_stmt|;
break|break;
case|case
name|sd_up
case|:
name|statemap
operator||=
name|sd_upstate
expr_stmt|;
break|break;
case|case
name|sd_initializing
case|:
name|statemap
operator||=
name|sd_initstate
expr_stmt|;
operator|(
name|plex
operator|->
name|sddowncount
operator|)
operator|++
expr_stmt|;
comment|/* another unusable subdisk */
break|break;
case|case
name|sd_initialized
case|:
name|statemap
operator||=
name|sd_initializedstate
expr_stmt|;
operator|(
name|plex
operator|->
name|sddowncount
operator|)
operator|++
expr_stmt|;
comment|/* another unusable subdisk */
break|break;
case|case
name|sd_unallocated
case|:
case|case
name|sd_uninit
case|:
case|case
name|sd_reviving
case|:
case|case
name|sd_referenced
case|:
name|statemap
operator||=
name|sd_otherstate
expr_stmt|;
operator|(
name|plex
operator|->
name|sddowncount
operator|)
operator|++
expr_stmt|;
comment|/* another unusable subdisk */
block|}
block|}
return|return
name|statemap
return|;
block|}
end_function

begin_comment
comment|/* determine the state of the volume relative to this plex */
end_comment

begin_function
name|enum
name|volplexstate
name|vpstate
parameter_list|(
name|struct
name|plex
modifier|*
name|plex
parameter_list|)
block|{
name|struct
name|volume
modifier|*
name|vol
decl_stmt|;
name|enum
name|volplexstate
name|state
init|=
name|volplex_onlyusdown
decl_stmt|;
comment|/* state to return */
name|int
name|plexno
decl_stmt|;
if|if
condition|(
name|plex
operator|->
name|volno
operator|<
literal|0
condition|)
block|{
comment|/* not associated with a volume */
if|if
condition|(
name|plex
operator|->
name|state
operator|>
name|plex_degraded
condition|)
return|return
name|volplex_onlyus
return|;
comment|/* just us */
else|else
return|return
name|volplex_onlyusdown
return|;
comment|/* assume the worst */
block|}
name|vol
operator|=
operator|&
name|VOL
index|[
name|plex
operator|->
name|volno
index|]
expr_stmt|;
comment|/* point to our volume */
for|for
control|(
name|plexno
operator|=
literal|0
init|;
name|plexno
operator|<
name|vol
operator|->
name|plexes
condition|;
name|plexno
operator|++
control|)
block|{
if|if
condition|(
operator|&
name|PLEX
index|[
name|vol
operator|->
name|plex
index|[
name|plexno
index|]
index|]
operator|==
name|plex
condition|)
block|{
comment|/* us */
if|if
condition|(
name|PLEX
index|[
name|vol
operator|->
name|plex
index|[
name|plexno
index|]
index|]
operator|.
name|state
operator|>=
name|plex_degraded
condition|)
comment|/* are we up? */
name|state
operator||=
name|volplex_onlyus
expr_stmt|;
comment|/* yes */
block|}
else|else
block|{
if|if
condition|(
name|PLEX
index|[
name|vol
operator|->
name|plex
index|[
name|plexno
index|]
index|]
operator|.
name|state
operator|>=
name|plex_degraded
condition|)
comment|/* not us */
name|state
operator||=
name|volplex_otherup
expr_stmt|;
comment|/* and when they were up, they were up */
else|else
name|state
operator||=
name|volplex_alldown
expr_stmt|;
comment|/* and when they were down, they were down */
block|}
block|}
return|return
name|state
return|;
comment|/* and when they were only halfway up */
block|}
end_function

begin_comment
comment|/* they were neither up nor down */
end_comment

begin_comment
comment|/* Check if all bits b are set in a */
end_comment

begin_function_decl
name|int
name|allset
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|allset
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
operator|(
name|a
operator|&
name|b
operator|)
operator|==
name|b
return|;
block|}
end_function

begin_comment
comment|/* Invalidate the subdisks belonging to a plex */
end_comment

begin_function
name|void
name|invalidate_subdisks
parameter_list|(
name|struct
name|plex
modifier|*
name|plex
parameter_list|,
name|enum
name|sdstate
name|state
parameter_list|)
block|{
name|int
name|sdno
decl_stmt|;
for|for
control|(
name|sdno
operator|=
literal|0
init|;
name|sdno
operator|<
name|plex
operator|->
name|subdisks
condition|;
name|sdno
operator|++
control|)
block|{
comment|/* for each subdisk */
name|struct
name|sd
modifier|*
name|sd
init|=
operator|&
name|SD
index|[
name|plex
operator|->
name|sdnos
index|[
name|sdno
index|]
index|]
decl_stmt|;
switch|switch
condition|(
name|sd
operator|->
name|state
condition|)
block|{
case|case
name|sd_unallocated
case|:
case|case
name|sd_uninit
case|:
case|case
name|sd_init
case|:
case|case
name|sd_initializing
case|:
case|case
name|sd_initialized
case|:
case|case
name|sd_empty
case|:
case|case
name|sd_obsolete
case|:
case|case
name|sd_stale
case|:
case|case
name|sd_crashed
case|:
case|case
name|sd_down
case|:
case|case
name|sd_referenced
case|:
break|break;
case|case
name|sd_reviving
case|:
case|case
name|sd_reborn
case|:
case|case
name|sd_up
case|:
name|set_sd_state
argument_list|(
name|plex
operator|->
name|sdnos
index|[
name|sdno
index|]
argument_list|,
name|state
argument_list|,
name|setstate_force
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Start an object, in other words do what we can to get it up.  * This is called from vinumioctl (VINUMSTART).  * Return error indications via ioctl_reply  */
end_comment

begin_function
name|void
name|start_object
parameter_list|(
name|struct
name|vinum_ioctl_msg
modifier|*
name|data
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|int
name|objindex
init|=
name|data
operator|->
name|index
decl_stmt|;
comment|/* data gets overwritten */
name|struct
name|_ioctl_reply
modifier|*
name|ioctl_reply
init|=
operator|(
expr|struct
name|_ioctl_reply
operator|*
operator|)
name|data
decl_stmt|;
comment|/* format for returning replies */
name|enum
name|setstateflags
name|flags
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|force
operator|!=
literal|0
condition|)
comment|/* are we going to use force? */
name|flags
operator|=
name|setstate_force
expr_stmt|;
comment|/* yes */
else|else
name|flags
operator|=
name|setstate_none
expr_stmt|;
comment|/* no */
switch|switch
condition|(
name|data
operator|->
name|type
condition|)
block|{
case|case
name|drive_object
case|:
name|status
operator|=
name|set_drive_state
argument_list|(
name|objindex
argument_list|,
name|drive_up
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|DRIVE
index|[
name|objindex
index|]
operator|.
name|state
operator|!=
name|drive_up
condition|)
comment|/* set status on whether we really did it */
name|ioctl_reply
operator|->
name|error
operator|=
name|EBUSY
expr_stmt|;
else|else
name|ioctl_reply
operator|->
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|sd_object
case|:
if|if
condition|(
name|DRIVE
index|[
name|SD
index|[
name|objindex
index|]
operator|.
name|driveno
index|]
operator|.
name|state
operator|!=
name|drive_up
condition|)
block|{
name|ioctl_reply
operator|->
name|error
operator|=
name|EIO
expr_stmt|;
name|strcpy
argument_list|(
name|ioctl_reply
operator|->
name|msg
argument_list|,
literal|"Drive is down"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|data
operator|->
name|blocksize
condition|)
name|SD
index|[
name|objindex
index|]
operator|.
name|revive_blocksize
operator|=
name|data
operator|->
name|blocksize
expr_stmt|;
if|if
condition|(
operator|(
name|SD
index|[
name|objindex
index|]
operator|.
name|state
operator|==
name|sd_reviving
operator|)
comment|/* reviving, */
operator|||
operator|(
name|SD
index|[
name|objindex
index|]
operator|.
name|state
operator|==
name|sd_stale
operator|)
condition|)
block|{
comment|/* or stale, will revive */
name|SD
index|[
name|objindex
index|]
operator|.
name|state
operator|=
name|sd_reviving
expr_stmt|;
comment|/* make sure we're reviving */
name|ioctl_reply
operator|->
name|error
operator|=
name|revive_block
argument_list|(
name|objindex
argument_list|)
expr_stmt|;
comment|/* revive another block */
name|ioctl_reply
operator|->
name|msg
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* no comment */
return|return;
block|}
elseif|else
if|if
condition|(
name|SD
index|[
name|objindex
index|]
operator|.
name|state
operator|==
name|sd_initializing
condition|)
block|{
comment|/* initializing, */
if|if
condition|(
name|data
operator|->
name|blocksize
condition|)
name|SD
index|[
name|objindex
index|]
operator|.
name|init_blocksize
operator|=
name|data
operator|->
name|blocksize
expr_stmt|;
name|ioctl_reply
operator|->
name|error
operator|=
name|initsd
argument_list|(
name|objindex
argument_list|,
name|data
operator|->
name|verify
argument_list|)
expr_stmt|;
comment|/* initialize another block */
name|ioctl_reply
operator|->
name|msg
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* no comment */
return|return;
block|}
name|status
operator|=
name|set_sd_state
argument_list|(
name|objindex
argument_list|,
name|sd_up
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* set state */
if|if
condition|(
name|status
operator|!=
name|EAGAIN
condition|)
block|{
comment|/* not first revive or initialize, */
if|if
condition|(
name|SD
index|[
name|objindex
index|]
operator|.
name|state
operator|!=
name|sd_up
condition|)
comment|/* set status on whether we really did it */
name|ioctl_reply
operator|->
name|error
operator|=
name|EBUSY
expr_stmt|;
else|else
name|ioctl_reply
operator|->
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|ioctl_reply
operator|->
name|error
operator|=
name|status
expr_stmt|;
break|break;
case|case
name|plex_object
case|:
name|status
operator|=
name|set_plex_state
argument_list|(
name|objindex
argument_list|,
name|plex_up
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|PLEX
index|[
name|objindex
index|]
operator|.
name|state
operator|!=
name|plex_up
condition|)
comment|/* set status on whether we really did it */
name|ioctl_reply
operator|->
name|error
operator|=
name|EBUSY
expr_stmt|;
else|else
name|ioctl_reply
operator|->
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|volume_object
case|:
name|status
operator|=
name|set_volume_state
argument_list|(
name|objindex
argument_list|,
name|volume_up
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|VOL
index|[
name|objindex
index|]
operator|.
name|state
operator|!=
name|volume_up
condition|)
comment|/* set status on whether we really did it */
name|ioctl_reply
operator|->
name|error
operator|=
name|EBUSY
expr_stmt|;
else|else
name|ioctl_reply
operator|->
name|error
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|ioctl_reply
operator|->
name|error
operator|=
name|EINVAL
expr_stmt|;
name|strcpy
argument_list|(
name|ioctl_reply
operator|->
name|msg
argument_list|,
literal|"Invalid object type"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*      * There's no point in saying anything here:      * the userland program does it better      */
name|ioctl_reply
operator|->
name|msg
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Stop an object, in other words do what we can to get it down  * This is called from vinumioctl (VINUMSTOP).  * Return error indications via ioctl_reply.  */
end_comment

begin_function
name|void
name|stop_object
parameter_list|(
name|struct
name|vinum_ioctl_msg
modifier|*
name|data
parameter_list|)
block|{
name|int
name|status
init|=
literal|1
decl_stmt|;
name|int
name|objindex
init|=
name|data
operator|->
name|index
decl_stmt|;
comment|/* save the number from change */
name|struct
name|_ioctl_reply
modifier|*
name|ioctl_reply
init|=
operator|(
expr|struct
name|_ioctl_reply
operator|*
operator|)
name|data
decl_stmt|;
comment|/* format for returning replies */
switch|switch
condition|(
name|data
operator|->
name|type
condition|)
block|{
case|case
name|drive_object
case|:
name|status
operator|=
name|set_drive_state
argument_list|(
name|objindex
argument_list|,
name|drive_down
argument_list|,
name|data
operator|->
name|force
argument_list|)
expr_stmt|;
break|break;
case|case
name|sd_object
case|:
name|status
operator|=
name|set_sd_state
argument_list|(
name|objindex
argument_list|,
name|sd_down
argument_list|,
name|data
operator|->
name|force
argument_list|)
expr_stmt|;
break|break;
case|case
name|plex_object
case|:
name|status
operator|=
name|set_plex_state
argument_list|(
name|objindex
argument_list|,
name|plex_down
argument_list|,
name|data
operator|->
name|force
argument_list|)
expr_stmt|;
break|break;
case|case
name|volume_object
case|:
name|status
operator|=
name|set_volume_state
argument_list|(
name|objindex
argument_list|,
name|volume_down
argument_list|,
name|data
operator|->
name|force
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ioctl_reply
operator|->
name|error
operator|=
name|EINVAL
expr_stmt|;
name|strcpy
argument_list|(
name|ioctl_reply
operator|->
name|msg
argument_list|,
literal|"Invalid object type"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ioctl_reply
operator|->
name|msg
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
comment|/* couldn't do it */
name|ioctl_reply
operator|->
name|error
operator|=
name|EBUSY
expr_stmt|;
else|else
name|ioctl_reply
operator|->
name|error
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * VINUM_SETSTATE ioctl: set an object state.  * msg is the message passed by the user.  */
end_comment

begin_function
name|void
name|setstate
parameter_list|(
name|struct
name|vinum_ioctl_msg
modifier|*
name|msg
parameter_list|)
block|{
name|int
name|sdno
decl_stmt|;
name|struct
name|sd
modifier|*
name|sd
decl_stmt|;
name|struct
name|plex
modifier|*
name|plex
decl_stmt|;
name|struct
name|_ioctl_reply
modifier|*
name|ioctl_reply
init|=
operator|(
expr|struct
name|_ioctl_reply
operator|*
operator|)
name|msg
decl_stmt|;
comment|/* format for returning replies */
switch|switch
condition|(
name|msg
operator|->
name|state
condition|)
block|{
case|case
name|object_down
case|:
name|stop_object
argument_list|(
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|object_initializing
case|:
switch|switch
condition|(
name|msg
operator|->
name|type
condition|)
block|{
case|case
name|sd_object
case|:
name|sd
operator|=
operator|&
name|SD
index|[
name|msg
operator|->
name|index
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|msg
operator|->
name|index
operator|>=
name|vinum_conf
operator|.
name|subdisks_allocated
operator|)
operator|||
operator|(
name|sd
operator|->
name|state
operator|<=
name|sd_referenced
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|ioctl_reply
operator|->
name|msg
argument_list|,
literal|"Invalid subdisk %d"
argument_list|,
name|msg
operator|->
name|index
argument_list|)
expr_stmt|;
name|ioctl_reply
operator|->
name|error
operator|=
name|EFAULT
expr_stmt|;
return|return;
block|}
name|set_sd_state
argument_list|(
name|msg
operator|->
name|index
argument_list|,
name|sd_initializing
argument_list|,
name|msg
operator|->
name|force
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|state
operator|!=
name|sd_initializing
condition|)
block|{
name|strcpy
argument_list|(
name|ioctl_reply
operator|->
name|msg
argument_list|,
literal|"Can't set state"
argument_list|)
expr_stmt|;
name|ioctl_reply
operator|->
name|error
operator|=
name|EBUSY
expr_stmt|;
block|}
else|else
name|ioctl_reply
operator|->
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|plex_object
case|:
name|plex
operator|=
operator|&
name|PLEX
index|[
name|msg
operator|->
name|index
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|msg
operator|->
name|index
operator|>=
name|vinum_conf
operator|.
name|plexes_allocated
operator|)
operator|||
operator|(
name|plex
operator|->
name|state
operator|<=
name|plex_unallocated
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|ioctl_reply
operator|->
name|msg
argument_list|,
literal|"Invalid plex %d"
argument_list|,
name|msg
operator|->
name|index
argument_list|)
expr_stmt|;
name|ioctl_reply
operator|->
name|error
operator|=
name|EFAULT
expr_stmt|;
return|return;
block|}
name|set_plex_state
argument_list|(
name|msg
operator|->
name|index
argument_list|,
name|plex_initializing
argument_list|,
name|msg
operator|->
name|force
argument_list|)
expr_stmt|;
if|if
condition|(
name|plex
operator|->
name|state
operator|!=
name|plex_initializing
condition|)
block|{
name|strcpy
argument_list|(
name|ioctl_reply
operator|->
name|msg
argument_list|,
literal|"Can't set state"
argument_list|)
expr_stmt|;
name|ioctl_reply
operator|->
name|error
operator|=
name|EBUSY
expr_stmt|;
block|}
else|else
block|{
name|ioctl_reply
operator|->
name|error
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sdno
operator|=
literal|0
init|;
name|sdno
operator|<
name|plex
operator|->
name|subdisks
condition|;
name|sdno
operator|++
control|)
block|{
name|sd
operator|=
operator|&
name|SD
index|[
name|plex
operator|->
name|sdnos
index|[
name|sdno
index|]
index|]
expr_stmt|;
name|set_sd_state
argument_list|(
name|plex
operator|->
name|sdnos
index|[
name|sdno
index|]
argument_list|,
name|sd_initializing
argument_list|,
name|msg
operator|->
name|force
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|state
operator|!=
name|sd_initializing
condition|)
block|{
name|strcpy
argument_list|(
name|ioctl_reply
operator|->
name|msg
argument_list|,
literal|"Can't set state"
argument_list|)
expr_stmt|;
name|ioctl_reply
operator|->
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
block|}
block|}
break|break;
default|default:
name|strcpy
argument_list|(
name|ioctl_reply
operator|->
name|msg
argument_list|,
literal|"Invalid object"
argument_list|)
expr_stmt|;
name|ioctl_reply
operator|->
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
case|case
name|object_initialized
case|:
if|if
condition|(
name|msg
operator|->
name|type
operator|==
name|sd_object
condition|)
block|{
name|sd
operator|=
operator|&
name|SD
index|[
name|msg
operator|->
name|index
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|msg
operator|->
name|index
operator|>=
name|vinum_conf
operator|.
name|subdisks_allocated
operator|)
operator|||
operator|(
name|sd
operator|->
name|state
operator|<=
name|sd_referenced
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|ioctl_reply
operator|->
name|msg
argument_list|,
literal|"Invalid subdisk %d"
argument_list|,
name|msg
operator|->
name|index
argument_list|)
expr_stmt|;
name|ioctl_reply
operator|->
name|error
operator|=
name|EFAULT
expr_stmt|;
return|return;
block|}
name|set_sd_state
argument_list|(
name|msg
operator|->
name|index
argument_list|,
name|sd_initialized
argument_list|,
name|msg
operator|->
name|force
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|state
operator|!=
name|sd_initializing
condition|)
block|{
name|strcpy
argument_list|(
name|ioctl_reply
operator|->
name|msg
argument_list|,
literal|"Can't set state"
argument_list|)
expr_stmt|;
name|ioctl_reply
operator|->
name|error
operator|=
name|EBUSY
expr_stmt|;
block|}
else|else
name|ioctl_reply
operator|->
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|ioctl_reply
operator|->
name|msg
argument_list|,
literal|"Invalid object"
argument_list|)
expr_stmt|;
name|ioctl_reply
operator|->
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
case|case
name|object_up
case|:
name|start_object
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Brute force set state function.  Don't look at  * any dependencies, just do it.  This is mainly  * intended for testing and recovery.  */
end_comment

begin_function
name|void
name|setstate_by_force
parameter_list|(
name|struct
name|vinum_ioctl_msg
modifier|*
name|msg
parameter_list|)
block|{
name|struct
name|_ioctl_reply
modifier|*
name|ioctl_reply
init|=
operator|(
expr|struct
name|_ioctl_reply
operator|*
operator|)
name|msg
decl_stmt|;
comment|/* format for returning replies */
switch|switch
condition|(
name|msg
operator|->
name|type
condition|)
block|{
case|case
name|drive_object
case|:
name|DRIVE
index|[
name|msg
operator|->
name|index
index|]
operator|.
name|state
operator|=
name|msg
operator|->
name|state
expr_stmt|;
break|break;
case|case
name|sd_object
case|:
name|SD
index|[
name|msg
operator|->
name|index
index|]
operator|.
name|state
operator|=
name|msg
operator|->
name|state
expr_stmt|;
break|break;
case|case
name|plex_object
case|:
name|PLEX
index|[
name|msg
operator|->
name|index
index|]
operator|.
name|state
operator|=
name|msg
operator|->
name|state
expr_stmt|;
break|break;
case|case
name|volume_object
case|:
name|VOL
index|[
name|msg
operator|->
name|index
index|]
operator|.
name|state
operator|=
name|msg
operator|->
name|state
expr_stmt|;
break|break;
default|default:
block|}
name|ioctl_reply
operator|->
name|error
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Local Variables: */
end_comment

begin_comment
comment|/* fill-column: 50 */
end_comment

begin_comment
comment|/* End: */
end_comment

end_unit

