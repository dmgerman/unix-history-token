begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * To do:  *  * Don't store drive configuration on the config DB: read each drive's header  * to decide where it is.  *  * Accept any old crap in the config_<foo> functions, and complain when  * we try to bring it up.  *  * When trying to bring volumes up, check that the complete address range  * is covered.  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 1997, 1998  *	Nan Yang Computer Services Limited.  All rights reserved.  *  *  This software is distributed under the so-called ``Berkeley  *  License'':  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Nan Yang Computer  *      Services Limited.  * 4. Neither the name of the Company nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * This software is provided ``as is'', and any express or implied  * warranties, including, but not limited to, the implied warranties of  * merchantability and fitness for a particular purpose are disclaimed.  * In no event shall the company or contributors be liable for any  * direct, indirect, incidental, special, exemplary, or consequential  * damages (including, but not limited to, procurement of substitute  * goods or services; loss of use, data, or profits; or business  * interruption) however caused and on any theory of liability, whether  * in contract, strict liability, or tort (including negligence or  * otherwise) arising in any way out of the use of this software, even if  * advised of the possibility of such damage.  *  * $Id: vinumconfig.c,v 1.30 2000/05/01 09:45:50 grog Exp grog $  * $FreeBSD$  */
end_comment

begin_define
define|#
directive|define
name|STATIC
value|static
end_define

begin_include
include|#
directive|include
file|<dev/vinum/vinumhdr.h>
end_include

begin_include
include|#
directive|include
file|<dev/vinum/request.h>
end_include

begin_define
define|#
directive|define
name|MAXTOKEN
value|64
end_define

begin_comment
comment|/* maximum number of tokens in a line */
end_comment

begin_comment
comment|/*  * We can afford the luxury of global variables here,  * since start_config ensures that these functions  * are single-threaded.  */
end_comment

begin_comment
comment|/* These are indices in vinum_conf of the last-mentioned of each kind of object */
end_comment

begin_decl_stmt
specifier|static
name|int
name|current_drive
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* note the last drive we mention, for 							    * some defaults */
end_comment

begin_decl_stmt
specifier|static
name|int
name|current_plex
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* and the same for the last plex */
end_comment

begin_decl_stmt
specifier|static
name|int
name|current_volume
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* and the last volme */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|_ioctl_reply
modifier|*
name|ioctl_reply
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* struct to return via ioctl */
end_comment

begin_comment
comment|/* These values are used by most of these routines, so set them as globals */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|token
index|[
name|MAXTOKEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointers to individual tokens */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tokens
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of tokens */
end_comment

begin_define
define|#
directive|define
name|TOCONS
value|0x01
end_define

begin_define
define|#
directive|define
name|TOTTY
value|0x02
end_define

begin_define
define|#
directive|define
name|TOLOG
value|0x04
end_define

begin_struct
struct|struct
name|putchar_arg
block|{
name|int
name|flags
decl_stmt|;
name|struct
name|tty
modifier|*
name|tty
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MSG_MAX
value|1024
end_define

begin_comment
comment|/* maximum length of a formatted message */
end_comment

begin_comment
comment|/*  * Format an error message and return to the user in the reply.  * CARE: This routine is designed to be called only from the  * configuration routines, so it assumes it's the owner of  * the configuration lock, and unlocks it on exit  */
end_comment

begin_function
name|void
name|throw_rude_remark
parameter_list|(
name|int
name|error
parameter_list|,
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
specifier|static
name|int
name|finishing
decl_stmt|;
comment|/* don't recurse */
name|int
name|was_finishing
decl_stmt|;
if|if
condition|(
operator|(
name|vinum_conf
operator|.
name|flags
operator|&
name|VF_LOCKED
operator|)
operator|==
literal|0
condition|)
comment|/* bug catcher */
name|panic
argument_list|(
literal|"throw_rude_remark: called without config lock"
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ioctl_reply
operator|!=
name|NULL
operator|)
comment|/* we're called from the user */
operator|&&
operator|(
operator|!
operator|(
name|vinum_conf
operator|.
name|flags
operator|&
name|VF_READING_CONFIG
operator|)
operator|)
condition|)
block|{
comment|/* and not reading from disk: return msg */
comment|/* 	 * We can't just format to ioctl_reply, since it 	 * may contain our input parameters 	 */
name|text
operator|=
name|Malloc
argument_list|(
name|MSG_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|text
operator|==
name|NULL
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"vinum: can't allocate error message buffer\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"vinum: "
argument_list|)
expr_stmt|;
name|vprintf
argument_list|(
name|msg
argument_list|,
name|ap
argument_list|)
expr_stmt|;
comment|/* print to the console */
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|=
name|kvprintf
argument_list|(
name|msg
argument_list|,
name|NULL
argument_list|,
operator|(
name|void
operator|*
operator|)
name|text
argument_list|,
literal|10
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|text
index|[
name|retval
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* delimit */
name|strcpy
argument_list|(
name|ioctl_reply
operator|->
name|msg
argument_list|,
name|text
argument_list|)
expr_stmt|;
name|ioctl_reply
operator|->
name|error
operator|=
name|error
expr_stmt|;
comment|/* first byte is the error number */
name|Free
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|"vinum: "
argument_list|)
expr_stmt|;
name|vprintf
argument_list|(
name|msg
argument_list|,
name|ap
argument_list|)
expr_stmt|;
comment|/* print to the console */
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|vinum_conf
operator|.
name|flags
operator|&
name|VF_READING_CONFIG
condition|)
block|{
comment|/* go through to the bitter end, */
if|if
condition|(
operator|(
name|vinum_conf
operator|.
name|flags
operator|&
name|VF_READING_CONFIG
operator|)
comment|/* we're reading from disk, */
operator|&&
operator|(
operator|(
name|daemon_options
operator|&
name|daemon_noupdate
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"Disabling configuration updates\n"
argument_list|)
expr_stmt|;
name|daemon_options
operator||=
name|daemon_noupdate
expr_stmt|;
block|}
return|return;
block|}
comment|/*      * We have a problem here: we want to unlock the      * configuration, which implies tidying up, but      * if we find an error while tidying up, we could      * recurse for ever.  Use this kludge to only try      * once      */
name|was_finishing
operator|=
name|finishing
expr_stmt|;
name|finishing
operator|=
literal|1
expr_stmt|;
name|finish_config
argument_list|(
name|was_finishing
argument_list|)
expr_stmt|;
comment|/* unlock anything we may be holding */
name|finishing
operator|=
name|was_finishing
expr_stmt|;
name|longjmp
argument_list|(
name|command_fail
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check a volume to see if the plex is already assigned to it.  * Return index in volume->plex, or -1 if not assigned  */
end_comment

begin_function
name|int
name|my_plex
parameter_list|(
name|int
name|volno
parameter_list|,
name|int
name|plexno
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|volume
modifier|*
name|vol
decl_stmt|;
name|vol
operator|=
operator|&
name|VOL
index|[
name|volno
index|]
expr_stmt|;
comment|/* point to volno */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vol
operator|->
name|plexes
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|vol
operator|->
name|plex
index|[
name|i
index|]
operator|==
name|plexno
condition|)
return|return
name|i
return|;
return|return
operator|-
literal|1
return|;
comment|/* not found */
block|}
end_function

begin_comment
comment|/*  * Check a plex to see if the subdisk is already assigned to it.  * Return index in plex->sd, or -1 if not assigned  */
end_comment

begin_function
name|int
name|my_sd
parameter_list|(
name|int
name|plexno
parameter_list|,
name|int
name|sdno
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|plex
modifier|*
name|plex
decl_stmt|;
name|plex
operator|=
operator|&
name|PLEX
index|[
name|plexno
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|plex
operator|->
name|subdisks
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|plex
operator|->
name|sdnos
index|[
name|i
index|]
operator|==
name|sdno
condition|)
return|return
name|i
return|;
return|return
operator|-
literal|1
return|;
comment|/* not found */
block|}
end_function

begin_comment
comment|/* Add plex to the volume if possible */
end_comment

begin_function
name|int
name|give_plex_to_volume
parameter_list|(
name|int
name|volno
parameter_list|,
name|int
name|plexno
parameter_list|)
block|{
name|struct
name|volume
modifier|*
name|vol
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/*      * It's not an error for the plex to already      * belong to the volume, but we need to check a      * number of things to make sure it's done right.      * Some day.      */
if|if
condition|(
name|my_plex
argument_list|(
name|volno
argument_list|,
name|plexno
argument_list|)
operator|>=
literal|0
condition|)
return|return
name|plexno
return|;
comment|/* that's it */
name|vol
operator|=
operator|&
name|VOL
index|[
name|volno
index|]
expr_stmt|;
comment|/* point to volume */
if|if
condition|(
name|vol
operator|->
name|plexes
operator|==
name|MAXPLEX
condition|)
comment|/* all plexes allocated */
name|throw_rude_remark
argument_list|(
name|ENOSPC
argument_list|,
literal|"Too many plexes for volume %s"
argument_list|,
name|vol
operator|->
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|vol
operator|->
name|plexes
operator|>
literal|0
operator|)
comment|/* we have other plexes */
operator|&&
operator|(
operator|(
name|vol
operator|->
name|flags
operator|&
name|VF_CONFIG_SETUPSTATE
operator|)
operator|==
literal|0
operator|)
condition|)
comment|/* and we're not setting up state */
name|invalidate_subdisks
argument_list|(
operator|&
name|PLEX
index|[
name|plexno
index|]
argument_list|,
name|sd_stale
argument_list|)
expr_stmt|;
comment|/* make the subdisks invalid */
name|vol
operator|->
name|plex
index|[
name|vol
operator|->
name|plexes
index|]
operator|=
name|plexno
expr_stmt|;
comment|/* this one */
name|vol
operator|->
name|plexes
operator|++
expr_stmt|;
comment|/* add another plex */
name|PLEX
index|[
name|plexno
index|]
operator|.
name|volno
operator|=
name|volno
expr_stmt|;
comment|/* note the number of our volume */
comment|/* Find out how big our volume is */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vol
operator|->
name|plexes
condition|;
name|i
operator|++
control|)
name|vol
operator|->
name|size
operator|=
name|max
argument_list|(
name|vol
operator|->
name|size
argument_list|,
name|PLEX
index|[
name|vol
operator|->
name|plex
index|[
name|i
index|]
index|]
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
name|vol
operator|->
name|plexes
operator|-
literal|1
return|;
comment|/* and return its index */
block|}
end_function

begin_comment
comment|/*  * Add subdisk to a plex if possible  */
end_comment

begin_function
name|int
name|give_sd_to_plex
parameter_list|(
name|int
name|plexno
parameter_list|,
name|int
name|sdno
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|plex
modifier|*
name|plex
decl_stmt|;
name|struct
name|sd
modifier|*
name|sd
decl_stmt|;
comment|/*      * It's not an error for the sd to already      * belong to the plex, but we need to check a      * number of things to make sure it's done right.      * Some day.      */
name|i
operator|=
name|my_sd
argument_list|(
name|plexno
argument_list|,
name|sdno
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
comment|/* does it already belong to us? */
return|return
name|i
return|;
comment|/* that's it */
name|plex
operator|=
operator|&
name|PLEX
index|[
name|plexno
index|]
expr_stmt|;
comment|/* point to the plex */
name|sd
operator|=
operator|&
name|SD
index|[
name|sdno
index|]
expr_stmt|;
comment|/* and the subdisk */
comment|/* Do we have an offset?  Otherwise put it after the last one */
if|if
condition|(
name|sd
operator|->
name|plexoffset
operator|<
literal|0
condition|)
block|{
comment|/* no offset specified */
if|if
condition|(
name|plex
operator|->
name|subdisks
operator|>
literal|0
condition|)
block|{
name|struct
name|sd
modifier|*
name|lastsd
init|=
operator|&
name|SD
index|[
name|plex
operator|->
name|sdnos
index|[
name|plex
operator|->
name|subdisks
operator|-
literal|1
index|]
index|]
decl_stmt|;
comment|/* last subdisk */
if|if
condition|(
name|plex
operator|->
name|organization
operator|==
name|plex_concat
condition|)
comment|/* concat, */
name|sd
operator|->
name|plexoffset
operator|=
name|lastsd
operator|->
name|sectors
operator|+
name|lastsd
operator|->
name|plexoffset
expr_stmt|;
comment|/* starts here */
else|else
comment|/* striped, RAID-4 or RAID-5 */
name|sd
operator|->
name|plexoffset
operator|=
name|plex
operator|->
name|stripesize
operator|*
name|plex
operator|->
name|subdisks
expr_stmt|;
comment|/* starts here */
block|}
else|else
comment|/* first subdisk */
name|sd
operator|->
name|plexoffset
operator|=
literal|0
expr_stmt|;
comment|/* start at the beginning */
block|}
if|if
condition|(
name|plex
operator|->
name|subdisks
operator|==
name|MAXSD
condition|)
comment|/* we already have our maximum */
name|throw_rude_remark
argument_list|(
name|ENOSPC
argument_list|,
comment|/* crap out */
literal|"Can't add %s to %s: plex full"
argument_list|,
name|sd
operator|->
name|name
argument_list|,
name|plex
operator|->
name|name
argument_list|)
expr_stmt|;
name|plex
operator|->
name|subdisks
operator|++
expr_stmt|;
comment|/* another entry */
if|if
condition|(
name|plex
operator|->
name|subdisks
operator|>=
name|plex
operator|->
name|subdisks_allocated
condition|)
comment|/* need more space */
name|EXPAND
argument_list|(
name|plex
operator|->
name|sdnos
argument_list|,
name|int
argument_list|,
name|plex
operator|->
name|subdisks_allocated
argument_list|,
name|INITIAL_SUBDISKS_IN_PLEX
argument_list|)
expr_stmt|;
comment|/* Adjust size of plex and volume. */
if|if
condition|(
name|isparity
argument_list|(
name|plex
argument_list|)
condition|)
comment|/* RAID-4 or RAID-5 */
name|plex
operator|->
name|length
operator|=
operator|(
name|plex
operator|->
name|subdisks
operator|-
literal|1
operator|)
operator|*
name|sd
operator|->
name|sectors
expr_stmt|;
comment|/* size is one disk short */
else|else
name|plex
operator|->
name|length
operator|+=
name|sd
operator|->
name|sectors
expr_stmt|;
comment|/* plex gets this much bigger */
if|if
condition|(
name|plex
operator|->
name|volno
operator|>=
literal|0
condition|)
comment|/* we have a volume */
name|VOL
index|[
name|plex
operator|->
name|volno
index|]
operator|.
name|size
operator|=
name|max
argument_list|(
name|VOL
index|[
name|plex
operator|->
name|volno
index|]
operator|.
name|size
argument_list|,
name|plex
operator|->
name|length
argument_list|)
expr_stmt|;
comment|/* adjust its size */
comment|/*      * We need to check that the subdisks don't overlap,      * but we can't do that until a point where we *must*      * know the size of all the subdisks.  That's not      * here.  But we need to sort them by offset      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|plex
operator|->
name|subdisks
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sd
operator|->
name|plexoffset
operator|<
name|SD
index|[
name|plex
operator|->
name|sdnos
index|[
name|i
index|]
index|]
operator|.
name|plexoffset
condition|)
block|{
comment|/* it fits before this one */
comment|/* First move any remaining subdisks by one */
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|plex
operator|->
name|subdisks
operator|-
literal|1
init|;
name|j
operator|>
name|i
condition|;
name|j
operator|--
control|)
comment|/* move up one at a time */
name|plex
operator|->
name|sdnos
index|[
name|j
index|]
operator|=
name|plex
operator|->
name|sdnos
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
name|plex
operator|->
name|sdnos
index|[
name|i
index|]
operator|=
name|sdno
expr_stmt|;
name|sd
operator|->
name|plexsdno
operator|=
name|i
expr_stmt|;
comment|/* note where we are in the subdisk */
return|return
name|i
return|;
block|}
block|}
comment|/*      * The plex doesn't have any subdisk with a      * larger offset.  Insert it here.      */
name|plex
operator|->
name|sdnos
index|[
name|i
index|]
operator|=
name|sdno
expr_stmt|;
name|sd
operator|->
name|plexsdno
operator|=
name|i
expr_stmt|;
comment|/* note where we are in the subdisk */
name|sd
operator|->
name|plexno
operator|=
name|plex
operator|->
name|plexno
expr_stmt|;
comment|/* and who we belong to */
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/*  * Add a subdisk to drive if possible.  The  * pointer to the drive must already be stored in  * the sd structure, but the drive doesn't know  * about the subdisk yet.  */
end_comment

begin_function
name|void
name|give_sd_to_drive
parameter_list|(
name|int
name|sdno
parameter_list|)
block|{
name|struct
name|sd
modifier|*
name|sd
decl_stmt|;
comment|/* pointer to subdisk */
name|struct
name|drive
modifier|*
name|drive
decl_stmt|;
comment|/* and drive */
name|int
name|fe
decl_stmt|;
comment|/* index in free list */
name|int
name|sfe
decl_stmt|;
comment|/* and index of subdisk when assigning max */
name|sd
operator|=
operator|&
name|SD
index|[
name|sdno
index|]
expr_stmt|;
comment|/* point to sd */
name|drive
operator|=
operator|&
name|DRIVE
index|[
name|sd
operator|->
name|driveno
index|]
expr_stmt|;
comment|/* and drive */
if|if
condition|(
name|drive
operator|->
name|state
operator|!=
name|drive_up
condition|)
block|{
name|update_sd_state
argument_list|(
name|sdno
argument_list|)
expr_stmt|;
comment|/* that crashes the subdisk */
return|return;
block|}
if|if
condition|(
name|drive
operator|->
name|flags
operator|&
name|VF_HOTSPARE
condition|)
comment|/* the drive is a hot spare, */
name|throw_rude_remark
argument_list|(
name|ENOSPC
argument_list|,
literal|"Can't place %s on hot spare drive %s"
argument_list|,
name|sd
operator|->
name|name
argument_list|,
name|drive
operator|->
name|label
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|drive
operator|->
name|sectors_available
operator|==
literal|0
operator|)
comment|/* no space left */
operator|||
operator|(
name|sd
operator|->
name|sectors
operator|>
name|drive
operator|->
name|sectors_available
operator|)
condition|)
block|{
comment|/* or too big, */
name|sd
operator|->
name|driveoffset
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* don't be confusing */
name|free_sd
argument_list|(
name|sd
operator|->
name|sdno
argument_list|)
expr_stmt|;
name|throw_rude_remark
argument_list|(
name|ENOSPC
argument_list|,
literal|"No space for %s on %s"
argument_list|,
name|sd
operator|->
name|name
argument_list|,
name|drive
operator|->
name|label
operator|.
name|name
argument_list|)
expr_stmt|;
return|return;
comment|/* in case we come back here */
block|}
name|drive
operator|->
name|subdisks_used
operator|++
expr_stmt|;
comment|/* one more subdisk */
if|if
condition|(
name|sd
operator|->
name|sectors
operator|==
literal|0
condition|)
block|{
comment|/* take the largest chunk */
name|sfe
operator|=
literal|0
expr_stmt|;
comment|/* to keep the compiler happy */
for|for
control|(
name|fe
operator|=
literal|0
init|;
name|fe
operator|<
name|drive
operator|->
name|freelist_entries
condition|;
name|fe
operator|++
control|)
block|{
if|if
condition|(
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
operator|.
name|sectors
operator|>=
name|sd
operator|->
name|sectors
condition|)
block|{
comment|/* more space here */
name|sd
operator|->
name|sectors
operator|=
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
operator|.
name|sectors
expr_stmt|;
comment|/* take it */
name|sd
operator|->
name|driveoffset
operator|=
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
operator|.
name|offset
expr_stmt|;
name|sfe
operator|=
name|fe
expr_stmt|;
comment|/* and note the index for later */
block|}
block|}
if|if
condition|(
name|sd
operator|->
name|sectors
operator|==
literal|0
condition|)
block|{
comment|/* no luck, */
name|sd
operator|->
name|driveoffset
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* don't be confusing */
name|free_sd
argument_list|(
name|sd
operator|->
name|sdno
argument_list|)
expr_stmt|;
name|throw_rude_remark
argument_list|(
name|ENOSPC
argument_list|,
comment|/* give up */
literal|"No space for %s on %s"
argument_list|,
name|sd
operator|->
name|name
argument_list|,
name|drive
operator|->
name|label
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sfe
operator|<
operator|(
name|drive
operator|->
name|freelist_entries
operator|-
literal|1
operator|)
condition|)
comment|/* not the last one, */
name|bcopy
argument_list|(
operator|&
name|drive
operator|->
name|freelist
index|[
name|sfe
operator|+
literal|1
index|]
argument_list|,
operator|&
name|drive
operator|->
name|freelist
index|[
name|sfe
index|]
argument_list|,
operator|(
name|drive
operator|->
name|freelist_entries
operator|-
name|sfe
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|drive_freelist
argument_list|)
argument_list|)
expr_stmt|;
name|drive
operator|->
name|freelist_entries
operator|--
expr_stmt|;
comment|/* one less entry */
name|drive
operator|->
name|sectors_available
operator|-=
name|sd
operator|->
name|sectors
expr_stmt|;
comment|/* and note how much less space we have */
block|}
elseif|else
if|if
condition|(
name|sd
operator|->
name|driveoffset
operator|<
literal|0
condition|)
block|{
comment|/* no offset specified, find one */
for|for
control|(
name|fe
operator|=
literal|0
init|;
name|fe
operator|<
name|drive
operator|->
name|freelist_entries
condition|;
name|fe
operator|++
control|)
block|{
if|if
condition|(
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
operator|.
name|sectors
operator|>=
name|sd
operator|->
name|sectors
condition|)
block|{
comment|/* it'll fit here */
name|sd
operator|->
name|driveoffset
operator|=
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
operator|.
name|offset
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|sectors
operator|==
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
operator|.
name|sectors
condition|)
block|{
comment|/* used up the entire entry */
if|if
condition|(
name|fe
operator|<
operator|(
name|drive
operator|->
name|freelist_entries
operator|-
literal|1
operator|)
condition|)
comment|/* not the last one, */
name|bcopy
argument_list|(
operator|&
name|drive
operator|->
name|freelist
index|[
name|fe
operator|+
literal|1
index|]
argument_list|,
operator|&
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
argument_list|,
operator|(
name|drive
operator|->
name|freelist_entries
operator|-
name|fe
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|drive_freelist
argument_list|)
argument_list|)
expr_stmt|;
name|drive
operator|->
name|freelist_entries
operator|--
expr_stmt|;
comment|/* one less entry */
block|}
else|else
block|{
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
operator|.
name|sectors
operator|-=
name|sd
operator|->
name|sectors
expr_stmt|;
comment|/* this much less space */
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
operator|.
name|offset
operator|+=
name|sd
operator|->
name|sectors
expr_stmt|;
comment|/* this much further on */
block|}
name|drive
operator|->
name|sectors_available
operator|-=
name|sd
operator|->
name|sectors
expr_stmt|;
comment|/* and note how much less space we have */
break|break;
block|}
block|}
if|if
condition|(
name|sd
operator|->
name|driveoffset
operator|<
literal|0
condition|)
comment|/* 	     * Didn't find anything.  Although the drive has 	     * enough space, it's too fragmented 	     */
block|{
name|free_sd
argument_list|(
name|sd
operator|->
name|sdno
argument_list|)
expr_stmt|;
name|throw_rude_remark
argument_list|(
name|ENOSPC
argument_list|,
literal|"No space for %s on %s"
argument_list|,
name|sd
operator|->
name|name
argument_list|,
name|drive
operator|->
name|label
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* specific offset */
comment|/* 	 * For a specific offset to work, the space must be 	 * entirely in a single freelist entry.  Look for it. 	 */
name|u_int64_t
name|sdend
init|=
name|sd
operator|->
name|driveoffset
operator|+
name|sd
operator|->
name|sectors
decl_stmt|;
comment|/* end of our subdisk */
for|for
control|(
name|fe
operator|=
literal|0
init|;
name|fe
operator|<
name|drive
operator|->
name|freelist_entries
condition|;
name|fe
operator|++
control|)
block|{
name|u_int64_t
name|dend
init|=
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
operator|.
name|offset
operator|+
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
operator|.
name|sectors
decl_stmt|;
comment|/* end of entry */
if|if
condition|(
name|dend
operator|>=
name|sdend
condition|)
block|{
comment|/* fits before here */
if|if
condition|(
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
operator|.
name|offset
operator|>
name|sd
operator|->
name|driveoffset
condition|)
block|{
comment|/* starts after the beginning of sd area */
name|sd
operator|->
name|driveoffset
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* don't be confusing */
name|set_sd_state
argument_list|(
name|sd
operator|->
name|sdno
argument_list|,
name|sd_down
argument_list|,
name|setstate_force
argument_list|)
expr_stmt|;
name|throw_rude_remark
argument_list|(
name|ENOSPC
argument_list|,
literal|"No space for %s on drive %s at offset %lld"
argument_list|,
name|sd
operator|->
name|name
argument_list|,
name|drive
operator|->
name|label
operator|.
name|name
argument_list|,
name|sd
operator|->
name|driveoffset
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * We've found the space, and we can allocate it. 		 * We don't need to say that to the subdisk, which 		 * already knows about it.  We need to tell it to 		 * the free list, though.  We have four possibilities: 		 * 		 * 1.  The subdisk exactly eats up the entry.  That's the 		 *     same as above. 		 * 2.  The subdisk starts at the beginning and leaves space 		 *     at the end. 		 * 3.  The subdisk starts after the beginning and leaves 		 *     space at the end as well: we end up with another 		 *     fragment. 		 * 4.  The subdisk leaves space at the beginning and finishes 		 *     at the end. 		 */
name|drive
operator|->
name|sectors_available
operator|-=
name|sd
operator|->
name|sectors
expr_stmt|;
comment|/* note how much less space we have */
if|if
condition|(
name|sd
operator|->
name|driveoffset
operator|==
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
operator|.
name|offset
condition|)
block|{
comment|/* 1 or 2 */
if|if
condition|(
name|sd
operator|->
name|sectors
operator|==
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
operator|.
name|sectors
condition|)
block|{
comment|/* 1: used up the entire entry */
if|if
condition|(
name|fe
operator|<
operator|(
name|drive
operator|->
name|freelist_entries
operator|-
literal|1
operator|)
condition|)
comment|/* not the last one, */
name|bcopy
argument_list|(
operator|&
name|drive
operator|->
name|freelist
index|[
name|fe
operator|+
literal|1
index|]
argument_list|,
operator|&
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
argument_list|,
operator|(
name|drive
operator|->
name|freelist_entries
operator|-
name|fe
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|drive_freelist
argument_list|)
argument_list|)
expr_stmt|;
name|drive
operator|->
name|freelist_entries
operator|--
expr_stmt|;
comment|/* one less entry */
block|}
else|else
block|{
comment|/* 2: space at the end */
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
operator|.
name|sectors
operator|-=
name|sd
operator|->
name|sectors
expr_stmt|;
comment|/* this much less space */
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
operator|.
name|offset
operator|+=
name|sd
operator|->
name|sectors
expr_stmt|;
comment|/* this much further on */
block|}
block|}
else|else
block|{
comment|/* 3 or 4 */
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
operator|.
name|sectors
operator|=
name|sd
operator|->
name|driveoffset
operator|-
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
operator|.
name|offset
expr_stmt|;
if|if
condition|(
name|dend
operator|>
name|sdend
condition|)
block|{
comment|/* 3: space at the end as well */
if|if
condition|(
name|fe
operator|<
operator|(
name|drive
operator|->
name|freelist_entries
operator|-
literal|1
operator|)
condition|)
comment|/* not the last one */
name|bcopy
argument_list|(
operator|&
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
argument_list|,
comment|/* move the rest down */
operator|&
name|drive
operator|->
name|freelist
index|[
name|fe
operator|+
literal|1
index|]
argument_list|,
operator|(
name|drive
operator|->
name|freelist_entries
operator|-
name|fe
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|drive_freelist
argument_list|)
argument_list|)
expr_stmt|;
name|drive
operator|->
name|freelist_entries
operator|++
expr_stmt|;
comment|/* one less entry */
name|drive
operator|->
name|freelist
index|[
name|fe
operator|+
literal|1
index|]
operator|.
name|offset
operator|=
name|sdend
expr_stmt|;
comment|/* second entry starts after sd */
name|drive
operator|->
name|freelist
index|[
name|fe
operator|+
literal|1
index|]
operator|.
name|sectors
operator|=
name|dend
operator|-
name|sdend
expr_stmt|;
comment|/* and is this long */
block|}
block|}
break|break;
block|}
block|}
block|}
name|drive
operator|->
name|opencount
operator|++
expr_stmt|;
comment|/* one more subdisk attached */
block|}
end_function

begin_comment
comment|/* Get an empty drive entry from the drive table */
end_comment

begin_function
name|int
name|get_empty_drive
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|driveno
decl_stmt|;
name|struct
name|drive
modifier|*
name|drive
decl_stmt|;
comment|/* first see if we have one which has been deallocated */
for|for
control|(
name|driveno
operator|=
literal|0
init|;
name|driveno
operator|<
name|vinum_conf
operator|.
name|drives_allocated
condition|;
name|driveno
operator|++
control|)
block|{
if|if
condition|(
name|DRIVE
index|[
name|driveno
index|]
operator|.
name|state
operator|==
name|drive_unallocated
condition|)
comment|/* bingo */
break|break;
block|}
if|if
condition|(
name|driveno
operator|>=
name|vinum_conf
operator|.
name|drives_allocated
condition|)
comment|/* we've used all our allocation */
name|EXPAND
argument_list|(
name|DRIVE
argument_list|,
expr|struct
name|drive
argument_list|,
name|vinum_conf
operator|.
name|drives_allocated
argument_list|,
name|INITIAL_DRIVES
argument_list|)
expr_stmt|;
comment|/* got a drive entry.  Make it pretty */
name|drive
operator|=
operator|&
name|DRIVE
index|[
name|driveno
index|]
expr_stmt|;
name|bzero
argument_list|(
name|drive
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|drive
argument_list|)
argument_list|)
expr_stmt|;
name|drive
operator|->
name|driveno
operator|=
name|driveno
expr_stmt|;
comment|/* put number in structure */
name|drive
operator|->
name|flags
operator||=
name|VF_NEWBORN
expr_stmt|;
comment|/* newly born drive */
name|strcpy
argument_list|(
literal|"unknown"
argument_list|,
name|drive
operator|->
name|devicename
argument_list|)
expr_stmt|;
comment|/* and make the name ``unknown'' */
return|return
name|driveno
return|;
comment|/* return the index */
block|}
end_function

begin_comment
comment|/*  * Find the named drive in vinum_conf.drive, return a pointer  * return the index in vinum_conf.drive.  * Don't mark the drive as allocated (XXX SMP)  * If create != 0, create an entry if it doesn't exist  */
end_comment

begin_comment
comment|/* XXX check if we have it open from attach */
end_comment

begin_function
name|int
name|find_drive
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|create
parameter_list|)
block|{
name|int
name|driveno
decl_stmt|;
name|struct
name|drive
modifier|*
name|drive
decl_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|driveno
operator|=
literal|0
init|;
name|driveno
operator|<
name|vinum_conf
operator|.
name|drives_allocated
condition|;
name|driveno
operator|++
control|)
block|{
name|drive
operator|=
operator|&
name|DRIVE
index|[
name|driveno
index|]
expr_stmt|;
comment|/* point to drive */
if|if
condition|(
operator|(
name|drive
operator|->
name|label
operator|.
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|)
comment|/* it has a name */
operator|&&
operator|(
name|strcmp
argument_list|(
name|drive
operator|->
name|label
operator|.
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
operator|)
comment|/* and it's this one */
operator|&&
operator|(
name|drive
operator|->
name|state
operator|>
name|drive_unallocated
operator|)
condition|)
comment|/* and it's a real one: found */
return|return
name|driveno
return|;
block|}
block|}
comment|/* the drive isn't in the list.  Add it if he wants */
if|if
condition|(
name|create
operator|==
literal|0
condition|)
comment|/* don't want to create */
return|return
operator|-
literal|1
return|;
comment|/* give up */
name|driveno
operator|=
name|get_empty_drive
argument_list|()
expr_stmt|;
name|drive
operator|=
operator|&
name|DRIVE
index|[
name|driveno
index|]
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
name|bcopy
argument_list|(
name|name
argument_list|,
comment|/* put in its name */
name|drive
operator|->
name|label
operator|.
name|name
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|drive
operator|->
name|label
operator|.
name|name
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|drive
operator|->
name|state
operator|=
name|drive_referenced
expr_stmt|;
comment|/* in use, nothing worthwhile there */
return|return
name|driveno
return|;
comment|/* return the index */
block|}
end_function

begin_comment
comment|/*  * Find a drive given its device name.  * devname must be valid.  * Otherwise the same as find_drive above  */
end_comment

begin_function
name|int
name|find_drive_by_dev
parameter_list|(
specifier|const
name|char
modifier|*
name|devname
parameter_list|,
name|int
name|create
parameter_list|)
block|{
name|int
name|driveno
decl_stmt|;
name|struct
name|drive
modifier|*
name|drive
decl_stmt|;
for|for
control|(
name|driveno
operator|=
literal|0
init|;
name|driveno
operator|<
name|vinum_conf
operator|.
name|drives_allocated
condition|;
name|driveno
operator|++
control|)
block|{
name|drive
operator|=
operator|&
name|DRIVE
index|[
name|driveno
index|]
expr_stmt|;
comment|/* point to drive */
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|drive
operator|->
name|devicename
argument_list|,
name|devname
argument_list|)
operator|==
literal|0
operator|)
comment|/* it's this device */
operator|&&
operator|(
name|drive
operator|->
name|state
operator|>
name|drive_unallocated
operator|)
condition|)
comment|/* and it's a real one: found */
return|return
name|driveno
return|;
block|}
comment|/* the drive isn't in the list.  Add it if he wants */
if|if
condition|(
name|create
operator|==
literal|0
condition|)
comment|/* don't want to create */
return|return
operator|-
literal|1
return|;
comment|/* give up */
name|driveno
operator|=
name|get_empty_drive
argument_list|()
expr_stmt|;
name|drive
operator|=
operator|&
name|DRIVE
index|[
name|driveno
index|]
expr_stmt|;
name|bcopy
argument_list|(
name|devname
argument_list|,
comment|/* put in its name */
name|drive
operator|->
name|devicename
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|drive
operator|->
name|devicename
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|devname
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|drive
operator|->
name|state
operator|=
name|drive_referenced
expr_stmt|;
comment|/* in use, nothing worthwhile there */
return|return
name|driveno
return|;
comment|/* return the index */
block|}
end_function

begin_comment
comment|/* Find an empty subdisk in the subdisk table */
end_comment

begin_function
name|int
name|get_empty_sd
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|sdno
decl_stmt|;
name|struct
name|sd
modifier|*
name|sd
decl_stmt|;
comment|/* first see if we have one which has been deallocated */
for|for
control|(
name|sdno
operator|=
literal|0
init|;
name|sdno
operator|<
name|vinum_conf
operator|.
name|subdisks_allocated
condition|;
name|sdno
operator|++
control|)
block|{
if|if
condition|(
name|SD
index|[
name|sdno
index|]
operator|.
name|state
operator|==
name|sd_unallocated
condition|)
comment|/* bingo */
break|break;
block|}
if|if
condition|(
name|sdno
operator|>=
name|vinum_conf
operator|.
name|subdisks_allocated
condition|)
comment|/* 	 * We've run out of space.  sdno is pointing 	 * where we want it, but at the moment we 	 * don't have the space.  Get it. 	 */
name|EXPAND
argument_list|(
name|SD
argument_list|,
expr|struct
name|sd
argument_list|,
name|vinum_conf
operator|.
name|subdisks_allocated
argument_list|,
name|INITIAL_SUBDISKS
argument_list|)
expr_stmt|;
comment|/* initialize some things */
name|sd
operator|=
operator|&
name|SD
index|[
name|sdno
index|]
expr_stmt|;
comment|/* point to it */
name|bzero
argument_list|(
name|sd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* initialize */
name|sd
operator|->
name|flags
operator||=
name|VF_NEWBORN
expr_stmt|;
comment|/* newly born subdisk */
name|sd
operator|->
name|plexno
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* no plex */
name|sd
operator|->
name|sectors
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* no space */
name|sd
operator|->
name|driveno
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* no drive */
name|sd
operator|->
name|plexoffset
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* and no offsets */
name|sd
operator|->
name|driveoffset
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|sdno
return|;
comment|/* return the index */
block|}
end_function

begin_comment
comment|/* return a drive to the free pool */
end_comment

begin_function
name|void
name|free_drive
parameter_list|(
name|struct
name|drive
modifier|*
name|drive
parameter_list|)
block|{
if|if
condition|(
operator|(
name|drive
operator|->
name|state
operator|>
name|drive_referenced
operator|)
comment|/* real drive */
operator|||
operator|(
name|drive
operator|->
name|flags
operator|&
name|VF_OPEN
operator|)
condition|)
block|{
comment|/* how can it be open without a state? */
name|LOCKDRIVE
argument_list|(
name|drive
argument_list|)
expr_stmt|;
if|if
condition|(
name|drive
operator|->
name|flags
operator|&
name|VF_OPEN
condition|)
block|{
comment|/* it's open, */
name|close_locked_drive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
comment|/* close it */
name|drive
operator|->
name|state
operator|=
name|drive_down
expr_stmt|;
comment|/* and note the fact */
block|}
if|if
condition|(
name|drive
operator|->
name|freelist
condition|)
name|Free
argument_list|(
name|drive
operator|->
name|freelist
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|drive
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|drive
argument_list|)
argument_list|)
expr_stmt|;
comment|/* this also sets drive_unallocated */
name|unlockdrive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Find the named subdisk in vinum_conf.sd.  *  * If create != 0, create an entry if it doesn't exist  *  * Return index in vinum_conf.sd  */
end_comment

begin_function
name|int
name|find_subdisk
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|create
parameter_list|)
block|{
name|int
name|sdno
decl_stmt|;
name|struct
name|sd
modifier|*
name|sd
decl_stmt|;
for|for
control|(
name|sdno
operator|=
literal|0
init|;
name|sdno
operator|<
name|vinum_conf
operator|.
name|subdisks_allocated
condition|;
name|sdno
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|SD
index|[
name|sdno
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
comment|/* found it */
return|return
name|sdno
return|;
block|}
comment|/* the subdisk isn't in the list.  Add it if he wants */
if|if
condition|(
name|create
operator|==
literal|0
condition|)
comment|/* don't want to create */
return|return
operator|-
literal|1
return|;
comment|/* give up */
comment|/* Allocate one and insert the name */
name|sdno
operator|=
name|get_empty_sd
argument_list|()
expr_stmt|;
name|sd
operator|=
operator|&
name|SD
index|[
name|sdno
index|]
expr_stmt|;
name|bcopy
argument_list|(
name|name
argument_list|,
name|sd
operator|->
name|name
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|sd
operator|->
name|name
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* put in its name */
return|return
name|sdno
return|;
comment|/* return the pointer */
block|}
end_function

begin_comment
comment|/* Return space to a drive */
end_comment

begin_function
name|void
name|return_drive_space
parameter_list|(
name|int
name|driveno
parameter_list|,
name|int64_t
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|struct
name|drive
modifier|*
name|drive
decl_stmt|;
name|int
name|fe
decl_stmt|;
comment|/* free list entry */
name|u_int64_t
name|sdend
decl_stmt|;
comment|/* end of our subdisk */
name|u_int64_t
name|dend
decl_stmt|;
comment|/* end of our freelist entry */
name|drive
operator|=
operator|&
name|DRIVE
index|[
name|driveno
index|]
expr_stmt|;
if|if
condition|(
name|drive
operator|->
name|state
operator|==
name|drive_up
condition|)
block|{
name|sdend
operator|=
name|offset
operator|+
name|length
expr_stmt|;
comment|/* end of our subdisk */
comment|/* Look for where to return the sd address space */
for|for
control|(
name|fe
operator|=
literal|0
init|;
operator|(
name|fe
operator|<
name|drive
operator|->
name|freelist_entries
operator|)
operator|&&
operator|(
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
operator|.
name|offset
operator|<
name|offset
operator|)
condition|;
name|fe
operator|++
control|)
empty_stmt|;
comment|/* 	 * Now we are pointing to the last entry, the first 	 * with a higher offset than the subdisk, or both. 	 */
if|if
condition|(
operator|(
name|fe
operator|>
literal|1
operator|)
comment|/* not the first entry */
operator|&&
operator|(
operator|(
name|fe
operator|==
name|drive
operator|->
name|freelist_entries
operator|)
comment|/* gone past the end */
operator|||
operator|(
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
operator|.
name|offset
operator|>
name|offset
operator|)
operator|)
condition|)
comment|/* or past the block were looking for */
name|fe
operator|--
expr_stmt|;
comment|/* point to the block before */
name|dend
operator|=
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
operator|.
name|offset
operator|+
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
operator|.
name|sectors
expr_stmt|;
comment|/* end of the entry */
comment|/* 	 * At this point, we are pointing to the correct 	 * place in the free list.  A number of possibilities 	 * exist: 	 * 	 * 1.  The block to be freed starts at the end of the 	 *     block to which we are pointing.  This has two 	 *     subcases: 	 * 	 * a.  The block to be freed ends at the beginning 	 *     of the following block.  Merge the three 	 *     areas into a single block. 	 * 	 * b.  The block is shorter than the space between 	 *     the current block and the next one.  Enlarge 	 *     the current block. 	 * 	 * 2.  The block to be freed starts after the end 	 *     of the block.  Again, we have two cases: 	 * 	 * a.  It ends before the start of the following block. 	 *     Create a new free block. 	 * 	 * b.  It ends at the start of the following block. 	 *     Enlarge the following block downwards. 	 * 	 * When there is only one free space block, and the 	 * space to be returned is before it, the pointer is 	 * to a non-existent zeroth block. XXX check this 	 */
if|if
condition|(
name|offset
operator|==
name|dend
condition|)
block|{
comment|/* Case 1: it starts at the end of this block */
if|if
condition|(
operator|(
name|fe
operator|<
name|drive
operator|->
name|freelist_entries
operator|-
literal|1
operator|)
comment|/* we're not the last block in the free list */
comment|/* and the subdisk ends at the start of the next block */
operator|&&
operator|(
name|sdend
operator|==
name|drive
operator|->
name|freelist
index|[
name|fe
operator|+
literal|1
index|]
operator|.
name|offset
operator|)
condition|)
block|{
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
operator|.
name|sectors
comment|/* 1a: merge all three blocks */
operator|=
name|drive
operator|->
name|freelist
index|[
name|fe
operator|+
literal|1
index|]
operator|.
name|sectors
expr_stmt|;
if|if
condition|(
name|fe
operator|<
name|drive
operator|->
name|freelist_entries
operator|-
literal|2
condition|)
comment|/* still more blocks after next */
name|bcopy
argument_list|(
operator|&
name|drive
operator|->
name|freelist
index|[
name|fe
operator|+
literal|2
index|]
argument_list|,
comment|/* move down one */
operator|&
name|drive
operator|->
name|freelist
index|[
name|fe
operator|+
literal|1
index|]
argument_list|,
operator|(
name|drive
operator|->
name|freelist_entries
operator|-
literal|2
operator|-
name|fe
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|drive_freelist
argument_list|)
argument_list|)
expr_stmt|;
name|drive
operator|->
name|freelist_entries
operator|--
expr_stmt|;
comment|/* one less entry in the free list */
block|}
else|else
comment|/* 1b: just enlarge this block */
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
operator|.
name|sectors
operator|+=
name|length
expr_stmt|;
block|}
else|else
block|{
comment|/* Case 2 */
if|if
condition|(
name|offset
operator|>
name|dend
condition|)
comment|/* it starts after this block */
name|fe
operator|++
expr_stmt|;
comment|/* so look at the next block */
if|if
condition|(
operator|(
name|fe
operator|<
name|drive
operator|->
name|freelist_entries
operator|)
comment|/* we're not the last block in the free list */
comment|/* and the subdisk ends at the start of this block: case 4 */
operator|&&
operator|(
name|sdend
operator|==
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
operator|.
name|offset
operator|)
condition|)
block|{
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
comment|/* it starts where the sd was */
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
operator|.
name|sectors
operator|+=
name|length
expr_stmt|;
comment|/* and it's this much bigger */
block|}
else|else
block|{
comment|/* case 3: non-contiguous */
if|if
condition|(
name|fe
operator|<
name|drive
operator|->
name|freelist_entries
condition|)
comment|/* not after the last block, */
name|bcopy
argument_list|(
operator|&
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
argument_list|,
comment|/* move the rest up one entry */
operator|&
name|drive
operator|->
name|freelist
index|[
name|fe
operator|+
literal|1
index|]
argument_list|,
operator|(
name|drive
operator|->
name|freelist_entries
operator|-
name|fe
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|drive_freelist
argument_list|)
argument_list|)
expr_stmt|;
name|drive
operator|->
name|freelist_entries
operator|++
expr_stmt|;
comment|/* one less entry */
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
comment|/* this entry represents the sd */
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
operator|.
name|sectors
operator|=
name|length
expr_stmt|;
block|}
block|}
name|drive
operator|->
name|sectors_available
operator|+=
name|length
expr_stmt|;
comment|/* the sectors are now available */
block|}
block|}
end_function

begin_comment
comment|/*  * Free an allocated sd entry.  * This performs memory management only.  remove()  * is responsible for checking relationships.  */
end_comment

begin_function
name|void
name|free_sd
parameter_list|(
name|int
name|sdno
parameter_list|)
block|{
name|struct
name|sd
modifier|*
name|sd
decl_stmt|;
name|sd
operator|=
operator|&
name|SD
index|[
name|sdno
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|sd
operator|->
name|driveno
operator|>=
literal|0
operator|)
comment|/* we have a drive, */
operator|&&
operator|(
name|sd
operator|->
name|sectors
operator|>
literal|0
operator|)
condition|)
comment|/* and some space on it */
name|return_drive_space
argument_list|(
name|sd
operator|->
name|driveno
argument_list|,
comment|/* return the space */
name|sd
operator|->
name|driveoffset
argument_list|,
name|sd
operator|->
name|sectors
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|plexno
operator|>=
literal|0
condition|)
name|PLEX
index|[
name|sd
operator|->
name|plexno
index|]
operator|.
name|subdisks
operator|--
expr_stmt|;
comment|/* one less subdisk */
name|bzero
argument_list|(
name|sd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* and clear it out */
name|sd
operator|->
name|state
operator|=
name|sd_unallocated
expr_stmt|;
name|vinum_conf
operator|.
name|subdisks_used
operator|--
expr_stmt|;
comment|/* one less sd */
block|}
end_function

begin_comment
comment|/* Find an empty plex in the plex table */
end_comment

begin_function
name|int
name|get_empty_plex
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|plexno
decl_stmt|;
name|struct
name|plex
modifier|*
name|plex
decl_stmt|;
comment|/* if we allocate one */
comment|/* first see if we have one which has been deallocated */
for|for
control|(
name|plexno
operator|=
literal|0
init|;
name|plexno
operator|<
name|vinum_conf
operator|.
name|plexes_allocated
condition|;
name|plexno
operator|++
control|)
block|{
if|if
condition|(
name|PLEX
index|[
name|plexno
index|]
operator|.
name|state
operator|==
name|plex_unallocated
condition|)
comment|/* bingo */
break|break;
comment|/* and get out of here */
block|}
if|if
condition|(
name|plexno
operator|>=
name|vinum_conf
operator|.
name|plexes_allocated
condition|)
name|EXPAND
argument_list|(
name|PLEX
argument_list|,
expr|struct
name|plex
argument_list|,
name|vinum_conf
operator|.
name|plexes_allocated
argument_list|,
name|INITIAL_PLEXES
argument_list|)
expr_stmt|;
comment|/* Found a plex.  Give it an sd structure */
name|plex
operator|=
operator|&
name|PLEX
index|[
name|plexno
index|]
expr_stmt|;
comment|/* this one is ours */
name|bzero
argument_list|(
name|plex
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|plex
argument_list|)
argument_list|)
expr_stmt|;
comment|/* polish it up */
name|plex
operator|->
name|sdnos
operator|=
operator|(
name|int
operator|*
operator|)
name|Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|INITIAL_SUBDISKS_IN_PLEX
argument_list|)
expr_stmt|;
comment|/* allocate sd table */
name|CHECKALLOC
argument_list|(
name|plex
operator|->
name|sdnos
argument_list|,
literal|"vinum: Can't allocate plex subdisk table"
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|plex
operator|->
name|sdnos
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|INITIAL_SUBDISKS_IN_PLEX
operator|)
argument_list|)
expr_stmt|;
comment|/* do we need this? */
name|plex
operator|->
name|flags
operator||=
name|VF_NEWBORN
expr_stmt|;
comment|/* newly born plex */
name|plex
operator|->
name|subdisks
operator|=
literal|0
expr_stmt|;
comment|/* no subdisks in use */
name|plex
operator|->
name|subdisks_allocated
operator|=
name|INITIAL_SUBDISKS_IN_PLEX
expr_stmt|;
comment|/* and we have space for this many */
name|plex
operator|->
name|organization
operator|=
name|plex_disorg
expr_stmt|;
comment|/* and it's not organized */
name|plex
operator|->
name|volno
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* no volume yet */
return|return
name|plexno
return|;
comment|/* return the index */
block|}
end_function

begin_comment
comment|/*  * Find the named plex in vinum_conf.plex  *  * If create != 0, create an entry if it doesn't exist  * return index in vinum_conf.plex  */
end_comment

begin_function
name|int
name|find_plex
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|create
parameter_list|)
block|{
name|int
name|plexno
decl_stmt|;
name|struct
name|plex
modifier|*
name|plex
decl_stmt|;
for|for
control|(
name|plexno
operator|=
literal|0
init|;
name|plexno
operator|<
name|vinum_conf
operator|.
name|plexes_allocated
condition|;
name|plexno
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|PLEX
index|[
name|plexno
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
comment|/* found it */
return|return
name|plexno
return|;
block|}
comment|/* the plex isn't in the list.  Add it if he wants */
if|if
condition|(
name|create
operator|==
literal|0
condition|)
comment|/* don't want to create */
return|return
operator|-
literal|1
return|;
comment|/* give up */
comment|/* Allocate one and insert the name */
name|plexno
operator|=
name|get_empty_plex
argument_list|()
expr_stmt|;
name|plex
operator|=
operator|&
name|PLEX
index|[
name|plexno
index|]
expr_stmt|;
comment|/* point to it */
name|bcopy
argument_list|(
name|name
argument_list|,
name|plex
operator|->
name|name
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|plex
operator|->
name|name
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* put in its name */
return|return
name|plexno
return|;
comment|/* return the pointer */
block|}
end_function

begin_comment
comment|/*  * Free an allocated plex entry  * and its associated memory areas  */
end_comment

begin_function
name|void
name|free_plex
parameter_list|(
name|int
name|plexno
parameter_list|)
block|{
name|struct
name|plex
modifier|*
name|plex
decl_stmt|;
name|plex
operator|=
operator|&
name|PLEX
index|[
name|plexno
index|]
expr_stmt|;
if|if
condition|(
name|plex
operator|->
name|sdnos
condition|)
name|Free
argument_list|(
name|plex
operator|->
name|sdnos
argument_list|)
expr_stmt|;
if|if
condition|(
name|plex
operator|->
name|lock
condition|)
name|Free
argument_list|(
name|plex
operator|->
name|lock
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|plex
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|plex
argument_list|)
argument_list|)
expr_stmt|;
comment|/* and clear it out */
name|plex
operator|->
name|state
operator|=
name|plex_unallocated
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find an empty volume in the volume table */
end_comment

begin_function
name|int
name|get_empty_volume
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|volno
decl_stmt|;
name|struct
name|volume
modifier|*
name|vol
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* first see if we have one which has been deallocated */
for|for
control|(
name|volno
operator|=
literal|0
init|;
name|volno
operator|<
name|vinum_conf
operator|.
name|volumes_allocated
condition|;
name|volno
operator|++
control|)
block|{
if|if
condition|(
name|VOL
index|[
name|volno
index|]
operator|.
name|state
operator|==
name|volume_unallocated
condition|)
comment|/* bingo */
break|break;
block|}
if|if
condition|(
name|volno
operator|>=
name|vinum_conf
operator|.
name|volumes_allocated
condition|)
name|EXPAND
argument_list|(
name|VOL
argument_list|,
expr|struct
name|volume
argument_list|,
name|vinum_conf
operator|.
name|volumes_allocated
argument_list|,
name|INITIAL_VOLUMES
argument_list|)
expr_stmt|;
comment|/* Now initialize fields */
name|vol
operator|=
operator|&
name|VOL
index|[
name|volno
index|]
expr_stmt|;
name|bzero
argument_list|(
name|vol
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|volume
argument_list|)
argument_list|)
expr_stmt|;
name|vol
operator|->
name|flags
operator||=
name|VF_NEWBORN
operator||
name|VF_CREATED
expr_stmt|;
comment|/* newly born volume */
name|vol
operator|->
name|preferred_plex
operator|=
name|ROUND_ROBIN_READPOL
expr_stmt|;
comment|/* round robin */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXPLEX
condition|;
name|i
operator|++
control|)
comment|/* mark the plexes missing */
name|vol
operator|->
name|plex
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|volno
return|;
comment|/* return the index */
block|}
end_function

begin_comment
comment|/*  * Find the named volume in vinum_conf.volume.  *  * If create != 0, create an entry if it doesn't exist  * return the index in vinum_conf  */
end_comment

begin_function
name|int
name|find_volume
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|create
parameter_list|)
block|{
name|int
name|volno
decl_stmt|;
name|struct
name|volume
modifier|*
name|vol
decl_stmt|;
for|for
control|(
name|volno
operator|=
literal|0
init|;
name|volno
operator|<
name|vinum_conf
operator|.
name|volumes_allocated
condition|;
name|volno
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|VOL
index|[
name|volno
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
comment|/* found it */
return|return
name|volno
return|;
block|}
comment|/* the volume isn't in the list.  Add it if he wants */
if|if
condition|(
name|create
operator|==
literal|0
condition|)
comment|/* don't want to create */
return|return
operator|-
literal|1
return|;
comment|/* give up */
comment|/* Allocate one and insert the name */
name|volno
operator|=
name|get_empty_volume
argument_list|()
expr_stmt|;
name|vol
operator|=
operator|&
name|VOL
index|[
name|volno
index|]
expr_stmt|;
name|bcopy
argument_list|(
name|name
argument_list|,
name|vol
operator|->
name|name
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|vol
operator|->
name|name
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* put in its name */
name|vol
operator|->
name|blocksize
operator|=
name|DEV_BSIZE
expr_stmt|;
comment|/* block size of this volume */
return|return
name|volno
return|;
comment|/* return the pointer */
block|}
end_function

begin_comment
comment|/*  * Free an allocated volume entry  * and its associated memory areas  */
end_comment

begin_function
name|void
name|free_volume
parameter_list|(
name|int
name|volno
parameter_list|)
block|{
name|struct
name|volume
modifier|*
name|vol
decl_stmt|;
name|vol
operator|=
operator|&
name|VOL
index|[
name|volno
index|]
expr_stmt|;
name|bzero
argument_list|(
name|vol
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|volume
argument_list|)
argument_list|)
expr_stmt|;
comment|/* and clear it out */
name|vol
operator|->
name|state
operator|=
name|volume_unallocated
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle a drive definition.  We store the information in the global variable  * drive, so we don't need to allocate.  *  * If we find an error, print a message and return  */
end_comment

begin_function
name|void
name|config_drive
parameter_list|(
name|int
name|update
parameter_list|)
block|{
name|enum
name|drive_label_info
name|partition_status
decl_stmt|;
comment|/* info about the partition */
name|int
name|parameter
decl_stmt|;
name|int
name|driveno
decl_stmt|;
comment|/* index of drive in vinum_conf */
name|struct
name|drive
modifier|*
name|drive
decl_stmt|;
comment|/* and pointer to it */
name|int
name|otherdriveno
decl_stmt|;
comment|/* index of possible second drive */
name|int
name|sdno
decl_stmt|;
if|if
condition|(
name|tokens
operator|<
literal|2
condition|)
comment|/* not enough tokens */
name|throw_rude_remark
argument_list|(
name|EINVAL
argument_list|,
literal|"Drive has no name\n"
argument_list|)
expr_stmt|;
name|driveno
operator|=
name|find_drive
argument_list|(
name|token
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* allocate a drive to initialize */
name|drive
operator|=
operator|&
name|DRIVE
index|[
name|driveno
index|]
expr_stmt|;
comment|/* and get a pointer */
if|if
condition|(
name|update
operator|&&
operator|(
operator|(
name|drive
operator|->
name|flags
operator|&
name|VF_NEWBORN
operator|)
operator|==
literal|0
operator|)
condition|)
comment|/* this drive exists already */
return|return;
comment|/* don't do anything */
name|drive
operator|->
name|flags
operator|&=
operator|~
name|VF_NEWBORN
expr_stmt|;
comment|/* no longer newly born */
if|if
condition|(
name|drive
operator|->
name|state
operator|!=
name|drive_referenced
condition|)
block|{
comment|/* we already know this drive */
comment|/* 	 * XXX Check which definition is more up-to-date.  Give 	 * preference for the definition on its own drive. 	 */
return|return;
comment|/* XXX */
block|}
for|for
control|(
name|parameter
operator|=
literal|2
init|;
name|parameter
operator|<
name|tokens
condition|;
name|parameter
operator|++
control|)
block|{
comment|/* look at the other tokens */
switch|switch
condition|(
name|get_keyword
argument_list|(
name|token
index|[
name|parameter
index|]
argument_list|,
operator|&
name|keyword_set
argument_list|)
condition|)
block|{
case|case
name|kw_device
case|:
name|parameter
operator|++
expr_stmt|;
name|otherdriveno
operator|=
name|find_drive_by_dev
argument_list|(
name|token
index|[
name|parameter
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* see if it exists already */
if|if
condition|(
name|otherdriveno
operator|>=
literal|0
condition|)
block|{
comment|/* yup, */
name|drive
operator|->
name|state
operator|=
name|drive_unallocated
expr_stmt|;
comment|/* deallocate the drive */
name|throw_rude_remark
argument_list|(
name|EEXIST
argument_list|,
comment|/* and complain */
literal|"Drive %s would have same device as drive %s"
argument_list|,
name|token
index|[
literal|1
index|]
argument_list|,
name|DRIVE
index|[
name|otherdriveno
index|]
operator|.
name|label
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|drive
operator|->
name|devicename
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
comment|/* we know this drive... */
if|if
condition|(
name|strcmp
argument_list|(
name|drive
operator|->
name|devicename
argument_list|,
name|token
index|[
name|parameter
index|]
argument_list|)
condition|)
comment|/* different name */
name|close_drive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
comment|/* close it if it's open */
else|else
comment|/* no change */
break|break;
block|}
comment|/* open the device and get the configuration */
name|bcopy
argument_list|(
name|token
index|[
name|parameter
index|]
argument_list|,
comment|/* insert device information */
name|drive
operator|->
name|devicename
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|drive
operator|->
name|devicename
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|token
index|[
name|parameter
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|partition_status
operator|=
name|read_drive_label
argument_list|(
name|drive
argument_list|,
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|partition_status
condition|)
block|{
case|case
name|DL_CANT_OPEN
case|:
comment|/* not our kind */
name|close_drive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
if|if
condition|(
name|drive
operator|->
name|lasterror
operator|==
name|EFTYPE
condition|)
comment|/* wrong kind of partition */
name|throw_rude_remark
argument_list|(
name|drive
operator|->
name|lasterror
argument_list|,
literal|"Drive %s has invalid partition type"
argument_list|,
name|drive
operator|->
name|label
operator|.
name|name
argument_list|)
expr_stmt|;
else|else
comment|/* I/O error of some kind */
name|throw_rude_remark
argument_list|(
name|drive
operator|->
name|lasterror
argument_list|,
literal|"Can't initialize drive %s"
argument_list|,
name|drive
operator|->
name|label
operator|.
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|DL_WRONG_DRIVE
case|:
comment|/* valid drive, not the name we expected */
if|if
condition|(
name|vinum_conf
operator|.
name|flags
operator|&
name|VF_FORCECONFIG
condition|)
block|{
comment|/* but we'll accept that */
name|bcopy
argument_list|(
name|token
index|[
literal|1
index|]
argument_list|,
name|drive
operator|->
name|label
operator|.
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|drive
operator|->
name|label
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|close_drive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
comment|/* 		 * There's a potential race condition here: 		 * the rude remark refers to a field in an 		 * unallocated drive, which potentially could 		 * be reused.  This works because we're the only 		 * thread accessing the config at the moment. 		 */
name|drive
operator|->
name|state
operator|=
name|drive_unallocated
expr_stmt|;
comment|/* throw it away completely */
name|throw_rude_remark
argument_list|(
name|drive
operator|->
name|lasterror
argument_list|,
literal|"Incorrect drive name %s specified for drive %s"
argument_list|,
name|token
index|[
literal|1
index|]
argument_list|,
name|drive
operator|->
name|label
operator|.
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|DL_DELETED_LABEL
case|:
comment|/* it was a drive, but we deleted it */
case|case
name|DL_NOT_OURS
case|:
comment|/* nothing to do with the rest */
case|case
name|DL_OURS
case|:
break|break;
block|}
comment|/* 	     * read_drive_label overwrites the device name. 	     * If we get here, we can have the drive, 	     * so put it back again 	     */
name|bcopy
argument_list|(
name|token
index|[
name|parameter
index|]
argument_list|,
name|drive
operator|->
name|devicename
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|drive
operator|->
name|devicename
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|token
index|[
name|parameter
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|kw_state
case|:
name|parameter
operator|++
expr_stmt|;
comment|/* skip the keyword */
if|if
condition|(
name|vinum_conf
operator|.
name|flags
operator|&
name|VF_READING_CONFIG
condition|)
name|drive
operator|->
name|state
operator|=
name|DriveState
argument_list|(
name|token
index|[
name|parameter
index|]
argument_list|)
expr_stmt|;
comment|/* set the state */
break|break;
case|case
name|kw_hotspare
case|:
comment|/* this drive is a hot spare */
name|drive
operator|->
name|flags
operator||=
name|VF_HOTSPARE
expr_stmt|;
break|break;
default|default:
name|close_drive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
name|throw_rude_remark
argument_list|(
name|EINVAL
argument_list|,
literal|"Drive %s, invalid keyword: %s"
argument_list|,
name|token
index|[
literal|1
index|]
argument_list|,
name|token
index|[
name|parameter
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|drive
operator|->
name|devicename
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
block|{
name|drive
operator|->
name|state
operator|=
name|drive_unallocated
expr_stmt|;
comment|/* deallocate the drive */
name|throw_rude_remark
argument_list|(
name|EINVAL
argument_list|,
literal|"No device name for %s"
argument_list|,
name|drive
operator|->
name|label
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
name|vinum_conf
operator|.
name|drives_used
operator|++
expr_stmt|;
comment|/* passed all hurdles: one more in use */
comment|/*      * If we're replacing a drive, it could be that      * we already have subdisks referencing this      * drive.  Note where they should be and change      * their state to obsolete.      */
for|for
control|(
name|sdno
operator|=
literal|0
init|;
name|sdno
operator|<
name|vinum_conf
operator|.
name|subdisks_allocated
condition|;
name|sdno
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|SD
index|[
name|sdno
index|]
operator|.
name|state
operator|>
name|sd_referenced
operator|)
operator|&&
operator|(
name|SD
index|[
name|sdno
index|]
operator|.
name|driveno
operator|==
name|driveno
operator|)
condition|)
block|{
name|give_sd_to_drive
argument_list|(
name|sdno
argument_list|)
expr_stmt|;
if|if
condition|(
name|SD
index|[
name|sdno
index|]
operator|.
name|state
operator|>
name|sd_stale
condition|)
name|SD
index|[
name|sdno
index|]
operator|.
name|state
operator|=
name|sd_stale
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Handle a subdisk definition.  We store the information in the global variable  * sd, so we don't need to allocate.  *  * If we find an error, print a message and return  */
end_comment

begin_function
name|void
name|config_subdisk
parameter_list|(
name|int
name|update
parameter_list|)
block|{
name|int
name|parameter
decl_stmt|;
name|int
name|sdno
decl_stmt|;
comment|/* index of sd in vinum_conf */
name|struct
name|sd
modifier|*
name|sd
decl_stmt|;
comment|/* and pointer to it */
name|u_int64_t
name|size
decl_stmt|;
name|int
name|detached
init|=
literal|0
decl_stmt|;
comment|/* set to 1 if this is a detached subdisk */
name|int
name|sdindex
init|=
operator|-
literal|1
decl_stmt|;
comment|/* index in plexes subdisk table */
name|enum
name|sdstate
name|state
init|=
name|sd_unallocated
decl_stmt|;
comment|/* state to set, if specified */
name|int
name|autosize
init|=
literal|0
decl_stmt|;
comment|/* set if we autosize in give_sd_to_drive */
name|int
name|namedsdno
decl_stmt|;
comment|/* index of another with this name */
name|char
name|partition
init|=
literal|0
decl_stmt|;
comment|/* partition of external subdisk */
name|sdno
operator|=
name|get_empty_sd
argument_list|()
expr_stmt|;
comment|/* allocate an SD to initialize */
name|sd
operator|=
operator|&
name|SD
index|[
name|sdno
index|]
expr_stmt|;
comment|/* and get a pointer */
for|for
control|(
name|parameter
operator|=
literal|1
init|;
name|parameter
operator|<
name|tokens
condition|;
name|parameter
operator|++
control|)
block|{
comment|/* look at the other tokens */
switch|switch
condition|(
name|get_keyword
argument_list|(
name|token
index|[
name|parameter
index|]
argument_list|,
operator|&
name|keyword_set
argument_list|)
condition|)
block|{
comment|/* 	     * If we have a 'name' parameter, it must 	     * come first, because we're too lazy to tidy 	     * up dangling refs if it comes later. 	     */
case|case
name|kw_name
case|:
name|namedsdno
operator|=
name|find_subdisk
argument_list|(
name|token
index|[
operator|++
name|parameter
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* find an existing sd with this name */
if|if
condition|(
name|namedsdno
operator|>=
literal|0
condition|)
block|{
comment|/* got one */
if|if
condition|(
name|SD
index|[
name|namedsdno
index|]
operator|.
name|state
operator|==
name|sd_referenced
condition|)
block|{
comment|/* we've been told about this one */
if|if
condition|(
name|parameter
operator|>
literal|2
condition|)
name|throw_rude_remark
argument_list|(
name|EINVAL
argument_list|,
literal|"sd %s: name parameter must come first\n"
argument_list|,
comment|/* no go */
name|token
index|[
name|parameter
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|i
decl_stmt|;
name|struct
name|plex
modifier|*
name|plex
decl_stmt|;
comment|/* for tidying up dangling references */
operator|*
name|sd
operator|=
name|SD
index|[
name|namedsdno
index|]
expr_stmt|;
comment|/* copy from the referenced one */
name|SD
index|[
name|namedsdno
index|]
operator|.
name|state
operator|=
name|sd_unallocated
expr_stmt|;
comment|/* and deallocate the referenced one */
name|plex
operator|=
operator|&
name|PLEX
index|[
name|sd
operator|->
name|plexno
index|]
expr_stmt|;
comment|/* now take a look at our plex */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|plex
operator|->
name|subdisks
condition|;
name|i
operator|++
control|)
block|{
comment|/* look for the pointer */
if|if
condition|(
name|plex
operator|->
name|sdnos
index|[
name|i
index|]
operator|==
name|namedsdno
condition|)
comment|/* pointing to the old subdisk */
name|plex
operator|->
name|sdnos
index|[
name|i
index|]
operator|=
name|sdno
expr_stmt|;
comment|/* bend it to point here */
block|}
block|}
block|}
if|if
condition|(
name|update
condition|)
comment|/* are we updating? */
return|return;
comment|/* that's OK, nothing more to do */
else|else
name|throw_rude_remark
argument_list|(
name|EINVAL
argument_list|,
literal|"Duplicate subdisk %s"
argument_list|,
name|token
index|[
name|parameter
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|bcopy
argument_list|(
name|token
index|[
name|parameter
index|]
argument_list|,
name|sd
operator|->
name|name
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|sd
operator|->
name|name
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|token
index|[
name|parameter
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|kw_detached
case|:
name|detached
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|kw_plexoffset
case|:
name|size
operator|=
name|sizespec
argument_list|(
name|token
index|[
operator|++
name|parameter
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|size
operator|==
operator|-
literal|1
operator|)
comment|/* unallocated */
operator|&&
operator|(
name|vinum_conf
operator|.
name|flags
operator|&
name|VF_READING_CONFIG
operator|)
condition|)
comment|/* reading from disk */
break|break;
comment|/* invalid sd; just ignore it */
if|if
condition|(
operator|(
name|size
operator|%
name|DEV_BSIZE
operator|)
operator|!=
literal|0
condition|)
name|throw_rude_remark
argument_list|(
name|EINVAL
argument_list|,
literal|"sd %s, bad plex offset alignment: %lld"
argument_list|,
name|sd
operator|->
name|name
argument_list|,
operator|(
name|long
name|long
operator|)
name|size
argument_list|)
expr_stmt|;
else|else
name|sd
operator|->
name|plexoffset
operator|=
name|size
operator|/
name|DEV_BSIZE
expr_stmt|;
break|break;
case|case
name|kw_driveoffset
case|:
name|size
operator|=
name|sizespec
argument_list|(
name|token
index|[
operator|++
name|parameter
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|size
operator|==
operator|-
literal|1
operator|)
comment|/* unallocated */
operator|&&
operator|(
name|vinum_conf
operator|.
name|flags
operator|&
name|VF_READING_CONFIG
operator|)
condition|)
comment|/* reading from disk */
break|break;
comment|/* invalid sd; just ignore it */
if|if
condition|(
operator|(
name|size
operator|%
name|DEV_BSIZE
operator|)
operator|!=
literal|0
condition|)
name|throw_rude_remark
argument_list|(
name|EINVAL
argument_list|,
literal|"sd %s, bad drive offset alignment: %lld"
argument_list|,
name|sd
operator|->
name|name
argument_list|,
operator|(
name|long
name|long
operator|)
name|size
argument_list|)
expr_stmt|;
else|else
name|sd
operator|->
name|driveoffset
operator|=
name|size
operator|/
name|DEV_BSIZE
expr_stmt|;
break|break;
case|case
name|kw_len
case|:
if|if
condition|(
name|get_keyword
argument_list|(
name|token
index|[
operator|++
name|parameter
index|]
argument_list|,
operator|&
name|keyword_set
argument_list|)
operator|==
name|kw_max
condition|)
comment|/* select maximum size from drive */
name|size
operator|=
literal|0
expr_stmt|;
comment|/* this is how we say it :-) */
else|else
name|size
operator|=
name|sizespec
argument_list|(
name|token
index|[
name|parameter
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|size
operator|%
name|DEV_BSIZE
operator|)
operator|!=
literal|0
condition|)
name|throw_rude_remark
argument_list|(
name|EINVAL
argument_list|,
literal|"sd %s, length %d not multiple of sector size"
argument_list|,
name|sd
operator|->
name|name
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|sd
operator|->
name|sectors
operator|=
name|size
operator|/
name|DEV_BSIZE
expr_stmt|;
comment|/* 	     * We have a problem with autosizing: we need to 	     * give the drive to the plex before we give it 	     * to the drive, in order to be clean if we give 	     * up in the middle, but at this time the size hasn't 	     * been set.  Note that we have to fix up after 	     * giving the subdisk to the drive. 	     */
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|autosize
operator|=
literal|1
expr_stmt|;
comment|/* note that we're autosizing */
break|break;
case|case
name|kw_drive
case|:
name|sd
operator|->
name|driveno
operator|=
name|find_drive
argument_list|(
name|token
index|[
operator|++
name|parameter
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* insert drive information */
break|break;
case|case
name|kw_plex
case|:
name|sd
operator|->
name|plexno
operator|=
name|find_plex
argument_list|(
name|token
index|[
operator|++
name|parameter
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* insert plex information */
break|break;
comment|/* 	     * Set the state.  We can't do this directly, 	     * because give_sd_to_plex may change it 	     */
case|case
name|kw_state
case|:
name|parameter
operator|++
expr_stmt|;
comment|/* skip the keyword */
if|if
condition|(
name|vinum_conf
operator|.
name|flags
operator|&
name|VF_READING_CONFIG
condition|)
name|state
operator|=
name|SdState
argument_list|(
name|token
index|[
name|parameter
index|]
argument_list|)
expr_stmt|;
comment|/* set the state */
break|break;
case|case
name|kw_partition
case|:
name|parameter
operator|++
expr_stmt|;
comment|/* skip the keyword */
if|if
condition|(
operator|(
name|strlen
argument_list|(
name|token
index|[
name|parameter
index|]
argument_list|)
operator|!=
literal|1
operator|)
operator|||
operator|(
name|token
index|[
name|parameter
index|]
index|[
literal|0
index|]
operator|<
literal|'a'
operator|)
operator|||
operator|(
name|token
index|[
name|parameter
index|]
index|[
literal|0
index|]
operator|>
literal|'h'
operator|)
condition|)
name|throw_rude_remark
argument_list|(
name|EINVAL
argument_list|,
literal|"%s: invalid partition %c"
argument_list|,
name|sd
operator|->
name|name
argument_list|,
name|token
index|[
name|parameter
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
name|partition
operator|=
name|token
index|[
name|parameter
index|]
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|kw_retryerrors
case|:
name|sd
operator|->
name|flags
operator||=
name|VF_RETRYERRORS
expr_stmt|;
break|break;
default|default:
name|throw_rude_remark
argument_list|(
name|EINVAL
argument_list|,
literal|"%s: invalid keyword: %s"
argument_list|,
name|sd
operator|->
name|name
argument_list|,
name|token
index|[
name|parameter
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Check we have a drive name */
if|if
condition|(
name|sd
operator|->
name|driveno
operator|<
literal|0
condition|)
block|{
comment|/* didn't specify a drive */
name|sd
operator|->
name|driveno
operator|=
name|current_drive
expr_stmt|;
comment|/* set to the current drive */
if|if
condition|(
name|sd
operator|->
name|driveno
operator|<
literal|0
condition|)
comment|/* no current drive? */
name|throw_rude_remark
argument_list|(
name|EINVAL
argument_list|,
literal|"Subdisk %s is not associated with a drive"
argument_list|,
name|sd
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
comment|/*      * This is tacky.  If something goes wrong      * with the checks, we may end up losing drive      * space.  FIXME.      */
if|if
condition|(
name|autosize
operator|!=
literal|0
condition|)
comment|/* need to find a size, */
name|give_sd_to_drive
argument_list|(
name|sdno
argument_list|)
expr_stmt|;
comment|/* do it before the plex */
comment|/*  Check for a plex name */
if|if
condition|(
operator|(
name|sd
operator|->
name|plexno
operator|<
literal|0
operator|)
comment|/* didn't specify a plex */
operator|&&
operator|(
operator|!
name|detached
operator|)
condition|)
comment|/* and didn't say not to, */
name|sd
operator|->
name|plexno
operator|=
name|current_plex
expr_stmt|;
comment|/* set to the current plex */
if|if
condition|(
name|sd
operator|->
name|plexno
operator|>=
literal|0
condition|)
name|sdindex
operator|=
name|give_sd_to_plex
argument_list|(
name|sd
operator|->
name|plexno
argument_list|,
name|sdno
argument_list|)
expr_stmt|;
comment|/* now tell the plex that it has this sd */
name|sd
operator|->
name|sdno
operator|=
name|sdno
expr_stmt|;
comment|/* point to our entry in the table */
comment|/* Does the subdisk have a name?  If not, give it one */
if|if
condition|(
name|sd
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* no name */
name|char
name|sdsuffix
index|[
literal|8
index|]
decl_stmt|;
comment|/* form sd name suffix here */
comment|/* Do we have a plex name? */
if|if
condition|(
name|sdindex
operator|>=
literal|0
condition|)
comment|/* we have a plex */
name|strcpy
argument_list|(
name|sd
operator|->
name|name
argument_list|,
name|PLEX
index|[
name|sd
operator|->
name|plexno
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
comment|/* take it from there */
else|else
comment|/* no way */
name|throw_rude_remark
argument_list|(
name|EINVAL
argument_list|,
literal|"Unnamed sd is not associated with a plex"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|sdsuffix
argument_list|,
literal|".s%d"
argument_list|,
name|sdindex
argument_list|)
expr_stmt|;
comment|/* form the suffix */
name|strcat
argument_list|(
name|sd
operator|->
name|name
argument_list|,
name|sdsuffix
argument_list|)
expr_stmt|;
comment|/* and add it to the name */
block|}
comment|/* do we have complete info for this subdisk? */
if|if
condition|(
name|sd
operator|->
name|sectors
operator|<
literal|0
condition|)
name|throw_rude_remark
argument_list|(
name|EINVAL
argument_list|,
literal|"sd %s has no length spec"
argument_list|,
name|sd
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|sd_unallocated
condition|)
comment|/* we had a specific state to set */
name|sd
operator|->
name|state
operator|=
name|state
expr_stmt|;
comment|/* do it now */
elseif|else
if|if
condition|(
name|sd
operator|->
name|state
operator|==
name|sd_unallocated
condition|)
comment|/* no, nothing set yet, */
name|sd
operator|->
name|state
operator|=
name|sd_empty
expr_stmt|;
comment|/* must be empty */
if|if
condition|(
name|autosize
operator|==
literal|0
condition|)
comment|/* no autoconfig, do the drive now */
name|give_sd_to_drive
argument_list|(
name|sdno
argument_list|)
expr_stmt|;
name|vinum_conf
operator|.
name|subdisks_used
operator|++
expr_stmt|;
comment|/* one more in use */
block|}
end_function

begin_comment
comment|/*  * Handle a plex definition.  */
end_comment

begin_function
name|void
name|config_plex
parameter_list|(
name|int
name|update
parameter_list|)
block|{
name|int
name|parameter
decl_stmt|;
name|int
name|plexno
decl_stmt|;
comment|/* index of plex in vinum_conf */
name|struct
name|plex
modifier|*
name|plex
decl_stmt|;
comment|/* and pointer to it */
name|int
name|pindex
init|=
name|MAXPLEX
decl_stmt|;
comment|/* index in volume's plex list */
name|int
name|detached
init|=
literal|0
decl_stmt|;
comment|/* don't give it to a volume */
name|int
name|namedplexno
decl_stmt|;
name|enum
name|plexstate
name|state
init|=
name|plex_init
decl_stmt|;
comment|/* state to set at end */
name|current_plex
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* forget the previous plex */
name|plexno
operator|=
name|get_empty_plex
argument_list|()
expr_stmt|;
comment|/* allocate a plex */
name|plex
operator|=
operator|&
name|PLEX
index|[
name|plexno
index|]
expr_stmt|;
comment|/* and point to it */
name|plex
operator|->
name|plexno
operator|=
name|plexno
expr_stmt|;
comment|/* and back to the config */
for|for
control|(
name|parameter
operator|=
literal|1
init|;
name|parameter
operator|<
name|tokens
condition|;
name|parameter
operator|++
control|)
block|{
comment|/* look at the other tokens */
switch|switch
condition|(
name|get_keyword
argument_list|(
name|token
index|[
name|parameter
index|]
argument_list|,
operator|&
name|keyword_set
argument_list|)
condition|)
block|{
comment|/* 	     * If we have a 'name' parameter, it must 	     * come first, because we're too lazy to tidy 	     * up dangling refs if it comes later. 	     */
case|case
name|kw_name
case|:
name|namedplexno
operator|=
name|find_plex
argument_list|(
name|token
index|[
operator|++
name|parameter
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* find an existing plex with this name */
if|if
condition|(
name|namedplexno
operator|>=
literal|0
condition|)
block|{
comment|/* plex exists already, */
if|if
condition|(
name|PLEX
index|[
name|namedplexno
index|]
operator|.
name|state
operator|==
name|plex_referenced
condition|)
block|{
comment|/* we've been told about this one */
if|if
condition|(
name|parameter
operator|>
literal|2
condition|)
comment|/* we've done other things first, */
name|throw_rude_remark
argument_list|(
name|EINVAL
argument_list|,
literal|"plex %s: name parameter must come first\n"
argument_list|,
comment|/* no go */
name|token
index|[
name|parameter
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|i
decl_stmt|;
name|struct
name|volume
modifier|*
name|vol
decl_stmt|;
comment|/* for tidying up dangling references */
operator|*
name|plex
operator|=
name|PLEX
index|[
name|namedplexno
index|]
expr_stmt|;
comment|/* get the info */
name|PLEX
index|[
name|namedplexno
index|]
operator|.
name|state
operator|=
name|plex_unallocated
expr_stmt|;
comment|/* and deallocate the other one */
name|vol
operator|=
operator|&
name|VOL
index|[
name|plex
operator|->
name|volno
index|]
expr_stmt|;
comment|/* point to the volume */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXPLEX
condition|;
name|i
operator|++
control|)
block|{
comment|/* for each plex */
if|if
condition|(
name|vol
operator|->
name|plex
index|[
name|i
index|]
operator|==
name|namedplexno
condition|)
name|vol
operator|->
name|plex
index|[
name|i
index|]
operator|=
name|plexno
expr_stmt|;
comment|/* bend the pointer */
block|}
block|}
break|break;
comment|/* use this one */
block|}
if|if
condition|(
name|update
condition|)
comment|/* are we updating? */
return|return;
comment|/* yes: that's OK, just return */
else|else
name|throw_rude_remark
argument_list|(
name|EINVAL
argument_list|,
literal|"Duplicate plex %s"
argument_list|,
name|token
index|[
name|parameter
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|bcopy
argument_list|(
name|token
index|[
name|parameter
index|]
argument_list|,
comment|/* put in the name */
name|plex
operator|->
name|name
argument_list|,
name|min
argument_list|(
name|MAXPLEXNAME
argument_list|,
name|strlen
argument_list|(
name|token
index|[
name|parameter
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|kw_detached
case|:
name|detached
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|kw_org
case|:
comment|/* plex organization */
switch|switch
condition|(
name|get_keyword
argument_list|(
name|token
index|[
operator|++
name|parameter
index|]
argument_list|,
operator|&
name|keyword_set
argument_list|)
condition|)
block|{
case|case
name|kw_concat
case|:
name|plex
operator|->
name|organization
operator|=
name|plex_concat
expr_stmt|;
break|break;
case|case
name|kw_striped
case|:
block|{
name|int
name|stripesize
init|=
name|sizespec
argument_list|(
name|token
index|[
operator|++
name|parameter
index|]
argument_list|)
decl_stmt|;
name|plex
operator|->
name|organization
operator|=
name|plex_striped
expr_stmt|;
if|if
condition|(
name|stripesize
operator|%
name|DEV_BSIZE
operator|!=
literal|0
condition|)
comment|/* not a multiple of block size, */
name|throw_rude_remark
argument_list|(
name|EINVAL
argument_list|,
literal|"plex %s: stripe size %d not a multiple of sector size"
argument_list|,
name|plex
operator|->
name|name
argument_list|,
name|stripesize
argument_list|)
expr_stmt|;
else|else
name|plex
operator|->
name|stripesize
operator|=
name|stripesize
operator|/
name|DEV_BSIZE
expr_stmt|;
break|break;
block|}
case|case
name|kw_raid4
case|:
block|{
name|int
name|stripesize
init|=
name|sizespec
argument_list|(
name|token
index|[
operator|++
name|parameter
index|]
argument_list|)
decl_stmt|;
name|plex
operator|->
name|organization
operator|=
name|plex_raid4
expr_stmt|;
if|if
condition|(
name|stripesize
operator|%
name|DEV_BSIZE
operator|!=
literal|0
condition|)
comment|/* not a multiple of block size, */
name|throw_rude_remark
argument_list|(
name|EINVAL
argument_list|,
literal|"plex %s: stripe size %d not a multiple of sector size"
argument_list|,
name|plex
operator|->
name|name
argument_list|,
name|stripesize
argument_list|)
expr_stmt|;
else|else
name|plex
operator|->
name|stripesize
operator|=
name|stripesize
operator|/
name|DEV_BSIZE
expr_stmt|;
break|break;
block|}
case|case
name|kw_raid5
case|:
block|{
name|int
name|stripesize
init|=
name|sizespec
argument_list|(
name|token
index|[
operator|++
name|parameter
index|]
argument_list|)
decl_stmt|;
name|plex
operator|->
name|organization
operator|=
name|plex_raid5
expr_stmt|;
if|if
condition|(
name|stripesize
operator|%
name|DEV_BSIZE
operator|!=
literal|0
condition|)
comment|/* not a multiple of block size, */
name|throw_rude_remark
argument_list|(
name|EINVAL
argument_list|,
literal|"plex %s: stripe size %d not a multiple of sector size"
argument_list|,
name|plex
operator|->
name|name
argument_list|,
name|stripesize
argument_list|)
expr_stmt|;
else|else
name|plex
operator|->
name|stripesize
operator|=
name|stripesize
operator|/
name|DEV_BSIZE
expr_stmt|;
break|break;
block|}
default|default:
name|throw_rude_remark
argument_list|(
name|EINVAL
argument_list|,
literal|"Invalid plex organization"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isstriped
argument_list|(
name|plex
argument_list|)
operator|&&
operator|(
name|plex
operator|->
name|stripesize
operator|==
literal|0
operator|)
condition|)
comment|/* didn't specify a valid stripe size */
name|throw_rude_remark
argument_list|(
name|EINVAL
argument_list|,
literal|"Need a stripe size parameter"
argument_list|)
expr_stmt|;
break|break;
case|case
name|kw_volume
case|:
name|plex
operator|->
name|volno
operator|=
name|find_volume
argument_list|(
name|token
index|[
operator|++
name|parameter
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* insert a pointer to the volume */
break|break;
case|case
name|kw_sd
case|:
comment|/* add a subdisk */
block|{
name|int
name|sdno
decl_stmt|;
name|sdno
operator|=
name|find_subdisk
argument_list|(
name|token
index|[
operator|++
name|parameter
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* find a subdisk */
name|SD
index|[
name|sdno
index|]
operator|.
name|plexoffset
operator|=
name|sizespec
argument_list|(
name|token
index|[
operator|++
name|parameter
index|]
argument_list|)
expr_stmt|;
comment|/* get the offset */
name|give_sd_to_plex
argument_list|(
name|plexno
argument_list|,
name|sdno
argument_list|)
expr_stmt|;
comment|/* and insert it there */
break|break;
block|}
case|case
name|kw_state
case|:
name|parameter
operator|++
expr_stmt|;
comment|/* skip the keyword */
if|if
condition|(
name|vinum_conf
operator|.
name|flags
operator|&
name|VF_READING_CONFIG
condition|)
name|state
operator|=
name|PlexState
argument_list|(
name|token
index|[
name|parameter
index|]
argument_list|)
expr_stmt|;
comment|/* set the state */
break|break;
default|default:
name|throw_rude_remark
argument_list|(
name|EINVAL
argument_list|,
literal|"plex %s, invalid keyword: %s"
argument_list|,
name|plex
operator|->
name|name
argument_list|,
name|token
index|[
name|parameter
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|plex
operator|->
name|organization
operator|==
name|plex_disorg
condition|)
name|throw_rude_remark
argument_list|(
name|EINVAL
argument_list|,
literal|"No plex organization specified"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|plex
operator|->
name|volno
operator|<
literal|0
operator|)
comment|/* we don't have a volume */
operator|&&
operator|(
operator|!
name|detached
operator|)
condition|)
comment|/* and we wouldn't object */
name|plex
operator|->
name|volno
operator|=
name|current_volume
expr_stmt|;
if|if
condition|(
name|plex
operator|->
name|volno
operator|>=
literal|0
condition|)
name|pindex
operator|=
name|give_plex_to_volume
argument_list|(
name|plex
operator|->
name|volno
argument_list|,
name|plexno
argument_list|)
expr_stmt|;
comment|/* Now tell the volume that it has this plex */
comment|/* Does the plex have a name?  If not, give it one */
if|if
condition|(
name|plex
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* no name */
name|char
name|plexsuffix
index|[
literal|8
index|]
decl_stmt|;
comment|/* form plex name suffix here */
comment|/* Do we have a volume name? */
if|if
condition|(
name|plex
operator|->
name|volno
operator|>=
literal|0
condition|)
comment|/* we have a volume */
name|strcpy
argument_list|(
name|plex
operator|->
name|name
argument_list|,
comment|/* take it from there */
name|VOL
index|[
name|plex
operator|->
name|volno
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
else|else
comment|/* no way */
name|throw_rude_remark
argument_list|(
name|EINVAL
argument_list|,
literal|"Unnamed plex is not associated with a volume"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|plexsuffix
argument_list|,
literal|".p%d"
argument_list|,
name|pindex
argument_list|)
expr_stmt|;
comment|/* form the suffix */
name|strcat
argument_list|(
name|plex
operator|->
name|name
argument_list|,
name|plexsuffix
argument_list|)
expr_stmt|;
comment|/* and add it to the name */
block|}
if|if
condition|(
name|isstriped
argument_list|(
name|plex
argument_list|)
condition|)
block|{
name|plex
operator|->
name|lock
operator|=
operator|(
expr|struct
name|rangelock
operator|*
operator|)
name|Malloc
argument_list|(
name|PLEX_LOCKS
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|rangelock
argument_list|)
argument_list|)
expr_stmt|;
name|CHECKALLOC
argument_list|(
name|plex
operator|->
name|lock
argument_list|,
literal|"vinum: Can't allocate lock table\n"
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|plex
operator|->
name|lock
argument_list|,
name|PLEX_LOCKS
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|rangelock
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Note the last plex we configured */
name|current_plex
operator|=
name|plexno
expr_stmt|;
name|plex
operator|->
name|state
operator|=
name|state
expr_stmt|;
comment|/* set whatever state we chose */
name|vinum_conf
operator|.
name|plexes_used
operator|++
expr_stmt|;
comment|/* one more in use */
block|}
end_function

begin_comment
comment|/*  * Handle a volume definition.  * If we find an error, print a message, deallocate the nascent volume, and return  */
end_comment

begin_function
name|void
name|config_volume
parameter_list|(
name|int
name|update
parameter_list|)
block|{
name|int
name|parameter
decl_stmt|;
name|int
name|volno
decl_stmt|;
name|struct
name|volume
modifier|*
name|vol
decl_stmt|;
comment|/* collect volume info here */
name|int
name|i
decl_stmt|;
if|if
condition|(
name|tokens
operator|<
literal|2
condition|)
comment|/* not enough tokens */
name|throw_rude_remark
argument_list|(
name|EINVAL
argument_list|,
literal|"Volume has no name"
argument_list|)
expr_stmt|;
name|current_volume
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* forget the previous volume */
name|volno
operator|=
name|find_volume
argument_list|(
name|token
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* allocate a volume to initialize */
name|vol
operator|=
operator|&
name|VOL
index|[
name|volno
index|]
expr_stmt|;
comment|/* and get a pointer */
if|if
condition|(
name|update
operator|&&
operator|(
operator|(
name|vol
operator|->
name|flags
operator|&
name|VF_CREATED
operator|)
operator|==
literal|0
operator|)
condition|)
comment|/* this volume exists already */
return|return;
comment|/* don't do anything */
name|vol
operator|->
name|flags
operator|&=
operator|~
name|VF_CREATED
expr_stmt|;
comment|/* it exists now */
for|for
control|(
name|parameter
operator|=
literal|2
init|;
name|parameter
operator|<
name|tokens
condition|;
name|parameter
operator|++
control|)
block|{
comment|/* look at all tokens */
switch|switch
condition|(
name|get_keyword
argument_list|(
name|token
index|[
name|parameter
index|]
argument_list|,
operator|&
name|keyword_set
argument_list|)
condition|)
block|{
case|case
name|kw_plex
case|:
block|{
name|int
name|plexno
decl_stmt|;
comment|/* index of this plex */
name|int
name|myplexno
decl_stmt|;
comment|/* and index if it's already ours */
name|plexno
operator|=
name|find_plex
argument_list|(
name|token
index|[
operator|++
name|parameter
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* find a plex */
if|if
condition|(
name|plexno
operator|<
literal|0
condition|)
comment|/* couldn't */
break|break;
comment|/* we've already had an error message */
name|myplexno
operator|=
name|my_plex
argument_list|(
name|volno
argument_list|,
name|plexno
argument_list|)
expr_stmt|;
comment|/* does it already belong to us? */
if|if
condition|(
name|myplexno
operator|>
literal|0
condition|)
comment|/* yes, shouldn't get it again */
name|throw_rude_remark
argument_list|(
name|EINVAL
argument_list|,
literal|"Plex %s already belongs to volume %s"
argument_list|,
name|token
index|[
name|parameter
index|]
argument_list|,
name|vol
operator|->
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|++
name|vol
operator|->
name|plexes
operator|>
literal|8
condition|)
comment|/* another entry */
name|throw_rude_remark
argument_list|(
name|EINVAL
argument_list|,
literal|"Too many plexes for volume %s"
argument_list|,
name|vol
operator|->
name|name
argument_list|)
expr_stmt|;
name|vol
operator|->
name|plex
index|[
name|vol
operator|->
name|plexes
operator|-
literal|1
index|]
operator|=
name|plexno
expr_stmt|;
name|PLEX
index|[
name|plexno
index|]
operator|.
name|state
operator|=
name|plex_referenced
expr_stmt|;
comment|/* we know something about it */
name|PLEX
index|[
name|plexno
index|]
operator|.
name|volno
operator|=
name|volno
expr_stmt|;
comment|/* and this volume references it */
block|}
break|break;
case|case
name|kw_readpol
case|:
switch|switch
condition|(
name|get_keyword
argument_list|(
name|token
index|[
operator|++
name|parameter
index|]
argument_list|,
operator|&
name|keyword_set
argument_list|)
condition|)
block|{
comment|/* decide what to do */
case|case
name|kw_round
case|:
name|vol
operator|->
name|preferred_plex
operator|=
name|ROUND_ROBIN_READPOL
expr_stmt|;
comment|/* default */
break|break;
case|case
name|kw_prefer
case|:
block|{
name|int
name|myplexno
decl_stmt|;
comment|/* index of this plex */
name|myplexno
operator|=
name|find_plex
argument_list|(
name|token
index|[
operator|++
name|parameter
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* find a plex */
if|if
condition|(
name|myplexno
operator|<
literal|0
condition|)
comment|/* couldn't */
break|break;
comment|/* we've already had an error message */
name|myplexno
operator|=
name|my_plex
argument_list|(
name|volno
argument_list|,
name|myplexno
argument_list|)
expr_stmt|;
comment|/* does it already belong to us? */
if|if
condition|(
name|myplexno
operator|>
literal|0
condition|)
comment|/* yes */
name|vol
operator|->
name|preferred_plex
operator|=
name|myplexno
expr_stmt|;
comment|/* just note the index */
elseif|else
if|if
condition|(
operator|++
name|vol
operator|->
name|plexes
operator|>
literal|8
condition|)
comment|/* another entry */
name|throw_rude_remark
argument_list|(
name|EINVAL
argument_list|,
literal|"Too many plexes"
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* space for the new plex */
name|vol
operator|->
name|plex
index|[
name|vol
operator|->
name|plexes
operator|-
literal|1
index|]
operator|=
name|myplexno
expr_stmt|;
comment|/* add it to our list */
name|vol
operator|->
name|preferred_plex
operator|=
name|vol
operator|->
name|plexes
operator|-
literal|1
expr_stmt|;
comment|/* and note the index */
block|}
block|}
break|break;
default|default:
name|throw_rude_remark
argument_list|(
name|EINVAL
argument_list|,
literal|"Invalid read policy"
argument_list|)
expr_stmt|;
block|}
case|case
name|kw_setupstate
case|:
name|vol
operator|->
name|flags
operator||=
name|VF_CONFIG_SETUPSTATE
expr_stmt|;
comment|/* set the volume up later on */
break|break;
case|case
name|kw_state
case|:
name|parameter
operator|++
expr_stmt|;
comment|/* skip the keyword */
if|if
condition|(
name|vinum_conf
operator|.
name|flags
operator|&
name|VF_READING_CONFIG
condition|)
name|vol
operator|->
name|state
operator|=
name|VolState
argument_list|(
name|token
index|[
name|parameter
index|]
argument_list|)
expr_stmt|;
comment|/* set the state */
break|break;
comment|/* 	     * XXX experimental ideas.  These are not 	     * documented, and will not be until I 	     * decide they're worth keeping 	     */
case|case
name|kw_writethrough
case|:
comment|/* set writethrough mode */
name|vol
operator|->
name|flags
operator||=
name|VF_WRITETHROUGH
expr_stmt|;
break|break;
case|case
name|kw_writeback
case|:
comment|/* set writeback mode */
name|vol
operator|->
name|flags
operator|&=
operator|~
name|VF_WRITETHROUGH
expr_stmt|;
break|break;
case|case
name|kw_raw
case|:
name|vol
operator|->
name|flags
operator||=
name|VF_RAW
expr_stmt|;
comment|/* raw volume (no label) */
break|break;
default|default:
name|throw_rude_remark
argument_list|(
name|EINVAL
argument_list|,
literal|"volume %s, invalid keyword: %s"
argument_list|,
name|vol
operator|->
name|name
argument_list|,
name|token
index|[
name|parameter
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|current_volume
operator|=
name|volno
expr_stmt|;
comment|/* note last referred volume */
name|vol
operator|->
name|volno
operator|=
name|volno
expr_stmt|;
comment|/* also note in volume */
comment|/*      * Before we can actually use the volume, we need      * a volume label.  We could start to fake one here,      * but it will be a lot easier when we have some      * to copy from the drives, so defer it until we      * set up the configuration. XXX      */
if|if
condition|(
name|vol
operator|->
name|state
operator|==
name|volume_unallocated
condition|)
name|vol
operator|->
name|state
operator|=
name|volume_down
expr_stmt|;
comment|/* now ready to bring up at the end */
comment|/* Find out how big our volume is */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vol
operator|->
name|plexes
condition|;
name|i
operator|++
control|)
name|vol
operator|->
name|size
operator|=
name|max
argument_list|(
name|vol
operator|->
name|size
argument_list|,
name|PLEX
index|[
name|vol
operator|->
name|plex
index|[
name|i
index|]
index|]
operator|.
name|length
argument_list|)
expr_stmt|;
name|vinum_conf
operator|.
name|volumes_used
operator|++
expr_stmt|;
comment|/* one more in use */
block|}
end_function

begin_comment
comment|/*  * Parse a config entry.  CARE!  This destroys the original contents of the  * config entry, which we don't really need after this.  More specifically, it  * places \0 characters at the end of each token.  *  * Return 0 if all is well, otherwise EINVAL for invalid keyword,  * or ENOENT if 'read' command doesn't find any drives.  */
end_comment

begin_function
name|int
name|parse_config
parameter_list|(
name|char
modifier|*
name|cptr
parameter_list|,
name|struct
name|keywordset
modifier|*
name|keyset
parameter_list|,
name|int
name|update
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
comment|/* until proven otherwise */
name|tokens
operator|=
name|tokenize
argument_list|(
name|cptr
argument_list|,
name|token
argument_list|)
expr_stmt|;
comment|/* chop up into tokens */
if|if
condition|(
name|tokens
operator|<=
literal|0
condition|)
comment|/* screwed up or empty line */
return|return
name|tokens
return|;
comment|/* give up */
if|if
condition|(
name|token
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
comment|/* comment line */
return|return
literal|0
return|;
switch|switch
condition|(
name|get_keyword
argument_list|(
name|token
index|[
literal|0
index|]
argument_list|,
name|keyset
argument_list|)
condition|)
block|{
comment|/* decide what to do */
case|case
name|kw_read
case|:
comment|/* read config from a specified drive */
name|status
operator|=
name|vinum_scandisk
argument_list|(
operator|&
name|token
index|[
literal|1
index|]
argument_list|,
name|tokens
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* read the config from disk */
break|break;
case|case
name|kw_drive
case|:
name|config_drive
argument_list|(
name|update
argument_list|)
expr_stmt|;
break|break;
case|case
name|kw_subdisk
case|:
name|config_subdisk
argument_list|(
name|update
argument_list|)
expr_stmt|;
break|break;
case|case
name|kw_plex
case|:
name|config_plex
argument_list|(
name|update
argument_list|)
expr_stmt|;
break|break;
case|case
name|kw_volume
case|:
name|config_volume
argument_list|(
name|update
argument_list|)
expr_stmt|;
break|break;
comment|/* Anything else is invalid in this context */
default|default:
name|throw_rude_remark
argument_list|(
name|EINVAL
argument_list|,
comment|/* should we die? */
literal|"Invalid configuration information: %s"
argument_list|,
name|token
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/*  * parse a line handed in from userland via ioctl.  * This differs only by the error reporting mechanism:  * we return the error indication in the reply to the  * ioctl, so we need to set a global static pointer in  * this file.  This technique works because we have  * ensured that configuration is performed in a single-  * threaded manner  */
end_comment

begin_function
name|int
name|parse_user_config
parameter_list|(
name|char
modifier|*
name|cptr
parameter_list|,
name|struct
name|keywordset
modifier|*
name|keyset
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|ioctl_reply
operator|=
operator|(
expr|struct
name|_ioctl_reply
operator|*
operator|)
name|cptr
expr_stmt|;
name|status
operator|=
name|parse_config
argument_list|(
name|cptr
argument_list|,
name|keyset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|ENOENT
condition|)
comment|/* from scandisk, but it can't tell us */
name|strcpy
argument_list|(
name|ioctl_reply
operator|->
name|msg
argument_list|,
literal|"no drives found"
argument_list|)
expr_stmt|;
name|ioctl_reply
operator|=
name|NULL
expr_stmt|;
comment|/* don't do this again */
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* Remove an object */
end_comment

begin_function
name|void
name|remove
parameter_list|(
name|struct
name|vinum_ioctl_msg
modifier|*
name|msg
parameter_list|)
block|{
name|struct
name|vinum_ioctl_msg
name|message
init|=
operator|*
name|msg
decl_stmt|;
comment|/* make a copy to hand on */
name|ioctl_reply
operator|=
operator|(
expr|struct
name|_ioctl_reply
operator|*
operator|)
name|msg
expr_stmt|;
comment|/* reinstate the address to reply to */
name|ioctl_reply
operator|->
name|error
operator|=
literal|0
expr_stmt|;
comment|/* no error, */
name|ioctl_reply
operator|->
name|msg
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* no message */
switch|switch
condition|(
name|message
operator|.
name|type
condition|)
block|{
case|case
name|drive_object
case|:
name|remove_drive_entry
argument_list|(
name|message
operator|.
name|index
argument_list|,
name|message
operator|.
name|force
argument_list|)
expr_stmt|;
name|updateconfig
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|sd_object
case|:
name|remove_sd_entry
argument_list|(
name|message
operator|.
name|index
argument_list|,
name|message
operator|.
name|force
argument_list|,
name|message
operator|.
name|recurse
argument_list|)
expr_stmt|;
name|updateconfig
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|plex_object
case|:
name|remove_plex_entry
argument_list|(
name|message
operator|.
name|index
argument_list|,
name|message
operator|.
name|force
argument_list|,
name|message
operator|.
name|recurse
argument_list|)
expr_stmt|;
name|updateconfig
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|volume_object
case|:
name|remove_volume_entry
argument_list|(
name|message
operator|.
name|index
argument_list|,
name|message
operator|.
name|force
argument_list|,
name|message
operator|.
name|recurse
argument_list|)
expr_stmt|;
name|updateconfig
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
default|default:
name|ioctl_reply
operator|->
name|error
operator|=
name|EINVAL
expr_stmt|;
name|strcpy
argument_list|(
name|ioctl_reply
operator|->
name|msg
argument_list|,
literal|"Invalid object type"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Remove a drive.  */
end_comment

begin_function
name|void
name|remove_drive_entry
parameter_list|(
name|int
name|driveno
parameter_list|,
name|int
name|force
parameter_list|)
block|{
name|struct
name|drive
modifier|*
name|drive
init|=
operator|&
name|DRIVE
index|[
name|driveno
index|]
decl_stmt|;
name|int
name|sdno
decl_stmt|;
if|if
condition|(
operator|(
name|driveno
operator|>
name|vinum_conf
operator|.
name|drives_allocated
operator|)
comment|/* not a valid drive */
operator|||
operator|(
name|drive
operator|->
name|state
operator|==
name|drive_unallocated
operator|)
condition|)
block|{
comment|/* or nothing there */
name|ioctl_reply
operator|->
name|error
operator|=
name|EINVAL
expr_stmt|;
name|strcpy
argument_list|(
name|ioctl_reply
operator|->
name|msg
argument_list|,
literal|"No such drive"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|drive
operator|->
name|opencount
operator|>
literal|0
condition|)
block|{
comment|/* we have subdisks */
if|if
condition|(
name|force
condition|)
block|{
comment|/* do it at any cost */
for|for
control|(
name|sdno
operator|=
literal|0
init|;
name|sdno
operator|<
name|vinum_conf
operator|.
name|subdisks_allocated
condition|;
name|sdno
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|SD
index|[
name|sdno
index|]
operator|.
name|state
operator|!=
name|sd_unallocated
operator|)
comment|/* subdisk is allocated */
operator|&&
operator|(
name|SD
index|[
name|sdno
index|]
operator|.
name|driveno
operator|==
name|driveno
operator|)
condition|)
comment|/* and it belongs to this drive */
name|remove_sd_entry
argument_list|(
name|sdno
argument_list|,
name|force
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|remove_drive
argument_list|(
name|driveno
argument_list|)
expr_stmt|;
comment|/* now remove it */
name|vinum_conf
operator|.
name|drives_used
operator|--
expr_stmt|;
comment|/* one less drive */
block|}
else|else
name|ioctl_reply
operator|->
name|error
operator|=
name|EBUSY
expr_stmt|;
comment|/* can't do that */
block|}
else|else
block|{
name|remove_drive
argument_list|(
name|driveno
argument_list|)
expr_stmt|;
comment|/* just remove it */
name|vinum_conf
operator|.
name|drives_used
operator|--
expr_stmt|;
comment|/* one less drive */
block|}
block|}
end_function

begin_comment
comment|/* remove a subdisk */
end_comment

begin_function
name|void
name|remove_sd_entry
parameter_list|(
name|int
name|sdno
parameter_list|,
name|int
name|force
parameter_list|,
name|int
name|recurse
parameter_list|)
block|{
name|struct
name|sd
modifier|*
name|sd
init|=
operator|&
name|SD
index|[
name|sdno
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|sdno
operator|>
name|vinum_conf
operator|.
name|subdisks_allocated
operator|)
comment|/* not a valid sd */
operator|||
operator|(
name|sd
operator|->
name|state
operator|==
name|sd_unallocated
operator|)
condition|)
block|{
comment|/* or nothing there */
name|ioctl_reply
operator|->
name|error
operator|=
name|EINVAL
expr_stmt|;
name|strcpy
argument_list|(
name|ioctl_reply
operator|->
name|msg
argument_list|,
literal|"No such subdisk"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sd
operator|->
name|flags
operator|&
name|VF_OPEN
condition|)
block|{
comment|/* we're open */
name|ioctl_reply
operator|->
name|error
operator|=
name|EBUSY
expr_stmt|;
comment|/* no getting around that */
return|return;
block|}
elseif|else
if|if
condition|(
name|sd
operator|->
name|plexno
operator|>=
literal|0
condition|)
block|{
comment|/* we have a plex */
if|if
condition|(
name|force
condition|)
block|{
comment|/* do it at any cost */
name|struct
name|plex
modifier|*
name|plex
init|=
operator|&
name|PLEX
index|[
name|sd
operator|->
name|plexno
index|]
decl_stmt|;
comment|/* point to our plex */
name|int
name|mysdno
decl_stmt|;
for|for
control|(
name|mysdno
operator|=
literal|0
init|;
comment|/* look for ourselves */
name|mysdno
operator|<
name|plex
operator|->
name|subdisks
operator|&&
operator|&
name|SD
index|[
name|plex
operator|->
name|sdnos
index|[
name|mysdno
index|]
index|]
operator|!=
name|sd
condition|;
name|mysdno
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|mysdno
operator|==
name|plex
operator|->
name|subdisks
condition|)
comment|/* didn't find it */
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Error removing subdisk %s: not found in plex %s\n"
argument_list|,
name|SD
index|[
name|mysdno
index|]
operator|.
name|name
argument_list|,
name|plex
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* remove the subdisk from plex */
if|if
condition|(
name|mysdno
operator|<
operator|(
name|plex
operator|->
name|subdisks
operator|-
literal|1
operator|)
condition|)
comment|/* not the last subdisk */
name|bcopy
argument_list|(
operator|&
name|plex
operator|->
name|sdnos
index|[
name|mysdno
operator|+
literal|1
index|]
argument_list|,
operator|&
name|plex
operator|->
name|sdnos
index|[
name|mysdno
index|]
argument_list|,
operator|(
name|plex
operator|->
name|subdisks
operator|-
literal|1
operator|-
name|mysdno
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|plex
operator|->
name|subdisks
operator|--
expr_stmt|;
name|sd
operator|->
name|plexno
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* disown the subdisk */
block|}
comment|/* 	     * Removing a subdisk from a striped or 	     * RAID-4 or RAID-5 plex really tears the 	     * hell out of the structure, and it needs 	     * to be reinitialized. 	     */
if|if
condition|(
name|plex
operator|->
name|organization
operator|!=
name|plex_concat
condition|)
comment|/* not concatenated, */
name|set_plex_state
argument_list|(
name|plex
operator|->
name|plexno
argument_list|,
name|plex_faulty
argument_list|,
name|setstate_force
argument_list|)
expr_stmt|;
comment|/* need to reinitialize */
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"vinum: removing %s\n"
argument_list|,
name|sd
operator|->
name|name
argument_list|)
expr_stmt|;
name|free_sd
argument_list|(
name|sdno
argument_list|)
expr_stmt|;
block|}
else|else
name|ioctl_reply
operator|->
name|error
operator|=
name|EBUSY
expr_stmt|;
comment|/* can't do that */
block|}
else|else
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"vinum: removing %s\n"
argument_list|,
name|sd
operator|->
name|name
argument_list|)
expr_stmt|;
name|free_sd
argument_list|(
name|sdno
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* remove a plex */
end_comment

begin_function
name|void
name|remove_plex_entry
parameter_list|(
name|int
name|plexno
parameter_list|,
name|int
name|force
parameter_list|,
name|int
name|recurse
parameter_list|)
block|{
name|struct
name|plex
modifier|*
name|plex
init|=
operator|&
name|PLEX
index|[
name|plexno
index|]
decl_stmt|;
name|int
name|sdno
decl_stmt|;
if|if
condition|(
operator|(
name|plexno
operator|>
name|vinum_conf
operator|.
name|plexes_allocated
operator|)
comment|/* not a valid plex */
operator|||
operator|(
name|plex
operator|->
name|state
operator|==
name|plex_unallocated
operator|)
condition|)
block|{
comment|/* or nothing there */
name|ioctl_reply
operator|->
name|error
operator|=
name|EINVAL
expr_stmt|;
name|strcpy
argument_list|(
name|ioctl_reply
operator|->
name|msg
argument_list|,
literal|"No such plex"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|plex
operator|->
name|flags
operator|&
name|VF_OPEN
condition|)
block|{
comment|/* we're open */
name|ioctl_reply
operator|->
name|error
operator|=
name|EBUSY
expr_stmt|;
comment|/* no getting around that */
return|return;
block|}
if|if
condition|(
name|plex
operator|->
name|subdisks
condition|)
block|{
if|if
condition|(
name|force
condition|)
block|{
comment|/* do it anyway */
if|if
condition|(
name|recurse
condition|)
block|{
comment|/* remove all below */
name|int
name|sds
init|=
name|plex
operator|->
name|subdisks
decl_stmt|;
for|for
control|(
name|sdno
operator|=
literal|0
init|;
name|sdno
operator|<
name|sds
condition|;
name|sdno
operator|++
control|)
name|free_sd
argument_list|(
name|plex
operator|->
name|sdnos
index|[
name|sdno
index|]
argument_list|)
expr_stmt|;
comment|/* free all subdisks */
block|}
else|else
block|{
comment|/* just tear them out */
name|int
name|sds
init|=
name|plex
operator|->
name|subdisks
decl_stmt|;
for|for
control|(
name|sdno
operator|=
literal|0
init|;
name|sdno
operator|<
name|sds
condition|;
name|sdno
operator|++
control|)
name|SD
index|[
name|plex
operator|->
name|sdnos
index|[
name|sdno
index|]
index|]
operator|.
name|plexno
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* no plex any more */
block|}
block|}
else|else
block|{
comment|/* can't do it without force */
name|ioctl_reply
operator|->
name|error
operator|=
name|EBUSY
expr_stmt|;
comment|/* can't do that */
return|return;
block|}
block|}
if|if
condition|(
name|plex
operator|->
name|volno
operator|>=
literal|0
condition|)
block|{
comment|/* we are part of a volume */
if|if
condition|(
name|force
condition|)
block|{
comment|/* do it at any cost */
name|struct
name|volume
modifier|*
name|vol
init|=
operator|&
name|VOL
index|[
name|plex
operator|->
name|volno
index|]
decl_stmt|;
name|int
name|myplexno
decl_stmt|;
for|for
control|(
name|myplexno
operator|=
literal|0
init|;
name|myplexno
operator|<
name|vol
operator|->
name|plexes
condition|;
name|myplexno
operator|++
control|)
if|if
condition|(
name|vol
operator|->
name|plex
index|[
name|myplexno
index|]
operator|==
name|plexno
condition|)
comment|/* found it */
break|break;
if|if
condition|(
name|myplexno
operator|==
name|vol
operator|->
name|plexes
condition|)
comment|/* didn't find it.  Huh? */
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Error removing plex %s: not found in volume %s\n"
argument_list|,
name|plex
operator|->
name|name
argument_list|,
name|vol
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|myplexno
operator|<
operator|(
name|vol
operator|->
name|plexes
operator|-
literal|1
operator|)
condition|)
comment|/* not the last plex in the list */
name|bcopy
argument_list|(
operator|&
name|vol
operator|->
name|plex
index|[
name|myplexno
operator|+
literal|1
index|]
argument_list|,
operator|&
name|vol
operator|->
name|plex
index|[
name|myplexno
index|]
argument_list|,
name|vol
operator|->
name|plexes
operator|-
literal|1
operator|-
name|myplexno
argument_list|)
expr_stmt|;
name|vol
operator|->
name|plexes
operator|--
expr_stmt|;
block|}
else|else
block|{
name|ioctl_reply
operator|->
name|error
operator|=
name|EBUSY
expr_stmt|;
comment|/* can't do that */
return|return;
block|}
block|}
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"vinum: removing %s\n"
argument_list|,
name|plex
operator|->
name|name
argument_list|)
expr_stmt|;
name|free_plex
argument_list|(
name|plexno
argument_list|)
expr_stmt|;
name|vinum_conf
operator|.
name|plexes_used
operator|--
expr_stmt|;
comment|/* one less plex */
block|}
end_function

begin_comment
comment|/* remove a volume */
end_comment

begin_function
name|void
name|remove_volume_entry
parameter_list|(
name|int
name|volno
parameter_list|,
name|int
name|force
parameter_list|,
name|int
name|recurse
parameter_list|)
block|{
name|struct
name|volume
modifier|*
name|vol
init|=
operator|&
name|VOL
index|[
name|volno
index|]
decl_stmt|;
name|int
name|plexno
decl_stmt|;
if|if
condition|(
operator|(
name|volno
operator|>
name|vinum_conf
operator|.
name|volumes_allocated
operator|)
comment|/* not a valid volume */
operator|||
operator|(
name|vol
operator|->
name|state
operator|==
name|volume_unallocated
operator|)
condition|)
block|{
comment|/* or nothing there */
name|ioctl_reply
operator|->
name|error
operator|=
name|EINVAL
expr_stmt|;
name|strcpy
argument_list|(
name|ioctl_reply
operator|->
name|msg
argument_list|,
literal|"No such volume"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vol
operator|->
name|flags
operator|&
name|VF_OPEN
condition|)
comment|/* we're open */
name|ioctl_reply
operator|->
name|error
operator|=
name|EBUSY
expr_stmt|;
comment|/* no getting around that */
elseif|else
if|if
condition|(
name|vol
operator|->
name|plexes
condition|)
block|{
if|if
condition|(
name|recurse
operator|&&
name|force
condition|)
block|{
comment|/* remove all below */
name|int
name|plexes
init|=
name|vol
operator|->
name|plexes
decl_stmt|;
comment|/*       for (plexno = plexes - 1; plexno>= 0; plexno--) */
for|for
control|(
name|plexno
operator|=
literal|0
init|;
name|plexno
operator|<
name|plexes
condition|;
name|plexno
operator|++
control|)
name|remove_plex_entry
argument_list|(
name|vol
operator|->
name|plex
index|[
name|plexno
index|]
argument_list|,
name|force
argument_list|,
name|recurse
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"vinum: removing %s\n"
argument_list|,
name|vol
operator|->
name|name
argument_list|)
expr_stmt|;
name|free_volume
argument_list|(
name|volno
argument_list|)
expr_stmt|;
name|vinum_conf
operator|.
name|volumes_used
operator|--
expr_stmt|;
comment|/* one less volume */
block|}
else|else
name|ioctl_reply
operator|->
name|error
operator|=
name|EBUSY
expr_stmt|;
comment|/* can't do that */
block|}
else|else
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"vinum: removing %s\n"
argument_list|,
name|vol
operator|->
name|name
argument_list|)
expr_stmt|;
name|free_volume
argument_list|(
name|volno
argument_list|)
expr_stmt|;
name|vinum_conf
operator|.
name|volumes_used
operator|--
expr_stmt|;
comment|/* one less volume */
block|}
block|}
end_function

begin_comment
comment|/* Currently called only from ioctl */
end_comment

begin_function
name|void
name|update_sd_config
parameter_list|(
name|int
name|sdno
parameter_list|,
name|int
name|diskconfig
parameter_list|)
block|{
if|if
condition|(
operator|!
name|diskconfig
condition|)
name|set_sd_state
argument_list|(
name|sdno
argument_list|,
name|sd_up
argument_list|,
name|setstate_configuring
argument_list|)
expr_stmt|;
name|SD
index|[
name|sdno
index|]
operator|.
name|flags
operator|&=
operator|~
name|VF_NEWBORN
expr_stmt|;
block|}
end_function

begin_function
name|void
name|update_plex_config
parameter_list|(
name|int
name|plexno
parameter_list|,
name|int
name|diskconfig
parameter_list|)
block|{
name|u_int64_t
name|size
decl_stmt|;
name|int
name|sdno
decl_stmt|;
name|struct
name|plex
modifier|*
name|plex
init|=
operator|&
name|PLEX
index|[
name|plexno
index|]
decl_stmt|;
name|enum
name|plexstate
name|state
init|=
name|plex_up
decl_stmt|;
comment|/* state we want the plex in */
name|int
name|remainder
decl_stmt|;
comment|/* size of fractional stripe at end */
name|int
name|added_plex
decl_stmt|;
comment|/* set if we add a plex to a volume */
name|int
name|required_sds
decl_stmt|;
comment|/* number of subdisks we need */
name|struct
name|sd
modifier|*
name|sd
decl_stmt|;
name|struct
name|volume
modifier|*
name|vol
decl_stmt|;
name|int
name|data_sds
decl_stmt|;
comment|/* number of sds carrying data */
if|if
condition|(
name|plex
operator|->
name|state
operator|<
name|plex_init
condition|)
comment|/* not a real plex, */
return|return;
name|added_plex
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|plex
operator|->
name|volno
operator|>=
literal|0
condition|)
block|{
comment|/* we have a volume */
name|vol
operator|=
operator|&
name|VOL
index|[
name|plex
operator|->
name|volno
index|]
expr_stmt|;
comment|/* 	 * If we're newly born, 	 * and the volume isn't, 	 * and it has other plexes, 	 * and we didn't read this mess from disk, 	 * we were added later. 	 */
if|if
condition|(
operator|(
name|plex
operator|->
name|flags
operator|&
name|VF_NEWBORN
operator|)
operator|&&
operator|(
operator|(
name|vol
operator|->
name|flags
operator|&
name|VF_NEWBORN
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|vol
operator|->
name|plexes
operator|>
literal|0
operator|)
operator|&&
operator|(
name|diskconfig
operator|==
literal|0
operator|)
condition|)
block|{
name|added_plex
operator|=
literal|1
expr_stmt|;
name|state
operator|=
name|plex_down
expr_stmt|;
comment|/* so take ourselves down */
block|}
block|}
comment|/*      * Check that our subdisks make sense.  For      * striped, RAID-4 and RAID-5 plexes, we need at      * least two subdisks, and they must all be the      * same size.      */
if|if
condition|(
name|plex
operator|->
name|organization
operator|==
name|plex_striped
condition|)
block|{
name|data_sds
operator|=
name|plex
operator|->
name|subdisks
expr_stmt|;
name|required_sds
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isparity
argument_list|(
name|plex
argument_list|)
condition|)
block|{
comment|/* RAID 4 or 5 */
name|data_sds
operator|=
name|plex
operator|->
name|subdisks
operator|-
literal|1
expr_stmt|;
name|required_sds
operator|=
literal|3
expr_stmt|;
block|}
else|else
name|required_sds
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|required_sds
operator|>
literal|0
condition|)
block|{
comment|/* striped, RAID-4 or RAID-5 */
if|if
condition|(
name|plex
operator|->
name|subdisks
operator|<
name|required_sds
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"vinum: plex %s does not have at least %d subdisks\n"
argument_list|,
name|plex
operator|->
name|name
argument_list|,
name|required_sds
argument_list|)
expr_stmt|;
name|state
operator|=
name|plex_faulty
expr_stmt|;
block|}
comment|/* 	 * Now see if the plex size is a multiple of 	 * the stripe size.  If not, trim off the end 	 * of each subdisk and return it to the drive. 	 */
if|if
condition|(
name|plex
operator|->
name|length
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|data_sds
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|plex
operator|->
name|stripesize
operator|>
literal|0
condition|)
block|{
name|remainder
operator|=
call|(
name|int
call|)
argument_list|(
name|plex
operator|->
name|length
comment|/* are we exact? */
operator|%
operator|(
operator|(
name|u_int64_t
operator|)
name|plex
operator|->
name|stripesize
operator|*
name|data_sds
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|remainder
condition|)
block|{
comment|/* no */
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"vinum: removing %d blocks of partial stripe at the end of %s\n"
argument_list|,
name|remainder
argument_list|,
name|plex
operator|->
name|name
argument_list|)
expr_stmt|;
name|plex
operator|->
name|length
operator|-=
name|remainder
expr_stmt|;
comment|/* shorten the plex */
name|remainder
operator|/=
name|data_sds
expr_stmt|;
comment|/* spread the remainder amongst the sds */
for|for
control|(
name|sdno
operator|=
literal|0
init|;
name|sdno
operator|<
name|plex
operator|->
name|subdisks
condition|;
name|sdno
operator|++
control|)
block|{
name|sd
operator|=
operator|&
name|SD
index|[
name|plex
operator|->
name|sdnos
index|[
name|sdno
index|]
index|]
expr_stmt|;
comment|/* point to the subdisk */
name|return_drive_space
argument_list|(
name|sd
operator|->
name|driveno
argument_list|,
comment|/* return the space */
name|sd
operator|->
name|driveoffset
operator|+
name|sd
operator|->
name|sectors
operator|-
name|remainder
argument_list|,
name|remainder
argument_list|)
expr_stmt|;
name|sd
operator|->
name|sectors
operator|-=
name|remainder
expr_stmt|;
comment|/* and shorten it */
block|}
block|}
block|}
else|else
comment|/* no data sds, */
name|plex
operator|->
name|length
operator|=
literal|0
expr_stmt|;
comment|/* reset length */
block|}
block|}
block|}
name|size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sdno
operator|=
literal|0
init|;
name|sdno
operator|<
name|plex
operator|->
name|subdisks
condition|;
name|sdno
operator|++
control|)
block|{
name|sd
operator|=
operator|&
name|SD
index|[
name|plex
operator|->
name|sdnos
index|[
name|sdno
index|]
index|]
expr_stmt|;
if|if
condition|(
name|isstriped
argument_list|(
name|plex
argument_list|)
operator|&&
operator|(
name|sdno
operator|>
literal|0
operator|)
operator|&&
operator|(
name|sd
operator|->
name|sectors
operator|!=
name|SD
index|[
name|plex
operator|->
name|sdnos
index|[
name|sdno
operator|-
literal|1
index|]
index|]
operator|.
name|sectors
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"vinum: %s must have equal sized subdisks\n"
argument_list|,
name|plex
operator|->
name|name
argument_list|)
expr_stmt|;
name|state
operator|=
name|plex_down
expr_stmt|;
block|}
name|size
operator|+=
name|sd
operator|->
name|sectors
expr_stmt|;
if|if
condition|(
name|added_plex
condition|)
comment|/* we were added later */
name|sd
operator|->
name|state
operator|=
name|sd_stale
expr_stmt|;
comment|/* stale until proven otherwise */
block|}
if|if
condition|(
name|plex
operator|->
name|subdisks
condition|)
block|{
comment|/* plex has subdisks, calculate size */
comment|/* 	 * XXX We shouldn't need to calculate the size any 	 * more.  Check this some time 	 */
if|if
condition|(
name|isparity
argument_list|(
name|plex
argument_list|)
condition|)
name|size
operator|=
name|size
operator|/
name|plex
operator|->
name|subdisks
operator|*
operator|(
name|plex
operator|->
name|subdisks
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* less space for RAID-4 and RAID-5 */
if|if
condition|(
name|plex
operator|->
name|length
operator|!=
name|size
condition|)
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Correcting length of %s: was %lld, is %lld\n"
argument_list|,
name|plex
operator|->
name|name
argument_list|,
operator|(
name|long
name|long
operator|)
name|plex
operator|->
name|length
argument_list|,
operator|(
name|long
name|long
operator|)
name|size
argument_list|)
expr_stmt|;
name|plex
operator|->
name|length
operator|=
name|size
expr_stmt|;
block|}
else|else
block|{
comment|/* no subdisks, */
name|plex
operator|->
name|length
operator|=
literal|0
expr_stmt|;
comment|/* no size */
name|state
operator|=
name|plex_down
expr_stmt|;
comment|/* take it down */
block|}
name|update_plex_state
argument_list|(
name|plexno
argument_list|)
expr_stmt|;
comment|/* set the state */
name|plex
operator|->
name|flags
operator|&=
operator|~
name|VF_NEWBORN
expr_stmt|;
block|}
end_function

begin_function
name|void
name|update_volume_config
parameter_list|(
name|int
name|volno
parameter_list|,
name|int
name|diskconfig
parameter_list|)
block|{
name|struct
name|volume
modifier|*
name|vol
init|=
operator|&
name|VOL
index|[
name|volno
index|]
decl_stmt|;
name|struct
name|plex
modifier|*
name|plex
decl_stmt|;
name|int
name|plexno
decl_stmt|;
if|if
condition|(
name|vol
operator|->
name|state
operator|!=
name|volume_unallocated
condition|)
comment|/* 	 * Recalculate the size of the volume, 	 * which might change if the original 	 * plexes were not a multiple of the 	 * stripe size. 	 */
block|{
name|vol
operator|->
name|size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|plexno
operator|=
literal|0
init|;
name|plexno
operator|<
name|vol
operator|->
name|plexes
condition|;
name|plexno
operator|++
control|)
block|{
name|plex
operator|=
operator|&
name|PLEX
index|[
name|vol
operator|->
name|plex
index|[
name|plexno
index|]
index|]
expr_stmt|;
name|vol
operator|->
name|size
operator|=
name|max
argument_list|(
name|plex
operator|->
name|length
argument_list|,
name|vol
operator|->
name|size
argument_list|)
expr_stmt|;
comment|/* maximum size */
name|plex
operator|->
name|volplexno
operator|=
name|plexno
expr_stmt|;
comment|/* note it in the plex */
block|}
block|}
name|vol
operator|->
name|flags
operator|&=
operator|~
name|VF_NEWBORN
expr_stmt|;
comment|/* no longer newly born */
block|}
end_function

begin_comment
comment|/*  * Update the global configuration.  * diskconfig is != 0 if we're reading in a config  * from disk.  In this case, we don't try to  * bring the devices up, though we will bring  * them down if there's some error which got  * missed when writing to disk.  */
end_comment

begin_function
name|void
name|updateconfig
parameter_list|(
name|int
name|diskconfig
parameter_list|)
block|{
name|int
name|plexno
decl_stmt|;
name|int
name|volno
decl_stmt|;
for|for
control|(
name|plexno
operator|=
literal|0
init|;
name|plexno
operator|<
name|vinum_conf
operator|.
name|plexes_allocated
condition|;
name|plexno
operator|++
control|)
name|update_plex_config
argument_list|(
name|plexno
argument_list|,
name|diskconfig
argument_list|)
expr_stmt|;
for|for
control|(
name|volno
operator|=
literal|0
init|;
name|volno
operator|<
name|vinum_conf
operator|.
name|volumes_allocated
condition|;
name|volno
operator|++
control|)
block|{
if|if
condition|(
name|VOL
index|[
name|volno
index|]
operator|.
name|state
operator|>
name|volume_uninit
condition|)
block|{
name|VOL
index|[
name|volno
index|]
operator|.
name|flags
operator|&=
operator|~
name|VF_CONFIG_SETUPSTATE
expr_stmt|;
comment|/* no more setupstate */
name|update_volume_state
argument_list|(
name|volno
argument_list|)
expr_stmt|;
name|update_volume_config
argument_list|(
name|volno
argument_list|,
name|diskconfig
argument_list|)
expr_stmt|;
block|}
block|}
name|save_config
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start manual changes to the configuration and lock out  * others who may wish to do so.  * XXX why do we need this and lock_config too?  */
end_comment

begin_function
name|int
name|start_config
parameter_list|(
name|int
name|force
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|current_drive
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* note the last drive we mention, for 							    * some defaults */
name|current_plex
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* and the same for the last plex */
name|current_volume
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* and the last volume */
while|while
condition|(
operator|(
name|vinum_conf
operator|.
name|flags
operator|&
name|VF_CONFIGURING
operator|)
operator|!=
literal|0
condition|)
block|{
name|vinum_conf
operator|.
name|flags
operator||=
name|VF_WILL_CONFIGURE
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|tsleep
argument_list|(
operator|&
name|vinum_conf
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"vincfg"
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
block|}
comment|/*      * We need two flags here: VF_CONFIGURING      * tells other processes to hold off (this      * function), and VF_CONFIG_INCOMPLETE      * tells the state change routines not to      * propagate incrememntal state changes      */
name|vinum_conf
operator|.
name|flags
operator||=
name|VF_CONFIGURING
operator||
name|VF_CONFIG_INCOMPLETE
expr_stmt|;
if|if
condition|(
name|force
condition|)
name|vinum_conf
operator|.
name|flags
operator||=
name|VF_FORCECONFIG
expr_stmt|;
comment|/* overwrite differently named drives */
name|current_drive
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* reset the defaults */
name|current_plex
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* and the same for the last plex */
name|current_volume
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* and the last volme */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Update the config if update is 1, and unlock  * it.  We won't update the configuration if we  * are called in a recursive loop via throw_rude_remark.  */
end_comment

begin_function
name|void
name|finish_config
parameter_list|(
name|int
name|update
parameter_list|)
block|{
comment|/* we've finished our config */
name|vinum_conf
operator|.
name|flags
operator|&=
operator|~
operator|(
name|VF_CONFIG_INCOMPLETE
operator||
name|VF_READING_CONFIG
operator||
name|VF_FORCECONFIG
operator|)
expr_stmt|;
if|if
condition|(
name|update
condition|)
name|updateconfig
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* so update things */
else|else
name|updateconfig
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* do some updates only */
name|vinum_conf
operator|.
name|flags
operator|&=
operator|~
name|VF_CONFIGURING
expr_stmt|;
comment|/* and now other people can take a turn */
if|if
condition|(
operator|(
name|vinum_conf
operator|.
name|flags
operator|&
name|VF_WILL_CONFIGURE
operator|)
operator|!=
literal|0
condition|)
block|{
name|vinum_conf
operator|.
name|flags
operator|&=
operator|~
name|VF_WILL_CONFIGURE
expr_stmt|;
name|wakeup_one
argument_list|(
operator|&
name|vinum_conf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Local Variables: */
end_comment

begin_comment
comment|/* fill-column: 50 */
end_comment

begin_comment
comment|/* End: */
end_comment

end_unit

