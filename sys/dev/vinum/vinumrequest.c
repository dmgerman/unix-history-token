begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1997, 1998, 1999  *	Nan Yang Computer Services Limited.  All rights reserved.  *  *  Parts copyright (c) 1997, 1998 Cybernet Corporation, NetMAX project.  *  *  Written by Greg Lehey  *  *  This software is distributed under the so-called ``Berkeley  *  License'':  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Nan Yang Computer  *      Services Limited.  * 4. Neither the name of the Company nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * This software is provided ``as is'', and any express or implied  * warranties, including, but not limited to, the implied warranties of  * merchantability and fitness for a particular purpose are disclaimed.  * In no event shall the company or contributors be liable for any  * direct, indirect, incidental, special, exemplary, or consequential  * damages (including, but not limited to, procurement of substitute  * goods or services; loss of use, data, or profits; or business  * interruption) however caused and on any theory of liability, whether  * in contract, strict liability, or tort (including negligence or  * otherwise) arising in any way out of the use of this software, even if  * advised of the possibility of such damage.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<dev/vinum/vinumhdr.h>
end_include

begin_include
include|#
directive|include
file|<dev/vinum/request.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_function_decl
name|enum
name|requeststatus
name|bre
parameter_list|(
name|struct
name|request
modifier|*
name|rq
parameter_list|,
name|int
name|plexno
parameter_list|,
name|daddr_t
modifier|*
name|diskstart
parameter_list|,
name|daddr_t
name|diskend
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|enum
name|requeststatus
name|bre5
parameter_list|(
name|struct
name|request
modifier|*
name|rq
parameter_list|,
name|int
name|plexno
parameter_list|,
name|daddr_t
modifier|*
name|diskstart
parameter_list|,
name|daddr_t
name|diskend
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|enum
name|requeststatus
name|build_read_request
parameter_list|(
name|struct
name|request
modifier|*
name|rq
parameter_list|,
name|int
name|volplexno
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|enum
name|requeststatus
name|build_write_request
parameter_list|(
name|struct
name|request
modifier|*
name|rq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|enum
name|requeststatus
name|build_rq_buffer
parameter_list|(
name|struct
name|rqelement
modifier|*
name|rqe
parameter_list|,
name|struct
name|plex
modifier|*
name|plex
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|find_alternate_sd
parameter_list|(
name|struct
name|request
modifier|*
name|rq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|check_range_covered
parameter_list|(
name|struct
name|request
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|complete_rqe
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|complete_raid5_write
parameter_list|(
name|struct
name|rqelement
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|abortrequest
parameter_list|(
name|struct
name|request
modifier|*
name|rq
parameter_list|,
name|int
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|sdio_done
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|vinum_bounds_check
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|struct
name|volume
modifier|*
name|vol
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|caddr_t
name|allocdatabuf
parameter_list|(
name|struct
name|rqelement
modifier|*
name|rqe
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|freedatabuf
parameter_list|(
name|struct
name|rqelement
modifier|*
name|rqe
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|VINUMDEBUG
end_ifdef

begin_decl_stmt
name|struct
name|rqinfo
name|rqinfo
index|[
name|RQINFO_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rqinfo
modifier|*
name|rqip
init|=
name|rqinfo
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|logrq
parameter_list|(
name|enum
name|rqinfo_type
name|type
parameter_list|,
name|union
name|rqinfou
name|info
parameter_list|,
name|struct
name|buf
modifier|*
name|ubp
parameter_list|)
block|{
name|int
name|s
init|=
name|splhigh
argument_list|()
decl_stmt|;
name|microtime
argument_list|(
operator|&
name|rqip
operator|->
name|timestamp
argument_list|)
expr_stmt|;
comment|/* when did this happen? */
name|rqip
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|rqip
operator|->
name|bp
operator|=
name|ubp
expr_stmt|;
comment|/* user buffer */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|loginfo_user_bp
case|:
case|case
name|loginfo_user_bpl
case|:
case|case
name|loginfo_sdio
case|:
comment|/* subdisk I/O */
case|case
name|loginfo_sdiol
case|:
comment|/* subdisk I/O launch */
name|bcopy
argument_list|(
name|info
operator|.
name|bp
argument_list|,
operator|&
name|rqip
operator|->
name|info
operator|.
name|b
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|rqip
operator|->
name|devmajor
operator|=
name|major
argument_list|(
name|info
operator|.
name|bp
operator|->
name|b_dev
argument_list|)
expr_stmt|;
name|rqip
operator|->
name|devminor
operator|=
name|minor
argument_list|(
name|info
operator|.
name|bp
operator|->
name|b_dev
argument_list|)
expr_stmt|;
break|break;
case|case
name|loginfo_iodone
case|:
case|case
name|loginfo_rqe
case|:
case|case
name|loginfo_raid5_data
case|:
case|case
name|loginfo_raid5_parity
case|:
name|bcopy
argument_list|(
name|info
operator|.
name|rqe
argument_list|,
operator|&
name|rqip
operator|->
name|info
operator|.
name|rqe
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rqelement
argument_list|)
argument_list|)
expr_stmt|;
name|rqip
operator|->
name|devmajor
operator|=
name|major
argument_list|(
name|info
operator|.
name|rqe
operator|->
name|b
operator|.
name|b_dev
argument_list|)
expr_stmt|;
name|rqip
operator|->
name|devminor
operator|=
name|minor
argument_list|(
name|info
operator|.
name|rqe
operator|->
name|b
operator|.
name|b_dev
argument_list|)
expr_stmt|;
break|break;
case|case
name|loginfo_lockwait
case|:
case|case
name|loginfo_lock
case|:
case|case
name|loginfo_unlock
case|:
name|bcopy
argument_list|(
name|info
operator|.
name|lockinfo
argument_list|,
operator|&
name|rqip
operator|->
name|info
operator|.
name|lockinfo
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rangelock
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|loginfo_unused
case|:
break|break;
block|}
name|rqip
operator|++
expr_stmt|;
if|if
condition|(
name|rqip
operator|>=
operator|&
name|rqinfo
index|[
name|RQINFO_SIZE
index|]
condition|)
comment|/* wrap around */
name|rqip
operator|=
name|rqinfo
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|vinumstrategy
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|volno
decl_stmt|;
name|struct
name|volume
modifier|*
name|vol
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|DEVTYPE
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
condition|)
block|{
case|case
name|VINUM_SD_TYPE
case|:
case|case
name|VINUM_RAWSD_TYPE
case|:
name|sdio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
comment|/* 	 * In fact, vinum doesn't handle drives: they're 	 * handled directly by the disk drivers 	 */
case|case
name|VINUM_DRIVE_TYPE
case|:
default|default:
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
comment|/* I/O error */
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
case|case
name|VINUM_VOLUME_TYPE
case|:
comment|/* volume I/O */
name|volno
operator|=
name|Volno
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
expr_stmt|;
name|vol
operator|=
operator|&
name|VOL
index|[
name|volno
index|]
expr_stmt|;
if|if
condition|(
name|vol
operator|->
name|state
operator|!=
name|volume_up
condition|)
block|{
comment|/* can't access this volume */
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
comment|/* I/O error */
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|vinum_bounds_check
argument_list|(
name|bp
argument_list|,
name|vol
argument_list|)
operator|<=
literal|0
condition|)
block|{
comment|/* don't like them bounds */
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* have nothing to do with this */
return|return;
block|}
comment|/* FALLTHROUGH */
comment|/* 	 * Plex I/O is pretty much the same as volume I/O 	 * for a single plex.  Indicate this by passing a NULL 	 * pointer (set above) for the volume 	 */
case|case
name|VINUM_PLEX_TYPE
case|:
case|case
name|VINUM_RAWPLEX_TYPE
case|:
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
comment|/* transfer everything */
name|vinumstart
argument_list|(
name|bp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/*  * Start a transfer.  Return -1 on error,  * 0 if OK, 1 if we need to retry.  * Parameter reviveok is set when doing  * transfers for revives: it allows transfers to  * be started immediately when a revive is in  * progress.  During revive, normal transfers  * are queued if they share address space with  * a currently active revive operation.  */
end_comment

begin_function
name|int
name|vinumstart
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|int
name|reviveok
parameter_list|)
block|{
name|int
name|plexno
decl_stmt|;
name|int
name|maxplex
decl_stmt|;
comment|/* maximum number of plexes to handle */
name|struct
name|volume
modifier|*
name|vol
decl_stmt|;
name|struct
name|request
modifier|*
name|rq
decl_stmt|;
comment|/* build up our request here */
name|enum
name|requeststatus
name|status
decl_stmt|;
if|#
directive|if
name|VINUMDEBUG
if|if
condition|(
name|debug
operator|&
name|DEBUG_LASTREQS
condition|)
name|logrq
argument_list|(
name|loginfo_user_bp
argument_list|,
operator|(
expr|union
name|rqinfou
operator|)
name|bp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|bp
operator|->
name|b_bcount
operator|%
name|DEV_BSIZE
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* bad length */
name|bp
operator|->
name|b_error
operator|=
name|EINVAL
expr_stmt|;
comment|/* invalid size */
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|rq
operator|=
operator|(
expr|struct
name|request
operator|*
operator|)
name|Malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|request
argument_list|)
argument_list|)
expr_stmt|;
comment|/* allocate a request struct */
if|if
condition|(
name|rq
operator|==
name|NULL
condition|)
block|{
comment|/* can't do it */
name|bp
operator|->
name|b_error
operator|=
name|ENOMEM
expr_stmt|;
comment|/* can't get memory */
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|bzero
argument_list|(
name|rq
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|request
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * Note the volume ID.  This can be NULL, which      * the request building functions use as an      * indication for single plex I/O      */
name|rq
operator|->
name|bp
operator|=
name|bp
expr_stmt|;
comment|/* and the user buffer struct */
if|if
condition|(
name|DEVTYPE
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
operator|==
name|VINUM_VOLUME_TYPE
condition|)
block|{
comment|/* it's a volume, */
name|rq
operator|->
name|volplex
operator|.
name|volno
operator|=
name|Volno
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
expr_stmt|;
comment|/* get the volume number */
name|vol
operator|=
operator|&
name|VOL
index|[
name|rq
operator|->
name|volplex
operator|.
name|volno
index|]
expr_stmt|;
comment|/* and point to it */
name|vol
operator|->
name|active
operator|++
expr_stmt|;
comment|/* one more active request */
name|maxplex
operator|=
name|vol
operator|->
name|plexes
expr_stmt|;
comment|/* consider all its plexes */
block|}
else|else
block|{
name|vol
operator|=
name|NULL
expr_stmt|;
comment|/* no volume */
name|rq
operator|->
name|volplex
operator|.
name|plexno
operator|=
name|Plexno
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
expr_stmt|;
comment|/* point to the plex */
name|rq
operator|->
name|isplex
operator|=
literal|1
expr_stmt|;
comment|/* note that it's a plex */
name|maxplex
operator|=
literal|1
expr_stmt|;
comment|/* just the one plex */
block|}
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
block|{
comment|/* 	 * This is a read request.  Decide 	 * which plex to read from. 	 * 	 * There's a potential race condition here, 	 * since we're not locked, and we could end 	 * up multiply incrementing the round-robin 	 * counter.  This doesn't have any serious 	 * effects, however. 	 */
if|if
condition|(
name|vol
operator|!=
name|NULL
condition|)
block|{
name|vol
operator|->
name|reads
operator|++
expr_stmt|;
name|vol
operator|->
name|bytes_read
operator|+=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|plexno
operator|=
name|vol
operator|->
name|preferred_plex
expr_stmt|;
comment|/* get the plex to use */
if|if
condition|(
name|plexno
operator|<
literal|0
condition|)
block|{
comment|/* round robin */
name|plexno
operator|=
name|vol
operator|->
name|last_plex_read
expr_stmt|;
name|vol
operator|->
name|last_plex_read
operator|++
expr_stmt|;
if|if
condition|(
name|vol
operator|->
name|last_plex_read
operator|>=
name|vol
operator|->
name|plexes
condition|)
comment|/* got the the end? */
name|vol
operator|->
name|last_plex_read
operator|=
literal|0
expr_stmt|;
comment|/* wrap around */
block|}
name|status
operator|=
name|build_read_request
argument_list|(
name|rq
argument_list|,
name|plexno
argument_list|)
expr_stmt|;
comment|/* build a request */
block|}
else|else
block|{
name|daddr_t
name|diskaddr
init|=
name|bp
operator|->
name|b_blkno
decl_stmt|;
comment|/* start offset of transfer */
name|status
operator|=
name|bre
argument_list|(
name|rq
argument_list|,
comment|/* build a request list */
name|rq
operator|->
name|volplex
operator|.
name|plexno
argument_list|,
operator|&
name|diskaddr
argument_list|,
name|diskaddr
operator|+
operator|(
name|bp
operator|->
name|b_bcount
operator|/
name|DEV_BSIZE
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|status
operator|>
name|REQUEST_RECOVERED
operator|)
comment|/* can't satisfy it */
operator|||
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DONE
operator|)
condition|)
block|{
comment|/* XXX shouldn't get this without bad status */
if|if
condition|(
name|status
operator|==
name|REQUEST_DOWN
condition|)
block|{
comment|/* not enough subdisks */
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
comment|/* I/O error */
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
block|}
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|freerq
argument_list|(
name|rq
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|launch_requests
argument_list|(
name|rq
argument_list|,
name|reviveok
argument_list|)
return|;
comment|/* now start the requests if we can */
block|}
else|else
comment|/* 	 * This is a write operation.  We write to all 	 * plexes.  If this is a RAID 5 plex, we must also 	 * update the parity stripe. 	 */
block|{
if|if
condition|(
name|vol
operator|!=
name|NULL
condition|)
block|{
name|vol
operator|->
name|writes
operator|++
expr_stmt|;
name|vol
operator|->
name|bytes_written
operator|+=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|status
operator|=
name|build_write_request
argument_list|(
name|rq
argument_list|)
expr_stmt|;
comment|/* Not all the subdisks are up */
block|}
else|else
block|{
comment|/* plex I/O */
name|daddr_t
name|diskstart
decl_stmt|;
name|diskstart
operator|=
name|bp
operator|->
name|b_blkno
expr_stmt|;
comment|/* start offset of transfer */
name|status
operator|=
name|bre
argument_list|(
name|rq
argument_list|,
name|Plexno
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
argument_list|,
operator|&
name|diskstart
argument_list|,
name|bp
operator|->
name|b_blkno
operator|+
operator|(
name|bp
operator|->
name|b_bcount
operator|/
name|DEV_BSIZE
operator|)
argument_list|)
expr_stmt|;
comment|/* build requests for the plex */
block|}
if|if
condition|(
operator|(
name|status
operator|>
name|REQUEST_RECOVERED
operator|)
comment|/* can't satisfy it */
operator|||
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DONE
operator|)
condition|)
block|{
comment|/* XXX shouldn't get this without bad status */
if|if
condition|(
name|status
operator|==
name|REQUEST_DOWN
condition|)
block|{
comment|/* not enough subdisks */
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
comment|/* I/O error */
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DONE
operator|)
operator|==
literal|0
condition|)
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|freerq
argument_list|(
name|rq
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|launch_requests
argument_list|(
name|rq
argument_list|,
name|reviveok
argument_list|)
return|;
comment|/* now start the requests if we can */
block|}
block|}
end_function

begin_comment
comment|/*  * Call the low-level strategy routines to  * perform the requests in a struct request  */
end_comment

begin_function
name|int
name|launch_requests
parameter_list|(
name|struct
name|request
modifier|*
name|rq
parameter_list|,
name|int
name|reviveok
parameter_list|)
block|{
name|struct
name|rqgroup
modifier|*
name|rqg
decl_stmt|;
name|int
name|rqno
decl_stmt|;
comment|/* loop index */
name|struct
name|rqelement
modifier|*
name|rqe
decl_stmt|;
comment|/* current element */
name|int
name|s
decl_stmt|;
comment|/*      * First find out whether we're reviving, and the      * request contains a conflict.  If so, we hang      * the request off plex->waitlist of the first      * plex we find which is reviving      */
if|if
condition|(
operator|(
name|rq
operator|->
name|flags
operator|&
name|XFR_REVIVECONFLICT
operator|)
comment|/* possible revive conflict */
operator|&&
operator|(
operator|!
name|reviveok
operator|)
condition|)
block|{
comment|/* and we don't want to do it now, */
name|struct
name|sd
modifier|*
name|sd
decl_stmt|;
name|struct
name|request
modifier|*
name|waitlist
decl_stmt|;
comment|/* point to the waitlist */
name|sd
operator|=
operator|&
name|SD
index|[
name|rq
operator|->
name|sdno
index|]
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|waitlist
operator|!=
name|NULL
condition|)
block|{
comment|/* something there already, */
name|waitlist
operator|=
name|sd
operator|->
name|waitlist
expr_stmt|;
while|while
condition|(
name|waitlist
operator|->
name|next
operator|!=
name|NULL
condition|)
comment|/* find the end */
name|waitlist
operator|=
name|waitlist
operator|->
name|next
expr_stmt|;
name|waitlist
operator|->
name|next
operator|=
name|rq
expr_stmt|;
comment|/* hook our request there */
block|}
else|else
name|sd
operator|->
name|waitlist
operator|=
name|rq
expr_stmt|;
comment|/* hook our request at the front */
if|#
directive|if
name|VINUMDEBUG
if|if
condition|(
name|debug
operator|&
name|DEBUG_REVIVECONFLICT
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"Revive conflict sd %d: %x\n%s dev %d.%d, offset 0x%x, length %ld\n"
argument_list|,
name|rq
operator|->
name|sdno
argument_list|,
operator|(
name|u_int
operator|)
name|rq
argument_list|,
name|rq
operator|->
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|?
literal|"Read"
else|:
literal|"Write"
argument_list|,
name|major
argument_list|(
name|rq
operator|->
name|bp
operator|->
name|b_dev
argument_list|)
argument_list|,
name|minor
argument_list|(
name|rq
operator|->
name|bp
operator|->
name|b_dev
argument_list|)
argument_list|,
name|rq
operator|->
name|bp
operator|->
name|b_blkno
argument_list|,
name|rq
operator|->
name|bp
operator|->
name|b_bcount
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
comment|/* and get out of here */
block|}
name|rq
operator|->
name|active
operator|=
literal|0
expr_stmt|;
comment|/* nothing yet */
comment|/* XXX This is probably due to a bug */
if|if
condition|(
name|rq
operator|->
name|rqg
operator|==
name|NULL
condition|)
block|{
comment|/* no request */
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"vinum: null rqg\n"
argument_list|)
expr_stmt|;
name|abortrequest
argument_list|(
name|rq
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|#
directive|if
name|VINUMDEBUG
if|if
condition|(
name|debug
operator|&
name|DEBUG_ADDRESSES
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"Request: %x\n%s dev %d.%d, offset 0x%x, length %ld\n"
argument_list|,
operator|(
name|u_int
operator|)
name|rq
argument_list|,
name|rq
operator|->
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|?
literal|"Read"
else|:
literal|"Write"
argument_list|,
name|major
argument_list|(
name|rq
operator|->
name|bp
operator|->
name|b_dev
argument_list|)
argument_list|,
name|minor
argument_list|(
name|rq
operator|->
name|bp
operator|->
name|b_dev
argument_list|)
argument_list|,
name|rq
operator|->
name|bp
operator|->
name|b_blkno
argument_list|,
name|rq
operator|->
name|bp
operator|->
name|b_bcount
argument_list|)
expr_stmt|;
name|vinum_conf
operator|.
name|lastrq
operator|=
operator|(
name|int
operator|)
name|rq
expr_stmt|;
name|vinum_conf
operator|.
name|lastbuf
operator|=
name|rq
operator|->
name|bp
expr_stmt|;
if|if
condition|(
name|debug
operator|&
name|DEBUG_LASTREQS
condition|)
name|logrq
argument_list|(
name|loginfo_user_bpl
argument_list|,
operator|(
expr|union
name|rqinfou
operator|)
name|rq
operator|->
name|bp
argument_list|,
name|rq
operator|->
name|bp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
for|for
control|(
name|rqg
operator|=
name|rq
operator|->
name|rqg
init|;
name|rqg
operator|!=
name|NULL
condition|;
name|rqg
operator|=
name|rqg
operator|->
name|next
control|)
block|{
comment|/* through the whole request chain */
name|rqg
operator|->
name|active
operator|=
name|rqg
operator|->
name|count
expr_stmt|;
comment|/* they're all active */
for|for
control|(
name|rqno
operator|=
literal|0
init|;
name|rqno
operator|<
name|rqg
operator|->
name|count
condition|;
name|rqno
operator|++
control|)
block|{
name|rqe
operator|=
operator|&
name|rqg
operator|->
name|rqe
index|[
name|rqno
index|]
expr_stmt|;
if|if
condition|(
name|rqe
operator|->
name|flags
operator|&
name|XFR_BAD_SUBDISK
condition|)
comment|/* this subdisk is bad, */
name|rqg
operator|->
name|active
operator|--
expr_stmt|;
comment|/* one less active request */
else|else
block|{
comment|/* we can do it */
if|if
condition|(
operator|(
name|rqe
operator|->
name|b
operator|.
name|b_flags
operator|&
name|B_READ
operator|)
operator|==
literal|0
condition|)
name|rqe
operator|->
name|b
operator|.
name|b_vp
operator|->
name|v_numoutput
operator|++
expr_stmt|;
comment|/* one more output going */
name|rqe
operator|->
name|b
operator|.
name|b_flags
operator||=
name|B_ORDERED
expr_stmt|;
comment|/* stick to the request order */
if|#
directive|if
name|VINUMDEBUG
if|if
condition|(
name|debug
operator|&
name|DEBUG_ADDRESSES
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"  %s dev %d.%d, sd %d, offset 0x%x, devoffset 0x%x, length %ld\n"
argument_list|,
name|rqe
operator|->
name|b
operator|.
name|b_flags
operator|&
name|B_READ
condition|?
literal|"Read"
else|:
literal|"Write"
argument_list|,
name|major
argument_list|(
name|rqe
operator|->
name|b
operator|.
name|b_dev
argument_list|)
argument_list|,
name|minor
argument_list|(
name|rqe
operator|->
name|b
operator|.
name|b_dev
argument_list|)
argument_list|,
name|rqe
operator|->
name|sdno
argument_list|,
call|(
name|u_int
call|)
argument_list|(
name|rqe
operator|->
name|b
operator|.
name|b_blkno
operator|-
name|SD
index|[
name|rqe
operator|->
name|sdno
index|]
operator|.
name|driveoffset
argument_list|)
argument_list|,
name|rqe
operator|->
name|b
operator|.
name|b_blkno
argument_list|,
name|rqe
operator|->
name|b
operator|.
name|b_bcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|&
name|DEBUG_NUMOUTPUT
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"  vinumstart sd %d numoutput %ld\n"
argument_list|,
name|rqe
operator|->
name|sdno
argument_list|,
name|rqe
operator|->
name|b
operator|.
name|b_vp
operator|->
name|v_numoutput
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|&
name|DEBUG_LASTREQS
condition|)
name|logrq
argument_list|(
name|loginfo_rqe
argument_list|,
operator|(
expr|union
name|rqinfou
operator|)
name|rqe
argument_list|,
name|rq
operator|->
name|bp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* fire off the request */
operator|(
operator|*
name|bdevsw
index|[
name|major
argument_list|(
name|rqe
operator|->
name|b
operator|.
name|b_dev
argument_list|)
index|]
operator|->
name|d_strategy
operator|)
operator|(
operator|&
name|rqe
operator|->
name|b
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rqg
operator|->
name|active
condition|)
comment|/* we have at least one active request, */
name|rq
operator|->
name|active
operator|++
expr_stmt|;
comment|/* one more active request group */
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * define the low-level requests needed to perform a  * high-level I/O operation for a specific plex 'plexno'.  *  * Return REQUEST_OK if all subdisks involved in the request are up,  * REQUEST_DOWN if some subdisks are not up, and REQUEST_EOF if the  * request is at least partially outside the bounds of the subdisks.  *  * Modify the pointer *diskstart to point to the end address.  On  * read, return on the first bad subdisk, so that the caller  * (build_read_request) can try alternatives.  *  * On entry to this routine, the rqg structures are not assigned.  The  * assignment is performed by expandrq().  Strictly speaking, the  * elements rqe->sdno of all entries should be set to -1, since 0  * (from bzero) is a valid subdisk number.  We avoid this problem by  * initializing the ones we use, and not looking at the others (index  *>= rqg->requests).  */
end_comment

begin_function
name|enum
name|requeststatus
name|bre
parameter_list|(
name|struct
name|request
modifier|*
name|rq
parameter_list|,
name|int
name|plexno
parameter_list|,
name|daddr_t
modifier|*
name|diskaddr
parameter_list|,
name|daddr_t
name|diskend
parameter_list|)
block|{
name|int
name|sdno
decl_stmt|;
name|struct
name|sd
modifier|*
name|sd
decl_stmt|;
name|struct
name|rqgroup
modifier|*
name|rqg
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
comment|/* user's bp */
name|struct
name|plex
modifier|*
name|plex
decl_stmt|;
name|enum
name|requeststatus
name|status
decl_stmt|;
comment|/* return value */
name|daddr_t
name|plexoffset
decl_stmt|;
comment|/* offset of transfer in plex */
name|daddr_t
name|stripebase
decl_stmt|;
comment|/* base address of stripe (1st subdisk) */
name|daddr_t
name|stripeoffset
decl_stmt|;
comment|/* offset in stripe */
name|daddr_t
name|blockoffset
decl_stmt|;
comment|/* offset in stripe on subdisk */
name|struct
name|rqelement
modifier|*
name|rqe
decl_stmt|;
comment|/* point to this request information */
name|daddr_t
name|diskstart
init|=
operator|*
name|diskaddr
decl_stmt|;
comment|/* remember where this transfer starts */
name|enum
name|requeststatus
name|s
decl_stmt|;
comment|/* temp return value */
name|bp
operator|=
name|rq
operator|->
name|bp
expr_stmt|;
comment|/* buffer pointer */
name|status
operator|=
name|REQUEST_OK
expr_stmt|;
comment|/* return value: OK until proven otherwise */
name|plex
operator|=
operator|&
name|PLEX
index|[
name|plexno
index|]
expr_stmt|;
comment|/* point to the plex */
switch|switch
condition|(
name|plex
operator|->
name|organization
condition|)
block|{
case|case
name|plex_concat
case|:
name|sd
operator|=
name|NULL
expr_stmt|;
comment|/* (keep compiler quiet) */
for|for
control|(
name|sdno
operator|=
literal|0
init|;
name|sdno
operator|<
name|plex
operator|->
name|subdisks
condition|;
name|sdno
operator|++
control|)
block|{
name|sd
operator|=
operator|&
name|SD
index|[
name|plex
operator|->
name|sdnos
index|[
name|sdno
index|]
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|diskaddr
operator|<
name|sd
operator|->
name|plexoffset
condition|)
comment|/* we must have a hole, */
name|status
operator|=
name|REQUEST_DEGRADED
expr_stmt|;
comment|/* note the fact */
if|if
condition|(
operator|*
name|diskaddr
operator|<
operator|(
name|sd
operator|->
name|plexoffset
operator|+
name|sd
operator|->
name|sectors
operator|)
condition|)
block|{
comment|/* the request starts in this subdisk */
name|rqg
operator|=
name|allocrqg
argument_list|(
name|rq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* space for the request */
if|if
condition|(
name|rqg
operator|==
name|NULL
condition|)
block|{
comment|/* malloc failed */
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|ENOMEM
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
name|REQUEST_ENOMEM
return|;
block|}
name|rqg
operator|->
name|plexno
operator|=
name|plexno
expr_stmt|;
name|rqe
operator|=
operator|&
name|rqg
operator|->
name|rqe
index|[
literal|0
index|]
expr_stmt|;
comment|/* point to the element */
name|rqe
operator|->
name|rqg
operator|=
name|rqg
expr_stmt|;
comment|/* group */
name|rqe
operator|->
name|sdno
operator|=
name|sd
operator|->
name|sdno
expr_stmt|;
comment|/* put in the subdisk number */
name|plexoffset
operator|=
operator|*
name|diskaddr
expr_stmt|;
comment|/* start offset in plex */
name|rqe
operator|->
name|sdoffset
operator|=
name|plexoffset
operator|-
name|sd
operator|->
name|plexoffset
expr_stmt|;
comment|/* start offset in subdisk */
name|rqe
operator|->
name|useroffset
operator|=
name|plexoffset
operator|-
name|diskstart
expr_stmt|;
comment|/* start offset in user buffer */
name|rqe
operator|->
name|dataoffset
operator|=
literal|0
expr_stmt|;
name|rqe
operator|->
name|datalen
operator|=
name|min
argument_list|(
name|diskend
operator|-
operator|*
name|diskaddr
argument_list|,
comment|/* number of sectors to transfer in this sd */
name|sd
operator|->
name|sectors
operator|-
name|rqe
operator|->
name|sdoffset
argument_list|)
expr_stmt|;
name|rqe
operator|->
name|groupoffset
operator|=
literal|0
expr_stmt|;
comment|/* no groups for concatenated plexes */
name|rqe
operator|->
name|grouplen
operator|=
literal|0
expr_stmt|;
name|rqe
operator|->
name|buflen
operator|=
name|rqe
operator|->
name|datalen
expr_stmt|;
comment|/* buffer length is data buffer length */
name|rqe
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|rqe
operator|->
name|driveno
operator|=
name|sd
operator|->
name|driveno
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|state
operator|!=
name|sd_up
condition|)
block|{
comment|/* *now* we find the sd is down */
name|s
operator|=
name|checksdstate
argument_list|(
name|sd
argument_list|,
name|rq
argument_list|,
operator|*
name|diskaddr
argument_list|,
name|diskend
argument_list|)
expr_stmt|;
comment|/* do we need to change state? */
if|if
condition|(
name|s
operator|==
name|REQUEST_DOWN
condition|)
block|{
comment|/* down? */
name|rqe
operator|->
name|flags
operator|=
name|XFR_BAD_SUBDISK
expr_stmt|;
comment|/* yup */
if|if
condition|(
name|rq
operator|->
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
comment|/* read request, */
return|return
name|REQUEST_DEGRADED
return|;
comment|/* give up here */
comment|/* 			 * If we're writing, don't give up 			 * because of a bad subdisk.  Go 			 * through to the bitter end, but note 			 * which ones we can't access. 			 */
name|status
operator|=
name|REQUEST_DEGRADED
expr_stmt|;
comment|/* can't do it all */
block|}
block|}
operator|*
name|diskaddr
operator|+=
name|rqe
operator|->
name|datalen
expr_stmt|;
comment|/* bump the address */
if|if
condition|(
name|build_rq_buffer
argument_list|(
name|rqe
argument_list|,
name|plex
argument_list|)
condition|)
block|{
comment|/* build the buffer */
name|deallocrqg
argument_list|(
name|rqg
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|ENOMEM
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
name|REQUEST_ENOMEM
return|;
comment|/* can't do it */
block|}
block|}
if|if
condition|(
operator|*
name|diskaddr
operator|==
name|diskend
condition|)
comment|/* we're finished, */
break|break;
comment|/* get out of here */
block|}
comment|/* 	 * We've got to the end of the plex.  Have we got to the end of 	 * the transfer?  It would seem that having an offset beyond the 	 * end of the subdisk is an error, but in fact it can happen if 	 * the volume has another plex of different size.  There's a valid 	 * question as to why you would want to do this, but currently 	 * it's allowed. 	 * 	 * In a previous version, I returned REQUEST_DOWN here.  I think 	 * REQUEST_EOF is more appropriate now. 	 */
if|if
condition|(
name|diskend
operator|>
name|sd
operator|->
name|sectors
operator|+
name|sd
operator|->
name|plexoffset
condition|)
comment|/* pointing beyond EOF? */
name|status
operator|=
name|REQUEST_EOF
expr_stmt|;
break|break;
case|case
name|plex_striped
case|:
block|{
while|while
condition|(
operator|*
name|diskaddr
operator|<
name|diskend
condition|)
block|{
comment|/* until we get it all sorted out */
if|if
condition|(
operator|*
name|diskaddr
operator|>=
name|plex
operator|->
name|length
condition|)
comment|/* beyond the end of the plex */
return|return
name|REQUEST_EOF
return|;
comment|/* can't continue */
comment|/* The offset of the start address from the start of the stripe. */
name|stripeoffset
operator|=
operator|*
name|diskaddr
operator|%
operator|(
name|plex
operator|->
name|stripesize
operator|*
name|plex
operator|->
name|subdisks
operator|)
expr_stmt|;
comment|/* The plex-relative address of the start of the stripe. */
name|stripebase
operator|=
operator|*
name|diskaddr
operator|-
name|stripeoffset
expr_stmt|;
comment|/* The number of the subdisk in which the start is located. */
name|sdno
operator|=
name|stripeoffset
operator|/
name|plex
operator|->
name|stripesize
expr_stmt|;
comment|/* The offset from the beginning of the stripe on this subdisk. */
name|blockoffset
operator|=
name|stripeoffset
operator|%
name|plex
operator|->
name|stripesize
expr_stmt|;
name|sd
operator|=
operator|&
name|SD
index|[
name|plex
operator|->
name|sdnos
index|[
name|sdno
index|]
index|]
expr_stmt|;
comment|/* the subdisk in question */
name|rqg
operator|=
name|allocrqg
argument_list|(
name|rq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* space for the request */
if|if
condition|(
name|rqg
operator|==
name|NULL
condition|)
block|{
comment|/* malloc failed */
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|ENOMEM
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
name|REQUEST_ENOMEM
return|;
block|}
name|rqg
operator|->
name|plexno
operator|=
name|plexno
expr_stmt|;
name|rqe
operator|=
operator|&
name|rqg
operator|->
name|rqe
index|[
literal|0
index|]
expr_stmt|;
comment|/* point to the element */
name|rqe
operator|->
name|rqg
operator|=
name|rqg
expr_stmt|;
name|rqe
operator|->
name|sdoffset
operator|=
name|stripebase
operator|/
name|plex
operator|->
name|subdisks
operator|+
name|blockoffset
expr_stmt|;
comment|/* start offset in this subdisk */
name|rqe
operator|->
name|useroffset
operator|=
operator|*
name|diskaddr
operator|-
name|diskstart
expr_stmt|;
comment|/* The offset of the start in the user buffer */
name|rqe
operator|->
name|dataoffset
operator|=
literal|0
expr_stmt|;
name|rqe
operator|->
name|datalen
operator|=
name|min
argument_list|(
name|diskend
operator|-
operator|*
name|diskaddr
argument_list|,
comment|/* the amount remaining to transfer */
name|plex
operator|->
name|stripesize
operator|-
name|blockoffset
argument_list|)
expr_stmt|;
comment|/* and the amount left in this stripe */
name|rqe
operator|->
name|groupoffset
operator|=
literal|0
expr_stmt|;
comment|/* no groups for striped plexes */
name|rqe
operator|->
name|grouplen
operator|=
literal|0
expr_stmt|;
name|rqe
operator|->
name|buflen
operator|=
name|rqe
operator|->
name|datalen
expr_stmt|;
comment|/* buffer length is data buffer length */
name|rqe
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|rqe
operator|->
name|sdno
operator|=
name|sd
operator|->
name|sdno
expr_stmt|;
comment|/* put in the subdisk number */
name|rqe
operator|->
name|driveno
operator|=
name|sd
operator|->
name|driveno
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|state
operator|!=
name|sd_up
condition|)
block|{
comment|/* *now* we find the sd is down */
name|s
operator|=
name|checksdstate
argument_list|(
name|sd
argument_list|,
name|rq
argument_list|,
operator|*
name|diskaddr
argument_list|,
name|diskend
argument_list|)
expr_stmt|;
comment|/* do we need to change state? */
if|if
condition|(
name|s
operator|==
name|REQUEST_DOWN
condition|)
block|{
comment|/* down? */
name|rqe
operator|->
name|flags
operator|=
name|XFR_BAD_SUBDISK
expr_stmt|;
comment|/* yup */
if|if
condition|(
name|rq
operator|->
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
comment|/* read request, */
return|return
name|REQUEST_DEGRADED
return|;
comment|/* give up here */
comment|/* 			 * If we're writing, don't give up 			 * because of a bad subdisk.  Go through 			 * to the bitter end, but note which 			 * ones we can't access. 			 */
name|status
operator|=
name|REQUEST_DEGRADED
expr_stmt|;
comment|/* can't do it all */
block|}
block|}
comment|/* 		 * It would seem that having an offset 		 * beyond the end of the subdisk is an 		 * error, but in fact it can happen if the 		 * volume has another plex of different 		 * size.  There's a valid question as to why 		 * you would want to do this, but currently 		 * it's allowed. 		 */
if|if
condition|(
name|rqe
operator|->
name|sdoffset
operator|+
name|rqe
operator|->
name|datalen
operator|>
name|sd
operator|->
name|sectors
condition|)
block|{
comment|/* ends beyond the end of the subdisk? */
name|rqe
operator|->
name|datalen
operator|=
name|sd
operator|->
name|sectors
operator|-
name|rqe
operator|->
name|sdoffset
expr_stmt|;
comment|/* truncate */
if|#
directive|if
name|VINUMDEBUG
if|if
condition|(
name|debug
operator|&
name|DEBUG_EOFINFO
condition|)
block|{
comment|/* tell on the request */
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"vinum: EOF on plex %s, sd %s offset %x (user offset %x)\n"
argument_list|,
name|plex
operator|->
name|name
argument_list|,
name|sd
operator|->
name|name
argument_list|,
operator|(
name|u_int
operator|)
name|sd
operator|->
name|sectors
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"vinum: stripebase %x, stripeoffset %x, blockoffset %x\n"
argument_list|,
name|stripebase
argument_list|,
name|stripeoffset
argument_list|,
name|blockoffset
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|build_rq_buffer
argument_list|(
name|rqe
argument_list|,
name|plex
argument_list|)
condition|)
block|{
comment|/* build the buffer */
name|deallocrqg
argument_list|(
name|rqg
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|ENOMEM
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
name|REQUEST_ENOMEM
return|;
comment|/* can't do it */
block|}
operator|*
name|diskaddr
operator|+=
name|rqe
operator|->
name|datalen
expr_stmt|;
comment|/* look at the remainder */
if|if
condition|(
operator|(
operator|*
name|diskaddr
operator|<
name|diskend
operator|)
comment|/* didn't finish the request on this stripe */
operator|&&
operator|(
operator|*
name|diskaddr
operator|<
name|plex
operator|->
name|length
operator|)
condition|)
block|{
comment|/* and there's more to come */
name|plex
operator|->
name|multiblock
operator|++
expr_stmt|;
comment|/* count another one */
if|if
condition|(
name|sdno
operator|==
name|plex
operator|->
name|subdisks
operator|-
literal|1
condition|)
comment|/* last subdisk, */
name|plex
operator|->
name|multistripe
operator|++
expr_stmt|;
comment|/* another stripe as well */
block|}
block|}
block|}
break|break;
comment|/* 	 * RAID5 is complicated enough to have 	 * its own function 	 */
case|case
name|plex_raid5
case|:
name|status
operator|=
name|bre5
argument_list|(
name|rq
argument_list|,
name|plexno
argument_list|,
name|diskaddr
argument_list|,
name|diskend
argument_list|)
expr_stmt|;
break|break;
default|default:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"vinum: invalid plex type %d in bre\n"
argument_list|,
name|plex
operator|->
name|organization
argument_list|)
expr_stmt|;
name|status
operator|=
name|REQUEST_DOWN
expr_stmt|;
comment|/* can't access it */
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/*  * Build up a request structure for reading volumes.  * This function is not needed for plex reads, since there's  * no recovery if a plex read can't be satisified.  */
end_comment

begin_function
name|enum
name|requeststatus
name|build_read_request
parameter_list|(
name|struct
name|request
modifier|*
name|rq
parameter_list|,
comment|/* request */
name|int
name|plexindex
parameter_list|)
block|{
comment|/* index in the volume's plex table */
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|daddr_t
name|startaddr
decl_stmt|;
comment|/* offset of previous part of transfer */
name|daddr_t
name|diskaddr
decl_stmt|;
comment|/* offset of current part of transfer */
name|daddr_t
name|diskend
decl_stmt|;
comment|/* and end offset of transfer */
name|int
name|plexno
decl_stmt|;
comment|/* plex index in vinum_conf */
name|struct
name|rqgroup
modifier|*
name|rqg
decl_stmt|;
comment|/* point to the request we're working on */
name|struct
name|volume
modifier|*
name|vol
decl_stmt|;
comment|/* volume in question */
name|int
name|recovered
init|=
literal|0
decl_stmt|;
comment|/* set if we recover a read */
name|enum
name|requeststatus
name|status
init|=
name|REQUEST_OK
decl_stmt|;
name|int
name|plexmask
decl_stmt|;
comment|/* bit mask of plexes, for recovery */
name|bp
operator|=
name|rq
operator|->
name|bp
expr_stmt|;
comment|/* buffer pointer */
name|diskaddr
operator|=
name|bp
operator|->
name|b_blkno
expr_stmt|;
comment|/* start offset of transfer */
name|diskend
operator|=
name|diskaddr
operator|+
operator|(
name|bp
operator|->
name|b_bcount
operator|/
name|DEV_BSIZE
operator|)
expr_stmt|;
comment|/* and end offset of transfer */
name|rqg
operator|=
operator|&
name|rq
operator|->
name|rqg
index|[
name|plexindex
index|]
expr_stmt|;
comment|/* plex request */
name|vol
operator|=
operator|&
name|VOL
index|[
name|rq
operator|->
name|volplex
operator|.
name|volno
index|]
expr_stmt|;
comment|/* point to volume */
while|while
condition|(
name|diskaddr
operator|<
name|diskend
condition|)
block|{
comment|/* build up request components */
name|startaddr
operator|=
name|diskaddr
expr_stmt|;
name|status
operator|=
name|bre
argument_list|(
name|rq
argument_list|,
name|vol
operator|->
name|plex
index|[
name|plexindex
index|]
argument_list|,
operator|&
name|diskaddr
argument_list|,
name|diskend
argument_list|)
expr_stmt|;
comment|/* build up a request */
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|REQUEST_OK
case|:
continue|continue;
case|case
name|REQUEST_RECOVERED
case|:
comment|/* 	     * XXX FIXME if we have more than one plex, and we can 	     * satisfy the request from another, don't use the 	     * recovered request, since it's more expensive. 	     */
name|recovered
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|REQUEST_ENOMEM
case|:
return|return
name|status
return|;
comment|/* 	     * If we get here, our request is not complete.  Try 	     * to fill in the missing parts from another plex. 	     * This can happen multiple times in this function, 	     * and we reinitialize the plex mask each time, since 	     * we could have a hole in our plexes. 	     */
case|case
name|REQUEST_EOF
case|:
case|case
name|REQUEST_DOWN
case|:
comment|/* can't access the plex */
case|case
name|REQUEST_DEGRADED
case|:
comment|/* can't access the plex */
name|plexmask
operator|=
operator|(
operator|(
literal|1
operator|<<
name|vol
operator|->
name|plexes
operator|)
operator|-
literal|1
operator|)
comment|/* all plexes in the volume */
operator|&
operator|~
operator|(
literal|1
operator|<<
name|plexindex
operator|)
expr_stmt|;
comment|/* except for the one we were looking at */
for|for
control|(
name|plexno
operator|=
literal|0
init|;
name|plexno
operator|<
name|vol
operator|->
name|plexes
condition|;
name|plexno
operator|++
control|)
block|{
if|if
condition|(
name|plexmask
operator|==
literal|0
condition|)
comment|/* no plexes left to try */
return|return
name|REQUEST_DOWN
return|;
comment|/* failed */
name|diskaddr
operator|=
name|startaddr
expr_stmt|;
comment|/* start at the beginning again */
if|if
condition|(
name|plexmask
operator|&
operator|(
literal|1
operator|<<
name|plexno
operator|)
condition|)
block|{
comment|/* we haven't tried this plex yet */
name|bre
argument_list|(
name|rq
argument_list|,
name|vol
operator|->
name|plex
index|[
name|plexno
index|]
argument_list|,
operator|&
name|diskaddr
argument_list|,
name|diskend
argument_list|)
expr_stmt|;
comment|/* try a request */
if|if
condition|(
name|diskaddr
operator|>
name|startaddr
condition|)
block|{
comment|/* we satisfied another part */
name|recovered
operator|=
literal|1
expr_stmt|;
comment|/* we recovered from the problem */
name|status
operator|=
name|REQUEST_OK
expr_stmt|;
comment|/* don't complain about it */
break|break;
block|}
block|}
block|}
if|if
condition|(
name|diskaddr
operator|==
name|startaddr
condition|)
comment|/* didn't get any further, */
return|return
name|status
return|;
block|}
if|if
condition|(
name|recovered
condition|)
name|vol
operator|->
name|recovered_reads
operator|+=
name|recovered
expr_stmt|;
comment|/* adjust our recovery count */
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/*  * Build up a request structure for writes.  * Return 0 if all subdisks involved in the request are up, 1 if some  * subdisks are not up, and -1 if the request is at least partially  * outside the bounds of the subdisks.  */
end_comment

begin_function
name|enum
name|requeststatus
name|build_write_request
parameter_list|(
name|struct
name|request
modifier|*
name|rq
parameter_list|)
block|{
comment|/* request */
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|daddr_t
name|diskstart
decl_stmt|;
comment|/* offset of current part of transfer */
name|daddr_t
name|diskend
decl_stmt|;
comment|/* and end offset of transfer */
name|int
name|plexno
decl_stmt|;
comment|/* plex index in vinum_conf */
name|struct
name|volume
modifier|*
name|vol
decl_stmt|;
comment|/* volume in question */
name|enum
name|requeststatus
name|status
decl_stmt|;
name|bp
operator|=
name|rq
operator|->
name|bp
expr_stmt|;
comment|/* buffer pointer */
name|vol
operator|=
operator|&
name|VOL
index|[
name|rq
operator|->
name|volplex
operator|.
name|volno
index|]
expr_stmt|;
comment|/* point to volume */
name|diskend
operator|=
name|bp
operator|->
name|b_blkno
operator|+
operator|(
name|bp
operator|->
name|b_bcount
operator|/
name|DEV_BSIZE
operator|)
expr_stmt|;
comment|/* end offset of transfer */
name|status
operator|=
name|REQUEST_DOWN
expr_stmt|;
comment|/* assume the worst */
for|for
control|(
name|plexno
operator|=
literal|0
init|;
name|plexno
operator|<
name|vol
operator|->
name|plexes
condition|;
name|plexno
operator|++
control|)
block|{
name|diskstart
operator|=
name|bp
operator|->
name|b_blkno
expr_stmt|;
comment|/* start offset of transfer */
comment|/* 	 * Build requests for the plex. 	 * We take the best possible result here (min, 	 * not max): we're happy if we can write at all 	 */
name|status
operator|=
name|min
argument_list|(
name|status
argument_list|,
name|bre
argument_list|(
name|rq
argument_list|,
name|vol
operator|->
name|plex
index|[
name|plexno
index|]
argument_list|,
operator|&
name|diskstart
argument_list|,
name|diskend
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* Fill in the struct buf part of a request element. */
end_comment

begin_function
name|enum
name|requeststatus
name|build_rq_buffer
parameter_list|(
name|struct
name|rqelement
modifier|*
name|rqe
parameter_list|,
name|struct
name|plex
modifier|*
name|plex
parameter_list|)
block|{
name|struct
name|sd
modifier|*
name|sd
decl_stmt|;
comment|/* point to subdisk */
name|struct
name|volume
modifier|*
name|vol
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|buf
modifier|*
name|ubp
decl_stmt|;
comment|/* user (high level) buffer header */
name|vol
operator|=
operator|&
name|VOL
index|[
name|rqe
operator|->
name|rqg
operator|->
name|rq
operator|->
name|volplex
operator|.
name|volno
index|]
expr_stmt|;
name|sd
operator|=
operator|&
name|SD
index|[
name|rqe
operator|->
name|sdno
index|]
expr_stmt|;
comment|/* point to subdisk */
name|bp
operator|=
operator|&
name|rqe
operator|->
name|b
expr_stmt|;
name|ubp
operator|=
name|rqe
operator|->
name|rqg
operator|->
name|rq
operator|->
name|bp
expr_stmt|;
comment|/* pointer to user buffer header */
comment|/* Initialize the buf struct */
name|bp
operator|->
name|b_flags
operator|=
name|ubp
operator|->
name|b_flags
operator|&
operator|(
name|B_NOCACHE
operator||
name|B_READ
operator||
name|B_ASYNC
operator|)
expr_stmt|;
comment|/* copy these flags from user bp */
name|bp
operator|->
name|b_flags
operator||=
name|B_CALL
operator||
name|B_BUSY
expr_stmt|;
comment|/* inform us when it's done */
name|bp
operator|->
name|b_iodone
operator|=
name|complete_rqe
expr_stmt|;
comment|/* by calling us here */
comment|/*      * You'd think that we wouldn't need to even      * build the request buffer for a dead subdisk,      * but in some cases we need information like      * the user buffer address.  Err on the side of      * generosity and supply what we can.  That      * obviously doesn't include drive information      * when the drive is dead.      */
if|if
condition|(
operator|(
name|rqe
operator|->
name|flags
operator|&
name|XFR_BAD_SUBDISK
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* subdisk is accessible, */
name|bp
operator|->
name|b_dev
operator|=
name|DRIVE
index|[
name|rqe
operator|->
name|driveno
index|]
operator|.
name|dev
expr_stmt|;
comment|/* drive device */
name|bp
operator|->
name|b_vp
operator|=
name|DRIVE
index|[
name|rqe
operator|->
name|driveno
index|]
operator|.
name|vp
expr_stmt|;
comment|/* drive vnode */
block|}
name|bp
operator|->
name|b_blkno
operator|=
name|rqe
operator|->
name|sdoffset
operator|+
name|sd
operator|->
name|driveoffset
expr_stmt|;
comment|/* start address */
name|bp
operator|->
name|b_bcount
operator|=
name|rqe
operator|->
name|buflen
operator|<<
name|DEV_BSHIFT
expr_stmt|;
comment|/* number of bytes to transfer */
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
comment|/* and it's still all waiting */
name|bp
operator|->
name|b_bufsize
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
comment|/* and buffer size */
name|bp
operator|->
name|b_rcred
operator|=
name|FSCRED
expr_stmt|;
comment|/* we have the file system credentials */
name|bp
operator|->
name|b_wcred
operator|=
name|FSCRED
expr_stmt|;
comment|/* we have the file system credentials */
if|if
condition|(
name|rqe
operator|->
name|flags
operator|&
name|XFR_MALLOCED
condition|)
block|{
comment|/* this operation requires a malloced buffer */
name|bp
operator|->
name|b_data
operator|=
name|Malloc
argument_list|(
name|bp
operator|->
name|b_bcount
argument_list|)
expr_stmt|;
comment|/* get a buffer to put it in */
if|if
condition|(
name|bp
operator|->
name|b_data
operator|==
name|NULL
condition|)
block|{
comment|/* failed */
name|abortrequest
argument_list|(
name|rqe
operator|->
name|rqg
operator|->
name|rq
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
return|return
name|REQUEST_ENOMEM
return|;
comment|/* no memory */
block|}
block|}
else|else
comment|/* 	 * Point directly to user buffer data.  This means 	 * that we don't need to do anything when we have 	 * finished the transfer 	 */
name|bp
operator|->
name|b_data
operator|=
name|ubp
operator|->
name|b_data
operator|+
name|rqe
operator|->
name|useroffset
operator|*
name|DEV_BSIZE
expr_stmt|;
comment|/*      * On a recovery read, we perform an XOR of      * all blocks to the user buffer.  To make      * this work, we first clean out the buffer      */
if|if
condition|(
operator|(
name|rqe
operator|->
name|flags
operator|&
operator|(
name|XFR_RECOVERY_READ
operator||
name|XFR_BAD_SUBDISK
operator|)
operator|)
operator|==
operator|(
name|XFR_RECOVERY_READ
operator||
name|XFR_BAD_SUBDISK
operator|)
condition|)
block|{
comment|/* bad subdisk of a recovery read */
name|int
name|length
init|=
name|rqe
operator|->
name|grouplen
operator|<<
name|DEV_BSHIFT
decl_stmt|;
comment|/* and count involved */
name|char
modifier|*
name|data
init|=
operator|(
name|char
operator|*
operator|)
operator|&
name|rqe
operator|->
name|b
operator|.
name|b_data
index|[
name|rqe
operator|->
name|groupoffset
operator|<<
name|DEV_BSHIFT
index|]
decl_stmt|;
comment|/* destination */
name|bzero
argument_list|(
name|data
argument_list|,
name|length
argument_list|)
expr_stmt|;
comment|/* clean it out */
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Abort a request: free resources and complete the  * user request with the specified error  */
end_comment

begin_function
name|int
name|abortrequest
parameter_list|(
name|struct
name|request
modifier|*
name|rq
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|buf
modifier|*
name|bp
init|=
name|rq
operator|->
name|bp
decl_stmt|;
comment|/* user buffer */
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|error
expr_stmt|;
name|freerq
argument_list|(
name|rq
argument_list|)
expr_stmt|;
comment|/* free everything we're doing */
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
comment|/* and give up */
block|}
end_function

begin_comment
comment|/*  * Check that our transfer will cover the  * complete address space of the user request.  *  * Return 1 if it can, otherwise 0  */
end_comment

begin_function
name|int
name|check_range_covered
parameter_list|(
name|struct
name|request
modifier|*
name|rq
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Perform I/O on a subdisk */
end_comment

begin_function
name|void
name|sdio
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
comment|/* spl */
name|struct
name|sd
modifier|*
name|sd
decl_stmt|;
name|struct
name|sdbuf
modifier|*
name|sbp
decl_stmt|;
name|daddr_t
name|endoffset
decl_stmt|;
name|struct
name|drive
modifier|*
name|drive
decl_stmt|;
name|sd
operator|=
operator|&
name|SD
index|[
name|Sdno
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
expr_stmt|;
comment|/* point to the subdisk */
name|drive
operator|=
operator|&
name|DRIVE
index|[
name|sd
operator|->
name|driveno
index|]
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|state
operator|<
name|sd_empty
condition|)
block|{
comment|/* nothing to talk to, */
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_BUSY
condition|)
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Get a buffer */
name|sbp
operator|=
operator|(
expr|struct
name|sdbuf
operator|*
operator|)
name|Malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sdbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbp
operator|==
name|NULL
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|ENOMEM
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
name|bzero
argument_list|(
name|sbp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sdbuf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* start with nothing */
name|sbp
operator|->
name|b
operator|.
name|b_flags
operator|=
name|bp
operator|->
name|b_flags
operator||
name|B_CALL
expr_stmt|;
comment|/* inform us when it's done */
name|sbp
operator|->
name|b
operator|.
name|b_bufsize
operator|=
name|bp
operator|->
name|b_bufsize
expr_stmt|;
comment|/* buffer size */
name|sbp
operator|->
name|b
operator|.
name|b_bcount
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
comment|/* number of bytes to transfer */
name|sbp
operator|->
name|b
operator|.
name|b_resid
operator|=
name|bp
operator|->
name|b_resid
expr_stmt|;
comment|/* and amount waiting */
name|sbp
operator|->
name|b
operator|.
name|b_dev
operator|=
name|DRIVE
index|[
name|sd
operator|->
name|driveno
index|]
operator|.
name|dev
expr_stmt|;
comment|/* device */
name|sbp
operator|->
name|b
operator|.
name|b_data
operator|=
name|bp
operator|->
name|b_data
expr_stmt|;
comment|/* data buffer */
name|sbp
operator|->
name|b
operator|.
name|b_blkno
operator|=
name|bp
operator|->
name|b_blkno
operator|+
name|sd
operator|->
name|driveoffset
expr_stmt|;
name|sbp
operator|->
name|b
operator|.
name|b_iodone
operator|=
name|sdio_done
expr_stmt|;
comment|/* come here on completion */
name|sbp
operator|->
name|b
operator|.
name|b_vp
operator|=
name|DRIVE
index|[
name|sd
operator|->
name|driveno
index|]
operator|.
name|vp
expr_stmt|;
comment|/* vnode */
name|sbp
operator|->
name|bp
operator|=
name|bp
expr_stmt|;
comment|/* note the address of the original header */
name|sbp
operator|->
name|sdno
operator|=
name|sd
operator|->
name|sdno
expr_stmt|;
comment|/* note for statistics */
name|sbp
operator|->
name|driveno
operator|=
name|sd
operator|->
name|driveno
expr_stmt|;
name|endoffset
operator|=
name|bp
operator|->
name|b_blkno
operator|+
name|sbp
operator|->
name|b
operator|.
name|b_bcount
operator|/
name|DEV_BSIZE
expr_stmt|;
comment|/* final sector offset */
if|if
condition|(
name|endoffset
operator|>
name|sd
operator|->
name|sectors
condition|)
block|{
comment|/* beyond the end */
name|sbp
operator|->
name|b
operator|.
name|b_bcount
operator|-=
operator|(
name|endoffset
operator|-
name|sd
operator|->
name|sectors
operator|)
operator|*
name|DEV_BSIZE
expr_stmt|;
comment|/* trim */
if|if
condition|(
name|sbp
operator|->
name|b
operator|.
name|b_bcount
operator|<=
literal|0
condition|)
block|{
comment|/* nothing to transfer */
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
comment|/* nothing transferred */
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|Free
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
operator|(
name|sbp
operator|->
name|b
operator|.
name|b_flags
operator|&
name|B_READ
operator|)
operator|==
literal|0
condition|)
comment|/* write */
name|sbp
operator|->
name|b
operator|.
name|b_vp
operator|->
name|v_numoutput
operator|++
expr_stmt|;
comment|/* one more output going */
if|#
directive|if
name|VINUMDEBUG
if|if
condition|(
name|debug
operator|&
name|DEBUG_ADDRESSES
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"  %s dev %d.%d, sd %d, offset 0x%x, devoffset 0x%x, length %ld\n"
argument_list|,
name|sbp
operator|->
name|b
operator|.
name|b_flags
operator|&
name|B_READ
condition|?
literal|"Read"
else|:
literal|"Write"
argument_list|,
name|major
argument_list|(
name|sbp
operator|->
name|b
operator|.
name|b_dev
argument_list|)
argument_list|,
name|minor
argument_list|(
name|sbp
operator|->
name|b
operator|.
name|b_dev
argument_list|)
argument_list|,
name|sbp
operator|->
name|sdno
argument_list|,
call|(
name|u_int
call|)
argument_list|(
name|sbp
operator|->
name|b
operator|.
name|b_blkno
operator|-
name|SD
index|[
name|sbp
operator|->
name|sdno
index|]
operator|.
name|driveoffset
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|sbp
operator|->
name|b
operator|.
name|b_blkno
argument_list|,
name|sbp
operator|->
name|b
operator|.
name|b_bcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|&
name|DEBUG_NUMOUTPUT
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"  vinumstart sd %d numoutput %ld\n"
argument_list|,
name|sbp
operator|->
name|sdno
argument_list|,
name|sbp
operator|->
name|b
operator|.
name|b_vp
operator|->
name|v_numoutput
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|#
directive|if
name|VINUMDEBUG
if|if
condition|(
name|debug
operator|&
name|DEBUG_LASTREQS
condition|)
name|logrq
argument_list|(
name|loginfo_sdiol
argument_list|,
operator|(
expr|union
name|rqinfou
operator|)
operator|(
expr|struct
name|buf
operator|*
operator|)
name|sbp
argument_list|,
operator|(
expr|struct
name|buf
operator|*
operator|)
name|sbp
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
operator|*
name|bdevsw
index|[
name|major
argument_list|(
name|sbp
operator|->
name|b
operator|.
name|b_dev
argument_list|)
index|]
operator|->
name|d_strategy
operator|)
operator|(
operator|&
name|sbp
operator|->
name|b
operator|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Simplified version of bounds_check_with_label  * Determine the size of the transfer, and make sure it is  * within the boundaries of the partition. Adjust transfer  * if needed, and signal errors or early completion.  *  * Volumes are simpler than disk slices: they only contain  * one component (though we call them a, b and c to make  * system utilities happy), and they always take up the  * complete space of the "partition".  *  * I'm still not happy with this: why should the label be  * protected?  If it weren't so damned difficult to write  * one in the first pleace (because it's protected), it wouldn't  * be a problem.  */
end_comment

begin_function
name|int
name|vinum_bounds_check
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|struct
name|volume
modifier|*
name|vol
parameter_list|)
block|{
name|int
name|maxsize
init|=
name|vol
operator|->
name|size
decl_stmt|;
comment|/* size of the partition (sectors) */
name|int
name|size
init|=
operator|(
name|bp
operator|->
name|b_bcount
operator|+
name|DEV_BSIZE
operator|-
literal|1
operator|)
operator|>>
name|DEV_BSHIFT
decl_stmt|;
comment|/* size of this request (sectors) */
comment|/* Would this transfer overwrite the disk label? */
if|if
condition|(
name|bp
operator|->
name|b_blkno
operator|<=
name|LABELSECTOR
comment|/* starts before or at the label */
if|#
directive|if
name|LABELSECTOR
operator|!=
literal|0
operator|&&
name|bp
operator|->
name|b_blkno
operator|+
name|size
operator|>
name|LABELSECTOR
comment|/* and finishes after */
endif|#
directive|endif
operator|&&
operator|(
operator|!
operator|(
name|vol
operator|->
name|flags
operator|&
name|VF_RAW
operator|)
operator|)
comment|/* and it's not raw */
operator|&&
name|major
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
operator|==
name|BDEV_MAJOR
comment|/* and it's the block device */
operator|&&
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|==
literal|0
comment|/* and it's a write */
operator|&&
operator|(
operator|!
name|vol
operator|->
name|flags
operator|&
operator|(
name|VF_WLABEL
operator||
name|VF_LABELLING
operator|)
operator|)
condition|)
block|{
comment|/* and we're not allowed to write the label */
name|bp
operator|->
name|b_error
operator|=
name|EROFS
expr_stmt|;
comment|/* read-only */
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|size
operator|==
literal|0
condition|)
comment|/* no transfer specified, */
return|return
literal|0
return|;
comment|/* treat as EOF */
comment|/* beyond partition? */
if|if
condition|(
name|bp
operator|->
name|b_blkno
operator|<
literal|0
comment|/* negative start */
operator|||
name|bp
operator|->
name|b_blkno
operator|+
name|size
operator|>
name|maxsize
condition|)
block|{
comment|/* or goes beyond the end of the partition */
comment|/* if exactly at end of disk, return an EOF */
if|if
condition|(
name|bp
operator|->
name|b_blkno
operator|==
name|maxsize
condition|)
block|{
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* or truncate if part of it fits */
name|size
operator|=
name|maxsize
operator|-
name|bp
operator|->
name|b_blkno
expr_stmt|;
if|if
condition|(
name|size
operator|<=
literal|0
condition|)
block|{
comment|/* nothing to transfer */
name|bp
operator|->
name|b_error
operator|=
name|EINVAL
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|bp
operator|->
name|b_bcount
operator|=
name|size
operator|<<
name|DEV_BSHIFT
expr_stmt|;
block|}
name|bp
operator|->
name|b_pblkno
operator|=
name|bp
operator|->
name|b_blkno
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a request group and hook  * it in in the list for rq  */
end_comment

begin_function
name|struct
name|rqgroup
modifier|*
name|allocrqg
parameter_list|(
name|struct
name|request
modifier|*
name|rq
parameter_list|,
name|int
name|elements
parameter_list|)
block|{
name|struct
name|rqgroup
modifier|*
name|rqg
decl_stmt|;
comment|/* the one we're going to allocate */
name|int
name|size
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|rqgroup
argument_list|)
operator|+
name|elements
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|rqelement
argument_list|)
decl_stmt|;
name|rqg
operator|=
operator|(
expr|struct
name|rqgroup
operator|*
operator|)
name|Malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|rqg
operator|!=
name|NULL
condition|)
block|{
comment|/* malloc OK, */
if|if
condition|(
name|rq
operator|->
name|rqg
condition|)
comment|/* we already have requests */
name|rq
operator|->
name|lrqg
operator|->
name|next
operator|=
name|rqg
expr_stmt|;
comment|/* hang it off the end */
else|else
comment|/* first request */
name|rq
operator|->
name|rqg
operator|=
name|rqg
expr_stmt|;
comment|/* at the start */
name|rq
operator|->
name|lrqg
operator|=
name|rqg
expr_stmt|;
comment|/* this one is the last in the list */
name|bzero
argument_list|(
name|rqg
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* no old junk */
name|rqg
operator|->
name|rq
operator|=
name|rq
expr_stmt|;
comment|/* point back to the parent request */
name|rqg
operator|->
name|count
operator|=
name|elements
expr_stmt|;
comment|/* number of requests in the group */
block|}
return|return
name|rqg
return|;
block|}
end_function

begin_comment
comment|/*  * Deallocate a request group out of a chain.  We do  * this by linear search: the chain is short, this  * almost never happens, and currently it can only  * happen to the first member of the chain.  */
end_comment

begin_function
name|void
name|deallocrqg
parameter_list|(
name|struct
name|rqgroup
modifier|*
name|rqg
parameter_list|)
block|{
name|struct
name|rqgroup
modifier|*
name|rqgc
init|=
name|rqg
operator|->
name|rq
operator|->
name|rqg
decl_stmt|;
comment|/* point to the request chain */
if|if
condition|(
name|rqg
operator|->
name|lock
condition|)
comment|/* got a lock? */
name|unlockrange
argument_list|(
name|rqg
operator|->
name|plexno
argument_list|,
name|rqg
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* yes, free it */
if|if
condition|(
name|rqgc
operator|==
name|rqg
condition|)
comment|/* we're first in line */
name|rqg
operator|->
name|rq
operator|->
name|rqg
operator|=
name|rqg
operator|->
name|next
expr_stmt|;
comment|/* unhook ourselves */
else|else
block|{
while|while
condition|(
operator|(
name|rqgc
operator|->
name|next
operator|!=
name|NULL
operator|)
comment|/* find the group */
operator|&&
operator|(
name|rqgc
operator|->
name|next
operator|!=
name|rqg
operator|)
condition|)
name|rqgc
operator|=
name|rqgc
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|rqgc
operator|->
name|next
operator|==
name|NULL
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"vinum deallocrqg: rqg %p not found in request %p\n"
argument_list|,
name|rqg
operator|->
name|rq
argument_list|,
name|rqg
argument_list|)
expr_stmt|;
else|else
name|rqgc
operator|->
name|next
operator|=
name|rqg
operator|->
name|next
expr_stmt|;
comment|/* make the chain jump over us */
block|}
name|Free
argument_list|(
name|rqg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Character device interface */
end_comment

begin_function
name|int
name|vinumread
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
return|return
operator|(
name|physio
argument_list|(
name|vinumstrategy
argument_list|,
name|NULL
argument_list|,
name|dev
argument_list|,
literal|1
argument_list|,
name|minphys
argument_list|,
name|uio
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vinumwrite
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
return|return
operator|(
name|physio
argument_list|(
name|vinumstrategy
argument_list|,
name|NULL
argument_list|,
name|dev
argument_list|,
literal|0
argument_list|,
name|minphys
argument_list|,
name|uio
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

