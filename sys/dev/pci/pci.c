begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1997, Stefan Esser<se@freebsd.org>  * Copyright (c) 2000, Michael Smith<msmith@freebsd.org>  * Copyright (c) 2000, BSDi  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_bus.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
operator|||
name|defined
argument_list|(
name|__powerpc__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<machine/intr_machdep.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/pciio.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pci_private.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PCI_IOV
end_ifdef

begin_include
include|#
directive|include
file|<sys/nv.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pci_iov_private.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/usb/controller/xhcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/controller/ehcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/controller/ohcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/controller/uhcireg.h>
end_include

begin_include
include|#
directive|include
file|"pcib_if.h"
end_include

begin_include
include|#
directive|include
file|"pci_if.h"
end_include

begin_define
define|#
directive|define
name|PCIR_IS_BIOS
parameter_list|(
name|cfg
parameter_list|,
name|reg
parameter_list|)
define|\
value|(((cfg)->hdrtype == PCIM_HDRTYPE_NORMAL&& reg == PCIR_BIOS) ||	\ 	 ((cfg)->hdrtype == PCIM_HDRTYPE_BRIDGE&& reg == PCIR_BIOS_1))
end_define

begin_function_decl
specifier|static
name|int
name|pci_has_quirk
parameter_list|(
name|uint32_t
name|devid
parameter_list|,
name|int
name|quirk
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|pci_addr_t
name|pci_mapbase
parameter_list|(
name|uint64_t
name|mapreg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|pci_maptype
parameter_list|(
name|uint64_t
name|mapreg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_maprange
parameter_list|(
name|uint64_t
name|mapreg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|pci_addr_t
name|pci_rombase
parameter_list|(
name|uint64_t
name|mapreg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_romsize
parameter_list|(
name|uint64_t
name|testval
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pci_fixancient
parameter_list|(
name|pcicfgregs
modifier|*
name|cfg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_printf
parameter_list|(
name|pcicfgregs
modifier|*
name|cfg
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_porten
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_memen
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pci_assign_interrupt
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|int
name|force_route
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_add_map
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|int
name|reg
parameter_list|,
name|struct
name|resource_list
modifier|*
name|rl
parameter_list|,
name|int
name|force
parameter_list|,
name|int
name|prefetch
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pci_load_vendor_data
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_describe_parse_line
parameter_list|(
name|char
modifier|*
modifier|*
name|ptr
parameter_list|,
name|int
modifier|*
name|vendor
parameter_list|,
name|int
modifier|*
name|device
parameter_list|,
name|char
modifier|*
modifier|*
name|desc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|pci_describe_device
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|what
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pci_hdrtypedata
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|s
parameter_list|,
name|int
name|f
parameter_list|,
name|pcicfgregs
modifier|*
name|cfg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pci_read_cap
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|pcicfgregs
modifier|*
name|cfg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_read_vpd_reg
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|pcicfgregs
modifier|*
name|cfg
parameter_list|,
name|int
name|reg
parameter_list|,
name|uint32_t
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int		pci_write_vpd_reg(device_t pcib, pcicfgregs *cfg, 			    int reg, uint32_t data);
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|pci_read_vpd
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|pcicfgregs
modifier|*
name|cfg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pci_mask_msix
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pci_unmask_msix
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_msi_blacklisted
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_msix_blacklisted
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pci_resume_msi
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pci_resume_msix
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_remap_intr_method
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|u_int
name|irq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_get_id_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|enum
name|pci_id_type
name|type
parameter_list|,
name|uintptr_t
modifier|*
name|rid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|pci_devinfo
modifier|*
name|pci_fill_devinfo
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|device_t
name|bus
parameter_list|,
name|int
name|d
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|s
parameter_list|,
name|int
name|f
parameter_list|,
name|uint16_t
name|vid
parameter_list|,
name|uint16_t
name|did
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|pci_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|pci_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|pci_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|pci_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bus_generic_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|bus_generic_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|pci_resume
argument_list|)
block|,
comment|/* Bus interface */
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|pci_print_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_probe_nomatch
argument_list|,
name|pci_probe_nomatch
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_read_ivar
argument_list|,
name|pci_read_ivar
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_write_ivar
argument_list|,
name|pci_write_ivar
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_driver_added
argument_list|,
name|pci_driver_added
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_setup_intr
argument_list|,
name|pci_setup_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_teardown_intr
argument_list|,
name|pci_teardown_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_get_dma_tag
argument_list|,
name|pci_get_dma_tag
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_get_resource_list
argument_list|,
name|pci_get_resource_list
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_set_resource
argument_list|,
name|bus_generic_rl_set_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_get_resource
argument_list|,
name|bus_generic_rl_get_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_delete_resource
argument_list|,
name|pci_delete_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_alloc_resource
argument_list|,
name|pci_alloc_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_adjust_resource
argument_list|,
name|bus_generic_adjust_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_release_resource
argument_list|,
name|pci_release_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_activate_resource
argument_list|,
name|pci_activate_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_deactivate_resource
argument_list|,
name|pci_deactivate_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_child_deleted
argument_list|,
name|pci_child_deleted
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_child_detached
argument_list|,
name|pci_child_detached
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_child_pnpinfo_str
argument_list|,
name|pci_child_pnpinfo_str_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_child_location_str
argument_list|,
name|pci_child_location_str_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_remap_intr
argument_list|,
name|pci_remap_intr_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_suspend_child
argument_list|,
name|pci_suspend_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_resume_child
argument_list|,
name|pci_resume_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_rescan
argument_list|,
name|pci_rescan_method
argument_list|)
block|,
comment|/* PCI interface */
name|DEVMETHOD
argument_list|(
name|pci_read_config
argument_list|,
name|pci_read_config_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_write_config
argument_list|,
name|pci_write_config_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_enable_busmaster
argument_list|,
name|pci_enable_busmaster_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_disable_busmaster
argument_list|,
name|pci_disable_busmaster_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_enable_io
argument_list|,
name|pci_enable_io_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_disable_io
argument_list|,
name|pci_disable_io_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_get_vpd_ident
argument_list|,
name|pci_get_vpd_ident_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_get_vpd_readonly
argument_list|,
name|pci_get_vpd_readonly_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_get_powerstate
argument_list|,
name|pci_get_powerstate_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_set_powerstate
argument_list|,
name|pci_set_powerstate_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_assign_interrupt
argument_list|,
name|pci_assign_interrupt_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_find_cap
argument_list|,
name|pci_find_cap_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_find_extcap
argument_list|,
name|pci_find_extcap_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_find_htcap
argument_list|,
name|pci_find_htcap_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_alloc_msi
argument_list|,
name|pci_alloc_msi_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_alloc_msix
argument_list|,
name|pci_alloc_msix_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_enable_msi
argument_list|,
name|pci_enable_msi_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_enable_msix
argument_list|,
name|pci_enable_msix_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_disable_msi
argument_list|,
name|pci_disable_msi_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_remap_msix
argument_list|,
name|pci_remap_msix_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_release_msi
argument_list|,
name|pci_release_msi_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_msi_count
argument_list|,
name|pci_msi_count_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_msix_count
argument_list|,
name|pci_msix_count_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_msix_pba_bar
argument_list|,
name|pci_msix_pba_bar_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_msix_table_bar
argument_list|,
name|pci_msix_table_bar_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_get_id
argument_list|,
name|pci_get_id_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_alloc_devinfo
argument_list|,
name|pci_alloc_devinfo_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_child_added
argument_list|,
name|pci_child_added_method
argument_list|)
block|,
ifdef|#
directive|ifdef
name|PCI_IOV
name|DEVMETHOD
argument_list|(
name|pci_iov_attach
argument_list|,
name|pci_iov_attach_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_iov_detach
argument_list|,
name|pci_iov_detach_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_create_iov_child
argument_list|,
name|pci_create_iov_child_method
argument_list|)
block|,
endif|#
directive|endif
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DEFINE_CLASS_0
argument_list|(
name|pci
argument_list|,
name|pci_driver
argument_list|,
name|pci_methods
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pci_softc
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|pci_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|pci
argument_list|,
name|pcib
argument_list|,
name|pci_driver
argument_list|,
name|pci_devclass
argument_list|,
name|pci_modevent
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|pci
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pci_vendordata
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|pci_vendordata_size
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|pci_quirk
block|{
name|uint32_t
name|devid
decl_stmt|;
comment|/* Vendor/device of the card */
name|int
name|type
decl_stmt|;
define|#
directive|define
name|PCI_QUIRK_MAP_REG
value|1
comment|/* PCI map register in weird place */
define|#
directive|define
name|PCI_QUIRK_DISABLE_MSI
value|2
comment|/* Neither MSI nor MSI-X work */
define|#
directive|define
name|PCI_QUIRK_ENABLE_MSI_VM
value|3
comment|/* Older chipset in VM where MSI works */
define|#
directive|define
name|PCI_QUIRK_UNMAP_REG
value|4
comment|/* Ignore PCI map register */
define|#
directive|define
name|PCI_QUIRK_DISABLE_MSIX
value|5
comment|/* MSI-X doesn't work */
define|#
directive|define
name|PCI_QUIRK_MSI_INTX_BUG
value|6
comment|/* PCIM_CMD_INTxDIS disables MSI */
name|int
name|arg1
decl_stmt|;
name|int
name|arg2
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|pci_quirk
name|pci_quirks
index|[]
init|=
block|{
comment|/* The Intel 82371AB and 82443MX have a map register at offset 0x90. */
block|{
literal|0x71138086
block|,
name|PCI_QUIRK_MAP_REG
block|,
literal|0x90
block|,
literal|0
block|}
block|,
block|{
literal|0x719b8086
block|,
name|PCI_QUIRK_MAP_REG
block|,
literal|0x90
block|,
literal|0
block|}
block|,
comment|/* As does the Serverworks OSB4 (the SMBus mapping register) */
block|{
literal|0x02001166
block|,
name|PCI_QUIRK_MAP_REG
block|,
literal|0x90
block|,
literal|0
block|}
block|,
comment|/* 	 * MSI doesn't work with the ServerWorks CNB20-HE Host Bridge 	 * or the CMIC-SL (AKA ServerWorks GC_LE). 	 */
block|{
literal|0x00141166
block|,
name|PCI_QUIRK_DISABLE_MSI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0x00171166
block|,
name|PCI_QUIRK_DISABLE_MSI
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* 	 * MSI doesn't work on earlier Intel chipsets including 	 * E7500, E7501, E7505, 845, 865, 875/E7210, and 855. 	 */
block|{
literal|0x25408086
block|,
name|PCI_QUIRK_DISABLE_MSI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0x254c8086
block|,
name|PCI_QUIRK_DISABLE_MSI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0x25508086
block|,
name|PCI_QUIRK_DISABLE_MSI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0x25608086
block|,
name|PCI_QUIRK_DISABLE_MSI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0x25708086
block|,
name|PCI_QUIRK_DISABLE_MSI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0x25788086
block|,
name|PCI_QUIRK_DISABLE_MSI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0x35808086
block|,
name|PCI_QUIRK_DISABLE_MSI
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* 	 * MSI doesn't work with devices behind the AMD 8131 HT-PCIX 	 * bridge. 	 */
block|{
literal|0x74501022
block|,
name|PCI_QUIRK_DISABLE_MSI
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* 	 * MSI-X allocation doesn't work properly for devices passed through 	 * by VMware up to at least ESXi 5.1. 	 */
block|{
literal|0x079015ad
block|,
name|PCI_QUIRK_DISABLE_MSIX
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* PCI/PCI-X */
block|{
literal|0x07a015ad
block|,
name|PCI_QUIRK_DISABLE_MSIX
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* PCIe */
comment|/* 	 * Some virtualization environments emulate an older chipset 	 * but support MSI just fine.  QEMU uses the Intel 82440. 	 */
block|{
literal|0x12378086
block|,
name|PCI_QUIRK_ENABLE_MSI_VM
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* 	 * HPET MMIO base address may appear in Bar1 for AMD SB600 SMBus 	 * controller depending on SoftPciRst register (PM_IO 0x55 [7]). 	 * It prevents us from attaching hpet(4) when the bit is unset. 	 * Note this quirk only affects SB600 revision A13 and earlier. 	 * For SB600 A21 and later, firmware must set the bit to hide it. 	 * For SB700 and later, it is unused and hardcoded to zero. 	 */
block|{
literal|0x43851002
block|,
name|PCI_QUIRK_UNMAP_REG
block|,
literal|0x14
block|,
literal|0
block|}
block|,
comment|/* 	 * Atheros AR8161/AR8162/E2200/E2400/E2500 Ethernet controllers have 	 * a bug that MSI interrupt does not assert if PCIM_CMD_INTxDIS bit 	 * of the command register is set. 	 */
block|{
literal|0x10911969
block|,
name|PCI_QUIRK_MSI_INTX_BUG
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0xE0911969
block|,
name|PCI_QUIRK_MSI_INTX_BUG
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0xE0A11969
block|,
name|PCI_QUIRK_MSI_INTX_BUG
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0xE0B11969
block|,
name|PCI_QUIRK_MSI_INTX_BUG
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0x10901969
block|,
name|PCI_QUIRK_MSI_INTX_BUG
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* 	 * Broadcom BCM5714(S)/BCM5715(S)/BCM5780(S) Ethernet MACs don't 	 * issue MSI interrupts with PCIM_CMD_INTxDIS set either. 	 */
block|{
literal|0x166814e4
block|,
name|PCI_QUIRK_MSI_INTX_BUG
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* BCM5714 */
block|{
literal|0x166914e4
block|,
name|PCI_QUIRK_MSI_INTX_BUG
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* BCM5714S */
block|{
literal|0x166a14e4
block|,
name|PCI_QUIRK_MSI_INTX_BUG
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* BCM5780 */
block|{
literal|0x166b14e4
block|,
name|PCI_QUIRK_MSI_INTX_BUG
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* BCM5780S */
block|{
literal|0x167814e4
block|,
name|PCI_QUIRK_MSI_INTX_BUG
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* BCM5715 */
block|{
literal|0x167914e4
block|,
name|PCI_QUIRK_MSI_INTX_BUG
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* BCM5715S */
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* map register information */
end_comment

begin_define
define|#
directive|define
name|PCI_MAPMEM
value|0x01
end_define

begin_comment
comment|/* memory map */
end_comment

begin_define
define|#
directive|define
name|PCI_MAPMEMP
value|0x02
end_define

begin_comment
comment|/* prefetchable memory map */
end_comment

begin_define
define|#
directive|define
name|PCI_MAPPORT
value|0x04
end_define

begin_comment
comment|/* port map */
end_comment

begin_decl_stmt
name|struct
name|devlist
name|pci_devq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|pci_generation
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|pci_numdevs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pcie_chipset
decl_stmt|,
name|pcix_chipset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sysctl vars */
end_comment

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|pci
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"PCI bus tuning parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|pci_enable_io_modes
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_pci
argument_list|,
name|OID_AUTO
argument_list|,
name|enable_io_modes
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|pci_enable_io_modes
argument_list|,
literal|1
argument_list|,
literal|"Enable I/O and memory bits in the config register.  Some BIOSes do not\n\ enable these bits correctly.  We'd like to do this all the time, but there\n\ are some peripherals that this causes problems with."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|pci_do_realloc_bars
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_pci
argument_list|,
name|OID_AUTO
argument_list|,
name|realloc_bars
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|pci_do_realloc_bars
argument_list|,
literal|0
argument_list|,
literal|"Attempt to allocate a new range for any BARs whose original "
literal|"firmware-assigned ranges fail to allocate during the initial device scan."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|pci_do_power_nodriver
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_pci
argument_list|,
name|OID_AUTO
argument_list|,
name|do_power_nodriver
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|pci_do_power_nodriver
argument_list|,
literal|0
argument_list|,
literal|"Place a function into D3 state when no driver attaches to it.  0 means\n\ disable.  1 means conservatively place devices into D3 state.  2 means\n\ aggressively place devices into D3 state.  3 means put absolutely everything\n\ in D3 state."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|pci_do_power_resume
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_pci
argument_list|,
name|OID_AUTO
argument_list|,
name|do_power_resume
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|pci_do_power_resume
argument_list|,
literal|1
argument_list|,
literal|"Transition from D3 -> D0 on resume."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|pci_do_power_suspend
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_pci
argument_list|,
name|OID_AUTO
argument_list|,
name|do_power_suspend
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|pci_do_power_suspend
argument_list|,
literal|1
argument_list|,
literal|"Transition from D0 -> D3 on suspend."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|pci_do_msi
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_pci
argument_list|,
name|OID_AUTO
argument_list|,
name|enable_msi
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|pci_do_msi
argument_list|,
literal|1
argument_list|,
literal|"Enable support for MSI interrupts"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|pci_do_msix
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_pci
argument_list|,
name|OID_AUTO
argument_list|,
name|enable_msix
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|pci_do_msix
argument_list|,
literal|1
argument_list|,
literal|"Enable support for MSI-X interrupts"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|pci_msix_rewrite_table
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_pci
argument_list|,
name|OID_AUTO
argument_list|,
name|msix_rewrite_table
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|pci_msix_rewrite_table
argument_list|,
literal|0
argument_list|,
literal|"Rewrite entire MSI-X table when updating MSI-X entries"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|pci_honor_msi_blacklist
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_pci
argument_list|,
name|OID_AUTO
argument_list|,
name|honor_msi_blacklist
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|pci_honor_msi_blacklist
argument_list|,
literal|1
argument_list|,
literal|"Honor chipset blacklist for MSI/MSI-X"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|int
name|pci_usb_takeover
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|int
name|pci_usb_takeover
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_pci
argument_list|,
name|OID_AUTO
argument_list|,
name|usb_early_takeover
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|pci_usb_takeover
argument_list|,
literal|1
argument_list|,
literal|"Enable early takeover of USB controllers.\n\ Disable this if you depend on BIOS emulation of USB devices, that is\n\ you use USB devices (like keyboard or mouse) but do not load USB drivers"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|pci_clear_bars
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_pci
argument_list|,
name|OID_AUTO
argument_list|,
name|clear_bars
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|pci_clear_bars
argument_list|,
literal|0
argument_list|,
literal|"Ignore firmware-assigned resources for BARs."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEW_PCIB
argument_list|)
operator|&&
name|defined
argument_list|(
name|PCI_RES_BUS
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|int
name|pci_clear_buses
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_pci
argument_list|,
name|OID_AUTO
argument_list|,
name|clear_buses
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|pci_clear_buses
argument_list|,
literal|0
argument_list|,
literal|"Ignore firmware-assigned bus numbers."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|pci_enable_ari
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_pci
argument_list|,
name|OID_AUTO
argument_list|,
name|enable_ari
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|pci_enable_ari
argument_list|,
literal|0
argument_list|,
literal|"Enable support for PCIe Alternative RID Interpretation"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|pci_has_quirk
parameter_list|(
name|uint32_t
name|devid
parameter_list|,
name|int
name|quirk
parameter_list|)
block|{
specifier|const
name|struct
name|pci_quirk
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|q
operator|=
operator|&
name|pci_quirks
index|[
literal|0
index|]
init|;
name|q
operator|->
name|devid
condition|;
name|q
operator|++
control|)
block|{
if|if
condition|(
name|q
operator|->
name|devid
operator|==
name|devid
operator|&&
name|q
operator|->
name|type
operator|==
name|quirk
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Find a device_t by bus/slot/function in domain 0 */
end_comment

begin_function
name|device_t
name|pci_find_bsf
parameter_list|(
name|uint8_t
name|bus
parameter_list|,
name|uint8_t
name|slot
parameter_list|,
name|uint8_t
name|func
parameter_list|)
block|{
return|return
operator|(
name|pci_find_dbsf
argument_list|(
literal|0
argument_list|,
name|bus
argument_list|,
name|slot
argument_list|,
name|func
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Find a device_t by domain/bus/slot/function */
end_comment

begin_function
name|device_t
name|pci_find_dbsf
parameter_list|(
name|uint32_t
name|domain
parameter_list|,
name|uint8_t
name|bus
parameter_list|,
name|uint8_t
name|slot
parameter_list|,
name|uint8_t
name|func
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|dinfo
argument_list|,
argument|&pci_devq
argument_list|,
argument|pci_links
argument_list|)
block|{
if|if
condition|(
operator|(
name|dinfo
operator|->
name|cfg
operator|.
name|domain
operator|==
name|domain
operator|)
operator|&&
operator|(
name|dinfo
operator|->
name|cfg
operator|.
name|bus
operator|==
name|bus
operator|)
operator|&&
operator|(
name|dinfo
operator|->
name|cfg
operator|.
name|slot
operator|==
name|slot
operator|)
operator|&&
operator|(
name|dinfo
operator|->
name|cfg
operator|.
name|func
operator|==
name|func
operator|)
condition|)
block|{
return|return
operator|(
name|dinfo
operator|->
name|cfg
operator|.
name|dev
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Find a device_t by vendor/device ID */
end_comment

begin_function
name|device_t
name|pci_find_device
parameter_list|(
name|uint16_t
name|vendor
parameter_list|,
name|uint16_t
name|device
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|dinfo
argument_list|,
argument|&pci_devq
argument_list|,
argument|pci_links
argument_list|)
block|{
if|if
condition|(
operator|(
name|dinfo
operator|->
name|cfg
operator|.
name|vendor
operator|==
name|vendor
operator|)
operator|&&
operator|(
name|dinfo
operator|->
name|cfg
operator|.
name|device
operator|==
name|device
operator|)
condition|)
block|{
return|return
operator|(
name|dinfo
operator|->
name|cfg
operator|.
name|dev
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|device_t
name|pci_find_class
parameter_list|(
name|uint8_t
name|class
parameter_list|,
name|uint8_t
name|subclass
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|dinfo
argument_list|,
argument|&pci_devq
argument_list|,
argument|pci_links
argument_list|)
block|{
if|if
condition|(
name|dinfo
operator|->
name|cfg
operator|.
name|baseclass
operator|==
name|class
operator|&&
name|dinfo
operator|->
name|cfg
operator|.
name|subclass
operator|==
name|subclass
condition|)
block|{
return|return
operator|(
name|dinfo
operator|->
name|cfg
operator|.
name|dev
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pci_printf
parameter_list|(
name|pcicfgregs
modifier|*
name|cfg
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|printf
argument_list|(
literal|"pci%d:%d:%d:%d: "
argument_list|,
name|cfg
operator|->
name|domain
argument_list|,
name|cfg
operator|->
name|bus
argument_list|,
name|cfg
operator|->
name|slot
argument_list|,
name|cfg
operator|->
name|func
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|vprintf
argument_list|(
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/* return base address of memory or port map */
end_comment

begin_function
specifier|static
name|pci_addr_t
name|pci_mapbase
parameter_list|(
name|uint64_t
name|mapreg
parameter_list|)
block|{
if|if
condition|(
name|PCI_BAR_MEM
argument_list|(
name|mapreg
argument_list|)
condition|)
return|return
operator|(
name|mapreg
operator|&
name|PCIM_BAR_MEM_BASE
operator|)
return|;
else|else
return|return
operator|(
name|mapreg
operator|&
name|PCIM_BAR_IO_BASE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* return map type of memory or port map */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|pci_maptype
parameter_list|(
name|uint64_t
name|mapreg
parameter_list|)
block|{
if|if
condition|(
name|PCI_BAR_IO
argument_list|(
name|mapreg
argument_list|)
condition|)
return|return
operator|(
literal|"I/O Port"
operator|)
return|;
if|if
condition|(
name|mapreg
operator|&
name|PCIM_BAR_MEM_PREFETCH
condition|)
return|return
operator|(
literal|"Prefetchable Memory"
operator|)
return|;
return|return
operator|(
literal|"Memory"
operator|)
return|;
block|}
end_function

begin_comment
comment|/* return log2 of map size decoded for memory or port map */
end_comment

begin_function
name|int
name|pci_mapsize
parameter_list|(
name|uint64_t
name|testval
parameter_list|)
block|{
name|int
name|ln2size
decl_stmt|;
name|testval
operator|=
name|pci_mapbase
argument_list|(
name|testval
argument_list|)
expr_stmt|;
name|ln2size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|testval
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
operator|(
name|testval
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|ln2size
operator|++
expr_stmt|;
name|testval
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ln2size
operator|)
return|;
block|}
end_function

begin_comment
comment|/* return base address of device ROM */
end_comment

begin_function
specifier|static
name|pci_addr_t
name|pci_rombase
parameter_list|(
name|uint64_t
name|mapreg
parameter_list|)
block|{
return|return
operator|(
name|mapreg
operator|&
name|PCIM_BIOS_ADDR_MASK
operator|)
return|;
block|}
end_function

begin_comment
comment|/* return log2 of map size decided for device ROM */
end_comment

begin_function
specifier|static
name|int
name|pci_romsize
parameter_list|(
name|uint64_t
name|testval
parameter_list|)
block|{
name|int
name|ln2size
decl_stmt|;
name|testval
operator|=
name|pci_rombase
argument_list|(
name|testval
argument_list|)
expr_stmt|;
name|ln2size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|testval
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
operator|(
name|testval
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|ln2size
operator|++
expr_stmt|;
name|testval
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ln2size
operator|)
return|;
block|}
end_function

begin_comment
comment|/* return log2 of address range supported by map register */
end_comment

begin_function
specifier|static
name|int
name|pci_maprange
parameter_list|(
name|uint64_t
name|mapreg
parameter_list|)
block|{
name|int
name|ln2range
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|PCI_BAR_IO
argument_list|(
name|mapreg
argument_list|)
condition|)
name|ln2range
operator|=
literal|32
expr_stmt|;
else|else
switch|switch
condition|(
name|mapreg
operator|&
name|PCIM_BAR_MEM_TYPE
condition|)
block|{
case|case
name|PCIM_BAR_MEM_32
case|:
name|ln2range
operator|=
literal|32
expr_stmt|;
break|break;
case|case
name|PCIM_BAR_MEM_1MB
case|:
name|ln2range
operator|=
literal|20
expr_stmt|;
break|break;
case|case
name|PCIM_BAR_MEM_64
case|:
name|ln2range
operator|=
literal|64
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|ln2range
operator|)
return|;
block|}
end_function

begin_comment
comment|/* adjust some values from PCI 1.0 devices to match 2.0 standards ... */
end_comment

begin_function
specifier|static
name|void
name|pci_fixancient
parameter_list|(
name|pcicfgregs
modifier|*
name|cfg
parameter_list|)
block|{
if|if
condition|(
operator|(
name|cfg
operator|->
name|hdrtype
operator|&
name|PCIM_HDRTYPE
operator|)
operator|!=
name|PCIM_HDRTYPE_NORMAL
condition|)
return|return;
comment|/* PCI to PCI bridges use header type 1 */
if|if
condition|(
name|cfg
operator|->
name|baseclass
operator|==
name|PCIC_BRIDGE
operator|&&
name|cfg
operator|->
name|subclass
operator|==
name|PCIS_BRIDGE_PCI
condition|)
name|cfg
operator|->
name|hdrtype
operator|=
name|PCIM_HDRTYPE_BRIDGE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* extract header type specific config data */
end_comment

begin_function
specifier|static
name|void
name|pci_hdrtypedata
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|s
parameter_list|,
name|int
name|f
parameter_list|,
name|pcicfgregs
modifier|*
name|cfg
parameter_list|)
block|{
define|#
directive|define
name|REG
parameter_list|(
name|n
parameter_list|,
name|w
parameter_list|)
value|PCIB_READ_CONFIG(pcib, b, s, f, n, w)
switch|switch
condition|(
name|cfg
operator|->
name|hdrtype
operator|&
name|PCIM_HDRTYPE
condition|)
block|{
case|case
name|PCIM_HDRTYPE_NORMAL
case|:
name|cfg
operator|->
name|subvendor
operator|=
name|REG
argument_list|(
name|PCIR_SUBVEND_0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|subdevice
operator|=
name|REG
argument_list|(
name|PCIR_SUBDEV_0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|mingnt
operator|=
name|REG
argument_list|(
name|PCIR_MINGNT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|maxlat
operator|=
name|REG
argument_list|(
name|PCIR_MAXLAT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|nummaps
operator|=
name|PCI_MAXMAPS_0
expr_stmt|;
break|break;
case|case
name|PCIM_HDRTYPE_BRIDGE
case|:
name|cfg
operator|->
name|bridge
operator|.
name|br_seclat
operator|=
name|REG
argument_list|(
name|PCIR_SECLAT_1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|bridge
operator|.
name|br_subbus
operator|=
name|REG
argument_list|(
name|PCIR_SUBBUS_1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|bridge
operator|.
name|br_secbus
operator|=
name|REG
argument_list|(
name|PCIR_SECBUS_1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|bridge
operator|.
name|br_pribus
operator|=
name|REG
argument_list|(
name|PCIR_PRIBUS_1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|bridge
operator|.
name|br_control
operator|=
name|REG
argument_list|(
name|PCIR_BRIDGECTL_1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|nummaps
operator|=
name|PCI_MAXMAPS_1
expr_stmt|;
break|break;
case|case
name|PCIM_HDRTYPE_CARDBUS
case|:
name|cfg
operator|->
name|bridge
operator|.
name|br_seclat
operator|=
name|REG
argument_list|(
name|PCIR_SECLAT_2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|bridge
operator|.
name|br_subbus
operator|=
name|REG
argument_list|(
name|PCIR_SUBBUS_2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|bridge
operator|.
name|br_secbus
operator|=
name|REG
argument_list|(
name|PCIR_SECBUS_2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|bridge
operator|.
name|br_pribus
operator|=
name|REG
argument_list|(
name|PCIR_PRIBUS_2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|bridge
operator|.
name|br_control
operator|=
name|REG
argument_list|(
name|PCIR_BRIDGECTL_2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|subvendor
operator|=
name|REG
argument_list|(
name|PCIR_SUBVEND_2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|subdevice
operator|=
name|REG
argument_list|(
name|PCIR_SUBDEV_2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|nummaps
operator|=
name|PCI_MAXMAPS_2
expr_stmt|;
break|break;
block|}
undef|#
directive|undef
name|REG
block|}
end_function

begin_comment
comment|/* read configuration header into pcicfgregs structure */
end_comment

begin_function
name|struct
name|pci_devinfo
modifier|*
name|pci_read_device
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|device_t
name|bus
parameter_list|,
name|int
name|d
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|s
parameter_list|,
name|int
name|f
parameter_list|)
block|{
define|#
directive|define
name|REG
parameter_list|(
name|n
parameter_list|,
name|w
parameter_list|)
value|PCIB_READ_CONFIG(pcib, b, s, f, n, w)
name|uint16_t
name|vid
decl_stmt|,
name|did
decl_stmt|;
name|vid
operator|=
name|REG
argument_list|(
name|PCIR_VENDOR
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|did
operator|=
name|REG
argument_list|(
name|PCIR_DEVICE
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|vid
operator|!=
literal|0xffff
condition|)
return|return
operator|(
name|pci_fill_devinfo
argument_list|(
name|pcib
argument_list|,
name|bus
argument_list|,
name|d
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|vid
argument_list|,
name|did
argument_list|)
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|pci_devinfo
modifier|*
name|pci_alloc_devinfo_method
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pci_devinfo
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|pci_devinfo
modifier|*
name|pci_fill_devinfo
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|device_t
name|bus
parameter_list|,
name|int
name|d
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|s
parameter_list|,
name|int
name|f
parameter_list|,
name|uint16_t
name|vid
parameter_list|,
name|uint16_t
name|did
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|devlist_entry
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
decl_stmt|;
name|devlist_entry
operator|=
name|PCI_ALLOC_DEVINFO
argument_list|(
name|bus
argument_list|)
expr_stmt|;
name|cfg
operator|=
operator|&
name|devlist_entry
operator|->
name|cfg
expr_stmt|;
name|cfg
operator|->
name|domain
operator|=
name|d
expr_stmt|;
name|cfg
operator|->
name|bus
operator|=
name|b
expr_stmt|;
name|cfg
operator|->
name|slot
operator|=
name|s
expr_stmt|;
name|cfg
operator|->
name|func
operator|=
name|f
expr_stmt|;
name|cfg
operator|->
name|vendor
operator|=
name|vid
expr_stmt|;
name|cfg
operator|->
name|device
operator|=
name|did
expr_stmt|;
name|cfg
operator|->
name|cmdreg
operator|=
name|REG
argument_list|(
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|statreg
operator|=
name|REG
argument_list|(
name|PCIR_STATUS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|baseclass
operator|=
name|REG
argument_list|(
name|PCIR_CLASS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|subclass
operator|=
name|REG
argument_list|(
name|PCIR_SUBCLASS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|progif
operator|=
name|REG
argument_list|(
name|PCIR_PROGIF
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|revid
operator|=
name|REG
argument_list|(
name|PCIR_REVID
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|hdrtype
operator|=
name|REG
argument_list|(
name|PCIR_HDRTYPE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|cachelnsz
operator|=
name|REG
argument_list|(
name|PCIR_CACHELNSZ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|lattimer
operator|=
name|REG
argument_list|(
name|PCIR_LATTIMER
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|intpin
operator|=
name|REG
argument_list|(
name|PCIR_INTPIN
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|intline
operator|=
name|REG
argument_list|(
name|PCIR_INTLINE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|mfdev
operator|=
operator|(
name|cfg
operator|->
name|hdrtype
operator|&
name|PCIM_MFDEV
operator|)
operator|!=
literal|0
expr_stmt|;
name|cfg
operator|->
name|hdrtype
operator|&=
operator|~
name|PCIM_MFDEV
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|cfg
operator|->
name|maps
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|iov
operator|=
name|NULL
expr_stmt|;
name|pci_fixancient
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
name|pci_hdrtypedata
argument_list|(
name|pcib
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|cfg
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG
argument_list|(
name|PCIR_STATUS
argument_list|,
literal|2
argument_list|)
operator|&
name|PCIM_STATUS_CAPPRESENT
condition|)
name|pci_read_cap
argument_list|(
name|pcib
argument_list|,
name|cfg
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pci_devq
argument_list|,
name|devlist_entry
argument_list|,
name|pci_links
argument_list|)
expr_stmt|;
name|devlist_entry
operator|->
name|conf
operator|.
name|pc_sel
operator|.
name|pc_domain
operator|=
name|cfg
operator|->
name|domain
expr_stmt|;
name|devlist_entry
operator|->
name|conf
operator|.
name|pc_sel
operator|.
name|pc_bus
operator|=
name|cfg
operator|->
name|bus
expr_stmt|;
name|devlist_entry
operator|->
name|conf
operator|.
name|pc_sel
operator|.
name|pc_dev
operator|=
name|cfg
operator|->
name|slot
expr_stmt|;
name|devlist_entry
operator|->
name|conf
operator|.
name|pc_sel
operator|.
name|pc_func
operator|=
name|cfg
operator|->
name|func
expr_stmt|;
name|devlist_entry
operator|->
name|conf
operator|.
name|pc_hdr
operator|=
name|cfg
operator|->
name|hdrtype
expr_stmt|;
name|devlist_entry
operator|->
name|conf
operator|.
name|pc_subvendor
operator|=
name|cfg
operator|->
name|subvendor
expr_stmt|;
name|devlist_entry
operator|->
name|conf
operator|.
name|pc_subdevice
operator|=
name|cfg
operator|->
name|subdevice
expr_stmt|;
name|devlist_entry
operator|->
name|conf
operator|.
name|pc_vendor
operator|=
name|cfg
operator|->
name|vendor
expr_stmt|;
name|devlist_entry
operator|->
name|conf
operator|.
name|pc_device
operator|=
name|cfg
operator|->
name|device
expr_stmt|;
name|devlist_entry
operator|->
name|conf
operator|.
name|pc_class
operator|=
name|cfg
operator|->
name|baseclass
expr_stmt|;
name|devlist_entry
operator|->
name|conf
operator|.
name|pc_subclass
operator|=
name|cfg
operator|->
name|subclass
expr_stmt|;
name|devlist_entry
operator|->
name|conf
operator|.
name|pc_progif
operator|=
name|cfg
operator|->
name|progif
expr_stmt|;
name|devlist_entry
operator|->
name|conf
operator|.
name|pc_revid
operator|=
name|cfg
operator|->
name|revid
expr_stmt|;
name|pci_numdevs
operator|++
expr_stmt|;
name|pci_generation
operator|++
expr_stmt|;
return|return
operator|(
name|devlist_entry
operator|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|REG
end_undef

begin_function
specifier|static
name|void
name|pci_ea_fill_info
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|pcicfgregs
modifier|*
name|cfg
parameter_list|)
block|{
define|#
directive|define
name|REG
parameter_list|(
name|n
parameter_list|,
name|w
parameter_list|)
value|PCIB_READ_CONFIG(pcib, cfg->bus, cfg->slot, cfg->func, \     cfg->ea.ea_location + (n), w)
name|int
name|num_ent
decl_stmt|;
name|int
name|ptr
decl_stmt|;
name|int
name|a
decl_stmt|,
name|b
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|int
name|ent_size
decl_stmt|;
name|uint32_t
name|dw
index|[
literal|4
index|]
decl_stmt|;
name|uint64_t
name|base
decl_stmt|,
name|max_offset
decl_stmt|;
name|struct
name|pci_ea_entry
modifier|*
name|eae
decl_stmt|;
if|if
condition|(
name|cfg
operator|->
name|ea
operator|.
name|ea_location
operator|==
literal|0
condition|)
return|return;
name|STAILQ_INIT
argument_list|(
operator|&
name|cfg
operator|->
name|ea
operator|.
name|ea_entries
argument_list|)
expr_stmt|;
comment|/* Determine the number of entries */
name|num_ent
operator|=
name|REG
argument_list|(
name|PCIR_EA_NUM_ENT
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|num_ent
operator|&=
name|PCIM_EA_NUM_ENT_MASK
expr_stmt|;
comment|/* Find the first entry to care of */
name|ptr
operator|=
name|PCIR_EA_FIRST_ENT
expr_stmt|;
comment|/* Skip DWORD 2 for type 1 functions */
if|if
condition|(
operator|(
name|cfg
operator|->
name|hdrtype
operator|&
name|PCIM_HDRTYPE
operator|)
operator|==
name|PCIM_HDRTYPE_BRIDGE
condition|)
name|ptr
operator|+=
literal|4
expr_stmt|;
for|for
control|(
name|a
operator|=
literal|0
init|;
name|a
operator|<
name|num_ent
condition|;
name|a
operator|++
control|)
block|{
name|eae
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|eae
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|eae
operator|->
name|eae_cfg_offset
operator|=
name|cfg
operator|->
name|ea
operator|.
name|ea_location
operator|+
name|ptr
expr_stmt|;
comment|/* Read a number of dwords in the entry */
name|val
operator|=
name|REG
argument_list|(
name|ptr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ptr
operator|+=
literal|4
expr_stmt|;
name|ent_size
operator|=
operator|(
name|val
operator|&
name|PCIM_EA_ES
operator|)
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|ent_size
condition|;
name|b
operator|++
control|)
block|{
name|dw
index|[
name|b
index|]
operator|=
name|REG
argument_list|(
name|ptr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ptr
operator|+=
literal|4
expr_stmt|;
block|}
name|eae
operator|->
name|eae_flags
operator|=
name|val
expr_stmt|;
name|eae
operator|->
name|eae_bei
operator|=
operator|(
name|PCIM_EA_BEI
operator|&
name|val
operator|)
operator|>>
name|PCIM_EA_BEI_OFFSET
expr_stmt|;
name|base
operator|=
name|dw
index|[
literal|0
index|]
operator|&
name|PCIM_EA_FIELD_MASK
expr_stmt|;
name|max_offset
operator|=
name|dw
index|[
literal|1
index|]
operator||
operator|~
name|PCIM_EA_FIELD_MASK
expr_stmt|;
name|b
operator|=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|dw
index|[
literal|0
index|]
operator|&
name|PCIM_EA_IS_64
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|b
operator|<
name|ent_size
operator|)
condition|)
block|{
name|base
operator||=
operator|(
name|uint64_t
operator|)
name|dw
index|[
name|b
index|]
operator|<<
literal|32UL
expr_stmt|;
name|b
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|dw
index|[
literal|1
index|]
operator|&
name|PCIM_EA_IS_64
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|b
operator|<
name|ent_size
operator|)
condition|)
block|{
name|max_offset
operator||=
operator|(
name|uint64_t
operator|)
name|dw
index|[
name|b
index|]
operator|<<
literal|32UL
expr_stmt|;
name|b
operator|++
expr_stmt|;
block|}
name|eae
operator|->
name|eae_base
operator|=
name|base
expr_stmt|;
name|eae
operator|->
name|eae_max_offset
operator|=
name|max_offset
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|cfg
operator|->
name|ea
operator|.
name|ea_entries
argument_list|,
name|eae
argument_list|,
name|eae_link
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"PCI(EA) dev %04x:%04x, bei %d, flags #%x, base #%jx, max_offset #%jx\n"
argument_list|,
name|cfg
operator|->
name|vendor
argument_list|,
name|cfg
operator|->
name|device
argument_list|,
name|eae
operator|->
name|eae_bei
argument_list|,
name|eae
operator|->
name|eae_flags
argument_list|,
operator|(
name|uintmax_t
operator|)
name|eae
operator|->
name|eae_base
argument_list|,
operator|(
name|uintmax_t
operator|)
name|eae
operator|->
name|eae_max_offset
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_undef
undef|#
directive|undef
name|REG
end_undef

begin_function
specifier|static
name|void
name|pci_read_cap
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|pcicfgregs
modifier|*
name|cfg
parameter_list|)
block|{
define|#
directive|define
name|REG
parameter_list|(
name|n
parameter_list|,
name|w
parameter_list|)
value|PCIB_READ_CONFIG(pcib, cfg->bus, cfg->slot, cfg->func, n, w)
define|#
directive|define
name|WREG
parameter_list|(
name|n
parameter_list|,
name|v
parameter_list|,
name|w
parameter_list|)
value|PCIB_WRITE_CONFIG(pcib, cfg->bus, cfg->slot, cfg->func, n, v, w)
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
operator|||
name|defined
argument_list|(
name|__powerpc__
argument_list|)
name|uint64_t
name|addr
decl_stmt|;
endif|#
directive|endif
name|uint32_t
name|val
decl_stmt|;
name|int
name|ptr
decl_stmt|,
name|nextptr
decl_stmt|,
name|ptrptr
decl_stmt|;
switch|switch
condition|(
name|cfg
operator|->
name|hdrtype
operator|&
name|PCIM_HDRTYPE
condition|)
block|{
case|case
name|PCIM_HDRTYPE_NORMAL
case|:
case|case
name|PCIM_HDRTYPE_BRIDGE
case|:
name|ptrptr
operator|=
name|PCIR_CAP_PTR
expr_stmt|;
break|break;
case|case
name|PCIM_HDRTYPE_CARDBUS
case|:
name|ptrptr
operator|=
name|PCIR_CAP_PTR_2
expr_stmt|;
comment|/* cardbus capabilities ptr */
break|break;
default|default:
return|return;
comment|/* no extended capabilities support */
block|}
name|nextptr
operator|=
name|REG
argument_list|(
name|ptrptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* sanity check? */
comment|/* 	 * Read capability entries. 	 */
while|while
condition|(
name|nextptr
operator|!=
literal|0
condition|)
block|{
comment|/* Sanity check */
if|if
condition|(
name|nextptr
operator|>
literal|255
condition|)
block|{
name|printf
argument_list|(
literal|"illegal PCI extended capability offset %d\n"
argument_list|,
name|nextptr
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Find the next entry */
name|ptr
operator|=
name|nextptr
expr_stmt|;
name|nextptr
operator|=
name|REG
argument_list|(
name|ptr
operator|+
name|PCICAP_NEXTPTR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Process this entry */
switch|switch
condition|(
name|REG
argument_list|(
name|ptr
operator|+
name|PCICAP_ID
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
name|PCIY_PMG
case|:
comment|/* PCI power management */
if|if
condition|(
name|cfg
operator|->
name|pp
operator|.
name|pp_cap
operator|==
literal|0
condition|)
block|{
name|cfg
operator|->
name|pp
operator|.
name|pp_cap
operator|=
name|REG
argument_list|(
name|ptr
operator|+
name|PCIR_POWER_CAP
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|pp
operator|.
name|pp_status
operator|=
name|ptr
operator|+
name|PCIR_POWER_STATUS
expr_stmt|;
name|cfg
operator|->
name|pp
operator|.
name|pp_bse
operator|=
name|ptr
operator|+
name|PCIR_POWER_BSE
expr_stmt|;
if|if
condition|(
operator|(
name|nextptr
operator|-
name|ptr
operator|)
operator|>
name|PCIR_POWER_DATA
condition|)
name|cfg
operator|->
name|pp
operator|.
name|pp_data
operator|=
name|ptr
operator|+
name|PCIR_POWER_DATA
expr_stmt|;
block|}
break|break;
case|case
name|PCIY_HT
case|:
comment|/* HyperTransport */
comment|/* Determine HT-specific capability type. */
name|val
operator|=
name|REG
argument_list|(
name|ptr
operator|+
name|PCIR_HT_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
literal|0xe000
operator|)
operator|==
name|PCIM_HTCAP_SLAVE
condition|)
name|cfg
operator|->
name|ht
operator|.
name|ht_slave
operator|=
name|ptr
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
operator|||
name|defined
argument_list|(
name|__powerpc__
argument_list|)
switch|switch
condition|(
name|val
operator|&
name|PCIM_HTCMD_CAP_MASK
condition|)
block|{
case|case
name|PCIM_HTCAP_MSI_MAPPING
case|:
if|if
condition|(
operator|!
operator|(
name|val
operator|&
name|PCIM_HTCMD_MSI_FIXED
operator|)
condition|)
block|{
comment|/* Sanity check the mapping window. */
name|addr
operator|=
name|REG
argument_list|(
name|ptr
operator|+
name|PCIR_HTMSI_ADDRESS_HI
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|addr
operator|<<=
literal|32
expr_stmt|;
name|addr
operator||=
name|REG
argument_list|(
name|ptr
operator|+
name|PCIR_HTMSI_ADDRESS_LO
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|!=
name|MSI_INTEL_ADDR_BASE
condition|)
name|device_printf
argument_list|(
name|pcib
argument_list|,
literal|"HT device at pci%d:%d:%d:%d has non-default MSI window 0x%llx\n"
argument_list|,
name|cfg
operator|->
name|domain
argument_list|,
name|cfg
operator|->
name|bus
argument_list|,
name|cfg
operator|->
name|slot
argument_list|,
name|cfg
operator|->
name|func
argument_list|,
operator|(
name|long
name|long
operator|)
name|addr
argument_list|)
expr_stmt|;
block|}
else|else
name|addr
operator|=
name|MSI_INTEL_ADDR_BASE
expr_stmt|;
name|cfg
operator|->
name|ht
operator|.
name|ht_msimap
operator|=
name|ptr
expr_stmt|;
name|cfg
operator|->
name|ht
operator|.
name|ht_msictrl
operator|=
name|val
expr_stmt|;
name|cfg
operator|->
name|ht
operator|.
name|ht_msiaddr
operator|=
name|addr
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
break|break;
case|case
name|PCIY_MSI
case|:
comment|/* PCI MSI */
name|cfg
operator|->
name|msi
operator|.
name|msi_location
operator|=
name|ptr
expr_stmt|;
name|cfg
operator|->
name|msi
operator|.
name|msi_ctrl
operator|=
name|REG
argument_list|(
name|ptr
operator|+
name|PCIR_MSI_CTRL
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|msi
operator|.
name|msi_msgnum
operator|=
literal|1
operator|<<
operator|(
operator|(
name|cfg
operator|->
name|msi
operator|.
name|msi_ctrl
operator|&
name|PCIM_MSICTRL_MMC_MASK
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
break|break;
case|case
name|PCIY_MSIX
case|:
comment|/* PCI MSI-X */
name|cfg
operator|->
name|msix
operator|.
name|msix_location
operator|=
name|ptr
expr_stmt|;
name|cfg
operator|->
name|msix
operator|.
name|msix_ctrl
operator|=
name|REG
argument_list|(
name|ptr
operator|+
name|PCIR_MSIX_CTRL
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|msix
operator|.
name|msix_msgnum
operator|=
operator|(
name|cfg
operator|->
name|msix
operator|.
name|msix_ctrl
operator|&
name|PCIM_MSIXCTRL_TABLE_SIZE
operator|)
operator|+
literal|1
expr_stmt|;
name|val
operator|=
name|REG
argument_list|(
name|ptr
operator|+
name|PCIR_MSIX_TABLE
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|msix
operator|.
name|msix_table_bar
operator|=
name|PCIR_BAR
argument_list|(
name|val
operator|&
name|PCIM_MSIX_BIR_MASK
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|msix
operator|.
name|msix_table_offset
operator|=
name|val
operator|&
operator|~
name|PCIM_MSIX_BIR_MASK
expr_stmt|;
name|val
operator|=
name|REG
argument_list|(
name|ptr
operator|+
name|PCIR_MSIX_PBA
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|msix
operator|.
name|msix_pba_bar
operator|=
name|PCIR_BAR
argument_list|(
name|val
operator|&
name|PCIM_MSIX_BIR_MASK
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|msix
operator|.
name|msix_pba_offset
operator|=
name|val
operator|&
operator|~
name|PCIM_MSIX_BIR_MASK
expr_stmt|;
break|break;
case|case
name|PCIY_VPD
case|:
comment|/* PCI Vital Product Data */
name|cfg
operator|->
name|vpd
operator|.
name|vpd_reg
operator|=
name|ptr
expr_stmt|;
break|break;
case|case
name|PCIY_SUBVENDOR
case|:
comment|/* Should always be true. */
if|if
condition|(
operator|(
name|cfg
operator|->
name|hdrtype
operator|&
name|PCIM_HDRTYPE
operator|)
operator|==
name|PCIM_HDRTYPE_BRIDGE
condition|)
block|{
name|val
operator|=
name|REG
argument_list|(
name|ptr
operator|+
name|PCIR_SUBVENDCAP_ID
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|subvendor
operator|=
name|val
operator|&
literal|0xffff
expr_stmt|;
name|cfg
operator|->
name|subdevice
operator|=
name|val
operator|>>
literal|16
expr_stmt|;
block|}
break|break;
case|case
name|PCIY_PCIX
case|:
comment|/* PCI-X */
comment|/* 			 * Assume we have a PCI-X chipset if we have 			 * at least one PCI-PCI bridge with a PCI-X 			 * capability.  Note that some systems with 			 * PCI-express or HT chipsets might match on 			 * this check as well. 			 */
if|if
condition|(
operator|(
name|cfg
operator|->
name|hdrtype
operator|&
name|PCIM_HDRTYPE
operator|)
operator|==
name|PCIM_HDRTYPE_BRIDGE
condition|)
name|pcix_chipset
operator|=
literal|1
expr_stmt|;
name|cfg
operator|->
name|pcix
operator|.
name|pcix_location
operator|=
name|ptr
expr_stmt|;
break|break;
case|case
name|PCIY_EXPRESS
case|:
comment|/* PCI-express */
comment|/* 			 * Assume we have a PCI-express chipset if we have 			 * at least one PCI-express device. 			 */
name|pcie_chipset
operator|=
literal|1
expr_stmt|;
name|cfg
operator|->
name|pcie
operator|.
name|pcie_location
operator|=
name|ptr
expr_stmt|;
name|val
operator|=
name|REG
argument_list|(
name|ptr
operator|+
name|PCIER_FLAGS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|pcie
operator|.
name|pcie_type
operator|=
name|val
operator|&
name|PCIEM_FLAGS_TYPE
expr_stmt|;
break|break;
case|case
name|PCIY_EA
case|:
comment|/* Enhanced Allocation */
name|cfg
operator|->
name|ea
operator|.
name|ea_location
operator|=
name|ptr
expr_stmt|;
name|pci_ea_fill_info
argument_list|(
name|pcib
argument_list|,
name|cfg
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|__powerpc__
argument_list|)
comment|/* 	 * Enable the MSI mapping window for all HyperTransport 	 * slaves.  PCI-PCI bridges have their windows enabled via 	 * PCIB_MAP_MSI(). 	 */
if|if
condition|(
name|cfg
operator|->
name|ht
operator|.
name|ht_slave
operator|!=
literal|0
operator|&&
name|cfg
operator|->
name|ht
operator|.
name|ht_msimap
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|cfg
operator|->
name|ht
operator|.
name|ht_msictrl
operator|&
name|PCIM_HTCMD_MSI_ENABLE
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|pcib
argument_list|,
literal|"Enabling MSI window for HyperTransport slave at pci%d:%d:%d:%d\n"
argument_list|,
name|cfg
operator|->
name|domain
argument_list|,
name|cfg
operator|->
name|bus
argument_list|,
name|cfg
operator|->
name|slot
argument_list|,
name|cfg
operator|->
name|func
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|ht
operator|.
name|ht_msictrl
operator||=
name|PCIM_HTCMD_MSI_ENABLE
expr_stmt|;
name|WREG
argument_list|(
name|cfg
operator|->
name|ht
operator|.
name|ht_msimap
operator|+
name|PCIR_HT_COMMAND
argument_list|,
name|cfg
operator|->
name|ht
operator|.
name|ht_msictrl
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* REG and WREG use carry through to next functions */
block|}
end_function

begin_comment
comment|/*  * PCI Vital Product Data  */
end_comment

begin_define
define|#
directive|define
name|PCI_VPD_TIMEOUT
value|1000000
end_define

begin_function
specifier|static
name|int
name|pci_read_vpd_reg
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|pcicfgregs
modifier|*
name|cfg
parameter_list|,
name|int
name|reg
parameter_list|,
name|uint32_t
modifier|*
name|data
parameter_list|)
block|{
name|int
name|count
init|=
name|PCI_VPD_TIMEOUT
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|reg
operator|&
literal|3
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"VPD register must by 4 byte aligned"
operator|)
argument_list|)
expr_stmt|;
name|WREG
argument_list|(
name|cfg
operator|->
name|vpd
operator|.
name|vpd_reg
operator|+
name|PCIR_VPD_ADDR
argument_list|,
name|reg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|REG
argument_list|(
name|cfg
operator|->
name|vpd
operator|.
name|vpd_reg
operator|+
name|PCIR_VPD_ADDR
argument_list|,
literal|2
argument_list|)
operator|&
literal|0x8000
operator|)
operator|!=
literal|0x8000
condition|)
block|{
if|if
condition|(
operator|--
name|count
operator|<
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* limit looping */
block|}
operator|*
name|data
operator|=
operator|(
name|REG
argument_list|(
name|cfg
operator|->
name|vpd
operator|.
name|vpd_reg
operator|+
name|PCIR_VPD_DATA
argument_list|,
literal|4
argument_list|)
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static int pci_write_vpd_reg(device_t pcib, pcicfgregs *cfg, int reg, uint32_t data) { 	int count = PCI_VPD_TIMEOUT;  	KASSERT((reg& 3) == 0, ("VPD register must by 4 byte aligned"));  	WREG(cfg->vpd.vpd_reg + PCIR_VPD_DATA, data, 4); 	WREG(cfg->vpd.vpd_reg + PCIR_VPD_ADDR, reg | 0x8000, 2); 	while ((REG(cfg->vpd.vpd_reg + PCIR_VPD_ADDR, 2)& 0x8000) == 0x8000) { 		if (--count< 0) 			return (ENXIO); 		DELAY(1);
comment|/* limit looping */
end_comment

begin_endif
unit|}  	return (0); }
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|PCI_VPD_TIMEOUT
end_undef

begin_struct
struct|struct
name|vpd_readstate
block|{
name|device_t
name|pcib
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|int
name|bytesinval
decl_stmt|;
name|int
name|off
decl_stmt|;
name|uint8_t
name|cksum
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|vpd_nextbyte
parameter_list|(
name|struct
name|vpd_readstate
modifier|*
name|vrs
parameter_list|,
name|uint8_t
modifier|*
name|data
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|;
name|uint8_t
name|byte
decl_stmt|;
if|if
condition|(
name|vrs
operator|->
name|bytesinval
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pci_read_vpd_reg
argument_list|(
name|vrs
operator|->
name|pcib
argument_list|,
name|vrs
operator|->
name|cfg
argument_list|,
name|vrs
operator|->
name|off
argument_list|,
operator|&
name|reg
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|vrs
operator|->
name|val
operator|=
name|le32toh
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|vrs
operator|->
name|off
operator|+=
literal|4
expr_stmt|;
name|byte
operator|=
name|vrs
operator|->
name|val
operator|&
literal|0xff
expr_stmt|;
name|vrs
operator|->
name|bytesinval
operator|=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|vrs
operator|->
name|val
operator|=
name|vrs
operator|->
name|val
operator|>>
literal|8
expr_stmt|;
name|byte
operator|=
name|vrs
operator|->
name|val
operator|&
literal|0xff
expr_stmt|;
name|vrs
operator|->
name|bytesinval
operator|--
expr_stmt|;
block|}
name|vrs
operator|->
name|cksum
operator|+=
name|byte
expr_stmt|;
operator|*
name|data
operator|=
name|byte
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pci_read_vpd
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|pcicfgregs
modifier|*
name|cfg
parameter_list|)
block|{
name|struct
name|vpd_readstate
name|vrs
decl_stmt|;
name|int
name|state
decl_stmt|;
name|int
name|name
decl_stmt|;
name|int
name|remain
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|alloc
decl_stmt|,
name|off
decl_stmt|;
comment|/* alloc/off for RO/W arrays */
name|int
name|cksumvalid
decl_stmt|;
name|int
name|dflen
decl_stmt|;
name|uint8_t
name|byte
decl_stmt|;
name|uint8_t
name|byte2
decl_stmt|;
comment|/* init vpd reader */
name|vrs
operator|.
name|bytesinval
operator|=
literal|0
expr_stmt|;
name|vrs
operator|.
name|off
operator|=
literal|0
expr_stmt|;
name|vrs
operator|.
name|pcib
operator|=
name|pcib
expr_stmt|;
name|vrs
operator|.
name|cfg
operator|=
name|cfg
expr_stmt|;
name|vrs
operator|.
name|cksum
operator|=
literal|0
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
name|name
operator|=
name|remain
operator|=
name|i
operator|=
literal|0
expr_stmt|;
comment|/* shut up stupid gcc */
name|alloc
operator|=
name|off
operator|=
literal|0
expr_stmt|;
comment|/* shut up stupid gcc */
name|dflen
operator|=
literal|0
expr_stmt|;
comment|/* shut up stupid gcc */
name|cksumvalid
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|state
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|vpd_nextbyte
argument_list|(
operator|&
name|vrs
argument_list|,
operator|&
name|byte
argument_list|)
condition|)
block|{
name|state
operator|=
operator|-
literal|2
expr_stmt|;
break|break;
block|}
if|#
directive|if
literal|0
block|printf("vpd: val: %#x, off: %d, bytesinval: %d, byte: %#hhx, " \ 		    "state: %d, remain: %d, name: %#x, i: %d\n", vrs.val, 		    vrs.off, vrs.bytesinval, byte, state, remain, name, i);
endif|#
directive|endif
switch|switch
condition|(
name|state
condition|)
block|{
case|case
literal|0
case|:
comment|/* item name */
if|if
condition|(
name|byte
operator|&
literal|0x80
condition|)
block|{
if|if
condition|(
name|vpd_nextbyte
argument_list|(
operator|&
name|vrs
argument_list|,
operator|&
name|byte2
argument_list|)
condition|)
block|{
name|state
operator|=
operator|-
literal|2
expr_stmt|;
break|break;
block|}
name|remain
operator|=
name|byte2
expr_stmt|;
if|if
condition|(
name|vpd_nextbyte
argument_list|(
operator|&
name|vrs
argument_list|,
operator|&
name|byte2
argument_list|)
condition|)
block|{
name|state
operator|=
operator|-
literal|2
expr_stmt|;
break|break;
block|}
name|remain
operator||=
name|byte2
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
name|remain
operator|>
operator|(
literal|0x7f
operator|*
literal|4
operator|-
name|vrs
operator|.
name|off
operator|)
condition|)
block|{
name|state
operator|=
operator|-
literal|1
expr_stmt|;
name|pci_printf
argument_list|(
name|cfg
argument_list|,
literal|"invalid VPD data, remain %#x\n"
argument_list|,
name|remain
argument_list|)
expr_stmt|;
block|}
name|name
operator|=
name|byte
operator|&
literal|0x7f
expr_stmt|;
block|}
else|else
block|{
name|remain
operator|=
name|byte
operator|&
literal|0x7
expr_stmt|;
name|name
operator|=
operator|(
name|byte
operator|>>
literal|3
operator|)
operator|&
literal|0xf
expr_stmt|;
block|}
switch|switch
condition|(
name|name
condition|)
block|{
case|case
literal|0x2
case|:
comment|/* String */
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ident
operator|=
name|malloc
argument_list|(
name|remain
operator|+
literal|1
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|state
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|0xf
case|:
comment|/* End */
name|state
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|0x10
case|:
comment|/* VPD-R */
name|alloc
operator|=
literal|8
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
operator|=
name|malloc
argument_list|(
name|alloc
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|state
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|0x11
case|:
comment|/* VPD-W */
name|alloc
operator|=
literal|8
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
operator|=
name|malloc
argument_list|(
name|alloc
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|state
operator|=
literal|5
expr_stmt|;
break|break;
default|default:
comment|/* Invalid data, abort */
name|state
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|1
case|:
comment|/* Identifier String */
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ident
index|[
name|i
operator|++
index|]
operator|=
name|byte
expr_stmt|;
name|remain
operator|--
expr_stmt|;
if|if
condition|(
name|remain
operator|==
literal|0
condition|)
block|{
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ident
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
comment|/* VPD-R Keyword Header */
if|if
condition|(
name|off
operator|==
name|alloc
condition|)
block|{
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
operator|=
name|reallocf
argument_list|(
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
argument_list|,
operator|(
name|alloc
operator|*=
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
block|}
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
index|[
name|off
index|]
operator|.
name|keyword
index|[
literal|0
index|]
operator|=
name|byte
expr_stmt|;
if|if
condition|(
name|vpd_nextbyte
argument_list|(
operator|&
name|vrs
argument_list|,
operator|&
name|byte2
argument_list|)
condition|)
block|{
name|state
operator|=
operator|-
literal|2
expr_stmt|;
break|break;
block|}
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
index|[
name|off
index|]
operator|.
name|keyword
index|[
literal|1
index|]
operator|=
name|byte2
expr_stmt|;
if|if
condition|(
name|vpd_nextbyte
argument_list|(
operator|&
name|vrs
argument_list|,
operator|&
name|byte2
argument_list|)
condition|)
block|{
name|state
operator|=
operator|-
literal|2
expr_stmt|;
break|break;
block|}
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
index|[
name|off
index|]
operator|.
name|len
operator|=
name|dflen
operator|=
name|byte2
expr_stmt|;
if|if
condition|(
name|dflen
operator|==
literal|0
operator|&&
name|strncmp
argument_list|(
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
index|[
name|off
index|]
operator|.
name|keyword
argument_list|,
literal|"RV"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * if this happens, we can't trust the rest 				 * of the VPD. 				 */
name|pci_printf
argument_list|(
name|cfg
argument_list|,
literal|"bad keyword length: %d\n"
argument_list|,
name|dflen
argument_list|)
expr_stmt|;
name|cksumvalid
operator|=
literal|0
expr_stmt|;
name|state
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|dflen
operator|==
literal|0
condition|)
block|{
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
index|[
name|off
index|]
operator|.
name|value
operator|=
name|malloc
argument_list|(
literal|1
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
index|[
name|off
index|]
operator|.
name|value
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
index|[
name|off
index|]
operator|.
name|value
index|[
literal|0
index|]
operator|=
literal|'\x00'
expr_stmt|;
block|}
else|else
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
index|[
name|off
index|]
operator|.
name|value
operator|=
name|malloc
argument_list|(
operator|(
name|dflen
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
index|[
name|off
index|]
operator|.
name|value
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|remain
operator|-=
literal|3
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
comment|/* keep in sync w/ state 3's transistions */
if|if
condition|(
name|dflen
operator|==
literal|0
operator|&&
name|remain
operator|==
literal|0
condition|)
name|state
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|dflen
operator|==
literal|0
condition|)
name|state
operator|=
literal|2
expr_stmt|;
else|else
name|state
operator|=
literal|3
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* VPD-R Keyword Value */
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
index|[
name|off
index|]
operator|.
name|value
index|[
name|i
operator|++
index|]
operator|=
name|byte
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
index|[
name|off
index|]
operator|.
name|keyword
argument_list|,
literal|"RV"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|&&
name|cksumvalid
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|vrs
operator|.
name|cksum
operator|==
literal|0
condition|)
name|cksumvalid
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|bootverbose
condition|)
name|pci_printf
argument_list|(
name|cfg
argument_list|,
literal|"bad VPD cksum, remain %hhu\n"
argument_list|,
name|vrs
operator|.
name|cksum
argument_list|)
expr_stmt|;
name|cksumvalid
operator|=
literal|0
expr_stmt|;
name|state
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|dflen
operator|--
expr_stmt|;
name|remain
operator|--
expr_stmt|;
comment|/* keep in sync w/ state 2's transistions */
if|if
condition|(
name|dflen
operator|==
literal|0
condition|)
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
index|[
name|off
operator|++
index|]
operator|.
name|value
index|[
name|i
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|dflen
operator|==
literal|0
operator|&&
name|remain
operator|==
literal|0
condition|)
block|{
name|cfg
operator|->
name|vpd
operator|.
name|vpd_rocnt
operator|=
name|off
expr_stmt|;
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
operator|=
name|reallocf
argument_list|(
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
argument_list|,
name|off
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dflen
operator|==
literal|0
condition|)
name|state
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|remain
operator|--
expr_stmt|;
if|if
condition|(
name|remain
operator|==
literal|0
condition|)
name|state
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* VPD-W Keyword Header */
if|if
condition|(
name|off
operator|==
name|alloc
condition|)
block|{
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
operator|=
name|reallocf
argument_list|(
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
argument_list|,
operator|(
name|alloc
operator|*=
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
block|}
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
index|[
name|off
index|]
operator|.
name|keyword
index|[
literal|0
index|]
operator|=
name|byte
expr_stmt|;
if|if
condition|(
name|vpd_nextbyte
argument_list|(
operator|&
name|vrs
argument_list|,
operator|&
name|byte2
argument_list|)
condition|)
block|{
name|state
operator|=
operator|-
literal|2
expr_stmt|;
break|break;
block|}
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
index|[
name|off
index|]
operator|.
name|keyword
index|[
literal|1
index|]
operator|=
name|byte2
expr_stmt|;
if|if
condition|(
name|vpd_nextbyte
argument_list|(
operator|&
name|vrs
argument_list|,
operator|&
name|byte2
argument_list|)
condition|)
block|{
name|state
operator|=
operator|-
literal|2
expr_stmt|;
break|break;
block|}
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
index|[
name|off
index|]
operator|.
name|len
operator|=
name|dflen
operator|=
name|byte2
expr_stmt|;
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
index|[
name|off
index|]
operator|.
name|start
operator|=
name|vrs
operator|.
name|off
operator|-
name|vrs
operator|.
name|bytesinval
expr_stmt|;
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
index|[
name|off
index|]
operator|.
name|value
operator|=
name|malloc
argument_list|(
operator|(
name|dflen
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
index|[
name|off
index|]
operator|.
name|value
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|remain
operator|-=
literal|3
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
comment|/* keep in sync w/ state 6's transistions */
if|if
condition|(
name|dflen
operator|==
literal|0
operator|&&
name|remain
operator|==
literal|0
condition|)
name|state
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|dflen
operator|==
literal|0
condition|)
name|state
operator|=
literal|5
expr_stmt|;
else|else
name|state
operator|=
literal|6
expr_stmt|;
break|break;
case|case
literal|6
case|:
comment|/* VPD-W Keyword Value */
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
index|[
name|off
index|]
operator|.
name|value
index|[
name|i
operator|++
index|]
operator|=
name|byte
expr_stmt|;
name|dflen
operator|--
expr_stmt|;
name|remain
operator|--
expr_stmt|;
comment|/* keep in sync w/ state 5's transistions */
if|if
condition|(
name|dflen
operator|==
literal|0
condition|)
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
index|[
name|off
operator|++
index|]
operator|.
name|value
index|[
name|i
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|dflen
operator|==
literal|0
operator|&&
name|remain
operator|==
literal|0
condition|)
block|{
name|cfg
operator|->
name|vpd
operator|.
name|vpd_wcnt
operator|=
name|off
expr_stmt|;
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
operator|=
name|reallocf
argument_list|(
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
argument_list|,
name|off
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dflen
operator|==
literal|0
condition|)
name|state
operator|=
literal|5
expr_stmt|;
break|break;
default|default:
name|pci_printf
argument_list|(
name|cfg
argument_list|,
literal|"invalid state: %d\n"
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|state
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|cksumvalid
operator|==
literal|0
operator|||
name|state
operator|<
operator|-
literal|1
condition|)
block|{
comment|/* read-only data bad, clean up */
if|if
condition|(
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|off
operator|=
literal|0
init|;
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
index|[
name|off
index|]
operator|.
name|value
condition|;
name|off
operator|++
control|)
name|free
argument_list|(
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
index|[
name|off
index|]
operator|.
name|value
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|state
operator|<
operator|-
literal|1
condition|)
block|{
comment|/* I/O error, clean up */
name|pci_printf
argument_list|(
name|cfg
argument_list|,
literal|"failed to read VPD data.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ident
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ident
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ident
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|off
operator|=
literal|0
init|;
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
index|[
name|off
index|]
operator|.
name|value
condition|;
name|off
operator|++
control|)
name|free
argument_list|(
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
index|[
name|off
index|]
operator|.
name|value
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|cfg
operator|->
name|vpd
operator|.
name|vpd_cached
operator|=
literal|1
expr_stmt|;
undef|#
directive|undef
name|REG
undef|#
directive|undef
name|WREG
block|}
end_function

begin_function
name|int
name|pci_get_vpd_ident_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|identptr
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
if|if
condition|(
operator|!
name|cfg
operator|->
name|vpd
operator|.
name|vpd_cached
operator|&&
name|cfg
operator|->
name|vpd
operator|.
name|vpd_reg
operator|!=
literal|0
condition|)
name|pci_read_vpd
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|cfg
argument_list|)
expr_stmt|;
operator|*
name|identptr
operator|=
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ident
expr_stmt|;
if|if
condition|(
operator|*
name|identptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_get_vpd_readonly_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
specifier|const
name|char
modifier|*
name|kw
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|vptr
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|cfg
operator|->
name|vpd
operator|.
name|vpd_cached
operator|&&
name|cfg
operator|->
name|vpd
operator|.
name|vpd_reg
operator|!=
literal|0
condition|)
name|pci_read_vpd
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|cfg
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cfg
operator|->
name|vpd
operator|.
name|vpd_rocnt
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|memcmp
argument_list|(
name|kw
argument_list|,
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
index|[
name|i
index|]
operator|.
name|keyword
argument_list|,
sizeof|sizeof
argument_list|(
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
index|[
name|i
index|]
operator|.
name|keyword
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|vptr
operator|=
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
index|[
name|i
index|]
operator|.
name|value
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|*
name|vptr
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|pcicfg_vpd
modifier|*
name|pci_fetch_vpd_list
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
if|if
condition|(
operator|!
name|cfg
operator|->
name|vpd
operator|.
name|vpd_cached
operator|&&
name|cfg
operator|->
name|vpd
operator|.
name|vpd_reg
operator|!=
literal|0
condition|)
name|pci_read_vpd
argument_list|(
name|device_get_parent
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|cfg
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|cfg
operator|->
name|vpd
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find the requested HyperTransport capability and return the offset  * in configuration space via the pointer provided.  The function  * returns 0 on success and an error code otherwise.  */
end_comment

begin_function
name|int
name|pci_find_htcap_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|capability
parameter_list|,
name|int
modifier|*
name|capreg
parameter_list|)
block|{
name|int
name|ptr
decl_stmt|,
name|error
decl_stmt|;
name|uint16_t
name|val
decl_stmt|;
name|error
operator|=
name|pci_find_cap
argument_list|(
name|child
argument_list|,
name|PCIY_HT
argument_list|,
operator|&
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Traverse the capabilities list checking each HT capability 	 * to see if it matches the requested HT capability. 	 */
while|while
condition|(
name|ptr
operator|!=
literal|0
condition|)
block|{
name|val
operator|=
name|pci_read_config
argument_list|(
name|child
argument_list|,
name|ptr
operator|+
name|PCIR_HT_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|capability
operator|==
name|PCIM_HTCAP_SLAVE
operator|||
name|capability
operator|==
name|PCIM_HTCAP_HOST
condition|)
name|val
operator|&=
literal|0xe000
expr_stmt|;
else|else
name|val
operator|&=
name|PCIM_HTCMD_CAP_MASK
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|capability
condition|)
block|{
if|if
condition|(
name|capreg
operator|!=
name|NULL
condition|)
operator|*
name|capreg
operator|=
name|ptr
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Skip to the next HT capability. */
while|while
condition|(
name|ptr
operator|!=
literal|0
condition|)
block|{
name|ptr
operator|=
name|pci_read_config
argument_list|(
name|child
argument_list|,
name|ptr
operator|+
name|PCICAP_NEXTPTR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_read_config
argument_list|(
name|child
argument_list|,
name|ptr
operator|+
name|PCICAP_ID
argument_list|,
literal|1
argument_list|)
operator|==
name|PCIY_HT
condition|)
break|break;
block|}
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find the requested capability and return the offset in  * configuration space via the pointer provided.  The function returns  * 0 on success and an error code otherwise.  */
end_comment

begin_function
name|int
name|pci_find_cap_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|capability
parameter_list|,
name|int
modifier|*
name|capreg
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
name|u_int32_t
name|status
decl_stmt|;
name|u_int8_t
name|ptr
decl_stmt|;
comment|/* 	 * Check the CAP_LIST bit of the PCI status register first. 	 */
name|status
operator|=
name|pci_read_config
argument_list|(
name|child
argument_list|,
name|PCIR_STATUS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|status
operator|&
name|PCIM_STATUS_CAPPRESENT
operator|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* 	 * Determine the start pointer of the capabilities list. 	 */
switch|switch
condition|(
name|cfg
operator|->
name|hdrtype
operator|&
name|PCIM_HDRTYPE
condition|)
block|{
case|case
name|PCIM_HDRTYPE_NORMAL
case|:
case|case
name|PCIM_HDRTYPE_BRIDGE
case|:
name|ptr
operator|=
name|PCIR_CAP_PTR
expr_stmt|;
break|break;
case|case
name|PCIM_HDRTYPE_CARDBUS
case|:
name|ptr
operator|=
name|PCIR_CAP_PTR_2
expr_stmt|;
break|break;
default|default:
comment|/* XXX: panic? */
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* no extended capabilities support */
block|}
name|ptr
operator|=
name|pci_read_config
argument_list|(
name|child
argument_list|,
name|ptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Traverse the capabilities list. 	 */
while|while
condition|(
name|ptr
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|pci_read_config
argument_list|(
name|child
argument_list|,
name|ptr
operator|+
name|PCICAP_ID
argument_list|,
literal|1
argument_list|)
operator|==
name|capability
condition|)
block|{
if|if
condition|(
name|capreg
operator|!=
name|NULL
condition|)
operator|*
name|capreg
operator|=
name|ptr
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ptr
operator|=
name|pci_read_config
argument_list|(
name|child
argument_list|,
name|ptr
operator|+
name|PCICAP_NEXTPTR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find the requested extended capability and return the offset in  * configuration space via the pointer provided.  The function returns  * 0 on success and an error code otherwise.  */
end_comment

begin_function
name|int
name|pci_find_extcap_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|capability
parameter_list|,
name|int
modifier|*
name|capreg
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
name|uint32_t
name|ecap
decl_stmt|;
name|uint16_t
name|ptr
decl_stmt|;
comment|/* Only supported for PCI-express devices. */
if|if
condition|(
name|cfg
operator|->
name|pcie
operator|.
name|pcie_location
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|ptr
operator|=
name|PCIR_EXTCAP
expr_stmt|;
name|ecap
operator|=
name|pci_read_config
argument_list|(
name|child
argument_list|,
name|ptr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecap
operator|==
literal|0xffffffff
operator|||
name|ecap
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|PCI_EXTCAP_ID
argument_list|(
name|ecap
argument_list|)
operator|==
name|capability
condition|)
block|{
if|if
condition|(
name|capreg
operator|!=
name|NULL
condition|)
operator|*
name|capreg
operator|=
name|ptr
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ptr
operator|=
name|PCI_EXTCAP_NEXTPTR
argument_list|(
name|ecap
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
literal|0
condition|)
break|break;
name|ecap
operator|=
name|pci_read_config
argument_list|(
name|child
argument_list|,
name|ptr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Support for MSI-X message interrupts.  */
end_comment

begin_function
specifier|static
name|void
name|pci_write_msix_entry
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|index
parameter_list|,
name|uint64_t
name|address
parameter_list|,
name|uint32_t
name|data
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|pcicfg_msix
modifier|*
name|msix
init|=
operator|&
name|dinfo
operator|->
name|cfg
operator|.
name|msix
decl_stmt|;
name|uint32_t
name|offset
decl_stmt|;
name|KASSERT
argument_list|(
name|msix
operator|->
name|msix_table_len
operator|>
name|index
argument_list|,
operator|(
literal|"bogus index"
operator|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|msix
operator|->
name|msix_table_offset
operator|+
name|index
operator|*
literal|16
expr_stmt|;
name|bus_write_4
argument_list|(
name|msix
operator|->
name|msix_table_res
argument_list|,
name|offset
argument_list|,
name|address
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|bus_write_4
argument_list|(
name|msix
operator|->
name|msix_table_res
argument_list|,
name|offset
operator|+
literal|4
argument_list|,
name|address
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|bus_write_4
argument_list|(
name|msix
operator|->
name|msix_table_res
argument_list|,
name|offset
operator|+
literal|8
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pci_enable_msix_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|u_int
name|index
parameter_list|,
name|uint64_t
name|address
parameter_list|,
name|uint32_t
name|data
parameter_list|)
block|{
if|if
condition|(
name|pci_msix_rewrite_table
condition|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|struct
name|pcicfg_msix
modifier|*
name|msix
init|=
operator|&
name|dinfo
operator|->
name|cfg
operator|.
name|msix
decl_stmt|;
comment|/* 		 * Some VM hosts require MSIX to be disabled in the 		 * control register before updating the MSIX table 		 * entries are allowed. It is not enough to only 		 * disable MSIX while updating a single entry. MSIX 		 * must be disabled while updating all entries in the 		 * table. 		 */
name|pci_write_config
argument_list|(
name|child
argument_list|,
name|msix
operator|->
name|msix_location
operator|+
name|PCIR_MSIX_CTRL
argument_list|,
name|msix
operator|->
name|msix_ctrl
operator|&
operator|~
name|PCIM_MSIXCTRL_MSIX_ENABLE
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pci_resume_msix
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
else|else
name|pci_write_msix_entry
argument_list|(
name|child
argument_list|,
name|index
argument_list|,
name|address
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* Enable MSI -> HT mapping. */
name|pci_ht_map_msi
argument_list|(
name|child
argument_list|,
name|address
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pci_mask_msix
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|index
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|pcicfg_msix
modifier|*
name|msix
init|=
operator|&
name|dinfo
operator|->
name|cfg
operator|.
name|msix
decl_stmt|;
name|uint32_t
name|offset
decl_stmt|,
name|val
decl_stmt|;
name|KASSERT
argument_list|(
name|msix
operator|->
name|msix_msgnum
operator|>
name|index
argument_list|,
operator|(
literal|"bogus index"
operator|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|msix
operator|->
name|msix_table_offset
operator|+
name|index
operator|*
literal|16
operator|+
literal|12
expr_stmt|;
name|val
operator|=
name|bus_read_4
argument_list|(
name|msix
operator|->
name|msix_table_res
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|val
operator|&
name|PCIM_MSIX_VCTRL_MASK
operator|)
condition|)
block|{
name|val
operator||=
name|PCIM_MSIX_VCTRL_MASK
expr_stmt|;
name|bus_write_4
argument_list|(
name|msix
operator|->
name|msix_table_res
argument_list|,
name|offset
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|pci_unmask_msix
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|index
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|pcicfg_msix
modifier|*
name|msix
init|=
operator|&
name|dinfo
operator|->
name|cfg
operator|.
name|msix
decl_stmt|;
name|uint32_t
name|offset
decl_stmt|,
name|val
decl_stmt|;
name|KASSERT
argument_list|(
name|msix
operator|->
name|msix_table_len
operator|>
name|index
argument_list|,
operator|(
literal|"bogus index"
operator|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|msix
operator|->
name|msix_table_offset
operator|+
name|index
operator|*
literal|16
operator|+
literal|12
expr_stmt|;
name|val
operator|=
name|bus_read_4
argument_list|(
name|msix
operator|->
name|msix_table_res
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|PCIM_MSIX_VCTRL_MASK
condition|)
block|{
name|val
operator|&=
operator|~
name|PCIM_MSIX_VCTRL_MASK
expr_stmt|;
name|bus_write_4
argument_list|(
name|msix
operator|->
name|msix_table_res
argument_list|,
name|offset
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|pci_pending_msix
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|index
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|pcicfg_msix
modifier|*
name|msix
init|=
operator|&
name|dinfo
operator|->
name|cfg
operator|.
name|msix
decl_stmt|;
name|uint32_t
name|offset
decl_stmt|,
name|bit
decl_stmt|;
name|KASSERT
argument_list|(
name|msix
operator|->
name|msix_table_len
operator|>
name|index
argument_list|,
operator|(
literal|"bogus index"
operator|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|msix
operator|->
name|msix_pba_offset
operator|+
operator|(
name|index
operator|/
literal|32
operator|)
operator|*
literal|4
expr_stmt|;
name|bit
operator|=
literal|1
operator|<<
name|index
operator|%
literal|32
expr_stmt|;
return|return
operator|(
name|bus_read_4
argument_list|(
name|msix
operator|->
name|msix_pba_res
argument_list|,
name|offset
argument_list|)
operator|&
name|bit
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Restore MSI-X registers and table during resume.  If MSI-X is  * enabled then walk the virtual table to restore the actual MSI-X  * table.  */
end_comment

begin_function
specifier|static
name|void
name|pci_resume_msix
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|pcicfg_msix
modifier|*
name|msix
init|=
operator|&
name|dinfo
operator|->
name|cfg
operator|.
name|msix
decl_stmt|;
name|struct
name|msix_table_entry
modifier|*
name|mte
decl_stmt|;
name|struct
name|msix_vector
modifier|*
name|mv
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|msix
operator|->
name|msix_alloc
operator|>
literal|0
condition|)
block|{
comment|/* First, mask all vectors. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msix
operator|->
name|msix_msgnum
condition|;
name|i
operator|++
control|)
name|pci_mask_msix
argument_list|(
name|dev
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Second, program any messages with at least one handler. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msix
operator|->
name|msix_table_len
condition|;
name|i
operator|++
control|)
block|{
name|mte
operator|=
operator|&
name|msix
operator|->
name|msix_table
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|mte
operator|->
name|mte_vector
operator|==
literal|0
operator|||
name|mte
operator|->
name|mte_handlers
operator|==
literal|0
condition|)
continue|continue;
name|mv
operator|=
operator|&
name|msix
operator|->
name|msix_vectors
index|[
name|mte
operator|->
name|mte_vector
operator|-
literal|1
index|]
expr_stmt|;
name|pci_write_msix_entry
argument_list|(
name|dev
argument_list|,
name|i
argument_list|,
name|mv
operator|->
name|mv_address
argument_list|,
name|mv
operator|->
name|mv_data
argument_list|)
expr_stmt|;
name|pci_unmask_msix
argument_list|(
name|dev
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|msix
operator|->
name|msix_location
operator|+
name|PCIR_MSIX_CTRL
argument_list|,
name|msix
operator|->
name|msix_ctrl
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Attempt to allocate *count MSI-X messages.  The actual number allocated is  * returned in *count.  After this function returns, each message will be  * available to the driver as SYS_RES_IRQ resources starting at rid 1.  */
end_comment

begin_function
name|int
name|pci_alloc_msix_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
modifier|*
name|count
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
name|int
name|actual
decl_stmt|,
name|error
decl_stmt|,
name|i
decl_stmt|,
name|irq
decl_stmt|,
name|max
decl_stmt|;
comment|/* Don't let count == 0 get us into trouble. */
if|if
condition|(
operator|*
name|count
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* If rid 0 is allocated, then fail. */
name|rle
operator|=
name|resource_list_find
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rle
operator|!=
name|NULL
operator|&&
name|rle
operator|->
name|res
operator|!=
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Already have allocated messages? */
if|if
condition|(
name|cfg
operator|->
name|msi
operator|.
name|msi_alloc
operator|!=
literal|0
operator|||
name|cfg
operator|->
name|msix
operator|.
name|msix_alloc
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* If MSI-X is blacklisted for this system, fail. */
if|if
condition|(
name|pci_msix_blacklisted
argument_list|()
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* MSI-X capability present? */
if|if
condition|(
name|cfg
operator|->
name|msix
operator|.
name|msix_location
operator|==
literal|0
operator|||
operator|!
name|pci_do_msix
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
comment|/* Make sure the appropriate BARs are mapped. */
name|rle
operator|=
name|resource_list_find
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|cfg
operator|->
name|msix
operator|.
name|msix_table_bar
argument_list|)
expr_stmt|;
if|if
condition|(
name|rle
operator|==
name|NULL
operator|||
name|rle
operator|->
name|res
operator|==
name|NULL
operator|||
operator|!
operator|(
name|rman_get_flags
argument_list|(
name|rle
operator|->
name|res
argument_list|)
operator|&
name|RF_ACTIVE
operator|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|cfg
operator|->
name|msix
operator|.
name|msix_table_res
operator|=
name|rle
operator|->
name|res
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|msix
operator|.
name|msix_pba_bar
operator|!=
name|cfg
operator|->
name|msix
operator|.
name|msix_table_bar
condition|)
block|{
name|rle
operator|=
name|resource_list_find
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|cfg
operator|->
name|msix
operator|.
name|msix_pba_bar
argument_list|)
expr_stmt|;
if|if
condition|(
name|rle
operator|==
name|NULL
operator|||
name|rle
operator|->
name|res
operator|==
name|NULL
operator|||
operator|!
operator|(
name|rman_get_flags
argument_list|(
name|rle
operator|->
name|res
argument_list|)
operator|&
name|RF_ACTIVE
operator|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|cfg
operator|->
name|msix
operator|.
name|msix_pba_res
operator|=
name|rle
operator|->
name|res
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|child
argument_list|,
literal|"attempting to allocate %d MSI-X vectors (%d supported)\n"
argument_list|,
operator|*
name|count
argument_list|,
name|cfg
operator|->
name|msix
operator|.
name|msix_msgnum
argument_list|)
expr_stmt|;
name|max
operator|=
name|min
argument_list|(
operator|*
name|count
argument_list|,
name|cfg
operator|->
name|msix
operator|.
name|msix_msgnum
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
comment|/* Allocate a message. */
name|error
operator|=
name|PCIB_ALLOC_MSIX
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
operator|&
name|irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
break|break;
block|}
name|resource_list_add
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|irq
argument_list|,
name|irq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|actual
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|rle
operator|=
name|resource_list_find
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|actual
operator|==
literal|1
condition|)
name|device_printf
argument_list|(
name|child
argument_list|,
literal|"using IRQ %ju for MSI-X\n"
argument_list|,
name|rle
operator|->
name|start
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|run
decl_stmt|;
comment|/* 			 * Be fancy and try to print contiguous runs of 			 * IRQ values as ranges.  'irq' is the previous IRQ. 			 * 'run' is true if we are in a range. 			 */
name|device_printf
argument_list|(
name|child
argument_list|,
literal|"using IRQs %ju"
argument_list|,
name|rle
operator|->
name|start
argument_list|)
expr_stmt|;
name|irq
operator|=
name|rle
operator|->
name|start
expr_stmt|;
name|run
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|actual
condition|;
name|i
operator|++
control|)
block|{
name|rle
operator|=
name|resource_list_find
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Still in a run? */
if|if
condition|(
name|rle
operator|->
name|start
operator|==
name|irq
operator|+
literal|1
condition|)
block|{
name|run
operator|=
literal|1
expr_stmt|;
name|irq
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Finish previous range. */
if|if
condition|(
name|run
condition|)
block|{
name|printf
argument_list|(
literal|"-%d"
argument_list|,
name|irq
argument_list|)
expr_stmt|;
name|run
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Start new range. */
name|printf
argument_list|(
literal|",%ju"
argument_list|,
name|rle
operator|->
name|start
argument_list|)
expr_stmt|;
name|irq
operator|=
name|rle
operator|->
name|start
expr_stmt|;
block|}
comment|/* Unfinished range? */
if|if
condition|(
name|run
condition|)
name|printf
argument_list|(
literal|"-%d"
argument_list|,
name|irq
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" for MSI-X\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Mask all vectors. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cfg
operator|->
name|msix
operator|.
name|msix_msgnum
condition|;
name|i
operator|++
control|)
name|pci_mask_msix
argument_list|(
name|child
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Allocate and initialize vector data and virtual table. */
name|cfg
operator|->
name|msix
operator|.
name|msix_vectors
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|msix_vector
argument_list|)
operator|*
name|actual
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|msix
operator|.
name|msix_table
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|msix_table_entry
argument_list|)
operator|*
name|actual
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|actual
condition|;
name|i
operator|++
control|)
block|{
name|rle
operator|=
name|resource_list_find
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|msix
operator|.
name|msix_vectors
index|[
name|i
index|]
operator|.
name|mv_irq
operator|=
name|rle
operator|->
name|start
expr_stmt|;
name|cfg
operator|->
name|msix
operator|.
name|msix_table
index|[
name|i
index|]
operator|.
name|mte_vector
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
comment|/* Update control register to enable MSI-X. */
name|cfg
operator|->
name|msix
operator|.
name|msix_ctrl
operator||=
name|PCIM_MSIXCTRL_MSIX_ENABLE
expr_stmt|;
name|pci_write_config
argument_list|(
name|child
argument_list|,
name|cfg
operator|->
name|msix
operator|.
name|msix_location
operator|+
name|PCIR_MSIX_CTRL
argument_list|,
name|cfg
operator|->
name|msix
operator|.
name|msix_ctrl
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Update counts of alloc'd messages. */
name|cfg
operator|->
name|msix
operator|.
name|msix_alloc
operator|=
name|actual
expr_stmt|;
name|cfg
operator|->
name|msix
operator|.
name|msix_table_len
operator|=
name|actual
expr_stmt|;
operator|*
name|count
operator|=
name|actual
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * By default, pci_alloc_msix() will assign the allocated IRQ  * resources consecutively to the first N messages in the MSI-X table.  * However, device drivers may want to use different layouts if they  * either receive fewer messages than they asked for, or they wish to  * populate the MSI-X table sparsely.  This method allows the driver  * to specify what layout it wants.  It must be called after a  * successful pci_alloc_msix() but before any of the associated  * SYS_RES_IRQ resources are allocated via bus_alloc_resource().  *  * The 'vectors' array contains 'count' message vectors.  The array  * maps directly to the MSI-X table in that index 0 in the array  * specifies the vector for the first message in the MSI-X table, etc.  * The vector value in each array index can either be 0 to indicate  * that no vector should be assigned to a message slot, or it can be a  * number from 1 to N (where N is the count returned from a  * succcessful call to pci_alloc_msix()) to indicate which message  * vector (IRQ) to be used for the corresponding message.  *  * On successful return, each message with a non-zero vector will have  * an associated SYS_RES_IRQ whose rid is equal to the array index +  * 1.  Additionally, if any of the IRQs allocated via the previous  * call to pci_alloc_msix() are not used in the mapping, those IRQs  * will be freed back to the system automatically.  *  * For example, suppose a driver has a MSI-X table with 6 messages and  * asks for 6 messages, but pci_alloc_msix() only returns a count of  * 3.  Call the three vectors allocated by pci_alloc_msix() A, B, and  * C.  After the call to pci_alloc_msix(), the device will be setup to  * have an MSI-X table of ABC--- (where - means no vector assigned).  * If the driver then passes a vector array of { 1, 0, 1, 2, 0, 2 },  * then the MSI-X table will look like A-AB-B, and the 'C' vector will  * be freed back to the system.  This device will also have valid  * SYS_RES_IRQ rids of 1, 3, 4, and 6.  *  * In any case, the SYS_RES_IRQ rid X will always map to the message  * at MSI-X table index X - 1 and will only be valid if a vector is  * assigned to that table entry.  */
end_comment

begin_function
name|int
name|pci_remap_msix_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|count
parameter_list|,
specifier|const
name|u_int
modifier|*
name|vectors
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|struct
name|pcicfg_msix
modifier|*
name|msix
init|=
operator|&
name|dinfo
operator|->
name|cfg
operator|.
name|msix
decl_stmt|;
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
name|int
name|i
decl_stmt|,
name|irq
decl_stmt|,
name|j
decl_stmt|,
modifier|*
name|used
decl_stmt|;
comment|/* 	 * Have to have at least one message in the table but the 	 * table can't be bigger than the actual MSI-X table in the 	 * device. 	 */
if|if
condition|(
name|count
operator|==
literal|0
operator|||
name|count
operator|>
name|msix
operator|->
name|msix_msgnum
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Sanity check the vectors. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|vectors
index|[
name|i
index|]
operator|>
name|msix
operator|->
name|msix_alloc
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Make sure there aren't any holes in the vectors to be used. 	 * It's a big pain to support it, and it doesn't really make 	 * sense anyway.  Also, at least one vector must be used. 	 */
name|used
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|msix
operator|->
name|msix_alloc
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|vectors
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|used
index|[
name|vectors
index|[
name|i
index|]
operator|-
literal|1
index|]
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msix
operator|->
name|msix_alloc
operator|-
literal|1
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|used
index|[
name|i
index|]
operator|==
literal|0
operator|&&
name|used
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|1
condition|)
block|{
name|free
argument_list|(
name|used
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|used
index|[
literal|0
index|]
operator|!=
literal|1
condition|)
block|{
name|free
argument_list|(
name|used
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Make sure none of the resources are allocated. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msix
operator|->
name|msix_table_len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|msix
operator|->
name|msix_table
index|[
name|i
index|]
operator|.
name|mte_vector
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|msix
operator|->
name|msix_table
index|[
name|i
index|]
operator|.
name|mte_handlers
operator|>
literal|0
condition|)
block|{
name|free
argument_list|(
name|used
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|rle
operator|=
name|resource_list_find
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|rle
operator|!=
name|NULL
argument_list|,
operator|(
literal|"missing resource"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rle
operator|->
name|res
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|used
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
block|}
comment|/* Free the existing resource list entries. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msix
operator|->
name|msix_table_len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|msix
operator|->
name|msix_table
index|[
name|i
index|]
operator|.
name|mte_vector
operator|==
literal|0
condition|)
continue|continue;
name|resource_list_delete
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Build the new virtual table keeping track of which vectors are 	 * used. 	 */
name|free
argument_list|(
name|msix
operator|->
name|msix_table
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|msix
operator|->
name|msix_table
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|msix_table_entry
argument_list|)
operator|*
name|count
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|msix
operator|->
name|msix_table
index|[
name|i
index|]
operator|.
name|mte_vector
operator|=
name|vectors
index|[
name|i
index|]
expr_stmt|;
name|msix
operator|->
name|msix_table_len
operator|=
name|count
expr_stmt|;
comment|/* Free any unused IRQs and resize the vectors array if necessary. */
name|j
operator|=
name|msix
operator|->
name|msix_alloc
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|used
index|[
name|j
index|]
operator|==
literal|0
condition|)
block|{
name|struct
name|msix_vector
modifier|*
name|vec
decl_stmt|;
while|while
condition|(
name|used
index|[
name|j
index|]
operator|==
literal|0
condition|)
block|{
name|PCIB_RELEASE_MSIX
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|msix
operator|->
name|msix_vectors
index|[
name|j
index|]
operator|.
name|mv_irq
argument_list|)
expr_stmt|;
name|j
operator|--
expr_stmt|;
block|}
name|vec
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|msix_vector
argument_list|)
operator|*
operator|(
name|j
operator|+
literal|1
operator|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|msix
operator|->
name|msix_vectors
argument_list|,
name|vec
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|msix_vector
argument_list|)
operator|*
operator|(
name|j
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|msix
operator|->
name|msix_vectors
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|msix
operator|->
name|msix_vectors
operator|=
name|vec
expr_stmt|;
name|msix
operator|->
name|msix_alloc
operator|=
name|j
operator|+
literal|1
expr_stmt|;
block|}
name|free
argument_list|(
name|used
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
comment|/* Map the IRQs onto the rids. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|vectors
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
name|irq
operator|=
name|msix
operator|->
name|msix_vectors
index|[
name|vectors
index|[
name|i
index|]
operator|-
literal|1
index|]
operator|.
name|mv_irq
expr_stmt|;
name|resource_list_add
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|irq
argument_list|,
name|irq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|child
argument_list|,
literal|"Remapped MSI-X IRQs as: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
if|if
condition|(
name|vectors
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"---"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|msix
operator|->
name|msix_vectors
index|[
name|vectors
index|[
name|i
index|]
operator|-
literal|1
index|]
operator|.
name|mv_irq
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pci_release_msix
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|struct
name|pcicfg_msix
modifier|*
name|msix
init|=
operator|&
name|dinfo
operator|->
name|cfg
operator|.
name|msix
decl_stmt|;
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Do we have any messages to release? */
if|if
condition|(
name|msix
operator|->
name|msix_alloc
operator|==
literal|0
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
comment|/* Make sure none of the resources are allocated. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msix
operator|->
name|msix_table_len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|msix
operator|->
name|msix_table
index|[
name|i
index|]
operator|.
name|mte_vector
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|msix
operator|->
name|msix_table
index|[
name|i
index|]
operator|.
name|mte_handlers
operator|>
literal|0
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|rle
operator|=
name|resource_list_find
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|rle
operator|!=
name|NULL
argument_list|,
operator|(
literal|"missing resource"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rle
operator|->
name|res
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
comment|/* Update control register to disable MSI-X. */
name|msix
operator|->
name|msix_ctrl
operator|&=
operator|~
name|PCIM_MSIXCTRL_MSIX_ENABLE
expr_stmt|;
name|pci_write_config
argument_list|(
name|child
argument_list|,
name|msix
operator|->
name|msix_location
operator|+
name|PCIR_MSIX_CTRL
argument_list|,
name|msix
operator|->
name|msix_ctrl
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Free the resource list entries. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msix
operator|->
name|msix_table_len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|msix
operator|->
name|msix_table
index|[
name|i
index|]
operator|.
name|mte_vector
operator|==
literal|0
condition|)
continue|continue;
name|resource_list_delete
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|msix
operator|->
name|msix_table
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|msix
operator|->
name|msix_table_len
operator|=
literal|0
expr_stmt|;
comment|/* Release the IRQs. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msix
operator|->
name|msix_alloc
condition|;
name|i
operator|++
control|)
name|PCIB_RELEASE_MSIX
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|msix
operator|->
name|msix_vectors
index|[
name|i
index|]
operator|.
name|mv_irq
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|msix
operator|->
name|msix_vectors
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|msix
operator|->
name|msix_alloc
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the max supported MSI-X messages this device supports.  * Basically, assuming the MD code can alloc messages, this function  * should return the maximum value that pci_alloc_msix() can return.  * Thus, it is subject to the tunables, etc.  */
end_comment

begin_function
name|int
name|pci_msix_count_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|struct
name|pcicfg_msix
modifier|*
name|msix
init|=
operator|&
name|dinfo
operator|->
name|cfg
operator|.
name|msix
decl_stmt|;
if|if
condition|(
name|pci_do_msix
operator|&&
name|msix
operator|->
name|msix_location
operator|!=
literal|0
condition|)
return|return
operator|(
name|msix
operator|->
name|msix_msgnum
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_msix_pba_bar_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|struct
name|pcicfg_msix
modifier|*
name|msix
init|=
operator|&
name|dinfo
operator|->
name|cfg
operator|.
name|msix
decl_stmt|;
if|if
condition|(
name|pci_do_msix
operator|&&
name|msix
operator|->
name|msix_location
operator|!=
literal|0
condition|)
return|return
operator|(
name|msix
operator|->
name|msix_pba_bar
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_msix_table_bar_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|struct
name|pcicfg_msix
modifier|*
name|msix
init|=
operator|&
name|dinfo
operator|->
name|cfg
operator|.
name|msix
decl_stmt|;
if|if
condition|(
name|pci_do_msix
operator|&&
name|msix
operator|->
name|msix_location
operator|!=
literal|0
condition|)
return|return
operator|(
name|msix
operator|->
name|msix_table_bar
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * HyperTransport MSI mapping control  */
end_comment

begin_function
name|void
name|pci_ht_map_msi
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|uint64_t
name|addr
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|pcicfg_ht
modifier|*
name|ht
init|=
operator|&
name|dinfo
operator|->
name|cfg
operator|.
name|ht
decl_stmt|;
if|if
condition|(
operator|!
name|ht
operator|->
name|ht_msimap
condition|)
return|return;
if|if
condition|(
name|addr
operator|&&
operator|!
operator|(
name|ht
operator|->
name|ht_msictrl
operator|&
name|PCIM_HTCMD_MSI_ENABLE
operator|)
operator|&&
name|ht
operator|->
name|ht_msiaddr
operator|>>
literal|20
operator|==
name|addr
operator|>>
literal|20
condition|)
block|{
comment|/* Enable MSI -> HT mapping. */
name|ht
operator|->
name|ht_msictrl
operator||=
name|PCIM_HTCMD_MSI_ENABLE
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|ht
operator|->
name|ht_msimap
operator|+
name|PCIR_HT_COMMAND
argument_list|,
name|ht
operator|->
name|ht_msictrl
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|addr
operator|&&
name|ht
operator|->
name|ht_msictrl
operator|&
name|PCIM_HTCMD_MSI_ENABLE
condition|)
block|{
comment|/* Disable MSI -> HT mapping. */
name|ht
operator|->
name|ht_msictrl
operator|&=
operator|~
name|PCIM_HTCMD_MSI_ENABLE
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|ht
operator|->
name|ht_msimap
operator|+
name|PCIR_HT_COMMAND
argument_list|,
name|ht
operator|->
name|ht_msictrl
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|pci_get_max_payload
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|cap
decl_stmt|;
name|uint16_t
name|val
decl_stmt|;
name|cap
operator|=
name|dinfo
operator|->
name|cfg
operator|.
name|pcie
operator|.
name|pcie_location
expr_stmt|;
if|if
condition|(
name|cap
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|val
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|cap
operator|+
name|PCIER_DEVICE_CTL
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|val
operator|&=
name|PCIEM_CTL_MAX_PAYLOAD
expr_stmt|;
name|val
operator|>>=
literal|5
expr_stmt|;
return|return
operator|(
literal|1
operator|<<
operator|(
name|val
operator|+
literal|7
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_get_max_read_req
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|cap
decl_stmt|;
name|uint16_t
name|val
decl_stmt|;
name|cap
operator|=
name|dinfo
operator|->
name|cfg
operator|.
name|pcie
operator|.
name|pcie_location
expr_stmt|;
if|if
condition|(
name|cap
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|val
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|cap
operator|+
name|PCIER_DEVICE_CTL
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|val
operator|&=
name|PCIEM_CTL_MAX_READ_REQUEST
expr_stmt|;
name|val
operator|>>=
literal|12
expr_stmt|;
return|return
operator|(
literal|1
operator|<<
operator|(
name|val
operator|+
literal|7
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_set_max_read_req
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|cap
decl_stmt|;
name|uint16_t
name|val
decl_stmt|;
name|cap
operator|=
name|dinfo
operator|->
name|cfg
operator|.
name|pcie
operator|.
name|pcie_location
expr_stmt|;
if|if
condition|(
name|cap
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|size
operator|<
literal|128
condition|)
name|size
operator|=
literal|128
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|4096
condition|)
name|size
operator|=
literal|4096
expr_stmt|;
name|size
operator|=
operator|(
literal|1
operator|<<
operator|(
name|fls
argument_list|(
name|size
argument_list|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|val
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|cap
operator|+
name|PCIER_DEVICE_CTL
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|PCIEM_CTL_MAX_READ_REQUEST
expr_stmt|;
name|val
operator||=
operator|(
name|fls
argument_list|(
name|size
argument_list|)
operator|-
literal|8
operator|)
operator|<<
literal|12
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|cap
operator|+
name|PCIER_DEVICE_CTL
argument_list|,
name|val
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
name|size
operator|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|pcie_read_config
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|width
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|cap
decl_stmt|;
name|cap
operator|=
name|dinfo
operator|->
name|cfg
operator|.
name|pcie
operator|.
name|pcie_location
expr_stmt|;
if|if
condition|(
name|cap
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|width
operator|==
literal|2
condition|)
return|return
operator|(
literal|0xffff
operator|)
return|;
return|return
operator|(
literal|0xffffffff
operator|)
return|;
block|}
return|return
operator|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|cap
operator|+
name|reg
argument_list|,
name|width
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pcie_write_config
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|reg
parameter_list|,
name|uint32_t
name|value
parameter_list|,
name|int
name|width
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|cap
decl_stmt|;
name|cap
operator|=
name|dinfo
operator|->
name|cfg
operator|.
name|pcie
operator|.
name|pcie_location
expr_stmt|;
if|if
condition|(
name|cap
operator|==
literal|0
condition|)
return|return;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|cap
operator|+
name|reg
argument_list|,
name|value
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Adjusts a PCI-e capability register by clearing the bits in mask  * and setting the bits in (value& mask).  Bits not set in mask are  * not adjusted.  *  * Returns the old value on success or all ones on failure.  */
end_comment

begin_function
name|uint32_t
name|pcie_adjust_config
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|reg
parameter_list|,
name|uint32_t
name|mask
parameter_list|,
name|uint32_t
name|value
parameter_list|,
name|int
name|width
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint32_t
name|old
decl_stmt|,
name|new
decl_stmt|;
name|int
name|cap
decl_stmt|;
name|cap
operator|=
name|dinfo
operator|->
name|cfg
operator|.
name|pcie
operator|.
name|pcie_location
expr_stmt|;
if|if
condition|(
name|cap
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|width
operator|==
literal|2
condition|)
return|return
operator|(
literal|0xffff
operator|)
return|;
return|return
operator|(
literal|0xffffffff
operator|)
return|;
block|}
name|old
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|cap
operator|+
name|reg
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|new
operator|=
name|old
operator|&
operator|~
name|mask
expr_stmt|;
name|new
operator||=
operator|(
name|value
operator|&
name|mask
operator|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|cap
operator|+
name|reg
argument_list|,
name|new
argument_list|,
name|width
argument_list|)
expr_stmt|;
return|return
operator|(
name|old
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Support for MSI message signalled interrupts.  */
end_comment

begin_function
name|void
name|pci_enable_msi_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|uint64_t
name|address
parameter_list|,
name|uint16_t
name|data
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|struct
name|pcicfg_msi
modifier|*
name|msi
init|=
operator|&
name|dinfo
operator|->
name|cfg
operator|.
name|msi
decl_stmt|;
comment|/* Write data and address values. */
name|pci_write_config
argument_list|(
name|child
argument_list|,
name|msi
operator|->
name|msi_location
operator|+
name|PCIR_MSI_ADDR
argument_list|,
name|address
operator|&
literal|0xffffffff
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|msi
operator|->
name|msi_ctrl
operator|&
name|PCIM_MSICTRL_64BIT
condition|)
block|{
name|pci_write_config
argument_list|(
name|child
argument_list|,
name|msi
operator|->
name|msi_location
operator|+
name|PCIR_MSI_ADDR_HIGH
argument_list|,
name|address
operator|>>
literal|32
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|child
argument_list|,
name|msi
operator|->
name|msi_location
operator|+
name|PCIR_MSI_DATA_64BIT
argument_list|,
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
name|pci_write_config
argument_list|(
name|child
argument_list|,
name|msi
operator|->
name|msi_location
operator|+
name|PCIR_MSI_DATA
argument_list|,
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Enable MSI in the control register. */
name|msi
operator|->
name|msi_ctrl
operator||=
name|PCIM_MSICTRL_MSI_ENABLE
expr_stmt|;
name|pci_write_config
argument_list|(
name|child
argument_list|,
name|msi
operator|->
name|msi_location
operator|+
name|PCIR_MSI_CTRL
argument_list|,
name|msi
operator|->
name|msi_ctrl
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Enable MSI -> HT mapping. */
name|pci_ht_map_msi
argument_list|(
name|child
argument_list|,
name|address
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pci_disable_msi_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|struct
name|pcicfg_msi
modifier|*
name|msi
init|=
operator|&
name|dinfo
operator|->
name|cfg
operator|.
name|msi
decl_stmt|;
comment|/* Disable MSI -> HT mapping. */
name|pci_ht_map_msi
argument_list|(
name|child
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Disable MSI in the control register. */
name|msi
operator|->
name|msi_ctrl
operator|&=
operator|~
name|PCIM_MSICTRL_MSI_ENABLE
expr_stmt|;
name|pci_write_config
argument_list|(
name|child
argument_list|,
name|msi
operator|->
name|msi_location
operator|+
name|PCIR_MSI_CTRL
argument_list|,
name|msi
operator|->
name|msi_ctrl
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Restore MSI registers during resume.  If MSI is enabled then  * restore the data and address registers in addition to the control  * register.  */
end_comment

begin_function
specifier|static
name|void
name|pci_resume_msi
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|pcicfg_msi
modifier|*
name|msi
init|=
operator|&
name|dinfo
operator|->
name|cfg
operator|.
name|msi
decl_stmt|;
name|uint64_t
name|address
decl_stmt|;
name|uint16_t
name|data
decl_stmt|;
if|if
condition|(
name|msi
operator|->
name|msi_ctrl
operator|&
name|PCIM_MSICTRL_MSI_ENABLE
condition|)
block|{
name|address
operator|=
name|msi
operator|->
name|msi_addr
expr_stmt|;
name|data
operator|=
name|msi
operator|->
name|msi_data
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|msi
operator|->
name|msi_location
operator|+
name|PCIR_MSI_ADDR
argument_list|,
name|address
operator|&
literal|0xffffffff
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|msi
operator|->
name|msi_ctrl
operator|&
name|PCIM_MSICTRL_64BIT
condition|)
block|{
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|msi
operator|->
name|msi_location
operator|+
name|PCIR_MSI_ADDR_HIGH
argument_list|,
name|address
operator|>>
literal|32
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|msi
operator|->
name|msi_location
operator|+
name|PCIR_MSI_DATA_64BIT
argument_list|,
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|msi
operator|->
name|msi_location
operator|+
name|PCIR_MSI_DATA
argument_list|,
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|msi
operator|->
name|msi_location
operator|+
name|PCIR_MSI_CTRL
argument_list|,
name|msi
operator|->
name|msi_ctrl
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pci_remap_intr_method
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|u_int
name|irq
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
name|struct
name|msix_table_entry
modifier|*
name|mte
decl_stmt|;
name|struct
name|msix_vector
modifier|*
name|mv
decl_stmt|;
name|uint64_t
name|addr
decl_stmt|;
name|uint32_t
name|data
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* 	 * Handle MSI first.  We try to find this IRQ among our list 	 * of MSI IRQs.  If we find it, we request updated address and 	 * data registers and apply the results. 	 */
if|if
condition|(
name|cfg
operator|->
name|msi
operator|.
name|msi_alloc
operator|>
literal|0
condition|)
block|{
comment|/* If we don't have any active handlers, nothing to do. */
if|if
condition|(
name|cfg
operator|->
name|msi
operator|.
name|msi_handlers
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cfg
operator|->
name|msi
operator|.
name|msi_alloc
condition|;
name|i
operator|++
control|)
block|{
name|rle
operator|=
name|resource_list_find
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rle
operator|->
name|start
operator|==
name|irq
condition|)
block|{
name|error
operator|=
name|PCIB_MAP_MSI
argument_list|(
name|device_get_parent
argument_list|(
name|bus
argument_list|)
argument_list|,
name|dev
argument_list|,
name|irq
argument_list|,
operator|&
name|addr
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|pci_disable_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|msi
operator|.
name|msi_addr
operator|=
name|addr
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|msi
operator|.
name|msi_data
operator|=
name|data
expr_stmt|;
name|pci_enable_msi
argument_list|(
name|dev
argument_list|,
name|addr
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
comment|/* 	 * For MSI-X, we check to see if we have this IRQ.  If we do, 	 * we request the updated mapping info.  If that works, we go 	 * through all the slots that use this IRQ and update them. 	 */
if|if
condition|(
name|cfg
operator|->
name|msix
operator|.
name|msix_alloc
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cfg
operator|->
name|msix
operator|.
name|msix_alloc
condition|;
name|i
operator|++
control|)
block|{
name|mv
operator|=
operator|&
name|cfg
operator|->
name|msix
operator|.
name|msix_vectors
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|mv
operator|->
name|mv_irq
operator|==
name|irq
condition|)
block|{
name|error
operator|=
name|PCIB_MAP_MSI
argument_list|(
name|device_get_parent
argument_list|(
name|bus
argument_list|)
argument_list|,
name|dev
argument_list|,
name|irq
argument_list|,
operator|&
name|addr
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|mv
operator|->
name|mv_address
operator|=
name|addr
expr_stmt|;
name|mv
operator|->
name|mv_data
operator|=
name|data
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|cfg
operator|->
name|msix
operator|.
name|msix_table_len
condition|;
name|j
operator|++
control|)
block|{
name|mte
operator|=
operator|&
name|cfg
operator|->
name|msix
operator|.
name|msix_table
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|mte
operator|->
name|mte_vector
operator|!=
name|i
operator|+
literal|1
condition|)
continue|continue;
if|if
condition|(
name|mte
operator|->
name|mte_handlers
operator|==
literal|0
condition|)
continue|continue;
name|pci_mask_msix
argument_list|(
name|dev
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|pci_enable_msix
argument_list|(
name|dev
argument_list|,
name|j
argument_list|,
name|addr
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|pci_unmask_msix
argument_list|(
name|dev
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns true if the specified device is blacklisted because MSI  * doesn't work.  */
end_comment

begin_function
name|int
name|pci_msi_device_blacklisted
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
operator|!
name|pci_honor_msi_blacklist
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|pci_has_quirk
argument_list|(
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
argument_list|,
name|PCI_QUIRK_DISABLE_MSI
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine if MSI is blacklisted globally on this system.  Currently,  * we just check for blacklisted chipsets as represented by the  * host-PCI bridge at device 0:0:0.  In the future, it may become  * necessary to check other system attributes, such as the kenv values  * that give the motherboard manufacturer and model number.  */
end_comment

begin_function
specifier|static
name|int
name|pci_msi_blacklisted
parameter_list|(
name|void
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
if|if
condition|(
operator|!
name|pci_honor_msi_blacklist
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Blacklist all non-PCI-express and non-PCI-X chipsets. */
if|if
condition|(
operator|!
operator|(
name|pcie_chipset
operator|||
name|pcix_chipset
operator|)
condition|)
block|{
if|if
condition|(
name|vm_guest
operator|!=
name|VM_GUEST_NO
condition|)
block|{
comment|/* 			 * Whitelist older chipsets in virtual 			 * machines known to support MSI. 			 */
name|dev
operator|=
name|pci_find_bsf
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|!=
name|NULL
condition|)
return|return
operator|(
operator|!
name|pci_has_quirk
argument_list|(
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
argument_list|,
name|PCI_QUIRK_ENABLE_MSI_VM
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|dev
operator|=
name|pci_find_bsf
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|!=
name|NULL
condition|)
return|return
operator|(
name|pci_msi_device_blacklisted
argument_list|(
name|dev
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns true if the specified device is blacklisted because MSI-X  * doesn't work.  Note that this assumes that if MSI doesn't work,  * MSI-X doesn't either.  */
end_comment

begin_function
name|int
name|pci_msix_device_blacklisted
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
operator|!
name|pci_honor_msi_blacklist
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|pci_has_quirk
argument_list|(
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
argument_list|,
name|PCI_QUIRK_DISABLE_MSIX
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
name|pci_msi_device_blacklisted
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine if MSI-X is blacklisted globally on this system.  If MSI  * is blacklisted, assume that MSI-X is as well.  Check for additional  * chipsets where MSI works but MSI-X does not.  */
end_comment

begin_function
specifier|static
name|int
name|pci_msix_blacklisted
parameter_list|(
name|void
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
if|if
condition|(
operator|!
name|pci_honor_msi_blacklist
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|dev
operator|=
name|pci_find_bsf
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|!=
name|NULL
operator|&&
name|pci_has_quirk
argument_list|(
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
argument_list|,
name|PCI_QUIRK_DISABLE_MSIX
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
name|pci_msi_blacklisted
argument_list|()
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attempt to allocate *count MSI messages.  The actual number allocated is  * returned in *count.  After this function returns, each message will be  * available to the driver as SYS_RES_IRQ resources starting at a rid 1.  */
end_comment

begin_function
name|int
name|pci_alloc_msi_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
modifier|*
name|count
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
name|int
name|actual
decl_stmt|,
name|error
decl_stmt|,
name|i
decl_stmt|,
name|irqs
index|[
literal|32
index|]
decl_stmt|;
name|uint16_t
name|ctrl
decl_stmt|;
comment|/* Don't let count == 0 get us into trouble. */
if|if
condition|(
operator|*
name|count
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* If rid 0 is allocated, then fail. */
name|rle
operator|=
name|resource_list_find
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rle
operator|!=
name|NULL
operator|&&
name|rle
operator|->
name|res
operator|!=
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Already have allocated messages? */
if|if
condition|(
name|cfg
operator|->
name|msi
operator|.
name|msi_alloc
operator|!=
literal|0
operator|||
name|cfg
operator|->
name|msix
operator|.
name|msix_alloc
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* If MSI is blacklisted for this system, fail. */
if|if
condition|(
name|pci_msi_blacklisted
argument_list|()
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* MSI capability present? */
if|if
condition|(
name|cfg
operator|->
name|msi
operator|.
name|msi_location
operator|==
literal|0
operator|||
operator|!
name|pci_do_msi
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|child
argument_list|,
literal|"attempting to allocate %d MSI vectors (%d supported)\n"
argument_list|,
operator|*
name|count
argument_list|,
name|cfg
operator|->
name|msi
operator|.
name|msi_msgnum
argument_list|)
expr_stmt|;
comment|/* Don't ask for more than the device supports. */
name|actual
operator|=
name|min
argument_list|(
operator|*
name|count
argument_list|,
name|cfg
operator|->
name|msi
operator|.
name|msi_msgnum
argument_list|)
expr_stmt|;
comment|/* Don't ask for more than 32 messages. */
name|actual
operator|=
name|min
argument_list|(
name|actual
argument_list|,
literal|32
argument_list|)
expr_stmt|;
comment|/* MSI requires power of 2 number of messages. */
if|if
condition|(
operator|!
name|powerof2
argument_list|(
name|actual
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Try to allocate N messages. */
name|error
operator|=
name|PCIB_ALLOC_MSI
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|actual
argument_list|,
name|actual
argument_list|,
name|irqs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|actual
operator|==
literal|1
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Try N / 2. */
name|actual
operator|>>=
literal|1
expr_stmt|;
block|}
comment|/* 	 * We now have N actual messages mapped onto SYS_RES_IRQ 	 * resources in the irqs[] array, so add new resources 	 * starting at rid 1. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|actual
condition|;
name|i
operator|++
control|)
name|resource_list_add
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|irqs
index|[
name|i
index|]
argument_list|,
name|irqs
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
if|if
condition|(
name|actual
operator|==
literal|1
condition|)
name|device_printf
argument_list|(
name|child
argument_list|,
literal|"using IRQ %d for MSI\n"
argument_list|,
name|irqs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|run
decl_stmt|;
comment|/* 			 * Be fancy and try to print contiguous runs 			 * of IRQ values as ranges.  'run' is true if 			 * we are in a range. 			 */
name|device_printf
argument_list|(
name|child
argument_list|,
literal|"using IRQs %d"
argument_list|,
name|irqs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|run
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|actual
condition|;
name|i
operator|++
control|)
block|{
comment|/* Still in a run? */
if|if
condition|(
name|irqs
index|[
name|i
index|]
operator|==
name|irqs
index|[
name|i
operator|-
literal|1
index|]
operator|+
literal|1
condition|)
block|{
name|run
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* Finish previous range. */
if|if
condition|(
name|run
condition|)
block|{
name|printf
argument_list|(
literal|"-%d"
argument_list|,
name|irqs
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|run
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Start new range. */
name|printf
argument_list|(
literal|",%d"
argument_list|,
name|irqs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Unfinished range? */
if|if
condition|(
name|run
condition|)
name|printf
argument_list|(
literal|"-%d"
argument_list|,
name|irqs
index|[
name|actual
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" for MSI\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Update control register with actual count. */
name|ctrl
operator|=
name|cfg
operator|->
name|msi
operator|.
name|msi_ctrl
expr_stmt|;
name|ctrl
operator|&=
operator|~
name|PCIM_MSICTRL_MME_MASK
expr_stmt|;
name|ctrl
operator||=
operator|(
name|ffs
argument_list|(
name|actual
argument_list|)
operator|-
literal|1
operator|)
operator|<<
literal|4
expr_stmt|;
name|cfg
operator|->
name|msi
operator|.
name|msi_ctrl
operator|=
name|ctrl
expr_stmt|;
name|pci_write_config
argument_list|(
name|child
argument_list|,
name|cfg
operator|->
name|msi
operator|.
name|msi_location
operator|+
name|PCIR_MSI_CTRL
argument_list|,
name|ctrl
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Update counts of alloc'd messages. */
name|cfg
operator|->
name|msi
operator|.
name|msi_alloc
operator|=
name|actual
expr_stmt|;
name|cfg
operator|->
name|msi
operator|.
name|msi_handlers
operator|=
literal|0
expr_stmt|;
operator|*
name|count
operator|=
name|actual
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Release the MSI messages associated with this device. */
end_comment

begin_function
name|int
name|pci_release_msi_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|struct
name|pcicfg_msi
modifier|*
name|msi
init|=
operator|&
name|dinfo
operator|->
name|cfg
operator|.
name|msi
decl_stmt|;
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|irqs
index|[
literal|32
index|]
decl_stmt|;
comment|/* Try MSI-X first. */
name|error
operator|=
name|pci_release_msix
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENODEV
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Do we have any messages to release? */
if|if
condition|(
name|msi
operator|->
name|msi_alloc
operator|==
literal|0
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
name|KASSERT
argument_list|(
name|msi
operator|->
name|msi_alloc
operator|<=
literal|32
argument_list|,
operator|(
literal|"more than 32 alloc'd messages"
operator|)
argument_list|)
expr_stmt|;
comment|/* Make sure none of the resources are allocated. */
if|if
condition|(
name|msi
operator|->
name|msi_handlers
operator|>
literal|0
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msi
operator|->
name|msi_alloc
condition|;
name|i
operator|++
control|)
block|{
name|rle
operator|=
name|resource_list_find
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|rle
operator|!=
name|NULL
argument_list|,
operator|(
literal|"missing MSI resource"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rle
operator|->
name|res
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|irqs
index|[
name|i
index|]
operator|=
name|rle
operator|->
name|start
expr_stmt|;
block|}
comment|/* Update control register with 0 count. */
name|KASSERT
argument_list|(
operator|!
operator|(
name|msi
operator|->
name|msi_ctrl
operator|&
name|PCIM_MSICTRL_MSI_ENABLE
operator|)
argument_list|,
operator|(
literal|"%s: MSI still enabled"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|msi
operator|->
name|msi_ctrl
operator|&=
operator|~
name|PCIM_MSICTRL_MME_MASK
expr_stmt|;
name|pci_write_config
argument_list|(
name|child
argument_list|,
name|msi
operator|->
name|msi_location
operator|+
name|PCIR_MSI_CTRL
argument_list|,
name|msi
operator|->
name|msi_ctrl
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Release the messages. */
name|PCIB_RELEASE_MSI
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|msi
operator|->
name|msi_alloc
argument_list|,
name|irqs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msi
operator|->
name|msi_alloc
condition|;
name|i
operator|++
control|)
name|resource_list_delete
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Update alloc count. */
name|msi
operator|->
name|msi_alloc
operator|=
literal|0
expr_stmt|;
name|msi
operator|->
name|msi_addr
operator|=
literal|0
expr_stmt|;
name|msi
operator|->
name|msi_data
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the max supported MSI messages this device supports.  * Basically, assuming the MD code can alloc messages, this function  * should return the maximum value that pci_alloc_msi() can return.  * Thus, it is subject to the tunables, etc.  */
end_comment

begin_function
name|int
name|pci_msi_count_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|struct
name|pcicfg_msi
modifier|*
name|msi
init|=
operator|&
name|dinfo
operator|->
name|cfg
operator|.
name|msi
decl_stmt|;
if|if
condition|(
name|pci_do_msi
operator|&&
name|msi
operator|->
name|msi_location
operator|!=
literal|0
condition|)
return|return
operator|(
name|msi
operator|->
name|msi_msgnum
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* free pcicfgregs structure and all depending data structures */
end_comment

begin_function
name|int
name|pci_freecfg
parameter_list|(
name|struct
name|pci_devinfo
modifier|*
name|dinfo
parameter_list|)
block|{
name|struct
name|devlist
modifier|*
name|devlist_head
decl_stmt|;
name|struct
name|pci_map
modifier|*
name|pm
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|int
name|i
decl_stmt|;
name|devlist_head
operator|=
operator|&
name|pci_devq
expr_stmt|;
if|if
condition|(
name|dinfo
operator|->
name|cfg
operator|.
name|vpd
operator|.
name|vpd_reg
condition|)
block|{
name|free
argument_list|(
name|dinfo
operator|->
name|cfg
operator|.
name|vpd
operator|.
name|vpd_ident
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dinfo
operator|->
name|cfg
operator|.
name|vpd
operator|.
name|vpd_rocnt
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|dinfo
operator|->
name|cfg
operator|.
name|vpd
operator|.
name|vpd_ros
index|[
name|i
index|]
operator|.
name|value
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dinfo
operator|->
name|cfg
operator|.
name|vpd
operator|.
name|vpd_ros
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dinfo
operator|->
name|cfg
operator|.
name|vpd
operator|.
name|vpd_wcnt
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|dinfo
operator|->
name|cfg
operator|.
name|vpd
operator|.
name|vpd_w
index|[
name|i
index|]
operator|.
name|value
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dinfo
operator|->
name|cfg
operator|.
name|vpd
operator|.
name|vpd_w
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|pm
argument_list|,
argument|&dinfo->cfg.maps
argument_list|,
argument|pm_link
argument_list|,
argument|next
argument_list|)
block|{
name|free
argument_list|(
name|pm
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|STAILQ_REMOVE
argument_list|(
name|devlist_head
argument_list|,
name|dinfo
argument_list|,
name|pci_devinfo
argument_list|,
name|pci_links
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dinfo
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
comment|/* increment the generation count */
name|pci_generation
operator|++
expr_stmt|;
comment|/* we're losing one device */
name|pci_numdevs
operator|--
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * PCI power manangement  */
end_comment

begin_function
name|int
name|pci_set_powerstate_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
name|uint16_t
name|status
decl_stmt|;
name|int
name|oldstate
decl_stmt|,
name|highest
decl_stmt|,
name|delay
decl_stmt|;
if|if
condition|(
name|cfg
operator|->
name|pp
operator|.
name|pp_cap
operator|==
literal|0
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
comment|/* 	 * Optimize a no state change request away.  While it would be OK to 	 * write to the hardware in theory, some devices have shown odd 	 * behavior when going from D3 -> D3. 	 */
name|oldstate
operator|=
name|pci_get_powerstate
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldstate
operator|==
name|state
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * The PCI power management specification states that after a state 	 * transition between PCI power states, system software must 	 * guarantee a minimal delay before the function accesses the device. 	 * Compute the worst case delay that we need to guarantee before we 	 * access the device.  Many devices will be responsive much more 	 * quickly than this delay, but there are some that don't respond 	 * instantly to state changes.  Transitions to/from D3 state require 	 * 10ms, while D2 requires 200us, and D0/1 require none.  The delay 	 * is done below with DELAY rather than a sleeper function because 	 * this function can be called from contexts where we cannot sleep. 	 */
name|highest
operator|=
operator|(
name|oldstate
operator|>
name|state
operator|)
condition|?
name|oldstate
else|:
name|state
expr_stmt|;
if|if
condition|(
name|highest
operator|==
name|PCI_POWERSTATE_D3
condition|)
name|delay
operator|=
literal|10000
expr_stmt|;
elseif|else
if|if
condition|(
name|highest
operator|==
name|PCI_POWERSTATE_D2
condition|)
name|delay
operator|=
literal|200
expr_stmt|;
else|else
name|delay
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|PCI_READ_CONFIG
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|cfg
operator|->
name|pp
operator|.
name|pp_status
argument_list|,
literal|2
argument_list|)
operator|&
operator|~
name|PCIM_PSTAT_DMASK
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|PCI_POWERSTATE_D0
case|:
name|status
operator||=
name|PCIM_PSTAT_D0
expr_stmt|;
break|break;
case|case
name|PCI_POWERSTATE_D1
case|:
if|if
condition|(
operator|(
name|cfg
operator|->
name|pp
operator|.
name|pp_cap
operator|&
name|PCIM_PCAP_D1SUPP
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
name|status
operator||=
name|PCIM_PSTAT_D1
expr_stmt|;
break|break;
case|case
name|PCI_POWERSTATE_D2
case|:
if|if
condition|(
operator|(
name|cfg
operator|->
name|pp
operator|.
name|pp_cap
operator|&
name|PCIM_PCAP_D2SUPP
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
name|status
operator||=
name|PCIM_PSTAT_D2
expr_stmt|;
break|break;
case|case
name|PCI_POWERSTATE_D3
case|:
name|status
operator||=
name|PCIM_PSTAT_D3
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|pci_printf
argument_list|(
name|cfg
argument_list|,
literal|"Transition from D%d to D%d\n"
argument_list|,
name|oldstate
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|PCI_WRITE_CONFIG
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|cfg
operator|->
name|pp
operator|.
name|pp_status
argument_list|,
name|status
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|delay
condition|)
name|DELAY
argument_list|(
name|delay
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_get_powerstate_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
name|uint16_t
name|status
decl_stmt|;
name|int
name|result
decl_stmt|;
if|if
condition|(
name|cfg
operator|->
name|pp
operator|.
name|pp_cap
operator|!=
literal|0
condition|)
block|{
name|status
operator|=
name|PCI_READ_CONFIG
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|cfg
operator|->
name|pp
operator|.
name|pp_status
argument_list|,
literal|2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|status
operator|&
name|PCIM_PSTAT_DMASK
condition|)
block|{
case|case
name|PCIM_PSTAT_D0
case|:
name|result
operator|=
name|PCI_POWERSTATE_D0
expr_stmt|;
break|break;
case|case
name|PCIM_PSTAT_D1
case|:
name|result
operator|=
name|PCI_POWERSTATE_D1
expr_stmt|;
break|break;
case|case
name|PCIM_PSTAT_D2
case|:
name|result
operator|=
name|PCI_POWERSTATE_D2
expr_stmt|;
break|break;
case|case
name|PCIM_PSTAT_D3
case|:
name|result
operator|=
name|PCI_POWERSTATE_D3
expr_stmt|;
break|break;
default|default:
name|result
operator|=
name|PCI_POWERSTATE_UNKNOWN
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* No support, device is always at D0 */
name|result
operator|=
name|PCI_POWERSTATE_D0
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Some convenience functions for PCI device drivers.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|pci_set_command_bit
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|uint16_t
name|bit
parameter_list|)
block|{
name|uint16_t
name|command
decl_stmt|;
name|command
operator|=
name|PCI_READ_CONFIG
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|command
operator||=
name|bit
expr_stmt|;
name|PCI_WRITE_CONFIG
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|command
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|pci_clear_command_bit
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|uint16_t
name|bit
parameter_list|)
block|{
name|uint16_t
name|command
decl_stmt|;
name|command
operator|=
name|PCI_READ_CONFIG
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|command
operator|&=
operator|~
name|bit
expr_stmt|;
name|PCI_WRITE_CONFIG
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|command
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pci_enable_busmaster_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|pci_set_command_bit
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|PCIM_CMD_BUSMASTEREN
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_disable_busmaster_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|pci_clear_command_bit
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|PCIM_CMD_BUSMASTEREN
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_enable_io_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|space
parameter_list|)
block|{
name|uint16_t
name|bit
decl_stmt|;
switch|switch
condition|(
name|space
condition|)
block|{
case|case
name|SYS_RES_IOPORT
case|:
name|bit
operator|=
name|PCIM_CMD_PORTEN
expr_stmt|;
break|break;
case|case
name|SYS_RES_MEMORY
case|:
name|bit
operator|=
name|PCIM_CMD_MEMEN
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|pci_set_command_bit
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|bit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_disable_io_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|space
parameter_list|)
block|{
name|uint16_t
name|bit
decl_stmt|;
switch|switch
condition|(
name|space
condition|)
block|{
case|case
name|SYS_RES_IOPORT
case|:
name|bit
operator|=
name|PCIM_CMD_PORTEN
expr_stmt|;
break|break;
case|case
name|SYS_RES_MEMORY
case|:
name|bit
operator|=
name|PCIM_CMD_MEMEN
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|pci_clear_command_bit
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|bit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * New style pci driver.  Parent device is either a pci-host-bridge or a  * pci-pci-bridge.  Both kinds are represented by instances of pcib.  */
end_comment

begin_function
name|void
name|pci_print_verbose
parameter_list|(
name|struct
name|pci_devinfo
modifier|*
name|dinfo
parameter_list|)
block|{
if|if
condition|(
name|bootverbose
condition|)
block|{
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
name|printf
argument_list|(
literal|"found->\tvendor=0x%04x, dev=0x%04x, revid=0x%02x\n"
argument_list|,
name|cfg
operator|->
name|vendor
argument_list|,
name|cfg
operator|->
name|device
argument_list|,
name|cfg
operator|->
name|revid
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tdomain=%d, bus=%d, slot=%d, func=%d\n"
argument_list|,
name|cfg
operator|->
name|domain
argument_list|,
name|cfg
operator|->
name|bus
argument_list|,
name|cfg
operator|->
name|slot
argument_list|,
name|cfg
operator|->
name|func
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tclass=%02x-%02x-%02x, hdrtype=0x%02x, mfdev=%d\n"
argument_list|,
name|cfg
operator|->
name|baseclass
argument_list|,
name|cfg
operator|->
name|subclass
argument_list|,
name|cfg
operator|->
name|progif
argument_list|,
name|cfg
operator|->
name|hdrtype
argument_list|,
name|cfg
operator|->
name|mfdev
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tcmdreg=0x%04x, statreg=0x%04x, cachelnsz=%d (dwords)\n"
argument_list|,
name|cfg
operator|->
name|cmdreg
argument_list|,
name|cfg
operator|->
name|statreg
argument_list|,
name|cfg
operator|->
name|cachelnsz
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tlattimer=0x%02x (%d ns), mingnt=0x%02x (%d ns), maxlat=0x%02x (%d ns)\n"
argument_list|,
name|cfg
operator|->
name|lattimer
argument_list|,
name|cfg
operator|->
name|lattimer
operator|*
literal|30
argument_list|,
name|cfg
operator|->
name|mingnt
argument_list|,
name|cfg
operator|->
name|mingnt
operator|*
literal|250
argument_list|,
name|cfg
operator|->
name|maxlat
argument_list|,
name|cfg
operator|->
name|maxlat
operator|*
literal|250
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|intpin
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"\tintpin=%c, irq=%d\n"
argument_list|,
name|cfg
operator|->
name|intpin
operator|+
literal|'a'
operator|-
literal|1
argument_list|,
name|cfg
operator|->
name|intline
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|pp
operator|.
name|pp_cap
condition|)
block|{
name|uint16_t
name|status
decl_stmt|;
name|status
operator|=
name|pci_read_config
argument_list|(
name|cfg
operator|->
name|dev
argument_list|,
name|cfg
operator|->
name|pp
operator|.
name|pp_status
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tpowerspec %d  supports D0%s%s D3  current D%d\n"
argument_list|,
name|cfg
operator|->
name|pp
operator|.
name|pp_cap
operator|&
name|PCIM_PCAP_SPEC
argument_list|,
name|cfg
operator|->
name|pp
operator|.
name|pp_cap
operator|&
name|PCIM_PCAP_D1SUPP
condition|?
literal|" D1"
else|:
literal|""
argument_list|,
name|cfg
operator|->
name|pp
operator|.
name|pp_cap
operator|&
name|PCIM_PCAP_D2SUPP
condition|?
literal|" D2"
else|:
literal|""
argument_list|,
name|status
operator|&
name|PCIM_PSTAT_DMASK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cfg
operator|->
name|msi
operator|.
name|msi_location
condition|)
block|{
name|int
name|ctrl
decl_stmt|;
name|ctrl
operator|=
name|cfg
operator|->
name|msi
operator|.
name|msi_ctrl
expr_stmt|;
name|printf
argument_list|(
literal|"\tMSI supports %d message%s%s%s\n"
argument_list|,
name|cfg
operator|->
name|msi
operator|.
name|msi_msgnum
argument_list|,
operator|(
name|cfg
operator|->
name|msi
operator|.
name|msi_msgnum
operator|==
literal|1
operator|)
condition|?
literal|""
else|:
literal|"s"
argument_list|,
operator|(
name|ctrl
operator|&
name|PCIM_MSICTRL_64BIT
operator|)
condition|?
literal|", 64 bit"
else|:
literal|""
argument_list|,
operator|(
name|ctrl
operator|&
name|PCIM_MSICTRL_VECTOR
operator|)
condition|?
literal|", vector masks"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cfg
operator|->
name|msix
operator|.
name|msix_location
condition|)
block|{
name|printf
argument_list|(
literal|"\tMSI-X supports %d message%s "
argument_list|,
name|cfg
operator|->
name|msix
operator|.
name|msix_msgnum
argument_list|,
operator|(
name|cfg
operator|->
name|msix
operator|.
name|msix_msgnum
operator|==
literal|1
operator|)
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|msix
operator|.
name|msix_table_bar
operator|==
name|cfg
operator|->
name|msix
operator|.
name|msix_pba_bar
condition|)
name|printf
argument_list|(
literal|"in map 0x%x\n"
argument_list|,
name|cfg
operator|->
name|msix
operator|.
name|msix_table_bar
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"in maps 0x%x and 0x%x\n"
argument_list|,
name|cfg
operator|->
name|msix
operator|.
name|msix_table_bar
argument_list|,
name|cfg
operator|->
name|msix
operator|.
name|msix_pba_bar
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|pci_porten
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
operator|&
name|PCIM_CMD_PORTEN
operator|)
operator|!=
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pci_memen
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
operator|&
name|PCIM_CMD_MEMEN
operator|)
operator|!=
literal|0
return|;
block|}
end_function

begin_function
name|void
name|pci_read_bar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|reg
parameter_list|,
name|pci_addr_t
modifier|*
name|mapp
parameter_list|,
name|pci_addr_t
modifier|*
name|testvalp
parameter_list|,
name|int
modifier|*
name|bar64
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|pci_addr_t
name|map
decl_stmt|,
name|testval
decl_stmt|;
name|int
name|ln2range
decl_stmt|;
name|uint16_t
name|cmd
decl_stmt|;
comment|/* 	 * The device ROM BAR is special.  It is always a 32-bit 	 * memory BAR.  Bit 0 is special and should not be set when 	 * sizing the BAR. 	 */
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|PCIR_IS_BIOS
argument_list|(
operator|&
name|dinfo
operator|->
name|cfg
argument_list|,
name|reg
argument_list|)
condition|)
block|{
name|map
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|reg
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|reg
argument_list|,
literal|0xfffffffe
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|testval
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|reg
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|reg
argument_list|,
name|map
argument_list|,
literal|4
argument_list|)
expr_stmt|;
operator|*
name|mapp
operator|=
name|map
expr_stmt|;
operator|*
name|testvalp
operator|=
name|testval
expr_stmt|;
if|if
condition|(
name|bar64
operator|!=
name|NULL
condition|)
operator|*
name|bar64
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|map
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|reg
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ln2range
operator|=
name|pci_maprange
argument_list|(
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln2range
operator|==
literal|64
condition|)
name|map
operator||=
operator|(
name|pci_addr_t
operator|)
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|reg
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
operator|<<
literal|32
expr_stmt|;
comment|/* 	 * Disable decoding via the command register before 	 * determining the BAR's length since we will be placing it in 	 * a weird state. 	 */
name|cmd
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|cmd
operator|&
operator|~
operator|(
name|PCI_BAR_MEM
argument_list|(
name|map
argument_list|)
condition|?
name|PCIM_CMD_MEMEN
else|:
name|PCIM_CMD_PORTEN
operator|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* 	 * Determine the BAR's length by writing all 1's.  The bottom 	 * log_2(size) bits of the BAR will stick as 0 when we read 	 * the value back. 	 * 	 * NB: according to the PCI Local Bus Specification, rev. 3.0: 	 * "Software writes 0FFFFFFFFh to both registers, reads them back, 	 * and combines the result into a 64-bit value." (section 6.2.5.1) 	 * 	 * Writes to both registers must be performed before attempting to 	 * read back the size value. 	 */
name|testval
operator|=
literal|0
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|reg
argument_list|,
literal|0xffffffff
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln2range
operator|==
literal|64
condition|)
block|{
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|reg
operator|+
literal|4
argument_list|,
literal|0xffffffff
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|testval
operator||=
operator|(
name|pci_addr_t
operator|)
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|reg
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
operator|<<
literal|32
expr_stmt|;
block|}
name|testval
operator||=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|reg
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* 	 * Restore the original value of the BAR.  We may have reprogrammed 	 * the BAR of the low-level console device and when booting verbose, 	 * we need the console device addressable. 	 */
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|reg
argument_list|,
name|map
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln2range
operator|==
literal|64
condition|)
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|reg
operator|+
literal|4
argument_list|,
name|map
operator|>>
literal|32
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|cmd
argument_list|,
literal|2
argument_list|)
expr_stmt|;
operator|*
name|mapp
operator|=
name|map
expr_stmt|;
operator|*
name|testvalp
operator|=
name|testval
expr_stmt|;
if|if
condition|(
name|bar64
operator|!=
name|NULL
condition|)
operator|*
name|bar64
operator|=
operator|(
name|ln2range
operator|==
literal|64
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pci_write_bar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|pci_map
modifier|*
name|pm
parameter_list|,
name|pci_addr_t
name|base
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|int
name|ln2range
decl_stmt|;
comment|/* The device ROM BAR is always a 32-bit memory BAR. */
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|PCIR_IS_BIOS
argument_list|(
operator|&
name|dinfo
operator|->
name|cfg
argument_list|,
name|pm
operator|->
name|pm_reg
argument_list|)
condition|)
name|ln2range
operator|=
literal|32
expr_stmt|;
else|else
name|ln2range
operator|=
name|pci_maprange
argument_list|(
name|pm
operator|->
name|pm_value
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|pm
operator|->
name|pm_reg
argument_list|,
name|base
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln2range
operator|==
literal|64
condition|)
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|pm
operator|->
name|pm_reg
operator|+
literal|4
argument_list|,
name|base
operator|>>
literal|32
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pm
operator|->
name|pm_value
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|pm
operator|->
name|pm_reg
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln2range
operator|==
literal|64
condition|)
name|pm
operator|->
name|pm_value
operator||=
operator|(
name|pci_addr_t
operator|)
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|pm
operator|->
name|pm_reg
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
operator|<<
literal|32
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|pci_map
modifier|*
name|pci_find_bar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|struct
name|pci_map
modifier|*
name|pm
decl_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|pm
argument_list|,
argument|&dinfo->cfg.maps
argument_list|,
argument|pm_link
argument_list|)
block|{
if|if
condition|(
name|pm
operator|->
name|pm_reg
operator|==
name|reg
condition|)
return|return
operator|(
name|pm
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_bar_enabled
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|pci_map
modifier|*
name|pm
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|uint16_t
name|cmd
decl_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|PCIR_IS_BIOS
argument_list|(
operator|&
name|dinfo
operator|->
name|cfg
argument_list|,
name|pm
operator|->
name|pm_reg
argument_list|)
operator|&&
operator|!
operator|(
name|pm
operator|->
name|pm_value
operator|&
name|PCIM_BIOS_ENABLE
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|cmd
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|PCIR_IS_BIOS
argument_list|(
operator|&
name|dinfo
operator|->
name|cfg
argument_list|,
name|pm
operator|->
name|pm_reg
argument_list|)
operator|||
name|PCI_BAR_MEM
argument_list|(
name|pm
operator|->
name|pm_value
argument_list|)
condition|)
return|return
operator|(
operator|(
name|cmd
operator|&
name|PCIM_CMD_MEMEN
operator|)
operator|!=
literal|0
operator|)
return|;
else|else
return|return
operator|(
operator|(
name|cmd
operator|&
name|PCIM_CMD_PORTEN
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|pci_map
modifier|*
name|pci_add_bar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|reg
parameter_list|,
name|pci_addr_t
name|value
parameter_list|,
name|pci_addr_t
name|size
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|struct
name|pci_map
modifier|*
name|pm
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pm
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pm
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|pm
operator|->
name|pm_reg
operator|=
name|reg
expr_stmt|;
name|pm
operator|->
name|pm_value
operator|=
name|value
expr_stmt|;
name|pm
operator|->
name|pm_size
operator|=
name|size
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|prev
argument_list|,
argument|&dinfo->cfg.maps
argument_list|,
argument|pm_link
argument_list|)
block|{
name|KASSERT
argument_list|(
name|prev
operator|->
name|pm_reg
operator|!=
name|pm
operator|->
name|pm_reg
argument_list|,
operator|(
literal|"duplicate map %02x"
operator|,
name|reg
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|STAILQ_NEXT
argument_list|(
name|prev
argument_list|,
name|pm_link
argument_list|)
operator|==
name|NULL
operator|||
name|STAILQ_NEXT
argument_list|(
name|prev
argument_list|,
name|pm_link
argument_list|)
operator|->
name|pm_reg
operator|>
name|pm
operator|->
name|pm_reg
condition|)
break|break;
block|}
if|if
condition|(
name|prev
operator|!=
name|NULL
condition|)
name|STAILQ_INSERT_AFTER
argument_list|(
operator|&
name|dinfo
operator|->
name|cfg
operator|.
name|maps
argument_list|,
name|prev
argument_list|,
name|pm
argument_list|,
name|pm_link
argument_list|)
expr_stmt|;
else|else
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|dinfo
operator|->
name|cfg
operator|.
name|maps
argument_list|,
name|pm
argument_list|,
name|pm_link
argument_list|)
expr_stmt|;
return|return
operator|(
name|pm
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pci_restore_bars
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|struct
name|pci_map
modifier|*
name|pm
decl_stmt|;
name|int
name|ln2range
decl_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|pm
argument_list|,
argument|&dinfo->cfg.maps
argument_list|,
argument|pm_link
argument_list|)
block|{
if|if
condition|(
name|PCIR_IS_BIOS
argument_list|(
operator|&
name|dinfo
operator|->
name|cfg
argument_list|,
name|pm
operator|->
name|pm_reg
argument_list|)
condition|)
name|ln2range
operator|=
literal|32
expr_stmt|;
else|else
name|ln2range
operator|=
name|pci_maprange
argument_list|(
name|pm
operator|->
name|pm_value
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|pm
operator|->
name|pm_reg
argument_list|,
name|pm
operator|->
name|pm_value
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln2range
operator|==
literal|64
condition|)
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|pm
operator|->
name|pm_reg
operator|+
literal|4
argument_list|,
name|pm
operator|->
name|pm_value
operator|>>
literal|32
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Add a resource based on a pci map register. Return 1 if the map  * register is a 32bit map register or 2 if it is a 64bit register.  */
end_comment

begin_function
specifier|static
name|int
name|pci_add_map
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|int
name|reg
parameter_list|,
name|struct
name|resource_list
modifier|*
name|rl
parameter_list|,
name|int
name|force
parameter_list|,
name|int
name|prefetch
parameter_list|)
block|{
name|struct
name|pci_map
modifier|*
name|pm
decl_stmt|;
name|pci_addr_t
name|base
decl_stmt|,
name|map
decl_stmt|,
name|testval
decl_stmt|;
name|pci_addr_t
name|start
decl_stmt|,
name|end
decl_stmt|,
name|count
decl_stmt|;
name|int
name|barlen
decl_stmt|,
name|basezero
decl_stmt|,
name|flags
decl_stmt|,
name|maprange
decl_stmt|,
name|mapsize
decl_stmt|,
name|type
decl_stmt|;
name|uint16_t
name|cmd
decl_stmt|;
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
comment|/* 	 * The BAR may already exist if the device is a CardBus card 	 * whose CIS is stored in this BAR. 	 */
name|pm
operator|=
name|pci_find_bar
argument_list|(
name|dev
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|pm
operator|!=
name|NULL
condition|)
block|{
name|maprange
operator|=
name|pci_maprange
argument_list|(
name|pm
operator|->
name|pm_value
argument_list|)
expr_stmt|;
name|barlen
operator|=
name|maprange
operator|==
literal|64
condition|?
literal|2
else|:
literal|1
expr_stmt|;
return|return
operator|(
name|barlen
operator|)
return|;
block|}
name|pci_read_bar
argument_list|(
name|dev
argument_list|,
name|reg
argument_list|,
operator|&
name|map
argument_list|,
operator|&
name|testval
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|PCI_BAR_MEM
argument_list|(
name|map
argument_list|)
condition|)
block|{
name|type
operator|=
name|SYS_RES_MEMORY
expr_stmt|;
if|if
condition|(
name|map
operator|&
name|PCIM_BAR_MEM_PREFETCH
condition|)
name|prefetch
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|type
operator|=
name|SYS_RES_IOPORT
expr_stmt|;
name|mapsize
operator|=
name|pci_mapsize
argument_list|(
name|testval
argument_list|)
expr_stmt|;
name|base
operator|=
name|pci_mapbase
argument_list|(
name|map
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__PCI_BAR_ZERO_VALID
name|basezero
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|basezero
operator|=
name|base
operator|==
literal|0
expr_stmt|;
endif|#
directive|endif
name|maprange
operator|=
name|pci_maprange
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|barlen
operator|=
name|maprange
operator|==
literal|64
condition|?
literal|2
else|:
literal|1
expr_stmt|;
comment|/* 	 * For I/O registers, if bottom bit is set, and the next bit up 	 * isn't clear, we know we have a BAR that doesn't conform to the 	 * spec, so ignore it.  Also, sanity check the size of the data 	 * areas to the type of memory involved.  Memory must be at least 	 * 16 bytes in size, while I/O ranges must be at least 4. 	 */
if|if
condition|(
name|PCI_BAR_IO
argument_list|(
name|testval
argument_list|)
operator|&&
operator|(
name|testval
operator|&
name|PCIM_BAR_IO_RESERVED
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|barlen
operator|)
return|;
if|if
condition|(
operator|(
name|type
operator|==
name|SYS_RES_MEMORY
operator|&&
name|mapsize
operator|<
literal|4
operator|)
operator|||
operator|(
name|type
operator|==
name|SYS_RES_IOPORT
operator|&&
name|mapsize
operator|<
literal|2
operator|)
condition|)
return|return
operator|(
name|barlen
operator|)
return|;
comment|/* Save a record of this BAR. */
name|pm
operator|=
name|pci_add_bar
argument_list|(
name|dev
argument_list|,
name|reg
argument_list|,
name|map
argument_list|,
name|mapsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"\tmap[%02x]: type %s, range %2d, base %#jx, size %2d"
argument_list|,
name|reg
argument_list|,
name|pci_maptype
argument_list|(
name|map
argument_list|)
argument_list|,
name|maprange
argument_list|,
operator|(
name|uintmax_t
operator|)
name|base
argument_list|,
name|mapsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|SYS_RES_IOPORT
operator|&&
operator|!
name|pci_porten
argument_list|(
name|dev
argument_list|)
condition|)
name|printf
argument_list|(
literal|", port disabled\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|SYS_RES_MEMORY
operator|&&
operator|!
name|pci_memen
argument_list|(
name|dev
argument_list|)
condition|)
name|printf
argument_list|(
literal|", memory disabled\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|", enabled\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If base is 0, then we have problems if this architecture does 	 * not allow that.  It is best to ignore such entries for the 	 * moment.  These will be allocated later if the driver specifically 	 * requests them.  However, some removable buses look better when 	 * all resources are allocated, so allow '0' to be overriden. 	 * 	 * Similarly treat maps whose values is the same as the test value 	 * read back.  These maps have had all f's written to them by the 	 * BIOS in an attempt to disable the resources. 	 */
if|if
condition|(
operator|!
name|force
operator|&&
operator|(
name|basezero
operator|||
name|map
operator|==
name|testval
operator|)
condition|)
return|return
operator|(
name|barlen
operator|)
return|;
if|if
condition|(
operator|(
name|u_long
operator|)
name|base
operator|!=
name|base
condition|)
block|{
name|device_printf
argument_list|(
name|bus
argument_list|,
literal|"pci%d:%d:%d:%d bar %#x too many address bits"
argument_list|,
name|pci_get_domain
argument_list|(
name|dev
argument_list|)
argument_list|,
name|pci_get_bus
argument_list|(
name|dev
argument_list|)
argument_list|,
name|pci_get_slot
argument_list|(
name|dev
argument_list|)
argument_list|,
name|pci_get_function
argument_list|(
name|dev
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
name|barlen
operator|)
return|;
block|}
comment|/* 	 * This code theoretically does the right thing, but has 	 * undesirable side effects in some cases where peripherals 	 * respond oddly to having these bits enabled.  Let the user 	 * be able to turn them off (since pci_enable_io_modes is 1 by 	 * default). 	 */
if|if
condition|(
name|pci_enable_io_modes
condition|)
block|{
comment|/* Turn on resources that have been left off by a lazy BIOS */
if|if
condition|(
name|type
operator|==
name|SYS_RES_IOPORT
operator|&&
operator|!
name|pci_porten
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|cmd
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cmd
operator||=
name|PCIM_CMD_PORTEN
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|cmd
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|SYS_RES_MEMORY
operator|&&
operator|!
name|pci_memen
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|cmd
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cmd
operator||=
name|PCIM_CMD_MEMEN
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|cmd
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|type
operator|==
name|SYS_RES_IOPORT
operator|&&
operator|!
name|pci_porten
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
name|barlen
operator|)
return|;
if|if
condition|(
name|type
operator|==
name|SYS_RES_MEMORY
operator|&&
operator|!
name|pci_memen
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
name|barlen
operator|)
return|;
block|}
name|count
operator|=
operator|(
name|pci_addr_t
operator|)
literal|1
operator|<<
name|mapsize
expr_stmt|;
name|flags
operator|=
name|RF_ALIGNMENT_LOG2
argument_list|(
name|mapsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefetch
condition|)
name|flags
operator||=
name|RF_PREFETCHABLE
expr_stmt|;
if|if
condition|(
name|basezero
operator|||
name|base
operator|==
name|pci_mapbase
argument_list|(
name|testval
argument_list|)
operator|||
name|pci_clear_bars
condition|)
block|{
name|start
operator|=
literal|0
expr_stmt|;
comment|/* Let the parent decide. */
name|end
operator|=
operator|~
literal|0
expr_stmt|;
block|}
else|else
block|{
name|start
operator|=
name|base
expr_stmt|;
name|end
operator|=
name|base
operator|+
name|count
operator|-
literal|1
expr_stmt|;
block|}
name|resource_list_add
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
name|reg
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/* 	 * Try to allocate the resource for this BAR from our parent 	 * so that this resource range is already reserved.  The 	 * driver for this device will later inherit this resource in 	 * pci_alloc_resource(). 	 */
name|res
operator|=
name|resource_list_reserve
argument_list|(
name|rl
argument_list|,
name|bus
argument_list|,
name|dev
argument_list|,
name|type
argument_list|,
operator|&
name|reg
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_do_realloc_bars
operator|&&
name|res
operator|==
name|NULL
operator|&&
operator|(
name|start
operator|!=
literal|0
operator|||
name|end
operator|!=
operator|~
literal|0
operator|)
condition|)
block|{
comment|/* 		 * If the allocation fails, try to allocate a resource for 		 * this BAR using any available range.  The firmware felt 		 * it was important enough to assign a resource, so don't 		 * disable decoding if we can help it. 		 */
name|resource_list_delete
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|resource_list_add
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|res
operator|=
name|resource_list_reserve
argument_list|(
name|rl
argument_list|,
name|bus
argument_list|,
name|dev
argument_list|,
name|type
argument_list|,
operator|&
name|reg
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * If the allocation fails, delete the resource list entry 		 * and disable decoding for this device. 		 * 		 * If the driver requests this resource in the future, 		 * pci_reserve_map() will try to allocate a fresh 		 * resource range. 		 */
name|resource_list_delete
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|pci_disable_io
argument_list|(
name|dev
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|bus
argument_list|,
literal|"pci%d:%d:%d:%d bar %#x failed to allocate\n"
argument_list|,
name|pci_get_domain
argument_list|(
name|dev
argument_list|)
argument_list|,
name|pci_get_bus
argument_list|(
name|dev
argument_list|)
argument_list|,
name|pci_get_slot
argument_list|(
name|dev
argument_list|)
argument_list|,
name|pci_get_function
argument_list|(
name|dev
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|start
operator|=
name|rman_get_start
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|pci_write_bar
argument_list|(
name|dev
argument_list|,
name|pm
argument_list|,
name|start
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|barlen
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * For ATA devices we need to decide early what addressing mode to use.  * Legacy demands that the primary and secondary ATA ports sits on the  * same addresses that old ISA hardware did. This dictates that we use  * those addresses and ignore the BAR's if we cannot set PCI native  * addressing mode.  */
end_comment

begin_function
specifier|static
name|void
name|pci_ata_maps
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|struct
name|resource_list
modifier|*
name|rl
parameter_list|,
name|int
name|force
parameter_list|,
name|uint32_t
name|prefetchmask
parameter_list|)
block|{
name|int
name|rid
decl_stmt|,
name|type
decl_stmt|,
name|progif
decl_stmt|;
if|#
directive|if
literal|0
comment|/* if this device supports PCI native addressing use it */
block|progif = pci_read_config(dev, PCIR_PROGIF, 1); 	if ((progif& 0x8a) == 0x8a) { 		if (pci_mapbase(pci_read_config(dev, PCIR_BAR(0), 4))&& 		    pci_mapbase(pci_read_config(dev, PCIR_BAR(2), 4))) { 			printf("Trying ATA native PCI addressing mode\n"); 			pci_write_config(dev, PCIR_PROGIF, progif | 0x05, 1); 		} 	}
endif|#
directive|endif
name|progif
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PROGIF
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|type
operator|=
name|SYS_RES_IOPORT
expr_stmt|;
if|if
condition|(
name|progif
operator|&
name|PCIP_STORAGE_IDE_MODEPRIM
condition|)
block|{
name|pci_add_map
argument_list|(
name|bus
argument_list|,
name|dev
argument_list|,
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|rl
argument_list|,
name|force
argument_list|,
name|prefetchmask
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
argument_list|)
expr_stmt|;
name|pci_add_map
argument_list|(
name|bus
argument_list|,
name|dev
argument_list|,
name|PCIR_BAR
argument_list|(
literal|1
argument_list|)
argument_list|,
name|rl
argument_list|,
name|force
argument_list|,
name|prefetchmask
operator|&
operator|(
literal|1
operator|<<
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|resource_list_add
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
literal|0x1f0
argument_list|,
literal|0x1f7
argument_list|,
literal|8
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|resource_list_reserve
argument_list|(
name|rl
argument_list|,
name|bus
argument_list|,
name|dev
argument_list|,
name|type
argument_list|,
operator|&
name|rid
argument_list|,
literal|0x1f0
argument_list|,
literal|0x1f7
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rid
operator|=
name|PCIR_BAR
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|resource_list_add
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
literal|0x3f6
argument_list|,
literal|0x3f6
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|resource_list_reserve
argument_list|(
name|rl
argument_list|,
name|bus
argument_list|,
name|dev
argument_list|,
name|type
argument_list|,
operator|&
name|rid
argument_list|,
literal|0x3f6
argument_list|,
literal|0x3f6
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|progif
operator|&
name|PCIP_STORAGE_IDE_MODESEC
condition|)
block|{
name|pci_add_map
argument_list|(
name|bus
argument_list|,
name|dev
argument_list|,
name|PCIR_BAR
argument_list|(
literal|2
argument_list|)
argument_list|,
name|rl
argument_list|,
name|force
argument_list|,
name|prefetchmask
operator|&
operator|(
literal|1
operator|<<
literal|2
operator|)
argument_list|)
expr_stmt|;
name|pci_add_map
argument_list|(
name|bus
argument_list|,
name|dev
argument_list|,
name|PCIR_BAR
argument_list|(
literal|3
argument_list|)
argument_list|,
name|rl
argument_list|,
name|force
argument_list|,
name|prefetchmask
operator|&
operator|(
literal|1
operator|<<
literal|3
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rid
operator|=
name|PCIR_BAR
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|resource_list_add
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
literal|0x170
argument_list|,
literal|0x177
argument_list|,
literal|8
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|resource_list_reserve
argument_list|(
name|rl
argument_list|,
name|bus
argument_list|,
name|dev
argument_list|,
name|type
argument_list|,
operator|&
name|rid
argument_list|,
literal|0x170
argument_list|,
literal|0x177
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rid
operator|=
name|PCIR_BAR
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|resource_list_add
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
literal|0x376
argument_list|,
literal|0x376
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|resource_list_reserve
argument_list|(
name|rl
argument_list|,
name|bus
argument_list|,
name|dev
argument_list|,
name|type
argument_list|,
operator|&
name|rid
argument_list|,
literal|0x376
argument_list|,
literal|0x376
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|pci_add_map
argument_list|(
name|bus
argument_list|,
name|dev
argument_list|,
name|PCIR_BAR
argument_list|(
literal|4
argument_list|)
argument_list|,
name|rl
argument_list|,
name|force
argument_list|,
name|prefetchmask
operator|&
operator|(
literal|1
operator|<<
literal|4
operator|)
argument_list|)
expr_stmt|;
name|pci_add_map
argument_list|(
name|bus
argument_list|,
name|dev
argument_list|,
name|PCIR_BAR
argument_list|(
literal|5
argument_list|)
argument_list|,
name|rl
argument_list|,
name|force
argument_list|,
name|prefetchmask
operator|&
operator|(
literal|1
operator|<<
literal|5
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pci_assign_interrupt
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|int
name|force_route
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
name|char
name|tunable_name
index|[
literal|64
index|]
decl_stmt|;
name|int
name|irq
decl_stmt|;
comment|/* Has to have an intpin to have an interrupt. */
if|if
condition|(
name|cfg
operator|->
name|intpin
operator|==
literal|0
condition|)
return|return;
comment|/* Let the user override the IRQ with a tunable. */
name|irq
operator|=
name|PCI_INVALID_IRQ
expr_stmt|;
name|snprintf
argument_list|(
name|tunable_name
argument_list|,
sizeof|sizeof
argument_list|(
name|tunable_name
argument_list|)
argument_list|,
literal|"hw.pci%d.%d.%d.INT%c.irq"
argument_list|,
name|cfg
operator|->
name|domain
argument_list|,
name|cfg
operator|->
name|bus
argument_list|,
name|cfg
operator|->
name|slot
argument_list|,
name|cfg
operator|->
name|intpin
operator|+
literal|'A'
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TUNABLE_INT_FETCH
argument_list|(
name|tunable_name
argument_list|,
operator|&
name|irq
argument_list|)
operator|&&
operator|(
name|irq
operator|>=
literal|255
operator|||
name|irq
operator|<=
literal|0
operator|)
condition|)
name|irq
operator|=
name|PCI_INVALID_IRQ
expr_stmt|;
comment|/* 	 * If we didn't get an IRQ via the tunable, then we either use the 	 * IRQ value in the intline register or we ask the bus to route an 	 * interrupt for us.  If force_route is true, then we only use the 	 * value in the intline register if the bus was unable to assign an 	 * IRQ. 	 */
if|if
condition|(
operator|!
name|PCI_INTERRUPT_VALID
argument_list|(
name|irq
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|PCI_INTERRUPT_VALID
argument_list|(
name|cfg
operator|->
name|intline
argument_list|)
operator|||
name|force_route
condition|)
name|irq
operator|=
name|PCI_ASSIGN_INTERRUPT
argument_list|(
name|bus
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PCI_INTERRUPT_VALID
argument_list|(
name|irq
argument_list|)
condition|)
name|irq
operator|=
name|cfg
operator|->
name|intline
expr_stmt|;
block|}
comment|/* If after all that we don't have an IRQ, just bail. */
if|if
condition|(
operator|!
name|PCI_INTERRUPT_VALID
argument_list|(
name|irq
argument_list|)
condition|)
return|return;
comment|/* Update the config register if it changed. */
if|if
condition|(
name|irq
operator|!=
name|cfg
operator|->
name|intline
condition|)
block|{
name|cfg
operator|->
name|intline
operator|=
name|irq
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_INTLINE
argument_list|,
name|irq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Add this IRQ as rid 0 interrupt resource. */
name|resource_list_add
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|irq
argument_list|,
name|irq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform early OHCI takeover from SMM. */
end_comment

begin_function
specifier|static
name|void
name|ohci_early_takeover
parameter_list|(
name|device_t
name|self
parameter_list|)
block|{
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|uint32_t
name|ctl
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|self
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
return|return;
name|ctl
operator|=
name|bus_read_4
argument_list|(
name|res
argument_list|,
name|OHCI_CONTROL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl
operator|&
name|OHCI_IR
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"ohci early: "
literal|"SMM active, request owner change\n"
argument_list|)
expr_stmt|;
name|bus_write_4
argument_list|(
name|res
argument_list|,
name|OHCI_COMMAND_STATUS
argument_list|,
name|OHCI_OCR
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
literal|100
operator|)
operator|&&
operator|(
name|ctl
operator|&
name|OHCI_IR
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|ctl
operator|=
name|bus_read_4
argument_list|(
name|res
argument_list|,
name|OHCI_CONTROL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctl
operator|&
name|OHCI_IR
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"ohci early: "
literal|"SMM does not respond, resetting\n"
argument_list|)
expr_stmt|;
name|bus_write_4
argument_list|(
name|res
argument_list|,
name|OHCI_CONTROL
argument_list|,
name|OHCI_HCFS_RESET
argument_list|)
expr_stmt|;
block|}
comment|/* Disable interrupts */
name|bus_write_4
argument_list|(
name|res
argument_list|,
name|OHCI_INTERRUPT_DISABLE
argument_list|,
name|OHCI_ALL_INTRS
argument_list|)
expr_stmt|;
block|}
name|bus_release_resource
argument_list|(
name|self
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|rid
argument_list|,
name|res
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform early UHCI takeover from SMM. */
end_comment

begin_function
specifier|static
name|void
name|uhci_early_takeover
parameter_list|(
name|device_t
name|self
parameter_list|)
block|{
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|int
name|rid
decl_stmt|;
comment|/* 	 * Set the PIRQD enable bit and switch off all the others. We don't 	 * want legacy support to interfere with us XXX Does this also mean 	 * that the BIOS won't touch the keyboard anymore if it is connected 	 * to the ports of the root hub? 	 */
name|pci_write_config
argument_list|(
name|self
argument_list|,
name|PCI_LEGSUP
argument_list|,
name|PCI_LEGSUP_USBPIRQDEN
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Disable interrupts */
name|rid
operator|=
name|PCI_UHCI_BASE_REG
expr_stmt|;
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|self
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|NULL
condition|)
block|{
name|bus_write_2
argument_list|(
name|res
argument_list|,
name|UHCI_INTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|self
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|rid
argument_list|,
name|res
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Perform early EHCI takeover from SMM. */
end_comment

begin_function
specifier|static
name|void
name|ehci_early_takeover
parameter_list|(
name|device_t
name|self
parameter_list|)
block|{
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|uint32_t
name|cparams
decl_stmt|;
name|uint32_t
name|eec
decl_stmt|;
name|uint8_t
name|eecp
decl_stmt|;
name|uint8_t
name|bios_sem
decl_stmt|;
name|uint8_t
name|offs
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|self
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
return|return;
name|cparams
operator|=
name|bus_read_4
argument_list|(
name|res
argument_list|,
name|EHCI_HCCPARAMS
argument_list|)
expr_stmt|;
comment|/* Synchronise with the BIOS if it owns the controller. */
for|for
control|(
name|eecp
operator|=
name|EHCI_HCC_EECP
argument_list|(
name|cparams
argument_list|)
init|;
name|eecp
operator|!=
literal|0
condition|;
name|eecp
operator|=
name|EHCI_EECP_NEXT
argument_list|(
name|eec
argument_list|)
control|)
block|{
name|eec
operator|=
name|pci_read_config
argument_list|(
name|self
argument_list|,
name|eecp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|EHCI_EECP_ID
argument_list|(
name|eec
argument_list|)
operator|!=
name|EHCI_EC_LEGSUP
condition|)
block|{
continue|continue;
block|}
name|bios_sem
operator|=
name|pci_read_config
argument_list|(
name|self
argument_list|,
name|eecp
operator|+
name|EHCI_LEGSUP_BIOS_SEM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bios_sem
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"ehci early: "
literal|"SMM active, request owner change\n"
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|self
argument_list|,
name|eecp
operator|+
name|EHCI_LEGSUP_OS_SEM
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
literal|100
operator|)
operator|&&
operator|(
name|bios_sem
operator|!=
literal|0
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|bios_sem
operator|=
name|pci_read_config
argument_list|(
name|self
argument_list|,
name|eecp
operator|+
name|EHCI_LEGSUP_BIOS_SEM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bios_sem
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"ehci early: "
literal|"SMM does not respond\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Disable interrupts */
name|offs
operator|=
name|EHCI_CAPLENGTH
argument_list|(
name|bus_read_4
argument_list|(
name|res
argument_list|,
name|EHCI_CAPLEN_HCIVERSION
argument_list|)
argument_list|)
expr_stmt|;
name|bus_write_4
argument_list|(
name|res
argument_list|,
name|offs
operator|+
name|EHCI_USBINTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|bus_release_resource
argument_list|(
name|self
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|rid
argument_list|,
name|res
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform early XHCI takeover from SMM. */
end_comment

begin_function
specifier|static
name|void
name|xhci_early_takeover
parameter_list|(
name|device_t
name|self
parameter_list|)
block|{
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|uint32_t
name|cparams
decl_stmt|;
name|uint32_t
name|eec
decl_stmt|;
name|uint8_t
name|eecp
decl_stmt|;
name|uint8_t
name|bios_sem
decl_stmt|;
name|uint8_t
name|offs
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|self
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
return|return;
name|cparams
operator|=
name|bus_read_4
argument_list|(
name|res
argument_list|,
name|XHCI_HCSPARAMS0
argument_list|)
expr_stmt|;
name|eec
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Synchronise with the BIOS if it owns the controller. */
for|for
control|(
name|eecp
operator|=
name|XHCI_HCS0_XECP
argument_list|(
name|cparams
argument_list|)
operator|<<
literal|2
init|;
name|eecp
operator|!=
literal|0
operator|&&
name|XHCI_XECP_NEXT
argument_list|(
name|eec
argument_list|)
condition|;
name|eecp
operator|+=
name|XHCI_XECP_NEXT
argument_list|(
name|eec
argument_list|)
operator|<<
literal|2
control|)
block|{
name|eec
operator|=
name|bus_read_4
argument_list|(
name|res
argument_list|,
name|eecp
argument_list|)
expr_stmt|;
if|if
condition|(
name|XHCI_XECP_ID
argument_list|(
name|eec
argument_list|)
operator|!=
name|XHCI_ID_USB_LEGACY
condition|)
continue|continue;
name|bios_sem
operator|=
name|bus_read_1
argument_list|(
name|res
argument_list|,
name|eecp
operator|+
name|XHCI_XECP_BIOS_SEM
argument_list|)
expr_stmt|;
if|if
condition|(
name|bios_sem
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"xhci early: "
literal|"SMM active, request owner change\n"
argument_list|)
expr_stmt|;
name|bus_write_1
argument_list|(
name|res
argument_list|,
name|eecp
operator|+
name|XHCI_XECP_OS_SEM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* wait a maximum of 5 second */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
literal|5000
operator|)
operator|&&
operator|(
name|bios_sem
operator|!=
literal|0
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|bios_sem
operator|=
name|bus_read_1
argument_list|(
name|res
argument_list|,
name|eecp
operator|+
name|XHCI_XECP_BIOS_SEM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bios_sem
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"xhci early: "
literal|"SMM does not respond\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Disable interrupts */
name|offs
operator|=
name|bus_read_1
argument_list|(
name|res
argument_list|,
name|XHCI_CAPLENGTH
argument_list|)
expr_stmt|;
name|bus_write_4
argument_list|(
name|res
argument_list|,
name|offs
operator|+
name|XHCI_USBCMD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_read_4
argument_list|(
name|res
argument_list|,
name|offs
operator|+
name|XHCI_USBSTS
argument_list|)
expr_stmt|;
block|}
name|bus_release_resource
argument_list|(
name|self
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|rid
argument_list|,
name|res
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEW_PCIB
argument_list|)
operator|&&
name|defined
argument_list|(
name|PCI_RES_BUS
argument_list|)
end_if

begin_function
specifier|static
name|void
name|pci_reserve_secbus
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|pcicfgregs
modifier|*
name|cfg
parameter_list|,
name|struct
name|resource_list
modifier|*
name|rl
parameter_list|)
block|{
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|rman_res_t
name|start
decl_stmt|,
name|end
decl_stmt|,
name|count
decl_stmt|;
name|int
name|rid
decl_stmt|,
name|sec_bus
decl_stmt|,
name|sec_reg
decl_stmt|,
name|sub_bus
decl_stmt|,
name|sub_reg
decl_stmt|,
name|sup_bus
decl_stmt|;
switch|switch
condition|(
name|cfg
operator|->
name|hdrtype
operator|&
name|PCIM_HDRTYPE
condition|)
block|{
case|case
name|PCIM_HDRTYPE_BRIDGE
case|:
name|sec_reg
operator|=
name|PCIR_SECBUS_1
expr_stmt|;
name|sub_reg
operator|=
name|PCIR_SUBBUS_1
expr_stmt|;
break|break;
case|case
name|PCIM_HDRTYPE_CARDBUS
case|:
name|sec_reg
operator|=
name|PCIR_SECBUS_2
expr_stmt|;
name|sub_reg
operator|=
name|PCIR_SUBBUS_2
expr_stmt|;
break|break;
default|default:
return|return;
block|}
comment|/* 	 * If the existing bus range is valid, attempt to reserve it 	 * from our parent.  If this fails for any reason, clear the 	 * secbus and subbus registers. 	 * 	 * XXX: Should we reset sub_bus to sec_bus if it is< sec_bus? 	 * This would at least preserve the existing sec_bus if it is 	 * valid. 	 */
name|sec_bus
operator|=
name|PCI_READ_CONFIG
argument_list|(
name|bus
argument_list|,
name|dev
argument_list|,
name|sec_reg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sub_bus
operator|=
name|PCI_READ_CONFIG
argument_list|(
name|bus
argument_list|,
name|dev
argument_list|,
name|sub_reg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Quirk handling. */
switch|switch
condition|(
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
condition|)
block|{
case|case
literal|0x12258086
case|:
comment|/* Intel 82454KX/GX (Orion) */
name|sup_bus
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
literal|0x41
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sup_bus
operator|!=
literal|0xff
condition|)
block|{
name|sec_bus
operator|=
name|sup_bus
operator|+
literal|1
expr_stmt|;
name|sub_bus
operator|=
name|sup_bus
operator|+
literal|1
expr_stmt|;
name|PCI_WRITE_CONFIG
argument_list|(
name|bus
argument_list|,
name|dev
argument_list|,
name|sec_reg
argument_list|,
name|sec_bus
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|PCI_WRITE_CONFIG
argument_list|(
name|bus
argument_list|,
name|dev
argument_list|,
name|sub_reg
argument_list|,
name|sub_bus
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|0x00dd10de
case|:
comment|/* Compaq R3000 BIOS sets wrong subordinate bus number. */
if|if
condition|(
operator|(
name|cp
operator|=
name|kern_getenv
argument_list|(
literal|"smbios.planar.maker"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"Compal"
argument_list|,
literal|6
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|freeenv
argument_list|(
name|cp
argument_list|)
expr_stmt|;
break|break;
block|}
name|freeenv
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|kern_getenv
argument_list|(
literal|"smbios.planar.product"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"08A0"
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|freeenv
argument_list|(
name|cp
argument_list|)
expr_stmt|;
break|break;
block|}
name|freeenv
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sub_bus
operator|<
literal|0xa
condition|)
block|{
name|sub_bus
operator|=
literal|0xa
expr_stmt|;
name|PCI_WRITE_CONFIG
argument_list|(
name|bus
argument_list|,
name|dev
argument_list|,
name|sub_reg
argument_list|,
name|sub_bus
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"\tsecbus=%d, subbus=%d\n"
argument_list|,
name|sec_bus
argument_list|,
name|sub_bus
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec_bus
operator|>
literal|0
operator|&&
name|sub_bus
operator|>=
name|sec_bus
condition|)
block|{
name|start
operator|=
name|sec_bus
expr_stmt|;
name|end
operator|=
name|sub_bus
expr_stmt|;
name|count
operator|=
name|end
operator|-
name|start
operator|+
literal|1
expr_stmt|;
name|resource_list_add
argument_list|(
name|rl
argument_list|,
name|PCI_RES_BUS
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/* 		 * If requested, clear secondary bus registers in 		 * bridge devices to force a complete renumbering 		 * rather than reserving the existing range.  However, 		 * preserve the existing size. 		 */
if|if
condition|(
name|pci_clear_buses
condition|)
goto|goto
name|clear
goto|;
name|rid
operator|=
literal|0
expr_stmt|;
name|res
operator|=
name|resource_list_reserve
argument_list|(
name|rl
argument_list|,
name|bus
argument_list|,
name|dev
argument_list|,
name|PCI_RES_BUS
argument_list|,
operator|&
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|NULL
condition|)
return|return;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|bus
argument_list|,
literal|"pci%d:%d:%d:%d secbus failed to allocate\n"
argument_list|,
name|pci_get_domain
argument_list|(
name|dev
argument_list|)
argument_list|,
name|pci_get_bus
argument_list|(
name|dev
argument_list|)
argument_list|,
name|pci_get_slot
argument_list|(
name|dev
argument_list|)
argument_list|,
name|pci_get_function
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|clear
label|:
name|PCI_WRITE_CONFIG
argument_list|(
name|bus
argument_list|,
name|dev
argument_list|,
name|sec_reg
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|PCI_WRITE_CONFIG
argument_list|(
name|bus
argument_list|,
name|dev
argument_list|,
name|sub_reg
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|resource
modifier|*
name|pci_alloc_secbus
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
modifier|*
name|rid
parameter_list|,
name|rman_res_t
name|start
parameter_list|,
name|rman_res_t
name|end
parameter_list|,
name|rman_res_t
name|count
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
decl_stmt|;
name|struct
name|resource_list
modifier|*
name|rl
decl_stmt|;
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|int
name|sec_reg
decl_stmt|,
name|sub_reg
decl_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|cfg
operator|=
operator|&
name|dinfo
operator|->
name|cfg
expr_stmt|;
name|rl
operator|=
operator|&
name|dinfo
operator|->
name|resources
expr_stmt|;
switch|switch
condition|(
name|cfg
operator|->
name|hdrtype
operator|&
name|PCIM_HDRTYPE
condition|)
block|{
case|case
name|PCIM_HDRTYPE_BRIDGE
case|:
name|sec_reg
operator|=
name|PCIR_SECBUS_1
expr_stmt|;
name|sub_reg
operator|=
name|PCIR_SUBBUS_1
expr_stmt|;
break|break;
case|case
name|PCIM_HDRTYPE_CARDBUS
case|:
name|sec_reg
operator|=
name|PCIR_SECBUS_2
expr_stmt|;
name|sub_reg
operator|=
name|PCIR_SUBBUS_2
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|rid
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|resource_list_find
argument_list|(
name|rl
argument_list|,
name|PCI_RES_BUS
argument_list|,
operator|*
name|rid
argument_list|)
operator|==
name|NULL
condition|)
name|resource_list_add
argument_list|(
name|rl
argument_list|,
name|PCI_RES_BUS
argument_list|,
operator|*
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|resource_list_reserved
argument_list|(
name|rl
argument_list|,
name|PCI_RES_BUS
argument_list|,
operator|*
name|rid
argument_list|)
condition|)
block|{
name|res
operator|=
name|resource_list_reserve
argument_list|(
name|rl
argument_list|,
name|dev
argument_list|,
name|child
argument_list|,
name|PCI_RES_BUS
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
operator|&
operator|~
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
block|{
name|resource_list_delete
argument_list|(
name|rl
argument_list|,
name|PCI_RES_BUS
argument_list|,
operator|*
name|rid
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|child
argument_list|,
literal|"allocating %ju bus%s failed\n"
argument_list|,
name|count
argument_list|,
name|count
operator|==
literal|1
condition|?
literal|""
else|:
literal|"es"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|child
argument_list|,
literal|"Lazy allocation of %ju bus%s at %ju\n"
argument_list|,
name|count
argument_list|,
name|count
operator|==
literal|1
condition|?
literal|""
else|:
literal|"es"
argument_list|,
name|rman_get_start
argument_list|(
name|res
argument_list|)
argument_list|)
expr_stmt|;
name|PCI_WRITE_CONFIG
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|sec_reg
argument_list|,
name|rman_get_start
argument_list|(
name|res
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|PCI_WRITE_CONFIG
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|sub_reg
argument_list|,
name|rman_get_end
argument_list|(
name|res
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|resource_list_alloc
argument_list|(
name|rl
argument_list|,
name|dev
argument_list|,
name|child
argument_list|,
name|PCI_RES_BUS
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|pci_ea_bei_to_rid
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|bei
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PCI_IOV
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|int
name|iov_pos
decl_stmt|;
name|struct
name|pcicfg_iov
modifier|*
name|iov
decl_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|iov
operator|=
name|dinfo
operator|->
name|cfg
operator|.
name|iov
expr_stmt|;
if|if
condition|(
name|iov
operator|!=
name|NULL
condition|)
name|iov_pos
operator|=
name|iov
operator|->
name|iov_pos
expr_stmt|;
else|else
name|iov_pos
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* Check if matches BAR */
if|if
condition|(
operator|(
name|bei
operator|>=
name|PCIM_EA_BEI_BAR_0
operator|)
operator|&&
operator|(
name|bei
operator|<=
name|PCIM_EA_BEI_BAR_5
operator|)
condition|)
return|return
operator|(
name|PCIR_BAR
argument_list|(
name|bei
argument_list|)
operator|)
return|;
comment|/* Check ROM */
if|if
condition|(
name|bei
operator|==
name|PCIM_EA_BEI_ROM
condition|)
return|return
operator|(
name|PCIR_BIOS
operator|)
return|;
ifdef|#
directive|ifdef
name|PCI_IOV
comment|/* Check if matches VF_BAR */
if|if
condition|(
operator|(
name|iov
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|bei
operator|>=
name|PCIM_EA_BEI_VF_BAR_0
operator|)
operator|&&
operator|(
name|bei
operator|<=
name|PCIM_EA_BEI_VF_BAR_5
operator|)
condition|)
return|return
operator|(
name|PCIR_SRIOV_BAR
argument_list|(
name|bei
operator|-
name|PCIM_EA_BEI_VF_BAR_0
argument_list|)
operator|+
name|iov_pos
operator|)
return|;
endif|#
directive|endif
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_ea_is_enabled
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|rid
parameter_list|)
block|{
name|struct
name|pci_ea_entry
modifier|*
name|ea
decl_stmt|;
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|ea
argument_list|,
argument|&dinfo->cfg.ea.ea_entries
argument_list|,
argument|eae_link
argument_list|)
block|{
if|if
condition|(
name|pci_ea_bei_to_rid
argument_list|(
name|dev
argument_list|,
name|ea
operator|->
name|eae_bei
argument_list|)
operator|==
name|rid
condition|)
return|return
operator|(
operator|(
name|ea
operator|->
name|eae_flags
operator|&
name|PCIM_EA_ENABLE
operator|)
operator|>
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pci_add_resources_ea
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|int
name|alloc_iov
parameter_list|)
block|{
name|struct
name|pci_ea_entry
modifier|*
name|ea
decl_stmt|;
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|pci_addr_t
name|start
decl_stmt|,
name|end
decl_stmt|,
name|count
decl_stmt|;
name|struct
name|resource_list
modifier|*
name|rl
decl_stmt|;
name|int
name|type
decl_stmt|,
name|flags
decl_stmt|,
name|rid
decl_stmt|;
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|uint32_t
name|tmp
decl_stmt|;
ifdef|#
directive|ifdef
name|PCI_IOV
name|struct
name|pcicfg_iov
modifier|*
name|iov
decl_stmt|;
endif|#
directive|endif
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|rl
operator|=
operator|&
name|dinfo
operator|->
name|resources
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|PCI_IOV
name|iov
operator|=
name|dinfo
operator|->
name|cfg
operator|.
name|iov
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dinfo
operator|->
name|cfg
operator|.
name|ea
operator|.
name|ea_location
operator|==
literal|0
condition|)
return|return;
name|STAILQ_FOREACH
argument_list|(
argument|ea
argument_list|,
argument|&dinfo->cfg.ea.ea_entries
argument_list|,
argument|eae_link
argument_list|)
block|{
comment|/* 		 * TODO: Ignore EA-BAR if is not enabled. 		 *   Currently the EA implementation supports 		 *   only situation, where EA structure contains 		 *   predefined entries. In case they are not enabled 		 *   leave them unallocated and proceed with 		 *   a legacy-BAR mechanism. 		 */
if|if
condition|(
operator|(
name|ea
operator|->
name|eae_flags
operator|&
name|PCIM_EA_ENABLE
operator|)
operator|==
literal|0
condition|)
continue|continue;
switch|switch
condition|(
operator|(
name|ea
operator|->
name|eae_flags
operator|&
name|PCIM_EA_PP
operator|)
operator|>>
name|PCIM_EA_PP_OFFSET
condition|)
block|{
case|case
name|PCIM_EA_P_MEM_PREFETCH
case|:
case|case
name|PCIM_EA_P_VF_MEM_PREFETCH
case|:
name|flags
operator|=
name|RF_PREFETCHABLE
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|PCIM_EA_P_VF_MEM
case|:
case|case
name|PCIM_EA_P_MEM
case|:
name|type
operator|=
name|SYS_RES_MEMORY
expr_stmt|;
break|break;
case|case
name|PCIM_EA_P_IO
case|:
name|type
operator|=
name|SYS_RES_IOPORT
expr_stmt|;
break|break;
default|default:
continue|continue;
block|}
if|if
condition|(
name|alloc_iov
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|PCI_IOV
comment|/* Allocating IOV, confirm BEI matches */
if|if
condition|(
operator|(
name|ea
operator|->
name|eae_bei
operator|<
name|PCIM_EA_BEI_VF_BAR_0
operator|)
operator|||
operator|(
name|ea
operator|->
name|eae_bei
operator|>
name|PCIM_EA_BEI_VF_BAR_5
operator|)
condition|)
continue|continue;
else|#
directive|else
continue|continue;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* Allocating BAR, confirm BEI matches */
if|if
condition|(
operator|(
operator|(
name|ea
operator|->
name|eae_bei
operator|<
name|PCIM_EA_BEI_BAR_0
operator|)
operator|||
operator|(
name|ea
operator|->
name|eae_bei
operator|>
name|PCIM_EA_BEI_BAR_5
operator|)
operator|)
operator|&&
operator|(
name|ea
operator|->
name|eae_bei
operator|!=
name|PCIM_EA_BEI_ROM
operator|)
condition|)
continue|continue;
block|}
name|rid
operator|=
name|pci_ea_bei_to_rid
argument_list|(
name|dev
argument_list|,
name|ea
operator|->
name|eae_bei
argument_list|)
expr_stmt|;
if|if
condition|(
name|rid
operator|<
literal|0
condition|)
continue|continue;
comment|/* Skip resources already allocated by EA */
if|if
condition|(
operator|(
name|resource_list_find
argument_list|(
name|rl
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|rid
argument_list|)
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|resource_list_find
argument_list|(
name|rl
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|rid
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
continue|continue;
name|start
operator|=
name|ea
operator|->
name|eae_base
expr_stmt|;
name|count
operator|=
name|ea
operator|->
name|eae_max_offset
operator|+
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|PCI_IOV
if|if
condition|(
name|iov
operator|!=
name|NULL
condition|)
name|count
operator|=
name|count
operator|*
name|iov
operator|->
name|iov_num_vfs
expr_stmt|;
endif|#
directive|endif
name|end
operator|=
name|start
operator|+
name|count
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
continue|continue;
name|resource_list_add
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|res
operator|=
name|resource_list_reserve
argument_list|(
name|rl
argument_list|,
name|bus
argument_list|,
name|dev
argument_list|,
name|type
argument_list|,
operator|&
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
block|{
name|resource_list_delete
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
name|rid
argument_list|)
expr_stmt|;
comment|/* 			 * Failed to allocate using EA, disable entry. 			 * Another attempt to allocation will be performed 			 * further, but this time using legacy BAR registers 			 */
name|tmp
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|ea
operator|->
name|eae_cfg_offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|tmp
operator|&=
operator|~
name|PCIM_EA_ENABLE
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|ea
operator|->
name|eae_cfg_offset
argument_list|,
name|tmp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* 			 * Disabling entry might fail in case it is hardwired. 			 * Read flags again to match current status. 			 */
name|ea
operator|->
name|eae_flags
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|ea
operator|->
name|eae_cfg_offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* As per specification, fill BAR with zeros */
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|rid
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|pci_add_resources
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|int
name|force
parameter_list|,
name|uint32_t
name|prefetchmask
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
decl_stmt|;
name|struct
name|resource_list
modifier|*
name|rl
decl_stmt|;
specifier|const
name|struct
name|pci_quirk
modifier|*
name|q
decl_stmt|;
name|uint32_t
name|devid
decl_stmt|;
name|int
name|i
decl_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|cfg
operator|=
operator|&
name|dinfo
operator|->
name|cfg
expr_stmt|;
name|rl
operator|=
operator|&
name|dinfo
operator|->
name|resources
expr_stmt|;
name|devid
operator|=
operator|(
name|cfg
operator|->
name|device
operator|<<
literal|16
operator|)
operator||
name|cfg
operator|->
name|vendor
expr_stmt|;
comment|/* Allocate resources using Enhanced Allocation */
name|pci_add_resources_ea
argument_list|(
name|bus
argument_list|,
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ATA devices needs special map treatment */
if|if
condition|(
operator|(
name|pci_get_class
argument_list|(
name|dev
argument_list|)
operator|==
name|PCIC_STORAGE
operator|)
operator|&&
operator|(
name|pci_get_subclass
argument_list|(
name|dev
argument_list|)
operator|==
name|PCIS_STORAGE_IDE
operator|)
operator|&&
operator|(
operator|(
name|pci_get_progif
argument_list|(
name|dev
argument_list|)
operator|&
name|PCIP_STORAGE_IDE_MASTERDEV
operator|)
operator|||
operator|(
operator|!
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|4
argument_list|)
operator|&&
operator|!
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_BAR
argument_list|(
literal|2
argument_list|)
argument_list|,
literal|4
argument_list|)
operator|)
operator|)
condition|)
name|pci_ata_maps
argument_list|(
name|bus
argument_list|,
name|dev
argument_list|,
name|rl
argument_list|,
name|force
argument_list|,
name|prefetchmask
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cfg
operator|->
name|nummaps
condition|;
control|)
block|{
comment|/* Skip resources already managed by EA */
if|if
condition|(
operator|(
name|resource_list_find
argument_list|(
name|rl
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|PCIR_BAR
argument_list|(
name|i
argument_list|)
argument_list|)
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|resource_list_find
argument_list|(
name|rl
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|PCIR_BAR
argument_list|(
name|i
argument_list|)
argument_list|)
operator|!=
name|NULL
operator|)
operator|||
name|pci_ea_is_enabled
argument_list|(
name|dev
argument_list|,
name|PCIR_BAR
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * Skip quirked resources. 			 */
for|for
control|(
name|q
operator|=
operator|&
name|pci_quirks
index|[
literal|0
index|]
init|;
name|q
operator|->
name|devid
operator|!=
literal|0
condition|;
name|q
operator|++
control|)
if|if
condition|(
name|q
operator|->
name|devid
operator|==
name|devid
operator|&&
name|q
operator|->
name|type
operator|==
name|PCI_QUIRK_UNMAP_REG
operator|&&
name|q
operator|->
name|arg1
operator|==
name|PCIR_BAR
argument_list|(
name|i
argument_list|)
condition|)
break|break;
if|if
condition|(
name|q
operator|->
name|devid
operator|!=
literal|0
condition|)
block|{
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
name|i
operator|+=
name|pci_add_map
argument_list|(
name|bus
argument_list|,
name|dev
argument_list|,
name|PCIR_BAR
argument_list|(
name|i
argument_list|)
argument_list|,
name|rl
argument_list|,
name|force
argument_list|,
name|prefetchmask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Add additional, quirked resources. 	 */
for|for
control|(
name|q
operator|=
operator|&
name|pci_quirks
index|[
literal|0
index|]
init|;
name|q
operator|->
name|devid
operator|!=
literal|0
condition|;
name|q
operator|++
control|)
if|if
condition|(
name|q
operator|->
name|devid
operator|==
name|devid
operator|&&
name|q
operator|->
name|type
operator|==
name|PCI_QUIRK_MAP_REG
condition|)
name|pci_add_map
argument_list|(
name|bus
argument_list|,
name|dev
argument_list|,
name|q
operator|->
name|arg1
argument_list|,
name|rl
argument_list|,
name|force
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|intpin
operator|>
literal|0
operator|&&
name|PCI_INTERRUPT_VALID
argument_list|(
name|cfg
operator|->
name|intline
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|__PCI_REROUTE_INTERRUPT
comment|/* 		 * Try to re-route interrupts. Sometimes the BIOS or 		 * firmware may leave bogus values in these registers. 		 * If the re-route fails, then just stick with what we 		 * have. 		 */
name|pci_assign_interrupt
argument_list|(
name|bus
argument_list|,
name|dev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|pci_assign_interrupt
argument_list|(
name|bus
argument_list|,
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|pci_usb_takeover
operator|&&
name|pci_get_class
argument_list|(
name|dev
argument_list|)
operator|==
name|PCIC_SERIALBUS
operator|&&
name|pci_get_subclass
argument_list|(
name|dev
argument_list|)
operator|==
name|PCIS_SERIALBUS_USB
condition|)
block|{
if|if
condition|(
name|pci_get_progif
argument_list|(
name|dev
argument_list|)
operator|==
name|PCIP_SERIALBUS_USB_XHCI
condition|)
name|xhci_early_takeover
argument_list|(
name|dev
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pci_get_progif
argument_list|(
name|dev
argument_list|)
operator|==
name|PCIP_SERIALBUS_USB_EHCI
condition|)
name|ehci_early_takeover
argument_list|(
name|dev
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pci_get_progif
argument_list|(
name|dev
argument_list|)
operator|==
name|PCIP_SERIALBUS_USB_OHCI
condition|)
name|ohci_early_takeover
argument_list|(
name|dev
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pci_get_progif
argument_list|(
name|dev
argument_list|)
operator|==
name|PCIP_SERIALBUS_USB_UHCI
condition|)
name|uhci_early_takeover
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|NEW_PCIB
argument_list|)
operator|&&
name|defined
argument_list|(
name|PCI_RES_BUS
argument_list|)
comment|/* 	 * Reserve resources for secondary bus ranges behind bridge 	 * devices. 	 */
name|pci_reserve_secbus
argument_list|(
name|bus
argument_list|,
name|dev
argument_list|,
name|cfg
argument_list|,
name|rl
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|struct
name|pci_devinfo
modifier|*
name|pci_identify_function
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|int
name|domain
parameter_list|,
name|int
name|busno
parameter_list|,
name|int
name|slot
parameter_list|,
name|int
name|func
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|dinfo
operator|=
name|pci_read_device
argument_list|(
name|pcib
argument_list|,
name|dev
argument_list|,
name|domain
argument_list|,
name|busno
argument_list|,
name|slot
argument_list|,
name|func
argument_list|)
expr_stmt|;
if|if
condition|(
name|dinfo
operator|!=
name|NULL
condition|)
name|pci_add_child
argument_list|(
name|dev
argument_list|,
name|dinfo
argument_list|)
expr_stmt|;
return|return
operator|(
name|dinfo
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pci_add_children
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|domain
parameter_list|,
name|int
name|busno
parameter_list|)
block|{
define|#
directive|define
name|REG
parameter_list|(
name|n
parameter_list|,
name|w
parameter_list|)
value|PCIB_READ_CONFIG(pcib, busno, s, f, n, w)
name|device_t
name|pcib
init|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|int
name|maxslots
decl_stmt|;
name|int
name|s
decl_stmt|,
name|f
decl_stmt|,
name|pcifunchigh
decl_stmt|;
name|uint8_t
name|hdrtype
decl_stmt|;
name|int
name|first_func
decl_stmt|;
comment|/* 	 * Try to detect a device at slot 0, function 0.  If it exists, try to 	 * enable ARI.  We must enable ARI before detecting the rest of the 	 * functions on this bus as ARI changes the set of slots and functions 	 * that are legal on this bus. 	 */
name|dinfo
operator|=
name|pci_identify_function
argument_list|(
name|pcib
argument_list|,
name|dev
argument_list|,
name|domain
argument_list|,
name|busno
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dinfo
operator|!=
name|NULL
operator|&&
name|pci_enable_ari
condition|)
name|PCIB_TRY_ENABLE_ARI
argument_list|(
name|pcib
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * Start looking for new devices on slot 0 at function 1 because we 	 * just identified the device at slot 0, function 0. 	 */
name|first_func
operator|=
literal|1
expr_stmt|;
name|maxslots
operator|=
name|PCIB_MAXSLOTS
argument_list|(
name|pcib
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<=
name|maxslots
condition|;
name|s
operator|++
operator|,
name|first_func
operator|=
literal|0
control|)
block|{
name|pcifunchigh
operator|=
literal|0
expr_stmt|;
name|f
operator|=
literal|0
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|hdrtype
operator|=
name|REG
argument_list|(
name|PCIR_HDRTYPE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hdrtype
operator|&
name|PCIM_HDRTYPE
operator|)
operator|>
name|PCI_MAXHDRTYPE
condition|)
continue|continue;
if|if
condition|(
name|hdrtype
operator|&
name|PCIM_MFDEV
condition|)
name|pcifunchigh
operator|=
name|PCIB_MAXFUNCS
argument_list|(
name|pcib
argument_list|)
expr_stmt|;
for|for
control|(
name|f
operator|=
name|first_func
init|;
name|f
operator|<=
name|pcifunchigh
condition|;
name|f
operator|++
control|)
name|pci_identify_function
argument_list|(
name|pcib
argument_list|,
name|dev
argument_list|,
name|domain
argument_list|,
name|busno
argument_list|,
name|s
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|REG
block|}
end_function

begin_function
name|int
name|pci_rescan_method
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
define|#
directive|define
name|REG
parameter_list|(
name|n
parameter_list|,
name|w
parameter_list|)
value|PCIB_READ_CONFIG(pcib, busno, s, f, n, w)
name|device_t
name|pcib
init|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|pci_softc
modifier|*
name|sc
decl_stmt|;
name|device_t
name|child
decl_stmt|,
modifier|*
name|devlist
decl_stmt|,
modifier|*
name|unchanged
decl_stmt|;
name|int
name|devcount
decl_stmt|,
name|error
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|maxslots
decl_stmt|,
name|oldcount
decl_stmt|;
name|int
name|busno
decl_stmt|,
name|domain
decl_stmt|,
name|s
decl_stmt|,
name|f
decl_stmt|,
name|pcifunchigh
decl_stmt|;
name|uint8_t
name|hdrtype
decl_stmt|;
comment|/* No need to check for ARI on a rescan. */
name|error
operator|=
name|device_get_children
argument_list|(
name|dev
argument_list|,
operator|&
name|devlist
argument_list|,
operator|&
name|devcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|devcount
operator|!=
literal|0
condition|)
block|{
name|unchanged
operator|=
name|malloc
argument_list|(
name|devcount
operator|*
sizeof|sizeof
argument_list|(
name|device_t
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|unchanged
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|devlist
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
block|}
else|else
name|unchanged
operator|=
name|NULL
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|domain
operator|=
name|pcib_get_domain
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|busno
operator|=
name|pcib_get_bus
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|maxslots
operator|=
name|PCIB_MAXSLOTS
argument_list|(
name|pcib
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<=
name|maxslots
condition|;
name|s
operator|++
control|)
block|{
comment|/* If function 0 is not present, skip to the next slot. */
name|f
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|REG
argument_list|(
name|PCIR_VENDOR
argument_list|,
literal|2
argument_list|)
operator|==
literal|0xffff
condition|)
continue|continue;
name|pcifunchigh
operator|=
literal|0
expr_stmt|;
name|hdrtype
operator|=
name|REG
argument_list|(
name|PCIR_HDRTYPE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hdrtype
operator|&
name|PCIM_HDRTYPE
operator|)
operator|>
name|PCI_MAXHDRTYPE
condition|)
continue|continue;
if|if
condition|(
name|hdrtype
operator|&
name|PCIM_MFDEV
condition|)
name|pcifunchigh
operator|=
name|PCIB_MAXFUNCS
argument_list|(
name|pcib
argument_list|)
expr_stmt|;
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<=
name|pcifunchigh
condition|;
name|f
operator|++
control|)
block|{
if|if
condition|(
name|REG
argument_list|(
name|PCIR_VENDOR
argument_list|,
literal|2
argument_list|)
operator|==
literal|0xffff
condition|)
continue|continue;
comment|/* 			 * Found a valid function.  Check if a 			 * device_t for this device already exists. 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|devcount
condition|;
name|i
operator|++
control|)
block|{
name|child
operator|=
name|devlist
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|pci_get_slot
argument_list|(
name|child
argument_list|)
operator|==
name|s
operator|&&
name|pci_get_function
argument_list|(
name|child
argument_list|)
operator|==
name|f
condition|)
block|{
name|unchanged
index|[
name|i
index|]
operator|=
name|child
expr_stmt|;
goto|goto
name|next_func
goto|;
block|}
block|}
name|pci_identify_function
argument_list|(
name|pcib
argument_list|,
name|dev
argument_list|,
name|domain
argument_list|,
name|busno
argument_list|,
name|s
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|next_func
label|:
empty_stmt|;
block|}
block|}
comment|/* Remove devices that are no longer present. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|devcount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|unchanged
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
continue|continue;
name|device_delete_child
argument_list|(
name|dev
argument_list|,
name|devlist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|devlist
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|oldcount
operator|=
name|devcount
expr_stmt|;
comment|/* Try to attach the devices just added. */
name|error
operator|=
name|device_get_children
argument_list|(
name|dev
argument_list|,
operator|&
name|devlist
argument_list|,
operator|&
name|devcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|unchanged
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|devcount
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|oldcount
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|devlist
index|[
name|i
index|]
operator|==
name|unchanged
index|[
name|j
index|]
condition|)
goto|goto
name|next_device
goto|;
block|}
name|device_probe_and_attach
argument_list|(
name|devlist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|next_device
label|:
empty_stmt|;
block|}
name|free
argument_list|(
name|unchanged
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|devlist
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
undef|#
directive|undef
name|REG
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PCI_IOV
end_ifdef

begin_function
name|device_t
name|pci_add_iov_child
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|pf
parameter_list|,
name|uint16_t
name|rid
parameter_list|,
name|uint16_t
name|vid
parameter_list|,
name|uint16_t
name|did
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|pf_dinfo
decl_stmt|,
modifier|*
name|vf_dinfo
decl_stmt|;
name|device_t
name|pcib
decl_stmt|;
name|int
name|busno
decl_stmt|,
name|slot
decl_stmt|,
name|func
decl_stmt|;
name|pf_dinfo
operator|=
name|device_get_ivars
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|pcib
operator|=
name|device_get_parent
argument_list|(
name|bus
argument_list|)
expr_stmt|;
name|PCIB_DECODE_RID
argument_list|(
name|pcib
argument_list|,
name|rid
argument_list|,
operator|&
name|busno
argument_list|,
operator|&
name|slot
argument_list|,
operator|&
name|func
argument_list|)
expr_stmt|;
name|vf_dinfo
operator|=
name|pci_fill_devinfo
argument_list|(
name|pcib
argument_list|,
name|bus
argument_list|,
name|pci_get_domain
argument_list|(
name|pcib
argument_list|)
argument_list|,
name|busno
argument_list|,
name|slot
argument_list|,
name|func
argument_list|,
name|vid
argument_list|,
name|did
argument_list|)
expr_stmt|;
name|vf_dinfo
operator|->
name|cfg
operator|.
name|flags
operator||=
name|PCICFG_VF
expr_stmt|;
name|pci_add_child
argument_list|(
name|bus
argument_list|,
name|vf_dinfo
argument_list|)
expr_stmt|;
return|return
operator|(
name|vf_dinfo
operator|->
name|cfg
operator|.
name|dev
operator|)
return|;
block|}
end_function

begin_function
name|device_t
name|pci_create_iov_child_method
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|pf
parameter_list|,
name|uint16_t
name|rid
parameter_list|,
name|uint16_t
name|vid
parameter_list|,
name|uint16_t
name|did
parameter_list|)
block|{
return|return
operator|(
name|pci_add_iov_child
argument_list|(
name|bus
argument_list|,
name|pf
argument_list|,
name|rid
argument_list|,
name|vid
argument_list|,
name|did
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|pci_add_child
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|struct
name|pci_devinfo
modifier|*
name|dinfo
parameter_list|)
block|{
name|dinfo
operator|->
name|cfg
operator|.
name|dev
operator|=
name|device_add_child
argument_list|(
name|bus
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|device_set_ivars
argument_list|(
name|dinfo
operator|->
name|cfg
operator|.
name|dev
argument_list|,
name|dinfo
argument_list|)
expr_stmt|;
name|resource_list_init
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|)
expr_stmt|;
name|pci_cfg_save
argument_list|(
name|dinfo
operator|->
name|cfg
operator|.
name|dev
argument_list|,
name|dinfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pci_cfg_restore
argument_list|(
name|dinfo
operator|->
name|cfg
operator|.
name|dev
argument_list|,
name|dinfo
argument_list|)
expr_stmt|;
name|pci_print_verbose
argument_list|(
name|dinfo
argument_list|)
expr_stmt|;
name|pci_add_resources
argument_list|(
name|bus
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|dev
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pci_child_added
argument_list|(
name|dinfo
operator|->
name|cfg
operator|.
name|dev
argument_list|)
expr_stmt|;
name|EVENTHANDLER_INVOKE
argument_list|(
name|pci_add_device
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pci_child_added_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{  }
end_function

begin_function
specifier|static
name|int
name|pci_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"PCI bus"
argument_list|)
expr_stmt|;
comment|/* Allow other subclasses to override this driver. */
return|return
operator|(
name|BUS_PROBE_GENERIC
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_attach_common
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|pci_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|busno
decl_stmt|,
name|domain
decl_stmt|;
ifdef|#
directive|ifdef
name|PCI_DMA_BOUNDARY
name|int
name|error
decl_stmt|,
name|tag_valid
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PCI_RES_BUS
name|int
name|rid
decl_stmt|;
endif|#
directive|endif
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|domain
operator|=
name|pcib_get_domain
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|busno
operator|=
name|pcib_get_bus
argument_list|(
name|dev
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PCI_RES_BUS
name|rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_bus
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|PCI_RES_BUS
argument_list|,
operator|&
name|rid
argument_list|,
name|busno
argument_list|,
name|busno
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_bus
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to allocate bus number\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"domain=%d, physical bus=%d\n"
argument_list|,
name|domain
argument_list|,
name|busno
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PCI_DMA_BOUNDARY
name|tag_valid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|device_get_devclass
argument_list|(
name|device_get_parent
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|devclass_find
argument_list|(
literal|"pci"
argument_list|)
condition|)
block|{
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|1
argument_list|,
name|PCI_DMA_BOUNDARY
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|BUS_SPACE_MAXSIZE
argument_list|,
name|BUS_SPACE_UNRESTRICTED
argument_list|,
name|BUS_SPACE_MAXSIZE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|sc_dma_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to create DMA tag: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
else|else
name|tag_valid
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|tag_valid
condition|)
endif|#
directive|endif
name|sc
operator|->
name|sc_dma_tag
operator|=
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pci_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|busno
decl_stmt|,
name|domain
decl_stmt|,
name|error
decl_stmt|;
name|error
operator|=
name|pci_attach_common
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Since there can be multiple independently numbered PCI 	 * buses on systems with multiple PCI domains, we can't use 	 * the unit number to decide which bus we are probing. We ask 	 * the parent pcib what our domain and bus numbers are. 	 */
name|domain
operator|=
name|pcib_get_domain
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|busno
operator|=
name|pcib_get_bus
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_add_children
argument_list|(
name|dev
argument_list|,
name|domain
argument_list|,
name|busno
argument_list|)
expr_stmt|;
return|return
operator|(
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pci_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PCI_RES_BUS
name|struct
name|pci_softc
modifier|*
name|sc
decl_stmt|;
endif|#
directive|endif
name|int
name|error
decl_stmt|;
name|error
operator|=
name|bus_generic_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
ifdef|#
directive|ifdef
name|PCI_RES_BUS
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|PCI_RES_BUS
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
endif|#
directive|endif
return|return
operator|(
name|device_delete_children
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pci_set_power_child
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|device_t
name|pcib
decl_stmt|;
name|int
name|dstate
decl_stmt|;
comment|/* 	 * Set the device to the given state.  If the firmware suggests 	 * a different power state, use it instead.  If power management 	 * is not present, the firmware is responsible for managing 	 * device power.  Skip children who aren't attached since they 	 * are handled separately. 	 */
name|pcib
operator|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dstate
operator|=
name|state
expr_stmt|;
if|if
condition|(
name|device_is_attached
argument_list|(
name|child
argument_list|)
operator|&&
name|PCIB_POWER_FOR_SLEEP
argument_list|(
name|pcib
argument_list|,
name|child
argument_list|,
operator|&
name|dstate
argument_list|)
operator|==
literal|0
condition|)
name|pci_set_powerstate
argument_list|(
name|child
argument_list|,
name|dstate
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pci_suspend_child
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|int
name|error
decl_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
comment|/* 	 * Save the PCI configuration space for the child and set the 	 * device in the appropriate power state for this sleep state. 	 */
name|pci_cfg_save
argument_list|(
name|child
argument_list|,
name|dinfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Suspend devices before potentially powering them down. */
name|error
operator|=
name|bus_generic_suspend_child
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|pci_do_power_suspend
condition|)
name|pci_set_power_child
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|PCI_POWERSTATE_D3
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_resume_child
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
if|if
condition|(
name|pci_do_power_resume
condition|)
name|pci_set_power_child
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|PCI_POWERSTATE_D0
argument_list|)
expr_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|pci_cfg_restore
argument_list|(
name|child
argument_list|,
name|dinfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|device_is_attached
argument_list|(
name|child
argument_list|)
condition|)
name|pci_cfg_save
argument_list|(
name|child
argument_list|,
name|dinfo
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bus_generic_resume_child
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_t
name|child
decl_stmt|,
modifier|*
name|devlist
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|numdevs
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|device_get_children
argument_list|(
name|dev
argument_list|,
operator|&
name|devlist
argument_list|,
operator|&
name|numdevs
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Resume critical devices first, then everything else later. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numdevs
condition|;
name|i
operator|++
control|)
block|{
name|child
operator|=
name|devlist
index|[
name|i
index|]
expr_stmt|;
switch|switch
condition|(
name|pci_get_class
argument_list|(
name|child
argument_list|)
condition|)
block|{
case|case
name|PCIC_DISPLAY
case|:
case|case
name|PCIC_MEMORY
case|:
case|case
name|PCIC_BRIDGE
case|:
case|case
name|PCIC_BASEPERIPH
case|:
name|BUS_RESUME_CHILD
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numdevs
condition|;
name|i
operator|++
control|)
block|{
name|child
operator|=
name|devlist
index|[
name|i
index|]
expr_stmt|;
switch|switch
condition|(
name|pci_get_class
argument_list|(
name|child
argument_list|)
condition|)
block|{
case|case
name|PCIC_DISPLAY
case|:
case|case
name|PCIC_MEMORY
case|:
case|case
name|PCIC_BRIDGE
case|:
case|case
name|PCIC_BASEPERIPH
case|:
break|break;
default|default:
name|BUS_RESUME_CHILD
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|devlist
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pci_load_vendor_data
parameter_list|(
name|void
parameter_list|)
block|{
name|caddr_t
name|data
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
name|size_t
name|sz
decl_stmt|;
name|data
operator|=
name|preload_search_by_type
argument_list|(
literal|"pci_vendor_data"
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|!=
name|NULL
condition|)
block|{
name|ptr
operator|=
name|preload_fetch_addr
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|sz
operator|=
name|preload_fetch_size
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
operator|&&
name|sz
operator|!=
literal|0
condition|)
block|{
name|pci_vendordata
operator|=
name|ptr
expr_stmt|;
name|pci_vendordata_size
operator|=
name|sz
expr_stmt|;
comment|/* terminate the database */
name|pci_vendordata
index|[
name|pci_vendordata_size
index|]
operator|=
literal|'\n'
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|pci_driver_added
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|driver_t
modifier|*
name|driver
parameter_list|)
block|{
name|int
name|numdevs
decl_stmt|;
name|device_t
modifier|*
name|devlist
decl_stmt|;
name|device_t
name|child
decl_stmt|;
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"driver added\n"
argument_list|)
expr_stmt|;
name|DEVICE_IDENTIFY
argument_list|(
name|driver
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_get_children
argument_list|(
name|dev
argument_list|,
operator|&
name|devlist
argument_list|,
operator|&
name|numdevs
argument_list|)
operator|!=
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numdevs
condition|;
name|i
operator|++
control|)
block|{
name|child
operator|=
name|devlist
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|device_get_state
argument_list|(
name|child
argument_list|)
operator|!=
name|DS_NOTPRESENT
condition|)
continue|continue;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|pci_print_verbose
argument_list|(
name|dinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|pci_printf
argument_list|(
operator|&
name|dinfo
operator|->
name|cfg
argument_list|,
literal|"reprobing on driver added\n"
argument_list|)
expr_stmt|;
name|pci_cfg_restore
argument_list|(
name|child
argument_list|,
name|dinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_probe_and_attach
argument_list|(
name|child
argument_list|)
operator|!=
literal|0
condition|)
name|pci_child_detached
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|devlist
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pci_setup_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|resource
modifier|*
name|irq
parameter_list|,
name|int
name|flags
parameter_list|,
name|driver_filter_t
modifier|*
name|filter
parameter_list|,
name|driver_intr_t
modifier|*
name|intr
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|void
modifier|*
modifier|*
name|cookiep
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|struct
name|msix_table_entry
modifier|*
name|mte
decl_stmt|;
name|struct
name|msix_vector
modifier|*
name|mv
decl_stmt|;
name|uint64_t
name|addr
decl_stmt|;
name|uint32_t
name|data
decl_stmt|;
name|void
modifier|*
name|cookie
decl_stmt|;
name|int
name|error
decl_stmt|,
name|rid
decl_stmt|;
name|error
operator|=
name|bus_generic_setup_intr
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|irq
argument_list|,
name|flags
argument_list|,
name|filter
argument_list|,
name|intr
argument_list|,
name|arg
argument_list|,
operator|&
name|cookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* If this is not a direct child, just bail out. */
if|if
condition|(
name|device_get_parent
argument_list|(
name|child
argument_list|)
operator|!=
name|dev
condition|)
block|{
operator|*
name|cookiep
operator|=
name|cookie
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|rid
operator|=
name|rman_get_rid
argument_list|(
name|irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|rid
operator|==
literal|0
condition|)
block|{
comment|/* Make sure that INTx is enabled */
name|pci_clear_command_bit
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|PCIM_CMD_INTxDIS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Check to see if the interrupt is MSI or MSI-X. 		 * Ask our parent to map the MSI and give 		 * us the address and data register values. 		 * If we fail for some reason, teardown the 		 * interrupt handler. 		 */
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|dinfo
operator|->
name|cfg
operator|.
name|msi
operator|.
name|msi_alloc
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|dinfo
operator|->
name|cfg
operator|.
name|msi
operator|.
name|msi_addr
operator|==
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
name|dinfo
operator|->
name|cfg
operator|.
name|msi
operator|.
name|msi_handlers
operator|==
literal|0
argument_list|,
operator|(
literal|"MSI has handlers, but vectors not mapped"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|PCIB_MAP_MSI
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|rman_get_start
argument_list|(
name|irq
argument_list|)
argument_list|,
operator|&
name|addr
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
name|dinfo
operator|->
name|cfg
operator|.
name|msi
operator|.
name|msi_addr
operator|=
name|addr
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|msi
operator|.
name|msi_data
operator|=
name|data
expr_stmt|;
block|}
if|if
condition|(
name|dinfo
operator|->
name|cfg
operator|.
name|msi
operator|.
name|msi_handlers
operator|==
literal|0
condition|)
name|pci_enable_msi
argument_list|(
name|child
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|msi
operator|.
name|msi_addr
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|msi
operator|.
name|msi_data
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|msi
operator|.
name|msi_handlers
operator|++
expr_stmt|;
block|}
else|else
block|{
name|KASSERT
argument_list|(
name|dinfo
operator|->
name|cfg
operator|.
name|msix
operator|.
name|msix_alloc
operator|>
literal|0
argument_list|,
operator|(
literal|"No MSI or MSI-X interrupts allocated"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|rid
operator|<=
name|dinfo
operator|->
name|cfg
operator|.
name|msix
operator|.
name|msix_table_len
argument_list|,
operator|(
literal|"MSI-X index too high"
operator|)
argument_list|)
expr_stmt|;
name|mte
operator|=
operator|&
name|dinfo
operator|->
name|cfg
operator|.
name|msix
operator|.
name|msix_table
index|[
name|rid
operator|-
literal|1
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|mte
operator|->
name|mte_vector
operator|!=
literal|0
argument_list|,
operator|(
literal|"no message vector"
operator|)
argument_list|)
expr_stmt|;
name|mv
operator|=
operator|&
name|dinfo
operator|->
name|cfg
operator|.
name|msix
operator|.
name|msix_vectors
index|[
name|mte
operator|->
name|mte_vector
operator|-
literal|1
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|mv
operator|->
name|mv_irq
operator|==
name|rman_get_start
argument_list|(
name|irq
argument_list|)
argument_list|,
operator|(
literal|"IRQ mismatch"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mv
operator|->
name|mv_address
operator|==
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
name|mte
operator|->
name|mte_handlers
operator|==
literal|0
argument_list|,
operator|(
literal|"MSI-X table entry has handlers, but vector not mapped"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|PCIB_MAP_MSI
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|rman_get_start
argument_list|(
name|irq
argument_list|)
argument_list|,
operator|&
name|addr
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
name|mv
operator|->
name|mv_address
operator|=
name|addr
expr_stmt|;
name|mv
operator|->
name|mv_data
operator|=
name|data
expr_stmt|;
block|}
comment|/* 			 * The MSIX table entry must be made valid by 			 * incrementing the mte_handlers before 			 * calling pci_enable_msix() and 			 * pci_resume_msix(). Else the MSIX rewrite 			 * table quirk will not work as expected. 			 */
name|mte
operator|->
name|mte_handlers
operator|++
expr_stmt|;
if|if
condition|(
name|mte
operator|->
name|mte_handlers
operator|==
literal|1
condition|)
block|{
name|pci_enable_msix
argument_list|(
name|child
argument_list|,
name|rid
operator|-
literal|1
argument_list|,
name|mv
operator|->
name|mv_address
argument_list|,
name|mv
operator|->
name|mv_data
argument_list|)
expr_stmt|;
name|pci_unmask_msix
argument_list|(
name|child
argument_list|,
name|rid
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * Make sure that INTx is disabled if we are using MSI/MSI-X, 		 * unless the device is affected by PCI_QUIRK_MSI_INTX_BUG, 		 * in which case we "enable" INTx so MSI/MSI-X actually works. 		 */
if|if
condition|(
operator|!
name|pci_has_quirk
argument_list|(
name|pci_get_devid
argument_list|(
name|child
argument_list|)
argument_list|,
name|PCI_QUIRK_MSI_INTX_BUG
argument_list|)
condition|)
name|pci_set_command_bit
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|PCIM_CMD_INTxDIS
argument_list|)
expr_stmt|;
else|else
name|pci_clear_command_bit
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|PCIM_CMD_INTxDIS
argument_list|)
expr_stmt|;
name|bad
label|:
if|if
condition|(
name|error
condition|)
block|{
operator|(
name|void
operator|)
name|bus_generic_teardown_intr
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|irq
argument_list|,
name|cookie
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
operator|*
name|cookiep
operator|=
name|cookie
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_teardown_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|resource
modifier|*
name|irq
parameter_list|,
name|void
modifier|*
name|cookie
parameter_list|)
block|{
name|struct
name|msix_table_entry
modifier|*
name|mte
decl_stmt|;
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|int
name|error
decl_stmt|,
name|rid
decl_stmt|;
if|if
condition|(
name|irq
operator|==
name|NULL
operator|||
operator|!
operator|(
name|rman_get_flags
argument_list|(
name|irq
argument_list|)
operator|&
name|RF_ACTIVE
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* If this isn't a direct child, just bail out */
if|if
condition|(
name|device_get_parent
argument_list|(
name|child
argument_list|)
operator|!=
name|dev
condition|)
return|return
operator|(
name|bus_generic_teardown_intr
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|irq
argument_list|,
name|cookie
argument_list|)
operator|)
return|;
name|rid
operator|=
name|rman_get_rid
argument_list|(
name|irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|rid
operator|==
literal|0
condition|)
block|{
comment|/* Mask INTx */
name|pci_set_command_bit
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|PCIM_CMD_INTxDIS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Check to see if the interrupt is MSI or MSI-X.  If so, 		 * decrement the appropriate handlers count and mask the 		 * MSI-X message, or disable MSI messages if the count 		 * drops to 0. 		 */
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|rle
operator|=
name|resource_list_find
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rid
argument_list|)
expr_stmt|;
if|if
condition|(
name|rle
operator|->
name|res
operator|!=
name|irq
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|dinfo
operator|->
name|cfg
operator|.
name|msi
operator|.
name|msi_alloc
operator|>
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
name|rid
operator|<=
name|dinfo
operator|->
name|cfg
operator|.
name|msi
operator|.
name|msi_alloc
argument_list|,
operator|(
literal|"MSI-X index too high"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dinfo
operator|->
name|cfg
operator|.
name|msi
operator|.
name|msi_handlers
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|dinfo
operator|->
name|cfg
operator|.
name|msi
operator|.
name|msi_handlers
operator|--
expr_stmt|;
if|if
condition|(
name|dinfo
operator|->
name|cfg
operator|.
name|msi
operator|.
name|msi_handlers
operator|==
literal|0
condition|)
name|pci_disable_msi
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|KASSERT
argument_list|(
name|dinfo
operator|->
name|cfg
operator|.
name|msix
operator|.
name|msix_alloc
operator|>
literal|0
argument_list|,
operator|(
literal|"No MSI or MSI-X interrupts allocated"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|rid
operator|<=
name|dinfo
operator|->
name|cfg
operator|.
name|msix
operator|.
name|msix_table_len
argument_list|,
operator|(
literal|"MSI-X index too high"
operator|)
argument_list|)
expr_stmt|;
name|mte
operator|=
operator|&
name|dinfo
operator|->
name|cfg
operator|.
name|msix
operator|.
name|msix_table
index|[
name|rid
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|mte
operator|->
name|mte_handlers
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|mte
operator|->
name|mte_handlers
operator|--
expr_stmt|;
if|if
condition|(
name|mte
operator|->
name|mte_handlers
operator|==
literal|0
condition|)
name|pci_mask_msix
argument_list|(
name|child
argument_list|,
name|rid
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|error
operator|=
name|bus_generic_teardown_intr
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|irq
argument_list|,
name|cookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|rid
operator|>
literal|0
condition|)
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: generic teardown failed for MSI/MSI-X"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_print_child
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|struct
name|resource_list
modifier|*
name|rl
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|rl
operator|=
operator|&
name|dinfo
operator|->
name|resources
expr_stmt|;
name|retval
operator|+=
name|bus_print_child_header
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|resource_list_print_type
argument_list|(
name|rl
argument_list|,
literal|"port"
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|"%#jx"
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|resource_list_print_type
argument_list|(
name|rl
argument_list|,
literal|"mem"
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|"%#jx"
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|resource_list_print_type
argument_list|(
name|rl
argument_list|,
literal|"irq"
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|"%jd"
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_get_flags
argument_list|(
name|dev
argument_list|)
condition|)
name|retval
operator|+=
name|printf
argument_list|(
literal|" flags %#x"
argument_list|,
name|device_get_flags
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|printf
argument_list|(
literal|" at device %d.%d"
argument_list|,
name|pci_get_slot
argument_list|(
name|child
argument_list|)
argument_list|,
name|pci_get_function
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|bus_print_child_domain
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|bus_print_child_footer
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|int
name|class
decl_stmt|;
name|int
name|subclass
decl_stmt|;
name|int
name|report
decl_stmt|;
comment|/* 0 = bootverbose, 1 = always */
specifier|const
name|char
modifier|*
name|desc
decl_stmt|;
block|}
name|pci_nomatch_tab
index|[]
init|=
block|{
block|{
name|PCIC_OLD
block|,
operator|-
literal|1
block|,
literal|1
block|,
literal|"old"
block|}
block|,
block|{
name|PCIC_OLD
block|,
name|PCIS_OLD_NONVGA
block|,
literal|1
block|,
literal|"non-VGA display device"
block|}
block|,
block|{
name|PCIC_OLD
block|,
name|PCIS_OLD_VGA
block|,
literal|1
block|,
literal|"VGA-compatible display device"
block|}
block|,
block|{
name|PCIC_STORAGE
block|,
operator|-
literal|1
block|,
literal|1
block|,
literal|"mass storage"
block|}
block|,
block|{
name|PCIC_STORAGE
block|,
name|PCIS_STORAGE_SCSI
block|,
literal|1
block|,
literal|"SCSI"
block|}
block|,
block|{
name|PCIC_STORAGE
block|,
name|PCIS_STORAGE_IDE
block|,
literal|1
block|,
literal|"ATA"
block|}
block|,
block|{
name|PCIC_STORAGE
block|,
name|PCIS_STORAGE_FLOPPY
block|,
literal|1
block|,
literal|"floppy disk"
block|}
block|,
block|{
name|PCIC_STORAGE
block|,
name|PCIS_STORAGE_IPI
block|,
literal|1
block|,
literal|"IPI"
block|}
block|,
block|{
name|PCIC_STORAGE
block|,
name|PCIS_STORAGE_RAID
block|,
literal|1
block|,
literal|"RAID"
block|}
block|,
block|{
name|PCIC_STORAGE
block|,
name|PCIS_STORAGE_ATA_ADMA
block|,
literal|1
block|,
literal|"ATA (ADMA)"
block|}
block|,
block|{
name|PCIC_STORAGE
block|,
name|PCIS_STORAGE_SATA
block|,
literal|1
block|,
literal|"SATA"
block|}
block|,
block|{
name|PCIC_STORAGE
block|,
name|PCIS_STORAGE_SAS
block|,
literal|1
block|,
literal|"SAS"
block|}
block|,
block|{
name|PCIC_STORAGE
block|,
name|PCIS_STORAGE_NVM
block|,
literal|1
block|,
literal|"NVM"
block|}
block|,
block|{
name|PCIC_NETWORK
block|,
operator|-
literal|1
block|,
literal|1
block|,
literal|"network"
block|}
block|,
block|{
name|PCIC_NETWORK
block|,
name|PCIS_NETWORK_ETHERNET
block|,
literal|1
block|,
literal|"ethernet"
block|}
block|,
block|{
name|PCIC_NETWORK
block|,
name|PCIS_NETWORK_TOKENRING
block|,
literal|1
block|,
literal|"token ring"
block|}
block|,
block|{
name|PCIC_NETWORK
block|,
name|PCIS_NETWORK_FDDI
block|,
literal|1
block|,
literal|"fddi"
block|}
block|,
block|{
name|PCIC_NETWORK
block|,
name|PCIS_NETWORK_ATM
block|,
literal|1
block|,
literal|"ATM"
block|}
block|,
block|{
name|PCIC_NETWORK
block|,
name|PCIS_NETWORK_ISDN
block|,
literal|1
block|,
literal|"ISDN"
block|}
block|,
block|{
name|PCIC_DISPLAY
block|,
operator|-
literal|1
block|,
literal|1
block|,
literal|"display"
block|}
block|,
block|{
name|PCIC_DISPLAY
block|,
name|PCIS_DISPLAY_VGA
block|,
literal|1
block|,
literal|"VGA"
block|}
block|,
block|{
name|PCIC_DISPLAY
block|,
name|PCIS_DISPLAY_XGA
block|,
literal|1
block|,
literal|"XGA"
block|}
block|,
block|{
name|PCIC_DISPLAY
block|,
name|PCIS_DISPLAY_3D
block|,
literal|1
block|,
literal|"3D"
block|}
block|,
block|{
name|PCIC_MULTIMEDIA
block|,
operator|-
literal|1
block|,
literal|1
block|,
literal|"multimedia"
block|}
block|,
block|{
name|PCIC_MULTIMEDIA
block|,
name|PCIS_MULTIMEDIA_VIDEO
block|,
literal|1
block|,
literal|"video"
block|}
block|,
block|{
name|PCIC_MULTIMEDIA
block|,
name|PCIS_MULTIMEDIA_AUDIO
block|,
literal|1
block|,
literal|"audio"
block|}
block|,
block|{
name|PCIC_MULTIMEDIA
block|,
name|PCIS_MULTIMEDIA_TELE
block|,
literal|1
block|,
literal|"telephony"
block|}
block|,
block|{
name|PCIC_MULTIMEDIA
block|,
name|PCIS_MULTIMEDIA_HDA
block|,
literal|1
block|,
literal|"HDA"
block|}
block|,
block|{
name|PCIC_MEMORY
block|,
operator|-
literal|1
block|,
literal|1
block|,
literal|"memory"
block|}
block|,
block|{
name|PCIC_MEMORY
block|,
name|PCIS_MEMORY_RAM
block|,
literal|1
block|,
literal|"RAM"
block|}
block|,
block|{
name|PCIC_MEMORY
block|,
name|PCIS_MEMORY_FLASH
block|,
literal|1
block|,
literal|"flash"
block|}
block|,
block|{
name|PCIC_BRIDGE
block|,
operator|-
literal|1
block|,
literal|1
block|,
literal|"bridge"
block|}
block|,
block|{
name|PCIC_BRIDGE
block|,
name|PCIS_BRIDGE_HOST
block|,
literal|1
block|,
literal|"HOST-PCI"
block|}
block|,
block|{
name|PCIC_BRIDGE
block|,
name|PCIS_BRIDGE_ISA
block|,
literal|1
block|,
literal|"PCI-ISA"
block|}
block|,
block|{
name|PCIC_BRIDGE
block|,
name|PCIS_BRIDGE_EISA
block|,
literal|1
block|,
literal|"PCI-EISA"
block|}
block|,
block|{
name|PCIC_BRIDGE
block|,
name|PCIS_BRIDGE_MCA
block|,
literal|1
block|,
literal|"PCI-MCA"
block|}
block|,
block|{
name|PCIC_BRIDGE
block|,
name|PCIS_BRIDGE_PCI
block|,
literal|1
block|,
literal|"PCI-PCI"
block|}
block|,
block|{
name|PCIC_BRIDGE
block|,
name|PCIS_BRIDGE_PCMCIA
block|,
literal|1
block|,
literal|"PCI-PCMCIA"
block|}
block|,
block|{
name|PCIC_BRIDGE
block|,
name|PCIS_BRIDGE_NUBUS
block|,
literal|1
block|,
literal|"PCI-NuBus"
block|}
block|,
block|{
name|PCIC_BRIDGE
block|,
name|PCIS_BRIDGE_CARDBUS
block|,
literal|1
block|,
literal|"PCI-CardBus"
block|}
block|,
block|{
name|PCIC_BRIDGE
block|,
name|PCIS_BRIDGE_RACEWAY
block|,
literal|1
block|,
literal|"PCI-RACEway"
block|}
block|,
block|{
name|PCIC_SIMPLECOMM
block|,
operator|-
literal|1
block|,
literal|1
block|,
literal|"simple comms"
block|}
block|,
block|{
name|PCIC_SIMPLECOMM
block|,
name|PCIS_SIMPLECOMM_UART
block|,
literal|1
block|,
literal|"UART"
block|}
block|,
comment|/* could detect 16550 */
block|{
name|PCIC_SIMPLECOMM
block|,
name|PCIS_SIMPLECOMM_PAR
block|,
literal|1
block|,
literal|"parallel port"
block|}
block|,
block|{
name|PCIC_SIMPLECOMM
block|,
name|PCIS_SIMPLECOMM_MULSER
block|,
literal|1
block|,
literal|"multiport serial"
block|}
block|,
block|{
name|PCIC_SIMPLECOMM
block|,
name|PCIS_SIMPLECOMM_MODEM
block|,
literal|1
block|,
literal|"generic modem"
block|}
block|,
block|{
name|PCIC_BASEPERIPH
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|"base peripheral"
block|}
block|,
block|{
name|PCIC_BASEPERIPH
block|,
name|PCIS_BASEPERIPH_PIC
block|,
literal|1
block|,
literal|"interrupt controller"
block|}
block|,
block|{
name|PCIC_BASEPERIPH
block|,
name|PCIS_BASEPERIPH_DMA
block|,
literal|1
block|,
literal|"DMA controller"
block|}
block|,
block|{
name|PCIC_BASEPERIPH
block|,
name|PCIS_BASEPERIPH_TIMER
block|,
literal|1
block|,
literal|"timer"
block|}
block|,
block|{
name|PCIC_BASEPERIPH
block|,
name|PCIS_BASEPERIPH_RTC
block|,
literal|1
block|,
literal|"realtime clock"
block|}
block|,
block|{
name|PCIC_BASEPERIPH
block|,
name|PCIS_BASEPERIPH_PCIHOT
block|,
literal|1
block|,
literal|"PCI hot-plug controller"
block|}
block|,
block|{
name|PCIC_BASEPERIPH
block|,
name|PCIS_BASEPERIPH_SDHC
block|,
literal|1
block|,
literal|"SD host controller"
block|}
block|,
block|{
name|PCIC_BASEPERIPH
block|,
name|PCIS_BASEPERIPH_IOMMU
block|,
literal|1
block|,
literal|"IOMMU"
block|}
block|,
block|{
name|PCIC_INPUTDEV
block|,
operator|-
literal|1
block|,
literal|1
block|,
literal|"input device"
block|}
block|,
block|{
name|PCIC_INPUTDEV
block|,
name|PCIS_INPUTDEV_KEYBOARD
block|,
literal|1
block|,
literal|"keyboard"
block|}
block|,
block|{
name|PCIC_INPUTDEV
block|,
name|PCIS_INPUTDEV_DIGITIZER
block|,
literal|1
block|,
literal|"digitizer"
block|}
block|,
block|{
name|PCIC_INPUTDEV
block|,
name|PCIS_INPUTDEV_MOUSE
block|,
literal|1
block|,
literal|"mouse"
block|}
block|,
block|{
name|PCIC_INPUTDEV
block|,
name|PCIS_INPUTDEV_SCANNER
block|,
literal|1
block|,
literal|"scanner"
block|}
block|,
block|{
name|PCIC_INPUTDEV
block|,
name|PCIS_INPUTDEV_GAMEPORT
block|,
literal|1
block|,
literal|"gameport"
block|}
block|,
block|{
name|PCIC_DOCKING
block|,
operator|-
literal|1
block|,
literal|1
block|,
literal|"docking station"
block|}
block|,
block|{
name|PCIC_PROCESSOR
block|,
operator|-
literal|1
block|,
literal|1
block|,
literal|"processor"
block|}
block|,
block|{
name|PCIC_SERIALBUS
block|,
operator|-
literal|1
block|,
literal|1
block|,
literal|"serial bus"
block|}
block|,
block|{
name|PCIC_SERIALBUS
block|,
name|PCIS_SERIALBUS_FW
block|,
literal|1
block|,
literal|"FireWire"
block|}
block|,
block|{
name|PCIC_SERIALBUS
block|,
name|PCIS_SERIALBUS_ACCESS
block|,
literal|1
block|,
literal|"AccessBus"
block|}
block|,
block|{
name|PCIC_SERIALBUS
block|,
name|PCIS_SERIALBUS_SSA
block|,
literal|1
block|,
literal|"SSA"
block|}
block|,
block|{
name|PCIC_SERIALBUS
block|,
name|PCIS_SERIALBUS_USB
block|,
literal|1
block|,
literal|"USB"
block|}
block|,
block|{
name|PCIC_SERIALBUS
block|,
name|PCIS_SERIALBUS_FC
block|,
literal|1
block|,
literal|"Fibre Channel"
block|}
block|,
block|{
name|PCIC_SERIALBUS
block|,
name|PCIS_SERIALBUS_SMBUS
block|,
literal|0
block|,
literal|"SMBus"
block|}
block|,
block|{
name|PCIC_WIRELESS
block|,
operator|-
literal|1
block|,
literal|1
block|,
literal|"wireless controller"
block|}
block|,
block|{
name|PCIC_WIRELESS
block|,
name|PCIS_WIRELESS_IRDA
block|,
literal|1
block|,
literal|"iRDA"
block|}
block|,
block|{
name|PCIC_WIRELESS
block|,
name|PCIS_WIRELESS_IR
block|,
literal|1
block|,
literal|"IR"
block|}
block|,
block|{
name|PCIC_WIRELESS
block|,
name|PCIS_WIRELESS_RF
block|,
literal|1
block|,
literal|"RF"
block|}
block|,
block|{
name|PCIC_INTELLIIO
block|,
operator|-
literal|1
block|,
literal|1
block|,
literal|"intelligent I/O controller"
block|}
block|,
block|{
name|PCIC_INTELLIIO
block|,
name|PCIS_INTELLIIO_I2O
block|,
literal|1
block|,
literal|"I2O"
block|}
block|,
block|{
name|PCIC_SATCOM
block|,
operator|-
literal|1
block|,
literal|1
block|,
literal|"satellite communication"
block|}
block|,
block|{
name|PCIC_SATCOM
block|,
name|PCIS_SATCOM_TV
block|,
literal|1
block|,
literal|"sat TV"
block|}
block|,
block|{
name|PCIC_SATCOM
block|,
name|PCIS_SATCOM_AUDIO
block|,
literal|1
block|,
literal|"sat audio"
block|}
block|,
block|{
name|PCIC_SATCOM
block|,
name|PCIS_SATCOM_VOICE
block|,
literal|1
block|,
literal|"sat voice"
block|}
block|,
block|{
name|PCIC_SATCOM
block|,
name|PCIS_SATCOM_DATA
block|,
literal|1
block|,
literal|"sat data"
block|}
block|,
block|{
name|PCIC_CRYPTO
block|,
operator|-
literal|1
block|,
literal|1
block|,
literal|"encrypt/decrypt"
block|}
block|,
block|{
name|PCIC_CRYPTO
block|,
name|PCIS_CRYPTO_NETCOMP
block|,
literal|1
block|,
literal|"network/computer crypto"
block|}
block|,
block|{
name|PCIC_CRYPTO
block|,
name|PCIS_CRYPTO_ENTERTAIN
block|,
literal|1
block|,
literal|"entertainment crypto"
block|}
block|,
block|{
name|PCIC_DASP
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|"dasp"
block|}
block|,
block|{
name|PCIC_DASP
block|,
name|PCIS_DASP_DPIO
block|,
literal|1
block|,
literal|"DPIO module"
block|}
block|,
block|{
name|PCIC_DASP
block|,
name|PCIS_DASP_PERFCNTRS
block|,
literal|1
block|,
literal|"performance counters"
block|}
block|,
block|{
name|PCIC_DASP
block|,
name|PCIS_DASP_COMM_SYNC
block|,
literal|1
block|,
literal|"communication synchronizer"
block|}
block|,
block|{
name|PCIC_DASP
block|,
name|PCIS_DASP_MGMT_CARD
block|,
literal|1
block|,
literal|"signal processing management"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_function
name|void
name|pci_probe_nomatch
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|report
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|scp
decl_stmt|;
name|char
modifier|*
name|device
decl_stmt|;
comment|/* 	 * Look for a listing for this device in a loaded device database. 	 */
name|report
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|device
operator|=
name|pci_describe_device
argument_list|(
name|child
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"<%s>"
argument_list|,
name|device
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|device
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Scan the class/subclass descriptions for a general 		 * description. 		 */
name|cp
operator|=
literal|"unknown"
expr_stmt|;
name|scp
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|pci_nomatch_tab
index|[
name|i
index|]
operator|.
name|desc
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pci_nomatch_tab
index|[
name|i
index|]
operator|.
name|class
operator|==
name|pci_get_class
argument_list|(
name|child
argument_list|)
condition|)
block|{
if|if
condition|(
name|pci_nomatch_tab
index|[
name|i
index|]
operator|.
name|subclass
operator|==
operator|-
literal|1
condition|)
block|{
name|cp
operator|=
name|pci_nomatch_tab
index|[
name|i
index|]
operator|.
name|desc
expr_stmt|;
name|report
operator|=
name|pci_nomatch_tab
index|[
name|i
index|]
operator|.
name|report
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pci_nomatch_tab
index|[
name|i
index|]
operator|.
name|subclass
operator|==
name|pci_get_subclass
argument_list|(
name|child
argument_list|)
condition|)
block|{
name|scp
operator|=
name|pci_nomatch_tab
index|[
name|i
index|]
operator|.
name|desc
expr_stmt|;
name|report
operator|=
name|pci_nomatch_tab
index|[
name|i
index|]
operator|.
name|report
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|report
operator|||
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"<%s%s%s>"
argument_list|,
name|cp
condition|?
name|cp
else|:
literal|""
argument_list|,
operator|(
operator|(
name|cp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|scp
operator|!=
name|NULL
operator|)
operator|)
condition|?
literal|", "
else|:
literal|""
argument_list|,
name|scp
condition|?
name|scp
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|report
operator|||
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|" at device %d.%d (no driver attached)\n"
argument_list|,
name|pci_get_slot
argument_list|(
name|child
argument_list|)
argument_list|,
name|pci_get_function
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pci_cfg_save
argument_list|(
name|child
argument_list|,
name|device_get_ivars
argument_list|(
name|child
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pci_child_detached
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|struct
name|resource_list
modifier|*
name|rl
decl_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|rl
operator|=
operator|&
name|dinfo
operator|->
name|resources
expr_stmt|;
comment|/* 	 * Have to deallocate IRQs before releasing any MSI messages and 	 * have to release MSI messages before deallocating any memory 	 * BARs. 	 */
if|if
condition|(
name|resource_list_release_active
argument_list|(
name|rl
argument_list|,
name|dev
argument_list|,
name|child
argument_list|,
name|SYS_RES_IRQ
argument_list|)
operator|!=
literal|0
condition|)
name|pci_printf
argument_list|(
operator|&
name|dinfo
operator|->
name|cfg
argument_list|,
literal|"Device leaked IRQ resources\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dinfo
operator|->
name|cfg
operator|.
name|msi
operator|.
name|msi_alloc
operator|!=
literal|0
operator|||
name|dinfo
operator|->
name|cfg
operator|.
name|msix
operator|.
name|msix_alloc
operator|!=
literal|0
condition|)
block|{
name|pci_printf
argument_list|(
operator|&
name|dinfo
operator|->
name|cfg
argument_list|,
literal|"Device leaked MSI vectors\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pci_release_msi
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|resource_list_release_active
argument_list|(
name|rl
argument_list|,
name|dev
argument_list|,
name|child
argument_list|,
name|SYS_RES_MEMORY
argument_list|)
operator|!=
literal|0
condition|)
name|pci_printf
argument_list|(
operator|&
name|dinfo
operator|->
name|cfg
argument_list|,
literal|"Device leaked memory resources\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|resource_list_release_active
argument_list|(
name|rl
argument_list|,
name|dev
argument_list|,
name|child
argument_list|,
name|SYS_RES_IOPORT
argument_list|)
operator|!=
literal|0
condition|)
name|pci_printf
argument_list|(
operator|&
name|dinfo
operator|->
name|cfg
argument_list|,
literal|"Device leaked I/O resources\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PCI_RES_BUS
if|if
condition|(
name|resource_list_release_active
argument_list|(
name|rl
argument_list|,
name|dev
argument_list|,
name|child
argument_list|,
name|PCI_RES_BUS
argument_list|)
operator|!=
literal|0
condition|)
name|pci_printf
argument_list|(
operator|&
name|dinfo
operator|->
name|cfg
argument_list|,
literal|"Device leaked PCI bus numbers\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pci_cfg_save
argument_list|(
name|child
argument_list|,
name|dinfo
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Parse the PCI device database, if loaded, and return a pointer to a  * description of the device.  *  * The database is flat text formatted as follows:  *  * Any line not in a valid format is ignored.  * Lines are terminated with newline '\n' characters.  *  * A VENDOR line consists of the 4 digit (hex) vendor code, a TAB, then  * the vendor name.  *  * A DEVICE line is entered immediately below the corresponding VENDOR ID.  * - devices cannot be listed without a corresponding VENDOR line.  * A DEVICE line consists of a TAB, the 4 digit (hex) device code,  * another TAB, then the device name.  */
end_comment

begin_comment
comment|/*  * Assuming (ptr) points to the beginning of a line in the database,  * return the vendor or device and description of the next entry.  * The value of (vendor) or (device) inappropriate for the entry type  * is set to -1.  Returns nonzero at the end of the database.  *  * Note that this is slightly unrobust in the face of corrupt data;  * we attempt to safeguard against this by spamming the end of the  * database with a newline when we initialise.  */
end_comment

begin_function
specifier|static
name|int
name|pci_describe_parse_line
parameter_list|(
name|char
modifier|*
modifier|*
name|ptr
parameter_list|,
name|int
modifier|*
name|vendor
parameter_list|,
name|int
modifier|*
name|device
parameter_list|,
name|char
modifier|*
modifier|*
name|desc
parameter_list|)
block|{
name|char
modifier|*
name|cp
init|=
operator|*
name|ptr
decl_stmt|;
name|int
name|left
decl_stmt|;
operator|*
name|device
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|vendor
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
operator|*
name|desc
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|left
operator|=
name|pci_vendordata_size
operator|-
operator|(
name|cp
operator|-
name|pci_vendordata
operator|)
expr_stmt|;
if|if
condition|(
name|left
operator|<=
literal|0
condition|)
block|{
operator|*
name|ptr
operator|=
name|cp
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* vendor entry? */
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'\t'
operator|&&
name|sscanf
argument_list|(
name|cp
argument_list|,
literal|"%x\t%80[^\n]"
argument_list|,
name|vendor
argument_list|,
operator|*
name|desc
argument_list|)
operator|==
literal|2
condition|)
break|break;
comment|/* device entry? */
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\t'
operator|&&
name|sscanf
argument_list|(
name|cp
argument_list|,
literal|"%x\t%80[^\n]"
argument_list|,
name|device
argument_list|,
operator|*
name|desc
argument_list|)
operator|==
literal|2
condition|)
break|break;
comment|/* skip to next line */
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\n'
operator|&&
name|left
operator|>
literal|0
condition|)
block|{
name|cp
operator|++
expr_stmt|;
name|left
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\n'
condition|)
block|{
name|cp
operator|++
expr_stmt|;
name|left
operator|--
expr_stmt|;
block|}
block|}
comment|/* skip to next line */
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\n'
operator|&&
name|left
operator|>
literal|0
condition|)
block|{
name|cp
operator|++
expr_stmt|;
name|left
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\n'
operator|&&
name|left
operator|>
literal|0
condition|)
name|cp
operator|++
expr_stmt|;
operator|*
name|ptr
operator|=
name|cp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|pci_describe_device
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|vendor
decl_stmt|,
name|device
decl_stmt|;
name|char
modifier|*
name|desc
decl_stmt|,
modifier|*
name|vp
decl_stmt|,
modifier|*
name|dp
decl_stmt|,
modifier|*
name|line
decl_stmt|;
name|desc
operator|=
name|vp
operator|=
name|dp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * If we have no vendor data, we can't do anything. 	 */
if|if
condition|(
name|pci_vendordata
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Scan the vendor data looking for this device 	 */
name|line
operator|=
name|pci_vendordata
expr_stmt|;
if|if
condition|(
operator|(
name|vp
operator|=
name|malloc
argument_list|(
literal|80
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|pci_describe_parse_line
argument_list|(
operator|&
name|line
argument_list|,
operator|&
name|vendor
argument_list|,
operator|&
name|device
argument_list|,
operator|&
name|vp
argument_list|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|vendor
operator|==
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|dp
operator|=
name|malloc
argument_list|(
literal|80
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|pci_describe_parse_line
argument_list|(
operator|&
name|line
argument_list|,
operator|&
name|vendor
argument_list|,
operator|&
name|device
argument_list|,
operator|&
name|dp
argument_list|)
condition|)
block|{
operator|*
name|dp
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|vendor
operator|!=
operator|-
literal|1
condition|)
block|{
operator|*
name|dp
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|device
operator|==
name|pci_get_device
argument_list|(
name|dev
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|dp
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|snprintf
argument_list|(
name|dp
argument_list|,
literal|80
argument_list|,
literal|"0x%x"
argument_list|,
name|pci_get_device
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|desc
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|vp
argument_list|)
operator|+
name|strlen
argument_list|(
name|dp
argument_list|)
operator|+
literal|3
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|sprintf
argument_list|(
name|desc
argument_list|,
literal|"%s, %s"
argument_list|,
name|vp
argument_list|,
name|dp
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|vp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|vp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|dp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|desc
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_read_ivar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|which
parameter_list|,
name|uintptr_t
modifier|*
name|result
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
decl_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|cfg
operator|=
operator|&
name|dinfo
operator|->
name|cfg
expr_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|PCI_IVAR_ETHADDR
case|:
comment|/* 		 * The generic accessor doesn't deal with failure, so 		 * we set the return value, then return an error. 		 */
operator|*
operator|(
operator|(
name|uint8_t
operator|*
operator|*
operator|)
name|result
operator|)
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
case|case
name|PCI_IVAR_SUBVENDOR
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|subvendor
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_SUBDEVICE
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|subdevice
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_VENDOR
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|vendor
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_DEVICE
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|device
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_DEVID
case|:
operator|*
name|result
operator|=
operator|(
name|cfg
operator|->
name|device
operator|<<
literal|16
operator|)
operator||
name|cfg
operator|->
name|vendor
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_CLASS
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|baseclass
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_SUBCLASS
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|subclass
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_PROGIF
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|progif
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_REVID
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|revid
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_INTPIN
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|intpin
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_IRQ
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|intline
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_DOMAIN
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|domain
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_BUS
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|bus
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_SLOT
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|slot
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_FUNCTION
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|func
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_CMDREG
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|cmdreg
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_CACHELNSZ
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|cachelnsz
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_MINGNT
case|:
if|if
condition|(
name|cfg
operator|->
name|hdrtype
operator|!=
name|PCIM_HDRTYPE_NORMAL
condition|)
block|{
operator|*
name|result
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
operator|*
name|result
operator|=
name|cfg
operator|->
name|mingnt
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_MAXLAT
case|:
if|if
condition|(
name|cfg
operator|->
name|hdrtype
operator|!=
name|PCIM_HDRTYPE_NORMAL
condition|)
block|{
operator|*
name|result
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
operator|*
name|result
operator|=
name|cfg
operator|->
name|maxlat
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_LATTIMER
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|lattimer
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_write_ivar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|which
parameter_list|,
name|uintptr_t
name|value
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|PCI_IVAR_INTPIN
case|:
name|dinfo
operator|->
name|cfg
operator|.
name|intpin
operator|=
name|value
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|PCI_IVAR_ETHADDR
case|:
case|case
name|PCI_IVAR_SUBVENDOR
case|:
case|case
name|PCI_IVAR_SUBDEVICE
case|:
case|case
name|PCI_IVAR_VENDOR
case|:
case|case
name|PCI_IVAR_DEVICE
case|:
case|case
name|PCI_IVAR_DEVID
case|:
case|case
name|PCI_IVAR_CLASS
case|:
case|case
name|PCI_IVAR_SUBCLASS
case|:
case|case
name|PCI_IVAR_PROGIF
case|:
case|case
name|PCI_IVAR_REVID
case|:
case|case
name|PCI_IVAR_IRQ
case|:
case|case
name|PCI_IVAR_DOMAIN
case|:
case|case
name|PCI_IVAR_BUS
case|:
case|case
name|PCI_IVAR_SLOT
case|:
case|case
name|PCI_IVAR_FUNCTION
case|:
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* disallow for now */
default|default:
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
block|}
end_function

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_include
include|#
directive|include
file|<sys/cons.h>
end_include

begin_comment
comment|/*  * List resources based on pci map registers, used for within ddb  */
end_comment

begin_macro
name|DB_SHOW_COMMAND
argument_list|(
argument|pciregs
argument_list|,
argument|db_pci_dump
argument_list|)
end_macro

begin_block
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|struct
name|devlist
modifier|*
name|devlist_head
decl_stmt|;
name|struct
name|pci_conf
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|,
name|none_count
decl_stmt|;
name|none_count
operator|=
literal|0
expr_stmt|;
comment|/* get the head of the device queue */
name|devlist_head
operator|=
operator|&
name|pci_devq
expr_stmt|;
comment|/* 	 * Go through the list of devices and print out devices 	 */
for|for
control|(
name|error
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
operator|,
name|dinfo
operator|=
name|STAILQ_FIRST
argument_list|(
name|devlist_head
argument_list|)
init|;
operator|(
name|dinfo
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|error
operator|==
literal|0
operator|)
operator|&&
operator|(
name|i
operator|<
name|pci_numdevs
operator|)
operator|&&
operator|!
name|db_pager_quit
condition|;
name|dinfo
operator|=
name|STAILQ_NEXT
argument_list|(
name|dinfo
argument_list|,
name|pci_links
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
comment|/* Populate pd_name and pd_unit */
name|name
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dinfo
operator|->
name|cfg
operator|.
name|dev
condition|)
name|name
operator|=
name|device_get_name
argument_list|(
name|dinfo
operator|->
name|cfg
operator|.
name|dev
argument_list|)
expr_stmt|;
name|p
operator|=
operator|&
name|dinfo
operator|->
name|conf
expr_stmt|;
name|db_printf
argument_list|(
literal|"%s%d@pci%d:%d:%d:%d:\tclass=0x%06x card=0x%08x "
literal|"chip=0x%08x rev=0x%02x hdr=0x%02x\n"
argument_list|,
operator|(
name|name
operator|&&
operator|*
name|name
operator|)
condition|?
name|name
else|:
literal|"none"
argument_list|,
operator|(
name|name
operator|&&
operator|*
name|name
operator|)
condition|?
operator|(
name|int
operator|)
name|device_get_unit
argument_list|(
name|dinfo
operator|->
name|cfg
operator|.
name|dev
argument_list|)
else|:
name|none_count
operator|++
argument_list|,
name|p
operator|->
name|pc_sel
operator|.
name|pc_domain
argument_list|,
name|p
operator|->
name|pc_sel
operator|.
name|pc_bus
argument_list|,
name|p
operator|->
name|pc_sel
operator|.
name|pc_dev
argument_list|,
name|p
operator|->
name|pc_sel
operator|.
name|pc_func
argument_list|,
operator|(
name|p
operator|->
name|pc_class
operator|<<
literal|16
operator|)
operator||
operator|(
name|p
operator|->
name|pc_subclass
operator|<<
literal|8
operator|)
operator||
name|p
operator|->
name|pc_progif
argument_list|,
operator|(
name|p
operator|->
name|pc_subdevice
operator|<<
literal|16
operator|)
operator||
name|p
operator|->
name|pc_subvendor
argument_list|,
operator|(
name|p
operator|->
name|pc_device
operator|<<
literal|16
operator|)
operator||
name|p
operator|->
name|pc_vendor
argument_list|,
name|p
operator|->
name|pc_revid
argument_list|,
name|p
operator|->
name|pc_hdr
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DDB */
end_comment

begin_function
specifier|static
name|struct
name|resource
modifier|*
name|pci_reserve_map
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|rid
parameter_list|,
name|rman_res_t
name|start
parameter_list|,
name|rman_res_t
name|end
parameter_list|,
name|rman_res_t
name|count
parameter_list|,
name|u_int
name|num
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|struct
name|resource_list
modifier|*
name|rl
init|=
operator|&
name|dinfo
operator|->
name|resources
decl_stmt|;
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|struct
name|pci_map
modifier|*
name|pm
decl_stmt|;
name|uint16_t
name|cmd
decl_stmt|;
name|pci_addr_t
name|map
decl_stmt|,
name|testval
decl_stmt|;
name|int
name|mapsize
decl_stmt|;
name|res
operator|=
name|NULL
expr_stmt|;
comment|/* If rid is managed by EA, ignore it */
if|if
condition|(
name|pci_ea_is_enabled
argument_list|(
name|child
argument_list|,
operator|*
name|rid
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|pm
operator|=
name|pci_find_bar
argument_list|(
name|child
argument_list|,
operator|*
name|rid
argument_list|)
expr_stmt|;
if|if
condition|(
name|pm
operator|!=
name|NULL
condition|)
block|{
comment|/* This is a BAR that we failed to allocate earlier. */
name|mapsize
operator|=
name|pm
operator|->
name|pm_size
expr_stmt|;
name|map
operator|=
name|pm
operator|->
name|pm_value
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Weed out the bogons, and figure out how large the 		 * BAR/map is.  BARs that read back 0 here are bogus 		 * and unimplemented.  Note: atapci in legacy mode are 		 * special and handled elsewhere in the code.  If you 		 * have a atapci device in legacy mode and it fails 		 * here, that other code is broken. 		 */
name|pci_read_bar
argument_list|(
name|child
argument_list|,
operator|*
name|rid
argument_list|,
operator|&
name|map
argument_list|,
operator|&
name|testval
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 		 * Determine the size of the BAR and ignore BARs with a size 		 * of 0.  Device ROM BARs use a different mask value. 		 */
if|if
condition|(
name|PCIR_IS_BIOS
argument_list|(
operator|&
name|dinfo
operator|->
name|cfg
argument_list|,
operator|*
name|rid
argument_list|)
condition|)
name|mapsize
operator|=
name|pci_romsize
argument_list|(
name|testval
argument_list|)
expr_stmt|;
else|else
name|mapsize
operator|=
name|pci_mapsize
argument_list|(
name|testval
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapsize
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
name|pm
operator|=
name|pci_add_bar
argument_list|(
name|child
argument_list|,
operator|*
name|rid
argument_list|,
name|map
argument_list|,
name|mapsize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|PCI_BAR_MEM
argument_list|(
name|map
argument_list|)
operator|||
name|PCIR_IS_BIOS
argument_list|(
operator|&
name|dinfo
operator|->
name|cfg
argument_list|,
operator|*
name|rid
argument_list|)
condition|)
block|{
if|if
condition|(
name|type
operator|!=
name|SYS_RES_MEMORY
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"child %s requested type %d for rid %#x,"
literal|" but the BAR says it is an memio\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|child
argument_list|)
argument_list|,
name|type
argument_list|,
operator|*
name|rid
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|type
operator|!=
name|SYS_RES_IOPORT
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"child %s requested type %d for rid %#x,"
literal|" but the BAR says it is an ioport\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|child
argument_list|)
argument_list|,
name|type
argument_list|,
operator|*
name|rid
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
comment|/* 	 * For real BARs, we need to override the size that 	 * the driver requests, because that's what the BAR 	 * actually uses and we would otherwise have a 	 * situation where we might allocate the excess to 	 * another driver, which won't work. 	 */
name|count
operator|=
operator|(
operator|(
name|pci_addr_t
operator|)
literal|1
operator|<<
name|mapsize
operator|)
operator|*
name|num
expr_stmt|;
if|if
condition|(
name|RF_ALIGNMENT
argument_list|(
name|flags
argument_list|)
operator|<
name|mapsize
condition|)
name|flags
operator|=
operator|(
name|flags
operator|&
operator|~
name|RF_ALIGNMENT_MASK
operator|)
operator||
name|RF_ALIGNMENT_LOG2
argument_list|(
name|mapsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|PCI_BAR_MEM
argument_list|(
name|map
argument_list|)
operator|&&
operator|(
name|map
operator|&
name|PCIM_BAR_MEM_PREFETCH
operator|)
condition|)
name|flags
operator||=
name|RF_PREFETCHABLE
expr_stmt|;
comment|/* 	 * Allocate enough resource, and then write back the 	 * appropriate BAR for that resource. 	 */
name|resource_list_add
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
operator|*
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|res
operator|=
name|resource_list_reserve
argument_list|(
name|rl
argument_list|,
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
operator|&
operator|~
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
block|{
name|resource_list_delete
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
operator|*
name|rid
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|child
argument_list|,
literal|"%#jx bytes of rid %#x res %d failed (%#jx, %#jx).\n"
argument_list|,
name|count
argument_list|,
operator|*
name|rid
argument_list|,
name|type
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|child
argument_list|,
literal|"Lazy allocation of %#jx bytes rid %#x type %d at %#jx\n"
argument_list|,
name|count
argument_list|,
operator|*
name|rid
argument_list|,
name|type
argument_list|,
name|rman_get_start
argument_list|(
name|res
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Disable decoding via the CMD register before updating the BAR */
name|cmd
operator|=
name|pci_read_config
argument_list|(
name|child
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|child
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|cmd
operator|&
operator|~
operator|(
name|PCI_BAR_MEM
argument_list|(
name|map
argument_list|)
condition|?
name|PCIM_CMD_MEMEN
else|:
name|PCIM_CMD_PORTEN
operator|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|map
operator|=
name|rman_get_start
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|pci_write_bar
argument_list|(
name|child
argument_list|,
name|pm
argument_list|,
name|map
argument_list|)
expr_stmt|;
comment|/* Restore the original value of the CMD register */
name|pci_write_config
argument_list|(
name|child
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|cmd
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|out
label|:
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|resource
modifier|*
name|pci_alloc_multi_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|rid
parameter_list|,
name|rman_res_t
name|start
parameter_list|,
name|rman_res_t
name|end
parameter_list|,
name|rman_res_t
name|count
parameter_list|,
name|u_long
name|num
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|struct
name|resource_list
modifier|*
name|rl
decl_stmt|;
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
decl_stmt|;
comment|/* 	 * Perform lazy resource allocation 	 */
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|rl
operator|=
operator|&
name|dinfo
operator|->
name|resources
expr_stmt|;
name|cfg
operator|=
operator|&
name|dinfo
operator|->
name|cfg
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|NEW_PCIB
argument_list|)
operator|&&
name|defined
argument_list|(
name|PCI_RES_BUS
argument_list|)
case|case
name|PCI_RES_BUS
case|:
return|return
operator|(
name|pci_alloc_secbus
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
operator|)
return|;
endif|#
directive|endif
case|case
name|SYS_RES_IRQ
case|:
comment|/* 		 * Can't alloc legacy interrupt once MSI messages have 		 * been allocated. 		 */
if|if
condition|(
operator|*
name|rid
operator|==
literal|0
operator|&&
operator|(
name|cfg
operator|->
name|msi
operator|.
name|msi_alloc
operator|>
literal|0
operator|||
name|cfg
operator|->
name|msix
operator|.
name|msix_alloc
operator|>
literal|0
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 		 * If the child device doesn't have an interrupt 		 * routed and is deserving of an interrupt, try to 		 * assign it one. 		 */
if|if
condition|(
operator|*
name|rid
operator|==
literal|0
operator|&&
operator|!
name|PCI_INTERRUPT_VALID
argument_list|(
name|cfg
operator|->
name|intline
argument_list|)
operator|&&
operator|(
name|cfg
operator|->
name|intpin
operator|!=
literal|0
operator|)
condition|)
name|pci_assign_interrupt
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYS_RES_IOPORT
case|:
case|case
name|SYS_RES_MEMORY
case|:
ifdef|#
directive|ifdef
name|NEW_PCIB
comment|/* 		 * PCI-PCI bridge I/O window resources are not BARs. 		 * For those allocations just pass the request up the 		 * tree. 		 */
if|if
condition|(
name|cfg
operator|->
name|hdrtype
operator|==
name|PCIM_HDRTYPE_BRIDGE
condition|)
block|{
switch|switch
condition|(
operator|*
name|rid
condition|)
block|{
case|case
name|PCIR_IOBASEL_1
case|:
case|case
name|PCIR_MEMBASE_1
case|:
case|case
name|PCIR_PMBASEL_1
case|:
comment|/* 				 * XXX: Should we bother creating a resource 				 * list entry? 				 */
return|return
operator|(
name|bus_generic_alloc_resource
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
block|}
endif|#
directive|endif
comment|/* Reserve resources for this BAR if needed. */
name|rle
operator|=
name|resource_list_find
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
operator|*
name|rid
argument_list|)
expr_stmt|;
if|if
condition|(
name|rle
operator|==
name|NULL
condition|)
block|{
name|res
operator|=
name|pci_reserve_map
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|num
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
return|return
operator|(
name|resource_list_alloc
argument_list|(
name|rl
argument_list|,
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|resource
modifier|*
name|pci_alloc_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|rid
parameter_list|,
name|rman_res_t
name|start
parameter_list|,
name|rman_res_t
name|end
parameter_list|,
name|rman_res_t
name|count
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PCI_IOV
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|device_get_parent
argument_list|(
name|child
argument_list|)
operator|!=
name|dev
condition|)
return|return
operator|(
name|BUS_ALLOC_RESOURCE
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
operator|)
return|;
ifdef|#
directive|ifdef
name|PCI_IOV
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|dinfo
operator|->
name|cfg
operator|.
name|flags
operator|&
name|PCICFG_VF
condition|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
comment|/* VFs can't have I/O BARs. */
case|case
name|SYS_RES_IOPORT
case|:
return|return
operator|(
name|NULL
operator|)
return|;
case|case
name|SYS_RES_MEMORY
case|:
return|return
operator|(
name|pci_vf_alloc_mem_resource
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
comment|/* Fall through for other types of resource allocations. */
block|}
endif|#
directive|endif
return|return
operator|(
name|pci_alloc_multi_resource
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
literal|1
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_release_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|struct
name|resource_list
modifier|*
name|rl
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
decl_stmt|;
if|if
condition|(
name|device_get_parent
argument_list|(
name|child
argument_list|)
operator|!=
name|dev
condition|)
return|return
operator|(
name|BUS_RELEASE_RESOURCE
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
operator|)
return|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|cfg
operator|=
operator|&
name|dinfo
operator|->
name|cfg
expr_stmt|;
ifdef|#
directive|ifdef
name|PCI_IOV
if|if
condition|(
name|dinfo
operator|->
name|cfg
operator|.
name|flags
operator|&
name|PCICFG_VF
condition|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
comment|/* VFs can't have I/O BARs. */
case|case
name|SYS_RES_IOPORT
case|:
return|return
operator|(
name|EDOOFUS
operator|)
return|;
case|case
name|SYS_RES_MEMORY
case|:
return|return
operator|(
name|pci_vf_release_mem_resource
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
operator|)
return|;
block|}
comment|/* Fall through for other types of resource allocations. */
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NEW_PCIB
comment|/* 	 * PCI-PCI bridge I/O window resources are not BARs.  For 	 * those allocations just pass the request up the tree. 	 */
if|if
condition|(
name|cfg
operator|->
name|hdrtype
operator|==
name|PCIM_HDRTYPE_BRIDGE
operator|&&
operator|(
name|type
operator|==
name|SYS_RES_IOPORT
operator|||
name|type
operator|==
name|SYS_RES_MEMORY
operator|)
condition|)
block|{
switch|switch
condition|(
name|rid
condition|)
block|{
case|case
name|PCIR_IOBASEL_1
case|:
case|case
name|PCIR_MEMBASE_1
case|:
case|case
name|PCIR_PMBASEL_1
case|:
return|return
operator|(
name|bus_generic_release_resource
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
operator|)
return|;
block|}
block|}
endif|#
directive|endif
name|rl
operator|=
operator|&
name|dinfo
operator|->
name|resources
expr_stmt|;
return|return
operator|(
name|resource_list_release
argument_list|(
name|rl
argument_list|,
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_activate_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|bus_generic_activate_resource
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Enable decoding in the command register when activating BARs. */
if|if
condition|(
name|device_get_parent
argument_list|(
name|child
argument_list|)
operator|==
name|dev
condition|)
block|{
comment|/* Device ROMs need their decoding explicitly enabled. */
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|SYS_RES_MEMORY
operator|&&
name|PCIR_IS_BIOS
argument_list|(
operator|&
name|dinfo
operator|->
name|cfg
argument_list|,
name|rid
argument_list|)
condition|)
name|pci_write_bar
argument_list|(
name|child
argument_list|,
name|pci_find_bar
argument_list|(
name|child
argument_list|,
name|rid
argument_list|)
argument_list|,
name|rman_get_start
argument_list|(
name|r
argument_list|)
operator||
name|PCIM_BIOS_ENABLE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SYS_RES_IOPORT
case|:
case|case
name|SYS_RES_MEMORY
case|:
name|error
operator|=
name|PCI_ENABLE_IO
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_deactivate_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|bus_generic_deactivate_resource
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Disable decoding for device ROMs. */
if|if
condition|(
name|device_get_parent
argument_list|(
name|child
argument_list|)
operator|==
name|dev
condition|)
block|{
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|SYS_RES_MEMORY
operator|&&
name|PCIR_IS_BIOS
argument_list|(
operator|&
name|dinfo
operator|->
name|cfg
argument_list|,
name|rid
argument_list|)
condition|)
name|pci_write_bar
argument_list|(
name|child
argument_list|,
name|pci_find_bar
argument_list|(
name|child
argument_list|,
name|rid
argument_list|)
argument_list|,
name|rman_get_start
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pci_child_deleted
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
name|struct
name|resource_list
modifier|*
name|rl
decl_stmt|;
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|rl
operator|=
operator|&
name|dinfo
operator|->
name|resources
expr_stmt|;
name|EVENTHANDLER_INVOKE
argument_list|(
name|pci_delete_device
argument_list|,
name|child
argument_list|)
expr_stmt|;
comment|/* Turn off access to resources we're about to free */
if|if
condition|(
name|bus_child_present
argument_list|(
name|child
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|pci_write_config
argument_list|(
name|child
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|pci_read_config
argument_list|(
name|child
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
operator|&
operator|~
operator|(
name|PCIM_CMD_MEMEN
operator||
name|PCIM_CMD_PORTEN
operator|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pci_disable_busmaster
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
comment|/* Free all allocated resources */
name|STAILQ_FOREACH
argument_list|(
argument|rle
argument_list|,
argument|rl
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|rle
operator|->
name|res
condition|)
block|{
if|if
condition|(
name|rman_get_flags
argument_list|(
name|rle
operator|->
name|res
argument_list|)
operator|&
name|RF_ACTIVE
operator|||
name|resource_list_busy
argument_list|(
name|rl
argument_list|,
name|rle
operator|->
name|type
argument_list|,
name|rle
operator|->
name|rid
argument_list|)
condition|)
block|{
name|pci_printf
argument_list|(
operator|&
name|dinfo
operator|->
name|cfg
argument_list|,
literal|"Resource still owned, oops. "
literal|"(type=%d, rid=%d, addr=%lx)\n"
argument_list|,
name|rle
operator|->
name|type
argument_list|,
name|rle
operator|->
name|rid
argument_list|,
name|rman_get_start
argument_list|(
name|rle
operator|->
name|res
argument_list|)
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|child
argument_list|,
name|rle
operator|->
name|type
argument_list|,
name|rle
operator|->
name|rid
argument_list|,
name|rle
operator|->
name|res
argument_list|)
expr_stmt|;
block|}
name|resource_list_unreserve
argument_list|(
name|rl
argument_list|,
name|dev
argument_list|,
name|child
argument_list|,
name|rle
operator|->
name|type
argument_list|,
name|rle
operator|->
name|rid
argument_list|)
expr_stmt|;
block|}
block|}
name|resource_list_free
argument_list|(
name|rl
argument_list|)
expr_stmt|;
name|pci_freecfg
argument_list|(
name|dinfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pci_delete_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|struct
name|resource_list
modifier|*
name|rl
decl_stmt|;
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
if|if
condition|(
name|device_get_parent
argument_list|(
name|child
argument_list|)
operator|!=
name|dev
condition|)
return|return;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|rl
operator|=
operator|&
name|dinfo
operator|->
name|resources
expr_stmt|;
name|rle
operator|=
name|resource_list_find
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
name|rid
argument_list|)
expr_stmt|;
if|if
condition|(
name|rle
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|rle
operator|->
name|res
condition|)
block|{
if|if
condition|(
name|rman_get_flags
argument_list|(
name|rle
operator|->
name|res
argument_list|)
operator|&
name|RF_ACTIVE
operator|||
name|resource_list_busy
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
name|rid
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"delete_resource: "
literal|"Resource still owned by child, oops. "
literal|"(type=%d, rid=%d, addr=%jx)\n"
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|rman_get_start
argument_list|(
name|rle
operator|->
name|res
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|resource_list_unreserve
argument_list|(
name|rl
argument_list|,
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|)
expr_stmt|;
block|}
name|resource_list_delete
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
name|rid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|resource_list
modifier|*
name|pci_get_resource_list
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
return|return
operator|(
operator|&
name|dinfo
operator|->
name|resources
operator|)
return|;
block|}
end_function

begin_function
name|bus_dma_tag_t
name|pci_get_dma_tag
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|pci_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|bus
argument_list|)
decl_stmt|;
return|return
operator|(
name|sc
operator|->
name|sc_dma_tag
operator|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|pci_read_config_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|width
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
ifdef|#
directive|ifdef
name|PCI_IOV
comment|/* 	 * SR-IOV VFs don't implement the VID or DID registers, so we have to 	 * emulate them here. 	 */
if|if
condition|(
name|cfg
operator|->
name|flags
operator|&
name|PCICFG_VF
condition|)
block|{
if|if
condition|(
name|reg
operator|==
name|PCIR_VENDOR
condition|)
block|{
switch|switch
condition|(
name|width
condition|)
block|{
case|case
literal|4
case|:
return|return
operator|(
name|cfg
operator|->
name|device
operator|<<
literal|16
operator||
name|cfg
operator|->
name|vendor
operator|)
return|;
case|case
literal|2
case|:
return|return
operator|(
name|cfg
operator|->
name|vendor
operator|)
return|;
case|case
literal|1
case|:
return|return
operator|(
name|cfg
operator|->
name|vendor
operator|&
literal|0xff
operator|)
return|;
default|default:
return|return
operator|(
literal|0xffffffff
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|reg
operator|==
name|PCIR_DEVICE
condition|)
block|{
switch|switch
condition|(
name|width
condition|)
block|{
comment|/* Note that an unaligned 4-byte read is an error. */
case|case
literal|2
case|:
return|return
operator|(
name|cfg
operator|->
name|device
operator|)
return|;
case|case
literal|1
case|:
return|return
operator|(
name|cfg
operator|->
name|device
operator|&
literal|0xff
operator|)
return|;
default|default:
return|return
operator|(
literal|0xffffffff
operator|)
return|;
block|}
block|}
block|}
endif|#
directive|endif
return|return
operator|(
name|PCIB_READ_CONFIG
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|cfg
operator|->
name|bus
argument_list|,
name|cfg
operator|->
name|slot
argument_list|,
name|cfg
operator|->
name|func
argument_list|,
name|reg
argument_list|,
name|width
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pci_write_config_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|reg
parameter_list|,
name|uint32_t
name|val
parameter_list|,
name|int
name|width
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
name|PCIB_WRITE_CONFIG
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|cfg
operator|->
name|bus
argument_list|,
name|cfg
operator|->
name|slot
argument_list|,
name|cfg
operator|->
name|func
argument_list|,
name|reg
argument_list|,
name|val
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pci_child_location_str_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
literal|"slot=%d function=%d dbsf=pci%d:%d:%d:%d"
argument_list|,
name|pci_get_slot
argument_list|(
name|child
argument_list|)
argument_list|,
name|pci_get_function
argument_list|(
name|child
argument_list|)
argument_list|,
name|pci_get_domain
argument_list|(
name|child
argument_list|)
argument_list|,
name|pci_get_bus
argument_list|(
name|child
argument_list|)
argument_list|,
name|pci_get_slot
argument_list|(
name|child
argument_list|)
argument_list|,
name|pci_get_function
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_child_pnpinfo_str_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
decl_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|cfg
operator|=
operator|&
name|dinfo
operator|->
name|cfg
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
literal|"vendor=0x%04x device=0x%04x subvendor=0x%04x "
literal|"subdevice=0x%04x class=0x%02x%02x%02x"
argument_list|,
name|cfg
operator|->
name|vendor
argument_list|,
name|cfg
operator|->
name|device
argument_list|,
name|cfg
operator|->
name|subvendor
argument_list|,
name|cfg
operator|->
name|subdevice
argument_list|,
name|cfg
operator|->
name|baseclass
argument_list|,
name|cfg
operator|->
name|subclass
argument_list|,
name|cfg
operator|->
name|progif
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_assign_interrupt_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
return|return
operator|(
name|PCIB_ROUTE_INTERRUPT
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|cfg
operator|->
name|intpin
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pci_lookup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|device_t
modifier|*
name|dev
parameter_list|)
block|{
name|long
name|val
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|int
name|domain
decl_stmt|,
name|bus
decl_stmt|,
name|slot
decl_stmt|,
name|func
decl_stmt|;
if|if
condition|(
operator|*
name|dev
operator|!=
name|NULL
condition|)
return|return;
comment|/* 	 * Accept pciconf-style selectors of either pciD:B:S:F or 	 * pciB:S:F.  In the latter case, the domain is assumed to 	 * be zero. 	 */
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"pci"
argument_list|,
literal|3
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|val
operator|=
name|strtol
argument_list|(
name|name
operator|+
literal|3
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
operator|||
name|val
operator|>
name|INT_MAX
operator|||
operator|*
name|end
operator|!=
literal|':'
condition|)
return|return;
name|domain
operator|=
name|val
expr_stmt|;
name|val
operator|=
name|strtol
argument_list|(
name|end
operator|+
literal|1
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
operator|||
name|val
operator|>
name|INT_MAX
operator|||
operator|*
name|end
operator|!=
literal|':'
condition|)
return|return;
name|bus
operator|=
name|val
expr_stmt|;
name|val
operator|=
name|strtol
argument_list|(
name|end
operator|+
literal|1
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
operator|||
name|val
operator|>
name|INT_MAX
condition|)
return|return;
name|slot
operator|=
name|val
expr_stmt|;
if|if
condition|(
operator|*
name|end
operator|==
literal|':'
condition|)
block|{
name|val
operator|=
name|strtol
argument_list|(
name|end
operator|+
literal|1
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
operator|||
name|val
operator|>
name|INT_MAX
operator|||
operator|*
name|end
operator|!=
literal|'\0'
condition|)
return|return;
name|func
operator|=
name|val
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|end
operator|==
literal|'\0'
condition|)
block|{
name|func
operator|=
name|slot
expr_stmt|;
name|slot
operator|=
name|bus
expr_stmt|;
name|bus
operator|=
name|domain
expr_stmt|;
name|domain
operator|=
literal|0
expr_stmt|;
block|}
else|else
return|return;
if|if
condition|(
name|domain
operator|>
name|PCI_DOMAINMAX
operator|||
name|bus
operator|>
name|PCI_BUSMAX
operator|||
name|slot
operator|>
name|PCI_SLOTMAX
operator|||
name|func
operator|>
name|PCIE_ARI_FUNCMAX
operator|||
operator|(
name|slot
operator|!=
literal|0
operator|&&
name|func
operator|>
name|PCI_FUNCMAX
operator|)
condition|)
return|return;
operator|*
name|dev
operator|=
name|pci_find_dbsf
argument_list|(
name|domain
argument_list|,
name|bus
argument_list|,
name|slot
argument_list|,
name|func
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pci_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|what
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
specifier|static
name|struct
name|cdev
modifier|*
name|pci_cdev
decl_stmt|;
specifier|static
name|eventhandler_tag
name|tag
decl_stmt|;
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|STAILQ_INIT
argument_list|(
operator|&
name|pci_devq
argument_list|)
expr_stmt|;
name|pci_generation
operator|=
literal|0
expr_stmt|;
name|pci_cdev
operator|=
name|make_dev
argument_list|(
operator|&
name|pcicdev
argument_list|,
literal|0
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0644
argument_list|,
literal|"pci"
argument_list|)
expr_stmt|;
name|pci_load_vendor_data
argument_list|()
expr_stmt|;
name|tag
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|dev_lookup
argument_list|,
name|pci_lookup
argument_list|,
name|NULL
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
if|if
condition|(
name|tag
operator|!=
name|NULL
condition|)
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|dev_lookup
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|destroy_dev
argument_list|(
name|pci_cdev
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pci_cfg_restore_pcie
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|pci_devinfo
modifier|*
name|dinfo
parameter_list|)
block|{
define|#
directive|define
name|WREG
parameter_list|(
name|n
parameter_list|,
name|v
parameter_list|)
value|pci_write_config(dev, pos + (n), (v), 2)
name|struct
name|pcicfg_pcie
modifier|*
name|cfg
decl_stmt|;
name|int
name|version
decl_stmt|,
name|pos
decl_stmt|;
name|cfg
operator|=
operator|&
name|dinfo
operator|->
name|cfg
operator|.
name|pcie
expr_stmt|;
name|pos
operator|=
name|cfg
operator|->
name|pcie_location
expr_stmt|;
name|version
operator|=
name|cfg
operator|->
name|pcie_flags
operator|&
name|PCIEM_FLAGS_VERSION
expr_stmt|;
name|WREG
argument_list|(
name|PCIER_DEVICE_CTL
argument_list|,
name|cfg
operator|->
name|pcie_device_ctl
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|>
literal|1
operator|||
name|cfg
operator|->
name|pcie_type
operator|==
name|PCIEM_TYPE_ROOT_PORT
operator|||
name|cfg
operator|->
name|pcie_type
operator|==
name|PCIEM_TYPE_ENDPOINT
operator|||
name|cfg
operator|->
name|pcie_type
operator|==
name|PCIEM_TYPE_LEGACY_ENDPOINT
condition|)
name|WREG
argument_list|(
name|PCIER_LINK_CTL
argument_list|,
name|cfg
operator|->
name|pcie_link_ctl
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|>
literal|1
operator|||
operator|(
name|cfg
operator|->
name|pcie_type
operator|==
name|PCIEM_TYPE_ROOT_PORT
operator|||
operator|(
name|cfg
operator|->
name|pcie_type
operator|==
name|PCIEM_TYPE_DOWNSTREAM_PORT
operator|&&
operator|(
name|cfg
operator|->
name|pcie_flags
operator|&
name|PCIEM_FLAGS_SLOT
operator|)
operator|)
operator|)
condition|)
name|WREG
argument_list|(
name|PCIER_SLOT_CTL
argument_list|,
name|cfg
operator|->
name|pcie_slot_ctl
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|>
literal|1
operator|||
name|cfg
operator|->
name|pcie_type
operator|==
name|PCIEM_TYPE_ROOT_PORT
operator|||
name|cfg
operator|->
name|pcie_type
operator|==
name|PCIEM_TYPE_ROOT_EC
condition|)
name|WREG
argument_list|(
name|PCIER_ROOT_CTL
argument_list|,
name|cfg
operator|->
name|pcie_root_ctl
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|>
literal|1
condition|)
block|{
name|WREG
argument_list|(
name|PCIER_DEVICE_CTL2
argument_list|,
name|cfg
operator|->
name|pcie_device_ctl2
argument_list|)
expr_stmt|;
name|WREG
argument_list|(
name|PCIER_LINK_CTL2
argument_list|,
name|cfg
operator|->
name|pcie_link_ctl2
argument_list|)
expr_stmt|;
name|WREG
argument_list|(
name|PCIER_SLOT_CTL2
argument_list|,
name|cfg
operator|->
name|pcie_slot_ctl2
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|WREG
block|}
end_function

begin_function
specifier|static
name|void
name|pci_cfg_restore_pcix
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|pci_devinfo
modifier|*
name|dinfo
parameter_list|)
block|{
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|pcix
operator|.
name|pcix_location
operator|+
name|PCIXR_COMMAND
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|pcix
operator|.
name|pcix_command
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pci_cfg_restore
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|pci_devinfo
modifier|*
name|dinfo
parameter_list|)
block|{
comment|/* 	 * Restore the device to full power mode.  We must do this 	 * before we restore the registers because moving from D3 to 	 * D0 will cause the chip's BARs and some other registers to 	 * be reset to some unknown power on reset values.  Cut down 	 * the noise on boot by doing nothing if we are already in 	 * state D0. 	 */
if|if
condition|(
name|pci_get_powerstate
argument_list|(
name|dev
argument_list|)
operator|!=
name|PCI_POWERSTATE_D0
condition|)
name|pci_set_powerstate
argument_list|(
name|dev
argument_list|,
name|PCI_POWERSTATE_D0
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|cmdreg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_INTLINE
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|intline
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_INTPIN
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|intpin
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_CACHELNSZ
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|cachelnsz
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_LATTIMER
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|lattimer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PROGIF
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|progif
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_REVID
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|revid
argument_list|,
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dinfo
operator|->
name|cfg
operator|.
name|hdrtype
operator|&
name|PCIM_HDRTYPE
condition|)
block|{
case|case
name|PCIM_HDRTYPE_NORMAL
case|:
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_MINGNT
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|mingnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_MAXLAT
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|maxlat
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCIM_HDRTYPE_BRIDGE
case|:
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SECLAT_1
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|bridge
operator|.
name|br_seclat
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SUBBUS_1
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|bridge
operator|.
name|br_subbus
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SECBUS_1
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|bridge
operator|.
name|br_secbus
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PRIBUS_1
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|bridge
operator|.
name|br_pribus
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_BRIDGECTL_1
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|bridge
operator|.
name|br_control
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCIM_HDRTYPE_CARDBUS
case|:
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SECLAT_2
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|bridge
operator|.
name|br_seclat
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SUBBUS_2
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|bridge
operator|.
name|br_subbus
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SECBUS_2
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|bridge
operator|.
name|br_secbus
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PRIBUS_2
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|bridge
operator|.
name|br_pribus
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_BRIDGECTL_2
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|bridge
operator|.
name|br_control
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
block|}
name|pci_restore_bars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * Restore extended capabilities for PCI-Express and PCI-X 	 */
if|if
condition|(
name|dinfo
operator|->
name|cfg
operator|.
name|pcie
operator|.
name|pcie_location
operator|!=
literal|0
condition|)
name|pci_cfg_restore_pcie
argument_list|(
name|dev
argument_list|,
name|dinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|dinfo
operator|->
name|cfg
operator|.
name|pcix
operator|.
name|pcix_location
operator|!=
literal|0
condition|)
name|pci_cfg_restore_pcix
argument_list|(
name|dev
argument_list|,
name|dinfo
argument_list|)
expr_stmt|;
comment|/* Restore MSI and MSI-X configurations if they are present. */
if|if
condition|(
name|dinfo
operator|->
name|cfg
operator|.
name|msi
operator|.
name|msi_location
operator|!=
literal|0
condition|)
name|pci_resume_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dinfo
operator|->
name|cfg
operator|.
name|msix
operator|.
name|msix_location
operator|!=
literal|0
condition|)
name|pci_resume_msix
argument_list|(
name|dev
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PCI_IOV
if|if
condition|(
name|dinfo
operator|->
name|cfg
operator|.
name|iov
operator|!=
name|NULL
condition|)
name|pci_iov_cfg_restore
argument_list|(
name|dev
argument_list|,
name|dinfo
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|pci_cfg_save_pcie
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|pci_devinfo
modifier|*
name|dinfo
parameter_list|)
block|{
define|#
directive|define
name|RREG
parameter_list|(
name|n
parameter_list|)
value|pci_read_config(dev, pos + (n), 2)
name|struct
name|pcicfg_pcie
modifier|*
name|cfg
decl_stmt|;
name|int
name|version
decl_stmt|,
name|pos
decl_stmt|;
name|cfg
operator|=
operator|&
name|dinfo
operator|->
name|cfg
operator|.
name|pcie
expr_stmt|;
name|pos
operator|=
name|cfg
operator|->
name|pcie_location
expr_stmt|;
name|cfg
operator|->
name|pcie_flags
operator|=
name|RREG
argument_list|(
name|PCIER_FLAGS
argument_list|)
expr_stmt|;
name|version
operator|=
name|cfg
operator|->
name|pcie_flags
operator|&
name|PCIEM_FLAGS_VERSION
expr_stmt|;
name|cfg
operator|->
name|pcie_device_ctl
operator|=
name|RREG
argument_list|(
name|PCIER_DEVICE_CTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|>
literal|1
operator|||
name|cfg
operator|->
name|pcie_type
operator|==
name|PCIEM_TYPE_ROOT_PORT
operator|||
name|cfg
operator|->
name|pcie_type
operator|==
name|PCIEM_TYPE_ENDPOINT
operator|||
name|cfg
operator|->
name|pcie_type
operator|==
name|PCIEM_TYPE_LEGACY_ENDPOINT
condition|)
name|cfg
operator|->
name|pcie_link_ctl
operator|=
name|RREG
argument_list|(
name|PCIER_LINK_CTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|>
literal|1
operator|||
operator|(
name|cfg
operator|->
name|pcie_type
operator|==
name|PCIEM_TYPE_ROOT_PORT
operator|||
operator|(
name|cfg
operator|->
name|pcie_type
operator|==
name|PCIEM_TYPE_DOWNSTREAM_PORT
operator|&&
operator|(
name|cfg
operator|->
name|pcie_flags
operator|&
name|PCIEM_FLAGS_SLOT
operator|)
operator|)
operator|)
condition|)
name|cfg
operator|->
name|pcie_slot_ctl
operator|=
name|RREG
argument_list|(
name|PCIER_SLOT_CTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|>
literal|1
operator|||
name|cfg
operator|->
name|pcie_type
operator|==
name|PCIEM_TYPE_ROOT_PORT
operator|||
name|cfg
operator|->
name|pcie_type
operator|==
name|PCIEM_TYPE_ROOT_EC
condition|)
name|cfg
operator|->
name|pcie_root_ctl
operator|=
name|RREG
argument_list|(
name|PCIER_ROOT_CTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|>
literal|1
condition|)
block|{
name|cfg
operator|->
name|pcie_device_ctl2
operator|=
name|RREG
argument_list|(
name|PCIER_DEVICE_CTL2
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|pcie_link_ctl2
operator|=
name|RREG
argument_list|(
name|PCIER_LINK_CTL2
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|pcie_slot_ctl2
operator|=
name|RREG
argument_list|(
name|PCIER_SLOT_CTL2
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|RREG
block|}
end_function

begin_function
specifier|static
name|void
name|pci_cfg_save_pcix
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|pci_devinfo
modifier|*
name|dinfo
parameter_list|)
block|{
name|dinfo
operator|->
name|cfg
operator|.
name|pcix
operator|.
name|pcix_command
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|pcix
operator|.
name|pcix_location
operator|+
name|PCIXR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pci_cfg_save
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|pci_devinfo
modifier|*
name|dinfo
parameter_list|,
name|int
name|setstate
parameter_list|)
block|{
name|uint32_t
name|cls
decl_stmt|;
name|int
name|ps
decl_stmt|;
comment|/* 	 * Some drivers apparently write to these registers w/o updating our 	 * cached copy.  No harm happens if we update the copy, so do so here 	 * so we can restore them.  The COMMAND register is modified by the 	 * bus w/o updating the cache.  This should represent the normally 	 * writable portion of the 'defined' part of type 0/1/2 headers. 	 */
name|dinfo
operator|->
name|cfg
operator|.
name|vendor
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_VENDOR
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|device
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_DEVICE
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|cmdreg
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|intline
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_INTLINE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|intpin
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_INTPIN
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|cachelnsz
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_CACHELNSZ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|lattimer
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_LATTIMER
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|baseclass
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_CLASS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|subclass
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SUBCLASS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|progif
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PROGIF
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|revid
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_REVID
argument_list|,
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dinfo
operator|->
name|cfg
operator|.
name|hdrtype
operator|&
name|PCIM_HDRTYPE
condition|)
block|{
case|case
name|PCIM_HDRTYPE_NORMAL
case|:
name|dinfo
operator|->
name|cfg
operator|.
name|subvendor
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SUBVEND_0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|subdevice
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SUBDEV_0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|mingnt
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_MINGNT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|maxlat
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_MAXLAT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCIM_HDRTYPE_BRIDGE
case|:
name|dinfo
operator|->
name|cfg
operator|.
name|bridge
operator|.
name|br_seclat
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SECLAT_1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|bridge
operator|.
name|br_subbus
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SUBBUS_1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|bridge
operator|.
name|br_secbus
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SECBUS_1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|bridge
operator|.
name|br_pribus
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PRIBUS_1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|bridge
operator|.
name|br_control
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_BRIDGECTL_1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCIM_HDRTYPE_CARDBUS
case|:
name|dinfo
operator|->
name|cfg
operator|.
name|bridge
operator|.
name|br_seclat
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SECLAT_2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|bridge
operator|.
name|br_subbus
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SUBBUS_2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|bridge
operator|.
name|br_secbus
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SECBUS_2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|bridge
operator|.
name|br_pribus
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PRIBUS_2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|bridge
operator|.
name|br_control
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_BRIDGECTL_2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|subvendor
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SUBVEND_2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|subdevice
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SUBDEV_2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dinfo
operator|->
name|cfg
operator|.
name|pcie
operator|.
name|pcie_location
operator|!=
literal|0
condition|)
name|pci_cfg_save_pcie
argument_list|(
name|dev
argument_list|,
name|dinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|dinfo
operator|->
name|cfg
operator|.
name|pcix
operator|.
name|pcix_location
operator|!=
literal|0
condition|)
name|pci_cfg_save_pcix
argument_list|(
name|dev
argument_list|,
name|dinfo
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PCI_IOV
if|if
condition|(
name|dinfo
operator|->
name|cfg
operator|.
name|iov
operator|!=
name|NULL
condition|)
name|pci_iov_cfg_save
argument_list|(
name|dev
argument_list|,
name|dinfo
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * don't set the state for display devices, base peripherals and 	 * memory devices since bad things happen when they are powered down. 	 * We should (a) have drivers that can easily detach and (b) use 	 * generic drivers for these devices so that some device actually 	 * attaches.  We need to make sure that when we implement (a) we don't 	 * power the device down on a reattach. 	 */
name|cls
operator|=
name|pci_get_class
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|setstate
condition|)
return|return;
switch|switch
condition|(
name|pci_do_power_nodriver
condition|)
block|{
case|case
literal|0
case|:
comment|/* NO powerdown at all */
return|return;
case|case
literal|1
case|:
comment|/* Conservative about what to power down */
if|if
condition|(
name|cls
operator|==
name|PCIC_STORAGE
condition|)
return|return;
comment|/*FALLTHROUGH*/
case|case
literal|2
case|:
comment|/* Aggressive about what to power down */
if|if
condition|(
name|cls
operator|==
name|PCIC_DISPLAY
operator|||
name|cls
operator|==
name|PCIC_MEMORY
operator|||
name|cls
operator|==
name|PCIC_BASEPERIPH
condition|)
return|return;
comment|/*FALLTHROUGH*/
case|case
literal|3
case|:
comment|/* Power down everything */
break|break;
block|}
comment|/* 	 * PCI spec says we can only go into D3 state from D0 state. 	 * Transition from D[12] into D0 before going to D3 state. 	 */
name|ps
operator|=
name|pci_get_powerstate
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|!=
name|PCI_POWERSTATE_D0
operator|&&
name|ps
operator|!=
name|PCI_POWERSTATE_D3
condition|)
name|pci_set_powerstate
argument_list|(
name|dev
argument_list|,
name|PCI_POWERSTATE_D0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_get_powerstate
argument_list|(
name|dev
argument_list|)
operator|!=
name|PCI_POWERSTATE_D3
condition|)
name|pci_set_powerstate
argument_list|(
name|dev
argument_list|,
name|PCI_POWERSTATE_D3
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Wrapper APIs suitable for device driver use. */
end_comment

begin_function
name|void
name|pci_save_state
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_cfg_save
argument_list|(
name|dev
argument_list|,
name|dinfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pci_restore_state
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_cfg_restore
argument_list|(
name|dev
argument_list|,
name|dinfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pci_get_id_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|enum
name|pci_id_type
name|type
parameter_list|,
name|uintptr_t
modifier|*
name|id
parameter_list|)
block|{
return|return
operator|(
name|PCIB_GET_ID
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|id
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Find the upstream port of a given PCI device in a root complex. */
end_comment

begin_function
name|device_t
name|pci_find_pcie_root_port
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|devclass_t
name|pci_class
decl_stmt|;
name|device_t
name|pcib
decl_stmt|,
name|bus
decl_stmt|;
name|pci_class
operator|=
name|devclass_find
argument_list|(
literal|"pci"
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|device_get_devclass
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
operator|==
name|pci_class
argument_list|,
operator|(
literal|"%s: non-pci device %s"
operator|,
name|__func__
operator|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Walk the bridge hierarchy until we find a PCI-e root 	 * port or a non-PCI device. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|bus
operator|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|bus
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: null parent of %s"
operator|,
name|__func__
operator|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|pcib
operator|=
name|device_get_parent
argument_list|(
name|bus
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pcib
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: null bridge of %s"
operator|,
name|__func__
operator|,
name|device_get_nameunit
argument_list|(
name|bus
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * pcib's parent must be a PCI bus for this to be a 		 * PCI-PCI bridge. 		 */
if|if
condition|(
name|device_get_devclass
argument_list|(
name|device_get_parent
argument_list|(
name|pcib
argument_list|)
argument_list|)
operator|!=
name|pci_class
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|pcib
argument_list|)
expr_stmt|;
if|if
condition|(
name|dinfo
operator|->
name|cfg
operator|.
name|pcie
operator|.
name|pcie_location
operator|!=
literal|0
operator|&&
name|dinfo
operator|->
name|cfg
operator|.
name|pcie
operator|.
name|pcie_type
operator|==
name|PCIEM_TYPE_ROOT_PORT
condition|)
return|return
operator|(
name|pcib
operator|)
return|;
name|dev
operator|=
name|pcib
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Wait for pending transactions to complete on a PCI-express function.  *  * The maximum delay is specified in milliseconds in max_delay.  Note  * that this function may sleep.  *  * Returns true if the function is idle and false if the timeout is  * exceeded.  If dev is not a PCI-express function, this returns true.  */
end_comment

begin_function
name|bool
name|pcie_wait_for_pending_transactions
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|max_delay
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint16_t
name|sta
decl_stmt|;
name|int
name|cap
decl_stmt|;
name|cap
operator|=
name|dinfo
operator|->
name|cfg
operator|.
name|pcie
operator|.
name|pcie_location
expr_stmt|;
if|if
condition|(
name|cap
operator|==
literal|0
condition|)
return|return
operator|(
name|true
operator|)
return|;
name|sta
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|cap
operator|+
name|PCIER_DEVICE_STA
argument_list|,
literal|2
argument_list|)
expr_stmt|;
while|while
condition|(
name|sta
operator|&
name|PCIEM_STA_TRANSACTION_PND
condition|)
block|{
if|if
condition|(
name|max_delay
operator|==
literal|0
condition|)
return|return
operator|(
name|false
operator|)
return|;
comment|/* Poll once every 100 milliseconds up to the timeout. */
if|if
condition|(
name|max_delay
operator|>
literal|100
condition|)
block|{
name|pause_sbt
argument_list|(
literal|"pcietp"
argument_list|,
literal|100
operator|*
name|SBT_1MS
argument_list|,
literal|0
argument_list|,
name|C_HARDCLOCK
argument_list|)
expr_stmt|;
name|max_delay
operator|-=
literal|100
expr_stmt|;
block|}
else|else
block|{
name|pause_sbt
argument_list|(
literal|"pcietp"
argument_list|,
name|max_delay
operator|*
name|SBT_1MS
argument_list|,
literal|0
argument_list|,
name|C_HARDCLOCK
argument_list|)
expr_stmt|;
name|max_delay
operator|=
literal|0
expr_stmt|;
block|}
name|sta
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|cap
operator|+
name|PCIER_DEVICE_STA
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine the maximum Completion Timeout in microseconds.  *  * For non-PCI-express functions this returns 0.  */
end_comment

begin_function
name|int
name|pcie_get_max_completion_timeout
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|cap
decl_stmt|;
name|cap
operator|=
name|dinfo
operator|->
name|cfg
operator|.
name|pcie
operator|.
name|pcie_location
expr_stmt|;
if|if
condition|(
name|cap
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Functions using the 1.x spec use the default timeout range of 	 * 50 microseconds to 50 milliseconds.  Functions that do not 	 * support programmable timeouts also use this range. 	 */
if|if
condition|(
operator|(
name|dinfo
operator|->
name|cfg
operator|.
name|pcie
operator|.
name|pcie_flags
operator|&
name|PCIEM_FLAGS_VERSION
operator|)
operator|<
literal|2
operator|||
operator|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|cap
operator|+
name|PCIER_DEVICE_CAP2
argument_list|,
literal|4
argument_list|)
operator|&
name|PCIEM_CAP2_COMP_TIMO_RANGES
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|50
operator|*
literal|1000
operator|)
return|;
switch|switch
condition|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|cap
operator|+
name|PCIER_DEVICE_CTL2
argument_list|,
literal|2
argument_list|)
operator|&
name|PCIEM_CTL2_COMP_TIMO_VAL
condition|)
block|{
case|case
name|PCIEM_CTL2_COMP_TIMO_100US
case|:
return|return
operator|(
literal|100
operator|)
return|;
case|case
name|PCIEM_CTL2_COMP_TIMO_10MS
case|:
return|return
operator|(
literal|10
operator|*
literal|1000
operator|)
return|;
case|case
name|PCIEM_CTL2_COMP_TIMO_55MS
case|:
return|return
operator|(
literal|55
operator|*
literal|1000
operator|)
return|;
case|case
name|PCIEM_CTL2_COMP_TIMO_210MS
case|:
return|return
operator|(
literal|210
operator|*
literal|1000
operator|)
return|;
case|case
name|PCIEM_CTL2_COMP_TIMO_900MS
case|:
return|return
operator|(
literal|900
operator|*
literal|1000
operator|)
return|;
case|case
name|PCIEM_CTL2_COMP_TIMO_3500MS
case|:
return|return
operator|(
literal|3500
operator|*
literal|1000
operator|)
return|;
case|case
name|PCIEM_CTL2_COMP_TIMO_13S
case|:
return|return
operator|(
literal|13
operator|*
literal|1000
operator|*
literal|1000
operator|)
return|;
case|case
name|PCIEM_CTL2_COMP_TIMO_64S
case|:
return|return
operator|(
literal|64
operator|*
literal|1000
operator|*
literal|1000
operator|)
return|;
default|default:
return|return
operator|(
literal|50
operator|*
literal|1000
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Perform a Function Level Reset (FLR) on a device.  *  * This function first waits for any pending transactions to complete  * within the timeout specified by max_delay.  If transactions are  * still pending, the function will return false without attempting a  * reset.  *  * If dev is not a PCI-express function or does not support FLR, this  * function returns false.  *  * Note that no registers are saved or restored.  The caller is  * responsible for saving and restoring any registers including  * PCI-standard registers via pci_save_state() and  * pci_restore_state().  */
end_comment

begin_function
name|bool
name|pcie_flr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|max_delay
parameter_list|,
name|bool
name|force
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint16_t
name|cmd
decl_stmt|,
name|ctl
decl_stmt|;
name|int
name|compl_delay
decl_stmt|;
name|int
name|cap
decl_stmt|;
name|cap
operator|=
name|dinfo
operator|->
name|cfg
operator|.
name|pcie
operator|.
name|pcie_location
expr_stmt|;
if|if
condition|(
name|cap
operator|==
literal|0
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|cap
operator|+
name|PCIER_DEVICE_CAP
argument_list|,
literal|4
argument_list|)
operator|&
name|PCIEM_CAP_FLR
operator|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
comment|/* 	 * Disable busmastering to prevent generation of new 	 * transactions while waiting for the device to go idle.  If 	 * the idle timeout fails, the command register is restored 	 * which will re-enable busmastering. 	 */
name|cmd
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|cmd
operator|&
operator|~
operator|(
name|PCIM_CMD_BUSMASTEREN
operator|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pcie_wait_for_pending_transactions
argument_list|(
name|dev
argument_list|,
name|max_delay
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|force
condition|)
block|{
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|cmd
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
name|pci_printf
argument_list|(
operator|&
name|dinfo
operator|->
name|cfg
argument_list|,
literal|"Resetting with transactions pending after %d ms\n"
argument_list|,
name|max_delay
argument_list|)
expr_stmt|;
comment|/* 		 * Extend the post-FLR delay to cover the maximum 		 * Completion Timeout delay of anything in flight 		 * during the FLR delay.  Enforce a minimum delay of 		 * at least 10ms. 		 */
name|compl_delay
operator|=
name|pcie_get_max_completion_timeout
argument_list|(
name|dev
argument_list|)
operator|/
literal|1000
expr_stmt|;
if|if
condition|(
name|compl_delay
operator|<
literal|10
condition|)
name|compl_delay
operator|=
literal|10
expr_stmt|;
block|}
else|else
name|compl_delay
operator|=
literal|0
expr_stmt|;
comment|/* Initiate the reset. */
name|ctl
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|cap
operator|+
name|PCIER_DEVICE_CTL
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|cap
operator|+
name|PCIER_DEVICE_CTL
argument_list|,
name|ctl
operator||
name|PCIEM_CTL_INITIATE_FLR
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Wait for 100ms. */
name|pause_sbt
argument_list|(
literal|"pcieflr"
argument_list|,
operator|(
literal|100
operator|+
name|compl_delay
operator|)
operator|*
name|SBT_1MS
argument_list|,
literal|0
argument_list|,
name|C_HARDCLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|cap
operator|+
name|PCIER_DEVICE_STA
argument_list|,
literal|2
argument_list|)
operator|&
name|PCIEM_STA_TRANSACTION_PND
condition|)
name|pci_printf
argument_list|(
operator|&
name|dinfo
operator|->
name|cfg
argument_list|,
literal|"Transactions pending after FLR!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

end_unit

