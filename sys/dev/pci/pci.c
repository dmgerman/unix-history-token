begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/************************************************************************** ** **  $Id: pci.c,v 1.8 1994/10/25 23:09:08 se Exp $ ** **  General subroutines for the PCI bus on 80*86 systems. **  pci_configure () ** **  386bsd / FreeBSD ** **------------------------------------------------------------------------- ** ** Copyright (c) 1994 Wolfgang Stanglmeier.  All rights reserved. ** ** Redistribution and use in source and binary forms, with or without ** modification, are permitted provided that the following conditions ** are met: ** 1. Redistributions of source code must retain the above copyright **    notice, this list of conditions and the following disclaimer. ** 2. Redistributions in binary form must reproduce the above copyright **    notice, this list of conditions and the following disclaimer in the **    documentation and/or other materials provided with the distribution. ** 3. The name of the author may not be used to endorse or promote products **    derived from this software without specific prior written permission. ** ** THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR ** IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ** OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ** IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, ** INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT ** NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, ** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ** THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ** *************************************************************************** */
end_comment

begin_include
include|#
directive|include
file|<pci.h>
end_include

begin_if
if|#
directive|if
name|NPCI
operator|>
literal|0
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|__FreeBSD2__
end_ifndef

begin_if
if|#
directive|if
name|__FreeBSD__
operator|>=
literal|2
end_if

begin_define
define|#
directive|define
name|__FreeBSD2__
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/*======================================================== ** **	#includes  and  declarations ** **======================================================== */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/icu.h>
end_include

begin_include
include|#
directive|include
file|<i386/pci/pcireg.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD2__
end_ifdef

begin_include
include|#
directive|include
file|<sys/devconf.h>
end_include

begin_struct
struct|struct
name|pci_devconf
block|{
name|struct
name|kern_devconf
name|pdc_kdc
decl_stmt|;
name|struct
name|pci_info
name|pdc_pi
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* **	Function prototypes missing in system headers */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__FreeBSD2__
end_ifndef

begin_function_decl
specifier|extern
name|pmap_t
name|pmap_kernel
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|vm_offset_t
name|pmap_mapdev
parameter_list|(
name|vm_offset_t
name|paddr
parameter_list|,
name|vm_size_t
name|vsize
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Type of the first (asm) part of an interrupt handler.  */
end_comment

begin_typedef
typedef|typedef
name|void
name|inthand_t
name|__P
typedef|((
name|u_int
name|cs
typedef|,
name|u_int
name|ef
typedef|,
name|u_int
name|esp
typedef|,
name|u_int
name|ss
typedef|));
end_typedef

begin_comment
comment|/*  * Usual type of the second (C) part of an interrupt handler.  Some bogus  * ones need the arg to be the interrupt frame (and not a copy of it, which  * is all that is possible in C).  */
end_comment

begin_typedef
typedef|typedef
name|void
name|inthand2_t
name|__P
typedef|((
name|int
name|unit
typedef|));
end_typedef

begin_comment
comment|/* **	XXX	@FreeBSD2@ ** **	Unfortunately, the mptr argument is _no_ pointer in 2.0 FreeBSD. **	We would prefer a pointer because it enables us to install **	new interrupt handlers at any time. **	(This is just going to be changed ...<se> :) **	In 2.0 FreeBSD later installed interrupt handlers may change **	the xyz_imask, but this would not be recognized by handlers **	which are installed before. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|register_intr
name|__P
argument_list|(
operator|(
name|int
name|intr
operator|,
name|int
name|device_id
operator|,
name|unsigned
name|int
name|flags
operator|,
name|inthand2_t
operator|*
name|handler
operator|,
name|unsigned
name|int
operator|*
name|mptr
operator|,
name|int
name|unit
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|intr_mask
index|[
name|ICU_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !__FreeBSD2__ */
end_comment

begin_escape
end_escape

begin_comment
comment|/*======================================================== ** **	Autoconfiguration of pci devices. ** **	This is reverse to the isa configuration. **	(1) find a pci device. **	(2) look for a driver. ** **======================================================== */
end_comment

begin_comment
comment|/*-------------------------------------------------------- ** **	The pci devices can be mapped to any address. **	As default we start at the last gigabyte. ** **-------------------------------------------------------- */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PCI_PMEM_START
end_ifndef

begin_define
define|#
directive|define
name|PCI_PMEM_START
value|0xc0000000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|vm_offset_t
name|pci_paddr
init|=
name|PCI_PMEM_START
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*-------------------------------------------------------- ** **	The pci device interrupt lines should have been **	assigned by the bios. But if the bios failed to **	to it, we set it. ** **-------------------------------------------------------- */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PCI_IRQ
end_ifndef

begin_define
define|#
directive|define
name|PCI_IRQ
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|u_long
name|pci_irq
init|=
name|PCI_IRQ
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*--------------------------------------------------------- ** **	pci_configure () ** **	Probe all devices on pci bus and attach them. ** **	May be called more than once. **	Any device is attached only once. **	(Attached devices are remembered in pci_seen.) ** **--------------------------------------------------------- */
end_comment

begin_function_decl
specifier|static
name|void
name|not_supported
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|u_long
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|pci_seen
index|[
name|NPCI
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pci_conf_count
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD2__
end_ifdef

begin_function_decl
specifier|static
name|int
name|pci_externalize
parameter_list|(
name|struct
name|proc
modifier|*
parameter_list|,
name|struct
name|kern_devconf
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_internalize
parameter_list|(
name|struct
name|proc
modifier|*
parameter_list|,
name|struct
name|kern_devconf
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD2__ */
end_comment

begin_function
name|void
name|pci_configure
parameter_list|()
block|{
name|u_char
name|device
decl_stmt|,
name|last_device
decl_stmt|;
name|u_short
name|bus
decl_stmt|;
name|pcici_t
name|tag
decl_stmt|;
name|pcidi_t
name|type
decl_stmt|;
name|u_long
name|data
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|int
name|pci_mechanism
decl_stmt|;
name|int
name|pciint
decl_stmt|;
name|int
name|irq
decl_stmt|;
name|char
modifier|*
name|name
init|=
literal|0
decl_stmt|;
name|vm_offset_t
name|old_addr
init|=
name|pci_paddr
decl_stmt|;
name|struct
name|pci_driver
modifier|*
name|drp
init|=
literal|0
decl_stmt|;
name|struct
name|pci_device
modifier|*
name|dvp
decl_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD2__
name|struct
name|pci_devconf
modifier|*
name|pdcp
decl_stmt|;
endif|#
directive|endif
comment|/* 	**	check pci bus present 	*/
name|pci_mechanism
operator|=
name|pci_conf_mode
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|pci_mechanism
condition|)
return|return;
name|last_device
operator|=
name|pci_mechanism
operator|==
literal|1
condition|?
literal|31
else|:
literal|15
expr_stmt|;
comment|/* 	**	hello world .. 	*/
for|for
control|(
name|bus
operator|=
literal|0
init|;
name|bus
operator|<
name|NPCI
condition|;
name|bus
operator|++
control|)
block|{
ifndef|#
directive|ifndef
name|PCI_QUIET
name|printf
argument_list|(
literal|"pci%d: scanning device 0..%d, mechanism=%d.\n"
argument_list|,
name|bus
argument_list|,
name|last_device
argument_list|,
name|pci_mechanism
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|device
operator|=
literal|0
init|;
name|device
operator|<=
name|last_device
condition|;
name|device
operator|++
control|)
block|{
if|if
condition|(
name|pci_seen
index|[
name|bus
index|]
operator|&
operator|(
literal|1ul
operator|<<
name|device
operator|)
condition|)
continue|continue;
name|tag
operator|=
name|pcitag
argument_list|(
name|bus
argument_list|,
name|device
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|type
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_ID_REG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|type
operator|)
operator|||
operator|(
name|type
operator|==
literal|0xfffffffful
operator|)
condition|)
continue|continue;
comment|/* 		**	lookup device in ioconfiguration: 		*/
for|for
control|(
name|dvp
operator|=
name|pci_devtab
init|;
name|dvp
operator|->
name|pd_name
condition|;
name|dvp
operator|++
control|)
block|{
name|drp
operator|=
name|dvp
operator|->
name|pd_driver
expr_stmt|;
if|if
condition|(
operator|!
name|drp
condition|)
continue|continue;
if|if
condition|(
operator|(
name|name
operator|=
call|(
modifier|*
name|drp
operator|->
name|probe
call|)
argument_list|(
name|tag
argument_list|,
name|type
argument_list|)
operator|)
condition|)
break|break;
block|}
empty_stmt|;
if|if
condition|(
operator|!
name|dvp
operator|->
name|pd_name
condition|)
block|{
ifndef|#
directive|ifndef
name|PCI_QUIET
if|if
condition|(
name|pci_conf_count
condition|)
continue|continue;
name|printf
argument_list|(
literal|"pci%d:%d: "
argument_list|,
name|bus
argument_list|,
name|device
argument_list|)
expr_stmt|;
name|not_supported
argument_list|(
name|tag
argument_list|,
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
empty_stmt|;
name|pci_seen
index|[
name|bus
index|]
operator||=
operator|(
literal|1ul
operator|<<
name|device
operator|)
expr_stmt|;
comment|/* 		**	Get and increment the unit. 		*/
name|unit
operator|=
operator|(
operator|*
name|drp
operator|->
name|count
operator|)
operator|++
expr_stmt|;
comment|/* 		**	ignore device ? 		*/
if|if
condition|(
operator|!
operator|*
name|name
condition|)
continue|continue;
comment|/* 		**	Announce this device 		*/
name|printf
argument_list|(
literal|"%s%d<%s>"
argument_list|,
name|dvp
operator|->
name|pd_name
argument_list|,
name|unit
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* 		**	Get the int pin number (pci interrupt number a-d) 		**	from the pci configuration space. 		*/
name|data
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_INTERRUPT_REG
argument_list|)
expr_stmt|;
name|pciint
operator|=
name|PCI_INTERRUPT_PIN_EXTRACT
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|pciint
condition|)
block|{
name|printf
argument_list|(
literal|" int %c"
argument_list|,
literal|0x60
operator|+
name|pciint
argument_list|)
expr_stmt|;
comment|/* 			**	If the interrupt line register is not set, 			**	set it now from PCI_IRQ. 			*/
if|if
condition|(
operator|!
operator|(
name|PCI_INTERRUPT_LINE_EXTRACT
argument_list|(
name|data
argument_list|)
operator|)
condition|)
block|{
name|irq
operator|=
name|pci_irq
operator|&
literal|0x0f
expr_stmt|;
name|pci_irq
operator|>>=
literal|4
expr_stmt|;
name|data
operator|=
name|PCI_INTERRUPT_LINE_INSERT
argument_list|(
name|data
argument_list|,
name|irq
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" (config)"
argument_list|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
name|PCI_INTERRUPT_REG
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|irq
operator|=
name|PCI_INTERRUPT_LINE_EXTRACT
argument_list|(
name|data
argument_list|)
expr_stmt|;
comment|/* 			**	If it's zero, the isa irq number is unknown, 			**	and we cannot bind the pci interrupt to isa. 			*/
if|if
condition|(
name|irq
condition|)
name|printf
argument_list|(
literal|" irq %d"
argument_list|,
name|irq
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" not bound"
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/* 		**	enable memory access 		*/
name|data
operator|=
operator|(
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_COMMAND_STATUS_REG
argument_list|)
operator|&
literal|0xffff
operator|)
operator||
name|PCI_COMMAND_MEM_ENABLE
expr_stmt|;
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
operator|(
name|u_char
operator|)
name|PCI_COMMAND_STATUS_REG
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* 		**	show pci slot. 		*/
name|printf
argument_list|(
literal|" on pci%d:%d\n"
argument_list|,
name|bus
argument_list|,
name|device
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD2__
comment|/* 		**	Allocate a devconf structure 		*/
name|pdcp
operator|=
operator|(
expr|struct
name|pci_devconf
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pci_devconf
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* 		**	Fill in. 		** 		**	Sorry, this is not yet complete. 		**	We should, and eventually will, set the 		**	parent pointer to a pci bus devconf structure, 		**	and arrange to set the state field dynamically. 		** 		**	But I'll go to vacation today, and after all, 		**	wasn't there a new feature freeze on Oct 1.? 		*/
name|pdcp
operator|->
name|pdc_pi
operator|.
name|pi_bus
operator|=
name|bus
expr_stmt|;
name|pdcp
operator|->
name|pdc_pi
operator|.
name|pi_device
operator|=
name|device
expr_stmt|;
name|pdcp
operator|->
name|pdc_kdc
operator|.
name|kdc_name
operator|=
name|dvp
operator|->
name|pd_name
expr_stmt|;
name|pdcp
operator|->
name|pdc_kdc
operator|.
name|kdc_unit
operator|=
name|unit
expr_stmt|;
name|pdcp
operator|->
name|pdc_kdc
operator|.
name|kdc_md
operator|.
name|mddc_devtype
operator|=
name|MDDT_PCI
expr_stmt|;
name|pdcp
operator|->
name|pdc_kdc
operator|.
name|kdc_externalize
operator|=
name|pci_externalize
expr_stmt|;
name|pdcp
operator|->
name|pdc_kdc
operator|.
name|kdc_internalize
operator|=
name|pci_internalize
expr_stmt|;
name|pdcp
operator|->
name|pdc_kdc
operator|.
name|kdc_datalen
operator|=
name|PCI_EXTERNAL_LEN
expr_stmt|;
name|pdcp
operator|->
name|pdc_kdc
operator|.
name|kdc_parentdata
operator|=
operator|&
name|pdcp
operator|->
name|pdc_pi
expr_stmt|;
name|pdcp
operator|->
name|pdc_kdc
operator|.
name|kdc_state
operator|=
name|DC_UNKNOWN
expr_stmt|;
name|pdcp
operator|->
name|pdc_kdc
operator|.
name|kdc_description
operator|=
name|name
expr_stmt|;
comment|/* 		**	And register this device 		*/
name|dev_attach
argument_list|(
operator|&
name|pdcp
operator|->
name|pdc_kdc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* __FreeBSD2__ */
comment|/* 		**	attach device 		**	may produce additional log messages, 		**	i.e. when installing subdevices. 		*/
call|(
modifier|*
name|drp
operator|->
name|attach
call|)
argument_list|(
name|tag
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
ifndef|#
directive|ifndef
name|PCI_QUIET
if|if
condition|(
name|pci_paddr
operator|!=
name|old_addr
condition|)
name|printf
argument_list|(
literal|"pci uses physical addresses from 0x%lx to 0x%lx\n"
argument_list|,
operator|(
name|u_long
operator|)
name|PCI_PMEM_START
argument_list|,
operator|(
name|u_long
operator|)
name|pci_paddr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pci_conf_count
operator|++
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*----------------------------------------------------------------------- ** **	Map device into port space. ** **	PCI-Specification:  6.2.5.1: address maps ** **----------------------------------------------------------------------- */
end_comment

begin_function
name|int
name|pci_map_port
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|u_long
name|reg
parameter_list|,
name|u_short
modifier|*
name|pa
parameter_list|)
block|{
comment|/* 	**	@MAPIO@ not yet implemented. 	*/
name|printf
argument_list|(
literal|"pci_map_port failed: not yet implemented\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*----------------------------------------------------------------------- ** **	Map device into virtual and physical space ** **	PCI-Specification:  6.2.5.1: address maps ** **----------------------------------------------------------------------- */
end_comment

begin_function
name|int
name|pci_map_mem
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|u_long
name|reg
parameter_list|,
name|vm_offset_t
modifier|*
name|va
parameter_list|,
name|vm_offset_t
modifier|*
name|pa
parameter_list|)
block|{
name|u_long
name|data
decl_stmt|;
name|vm_size_t
name|vsize
decl_stmt|;
name|vm_offset_t
name|vaddr
decl_stmt|;
comment|/* 	**	sanity check 	*/
if|if
condition|(
name|reg
operator|<
name|PCI_MAP_REG_START
operator|||
name|reg
operator|>=
name|PCI_MAP_REG_END
operator|||
operator|(
name|reg
operator|&
literal|3
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"pci_map_mem failed: bad register=0x%x\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
empty_stmt|;
comment|/* 	**	get size and type of memory 	** 	**	type is in the lowest four bits. 	**	If device requires 2^n bytes, the next 	**	n-4 bits are read as 0. 	*/
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|,
literal|0xfffffffful
argument_list|)
expr_stmt|;
name|data
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|data
operator|&
literal|0x0f
condition|)
block|{
case|case
name|PCI_MAP_MEMORY_TYPE_32BIT
case|:
comment|/* 32 bit non cachable */
break|break;
default|default:
comment|/* unknown */
name|printf
argument_list|(
literal|"pci_map_mem failed: bad memory type=0x%x\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|data
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
empty_stmt|;
comment|/* 	**	mask out the type, 	**	and round up to a page size 	*/
name|vsize
operator|=
name|round_page
argument_list|(
operator|-
operator|(
name|data
operator|&
name|PCI_MAP_MEMORY_ADDRESS_MASK
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vsize
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	**	align physical address to virtual size 	*/
if|if
condition|(
operator|(
name|data
operator|=
name|pci_paddr
operator|%
name|vsize
operator|)
condition|)
name|pci_paddr
operator|+=
name|vsize
operator|-
name|data
expr_stmt|;
name|vaddr
operator|=
operator|(
name|vm_offset_t
operator|)
name|pmap_mapdev
argument_list|(
name|pci_paddr
argument_list|,
name|vsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vaddr
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifndef|#
directive|ifndef
name|PCI_QUIET
comment|/* 	**	display values. 	*/
name|printf
argument_list|(
literal|"\treg%d: virtual=0x%lx physical=0x%lx\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|reg
argument_list|,
operator|(
name|u_long
operator|)
name|vaddr
argument_list|,
operator|(
name|u_long
operator|)
name|pci_paddr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	**	return them to the driver 	*/
operator|*
name|va
operator|=
name|vaddr
expr_stmt|;
operator|*
name|pa
operator|=
name|pci_paddr
expr_stmt|;
comment|/* 	**	set device address 	*/
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|,
name|pci_paddr
argument_list|)
expr_stmt|;
comment|/* 	**	and don't forget to increment pci_paddr 	*/
name|pci_paddr
operator|+=
name|vsize
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*------------------------------------------------------------ ** **	Interface functions for the devconf module. ** **------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|int
name|pci_externalize
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|kern_devconf
modifier|*
name|kdcp
parameter_list|,
name|void
modifier|*
name|u
parameter_list|,
name|size_t
name|l
parameter_list|)
block|{
name|struct
name|pci_externalize_buffer
name|buffer
decl_stmt|;
name|struct
name|pci_info
modifier|*
name|pip
init|=
name|kdcp
operator|->
name|kdc_parentdata
decl_stmt|;
name|pcici_t
name|tag
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|l
operator|<
sizeof|sizeof
name|buffer
condition|)
block|{
return|return
name|ENOMEM
return|;
block|}
empty_stmt|;
name|tag
operator|=
name|pcitag
argument_list|(
name|pip
operator|->
name|pi_bus
argument_list|,
name|pip
operator|->
name|pi_device
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|peb_pci_info
operator|=
operator|*
name|pip
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PCI_EXT_CONF_LEN
condition|;
name|i
operator|++
control|)
block|{
name|buffer
operator|.
name|peb_config
index|[
name|i
index|]
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|i
operator|*
literal|4
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
return|return
name|copyout
argument_list|(
operator|&
name|buffer
argument_list|,
name|u
argument_list|,
sizeof|sizeof
name|buffer
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pci_internalize
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|kern_devconf
modifier|*
name|kdcp
parameter_list|,
name|void
modifier|*
name|u
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
return|return
name|EOPNOTSUPP
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*----------------------------------------------------------------------- ** **	Map pci interrupts to isa interrupts. ** **----------------------------------------------------------------------- */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|pci_int_mask
index|[
literal|16
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|pci_map_int
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|unsigned
modifier|*
name|maskptr
parameter_list|)
block|{
name|int
name|irq
decl_stmt|;
name|unsigned
name|mask
decl_stmt|;
name|irq
operator|=
name|PCI_INTERRUPT_LINE_EXTRACT
argument_list|(
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_INTERRUPT_REG
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|irq
operator|>=
literal|16
operator|||
name|irq
operator|<=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"pci_map_int failed: no int line set.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|mask
operator|=
literal|1ul
operator|<<
name|irq
expr_stmt|;
if|if
condition|(
operator|!
name|maskptr
condition|)
name|maskptr
operator|=
operator|&
name|pci_int_mask
index|[
name|irq
index|]
expr_stmt|;
name|INTRMASK
argument_list|(
operator|*
name|maskptr
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|register_intr
argument_list|(
name|irq
argument_list|,
comment|/* isa irq	*/
literal|0
argument_list|,
comment|/* deviced??	*/
literal|0
argument_list|,
comment|/* flags?	*/
operator|(
name|inthand2_t
operator|*
operator|)
name|func
argument_list|,
comment|/* handler	*/
name|maskptr
argument_list|,
comment|/* mask pointer	*/
operator|(
name|int
operator|)
name|arg
argument_list|)
expr_stmt|;
comment|/* handler arg	*/
ifdef|#
directive|ifdef
name|__FreeBSD2__
comment|/* 	**	XXX See comment at beginning of file. 	** 	**	Have to update all the interrupt masks ... Grrrrr!!! 	*/
block|{
name|unsigned
modifier|*
name|mp
init|=
operator|&
name|intr_mask
index|[
literal|0
index|]
decl_stmt|;
comment|/* 		**	update the isa interrupt masks. 		*/
for|for
control|(
name|mp
operator|=
operator|&
name|intr_mask
index|[
literal|0
index|]
init|;
name|mp
operator|<
operator|&
name|intr_mask
index|[
name|ICU_LEN
index|]
condition|;
name|mp
operator|++
control|)
if|if
condition|(
operator|*
name|mp
operator|&
operator|*
name|maskptr
condition|)
operator|*
name|mp
operator||=
name|mask
expr_stmt|;
comment|/* 		**	update the pci interrupt masks. 		*/
for|for
control|(
name|mp
operator|=
operator|&
name|pci_int_mask
index|[
literal|0
index|]
init|;
name|mp
operator|<
operator|&
name|pci_int_mask
index|[
literal|16
index|]
condition|;
name|mp
operator|++
control|)
if|if
condition|(
operator|*
name|mp
operator|&
operator|*
name|maskptr
condition|)
operator|*
name|mp
operator||=
name|mask
expr_stmt|;
block|}
empty_stmt|;
endif|#
directive|endif
name|INTREN
argument_list|(
name|mask
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*----------------------------------------------------------- ** **	Display of unknown devices. ** **----------------------------------------------------------- */
end_comment

begin_struct
struct|struct
name|vt
block|{
name|u_short
name|ident
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|vt
name|VendorTable
index|[]
init|=
block|{
block|{
literal|0x1002
block|,
literal|"ATI TECHNOLOGIES INC"
block|}
block|,
block|{
literal|0x1011
block|,
literal|"DIGITAL EQUIPMENT CORPORATION"
block|}
block|,
block|{
literal|0x101A
block|,
literal|"NCR"
block|}
block|,
block|{
literal|0x102B
block|,
literal|"MATROX"
block|}
block|,
block|{
literal|0x1045
block|,
literal|"OPTI"
block|}
block|,
block|{
literal|0x5333
block|,
literal|"S3 INC."
block|}
block|,
block|{
literal|0x8086
block|,
literal|"INTEL CORPORATION"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|majclasses
index|[]
init|=
block|{
literal|"old"
block|,
literal|"storage"
block|,
literal|"network"
block|,
literal|"display"
block|,
literal|"multimedia"
block|,
literal|"memory"
block|,
literal|"bridge"
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|void
name|not_supported
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|u_long
name|type
parameter_list|)
block|{
name|u_char
name|reg
decl_stmt|;
name|u_long
name|data
decl_stmt|;
name|struct
name|vt
modifier|*
name|vp
decl_stmt|;
comment|/* 	**	lookup the names. 	*/
for|for
control|(
name|vp
operator|=
name|VendorTable
init|;
name|vp
operator|->
name|ident
condition|;
name|vp
operator|++
control|)
if|if
condition|(
name|vp
operator|->
name|ident
operator|==
operator|(
name|type
operator|&
literal|0xffff
operator|)
condition|)
break|break;
comment|/* 	**	and display them. 	*/
if|if
condition|(
name|vp
operator|->
name|ident
condition|)
name|printf
argument_list|(
name|vp
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"vendor=0x%lx"
argument_list|,
name|type
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", device=0x%lx"
argument_list|,
name|type
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_CLASS_REG
argument_list|)
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|data
operator|<
sizeof|sizeof
argument_list|(
name|majclasses
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|majclasses
index|[
literal|0
index|]
argument_list|)
condition|)
name|printf
argument_list|(
literal|", class=%s"
argument_list|,
name|majclasses
index|[
name|data
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" [not supported]\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|reg
operator|=
name|PCI_MAP_REG_START
init|;
name|reg
operator|<
name|PCI_MAP_REG_END
condition|;
name|reg
operator|+=
literal|4
control|)
block|{
name|data
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|data
condition|)
continue|continue;
switch|switch
condition|(
name|data
operator|&
literal|7
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|5
case|:
name|printf
argument_list|(
literal|"	map(%x): io(%lx)\n"
argument_list|,
name|reg
argument_list|,
name|data
operator|&
operator|~
literal|3
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|printf
argument_list|(
literal|"	map(%x): mem32(%lx)\n"
argument_list|,
name|reg
argument_list|,
name|data
operator|&
operator|~
literal|7
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|printf
argument_list|(
literal|"	map(%x): mem20(%lx)\n"
argument_list|,
name|reg
argument_list|,
name|data
operator|&
operator|~
literal|7
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|printf
argument_list|(
literal|"	map(%x): mem64(%lx)\n"
argument_list|,
name|reg
argument_list|,
name|data
operator|&
operator|~
literal|7
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|__FreeBSD2__
end_ifndef

begin_comment
comment|/*----------------------------------------------------------- ** **	Mapping of physical to virtual memory ** **----------------------------------------------------------- */
end_comment

begin_decl_stmt
specifier|extern
name|vm_map_t
name|kernel_map
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|vm_offset_t
name|pmap_mapdev
parameter_list|(
name|vm_offset_t
name|paddr
parameter_list|,
name|vm_size_t
name|vsize
parameter_list|)
block|{
name|vm_offset_t
name|vaddr
decl_stmt|,
name|value
decl_stmt|;
name|u_long
name|result
decl_stmt|;
name|vaddr
operator|=
name|vm_map_min
argument_list|(
name|kernel_map
argument_list|)
expr_stmt|;
name|result
operator|=
name|vm_map_find
argument_list|(
name|kernel_map
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|vm_offset_t
operator|)
literal|0
argument_list|,
operator|&
name|vaddr
argument_list|,
name|vsize
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|KERN_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|" vm_map_find failed(%d)\n"
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
empty_stmt|;
comment|/* 	**	map physical 	*/
name|value
operator|=
name|vaddr
expr_stmt|;
while|while
condition|(
name|vsize
operator|>=
name|NBPG
condition|)
block|{
name|pmap_enter
argument_list|(
name|pmap_kernel
argument_list|()
argument_list|,
name|vaddr
argument_list|,
name|paddr
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|vaddr
operator|+=
name|NBPG
expr_stmt|;
name|paddr
operator|+=
name|NBPG
expr_stmt|;
name|vsize
operator|-=
name|NBPG
expr_stmt|;
block|}
empty_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*------------------------------------------------------------ ** **	Emulate the register_intr() function of FreeBSD 2.0 ** **	requires a patch: **	FreeBSD 2.0:	"/sys/i386/isa/vector.s" **	386bsd0.1:	"/sys/i386/isa/icu.s" **	386bsd1.0:	Please ask Jesus Monroy Jr. ** **------------------------------------------------------------ */
end_comment

begin_include
include|#
directive|include
file|<machine/segments.h>
end_include

begin_decl_stmt
name|int
name|pci_int_unit
index|[
literal|16
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|inthand2_t
argument_list|*
operator|(
name|pci_int_hdlr
index|[
literal|16
index|]
operator|)
argument_list|;
name|unsigned
name|int
operator|*
name|pci_int_mptr
index|[
literal|16
index|]
argument_list|;
name|unsigned
name|int
name|pci_int_count
index|[
literal|16
index|]
argument_list|;
specifier|extern
name|void
name|Vpci3
argument_list|()
argument_list|,
name|Vpci4
argument_list|()
argument_list|,
name|Vpci5
argument_list|()
argument_list|,
name|Vpci6
argument_list|()
argument_list|,
name|Vpci7
argument_list|()
argument_list|,
name|Vpci8
argument_list|()
argument_list|,
name|Vpci9
argument_list|()
argument_list|,
name|Vpci10
argument_list|()
argument_list|,
name|Vpci11
argument_list|()
argument_list|,
name|Vpci12
argument_list|()
argument_list|,
name|Vpci13
argument_list|()
argument_list|,
name|Vpci14
argument_list|()
argument_list|,
name|Vpci15
argument_list|()
argument_list|;
specifier|static
name|inthand_t
operator|*
name|pci_int_glue
index|[
literal|16
index|]
operator|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|Vpci3
block|,
name|Vpci4
block|,
name|Vpci5
block|,
name|Vpci6
block|,
name|Vpci7
block|,
name|Vpci8
block|,
name|Vpci9
block|,
name|Vpci10
block|,
name|Vpci11
block|,
name|Vpci12
block|,
name|Vpci13
block|,
name|Vpci14
block|,
name|Vpci15
block|}
argument_list|;
specifier|static
name|int
name|register_intr
name|__P
argument_list|(
argument|(int intr, int device_id, unsigned int flags, 		       inthand2_t *handler, unsigned int* mptr, int unit)
argument_list|)
block|{
if|if
condition|(
name|intr
operator|>=
literal|16
operator|||
name|intr
operator|<=
literal|2
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|pci_int_hdlr
index|[
name|intr
index|]
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
end_expr_stmt

begin_expr_stmt
name|pci_int_hdlr
index|[
name|intr
index|]
operator|=
name|handler
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|pci_int_unit
index|[
name|intr
index|]
operator|=
name|unit
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|pci_int_mptr
index|[
name|intr
index|]
operator|=
name|mptr
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setidt
argument_list|(
name|NRSVIDT
operator|+
name|intr
argument_list|,
name|pci_int_glue
index|[
name|intr
index|]
argument_list|,
name|SDT_SYS386IGT
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
literal|0
operator|)
return|;
end_return

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD2__ */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NPCI */
end_comment

end_unit

