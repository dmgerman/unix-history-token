begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997, Stefan Esser<se@freebsd.org>  * Copyright (c) 2000, Michael Smith<msmith@freebsd.org>  * Copyright (c) 2000, BSDi  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  *  */
end_comment

begin_include
include|#
directive|include
file|"opt_bus.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/pciio.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pci_private.h>
end_include

begin_include
include|#
directive|include
file|"pcib_if.h"
end_include

begin_include
include|#
directive|include
file|"pci_if.h"
end_include

begin_function_decl
specifier|static
name|uint32_t
name|pci_mapbase
parameter_list|(
name|unsigned
name|mapreg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_maptype
parameter_list|(
name|unsigned
name|mapreg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_mapsize
parameter_list|(
name|unsigned
name|testval
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_maprange
parameter_list|(
name|unsigned
name|mapreg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pci_fixancient
parameter_list|(
name|pcicfgregs
modifier|*
name|cfg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_porten
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|s
parameter_list|,
name|int
name|f
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_memen
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|s
parameter_list|,
name|int
name|f
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_add_map
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|s
parameter_list|,
name|int
name|f
parameter_list|,
name|int
name|reg
parameter_list|,
name|struct
name|resource_list
modifier|*
name|rl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pci_add_resources
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pci_load_vendor_data
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_describe_parse_line
parameter_list|(
name|char
modifier|*
modifier|*
name|ptr
parameter_list|,
name|int
modifier|*
name|vendor
parameter_list|,
name|int
modifier|*
name|device
parameter_list|,
name|char
modifier|*
modifier|*
name|desc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|pci_describe_device
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|what
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pci_hdrtypedata
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|s
parameter_list|,
name|int
name|f
parameter_list|,
name|pcicfgregs
modifier|*
name|cfg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pci_read_extcap
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|pcicfgregs
modifier|*
name|cfg
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|pci_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|pci_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|pci_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bus_generic_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|bus_generic_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|pci_resume
argument_list|)
block|,
comment|/* Bus interface */
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|pci_print_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_probe_nomatch
argument_list|,
name|pci_probe_nomatch
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_read_ivar
argument_list|,
name|pci_read_ivar
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_write_ivar
argument_list|,
name|pci_write_ivar
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_driver_added
argument_list|,
name|bus_generic_driver_added
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_setup_intr
argument_list|,
name|bus_generic_setup_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_teardown_intr
argument_list|,
name|bus_generic_teardown_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_get_resource_list
argument_list|,
name|pci_get_resource_list
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_set_resource
argument_list|,
name|bus_generic_rl_set_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_get_resource
argument_list|,
name|bus_generic_rl_get_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_delete_resource
argument_list|,
name|pci_delete_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_alloc_resource
argument_list|,
name|pci_alloc_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_release_resource
argument_list|,
name|bus_generic_rl_release_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_activate_resource
argument_list|,
name|bus_generic_activate_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_deactivate_resource
argument_list|,
name|bus_generic_deactivate_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_child_pnpinfo_str
argument_list|,
name|pci_child_pnpinfo_str_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_child_location_str
argument_list|,
name|pci_child_location_str_method
argument_list|)
block|,
comment|/* PCI interface */
name|DEVMETHOD
argument_list|(
name|pci_read_config
argument_list|,
name|pci_read_config_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_write_config
argument_list|,
name|pci_write_config_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_enable_busmaster
argument_list|,
name|pci_enable_busmaster_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_disable_busmaster
argument_list|,
name|pci_disable_busmaster_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_enable_io
argument_list|,
name|pci_enable_io_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_disable_io
argument_list|,
name|pci_disable_io_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_get_powerstate
argument_list|,
name|pci_get_powerstate_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_set_powerstate
argument_list|,
name|pci_set_powerstate_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_assign_interrupt
argument_list|,
name|pci_assign_interrupt_method
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|pci_driver
init|=
block|{
literal|"pci"
block|,
name|pci_methods
block|,
literal|0
block|,
comment|/* no softc */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|devclass_t
name|pci_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|pci
argument_list|,
name|pcib
argument_list|,
name|pci_driver
argument_list|,
name|pci_devclass
argument_list|,
name|pci_modevent
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|pci
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pci_vendordata
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|pci_vendordata_size
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|pci_quirk
block|{
name|uint32_t
name|devid
decl_stmt|;
comment|/* Vendor/device of the card */
name|int
name|type
decl_stmt|;
define|#
directive|define
name|PCI_QUIRK_MAP_REG
value|1
comment|/* PCI map register in weird place */
name|int
name|arg1
decl_stmt|;
name|int
name|arg2
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|pci_quirk
name|pci_quirks
index|[]
init|=
block|{
comment|/* The Intel 82371AB and 82443MX has a map register at offset 0x90. */
block|{
literal|0x71138086
block|,
name|PCI_QUIRK_MAP_REG
block|,
literal|0x90
block|,
literal|0
block|}
block|,
block|{
literal|0x719b8086
block|,
name|PCI_QUIRK_MAP_REG
block|,
literal|0x90
block|,
literal|0
block|}
block|,
comment|/* As does the Serverworks OSB4 (the SMBus mapping register) */
block|{
literal|0x02001166
block|,
name|PCI_QUIRK_MAP_REG
block|,
literal|0x90
block|,
literal|0
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* map register information */
end_comment

begin_define
define|#
directive|define
name|PCI_MAPMEM
value|0x01
end_define

begin_comment
comment|/* memory map */
end_comment

begin_define
define|#
directive|define
name|PCI_MAPMEMP
value|0x02
end_define

begin_comment
comment|/* prefetchable memory map */
end_comment

begin_define
define|#
directive|define
name|PCI_MAPPORT
value|0x04
end_define

begin_comment
comment|/* port map */
end_comment

begin_decl_stmt
name|struct
name|devlist
name|pci_devq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|pci_generation
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|pci_numdevs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sysctl vars */
end_comment

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|pci
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"PCI bus tuning parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|pci_enable_io_modes
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.pci.enable_io_modes"
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|&
name|pci_enable_io_modes
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_pci
argument_list|,
name|OID_AUTO
argument_list|,
name|enable_io_modes
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|pci_enable_io_modes
argument_list|,
literal|1
argument_list|,
literal|"Enable I/O and memory bits in the config register.  Some BIOSes do not\n\ enable these bits correctly.  We'd like to do this all the time, but there\n\ are some peripherals that this causes problems with."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Find a device_t by bus/slot/function */
end_comment

begin_function
name|device_t
name|pci_find_bsf
parameter_list|(
name|uint8_t
name|bus
parameter_list|,
name|uint8_t
name|slot
parameter_list|,
name|uint8_t
name|func
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|dinfo
argument_list|,
argument|&pci_devq
argument_list|,
argument|pci_links
argument_list|)
block|{
if|if
condition|(
operator|(
name|dinfo
operator|->
name|cfg
operator|.
name|bus
operator|==
name|bus
operator|)
operator|&&
operator|(
name|dinfo
operator|->
name|cfg
operator|.
name|slot
operator|==
name|slot
operator|)
operator|&&
operator|(
name|dinfo
operator|->
name|cfg
operator|.
name|func
operator|==
name|func
operator|)
condition|)
block|{
return|return
operator|(
name|dinfo
operator|->
name|cfg
operator|.
name|dev
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Find a device_t by vendor/device ID */
end_comment

begin_function
name|device_t
name|pci_find_device
parameter_list|(
name|uint16_t
name|vendor
parameter_list|,
name|uint16_t
name|device
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|dinfo
argument_list|,
argument|&pci_devq
argument_list|,
argument|pci_links
argument_list|)
block|{
if|if
condition|(
operator|(
name|dinfo
operator|->
name|cfg
operator|.
name|vendor
operator|==
name|vendor
operator|)
operator|&&
operator|(
name|dinfo
operator|->
name|cfg
operator|.
name|device
operator|==
name|device
operator|)
condition|)
block|{
return|return
operator|(
name|dinfo
operator|->
name|cfg
operator|.
name|dev
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* return base address of memory or port map */
end_comment

begin_function
specifier|static
name|uint32_t
name|pci_mapbase
parameter_list|(
name|unsigned
name|mapreg
parameter_list|)
block|{
name|int
name|mask
init|=
literal|0x03
decl_stmt|;
if|if
condition|(
operator|(
name|mapreg
operator|&
literal|0x01
operator|)
operator|==
literal|0
condition|)
name|mask
operator|=
literal|0x0f
expr_stmt|;
return|return
operator|(
name|mapreg
operator|&
operator|~
name|mask
operator|)
return|;
block|}
end_function

begin_comment
comment|/* return map type of memory or port map */
end_comment

begin_function
specifier|static
name|int
name|pci_maptype
parameter_list|(
name|unsigned
name|mapreg
parameter_list|)
block|{
specifier|static
name|uint8_t
name|maptype
index|[
literal|0x10
index|]
init|=
block|{
name|PCI_MAPMEM
block|,
name|PCI_MAPPORT
block|,
name|PCI_MAPMEM
block|,
literal|0
block|,
name|PCI_MAPMEM
block|,
name|PCI_MAPPORT
block|,
literal|0
block|,
literal|0
block|,
name|PCI_MAPMEM
operator||
name|PCI_MAPMEMP
block|,
name|PCI_MAPPORT
block|,
name|PCI_MAPMEM
operator||
name|PCI_MAPMEMP
block|,
literal|0
block|,
name|PCI_MAPMEM
operator||
name|PCI_MAPMEMP
block|,
name|PCI_MAPPORT
block|,
literal|0
block|,
literal|0
block|, 	}
decl_stmt|;
return|return
name|maptype
index|[
name|mapreg
operator|&
literal|0x0f
index|]
return|;
block|}
end_function

begin_comment
comment|/* return log2 of map size decoded for memory or port map */
end_comment

begin_function
specifier|static
name|int
name|pci_mapsize
parameter_list|(
name|unsigned
name|testval
parameter_list|)
block|{
name|int
name|ln2size
decl_stmt|;
name|testval
operator|=
name|pci_mapbase
argument_list|(
name|testval
argument_list|)
expr_stmt|;
name|ln2size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|testval
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
operator|(
name|testval
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|ln2size
operator|++
expr_stmt|;
name|testval
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ln2size
operator|)
return|;
block|}
end_function

begin_comment
comment|/* return log2 of address range supported by map register */
end_comment

begin_function
specifier|static
name|int
name|pci_maprange
parameter_list|(
name|unsigned
name|mapreg
parameter_list|)
block|{
name|int
name|ln2range
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|mapreg
operator|&
literal|0x07
condition|)
block|{
case|case
literal|0x00
case|:
case|case
literal|0x01
case|:
case|case
literal|0x05
case|:
name|ln2range
operator|=
literal|32
expr_stmt|;
break|break;
case|case
literal|0x02
case|:
name|ln2range
operator|=
literal|20
expr_stmt|;
break|break;
case|case
literal|0x04
case|:
name|ln2range
operator|=
literal|64
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|ln2range
operator|)
return|;
block|}
end_function

begin_comment
comment|/* adjust some values from PCI 1.0 devices to match 2.0 standards ... */
end_comment

begin_function
specifier|static
name|void
name|pci_fixancient
parameter_list|(
name|pcicfgregs
modifier|*
name|cfg
parameter_list|)
block|{
if|if
condition|(
name|cfg
operator|->
name|hdrtype
operator|!=
literal|0
condition|)
return|return;
comment|/* PCI to PCI bridges use header type 1 */
if|if
condition|(
name|cfg
operator|->
name|baseclass
operator|==
name|PCIC_BRIDGE
operator|&&
name|cfg
operator|->
name|subclass
operator|==
name|PCIS_BRIDGE_PCI
condition|)
name|cfg
operator|->
name|hdrtype
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* extract header type specific config data */
end_comment

begin_function
specifier|static
name|void
name|pci_hdrtypedata
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|s
parameter_list|,
name|int
name|f
parameter_list|,
name|pcicfgregs
modifier|*
name|cfg
parameter_list|)
block|{
define|#
directive|define
name|REG
parameter_list|(
name|n
parameter_list|,
name|w
parameter_list|)
value|PCIB_READ_CONFIG(pcib, b, s, f, n, w)
switch|switch
condition|(
name|cfg
operator|->
name|hdrtype
condition|)
block|{
case|case
literal|0
case|:
name|cfg
operator|->
name|subvendor
operator|=
name|REG
argument_list|(
name|PCIR_SUBVEND_0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|subdevice
operator|=
name|REG
argument_list|(
name|PCIR_SUBDEV_0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|nummaps
operator|=
name|PCI_MAXMAPS_0
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|cfg
operator|->
name|subvendor
operator|=
name|REG
argument_list|(
name|PCIR_SUBVEND_1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|subdevice
operator|=
name|REG
argument_list|(
name|PCIR_SUBDEV_1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|nummaps
operator|=
name|PCI_MAXMAPS_1
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|cfg
operator|->
name|subvendor
operator|=
name|REG
argument_list|(
name|PCIR_SUBVEND_2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|subdevice
operator|=
name|REG
argument_list|(
name|PCIR_SUBDEV_2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|nummaps
operator|=
name|PCI_MAXMAPS_2
expr_stmt|;
break|break;
block|}
undef|#
directive|undef
name|REG
block|}
end_function

begin_comment
comment|/* read configuration header into pcicfgregs structure */
end_comment

begin_function
name|struct
name|pci_devinfo
modifier|*
name|pci_read_device
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|s
parameter_list|,
name|int
name|f
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
define|#
directive|define
name|REG
parameter_list|(
name|n
parameter_list|,
name|w
parameter_list|)
value|PCIB_READ_CONFIG(pcib, b, s, f, n, w)
name|pcicfgregs
modifier|*
name|cfg
init|=
name|NULL
decl_stmt|;
name|struct
name|pci_devinfo
modifier|*
name|devlist_entry
decl_stmt|;
name|struct
name|devlist
modifier|*
name|devlist_head
decl_stmt|;
name|devlist_head
operator|=
operator|&
name|pci_devq
expr_stmt|;
name|devlist_entry
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|REG
argument_list|(
name|PCIR_DEVVENDOR
argument_list|,
literal|4
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|devlist_entry
operator|=
name|malloc
argument_list|(
name|size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|devlist_entry
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|cfg
operator|=
operator|&
name|devlist_entry
operator|->
name|cfg
expr_stmt|;
name|cfg
operator|->
name|bus
operator|=
name|b
expr_stmt|;
name|cfg
operator|->
name|slot
operator|=
name|s
expr_stmt|;
name|cfg
operator|->
name|func
operator|=
name|f
expr_stmt|;
name|cfg
operator|->
name|vendor
operator|=
name|REG
argument_list|(
name|PCIR_VENDOR
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|device
operator|=
name|REG
argument_list|(
name|PCIR_DEVICE
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|cmdreg
operator|=
name|REG
argument_list|(
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|statreg
operator|=
name|REG
argument_list|(
name|PCIR_STATUS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|baseclass
operator|=
name|REG
argument_list|(
name|PCIR_CLASS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|subclass
operator|=
name|REG
argument_list|(
name|PCIR_SUBCLASS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|progif
operator|=
name|REG
argument_list|(
name|PCIR_PROGIF
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|revid
operator|=
name|REG
argument_list|(
name|PCIR_REVID
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|hdrtype
operator|=
name|REG
argument_list|(
name|PCIR_HDRTYPE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|cachelnsz
operator|=
name|REG
argument_list|(
name|PCIR_CACHELNSZ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|lattimer
operator|=
name|REG
argument_list|(
name|PCIR_LATTIMER
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|intpin
operator|=
name|REG
argument_list|(
name|PCIR_INTPIN
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|intline
operator|=
name|REG
argument_list|(
name|PCIR_INTLINE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|mingnt
operator|=
name|REG
argument_list|(
name|PCIR_MINGNT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|maxlat
operator|=
name|REG
argument_list|(
name|PCIR_MAXLAT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|mfdev
operator|=
operator|(
name|cfg
operator|->
name|hdrtype
operator|&
name|PCIM_MFDEV
operator|)
operator|!=
literal|0
expr_stmt|;
name|cfg
operator|->
name|hdrtype
operator|&=
operator|~
name|PCIM_MFDEV
expr_stmt|;
name|pci_fixancient
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
name|pci_hdrtypedata
argument_list|(
name|pcib
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|cfg
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG
argument_list|(
name|PCIR_STATUS
argument_list|,
literal|2
argument_list|)
operator|&
name|PCIM_STATUS_CAPPRESENT
condition|)
name|pci_read_extcap
argument_list|(
name|pcib
argument_list|,
name|cfg
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
name|devlist_head
argument_list|,
name|devlist_entry
argument_list|,
name|pci_links
argument_list|)
expr_stmt|;
name|devlist_entry
operator|->
name|conf
operator|.
name|pc_sel
operator|.
name|pc_bus
operator|=
name|cfg
operator|->
name|bus
expr_stmt|;
name|devlist_entry
operator|->
name|conf
operator|.
name|pc_sel
operator|.
name|pc_dev
operator|=
name|cfg
operator|->
name|slot
expr_stmt|;
name|devlist_entry
operator|->
name|conf
operator|.
name|pc_sel
operator|.
name|pc_func
operator|=
name|cfg
operator|->
name|func
expr_stmt|;
name|devlist_entry
operator|->
name|conf
operator|.
name|pc_hdr
operator|=
name|cfg
operator|->
name|hdrtype
expr_stmt|;
name|devlist_entry
operator|->
name|conf
operator|.
name|pc_subvendor
operator|=
name|cfg
operator|->
name|subvendor
expr_stmt|;
name|devlist_entry
operator|->
name|conf
operator|.
name|pc_subdevice
operator|=
name|cfg
operator|->
name|subdevice
expr_stmt|;
name|devlist_entry
operator|->
name|conf
operator|.
name|pc_vendor
operator|=
name|cfg
operator|->
name|vendor
expr_stmt|;
name|devlist_entry
operator|->
name|conf
operator|.
name|pc_device
operator|=
name|cfg
operator|->
name|device
expr_stmt|;
name|devlist_entry
operator|->
name|conf
operator|.
name|pc_class
operator|=
name|cfg
operator|->
name|baseclass
expr_stmt|;
name|devlist_entry
operator|->
name|conf
operator|.
name|pc_subclass
operator|=
name|cfg
operator|->
name|subclass
expr_stmt|;
name|devlist_entry
operator|->
name|conf
operator|.
name|pc_progif
operator|=
name|cfg
operator|->
name|progif
expr_stmt|;
name|devlist_entry
operator|->
name|conf
operator|.
name|pc_revid
operator|=
name|cfg
operator|->
name|revid
expr_stmt|;
name|pci_numdevs
operator|++
expr_stmt|;
name|pci_generation
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|devlist_entry
operator|)
return|;
undef|#
directive|undef
name|REG
block|}
end_function

begin_function
specifier|static
name|void
name|pci_read_extcap
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|pcicfgregs
modifier|*
name|cfg
parameter_list|)
block|{
define|#
directive|define
name|REG
parameter_list|(
name|n
parameter_list|,
name|w
parameter_list|)
value|PCIB_READ_CONFIG(pcib, cfg->bus, cfg->slot, cfg->func, n, w)
name|int
name|ptr
decl_stmt|,
name|nextptr
decl_stmt|,
name|ptrptr
decl_stmt|;
switch|switch
condition|(
name|cfg
operator|->
name|hdrtype
operator|&
name|PCIM_HDRTYPE
condition|)
block|{
case|case
literal|0
case|:
name|ptrptr
operator|=
name|PCIR_CAP_PTR
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|ptrptr
operator|=
literal|0x14
expr_stmt|;
break|break;
default|default:
return|return;
comment|/* no extended capabilities support */
block|}
name|nextptr
operator|=
name|REG
argument_list|(
name|ptrptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* sanity check? */
comment|/* 	 * Read capability entries. 	 */
while|while
condition|(
name|nextptr
operator|!=
literal|0
condition|)
block|{
comment|/* Sanity check */
if|if
condition|(
name|nextptr
operator|>
literal|255
condition|)
block|{
name|printf
argument_list|(
literal|"illegal PCI extended capability offset %d\n"
argument_list|,
name|nextptr
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Find the next entry */
name|ptr
operator|=
name|nextptr
expr_stmt|;
name|nextptr
operator|=
name|REG
argument_list|(
name|ptr
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Process this entry */
switch|switch
condition|(
name|REG
argument_list|(
name|ptr
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
name|PCIY_PMG
case|:
comment|/* PCI power management */
if|if
condition|(
name|cfg
operator|->
name|pp
operator|.
name|pp_cap
operator|==
literal|0
condition|)
block|{
name|cfg
operator|->
name|pp
operator|.
name|pp_cap
operator|=
name|REG
argument_list|(
name|ptr
operator|+
name|PCIR_POWER_CAP
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|pp
operator|.
name|pp_status
operator|=
name|ptr
operator|+
name|PCIR_POWER_STATUS
expr_stmt|;
name|cfg
operator|->
name|pp
operator|.
name|pp_pmcsr
operator|=
name|ptr
operator|+
name|PCIR_POWER_PMCSR
expr_stmt|;
if|if
condition|(
operator|(
name|nextptr
operator|-
name|ptr
operator|)
operator|>
name|PCIR_POWER_DATA
condition|)
name|cfg
operator|->
name|pp
operator|.
name|pp_data
operator|=
name|ptr
operator|+
name|PCIR_POWER_DATA
expr_stmt|;
block|}
break|break;
case|case
name|PCIY_MSI
case|:
comment|/* PCI MSI */
name|cfg
operator|->
name|msi
operator|.
name|msi_ctrl
operator|=
name|REG
argument_list|(
name|ptr
operator|+
name|PCIR_MSI_CTRL
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|msi
operator|.
name|msi_ctrl
operator|&
name|PCIM_MSICTRL_64BIT
condition|)
name|cfg
operator|->
name|msi
operator|.
name|msi_data
operator|=
name|PCIR_MSI_DATA_64BIT
expr_stmt|;
else|else
name|cfg
operator|->
name|msi
operator|.
name|msi_data
operator|=
name|PCIR_MSI_DATA
expr_stmt|;
name|cfg
operator|->
name|msi
operator|.
name|msi_msgnum
operator|=
literal|1
operator|<<
operator|(
operator|(
name|cfg
operator|->
name|msi
operator|.
name|msi_ctrl
operator|&
name|PCIM_MSICTRL_MMC_MASK
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
default|default:
break|break;
block|}
block|}
undef|#
directive|undef
name|REG
block|}
end_function

begin_comment
comment|/* free pcicfgregs structure and all depending data structures */
end_comment

begin_function
name|int
name|pci_freecfg
parameter_list|(
name|struct
name|pci_devinfo
modifier|*
name|dinfo
parameter_list|)
block|{
name|struct
name|devlist
modifier|*
name|devlist_head
decl_stmt|;
name|devlist_head
operator|=
operator|&
name|pci_devq
expr_stmt|;
name|STAILQ_REMOVE
argument_list|(
name|devlist_head
argument_list|,
name|dinfo
argument_list|,
name|pci_devinfo
argument_list|,
name|pci_links
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dinfo
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
comment|/* increment the generation count */
name|pci_generation
operator|++
expr_stmt|;
comment|/* we're losing one device */
name|pci_numdevs
operator|--
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * PCI power manangement  */
end_comment

begin_function
name|int
name|pci_set_powerstate_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
name|uint16_t
name|status
decl_stmt|;
name|int
name|result
decl_stmt|;
if|if
condition|(
name|cfg
operator|->
name|pp
operator|.
name|pp_cap
operator|!=
literal|0
condition|)
block|{
name|status
operator|=
name|PCI_READ_CONFIG
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|cfg
operator|->
name|pp
operator|.
name|pp_status
argument_list|,
literal|2
argument_list|)
operator|&
operator|~
name|PCIM_PSTAT_DMASK
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|PCI_POWERSTATE_D0
case|:
name|status
operator||=
name|PCIM_PSTAT_D0
expr_stmt|;
break|break;
case|case
name|PCI_POWERSTATE_D1
case|:
if|if
condition|(
name|cfg
operator|->
name|pp
operator|.
name|pp_cap
operator|&
name|PCIM_PCAP_D1SUPP
condition|)
block|{
name|status
operator||=
name|PCIM_PSTAT_D1
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|EOPNOTSUPP
expr_stmt|;
block|}
break|break;
case|case
name|PCI_POWERSTATE_D2
case|:
if|if
condition|(
name|cfg
operator|->
name|pp
operator|.
name|pp_cap
operator|&
name|PCIM_PCAP_D2SUPP
condition|)
block|{
name|status
operator||=
name|PCIM_PSTAT_D2
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|EOPNOTSUPP
expr_stmt|;
block|}
break|break;
case|case
name|PCI_POWERSTATE_D3
case|:
name|status
operator||=
name|PCIM_PSTAT_D3
expr_stmt|;
break|break;
default|default:
name|result
operator|=
name|EINVAL
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
literal|0
condition|)
name|PCI_WRITE_CONFIG
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|cfg
operator|->
name|pp
operator|.
name|pp_status
argument_list|,
name|status
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|ENXIO
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_get_powerstate_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
name|uint16_t
name|status
decl_stmt|;
name|int
name|result
decl_stmt|;
if|if
condition|(
name|cfg
operator|->
name|pp
operator|.
name|pp_cap
operator|!=
literal|0
condition|)
block|{
name|status
operator|=
name|PCI_READ_CONFIG
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|cfg
operator|->
name|pp
operator|.
name|pp_status
argument_list|,
literal|2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|status
operator|&
name|PCIM_PSTAT_DMASK
condition|)
block|{
case|case
name|PCIM_PSTAT_D0
case|:
name|result
operator|=
name|PCI_POWERSTATE_D0
expr_stmt|;
break|break;
case|case
name|PCIM_PSTAT_D1
case|:
name|result
operator|=
name|PCI_POWERSTATE_D1
expr_stmt|;
break|break;
case|case
name|PCIM_PSTAT_D2
case|:
name|result
operator|=
name|PCI_POWERSTATE_D2
expr_stmt|;
break|break;
case|case
name|PCIM_PSTAT_D3
case|:
name|result
operator|=
name|PCI_POWERSTATE_D3
expr_stmt|;
break|break;
default|default:
name|result
operator|=
name|PCI_POWERSTATE_UNKNOWN
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* No support, device is always at D0 */
name|result
operator|=
name|PCI_POWERSTATE_D0
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Some convenience functions for PCI device drivers.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|pci_set_command_bit
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|uint16_t
name|bit
parameter_list|)
block|{
name|uint16_t
name|command
decl_stmt|;
name|command
operator|=
name|PCI_READ_CONFIG
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|command
operator||=
name|bit
expr_stmt|;
name|PCI_WRITE_CONFIG
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|command
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|pci_clear_command_bit
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|uint16_t
name|bit
parameter_list|)
block|{
name|uint16_t
name|command
decl_stmt|;
name|command
operator|=
name|PCI_READ_CONFIG
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|command
operator|&=
operator|~
name|bit
expr_stmt|;
name|PCI_WRITE_CONFIG
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|command
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pci_enable_busmaster_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|pci_set_command_bit
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|PCIM_CMD_BUSMASTEREN
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_disable_busmaster_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|pci_clear_command_bit
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|PCIM_CMD_BUSMASTEREN
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_enable_io_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|space
parameter_list|)
block|{
name|uint16_t
name|command
decl_stmt|;
name|uint16_t
name|bit
decl_stmt|;
name|char
modifier|*
name|error
decl_stmt|;
name|bit
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|space
condition|)
block|{
case|case
name|SYS_RES_IOPORT
case|:
name|bit
operator|=
name|PCIM_CMD_PORTEN
expr_stmt|;
name|error
operator|=
literal|"port"
expr_stmt|;
break|break;
case|case
name|SYS_RES_MEMORY
case|:
name|bit
operator|=
name|PCIM_CMD_MEMEN
expr_stmt|;
name|error
operator|=
literal|"memory"
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|pci_set_command_bit
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|bit
argument_list|)
expr_stmt|;
name|command
operator|=
name|PCI_READ_CONFIG
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
operator|&
name|bit
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|device_printf
argument_list|(
name|child
argument_list|,
literal|"failed to enable %s mapping!\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_disable_io_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|space
parameter_list|)
block|{
name|uint16_t
name|command
decl_stmt|;
name|uint16_t
name|bit
decl_stmt|;
name|char
modifier|*
name|error
decl_stmt|;
name|bit
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|space
condition|)
block|{
case|case
name|SYS_RES_IOPORT
case|:
name|bit
operator|=
name|PCIM_CMD_PORTEN
expr_stmt|;
name|error
operator|=
literal|"port"
expr_stmt|;
break|break;
case|case
name|SYS_RES_MEMORY
case|:
name|bit
operator|=
name|PCIM_CMD_MEMEN
expr_stmt|;
name|error
operator|=
literal|"memory"
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|pci_clear_command_bit
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|bit
argument_list|)
expr_stmt|;
name|command
operator|=
name|PCI_READ_CONFIG
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
operator|&
name|bit
condition|)
block|{
name|device_printf
argument_list|(
name|child
argument_list|,
literal|"failed to disable %s mapping!\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * New style pci driver.  Parent device is either a pci-host-bridge or a  * pci-pci-bridge.  Both kinds are represented by instances of pcib.  */
end_comment

begin_function
name|void
name|pci_print_verbose
parameter_list|(
name|struct
name|pci_devinfo
modifier|*
name|dinfo
parameter_list|)
block|{
if|if
condition|(
name|bootverbose
condition|)
block|{
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
name|printf
argument_list|(
literal|"found->\tvendor=0x%04x, dev=0x%04x, revid=0x%02x\n"
argument_list|,
name|cfg
operator|->
name|vendor
argument_list|,
name|cfg
operator|->
name|device
argument_list|,
name|cfg
operator|->
name|revid
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tbus=%d, slot=%d, func=%d\n"
argument_list|,
name|cfg
operator|->
name|bus
argument_list|,
name|cfg
operator|->
name|slot
argument_list|,
name|cfg
operator|->
name|func
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tclass=%02x-%02x-%02x, hdrtype=0x%02x, mfdev=%d\n"
argument_list|,
name|cfg
operator|->
name|baseclass
argument_list|,
name|cfg
operator|->
name|subclass
argument_list|,
name|cfg
operator|->
name|progif
argument_list|,
name|cfg
operator|->
name|hdrtype
argument_list|,
name|cfg
operator|->
name|mfdev
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tcmdreg=0x%04x, statreg=0x%04x, cachelnsz=%d (dwords)\n"
argument_list|,
name|cfg
operator|->
name|cmdreg
argument_list|,
name|cfg
operator|->
name|statreg
argument_list|,
name|cfg
operator|->
name|cachelnsz
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tlattimer=0x%02x (%d ns), mingnt=0x%02x (%d ns), maxlat=0x%02x (%d ns)\n"
argument_list|,
name|cfg
operator|->
name|lattimer
argument_list|,
name|cfg
operator|->
name|lattimer
operator|*
literal|30
argument_list|,
name|cfg
operator|->
name|mingnt
argument_list|,
name|cfg
operator|->
name|mingnt
operator|*
literal|250
argument_list|,
name|cfg
operator|->
name|maxlat
argument_list|,
name|cfg
operator|->
name|maxlat
operator|*
literal|250
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|intpin
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"\tintpin=%c, irq=%d\n"
argument_list|,
name|cfg
operator|->
name|intpin
operator|+
literal|'a'
operator|-
literal|1
argument_list|,
name|cfg
operator|->
name|intline
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|pp
operator|.
name|pp_cap
condition|)
block|{
name|uint16_t
name|status
decl_stmt|;
name|status
operator|=
name|pci_read_config
argument_list|(
name|cfg
operator|->
name|dev
argument_list|,
name|cfg
operator|->
name|pp
operator|.
name|pp_status
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tpowerspec %d  supports D0%s%s D3  current D%d\n"
argument_list|,
name|cfg
operator|->
name|pp
operator|.
name|pp_cap
operator|&
name|PCIM_PCAP_SPEC
argument_list|,
name|cfg
operator|->
name|pp
operator|.
name|pp_cap
operator|&
name|PCIM_PCAP_D1SUPP
condition|?
literal|" D1"
else|:
literal|""
argument_list|,
name|cfg
operator|->
name|pp
operator|.
name|pp_cap
operator|&
name|PCIM_PCAP_D2SUPP
condition|?
literal|" D2"
else|:
literal|""
argument_list|,
name|status
operator|&
name|PCIM_PSTAT_DMASK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cfg
operator|->
name|msi
operator|.
name|msi_data
condition|)
block|{
name|int
name|ctrl
decl_stmt|;
name|ctrl
operator|=
name|cfg
operator|->
name|msi
operator|.
name|msi_ctrl
expr_stmt|;
name|printf
argument_list|(
literal|"\tMSI supports %d message%s%s%s\n"
argument_list|,
name|cfg
operator|->
name|msi
operator|.
name|msi_msgnum
argument_list|,
operator|(
name|cfg
operator|->
name|msi
operator|.
name|msi_msgnum
operator|==
literal|1
operator|)
condition|?
literal|""
else|:
literal|"s"
argument_list|,
operator|(
name|ctrl
operator|&
name|PCIM_MSICTRL_64BIT
operator|)
condition|?
literal|", 64 bit"
else|:
literal|""
argument_list|,
operator|(
name|ctrl
operator|&
name|PCIM_MSICTRL_VECTOR
operator|)
condition|?
literal|", vector masks"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|pci_porten
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|s
parameter_list|,
name|int
name|f
parameter_list|)
block|{
return|return
operator|(
name|PCIB_READ_CONFIG
argument_list|(
name|pcib
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
operator|&
name|PCIM_CMD_PORTEN
operator|)
operator|!=
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pci_memen
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|s
parameter_list|,
name|int
name|f
parameter_list|)
block|{
return|return
operator|(
name|PCIB_READ_CONFIG
argument_list|(
name|pcib
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
operator|&
name|PCIM_CMD_MEMEN
operator|)
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Add a resource based on a pci map register. Return 1 if the map  * register is a 32bit map register or 2 if it is a 64bit register.  */
end_comment

begin_function
specifier|static
name|int
name|pci_add_map
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|s
parameter_list|,
name|int
name|f
parameter_list|,
name|int
name|reg
parameter_list|,
name|struct
name|resource_list
modifier|*
name|rl
parameter_list|)
block|{
name|uint32_t
name|map
decl_stmt|;
name|uint64_t
name|base
decl_stmt|;
name|uint8_t
name|ln2size
decl_stmt|;
name|uint8_t
name|ln2range
decl_stmt|;
name|uint32_t
name|testval
decl_stmt|;
name|uint16_t
name|cmd
decl_stmt|;
name|int
name|type
decl_stmt|;
name|map
operator|=
name|PCIB_READ_CONFIG
argument_list|(
name|pcib
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|reg
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|==
literal|0
operator|||
name|map
operator|==
literal|0xffffffff
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* skip invalid entry */
name|PCIB_WRITE_CONFIG
argument_list|(
name|pcib
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|reg
argument_list|,
literal|0xffffffff
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|testval
operator|=
name|PCIB_READ_CONFIG
argument_list|(
name|pcib
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|reg
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|PCIB_WRITE_CONFIG
argument_list|(
name|pcib
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|reg
argument_list|,
name|map
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|base
operator|=
name|pci_mapbase
argument_list|(
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_maptype
argument_list|(
name|map
argument_list|)
operator|&
name|PCI_MAPMEM
condition|)
name|type
operator|=
name|SYS_RES_MEMORY
expr_stmt|;
else|else
name|type
operator|=
name|SYS_RES_IOPORT
expr_stmt|;
name|ln2size
operator|=
name|pci_mapsize
argument_list|(
name|testval
argument_list|)
expr_stmt|;
name|ln2range
operator|=
name|pci_maprange
argument_list|(
name|testval
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln2range
operator|==
literal|64
condition|)
block|{
comment|/* Read the other half of a 64bit map register */
name|base
operator||=
operator|(
name|uint64_t
operator|)
name|PCIB_READ_CONFIG
argument_list|(
name|pcib
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|reg
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
operator|<<
literal|32
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"\tmap[%02x]: type %x, range %2d, base %08x, size %2d"
argument_list|,
name|reg
argument_list|,
name|pci_maptype
argument_list|(
name|map
argument_list|)
argument_list|,
name|ln2range
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|base
argument_list|,
name|ln2size
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|SYS_RES_IOPORT
operator|&&
operator|!
name|pci_porten
argument_list|(
name|pcib
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|)
condition|)
name|printf
argument_list|(
literal|", port disabled\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|SYS_RES_MEMORY
operator|&&
operator|!
name|pci_memen
argument_list|(
name|pcib
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|)
condition|)
name|printf
argument_list|(
literal|", memory disabled\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|", enabled\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * This code theoretically does the right thing, but has 	 * undesirable side effects in some cases where 	 * peripherals respond oddly to having these bits 	 * enabled.  Leave them alone by default. 	 */
if|if
condition|(
name|pci_enable_io_modes
condition|)
block|{
comment|/* Turn on resources that have been left off by a lazy BIOS */
if|if
condition|(
name|type
operator|==
name|SYS_RES_IOPORT
operator|&&
operator|!
name|pci_porten
argument_list|(
name|pcib
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|cmd
operator|=
name|PCIB_READ_CONFIG
argument_list|(
name|pcib
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cmd
operator||=
name|PCIM_CMD_PORTEN
expr_stmt|;
name|PCIB_WRITE_CONFIG
argument_list|(
name|pcib
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|cmd
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|SYS_RES_MEMORY
operator|&&
operator|!
name|pci_memen
argument_list|(
name|pcib
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|cmd
operator|=
name|PCIB_READ_CONFIG
argument_list|(
name|pcib
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cmd
operator||=
name|PCIM_CMD_MEMEN
expr_stmt|;
name|PCIB_WRITE_CONFIG
argument_list|(
name|pcib
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|cmd
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|type
operator|==
name|SYS_RES_IOPORT
operator|&&
operator|!
name|pci_porten
argument_list|(
name|pcib
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|type
operator|==
name|SYS_RES_MEMORY
operator|&&
operator|!
name|pci_memen
argument_list|(
name|pcib
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|resource_list_add
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
name|reg
argument_list|,
name|base
argument_list|,
name|base
operator|+
operator|(
literal|1
operator|<<
name|ln2size
operator|)
operator|-
literal|1
argument_list|,
operator|(
literal|1
operator|<<
name|ln2size
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|ln2range
operator|==
literal|64
operator|)
condition|?
literal|2
else|:
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pci_add_resources
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
name|struct
name|resource_list
modifier|*
name|rl
init|=
operator|&
name|dinfo
operator|->
name|resources
decl_stmt|;
name|struct
name|pci_quirk
modifier|*
name|q
decl_stmt|;
name|int
name|b
decl_stmt|,
name|i
decl_stmt|,
name|irq
decl_stmt|,
name|f
decl_stmt|,
name|s
decl_stmt|;
name|b
operator|=
name|cfg
operator|->
name|bus
expr_stmt|;
name|s
operator|=
name|cfg
operator|->
name|slot
expr_stmt|;
name|f
operator|=
name|cfg
operator|->
name|func
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cfg
operator|->
name|nummaps
condition|;
control|)
block|{
name|i
operator|+=
name|pci_add_map
argument_list|(
name|pcib
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|PCIR_BAR
argument_list|(
name|i
argument_list|)
argument_list|,
name|rl
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|q
operator|=
operator|&
name|pci_quirks
index|[
literal|0
index|]
init|;
name|q
operator|->
name|devid
condition|;
name|q
operator|++
control|)
block|{
if|if
condition|(
name|q
operator|->
name|devid
operator|==
operator|(
operator|(
name|cfg
operator|->
name|device
operator|<<
literal|16
operator|)
operator||
name|cfg
operator|->
name|vendor
operator|)
operator|&&
name|q
operator|->
name|type
operator|==
name|PCI_QUIRK_MAP_REG
condition|)
name|pci_add_map
argument_list|(
name|pcib
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|q
operator|->
name|arg1
argument_list|,
name|rl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cfg
operator|->
name|intpin
operator|>
literal|0
operator|&&
name|PCI_INTERRUPT_VALID
argument_list|(
name|cfg
operator|->
name|intline
argument_list|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__ia64__
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SMP
argument_list|)
operator|)
comment|/* 		 * Try to re-route interrupts. Sometimes the BIOS or 		 * firmware may leave bogus values in these registers. 		 * If the re-route fails, then just stick with what we 		 * have. 		 */
name|irq
operator|=
name|PCI_ASSIGN_INTERRUPT
argument_list|(
name|bus
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|PCI_INTERRUPT_VALID
argument_list|(
name|irq
argument_list|)
condition|)
block|{
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_INTLINE
argument_list|,
name|irq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|intline
operator|=
name|irq
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|irq
operator|=
name|cfg
operator|->
name|intline
expr_stmt|;
name|resource_list_add
argument_list|(
name|rl
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|irq
argument_list|,
name|irq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|pci_add_children
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|busno
parameter_list|,
name|size_t
name|dinfo_size
parameter_list|)
block|{
define|#
directive|define
name|REG
parameter_list|(
name|n
parameter_list|,
name|w
parameter_list|)
value|PCIB_READ_CONFIG(pcib, busno, s, f, n, w)
name|device_t
name|pcib
init|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|int
name|maxslots
decl_stmt|;
name|int
name|s
decl_stmt|,
name|f
decl_stmt|,
name|pcifunchigh
decl_stmt|;
name|uint8_t
name|hdrtype
decl_stmt|;
name|KASSERT
argument_list|(
name|dinfo_size
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|pci_devinfo
argument_list|)
argument_list|,
operator|(
literal|"dinfo_size too small"
operator|)
argument_list|)
expr_stmt|;
name|maxslots
operator|=
name|PCIB_MAXSLOTS
argument_list|(
name|pcib
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<=
name|maxslots
condition|;
name|s
operator|++
control|)
block|{
name|pcifunchigh
operator|=
literal|0
expr_stmt|;
name|f
operator|=
literal|0
expr_stmt|;
name|hdrtype
operator|=
name|REG
argument_list|(
name|PCIR_HDRTYPE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hdrtype
operator|&
name|PCIM_HDRTYPE
operator|)
operator|>
name|PCI_MAXHDRTYPE
condition|)
continue|continue;
if|if
condition|(
name|hdrtype
operator|&
name|PCIM_MFDEV
condition|)
name|pcifunchigh
operator|=
name|PCI_FUNCMAX
expr_stmt|;
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<=
name|pcifunchigh
condition|;
name|f
operator|++
control|)
block|{
name|dinfo
operator|=
name|pci_read_device
argument_list|(
name|pcib
argument_list|,
name|busno
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|dinfo_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|dinfo
operator|!=
name|NULL
condition|)
block|{
name|pci_add_child
argument_list|(
name|dev
argument_list|,
name|dinfo
argument_list|)
expr_stmt|;
block|}
block|}
block|}
undef|#
directive|undef
name|REG
block|}
end_function

begin_function
name|void
name|pci_add_child
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|struct
name|pci_devinfo
modifier|*
name|dinfo
parameter_list|)
block|{
name|device_t
name|pcib
decl_stmt|;
name|pcib
operator|=
name|device_get_parent
argument_list|(
name|bus
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|dev
operator|=
name|device_add_child
argument_list|(
name|bus
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|device_set_ivars
argument_list|(
name|dinfo
operator|->
name|cfg
operator|.
name|dev
argument_list|,
name|dinfo
argument_list|)
expr_stmt|;
name|pci_add_resources
argument_list|(
name|pcib
argument_list|,
name|bus
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|dev
argument_list|)
expr_stmt|;
name|pci_print_verbose
argument_list|(
name|dinfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pci_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"PCI bus"
argument_list|)
expr_stmt|;
comment|/* Allow other subclasses to override this driver. */
return|return
operator|(
operator|-
literal|1000
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pci_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|busno
decl_stmt|;
comment|/* 	 * Since there can be multiple independantly numbered PCI 	 * busses on some large alpha systems, we can't use the unit 	 * number to decide what bus we are probing. We ask the parent  	 * pcib what our bus number is. 	 */
name|busno
operator|=
name|pcib_get_bus
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"physical bus=%d\n"
argument_list|,
name|busno
argument_list|)
expr_stmt|;
name|pci_add_children
argument_list|(
name|dev
argument_list|,
name|busno
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pci_devinfo
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pci_load_vendor_data
parameter_list|(
name|void
parameter_list|)
block|{
name|caddr_t
name|vendordata
decl_stmt|,
name|info
decl_stmt|;
if|if
condition|(
operator|(
name|vendordata
operator|=
name|preload_search_by_type
argument_list|(
literal|"pci_vendor_data"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|info
operator|=
name|preload_search_info
argument_list|(
name|vendordata
argument_list|,
name|MODINFO_ADDR
argument_list|)
expr_stmt|;
name|pci_vendordata
operator|=
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
name|info
expr_stmt|;
name|info
operator|=
name|preload_search_info
argument_list|(
name|vendordata
argument_list|,
name|MODINFO_SIZE
argument_list|)
expr_stmt|;
name|pci_vendordata_size
operator|=
operator|*
operator|(
name|size_t
operator|*
operator|)
name|info
expr_stmt|;
comment|/* terminate the database */
name|pci_vendordata
index|[
name|pci_vendordata_size
index|]
operator|=
literal|'\n'
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|pci_print_child
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|struct
name|resource_list
modifier|*
name|rl
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|rl
operator|=
operator|&
name|dinfo
operator|->
name|resources
expr_stmt|;
name|retval
operator|+=
name|bus_print_child_header
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|resource_list_print_type
argument_list|(
name|rl
argument_list|,
literal|"port"
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|"%#lx"
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|resource_list_print_type
argument_list|(
name|rl
argument_list|,
literal|"mem"
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|"%#lx"
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|resource_list_print_type
argument_list|(
name|rl
argument_list|,
literal|"irq"
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|"%ld"
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_get_flags
argument_list|(
name|dev
argument_list|)
condition|)
name|retval
operator|+=
name|printf
argument_list|(
literal|" flags %#x"
argument_list|,
name|device_get_flags
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|printf
argument_list|(
literal|" at device %d.%d"
argument_list|,
name|pci_get_slot
argument_list|(
name|child
argument_list|)
argument_list|,
name|pci_get_function
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|bus_print_child_footer
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_struct
specifier|static
struct|struct
block|{
name|int
name|class
decl_stmt|;
name|int
name|subclass
decl_stmt|;
name|char
modifier|*
name|desc
decl_stmt|;
block|}
name|pci_nomatch_tab
index|[]
init|=
block|{
block|{
name|PCIC_OLD
block|,
operator|-
literal|1
block|,
literal|"old"
block|}
block|,
block|{
name|PCIC_OLD
block|,
name|PCIS_OLD_NONVGA
block|,
literal|"non-VGA display device"
block|}
block|,
block|{
name|PCIC_OLD
block|,
name|PCIS_OLD_VGA
block|,
literal|"VGA-compatible display device"
block|}
block|,
block|{
name|PCIC_STORAGE
block|,
operator|-
literal|1
block|,
literal|"mass storage"
block|}
block|,
block|{
name|PCIC_STORAGE
block|,
name|PCIS_STORAGE_SCSI
block|,
literal|"SCSI"
block|}
block|,
block|{
name|PCIC_STORAGE
block|,
name|PCIS_STORAGE_IDE
block|,
literal|"ATA"
block|}
block|,
block|{
name|PCIC_STORAGE
block|,
name|PCIS_STORAGE_FLOPPY
block|,
literal|"floppy disk"
block|}
block|,
block|{
name|PCIC_STORAGE
block|,
name|PCIS_STORAGE_IPI
block|,
literal|"IPI"
block|}
block|,
block|{
name|PCIC_STORAGE
block|,
name|PCIS_STORAGE_RAID
block|,
literal|"RAID"
block|}
block|,
block|{
name|PCIC_NETWORK
block|,
operator|-
literal|1
block|,
literal|"network"
block|}
block|,
block|{
name|PCIC_NETWORK
block|,
name|PCIS_NETWORK_ETHERNET
block|,
literal|"ethernet"
block|}
block|,
block|{
name|PCIC_NETWORK
block|,
name|PCIS_NETWORK_TOKENRING
block|,
literal|"token ring"
block|}
block|,
block|{
name|PCIC_NETWORK
block|,
name|PCIS_NETWORK_FDDI
block|,
literal|"fddi"
block|}
block|,
block|{
name|PCIC_NETWORK
block|,
name|PCIS_NETWORK_ATM
block|,
literal|"ATM"
block|}
block|,
block|{
name|PCIC_DISPLAY
block|,
operator|-
literal|1
block|,
literal|"display"
block|}
block|,
block|{
name|PCIC_DISPLAY
block|,
name|PCIS_DISPLAY_VGA
block|,
literal|"VGA"
block|}
block|,
block|{
name|PCIC_DISPLAY
block|,
name|PCIS_DISPLAY_XGA
block|,
literal|"XGA"
block|}
block|,
block|{
name|PCIC_MULTIMEDIA
block|,
operator|-
literal|1
block|,
literal|"multimedia"
block|}
block|,
block|{
name|PCIC_MULTIMEDIA
block|,
name|PCIS_MULTIMEDIA_VIDEO
block|,
literal|"video"
block|}
block|,
block|{
name|PCIC_MULTIMEDIA
block|,
name|PCIS_MULTIMEDIA_AUDIO
block|,
literal|"audio"
block|}
block|,
block|{
name|PCIC_MEMORY
block|,
operator|-
literal|1
block|,
literal|"memory"
block|}
block|,
block|{
name|PCIC_MEMORY
block|,
name|PCIS_MEMORY_RAM
block|,
literal|"RAM"
block|}
block|,
block|{
name|PCIC_MEMORY
block|,
name|PCIS_MEMORY_FLASH
block|,
literal|"flash"
block|}
block|,
block|{
name|PCIC_BRIDGE
block|,
operator|-
literal|1
block|,
literal|"bridge"
block|}
block|,
block|{
name|PCIC_BRIDGE
block|,
name|PCIS_BRIDGE_HOST
block|,
literal|"HOST-PCI"
block|}
block|,
block|{
name|PCIC_BRIDGE
block|,
name|PCIS_BRIDGE_ISA
block|,
literal|"PCI-ISA"
block|}
block|,
block|{
name|PCIC_BRIDGE
block|,
name|PCIS_BRIDGE_EISA
block|,
literal|"PCI-EISA"
block|}
block|,
block|{
name|PCIC_BRIDGE
block|,
name|PCIS_BRIDGE_MCA
block|,
literal|"PCI-MCA"
block|}
block|,
block|{
name|PCIC_BRIDGE
block|,
name|PCIS_BRIDGE_PCI
block|,
literal|"PCI-PCI"
block|}
block|,
block|{
name|PCIC_BRIDGE
block|,
name|PCIS_BRIDGE_PCMCIA
block|,
literal|"PCI-PCMCIA"
block|}
block|,
block|{
name|PCIC_BRIDGE
block|,
name|PCIS_BRIDGE_NUBUS
block|,
literal|"PCI-NuBus"
block|}
block|,
block|{
name|PCIC_BRIDGE
block|,
name|PCIS_BRIDGE_CARDBUS
block|,
literal|"PCI-CardBus"
block|}
block|,
block|{
name|PCIC_BRIDGE
block|,
name|PCIS_BRIDGE_OTHER
block|,
literal|"PCI-unknown"
block|}
block|,
block|{
name|PCIC_SIMPLECOMM
block|,
operator|-
literal|1
block|,
literal|"simple comms"
block|}
block|,
block|{
name|PCIC_SIMPLECOMM
block|,
name|PCIS_SIMPLECOMM_UART
block|,
literal|"UART"
block|}
block|,
comment|/* could detect 16550 */
block|{
name|PCIC_SIMPLECOMM
block|,
name|PCIS_SIMPLECOMM_PAR
block|,
literal|"parallel port"
block|}
block|,
block|{
name|PCIC_BASEPERIPH
block|,
operator|-
literal|1
block|,
literal|"base peripheral"
block|}
block|,
block|{
name|PCIC_BASEPERIPH
block|,
name|PCIS_BASEPERIPH_PIC
block|,
literal|"interrupt controller"
block|}
block|,
block|{
name|PCIC_BASEPERIPH
block|,
name|PCIS_BASEPERIPH_DMA
block|,
literal|"DMA controller"
block|}
block|,
block|{
name|PCIC_BASEPERIPH
block|,
name|PCIS_BASEPERIPH_TIMER
block|,
literal|"timer"
block|}
block|,
block|{
name|PCIC_BASEPERIPH
block|,
name|PCIS_BASEPERIPH_RTC
block|,
literal|"realtime clock"
block|}
block|,
block|{
name|PCIC_INPUTDEV
block|,
operator|-
literal|1
block|,
literal|"input device"
block|}
block|,
block|{
name|PCIC_INPUTDEV
block|,
name|PCIS_INPUTDEV_KEYBOARD
block|,
literal|"keyboard"
block|}
block|,
block|{
name|PCIC_INPUTDEV
block|,
name|PCIS_INPUTDEV_DIGITIZER
block|,
literal|"digitizer"
block|}
block|,
block|{
name|PCIC_INPUTDEV
block|,
name|PCIS_INPUTDEV_MOUSE
block|,
literal|"mouse"
block|}
block|,
block|{
name|PCIC_DOCKING
block|,
operator|-
literal|1
block|,
literal|"docking station"
block|}
block|,
block|{
name|PCIC_PROCESSOR
block|,
operator|-
literal|1
block|,
literal|"processor"
block|}
block|,
block|{
name|PCIC_SERIALBUS
block|,
operator|-
literal|1
block|,
literal|"serial bus"
block|}
block|,
block|{
name|PCIC_SERIALBUS
block|,
name|PCIS_SERIALBUS_FW
block|,
literal|"FireWire"
block|}
block|,
block|{
name|PCIC_SERIALBUS
block|,
name|PCIS_SERIALBUS_ACCESS
block|,
literal|"AccessBus"
block|}
block|,
block|{
name|PCIC_SERIALBUS
block|,
name|PCIS_SERIALBUS_SSA
block|,
literal|"SSA"
block|}
block|,
block|{
name|PCIC_SERIALBUS
block|,
name|PCIS_SERIALBUS_USB
block|,
literal|"USB"
block|}
block|,
block|{
name|PCIC_SERIALBUS
block|,
name|PCIS_SERIALBUS_FC
block|,
literal|"Fibre Channel"
block|}
block|,
block|{
name|PCIC_SERIALBUS
block|,
name|PCIS_SERIALBUS_SMBUS
block|,
literal|"SMBus"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_function
name|void
name|pci_probe_nomatch
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|scp
decl_stmt|,
modifier|*
name|device
decl_stmt|;
comment|/* 	 * Look for a listing for this device in a loaded device database. 	 */
if|if
condition|(
operator|(
name|device
operator|=
name|pci_describe_device
argument_list|(
name|child
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"<%s>"
argument_list|,
name|device
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|device
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Scan the class/subclass descriptions for a general 		 * description. 		 */
name|cp
operator|=
literal|"unknown"
expr_stmt|;
name|scp
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|pci_nomatch_tab
index|[
name|i
index|]
operator|.
name|desc
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pci_nomatch_tab
index|[
name|i
index|]
operator|.
name|class
operator|==
name|pci_get_class
argument_list|(
name|child
argument_list|)
condition|)
block|{
if|if
condition|(
name|pci_nomatch_tab
index|[
name|i
index|]
operator|.
name|subclass
operator|==
operator|-
literal|1
condition|)
block|{
name|cp
operator|=
name|pci_nomatch_tab
index|[
name|i
index|]
operator|.
name|desc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pci_nomatch_tab
index|[
name|i
index|]
operator|.
name|subclass
operator|==
name|pci_get_subclass
argument_list|(
name|child
argument_list|)
condition|)
block|{
name|scp
operator|=
name|pci_nomatch_tab
index|[
name|i
index|]
operator|.
name|desc
expr_stmt|;
block|}
block|}
block|}
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"<%s%s%s>"
argument_list|,
name|cp
condition|?
name|cp
else|:
literal|""
argument_list|,
operator|(
operator|(
name|cp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|scp
operator|!=
name|NULL
operator|)
operator|)
condition|?
literal|", "
else|:
literal|""
argument_list|,
name|scp
condition|?
name|scp
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" at device %d.%d (no driver attached)\n"
argument_list|,
name|pci_get_slot
argument_list|(
name|child
argument_list|)
argument_list|,
name|pci_get_function
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Parse the PCI device database, if loaded, and return a pointer to a   * description of the device.  *  * The database is flat text formatted as follows:  *  * Any line not in a valid format is ignored.  * Lines are terminated with newline '\n' characters.  *   * A VENDOR line consists of the 4 digit (hex) vendor code, a TAB, then  * the vendor name.  *   * A DEVICE line is entered immediately below the corresponding VENDOR ID.  * - devices cannot be listed without a corresponding VENDOR line.  * A DEVICE line consists of a TAB, the 4 digit (hex) device code,  * another TAB, then the device name.                                              */
end_comment

begin_comment
comment|/*  * Assuming (ptr) points to the beginning of a line in the database,  * return the vendor or device and description of the next entry.  * The value of (vendor) or (device) inappropriate for the entry type  * is set to -1.  Returns nonzero at the end of the database.  *  * Note that this is slightly unrobust in the face of corrupt data;  * we attempt to safeguard against this by spamming the end of the  * database with a newline when we initialise.  */
end_comment

begin_function
specifier|static
name|int
name|pci_describe_parse_line
parameter_list|(
name|char
modifier|*
modifier|*
name|ptr
parameter_list|,
name|int
modifier|*
name|vendor
parameter_list|,
name|int
modifier|*
name|device
parameter_list|,
name|char
modifier|*
modifier|*
name|desc
parameter_list|)
block|{
name|char
modifier|*
name|cp
init|=
operator|*
name|ptr
decl_stmt|;
name|int
name|left
decl_stmt|;
operator|*
name|device
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|vendor
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
operator|*
name|desc
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|left
operator|=
name|pci_vendordata_size
operator|-
operator|(
name|cp
operator|-
name|pci_vendordata
operator|)
expr_stmt|;
if|if
condition|(
name|left
operator|<=
literal|0
condition|)
block|{
operator|*
name|ptr
operator|=
name|cp
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* vendor entry? */
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'\t'
operator|&&
name|sscanf
argument_list|(
name|cp
argument_list|,
literal|"%x\t%80[^\n]"
argument_list|,
name|vendor
argument_list|,
operator|*
name|desc
argument_list|)
operator|==
literal|2
condition|)
break|break;
comment|/* device entry? */
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\t'
operator|&&
name|sscanf
argument_list|(
name|cp
argument_list|,
literal|"%x\t%80[^\n]"
argument_list|,
name|device
argument_list|,
operator|*
name|desc
argument_list|)
operator|==
literal|2
condition|)
break|break;
comment|/* skip to next line */
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\n'
operator|&&
name|left
operator|>
literal|0
condition|)
block|{
name|cp
operator|++
expr_stmt|;
name|left
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\n'
condition|)
block|{
name|cp
operator|++
expr_stmt|;
name|left
operator|--
expr_stmt|;
block|}
block|}
comment|/* skip to next line */
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\n'
operator|&&
name|left
operator|>
literal|0
condition|)
block|{
name|cp
operator|++
expr_stmt|;
name|left
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\n'
operator|&&
name|left
operator|>
literal|0
condition|)
name|cp
operator|++
expr_stmt|;
operator|*
name|ptr
operator|=
name|cp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|pci_describe_device
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|vendor
decl_stmt|,
name|device
decl_stmt|;
name|char
modifier|*
name|desc
decl_stmt|,
modifier|*
name|vp
decl_stmt|,
modifier|*
name|dp
decl_stmt|,
modifier|*
name|line
decl_stmt|;
name|desc
operator|=
name|vp
operator|=
name|dp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * If we have no vendor data, we can't do anything. 	 */
if|if
condition|(
name|pci_vendordata
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Scan the vendor data looking for this device 	 */
name|line
operator|=
name|pci_vendordata
expr_stmt|;
if|if
condition|(
operator|(
name|vp
operator|=
name|malloc
argument_list|(
literal|80
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|pci_describe_parse_line
argument_list|(
operator|&
name|line
argument_list|,
operator|&
name|vendor
argument_list|,
operator|&
name|device
argument_list|,
operator|&
name|vp
argument_list|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|vendor
operator|==
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|dp
operator|=
name|malloc
argument_list|(
literal|80
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|pci_describe_parse_line
argument_list|(
operator|&
name|line
argument_list|,
operator|&
name|vendor
argument_list|,
operator|&
name|device
argument_list|,
operator|&
name|dp
argument_list|)
condition|)
block|{
operator|*
name|dp
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|vendor
operator|!=
operator|-
literal|1
condition|)
block|{
operator|*
name|dp
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|device
operator|==
name|pci_get_device
argument_list|(
name|dev
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|dp
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|snprintf
argument_list|(
name|dp
argument_list|,
literal|80
argument_list|,
literal|"0x%x"
argument_list|,
name|pci_get_device
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|desc
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|vp
argument_list|)
operator|+
name|strlen
argument_list|(
name|dp
argument_list|)
operator|+
literal|3
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|sprintf
argument_list|(
name|desc
argument_list|,
literal|"%s, %s"
argument_list|,
name|vp
argument_list|,
name|dp
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|vp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|vp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|dp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|desc
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_read_ivar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|which
parameter_list|,
name|uintptr_t
modifier|*
name|result
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
decl_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|cfg
operator|=
operator|&
name|dinfo
operator|->
name|cfg
expr_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|PCI_IVAR_ETHADDR
case|:
comment|/* 		 * The generic accessor doesn't deal with failure, so 		 * we set the return value, then return an error. 		 */
operator|*
operator|(
operator|(
name|uint8_t
operator|*
operator|*
operator|)
name|result
operator|)
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
case|case
name|PCI_IVAR_SUBVENDOR
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|subvendor
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_SUBDEVICE
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|subdevice
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_VENDOR
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|vendor
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_DEVICE
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|device
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_DEVID
case|:
operator|*
name|result
operator|=
operator|(
name|cfg
operator|->
name|device
operator|<<
literal|16
operator|)
operator||
name|cfg
operator|->
name|vendor
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_CLASS
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|baseclass
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_SUBCLASS
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|subclass
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_PROGIF
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|progif
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_REVID
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|revid
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_INTPIN
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|intpin
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_IRQ
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|intline
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_BUS
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|bus
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_SLOT
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|slot
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_FUNCTION
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|func
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_write_ivar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|which
parameter_list|,
name|uintptr_t
name|value
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|PCI_IVAR_INTPIN
case|:
name|dinfo
operator|->
name|cfg
operator|.
name|intpin
operator|=
name|value
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|PCI_IVAR_ETHADDR
case|:
case|case
name|PCI_IVAR_SUBVENDOR
case|:
case|case
name|PCI_IVAR_SUBDEVICE
case|:
case|case
name|PCI_IVAR_VENDOR
case|:
case|case
name|PCI_IVAR_DEVICE
case|:
case|case
name|PCI_IVAR_DEVID
case|:
case|case
name|PCI_IVAR_CLASS
case|:
case|case
name|PCI_IVAR_SUBCLASS
case|:
case|case
name|PCI_IVAR_PROGIF
case|:
case|case
name|PCI_IVAR_REVID
case|:
case|case
name|PCI_IVAR_IRQ
case|:
case|case
name|PCI_IVAR_BUS
case|:
case|case
name|PCI_IVAR_SLOT
case|:
case|case
name|PCI_IVAR_FUNCTION
case|:
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* disallow for now */
default|default:
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
block|}
end_function

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_include
include|#
directive|include
file|<sys/cons.h>
end_include

begin_comment
comment|/*  * List resources based on pci map registers, used for within ddb  */
end_comment

begin_macro
name|DB_SHOW_COMMAND
argument_list|(
argument|pciregs
argument_list|,
argument|db_pci_dump
argument_list|)
end_macro

begin_block
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|struct
name|devlist
modifier|*
name|devlist_head
decl_stmt|;
name|struct
name|pci_conf
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|,
name|none_count
decl_stmt|,
name|quit
decl_stmt|;
name|none_count
operator|=
literal|0
expr_stmt|;
comment|/* get the head of the device queue */
name|devlist_head
operator|=
operator|&
name|pci_devq
expr_stmt|;
comment|/* 	 * Go through the list of devices and print out devices 	 */
name|db_setup_paging
argument_list|(
name|db_simple_pager
argument_list|,
operator|&
name|quit
argument_list|,
name|DB_LINES_PER_PAGE
argument_list|)
expr_stmt|;
for|for
control|(
name|error
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
operator|,
name|quit
operator|=
literal|0
operator|,
name|dinfo
operator|=
name|STAILQ_FIRST
argument_list|(
name|devlist_head
argument_list|)
init|;
operator|(
name|dinfo
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|error
operator|==
literal|0
operator|)
operator|&&
operator|(
name|i
operator|<
name|pci_numdevs
operator|)
operator|&&
operator|!
name|quit
condition|;
name|dinfo
operator|=
name|STAILQ_NEXT
argument_list|(
name|dinfo
argument_list|,
name|pci_links
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
comment|/* Populate pd_name and pd_unit */
name|name
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dinfo
operator|->
name|cfg
operator|.
name|dev
condition|)
name|name
operator|=
name|device_get_name
argument_list|(
name|dinfo
operator|->
name|cfg
operator|.
name|dev
argument_list|)
expr_stmt|;
name|p
operator|=
operator|&
name|dinfo
operator|->
name|conf
expr_stmt|;
name|db_printf
argument_list|(
literal|"%s%d@pci%d:%d:%d:\tclass=0x%06x card=0x%08x "
literal|"chip=0x%08x rev=0x%02x hdr=0x%02x\n"
argument_list|,
operator|(
name|name
operator|&&
operator|*
name|name
operator|)
condition|?
name|name
else|:
literal|"none"
argument_list|,
operator|(
name|name
operator|&&
operator|*
name|name
operator|)
condition|?
operator|(
name|int
operator|)
name|device_get_unit
argument_list|(
name|dinfo
operator|->
name|cfg
operator|.
name|dev
argument_list|)
else|:
name|none_count
operator|++
argument_list|,
name|p
operator|->
name|pc_sel
operator|.
name|pc_bus
argument_list|,
name|p
operator|->
name|pc_sel
operator|.
name|pc_dev
argument_list|,
name|p
operator|->
name|pc_sel
operator|.
name|pc_func
argument_list|,
operator|(
name|p
operator|->
name|pc_class
operator|<<
literal|16
operator|)
operator||
operator|(
name|p
operator|->
name|pc_subclass
operator|<<
literal|8
operator|)
operator||
name|p
operator|->
name|pc_progif
argument_list|,
operator|(
name|p
operator|->
name|pc_subdevice
operator|<<
literal|16
operator|)
operator||
name|p
operator|->
name|pc_subvendor
argument_list|,
operator|(
name|p
operator|->
name|pc_device
operator|<<
literal|16
operator|)
operator||
name|p
operator|->
name|pc_vendor
argument_list|,
name|p
operator|->
name|pc_revid
argument_list|,
name|p
operator|->
name|pc_hdr
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DDB */
end_comment

begin_function
name|struct
name|resource
modifier|*
name|pci_alloc_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|rid
parameter_list|,
name|u_long
name|start
parameter_list|,
name|u_long
name|end
parameter_list|,
name|u_long
name|count
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|struct
name|resource_list
modifier|*
name|rl
init|=
operator|&
name|dinfo
operator|->
name|resources
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
comment|/* 	 * Perform lazy resource allocation 	 * 	 * XXX add support here for SYS_RES_IOPORT and SYS_RES_MEMORY 	 */
if|if
condition|(
name|device_get_parent
argument_list|(
name|child
argument_list|)
operator|==
name|dev
condition|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SYS_RES_IRQ
case|:
comment|/* 			 * If the child device doesn't have an 			 * interrupt routed and is deserving of an 			 * interrupt, try to assign it one. 			 */
if|if
condition|(
operator|!
name|PCI_INTERRUPT_VALID
argument_list|(
name|cfg
operator|->
name|intline
argument_list|)
operator|&&
operator|(
name|cfg
operator|->
name|intpin
operator|!=
literal|0
operator|)
condition|)
block|{
name|cfg
operator|->
name|intline
operator|=
name|PCI_ASSIGN_INTERRUPT
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|PCI_INTERRUPT_VALID
argument_list|(
name|cfg
operator|->
name|intline
argument_list|)
condition|)
block|{
name|pci_write_config
argument_list|(
name|child
argument_list|,
name|PCIR_INTLINE
argument_list|,
name|cfg
operator|->
name|intline
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|resource_list_add
argument_list|(
name|rl
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|cfg
operator|->
name|intline
argument_list|,
name|cfg
operator|->
name|intline
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SYS_RES_IOPORT
case|:
case|case
name|SYS_RES_MEMORY
case|:
if|if
condition|(
operator|*
name|rid
operator|<
name|PCIR_BAR
argument_list|(
name|cfg
operator|->
name|nummaps
argument_list|)
condition|)
block|{
comment|/* 				 * Enable the I/O mode.  We should 				 * also be allocating resources 				 * too. XXX 				 */
if|if
condition|(
name|PCI_ENABLE_IO
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
break|break;
block|}
block|}
return|return
operator|(
name|resource_list_alloc
argument_list|(
name|rl
argument_list|,
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pci_delete_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|struct
name|resource_list
modifier|*
name|rl
decl_stmt|;
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
if|if
condition|(
name|device_get_parent
argument_list|(
name|child
argument_list|)
operator|!=
name|dev
condition|)
return|return;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|rl
operator|=
operator|&
name|dinfo
operator|->
name|resources
expr_stmt|;
name|rle
operator|=
name|resource_list_find
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
name|rid
argument_list|)
expr_stmt|;
if|if
condition|(
name|rle
condition|)
block|{
if|if
condition|(
name|rle
operator|->
name|res
condition|)
block|{
if|if
condition|(
name|rman_get_device
argument_list|(
name|rle
operator|->
name|res
argument_list|)
operator|!=
name|dev
operator|||
name|rman_get_flags
argument_list|(
name|rle
operator|->
name|res
argument_list|)
operator|&
name|RF_ACTIVE
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"delete_resource: "
literal|"Resource still owned by child, oops. "
literal|"(type=%d, rid=%d, addr=%lx)\n"
argument_list|,
name|rle
operator|->
name|type
argument_list|,
name|rle
operator|->
name|rid
argument_list|,
name|rman_get_start
argument_list|(
name|rle
operator|->
name|res
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|rle
operator|->
name|res
argument_list|)
expr_stmt|;
block|}
name|resource_list_delete
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
name|rid
argument_list|)
expr_stmt|;
block|}
comment|/*  	 * Why do we turn off the PCI configuration BAR when we delete a 	 * resource? -- imp 	 */
name|pci_write_config
argument_list|(
name|child
argument_list|,
name|rid
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|BUS_DELETE_RESOURCE
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|resource_list
modifier|*
name|pci_get_resource_list
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|struct
name|resource_list
modifier|*
name|rl
init|=
operator|&
name|dinfo
operator|->
name|resources
decl_stmt|;
if|if
condition|(
operator|!
name|rl
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|rl
operator|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|pci_read_config_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|width
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
return|return
operator|(
name|PCIB_READ_CONFIG
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|cfg
operator|->
name|bus
argument_list|,
name|cfg
operator|->
name|slot
argument_list|,
name|cfg
operator|->
name|func
argument_list|,
name|reg
argument_list|,
name|width
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pci_write_config_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|reg
parameter_list|,
name|uint32_t
name|val
parameter_list|,
name|int
name|width
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
name|PCIB_WRITE_CONFIG
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|cfg
operator|->
name|bus
argument_list|,
name|cfg
operator|->
name|slot
argument_list|,
name|cfg
operator|->
name|func
argument_list|,
name|reg
argument_list|,
name|val
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pci_child_location_str_method
parameter_list|(
name|device_t
name|cbdev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
literal|"slot=%d function=%d"
argument_list|,
name|pci_get_slot
argument_list|(
name|child
argument_list|)
argument_list|,
name|pci_get_function
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_child_pnpinfo_str_method
parameter_list|(
name|device_t
name|cbdev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
decl_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|cfg
operator|=
operator|&
name|dinfo
operator|->
name|cfg
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
literal|"vendor=0x%04x device=0x%04x subvendor=0x%04x "
literal|"subdevice=0x%04x class=0x%02x%02x%02x"
argument_list|,
name|cfg
operator|->
name|vendor
argument_list|,
name|cfg
operator|->
name|device
argument_list|,
name|cfg
operator|->
name|subvendor
argument_list|,
name|cfg
operator|->
name|subdevice
argument_list|,
name|cfg
operator|->
name|baseclass
argument_list|,
name|cfg
operator|->
name|subclass
argument_list|,
name|cfg
operator|->
name|progif
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_assign_interrupt_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
return|return
operator|(
name|PCIB_ROUTE_INTERRUPT
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|cfg
operator|->
name|intpin
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pci_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|what
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
specifier|static
name|dev_t
name|pci_cdev
decl_stmt|;
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|STAILQ_INIT
argument_list|(
operator|&
name|pci_devq
argument_list|)
expr_stmt|;
name|pci_generation
operator|=
literal|0
expr_stmt|;
name|pci_cdev
operator|=
name|make_dev
argument_list|(
operator|&
name|pcicdev
argument_list|,
literal|0
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0644
argument_list|,
literal|"pci"
argument_list|)
expr_stmt|;
name|pci_load_vendor_data
argument_list|()
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|destroy_dev
argument_list|(
name|pci_cdev
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|numdevs
decl_stmt|;
name|int
name|i
decl_stmt|;
name|device_t
modifier|*
name|children
decl_stmt|;
name|device_t
name|child
decl_stmt|;
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
decl_stmt|;
name|device_get_children
argument_list|(
name|dev
argument_list|,
operator|&
name|children
argument_list|,
operator|&
name|numdevs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numdevs
condition|;
name|i
operator|++
control|)
block|{
name|child
operator|=
name|children
index|[
name|i
index|]
expr_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|cfg
operator|=
operator|&
name|dinfo
operator|->
name|cfg
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|intpin
operator|>
literal|0
operator|&&
name|PCI_INTERRUPT_VALID
argument_list|(
name|cfg
operator|->
name|intline
argument_list|)
condition|)
block|{
name|cfg
operator|->
name|intline
operator|=
name|PCI_ASSIGN_INTERRUPT
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|PCI_INTERRUPT_VALID
argument_list|(
name|cfg
operator|->
name|intline
argument_list|)
condition|)
block|{
name|pci_write_config
argument_list|(
name|child
argument_list|,
name|PCIR_INTLINE
argument_list|,
name|cfg
operator|->
name|intline
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|free
argument_list|(
name|children
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|bus_generic_resume
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

