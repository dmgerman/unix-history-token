begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1997, Stefan Esser<se@freebsd.org>  * Copyright (c) 2000, Michael Smith<msmith@freebsd.org>  * Copyright (c) 2000, BSDi  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_bus.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
operator|||
name|defined
argument_list|(
name|__powerpc__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<machine/intr_machdep.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/pciio.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pci_private.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/controller/ehcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/controller/ohcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/controller/uhcireg.h>
end_include

begin_include
include|#
directive|include
file|"pcib_if.h"
end_include

begin_include
include|#
directive|include
file|"pci_if.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__HAVE_ACPI
end_ifdef

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/acpi.h>
end_include

begin_include
include|#
directive|include
file|"acpi_if.h"
end_include

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ACPI_PWR_FOR_SLEEP
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * XXX: Due to a limitation of the bus_dma_tag_create() API, we cannot  * specify a 4GB boundary on 32-bit targets.  Usually this does not  * matter as it is ok to use a boundary of 0 on these systems.  * However, in the case of PAE, DMA addresses can cross a 4GB  * boundary, so as a workaround use a 2GB boundary.  */
end_comment

begin_if
if|#
directive|if
operator|(
name|BUS_SPACE_MAXADDR
operator|>
literal|0xFFFFFFFF
operator|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|PAE
end_ifdef

begin_define
define|#
directive|define
name|PCI_DMA_BOUNDARY
value|0x80000000
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PCI_DMA_BOUNDARY
value|0x100000000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PCIR_IS_BIOS
parameter_list|(
name|cfg
parameter_list|,
name|reg
parameter_list|)
define|\
value|(((cfg)->hdrtype == PCIM_HDRTYPE_NORMAL&& reg == PCIR_BIOS) ||	\ 	 ((cfg)->hdrtype == PCIM_HDRTYPE_BRIDGE&& reg == PCIR_BIOS_1))
end_define

begin_function_decl
specifier|static
name|pci_addr_t
name|pci_mapbase
parameter_list|(
name|uint64_t
name|mapreg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|pci_maptype
parameter_list|(
name|uint64_t
name|mapreg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_mapsize
parameter_list|(
name|uint64_t
name|testval
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_maprange
parameter_list|(
name|uint64_t
name|mapreg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|pci_addr_t
name|pci_rombase
parameter_list|(
name|uint64_t
name|mapreg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_romsize
parameter_list|(
name|uint64_t
name|testval
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pci_fixancient
parameter_list|(
name|pcicfgregs
modifier|*
name|cfg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_printf
parameter_list|(
name|pcicfgregs
modifier|*
name|cfg
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_porten
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_memen
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pci_assign_interrupt
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|int
name|force_route
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_add_map
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|int
name|reg
parameter_list|,
name|struct
name|resource_list
modifier|*
name|rl
parameter_list|,
name|int
name|force
parameter_list|,
name|int
name|prefetch
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pci_load_vendor_data
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_describe_parse_line
parameter_list|(
name|char
modifier|*
modifier|*
name|ptr
parameter_list|,
name|int
modifier|*
name|vendor
parameter_list|,
name|int
modifier|*
name|device
parameter_list|,
name|char
modifier|*
modifier|*
name|desc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|pci_describe_device
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bus_dma_tag_t
name|pci_get_dma_tag
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|what
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pci_hdrtypedata
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|s
parameter_list|,
name|int
name|f
parameter_list|,
name|pcicfgregs
modifier|*
name|cfg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pci_read_cap
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|pcicfgregs
modifier|*
name|cfg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_read_vpd_reg
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|pcicfgregs
modifier|*
name|cfg
parameter_list|,
name|int
name|reg
parameter_list|,
name|uint32_t
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int		pci_write_vpd_reg(device_t pcib, pcicfgregs *cfg, 			    int reg, uint32_t data);
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|pci_read_vpd
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|pcicfgregs
modifier|*
name|cfg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pci_disable_msi
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pci_enable_msi
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|uint64_t
name|address
parameter_list|,
name|uint16_t
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pci_enable_msix
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|index
parameter_list|,
name|uint64_t
name|address
parameter_list|,
name|uint32_t
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pci_mask_msix
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pci_unmask_msix
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_msi_blacklisted
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pci_resume_msi
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pci_resume_msix
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_remap_intr_method
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|u_int
name|irq
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|pci_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|pci_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|pci_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|bus_generic_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bus_generic_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|pci_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|pci_resume
argument_list|)
block|,
comment|/* Bus interface */
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|pci_print_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_probe_nomatch
argument_list|,
name|pci_probe_nomatch
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_read_ivar
argument_list|,
name|pci_read_ivar
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_write_ivar
argument_list|,
name|pci_write_ivar
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_driver_added
argument_list|,
name|pci_driver_added
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_setup_intr
argument_list|,
name|pci_setup_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_teardown_intr
argument_list|,
name|pci_teardown_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_get_dma_tag
argument_list|,
name|pci_get_dma_tag
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_get_resource_list
argument_list|,
name|pci_get_resource_list
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_set_resource
argument_list|,
name|bus_generic_rl_set_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_get_resource
argument_list|,
name|bus_generic_rl_get_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_delete_resource
argument_list|,
name|pci_delete_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_alloc_resource
argument_list|,
name|pci_alloc_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_adjust_resource
argument_list|,
name|bus_generic_adjust_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_release_resource
argument_list|,
name|bus_generic_rl_release_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_activate_resource
argument_list|,
name|pci_activate_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_deactivate_resource
argument_list|,
name|pci_deactivate_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_child_pnpinfo_str
argument_list|,
name|pci_child_pnpinfo_str_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_child_location_str
argument_list|,
name|pci_child_location_str_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_remap_intr
argument_list|,
name|pci_remap_intr_method
argument_list|)
block|,
comment|/* PCI interface */
name|DEVMETHOD
argument_list|(
name|pci_read_config
argument_list|,
name|pci_read_config_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_write_config
argument_list|,
name|pci_write_config_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_enable_busmaster
argument_list|,
name|pci_enable_busmaster_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_disable_busmaster
argument_list|,
name|pci_disable_busmaster_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_enable_io
argument_list|,
name|pci_enable_io_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_disable_io
argument_list|,
name|pci_disable_io_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_get_vpd_ident
argument_list|,
name|pci_get_vpd_ident_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_get_vpd_readonly
argument_list|,
name|pci_get_vpd_readonly_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_get_powerstate
argument_list|,
name|pci_get_powerstate_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_set_powerstate
argument_list|,
name|pci_set_powerstate_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_assign_interrupt
argument_list|,
name|pci_assign_interrupt_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_find_extcap
argument_list|,
name|pci_find_extcap_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_alloc_msi
argument_list|,
name|pci_alloc_msi_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_alloc_msix
argument_list|,
name|pci_alloc_msix_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_remap_msix
argument_list|,
name|pci_remap_msix_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_release_msi
argument_list|,
name|pci_release_msi_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_msi_count
argument_list|,
name|pci_msi_count_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_msix_count
argument_list|,
name|pci_msix_count_method
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DEFINE_CLASS_0
argument_list|(
name|pci
argument_list|,
name|pci_driver
argument_list|,
name|pci_methods
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pci_softc
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|pci_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|pci
argument_list|,
name|pcib
argument_list|,
name|pci_driver
argument_list|,
name|pci_devclass
argument_list|,
name|pci_modevent
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|pci
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pci_vendordata
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|pci_vendordata_size
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|pci_quirk
block|{
name|uint32_t
name|devid
decl_stmt|;
comment|/* Vendor/device of the card */
name|int
name|type
decl_stmt|;
define|#
directive|define
name|PCI_QUIRK_MAP_REG
value|1
comment|/* PCI map register in weird place */
define|#
directive|define
name|PCI_QUIRK_DISABLE_MSI
value|2
comment|/* MSI/MSI-X doesn't work */
define|#
directive|define
name|PCI_QUIRK_ENABLE_MSI_VM
value|3
comment|/* Older chipset in VM where MSI works */
define|#
directive|define
name|PCI_QUIRK_UNMAP_REG
value|4
comment|/* Ignore PCI map register */
name|int
name|arg1
decl_stmt|;
name|int
name|arg2
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|pci_quirk
name|pci_quirks
index|[]
init|=
block|{
comment|/* The Intel 82371AB and 82443MX has a map register at offset 0x90. */
block|{
literal|0x71138086
block|,
name|PCI_QUIRK_MAP_REG
block|,
literal|0x90
block|,
literal|0
block|}
block|,
block|{
literal|0x719b8086
block|,
name|PCI_QUIRK_MAP_REG
block|,
literal|0x90
block|,
literal|0
block|}
block|,
comment|/* As does the Serverworks OSB4 (the SMBus mapping register) */
block|{
literal|0x02001166
block|,
name|PCI_QUIRK_MAP_REG
block|,
literal|0x90
block|,
literal|0
block|}
block|,
comment|/* 	 * MSI doesn't work with the ServerWorks CNB20-HE Host Bridge 	 * or the CMIC-SL (AKA ServerWorks GC_LE). 	 */
block|{
literal|0x00141166
block|,
name|PCI_QUIRK_DISABLE_MSI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0x00171166
block|,
name|PCI_QUIRK_DISABLE_MSI
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* 	 * MSI doesn't work on earlier Intel chipsets including 	 * E7500, E7501, E7505, 845, 865, 875/E7210, and 855. 	 */
block|{
literal|0x25408086
block|,
name|PCI_QUIRK_DISABLE_MSI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0x254c8086
block|,
name|PCI_QUIRK_DISABLE_MSI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0x25508086
block|,
name|PCI_QUIRK_DISABLE_MSI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0x25608086
block|,
name|PCI_QUIRK_DISABLE_MSI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0x25708086
block|,
name|PCI_QUIRK_DISABLE_MSI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0x25788086
block|,
name|PCI_QUIRK_DISABLE_MSI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0x35808086
block|,
name|PCI_QUIRK_DISABLE_MSI
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* 	 * MSI doesn't work with devices behind the AMD 8131 HT-PCIX 	 * bridge. 	 */
block|{
literal|0x74501022
block|,
name|PCI_QUIRK_DISABLE_MSI
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* 	 * MSI-X doesn't work with at least LSI SAS1068E passed through by 	 * VMware. 	 */
block|{
literal|0x079015ad
block|,
name|PCI_QUIRK_DISABLE_MSI
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* 	 * Some virtualization environments emulate an older chipset 	 * but support MSI just fine.  QEMU uses the Intel 82440. 	 */
block|{
literal|0x12378086
block|,
name|PCI_QUIRK_ENABLE_MSI_VM
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* 	 * HPET MMIO base address may appear in Bar1 for AMD SB600 SMBus 	 * controller depending on SoftPciRst register (PM_IO 0x55 [7]). 	 * It prevents us from attaching hpet(4) when the bit is unset. 	 * Note this quirk only affects SB600 revision A13 and earlier. 	 * For SB600 A21 and later, firmware must set the bit to hide it. 	 * For SB700 and later, it is unused and hardcoded to zero. 	 */
block|{
literal|0x43851002
block|,
name|PCI_QUIRK_UNMAP_REG
block|,
literal|0x14
block|,
literal|0
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* map register information */
end_comment

begin_define
define|#
directive|define
name|PCI_MAPMEM
value|0x01
end_define

begin_comment
comment|/* memory map */
end_comment

begin_define
define|#
directive|define
name|PCI_MAPMEMP
value|0x02
end_define

begin_comment
comment|/* prefetchable memory map */
end_comment

begin_define
define|#
directive|define
name|PCI_MAPPORT
value|0x04
end_define

begin_comment
comment|/* port map */
end_comment

begin_decl_stmt
name|struct
name|devlist
name|pci_devq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|pci_generation
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|pci_numdevs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pcie_chipset
decl_stmt|,
name|pcix_chipset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sysctl vars */
end_comment

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|pci
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"PCI bus tuning parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|pci_enable_io_modes
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.pci.enable_io_modes"
argument_list|,
operator|&
name|pci_enable_io_modes
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_pci
argument_list|,
name|OID_AUTO
argument_list|,
name|enable_io_modes
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|pci_enable_io_modes
argument_list|,
literal|1
argument_list|,
literal|"Enable I/O and memory bits in the config register.  Some BIOSes do not\n\ enable these bits correctly.  We'd like to do this all the time, but there\n\ are some peripherals that this causes problems with."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|pci_do_power_nodriver
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.pci.do_power_nodriver"
argument_list|,
operator|&
name|pci_do_power_nodriver
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_pci
argument_list|,
name|OID_AUTO
argument_list|,
name|do_power_nodriver
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|pci_do_power_nodriver
argument_list|,
literal|0
argument_list|,
literal|"Place a function into D3 state when no driver attaches to it.  0 means\n\ disable.  1 means conservatively place devices into D3 state.  2 means\n\ agressively place devices into D3 state.  3 means put absolutely everything\n\ in D3 state."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|pci_do_power_resume
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.pci.do_power_resume"
argument_list|,
operator|&
name|pci_do_power_resume
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_pci
argument_list|,
name|OID_AUTO
argument_list|,
name|do_power_resume
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|pci_do_power_resume
argument_list|,
literal|1
argument_list|,
literal|"Transition from D3 -> D0 on resume."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|pci_do_msi
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.pci.enable_msi"
argument_list|,
operator|&
name|pci_do_msi
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_pci
argument_list|,
name|OID_AUTO
argument_list|,
name|enable_msi
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|pci_do_msi
argument_list|,
literal|1
argument_list|,
literal|"Enable support for MSI interrupts"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|pci_do_msix
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.pci.enable_msix"
argument_list|,
operator|&
name|pci_do_msix
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_pci
argument_list|,
name|OID_AUTO
argument_list|,
name|enable_msix
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|pci_do_msix
argument_list|,
literal|1
argument_list|,
literal|"Enable support for MSI-X interrupts"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|pci_honor_msi_blacklist
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.pci.honor_msi_blacklist"
argument_list|,
operator|&
name|pci_honor_msi_blacklist
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_pci
argument_list|,
name|OID_AUTO
argument_list|,
name|honor_msi_blacklist
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pci_honor_msi_blacklist
argument_list|,
literal|1
argument_list|,
literal|"Honor chipset blacklist for MSI"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|int
name|pci_usb_takeover
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|int
name|pci_usb_takeover
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.pci.usb_early_takeover"
argument_list|,
operator|&
name|pci_usb_takeover
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_pci
argument_list|,
name|OID_AUTO
argument_list|,
name|usb_early_takeover
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|pci_usb_takeover
argument_list|,
literal|1
argument_list|,
literal|"Enable early takeover of USB controllers.\n\ Disable this if you depend on BIOS emulation of USB devices, that is\n\ you use USB devices (like keyboard or mouse) but do not load USB drivers"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Find a device_t by bus/slot/function in domain 0 */
end_comment

begin_function
name|device_t
name|pci_find_bsf
parameter_list|(
name|uint8_t
name|bus
parameter_list|,
name|uint8_t
name|slot
parameter_list|,
name|uint8_t
name|func
parameter_list|)
block|{
return|return
operator|(
name|pci_find_dbsf
argument_list|(
literal|0
argument_list|,
name|bus
argument_list|,
name|slot
argument_list|,
name|func
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Find a device_t by domain/bus/slot/function */
end_comment

begin_function
name|device_t
name|pci_find_dbsf
parameter_list|(
name|uint32_t
name|domain
parameter_list|,
name|uint8_t
name|bus
parameter_list|,
name|uint8_t
name|slot
parameter_list|,
name|uint8_t
name|func
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|dinfo
argument_list|,
argument|&pci_devq
argument_list|,
argument|pci_links
argument_list|)
block|{
if|if
condition|(
operator|(
name|dinfo
operator|->
name|cfg
operator|.
name|domain
operator|==
name|domain
operator|)
operator|&&
operator|(
name|dinfo
operator|->
name|cfg
operator|.
name|bus
operator|==
name|bus
operator|)
operator|&&
operator|(
name|dinfo
operator|->
name|cfg
operator|.
name|slot
operator|==
name|slot
operator|)
operator|&&
operator|(
name|dinfo
operator|->
name|cfg
operator|.
name|func
operator|==
name|func
operator|)
condition|)
block|{
return|return
operator|(
name|dinfo
operator|->
name|cfg
operator|.
name|dev
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Find a device_t by vendor/device ID */
end_comment

begin_function
name|device_t
name|pci_find_device
parameter_list|(
name|uint16_t
name|vendor
parameter_list|,
name|uint16_t
name|device
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|dinfo
argument_list|,
argument|&pci_devq
argument_list|,
argument|pci_links
argument_list|)
block|{
if|if
condition|(
operator|(
name|dinfo
operator|->
name|cfg
operator|.
name|vendor
operator|==
name|vendor
operator|)
operator|&&
operator|(
name|dinfo
operator|->
name|cfg
operator|.
name|device
operator|==
name|device
operator|)
condition|)
block|{
return|return
operator|(
name|dinfo
operator|->
name|cfg
operator|.
name|dev
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|device_t
name|pci_find_class
parameter_list|(
name|uint8_t
name|class
parameter_list|,
name|uint8_t
name|subclass
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|dinfo
argument_list|,
argument|&pci_devq
argument_list|,
argument|pci_links
argument_list|)
block|{
if|if
condition|(
name|dinfo
operator|->
name|cfg
operator|.
name|baseclass
operator|==
name|class
operator|&&
name|dinfo
operator|->
name|cfg
operator|.
name|subclass
operator|==
name|subclass
condition|)
block|{
return|return
operator|(
name|dinfo
operator|->
name|cfg
operator|.
name|dev
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pci_printf
parameter_list|(
name|pcicfgregs
modifier|*
name|cfg
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|printf
argument_list|(
literal|"pci%d:%d:%d:%d: "
argument_list|,
name|cfg
operator|->
name|domain
argument_list|,
name|cfg
operator|->
name|bus
argument_list|,
name|cfg
operator|->
name|slot
argument_list|,
name|cfg
operator|->
name|func
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|vprintf
argument_list|(
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/* return base address of memory or port map */
end_comment

begin_function
specifier|static
name|pci_addr_t
name|pci_mapbase
parameter_list|(
name|uint64_t
name|mapreg
parameter_list|)
block|{
if|if
condition|(
name|PCI_BAR_MEM
argument_list|(
name|mapreg
argument_list|)
condition|)
return|return
operator|(
name|mapreg
operator|&
name|PCIM_BAR_MEM_BASE
operator|)
return|;
else|else
return|return
operator|(
name|mapreg
operator|&
name|PCIM_BAR_IO_BASE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* return map type of memory or port map */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|pci_maptype
parameter_list|(
name|uint64_t
name|mapreg
parameter_list|)
block|{
if|if
condition|(
name|PCI_BAR_IO
argument_list|(
name|mapreg
argument_list|)
condition|)
return|return
operator|(
literal|"I/O Port"
operator|)
return|;
if|if
condition|(
name|mapreg
operator|&
name|PCIM_BAR_MEM_PREFETCH
condition|)
return|return
operator|(
literal|"Prefetchable Memory"
operator|)
return|;
return|return
operator|(
literal|"Memory"
operator|)
return|;
block|}
end_function

begin_comment
comment|/* return log2 of map size decoded for memory or port map */
end_comment

begin_function
specifier|static
name|int
name|pci_mapsize
parameter_list|(
name|uint64_t
name|testval
parameter_list|)
block|{
name|int
name|ln2size
decl_stmt|;
name|testval
operator|=
name|pci_mapbase
argument_list|(
name|testval
argument_list|)
expr_stmt|;
name|ln2size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|testval
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
operator|(
name|testval
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|ln2size
operator|++
expr_stmt|;
name|testval
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ln2size
operator|)
return|;
block|}
end_function

begin_comment
comment|/* return base address of device ROM */
end_comment

begin_function
specifier|static
name|pci_addr_t
name|pci_rombase
parameter_list|(
name|uint64_t
name|mapreg
parameter_list|)
block|{
return|return
operator|(
name|mapreg
operator|&
name|PCIM_BIOS_ADDR_MASK
operator|)
return|;
block|}
end_function

begin_comment
comment|/* return log2 of map size decided for device ROM */
end_comment

begin_function
specifier|static
name|int
name|pci_romsize
parameter_list|(
name|uint64_t
name|testval
parameter_list|)
block|{
name|int
name|ln2size
decl_stmt|;
name|testval
operator|=
name|pci_rombase
argument_list|(
name|testval
argument_list|)
expr_stmt|;
name|ln2size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|testval
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
operator|(
name|testval
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|ln2size
operator|++
expr_stmt|;
name|testval
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ln2size
operator|)
return|;
block|}
end_function

begin_comment
comment|/* return log2 of address range supported by map register */
end_comment

begin_function
specifier|static
name|int
name|pci_maprange
parameter_list|(
name|uint64_t
name|mapreg
parameter_list|)
block|{
name|int
name|ln2range
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|PCI_BAR_IO
argument_list|(
name|mapreg
argument_list|)
condition|)
name|ln2range
operator|=
literal|32
expr_stmt|;
else|else
switch|switch
condition|(
name|mapreg
operator|&
name|PCIM_BAR_MEM_TYPE
condition|)
block|{
case|case
name|PCIM_BAR_MEM_32
case|:
name|ln2range
operator|=
literal|32
expr_stmt|;
break|break;
case|case
name|PCIM_BAR_MEM_1MB
case|:
name|ln2range
operator|=
literal|20
expr_stmt|;
break|break;
case|case
name|PCIM_BAR_MEM_64
case|:
name|ln2range
operator|=
literal|64
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|ln2range
operator|)
return|;
block|}
end_function

begin_comment
comment|/* adjust some values from PCI 1.0 devices to match 2.0 standards ... */
end_comment

begin_function
specifier|static
name|void
name|pci_fixancient
parameter_list|(
name|pcicfgregs
modifier|*
name|cfg
parameter_list|)
block|{
if|if
condition|(
name|cfg
operator|->
name|hdrtype
operator|!=
literal|0
condition|)
return|return;
comment|/* PCI to PCI bridges use header type 1 */
if|if
condition|(
name|cfg
operator|->
name|baseclass
operator|==
name|PCIC_BRIDGE
operator|&&
name|cfg
operator|->
name|subclass
operator|==
name|PCIS_BRIDGE_PCI
condition|)
name|cfg
operator|->
name|hdrtype
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* extract header type specific config data */
end_comment

begin_function
specifier|static
name|void
name|pci_hdrtypedata
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|s
parameter_list|,
name|int
name|f
parameter_list|,
name|pcicfgregs
modifier|*
name|cfg
parameter_list|)
block|{
define|#
directive|define
name|REG
parameter_list|(
name|n
parameter_list|,
name|w
parameter_list|)
value|PCIB_READ_CONFIG(pcib, b, s, f, n, w)
switch|switch
condition|(
name|cfg
operator|->
name|hdrtype
condition|)
block|{
case|case
literal|0
case|:
name|cfg
operator|->
name|subvendor
operator|=
name|REG
argument_list|(
name|PCIR_SUBVEND_0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|subdevice
operator|=
name|REG
argument_list|(
name|PCIR_SUBDEV_0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|nummaps
operator|=
name|PCI_MAXMAPS_0
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|cfg
operator|->
name|nummaps
operator|=
name|PCI_MAXMAPS_1
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|cfg
operator|->
name|subvendor
operator|=
name|REG
argument_list|(
name|PCIR_SUBVEND_2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|subdevice
operator|=
name|REG
argument_list|(
name|PCIR_SUBDEV_2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|nummaps
operator|=
name|PCI_MAXMAPS_2
expr_stmt|;
break|break;
block|}
undef|#
directive|undef
name|REG
block|}
end_function

begin_comment
comment|/* read configuration header into pcicfgregs structure */
end_comment

begin_function
name|struct
name|pci_devinfo
modifier|*
name|pci_read_device
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|int
name|d
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|s
parameter_list|,
name|int
name|f
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
define|#
directive|define
name|REG
parameter_list|(
name|n
parameter_list|,
name|w
parameter_list|)
value|PCIB_READ_CONFIG(pcib, b, s, f, n, w)
name|pcicfgregs
modifier|*
name|cfg
init|=
name|NULL
decl_stmt|;
name|struct
name|pci_devinfo
modifier|*
name|devlist_entry
decl_stmt|;
name|struct
name|devlist
modifier|*
name|devlist_head
decl_stmt|;
name|devlist_head
operator|=
operator|&
name|pci_devq
expr_stmt|;
name|devlist_entry
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|REG
argument_list|(
name|PCIR_DEVVENDOR
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0xfffffffful
condition|)
block|{
name|devlist_entry
operator|=
name|malloc
argument_list|(
name|size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|devlist_entry
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|cfg
operator|=
operator|&
name|devlist_entry
operator|->
name|cfg
expr_stmt|;
name|cfg
operator|->
name|domain
operator|=
name|d
expr_stmt|;
name|cfg
operator|->
name|bus
operator|=
name|b
expr_stmt|;
name|cfg
operator|->
name|slot
operator|=
name|s
expr_stmt|;
name|cfg
operator|->
name|func
operator|=
name|f
expr_stmt|;
name|cfg
operator|->
name|vendor
operator|=
name|REG
argument_list|(
name|PCIR_VENDOR
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|device
operator|=
name|REG
argument_list|(
name|PCIR_DEVICE
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|cmdreg
operator|=
name|REG
argument_list|(
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|statreg
operator|=
name|REG
argument_list|(
name|PCIR_STATUS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|baseclass
operator|=
name|REG
argument_list|(
name|PCIR_CLASS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|subclass
operator|=
name|REG
argument_list|(
name|PCIR_SUBCLASS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|progif
operator|=
name|REG
argument_list|(
name|PCIR_PROGIF
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|revid
operator|=
name|REG
argument_list|(
name|PCIR_REVID
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|hdrtype
operator|=
name|REG
argument_list|(
name|PCIR_HDRTYPE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|cachelnsz
operator|=
name|REG
argument_list|(
name|PCIR_CACHELNSZ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|lattimer
operator|=
name|REG
argument_list|(
name|PCIR_LATTIMER
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|intpin
operator|=
name|REG
argument_list|(
name|PCIR_INTPIN
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|intline
operator|=
name|REG
argument_list|(
name|PCIR_INTLINE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|mingnt
operator|=
name|REG
argument_list|(
name|PCIR_MINGNT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|maxlat
operator|=
name|REG
argument_list|(
name|PCIR_MAXLAT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|mfdev
operator|=
operator|(
name|cfg
operator|->
name|hdrtype
operator|&
name|PCIM_MFDEV
operator|)
operator|!=
literal|0
expr_stmt|;
name|cfg
operator|->
name|hdrtype
operator|&=
operator|~
name|PCIM_MFDEV
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|cfg
operator|->
name|maps
argument_list|)
expr_stmt|;
name|pci_fixancient
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
name|pci_hdrtypedata
argument_list|(
name|pcib
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|cfg
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG
argument_list|(
name|PCIR_STATUS
argument_list|,
literal|2
argument_list|)
operator|&
name|PCIM_STATUS_CAPPRESENT
condition|)
name|pci_read_cap
argument_list|(
name|pcib
argument_list|,
name|cfg
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
name|devlist_head
argument_list|,
name|devlist_entry
argument_list|,
name|pci_links
argument_list|)
expr_stmt|;
name|devlist_entry
operator|->
name|conf
operator|.
name|pc_sel
operator|.
name|pc_domain
operator|=
name|cfg
operator|->
name|domain
expr_stmt|;
name|devlist_entry
operator|->
name|conf
operator|.
name|pc_sel
operator|.
name|pc_bus
operator|=
name|cfg
operator|->
name|bus
expr_stmt|;
name|devlist_entry
operator|->
name|conf
operator|.
name|pc_sel
operator|.
name|pc_dev
operator|=
name|cfg
operator|->
name|slot
expr_stmt|;
name|devlist_entry
operator|->
name|conf
operator|.
name|pc_sel
operator|.
name|pc_func
operator|=
name|cfg
operator|->
name|func
expr_stmt|;
name|devlist_entry
operator|->
name|conf
operator|.
name|pc_hdr
operator|=
name|cfg
operator|->
name|hdrtype
expr_stmt|;
name|devlist_entry
operator|->
name|conf
operator|.
name|pc_subvendor
operator|=
name|cfg
operator|->
name|subvendor
expr_stmt|;
name|devlist_entry
operator|->
name|conf
operator|.
name|pc_subdevice
operator|=
name|cfg
operator|->
name|subdevice
expr_stmt|;
name|devlist_entry
operator|->
name|conf
operator|.
name|pc_vendor
operator|=
name|cfg
operator|->
name|vendor
expr_stmt|;
name|devlist_entry
operator|->
name|conf
operator|.
name|pc_device
operator|=
name|cfg
operator|->
name|device
expr_stmt|;
name|devlist_entry
operator|->
name|conf
operator|.
name|pc_class
operator|=
name|cfg
operator|->
name|baseclass
expr_stmt|;
name|devlist_entry
operator|->
name|conf
operator|.
name|pc_subclass
operator|=
name|cfg
operator|->
name|subclass
expr_stmt|;
name|devlist_entry
operator|->
name|conf
operator|.
name|pc_progif
operator|=
name|cfg
operator|->
name|progif
expr_stmt|;
name|devlist_entry
operator|->
name|conf
operator|.
name|pc_revid
operator|=
name|cfg
operator|->
name|revid
expr_stmt|;
name|pci_numdevs
operator|++
expr_stmt|;
name|pci_generation
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|devlist_entry
operator|)
return|;
undef|#
directive|undef
name|REG
block|}
end_function

begin_function
specifier|static
name|void
name|pci_read_cap
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|pcicfgregs
modifier|*
name|cfg
parameter_list|)
block|{
define|#
directive|define
name|REG
parameter_list|(
name|n
parameter_list|,
name|w
parameter_list|)
value|PCIB_READ_CONFIG(pcib, cfg->bus, cfg->slot, cfg->func, n, w)
define|#
directive|define
name|WREG
parameter_list|(
name|n
parameter_list|,
name|v
parameter_list|,
name|w
parameter_list|)
value|PCIB_WRITE_CONFIG(pcib, cfg->bus, cfg->slot, cfg->func, n, v, w)
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
operator|||
name|defined
argument_list|(
name|__powerpc__
argument_list|)
name|uint64_t
name|addr
decl_stmt|;
endif|#
directive|endif
name|uint32_t
name|val
decl_stmt|;
name|int
name|ptr
decl_stmt|,
name|nextptr
decl_stmt|,
name|ptrptr
decl_stmt|;
switch|switch
condition|(
name|cfg
operator|->
name|hdrtype
operator|&
name|PCIM_HDRTYPE
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
name|ptrptr
operator|=
name|PCIR_CAP_PTR
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|ptrptr
operator|=
name|PCIR_CAP_PTR_2
expr_stmt|;
comment|/* cardbus capabilities ptr */
break|break;
default|default:
return|return;
comment|/* no extended capabilities support */
block|}
name|nextptr
operator|=
name|REG
argument_list|(
name|ptrptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* sanity check? */
comment|/* 	 * Read capability entries. 	 */
while|while
condition|(
name|nextptr
operator|!=
literal|0
condition|)
block|{
comment|/* Sanity check */
if|if
condition|(
name|nextptr
operator|>
literal|255
condition|)
block|{
name|printf
argument_list|(
literal|"illegal PCI extended capability offset %d\n"
argument_list|,
name|nextptr
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Find the next entry */
name|ptr
operator|=
name|nextptr
expr_stmt|;
name|nextptr
operator|=
name|REG
argument_list|(
name|ptr
operator|+
name|PCICAP_NEXTPTR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Process this entry */
switch|switch
condition|(
name|REG
argument_list|(
name|ptr
operator|+
name|PCICAP_ID
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
name|PCIY_PMG
case|:
comment|/* PCI power management */
if|if
condition|(
name|cfg
operator|->
name|pp
operator|.
name|pp_cap
operator|==
literal|0
condition|)
block|{
name|cfg
operator|->
name|pp
operator|.
name|pp_cap
operator|=
name|REG
argument_list|(
name|ptr
operator|+
name|PCIR_POWER_CAP
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|pp
operator|.
name|pp_status
operator|=
name|ptr
operator|+
name|PCIR_POWER_STATUS
expr_stmt|;
name|cfg
operator|->
name|pp
operator|.
name|pp_pmcsr
operator|=
name|ptr
operator|+
name|PCIR_POWER_PMCSR
expr_stmt|;
if|if
condition|(
operator|(
name|nextptr
operator|-
name|ptr
operator|)
operator|>
name|PCIR_POWER_DATA
condition|)
name|cfg
operator|->
name|pp
operator|.
name|pp_data
operator|=
name|ptr
operator|+
name|PCIR_POWER_DATA
expr_stmt|;
block|}
break|break;
case|case
name|PCIY_HT
case|:
comment|/* HyperTransport */
comment|/* Determine HT-specific capability type. */
name|val
operator|=
name|REG
argument_list|(
name|ptr
operator|+
name|PCIR_HT_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
literal|0xe000
operator|)
operator|==
name|PCIM_HTCAP_SLAVE
condition|)
name|cfg
operator|->
name|ht
operator|.
name|ht_slave
operator|=
name|ptr
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
operator|||
name|defined
argument_list|(
name|__powerpc__
argument_list|)
switch|switch
condition|(
name|val
operator|&
name|PCIM_HTCMD_CAP_MASK
condition|)
block|{
case|case
name|PCIM_HTCAP_MSI_MAPPING
case|:
if|if
condition|(
operator|!
operator|(
name|val
operator|&
name|PCIM_HTCMD_MSI_FIXED
operator|)
condition|)
block|{
comment|/* Sanity check the mapping window. */
name|addr
operator|=
name|REG
argument_list|(
name|ptr
operator|+
name|PCIR_HTMSI_ADDRESS_HI
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|addr
operator|<<=
literal|32
expr_stmt|;
name|addr
operator||=
name|REG
argument_list|(
name|ptr
operator|+
name|PCIR_HTMSI_ADDRESS_LO
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|!=
name|MSI_INTEL_ADDR_BASE
condition|)
name|device_printf
argument_list|(
name|pcib
argument_list|,
literal|"HT device at pci%d:%d:%d:%d has non-default MSI window 0x%llx\n"
argument_list|,
name|cfg
operator|->
name|domain
argument_list|,
name|cfg
operator|->
name|bus
argument_list|,
name|cfg
operator|->
name|slot
argument_list|,
name|cfg
operator|->
name|func
argument_list|,
operator|(
name|long
name|long
operator|)
name|addr
argument_list|)
expr_stmt|;
block|}
else|else
name|addr
operator|=
name|MSI_INTEL_ADDR_BASE
expr_stmt|;
name|cfg
operator|->
name|ht
operator|.
name|ht_msimap
operator|=
name|ptr
expr_stmt|;
name|cfg
operator|->
name|ht
operator|.
name|ht_msictrl
operator|=
name|val
expr_stmt|;
name|cfg
operator|->
name|ht
operator|.
name|ht_msiaddr
operator|=
name|addr
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
break|break;
case|case
name|PCIY_MSI
case|:
comment|/* PCI MSI */
name|cfg
operator|->
name|msi
operator|.
name|msi_location
operator|=
name|ptr
expr_stmt|;
name|cfg
operator|->
name|msi
operator|.
name|msi_ctrl
operator|=
name|REG
argument_list|(
name|ptr
operator|+
name|PCIR_MSI_CTRL
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|msi
operator|.
name|msi_msgnum
operator|=
literal|1
operator|<<
operator|(
operator|(
name|cfg
operator|->
name|msi
operator|.
name|msi_ctrl
operator|&
name|PCIM_MSICTRL_MMC_MASK
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
break|break;
case|case
name|PCIY_MSIX
case|:
comment|/* PCI MSI-X */
name|cfg
operator|->
name|msix
operator|.
name|msix_location
operator|=
name|ptr
expr_stmt|;
name|cfg
operator|->
name|msix
operator|.
name|msix_ctrl
operator|=
name|REG
argument_list|(
name|ptr
operator|+
name|PCIR_MSIX_CTRL
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|msix
operator|.
name|msix_msgnum
operator|=
operator|(
name|cfg
operator|->
name|msix
operator|.
name|msix_ctrl
operator|&
name|PCIM_MSIXCTRL_TABLE_SIZE
operator|)
operator|+
literal|1
expr_stmt|;
name|val
operator|=
name|REG
argument_list|(
name|ptr
operator|+
name|PCIR_MSIX_TABLE
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|msix
operator|.
name|msix_table_bar
operator|=
name|PCIR_BAR
argument_list|(
name|val
operator|&
name|PCIM_MSIX_BIR_MASK
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|msix
operator|.
name|msix_table_offset
operator|=
name|val
operator|&
operator|~
name|PCIM_MSIX_BIR_MASK
expr_stmt|;
name|val
operator|=
name|REG
argument_list|(
name|ptr
operator|+
name|PCIR_MSIX_PBA
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|msix
operator|.
name|msix_pba_bar
operator|=
name|PCIR_BAR
argument_list|(
name|val
operator|&
name|PCIM_MSIX_BIR_MASK
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|msix
operator|.
name|msix_pba_offset
operator|=
name|val
operator|&
operator|~
name|PCIM_MSIX_BIR_MASK
expr_stmt|;
break|break;
case|case
name|PCIY_VPD
case|:
comment|/* PCI Vital Product Data */
name|cfg
operator|->
name|vpd
operator|.
name|vpd_reg
operator|=
name|ptr
expr_stmt|;
break|break;
case|case
name|PCIY_SUBVENDOR
case|:
comment|/* Should always be true. */
if|if
condition|(
operator|(
name|cfg
operator|->
name|hdrtype
operator|&
name|PCIM_HDRTYPE
operator|)
operator|==
literal|1
condition|)
block|{
name|val
operator|=
name|REG
argument_list|(
name|ptr
operator|+
name|PCIR_SUBVENDCAP_ID
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|subvendor
operator|=
name|val
operator|&
literal|0xffff
expr_stmt|;
name|cfg
operator|->
name|subdevice
operator|=
name|val
operator|>>
literal|16
expr_stmt|;
block|}
break|break;
case|case
name|PCIY_PCIX
case|:
comment|/* PCI-X */
comment|/* 			 * Assume we have a PCI-X chipset if we have 			 * at least one PCI-PCI bridge with a PCI-X 			 * capability.  Note that some systems with 			 * PCI-express or HT chipsets might match on 			 * this check as well. 			 */
if|if
condition|(
operator|(
name|cfg
operator|->
name|hdrtype
operator|&
name|PCIM_HDRTYPE
operator|)
operator|==
literal|1
condition|)
name|pcix_chipset
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|PCIY_EXPRESS
case|:
comment|/* PCI-express */
comment|/* 			 * Assume we have a PCI-express chipset if we have 			 * at least one PCI-express device. 			 */
name|pcie_chipset
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|__powerpc__
argument_list|)
comment|/* 	 * Enable the MSI mapping window for all HyperTransport 	 * slaves.  PCI-PCI bridges have their windows enabled via 	 * PCIB_MAP_MSI(). 	 */
if|if
condition|(
name|cfg
operator|->
name|ht
operator|.
name|ht_slave
operator|!=
literal|0
operator|&&
name|cfg
operator|->
name|ht
operator|.
name|ht_msimap
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|cfg
operator|->
name|ht
operator|.
name|ht_msictrl
operator|&
name|PCIM_HTCMD_MSI_ENABLE
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|pcib
argument_list|,
literal|"Enabling MSI window for HyperTransport slave at pci%d:%d:%d:%d\n"
argument_list|,
name|cfg
operator|->
name|domain
argument_list|,
name|cfg
operator|->
name|bus
argument_list|,
name|cfg
operator|->
name|slot
argument_list|,
name|cfg
operator|->
name|func
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|ht
operator|.
name|ht_msictrl
operator||=
name|PCIM_HTCMD_MSI_ENABLE
expr_stmt|;
name|WREG
argument_list|(
name|cfg
operator|->
name|ht
operator|.
name|ht_msimap
operator|+
name|PCIR_HT_COMMAND
argument_list|,
name|cfg
operator|->
name|ht
operator|.
name|ht_msictrl
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* REG and WREG use carry through to next functions */
block|}
end_function

begin_comment
comment|/*  * PCI Vital Product Data  */
end_comment

begin_define
define|#
directive|define
name|PCI_VPD_TIMEOUT
value|1000000
end_define

begin_function
specifier|static
name|int
name|pci_read_vpd_reg
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|pcicfgregs
modifier|*
name|cfg
parameter_list|,
name|int
name|reg
parameter_list|,
name|uint32_t
modifier|*
name|data
parameter_list|)
block|{
name|int
name|count
init|=
name|PCI_VPD_TIMEOUT
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|reg
operator|&
literal|3
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"VPD register must by 4 byte aligned"
operator|)
argument_list|)
expr_stmt|;
name|WREG
argument_list|(
name|cfg
operator|->
name|vpd
operator|.
name|vpd_reg
operator|+
name|PCIR_VPD_ADDR
argument_list|,
name|reg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|REG
argument_list|(
name|cfg
operator|->
name|vpd
operator|.
name|vpd_reg
operator|+
name|PCIR_VPD_ADDR
argument_list|,
literal|2
argument_list|)
operator|&
literal|0x8000
operator|)
operator|!=
literal|0x8000
condition|)
block|{
if|if
condition|(
operator|--
name|count
operator|<
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* limit looping */
block|}
operator|*
name|data
operator|=
operator|(
name|REG
argument_list|(
name|cfg
operator|->
name|vpd
operator|.
name|vpd_reg
operator|+
name|PCIR_VPD_DATA
argument_list|,
literal|4
argument_list|)
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static int pci_write_vpd_reg(device_t pcib, pcicfgregs *cfg, int reg, uint32_t data) { 	int count = PCI_VPD_TIMEOUT;  	KASSERT((reg& 3) == 0, ("VPD register must by 4 byte aligned"));  	WREG(cfg->vpd.vpd_reg + PCIR_VPD_DATA, data, 4); 	WREG(cfg->vpd.vpd_reg + PCIR_VPD_ADDR, reg | 0x8000, 2); 	while ((REG(cfg->vpd.vpd_reg + PCIR_VPD_ADDR, 2)& 0x8000) == 0x8000) { 		if (--count< 0) 			return (ENXIO); 		DELAY(1);
comment|/* limit looping */
end_comment

begin_endif
unit|}  	return (0); }
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|PCI_VPD_TIMEOUT
end_undef

begin_struct
struct|struct
name|vpd_readstate
block|{
name|device_t
name|pcib
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|int
name|bytesinval
decl_stmt|;
name|int
name|off
decl_stmt|;
name|uint8_t
name|cksum
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|vpd_nextbyte
parameter_list|(
name|struct
name|vpd_readstate
modifier|*
name|vrs
parameter_list|,
name|uint8_t
modifier|*
name|data
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|;
name|uint8_t
name|byte
decl_stmt|;
if|if
condition|(
name|vrs
operator|->
name|bytesinval
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pci_read_vpd_reg
argument_list|(
name|vrs
operator|->
name|pcib
argument_list|,
name|vrs
operator|->
name|cfg
argument_list|,
name|vrs
operator|->
name|off
argument_list|,
operator|&
name|reg
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|vrs
operator|->
name|val
operator|=
name|le32toh
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|vrs
operator|->
name|off
operator|+=
literal|4
expr_stmt|;
name|byte
operator|=
name|vrs
operator|->
name|val
operator|&
literal|0xff
expr_stmt|;
name|vrs
operator|->
name|bytesinval
operator|=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|vrs
operator|->
name|val
operator|=
name|vrs
operator|->
name|val
operator|>>
literal|8
expr_stmt|;
name|byte
operator|=
name|vrs
operator|->
name|val
operator|&
literal|0xff
expr_stmt|;
name|vrs
operator|->
name|bytesinval
operator|--
expr_stmt|;
block|}
name|vrs
operator|->
name|cksum
operator|+=
name|byte
expr_stmt|;
operator|*
name|data
operator|=
name|byte
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pci_read_vpd
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|pcicfgregs
modifier|*
name|cfg
parameter_list|)
block|{
name|struct
name|vpd_readstate
name|vrs
decl_stmt|;
name|int
name|state
decl_stmt|;
name|int
name|name
decl_stmt|;
name|int
name|remain
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|alloc
decl_stmt|,
name|off
decl_stmt|;
comment|/* alloc/off for RO/W arrays */
name|int
name|cksumvalid
decl_stmt|;
name|int
name|dflen
decl_stmt|;
name|uint8_t
name|byte
decl_stmt|;
name|uint8_t
name|byte2
decl_stmt|;
comment|/* init vpd reader */
name|vrs
operator|.
name|bytesinval
operator|=
literal|0
expr_stmt|;
name|vrs
operator|.
name|off
operator|=
literal|0
expr_stmt|;
name|vrs
operator|.
name|pcib
operator|=
name|pcib
expr_stmt|;
name|vrs
operator|.
name|cfg
operator|=
name|cfg
expr_stmt|;
name|vrs
operator|.
name|cksum
operator|=
literal|0
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
name|name
operator|=
name|remain
operator|=
name|i
operator|=
literal|0
expr_stmt|;
comment|/* shut up stupid gcc */
name|alloc
operator|=
name|off
operator|=
literal|0
expr_stmt|;
comment|/* shut up stupid gcc */
name|dflen
operator|=
literal|0
expr_stmt|;
comment|/* shut up stupid gcc */
name|cksumvalid
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|state
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|vpd_nextbyte
argument_list|(
operator|&
name|vrs
argument_list|,
operator|&
name|byte
argument_list|)
condition|)
block|{
name|state
operator|=
operator|-
literal|2
expr_stmt|;
break|break;
block|}
if|#
directive|if
literal|0
block|printf("vpd: val: %#x, off: %d, bytesinval: %d, byte: %#hhx, " \ 		    "state: %d, remain: %d, name: %#x, i: %d\n", vrs.val, 		    vrs.off, vrs.bytesinval, byte, state, remain, name, i);
endif|#
directive|endif
switch|switch
condition|(
name|state
condition|)
block|{
case|case
literal|0
case|:
comment|/* item name */
if|if
condition|(
name|byte
operator|&
literal|0x80
condition|)
block|{
if|if
condition|(
name|vpd_nextbyte
argument_list|(
operator|&
name|vrs
argument_list|,
operator|&
name|byte2
argument_list|)
condition|)
block|{
name|state
operator|=
operator|-
literal|2
expr_stmt|;
break|break;
block|}
name|remain
operator|=
name|byte2
expr_stmt|;
if|if
condition|(
name|vpd_nextbyte
argument_list|(
operator|&
name|vrs
argument_list|,
operator|&
name|byte2
argument_list|)
condition|)
block|{
name|state
operator|=
operator|-
literal|2
expr_stmt|;
break|break;
block|}
name|remain
operator||=
name|byte2
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
name|remain
operator|>
operator|(
literal|0x7f
operator|*
literal|4
operator|-
name|vrs
operator|.
name|off
operator|)
condition|)
block|{
name|state
operator|=
operator|-
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"pci%d:%d:%d:%d: invalid VPD data, remain %#x\n"
argument_list|,
name|cfg
operator|->
name|domain
argument_list|,
name|cfg
operator|->
name|bus
argument_list|,
name|cfg
operator|->
name|slot
argument_list|,
name|cfg
operator|->
name|func
argument_list|,
name|remain
argument_list|)
expr_stmt|;
block|}
name|name
operator|=
name|byte
operator|&
literal|0x7f
expr_stmt|;
block|}
else|else
block|{
name|remain
operator|=
name|byte
operator|&
literal|0x7
expr_stmt|;
name|name
operator|=
operator|(
name|byte
operator|>>
literal|3
operator|)
operator|&
literal|0xf
expr_stmt|;
block|}
switch|switch
condition|(
name|name
condition|)
block|{
case|case
literal|0x2
case|:
comment|/* String */
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ident
operator|=
name|malloc
argument_list|(
name|remain
operator|+
literal|1
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|state
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|0xf
case|:
comment|/* End */
name|state
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|0x10
case|:
comment|/* VPD-R */
name|alloc
operator|=
literal|8
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
operator|=
name|malloc
argument_list|(
name|alloc
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|state
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|0x11
case|:
comment|/* VPD-W */
name|alloc
operator|=
literal|8
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
operator|=
name|malloc
argument_list|(
name|alloc
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|state
operator|=
literal|5
expr_stmt|;
break|break;
default|default:
comment|/* Invalid data, abort */
name|state
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|1
case|:
comment|/* Identifier String */
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ident
index|[
name|i
operator|++
index|]
operator|=
name|byte
expr_stmt|;
name|remain
operator|--
expr_stmt|;
if|if
condition|(
name|remain
operator|==
literal|0
condition|)
block|{
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ident
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
comment|/* VPD-R Keyword Header */
if|if
condition|(
name|off
operator|==
name|alloc
condition|)
block|{
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
operator|=
name|reallocf
argument_list|(
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
argument_list|,
operator|(
name|alloc
operator|*=
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
block|}
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
index|[
name|off
index|]
operator|.
name|keyword
index|[
literal|0
index|]
operator|=
name|byte
expr_stmt|;
if|if
condition|(
name|vpd_nextbyte
argument_list|(
operator|&
name|vrs
argument_list|,
operator|&
name|byte2
argument_list|)
condition|)
block|{
name|state
operator|=
operator|-
literal|2
expr_stmt|;
break|break;
block|}
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
index|[
name|off
index|]
operator|.
name|keyword
index|[
literal|1
index|]
operator|=
name|byte2
expr_stmt|;
if|if
condition|(
name|vpd_nextbyte
argument_list|(
operator|&
name|vrs
argument_list|,
operator|&
name|byte2
argument_list|)
condition|)
block|{
name|state
operator|=
operator|-
literal|2
expr_stmt|;
break|break;
block|}
name|dflen
operator|=
name|byte2
expr_stmt|;
if|if
condition|(
name|dflen
operator|==
literal|0
operator|&&
name|strncmp
argument_list|(
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
index|[
name|off
index|]
operator|.
name|keyword
argument_list|,
literal|"RV"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * if this happens, we can't trust the rest 				 * of the VPD. 				 */
name|printf
argument_list|(
literal|"pci%d:%d:%d:%d: bad keyword length: %d\n"
argument_list|,
name|cfg
operator|->
name|domain
argument_list|,
name|cfg
operator|->
name|bus
argument_list|,
name|cfg
operator|->
name|slot
argument_list|,
name|cfg
operator|->
name|func
argument_list|,
name|dflen
argument_list|)
expr_stmt|;
name|cksumvalid
operator|=
literal|0
expr_stmt|;
name|state
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|dflen
operator|==
literal|0
condition|)
block|{
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
index|[
name|off
index|]
operator|.
name|value
operator|=
name|malloc
argument_list|(
literal|1
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
index|[
name|off
index|]
operator|.
name|value
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
index|[
name|off
index|]
operator|.
name|value
index|[
literal|0
index|]
operator|=
literal|'\x00'
expr_stmt|;
block|}
else|else
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
index|[
name|off
index|]
operator|.
name|value
operator|=
name|malloc
argument_list|(
operator|(
name|dflen
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
index|[
name|off
index|]
operator|.
name|value
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|remain
operator|-=
literal|3
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
comment|/* keep in sync w/ state 3's transistions */
if|if
condition|(
name|dflen
operator|==
literal|0
operator|&&
name|remain
operator|==
literal|0
condition|)
name|state
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|dflen
operator|==
literal|0
condition|)
name|state
operator|=
literal|2
expr_stmt|;
else|else
name|state
operator|=
literal|3
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* VPD-R Keyword Value */
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
index|[
name|off
index|]
operator|.
name|value
index|[
name|i
operator|++
index|]
operator|=
name|byte
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
index|[
name|off
index|]
operator|.
name|keyword
argument_list|,
literal|"RV"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|&&
name|cksumvalid
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|vrs
operator|.
name|cksum
operator|==
literal|0
condition|)
name|cksumvalid
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"pci%d:%d:%d:%d: bad VPD cksum, remain %hhu\n"
argument_list|,
name|cfg
operator|->
name|domain
argument_list|,
name|cfg
operator|->
name|bus
argument_list|,
name|cfg
operator|->
name|slot
argument_list|,
name|cfg
operator|->
name|func
argument_list|,
name|vrs
operator|.
name|cksum
argument_list|)
expr_stmt|;
name|cksumvalid
operator|=
literal|0
expr_stmt|;
name|state
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|dflen
operator|--
expr_stmt|;
name|remain
operator|--
expr_stmt|;
comment|/* keep in sync w/ state 2's transistions */
if|if
condition|(
name|dflen
operator|==
literal|0
condition|)
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
index|[
name|off
operator|++
index|]
operator|.
name|value
index|[
name|i
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|dflen
operator|==
literal|0
operator|&&
name|remain
operator|==
literal|0
condition|)
block|{
name|cfg
operator|->
name|vpd
operator|.
name|vpd_rocnt
operator|=
name|off
expr_stmt|;
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
operator|=
name|reallocf
argument_list|(
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
argument_list|,
name|off
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dflen
operator|==
literal|0
condition|)
name|state
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|remain
operator|--
expr_stmt|;
if|if
condition|(
name|remain
operator|==
literal|0
condition|)
name|state
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* VPD-W Keyword Header */
if|if
condition|(
name|off
operator|==
name|alloc
condition|)
block|{
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
operator|=
name|reallocf
argument_list|(
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
argument_list|,
operator|(
name|alloc
operator|*=
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
block|}
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
index|[
name|off
index|]
operator|.
name|keyword
index|[
literal|0
index|]
operator|=
name|byte
expr_stmt|;
if|if
condition|(
name|vpd_nextbyte
argument_list|(
operator|&
name|vrs
argument_list|,
operator|&
name|byte2
argument_list|)
condition|)
block|{
name|state
operator|=
operator|-
literal|2
expr_stmt|;
break|break;
block|}
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
index|[
name|off
index|]
operator|.
name|keyword
index|[
literal|1
index|]
operator|=
name|byte2
expr_stmt|;
if|if
condition|(
name|vpd_nextbyte
argument_list|(
operator|&
name|vrs
argument_list|,
operator|&
name|byte2
argument_list|)
condition|)
block|{
name|state
operator|=
operator|-
literal|2
expr_stmt|;
break|break;
block|}
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
index|[
name|off
index|]
operator|.
name|len
operator|=
name|dflen
operator|=
name|byte2
expr_stmt|;
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
index|[
name|off
index|]
operator|.
name|start
operator|=
name|vrs
operator|.
name|off
operator|-
name|vrs
operator|.
name|bytesinval
expr_stmt|;
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
index|[
name|off
index|]
operator|.
name|value
operator|=
name|malloc
argument_list|(
operator|(
name|dflen
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
index|[
name|off
index|]
operator|.
name|value
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|remain
operator|-=
literal|3
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
comment|/* keep in sync w/ state 6's transistions */
if|if
condition|(
name|dflen
operator|==
literal|0
operator|&&
name|remain
operator|==
literal|0
condition|)
name|state
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|dflen
operator|==
literal|0
condition|)
name|state
operator|=
literal|5
expr_stmt|;
else|else
name|state
operator|=
literal|6
expr_stmt|;
break|break;
case|case
literal|6
case|:
comment|/* VPD-W Keyword Value */
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
index|[
name|off
index|]
operator|.
name|value
index|[
name|i
operator|++
index|]
operator|=
name|byte
expr_stmt|;
name|dflen
operator|--
expr_stmt|;
name|remain
operator|--
expr_stmt|;
comment|/* keep in sync w/ state 5's transistions */
if|if
condition|(
name|dflen
operator|==
literal|0
condition|)
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
index|[
name|off
operator|++
index|]
operator|.
name|value
index|[
name|i
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|dflen
operator|==
literal|0
operator|&&
name|remain
operator|==
literal|0
condition|)
block|{
name|cfg
operator|->
name|vpd
operator|.
name|vpd_wcnt
operator|=
name|off
expr_stmt|;
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
operator|=
name|reallocf
argument_list|(
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
argument_list|,
name|off
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dflen
operator|==
literal|0
condition|)
name|state
operator|=
literal|5
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"pci%d:%d:%d:%d: invalid state: %d\n"
argument_list|,
name|cfg
operator|->
name|domain
argument_list|,
name|cfg
operator|->
name|bus
argument_list|,
name|cfg
operator|->
name|slot
argument_list|,
name|cfg
operator|->
name|func
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|state
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|cksumvalid
operator|==
literal|0
operator|||
name|state
operator|<
operator|-
literal|1
condition|)
block|{
comment|/* read-only data bad, clean up */
if|if
condition|(
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|off
operator|=
literal|0
init|;
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
index|[
name|off
index|]
operator|.
name|value
condition|;
name|off
operator|++
control|)
name|free
argument_list|(
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
index|[
name|off
index|]
operator|.
name|value
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|state
operator|<
operator|-
literal|1
condition|)
block|{
comment|/* I/O error, clean up */
name|printf
argument_list|(
literal|"pci%d:%d:%d:%d: failed to read VPD data.\n"
argument_list|,
name|cfg
operator|->
name|domain
argument_list|,
name|cfg
operator|->
name|bus
argument_list|,
name|cfg
operator|->
name|slot
argument_list|,
name|cfg
operator|->
name|func
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ident
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ident
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ident
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|off
operator|=
literal|0
init|;
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
index|[
name|off
index|]
operator|.
name|value
condition|;
name|off
operator|++
control|)
name|free
argument_list|(
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
index|[
name|off
index|]
operator|.
name|value
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|cfg
operator|->
name|vpd
operator|.
name|vpd_cached
operator|=
literal|1
expr_stmt|;
undef|#
directive|undef
name|REG
undef|#
directive|undef
name|WREG
block|}
end_function

begin_function
name|int
name|pci_get_vpd_ident_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|identptr
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
if|if
condition|(
operator|!
name|cfg
operator|->
name|vpd
operator|.
name|vpd_cached
operator|&&
name|cfg
operator|->
name|vpd
operator|.
name|vpd_reg
operator|!=
literal|0
condition|)
name|pci_read_vpd
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|cfg
argument_list|)
expr_stmt|;
operator|*
name|identptr
operator|=
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ident
expr_stmt|;
if|if
condition|(
operator|*
name|identptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_get_vpd_readonly_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
specifier|const
name|char
modifier|*
name|kw
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|vptr
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|cfg
operator|->
name|vpd
operator|.
name|vpd_cached
operator|&&
name|cfg
operator|->
name|vpd
operator|.
name|vpd_reg
operator|!=
literal|0
condition|)
name|pci_read_vpd
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|cfg
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cfg
operator|->
name|vpd
operator|.
name|vpd_rocnt
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|memcmp
argument_list|(
name|kw
argument_list|,
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
index|[
name|i
index|]
operator|.
name|keyword
argument_list|,
sizeof|sizeof
argument_list|(
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
index|[
name|i
index|]
operator|.
name|keyword
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|vptr
operator|=
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
index|[
name|i
index|]
operator|.
name|value
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|*
name|vptr
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find the requested extended capability and return the offset in  * configuration space via the pointer provided. The function returns  * 0 on success and error code otherwise.  */
end_comment

begin_function
name|int
name|pci_find_extcap_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|capability
parameter_list|,
name|int
modifier|*
name|capreg
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
name|u_int32_t
name|status
decl_stmt|;
name|u_int8_t
name|ptr
decl_stmt|;
comment|/* 	 * Check the CAP_LIST bit of the PCI status register first. 	 */
name|status
operator|=
name|pci_read_config
argument_list|(
name|child
argument_list|,
name|PCIR_STATUS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|status
operator|&
name|PCIM_STATUS_CAPPRESENT
operator|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* 	 * Determine the start pointer of the capabilities list. 	 */
switch|switch
condition|(
name|cfg
operator|->
name|hdrtype
operator|&
name|PCIM_HDRTYPE
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
name|ptr
operator|=
name|PCIR_CAP_PTR
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|ptr
operator|=
name|PCIR_CAP_PTR_2
expr_stmt|;
break|break;
default|default:
comment|/* XXX: panic? */
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* no extended capabilities support */
block|}
name|ptr
operator|=
name|pci_read_config
argument_list|(
name|child
argument_list|,
name|ptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Traverse the capabilities list. 	 */
while|while
condition|(
name|ptr
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|pci_read_config
argument_list|(
name|child
argument_list|,
name|ptr
operator|+
name|PCICAP_ID
argument_list|,
literal|1
argument_list|)
operator|==
name|capability
condition|)
block|{
if|if
condition|(
name|capreg
operator|!=
name|NULL
condition|)
operator|*
name|capreg
operator|=
name|ptr
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ptr
operator|=
name|pci_read_config
argument_list|(
name|child
argument_list|,
name|ptr
operator|+
name|PCICAP_NEXTPTR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Support for MSI-X message interrupts.  */
end_comment

begin_function
name|void
name|pci_enable_msix
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|index
parameter_list|,
name|uint64_t
name|address
parameter_list|,
name|uint32_t
name|data
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|pcicfg_msix
modifier|*
name|msix
init|=
operator|&
name|dinfo
operator|->
name|cfg
operator|.
name|msix
decl_stmt|;
name|uint32_t
name|offset
decl_stmt|;
name|KASSERT
argument_list|(
name|msix
operator|->
name|msix_table_len
operator|>
name|index
argument_list|,
operator|(
literal|"bogus index"
operator|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|msix
operator|->
name|msix_table_offset
operator|+
name|index
operator|*
literal|16
expr_stmt|;
name|bus_write_4
argument_list|(
name|msix
operator|->
name|msix_table_res
argument_list|,
name|offset
argument_list|,
name|address
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|bus_write_4
argument_list|(
name|msix
operator|->
name|msix_table_res
argument_list|,
name|offset
operator|+
literal|4
argument_list|,
name|address
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|bus_write_4
argument_list|(
name|msix
operator|->
name|msix_table_res
argument_list|,
name|offset
operator|+
literal|8
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* Enable MSI -> HT mapping. */
name|pci_ht_map_msi
argument_list|(
name|dev
argument_list|,
name|address
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pci_mask_msix
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|index
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|pcicfg_msix
modifier|*
name|msix
init|=
operator|&
name|dinfo
operator|->
name|cfg
operator|.
name|msix
decl_stmt|;
name|uint32_t
name|offset
decl_stmt|,
name|val
decl_stmt|;
name|KASSERT
argument_list|(
name|msix
operator|->
name|msix_msgnum
operator|>
name|index
argument_list|,
operator|(
literal|"bogus index"
operator|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|msix
operator|->
name|msix_table_offset
operator|+
name|index
operator|*
literal|16
operator|+
literal|12
expr_stmt|;
name|val
operator|=
name|bus_read_4
argument_list|(
name|msix
operator|->
name|msix_table_res
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|val
operator|&
name|PCIM_MSIX_VCTRL_MASK
operator|)
condition|)
block|{
name|val
operator||=
name|PCIM_MSIX_VCTRL_MASK
expr_stmt|;
name|bus_write_4
argument_list|(
name|msix
operator|->
name|msix_table_res
argument_list|,
name|offset
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|pci_unmask_msix
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|index
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|pcicfg_msix
modifier|*
name|msix
init|=
operator|&
name|dinfo
operator|->
name|cfg
operator|.
name|msix
decl_stmt|;
name|uint32_t
name|offset
decl_stmt|,
name|val
decl_stmt|;
name|KASSERT
argument_list|(
name|msix
operator|->
name|msix_table_len
operator|>
name|index
argument_list|,
operator|(
literal|"bogus index"
operator|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|msix
operator|->
name|msix_table_offset
operator|+
name|index
operator|*
literal|16
operator|+
literal|12
expr_stmt|;
name|val
operator|=
name|bus_read_4
argument_list|(
name|msix
operator|->
name|msix_table_res
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|PCIM_MSIX_VCTRL_MASK
condition|)
block|{
name|val
operator|&=
operator|~
name|PCIM_MSIX_VCTRL_MASK
expr_stmt|;
name|bus_write_4
argument_list|(
name|msix
operator|->
name|msix_table_res
argument_list|,
name|offset
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|pci_pending_msix
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|index
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|pcicfg_msix
modifier|*
name|msix
init|=
operator|&
name|dinfo
operator|->
name|cfg
operator|.
name|msix
decl_stmt|;
name|uint32_t
name|offset
decl_stmt|,
name|bit
decl_stmt|;
name|KASSERT
argument_list|(
name|msix
operator|->
name|msix_table_len
operator|>
name|index
argument_list|,
operator|(
literal|"bogus index"
operator|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|msix
operator|->
name|msix_pba_offset
operator|+
operator|(
name|index
operator|/
literal|32
operator|)
operator|*
literal|4
expr_stmt|;
name|bit
operator|=
literal|1
operator|<<
name|index
operator|%
literal|32
expr_stmt|;
return|return
operator|(
name|bus_read_4
argument_list|(
name|msix
operator|->
name|msix_pba_res
argument_list|,
name|offset
argument_list|)
operator|&
name|bit
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Restore MSI-X registers and table during resume.  If MSI-X is  * enabled then walk the virtual table to restore the actual MSI-X  * table.  */
end_comment

begin_function
specifier|static
name|void
name|pci_resume_msix
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|pcicfg_msix
modifier|*
name|msix
init|=
operator|&
name|dinfo
operator|->
name|cfg
operator|.
name|msix
decl_stmt|;
name|struct
name|msix_table_entry
modifier|*
name|mte
decl_stmt|;
name|struct
name|msix_vector
modifier|*
name|mv
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|msix
operator|->
name|msix_alloc
operator|>
literal|0
condition|)
block|{
comment|/* First, mask all vectors. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msix
operator|->
name|msix_msgnum
condition|;
name|i
operator|++
control|)
name|pci_mask_msix
argument_list|(
name|dev
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Second, program any messages with at least one handler. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msix
operator|->
name|msix_table_len
condition|;
name|i
operator|++
control|)
block|{
name|mte
operator|=
operator|&
name|msix
operator|->
name|msix_table
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|mte
operator|->
name|mte_vector
operator|==
literal|0
operator|||
name|mte
operator|->
name|mte_handlers
operator|==
literal|0
condition|)
continue|continue;
name|mv
operator|=
operator|&
name|msix
operator|->
name|msix_vectors
index|[
name|mte
operator|->
name|mte_vector
operator|-
literal|1
index|]
expr_stmt|;
name|pci_enable_msix
argument_list|(
name|dev
argument_list|,
name|i
argument_list|,
name|mv
operator|->
name|mv_address
argument_list|,
name|mv
operator|->
name|mv_data
argument_list|)
expr_stmt|;
name|pci_unmask_msix
argument_list|(
name|dev
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|msix
operator|->
name|msix_location
operator|+
name|PCIR_MSIX_CTRL
argument_list|,
name|msix
operator|->
name|msix_ctrl
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Attempt to allocate *count MSI-X messages.  The actual number allocated is  * returned in *count.  After this function returns, each message will be  * available to the driver as SYS_RES_IRQ resources starting at rid 1.  */
end_comment

begin_function
name|int
name|pci_alloc_msix_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
modifier|*
name|count
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
name|int
name|actual
decl_stmt|,
name|error
decl_stmt|,
name|i
decl_stmt|,
name|irq
decl_stmt|,
name|max
decl_stmt|;
comment|/* Don't let count == 0 get us into trouble. */
if|if
condition|(
operator|*
name|count
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* If rid 0 is allocated, then fail. */
name|rle
operator|=
name|resource_list_find
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rle
operator|!=
name|NULL
operator|&&
name|rle
operator|->
name|res
operator|!=
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Already have allocated messages? */
if|if
condition|(
name|cfg
operator|->
name|msi
operator|.
name|msi_alloc
operator|!=
literal|0
operator|||
name|cfg
operator|->
name|msix
operator|.
name|msix_alloc
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* If MSI is blacklisted for this system, fail. */
if|if
condition|(
name|pci_msi_blacklisted
argument_list|()
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* MSI-X capability present? */
if|if
condition|(
name|cfg
operator|->
name|msix
operator|.
name|msix_location
operator|==
literal|0
operator|||
operator|!
name|pci_do_msix
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
comment|/* Make sure the appropriate BARs are mapped. */
name|rle
operator|=
name|resource_list_find
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|cfg
operator|->
name|msix
operator|.
name|msix_table_bar
argument_list|)
expr_stmt|;
if|if
condition|(
name|rle
operator|==
name|NULL
operator|||
name|rle
operator|->
name|res
operator|==
name|NULL
operator|||
operator|!
operator|(
name|rman_get_flags
argument_list|(
name|rle
operator|->
name|res
argument_list|)
operator|&
name|RF_ACTIVE
operator|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|cfg
operator|->
name|msix
operator|.
name|msix_table_res
operator|=
name|rle
operator|->
name|res
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|msix
operator|.
name|msix_pba_bar
operator|!=
name|cfg
operator|->
name|msix
operator|.
name|msix_table_bar
condition|)
block|{
name|rle
operator|=
name|resource_list_find
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|cfg
operator|->
name|msix
operator|.
name|msix_pba_bar
argument_list|)
expr_stmt|;
if|if
condition|(
name|rle
operator|==
name|NULL
operator|||
name|rle
operator|->
name|res
operator|==
name|NULL
operator|||
operator|!
operator|(
name|rman_get_flags
argument_list|(
name|rle
operator|->
name|res
argument_list|)
operator|&
name|RF_ACTIVE
operator|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|cfg
operator|->
name|msix
operator|.
name|msix_pba_res
operator|=
name|rle
operator|->
name|res
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|child
argument_list|,
literal|"attempting to allocate %d MSI-X vectors (%d supported)\n"
argument_list|,
operator|*
name|count
argument_list|,
name|cfg
operator|->
name|msix
operator|.
name|msix_msgnum
argument_list|)
expr_stmt|;
name|max
operator|=
name|min
argument_list|(
operator|*
name|count
argument_list|,
name|cfg
operator|->
name|msix
operator|.
name|msix_msgnum
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
comment|/* Allocate a message. */
name|error
operator|=
name|PCIB_ALLOC_MSIX
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
operator|&
name|irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
break|break;
block|}
name|resource_list_add
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|irq
argument_list|,
name|irq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|actual
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|rle
operator|=
name|resource_list_find
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|actual
operator|==
literal|1
condition|)
name|device_printf
argument_list|(
name|child
argument_list|,
literal|"using IRQ %lu for MSI-X\n"
argument_list|,
name|rle
operator|->
name|start
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|run
decl_stmt|;
comment|/* 			 * Be fancy and try to print contiguous runs of 			 * IRQ values as ranges.  'irq' is the previous IRQ. 			 * 'run' is true if we are in a range. 			 */
name|device_printf
argument_list|(
name|child
argument_list|,
literal|"using IRQs %lu"
argument_list|,
name|rle
operator|->
name|start
argument_list|)
expr_stmt|;
name|irq
operator|=
name|rle
operator|->
name|start
expr_stmt|;
name|run
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|actual
condition|;
name|i
operator|++
control|)
block|{
name|rle
operator|=
name|resource_list_find
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Still in a run? */
if|if
condition|(
name|rle
operator|->
name|start
operator|==
name|irq
operator|+
literal|1
condition|)
block|{
name|run
operator|=
literal|1
expr_stmt|;
name|irq
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Finish previous range. */
if|if
condition|(
name|run
condition|)
block|{
name|printf
argument_list|(
literal|"-%d"
argument_list|,
name|irq
argument_list|)
expr_stmt|;
name|run
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Start new range. */
name|printf
argument_list|(
literal|",%lu"
argument_list|,
name|rle
operator|->
name|start
argument_list|)
expr_stmt|;
name|irq
operator|=
name|rle
operator|->
name|start
expr_stmt|;
block|}
comment|/* Unfinished range? */
if|if
condition|(
name|run
condition|)
name|printf
argument_list|(
literal|"-%d"
argument_list|,
name|irq
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" for MSI-X\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Mask all vectors. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cfg
operator|->
name|msix
operator|.
name|msix_msgnum
condition|;
name|i
operator|++
control|)
name|pci_mask_msix
argument_list|(
name|child
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Allocate and initialize vector data and virtual table. */
name|cfg
operator|->
name|msix
operator|.
name|msix_vectors
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|msix_vector
argument_list|)
operator|*
name|actual
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|msix
operator|.
name|msix_table
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|msix_table_entry
argument_list|)
operator|*
name|actual
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|actual
condition|;
name|i
operator|++
control|)
block|{
name|rle
operator|=
name|resource_list_find
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|msix
operator|.
name|msix_vectors
index|[
name|i
index|]
operator|.
name|mv_irq
operator|=
name|rle
operator|->
name|start
expr_stmt|;
name|cfg
operator|->
name|msix
operator|.
name|msix_table
index|[
name|i
index|]
operator|.
name|mte_vector
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
comment|/* Update control register to enable MSI-X. */
name|cfg
operator|->
name|msix
operator|.
name|msix_ctrl
operator||=
name|PCIM_MSIXCTRL_MSIX_ENABLE
expr_stmt|;
name|pci_write_config
argument_list|(
name|child
argument_list|,
name|cfg
operator|->
name|msix
operator|.
name|msix_location
operator|+
name|PCIR_MSIX_CTRL
argument_list|,
name|cfg
operator|->
name|msix
operator|.
name|msix_ctrl
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Update counts of alloc'd messages. */
name|cfg
operator|->
name|msix
operator|.
name|msix_alloc
operator|=
name|actual
expr_stmt|;
name|cfg
operator|->
name|msix
operator|.
name|msix_table_len
operator|=
name|actual
expr_stmt|;
operator|*
name|count
operator|=
name|actual
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * By default, pci_alloc_msix() will assign the allocated IRQ  * resources consecutively to the first N messages in the MSI-X table.  * However, device drivers may want to use different layouts if they  * either receive fewer messages than they asked for, or they wish to  * populate the MSI-X table sparsely.  This method allows the driver  * to specify what layout it wants.  It must be called after a  * successful pci_alloc_msix() but before any of the associated  * SYS_RES_IRQ resources are allocated via bus_alloc_resource().  *  * The 'vectors' array contains 'count' message vectors.  The array  * maps directly to the MSI-X table in that index 0 in the array  * specifies the vector for the first message in the MSI-X table, etc.  * The vector value in each array index can either be 0 to indicate  * that no vector should be assigned to a message slot, or it can be a  * number from 1 to N (where N is the count returned from a  * succcessful call to pci_alloc_msix()) to indicate which message  * vector (IRQ) to be used for the corresponding message.  *  * On successful return, each message with a non-zero vector will have  * an associated SYS_RES_IRQ whose rid is equal to the array index +  * 1.  Additionally, if any of the IRQs allocated via the previous  * call to pci_alloc_msix() are not used in the mapping, those IRQs  * will be freed back to the system automatically.  *  * For example, suppose a driver has a MSI-X table with 6 messages and  * asks for 6 messages, but pci_alloc_msix() only returns a count of  * 3.  Call the three vectors allocated by pci_alloc_msix() A, B, and  * C.  After the call to pci_alloc_msix(), the device will be setup to  * have an MSI-X table of ABC--- (where - means no vector assigned).  * If the driver ten passes a vector array of { 1, 0, 1, 2, 0, 2 },  * then the MSI-X table will look like A-AB-B, and the 'C' vector will  * be freed back to the system.  This device will also have valid  * SYS_RES_IRQ rids of 1, 3, 4, and 6.  *  * In any case, the SYS_RES_IRQ rid X will always map to the message  * at MSI-X table index X - 1 and will only be valid if a vector is  * assigned to that table entry.  */
end_comment

begin_function
name|int
name|pci_remap_msix_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|count
parameter_list|,
specifier|const
name|u_int
modifier|*
name|vectors
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|struct
name|pcicfg_msix
modifier|*
name|msix
init|=
operator|&
name|dinfo
operator|->
name|cfg
operator|.
name|msix
decl_stmt|;
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
name|int
name|i
decl_stmt|,
name|irq
decl_stmt|,
name|j
decl_stmt|,
modifier|*
name|used
decl_stmt|;
comment|/* 	 * Have to have at least one message in the table but the 	 * table can't be bigger than the actual MSI-X table in the 	 * device. 	 */
if|if
condition|(
name|count
operator|==
literal|0
operator|||
name|count
operator|>
name|msix
operator|->
name|msix_msgnum
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Sanity check the vectors. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|vectors
index|[
name|i
index|]
operator|>
name|msix
operator|->
name|msix_alloc
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Make sure there aren't any holes in the vectors to be used. 	 * It's a big pain to support it, and it doesn't really make 	 * sense anyway.  Also, at least one vector must be used. 	 */
name|used
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|msix
operator|->
name|msix_alloc
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|vectors
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|used
index|[
name|vectors
index|[
name|i
index|]
operator|-
literal|1
index|]
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msix
operator|->
name|msix_alloc
operator|-
literal|1
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|used
index|[
name|i
index|]
operator|==
literal|0
operator|&&
name|used
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|1
condition|)
block|{
name|free
argument_list|(
name|used
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|used
index|[
literal|0
index|]
operator|!=
literal|1
condition|)
block|{
name|free
argument_list|(
name|used
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Make sure none of the resources are allocated. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msix
operator|->
name|msix_table_len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|msix
operator|->
name|msix_table
index|[
name|i
index|]
operator|.
name|mte_vector
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|msix
operator|->
name|msix_table
index|[
name|i
index|]
operator|.
name|mte_handlers
operator|>
literal|0
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|rle
operator|=
name|resource_list_find
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|rle
operator|!=
name|NULL
argument_list|,
operator|(
literal|"missing resource"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rle
operator|->
name|res
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
comment|/* Free the existing resource list entries. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msix
operator|->
name|msix_table_len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|msix
operator|->
name|msix_table
index|[
name|i
index|]
operator|.
name|mte_vector
operator|==
literal|0
condition|)
continue|continue;
name|resource_list_delete
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Build the new virtual table keeping track of which vectors are 	 * used. 	 */
name|free
argument_list|(
name|msix
operator|->
name|msix_table
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|msix
operator|->
name|msix_table
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|msix_table_entry
argument_list|)
operator|*
name|count
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|msix
operator|->
name|msix_table
index|[
name|i
index|]
operator|.
name|mte_vector
operator|=
name|vectors
index|[
name|i
index|]
expr_stmt|;
name|msix
operator|->
name|msix_table_len
operator|=
name|count
expr_stmt|;
comment|/* Free any unused IRQs and resize the vectors array if necessary. */
name|j
operator|=
name|msix
operator|->
name|msix_alloc
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|used
index|[
name|j
index|]
operator|==
literal|0
condition|)
block|{
name|struct
name|msix_vector
modifier|*
name|vec
decl_stmt|;
while|while
condition|(
name|used
index|[
name|j
index|]
operator|==
literal|0
condition|)
block|{
name|PCIB_RELEASE_MSIX
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|msix
operator|->
name|msix_vectors
index|[
name|j
index|]
operator|.
name|mv_irq
argument_list|)
expr_stmt|;
name|j
operator|--
expr_stmt|;
block|}
name|vec
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|msix_vector
argument_list|)
operator|*
operator|(
name|j
operator|+
literal|1
operator|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|msix
operator|->
name|msix_vectors
argument_list|,
name|vec
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|msix_vector
argument_list|)
operator|*
operator|(
name|j
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|msix
operator|->
name|msix_vectors
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|msix
operator|->
name|msix_vectors
operator|=
name|vec
expr_stmt|;
name|msix
operator|->
name|msix_alloc
operator|=
name|j
operator|+
literal|1
expr_stmt|;
block|}
name|free
argument_list|(
name|used
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
comment|/* Map the IRQs onto the rids. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|vectors
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
name|irq
operator|=
name|msix
operator|->
name|msix_vectors
index|[
name|vectors
index|[
name|i
index|]
index|]
operator|.
name|mv_irq
expr_stmt|;
name|resource_list_add
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|irq
argument_list|,
name|irq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|child
argument_list|,
literal|"Remapped MSI-X IRQs as: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
if|if
condition|(
name|vectors
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"---"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|msix
operator|->
name|msix_vectors
index|[
name|vectors
index|[
name|i
index|]
index|]
operator|.
name|mv_irq
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pci_release_msix
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|struct
name|pcicfg_msix
modifier|*
name|msix
init|=
operator|&
name|dinfo
operator|->
name|cfg
operator|.
name|msix
decl_stmt|;
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Do we have any messages to release? */
if|if
condition|(
name|msix
operator|->
name|msix_alloc
operator|==
literal|0
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
comment|/* Make sure none of the resources are allocated. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msix
operator|->
name|msix_table_len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|msix
operator|->
name|msix_table
index|[
name|i
index|]
operator|.
name|mte_vector
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|msix
operator|->
name|msix_table
index|[
name|i
index|]
operator|.
name|mte_handlers
operator|>
literal|0
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|rle
operator|=
name|resource_list_find
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|rle
operator|!=
name|NULL
argument_list|,
operator|(
literal|"missing resource"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rle
operator|->
name|res
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
comment|/* Update control register to disable MSI-X. */
name|msix
operator|->
name|msix_ctrl
operator|&=
operator|~
name|PCIM_MSIXCTRL_MSIX_ENABLE
expr_stmt|;
name|pci_write_config
argument_list|(
name|child
argument_list|,
name|msix
operator|->
name|msix_location
operator|+
name|PCIR_MSIX_CTRL
argument_list|,
name|msix
operator|->
name|msix_ctrl
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Free the resource list entries. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msix
operator|->
name|msix_table_len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|msix
operator|->
name|msix_table
index|[
name|i
index|]
operator|.
name|mte_vector
operator|==
literal|0
condition|)
continue|continue;
name|resource_list_delete
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|msix
operator|->
name|msix_table
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|msix
operator|->
name|msix_table_len
operator|=
literal|0
expr_stmt|;
comment|/* Release the IRQs. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msix
operator|->
name|msix_alloc
condition|;
name|i
operator|++
control|)
name|PCIB_RELEASE_MSIX
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|msix
operator|->
name|msix_vectors
index|[
name|i
index|]
operator|.
name|mv_irq
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|msix
operator|->
name|msix_vectors
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|msix
operator|->
name|msix_alloc
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the max supported MSI-X messages this device supports.  * Basically, assuming the MD code can alloc messages, this function  * should return the maximum value that pci_alloc_msix() can return.  * Thus, it is subject to the tunables, etc.  */
end_comment

begin_function
name|int
name|pci_msix_count_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|struct
name|pcicfg_msix
modifier|*
name|msix
init|=
operator|&
name|dinfo
operator|->
name|cfg
operator|.
name|msix
decl_stmt|;
if|if
condition|(
name|pci_do_msix
operator|&&
name|msix
operator|->
name|msix_location
operator|!=
literal|0
condition|)
return|return
operator|(
name|msix
operator|->
name|msix_msgnum
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * HyperTransport MSI mapping control  */
end_comment

begin_function
name|void
name|pci_ht_map_msi
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|uint64_t
name|addr
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|pcicfg_ht
modifier|*
name|ht
init|=
operator|&
name|dinfo
operator|->
name|cfg
operator|.
name|ht
decl_stmt|;
if|if
condition|(
operator|!
name|ht
operator|->
name|ht_msimap
condition|)
return|return;
if|if
condition|(
name|addr
operator|&&
operator|!
operator|(
name|ht
operator|->
name|ht_msictrl
operator|&
name|PCIM_HTCMD_MSI_ENABLE
operator|)
operator|&&
name|ht
operator|->
name|ht_msiaddr
operator|>>
literal|20
operator|==
name|addr
operator|>>
literal|20
condition|)
block|{
comment|/* Enable MSI -> HT mapping. */
name|ht
operator|->
name|ht_msictrl
operator||=
name|PCIM_HTCMD_MSI_ENABLE
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|ht
operator|->
name|ht_msimap
operator|+
name|PCIR_HT_COMMAND
argument_list|,
name|ht
operator|->
name|ht_msictrl
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|addr
operator|&&
name|ht
operator|->
name|ht_msictrl
operator|&
name|PCIM_HTCMD_MSI_ENABLE
condition|)
block|{
comment|/* Disable MSI -> HT mapping. */
name|ht
operator|->
name|ht_msictrl
operator|&=
operator|~
name|PCIM_HTCMD_MSI_ENABLE
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|ht
operator|->
name|ht_msimap
operator|+
name|PCIR_HT_COMMAND
argument_list|,
name|ht
operator|->
name|ht_msictrl
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|pci_get_max_read_req
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|cap
decl_stmt|;
name|uint16_t
name|val
decl_stmt|;
if|if
condition|(
name|pci_find_cap
argument_list|(
name|dev
argument_list|,
name|PCIY_EXPRESS
argument_list|,
operator|&
name|cap
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|val
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|cap
operator|+
name|PCIER_DEVICE_CTL
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|val
operator|&=
name|PCIEM_CTL_MAX_READ_REQUEST
expr_stmt|;
name|val
operator|>>=
literal|12
expr_stmt|;
return|return
operator|(
literal|1
operator|<<
operator|(
name|val
operator|+
literal|7
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_set_max_read_req
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|cap
decl_stmt|;
name|uint16_t
name|val
decl_stmt|;
if|if
condition|(
name|pci_find_cap
argument_list|(
name|dev
argument_list|,
name|PCIY_EXPRESS
argument_list|,
operator|&
name|cap
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|size
operator|<
literal|128
condition|)
name|size
operator|=
literal|128
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|4096
condition|)
name|size
operator|=
literal|4096
expr_stmt|;
name|size
operator|=
operator|(
literal|1
operator|<<
operator|(
name|fls
argument_list|(
name|size
argument_list|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|val
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|cap
operator|+
name|PCIER_DEVICE_CTL
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|PCIEM_CTL_MAX_READ_REQUEST
expr_stmt|;
name|val
operator||=
operator|(
name|fls
argument_list|(
name|size
argument_list|)
operator|-
literal|8
operator|)
operator|<<
literal|12
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|cap
operator|+
name|PCIER_DEVICE_CTL
argument_list|,
name|val
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
name|size
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Support for MSI message signalled interrupts.  */
end_comment

begin_function
name|void
name|pci_enable_msi
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|uint64_t
name|address
parameter_list|,
name|uint16_t
name|data
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|pcicfg_msi
modifier|*
name|msi
init|=
operator|&
name|dinfo
operator|->
name|cfg
operator|.
name|msi
decl_stmt|;
comment|/* Write data and address values. */
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|msi
operator|->
name|msi_location
operator|+
name|PCIR_MSI_ADDR
argument_list|,
name|address
operator|&
literal|0xffffffff
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|msi
operator|->
name|msi_ctrl
operator|&
name|PCIM_MSICTRL_64BIT
condition|)
block|{
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|msi
operator|->
name|msi_location
operator|+
name|PCIR_MSI_ADDR_HIGH
argument_list|,
name|address
operator|>>
literal|32
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|msi
operator|->
name|msi_location
operator|+
name|PCIR_MSI_DATA_64BIT
argument_list|,
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|msi
operator|->
name|msi_location
operator|+
name|PCIR_MSI_DATA
argument_list|,
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Enable MSI in the control register. */
name|msi
operator|->
name|msi_ctrl
operator||=
name|PCIM_MSICTRL_MSI_ENABLE
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|msi
operator|->
name|msi_location
operator|+
name|PCIR_MSI_CTRL
argument_list|,
name|msi
operator|->
name|msi_ctrl
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Enable MSI -> HT mapping. */
name|pci_ht_map_msi
argument_list|(
name|dev
argument_list|,
name|address
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pci_disable_msi
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|pcicfg_msi
modifier|*
name|msi
init|=
operator|&
name|dinfo
operator|->
name|cfg
operator|.
name|msi
decl_stmt|;
comment|/* Disable MSI -> HT mapping. */
name|pci_ht_map_msi
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Disable MSI in the control register. */
name|msi
operator|->
name|msi_ctrl
operator|&=
operator|~
name|PCIM_MSICTRL_MSI_ENABLE
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|msi
operator|->
name|msi_location
operator|+
name|PCIR_MSI_CTRL
argument_list|,
name|msi
operator|->
name|msi_ctrl
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Restore MSI registers during resume.  If MSI is enabled then  * restore the data and address registers in addition to the control  * register.  */
end_comment

begin_function
specifier|static
name|void
name|pci_resume_msi
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|pcicfg_msi
modifier|*
name|msi
init|=
operator|&
name|dinfo
operator|->
name|cfg
operator|.
name|msi
decl_stmt|;
name|uint64_t
name|address
decl_stmt|;
name|uint16_t
name|data
decl_stmt|;
if|if
condition|(
name|msi
operator|->
name|msi_ctrl
operator|&
name|PCIM_MSICTRL_MSI_ENABLE
condition|)
block|{
name|address
operator|=
name|msi
operator|->
name|msi_addr
expr_stmt|;
name|data
operator|=
name|msi
operator|->
name|msi_data
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|msi
operator|->
name|msi_location
operator|+
name|PCIR_MSI_ADDR
argument_list|,
name|address
operator|&
literal|0xffffffff
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|msi
operator|->
name|msi_ctrl
operator|&
name|PCIM_MSICTRL_64BIT
condition|)
block|{
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|msi
operator|->
name|msi_location
operator|+
name|PCIR_MSI_ADDR_HIGH
argument_list|,
name|address
operator|>>
literal|32
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|msi
operator|->
name|msi_location
operator|+
name|PCIR_MSI_DATA_64BIT
argument_list|,
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|msi
operator|->
name|msi_location
operator|+
name|PCIR_MSI_DATA
argument_list|,
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|msi
operator|->
name|msi_location
operator|+
name|PCIR_MSI_CTRL
argument_list|,
name|msi
operator|->
name|msi_ctrl
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pci_remap_intr_method
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|u_int
name|irq
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
name|struct
name|msix_table_entry
modifier|*
name|mte
decl_stmt|;
name|struct
name|msix_vector
modifier|*
name|mv
decl_stmt|;
name|uint64_t
name|addr
decl_stmt|;
name|uint32_t
name|data
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* 	 * Handle MSI first.  We try to find this IRQ among our list 	 * of MSI IRQs.  If we find it, we request updated address and 	 * data registers and apply the results. 	 */
if|if
condition|(
name|cfg
operator|->
name|msi
operator|.
name|msi_alloc
operator|>
literal|0
condition|)
block|{
comment|/* If we don't have any active handlers, nothing to do. */
if|if
condition|(
name|cfg
operator|->
name|msi
operator|.
name|msi_handlers
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cfg
operator|->
name|msi
operator|.
name|msi_alloc
condition|;
name|i
operator|++
control|)
block|{
name|rle
operator|=
name|resource_list_find
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rle
operator|->
name|start
operator|==
name|irq
condition|)
block|{
name|error
operator|=
name|PCIB_MAP_MSI
argument_list|(
name|device_get_parent
argument_list|(
name|bus
argument_list|)
argument_list|,
name|dev
argument_list|,
name|irq
argument_list|,
operator|&
name|addr
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|pci_disable_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|msi
operator|.
name|msi_addr
operator|=
name|addr
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|msi
operator|.
name|msi_data
operator|=
name|data
expr_stmt|;
name|pci_enable_msi
argument_list|(
name|dev
argument_list|,
name|addr
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
comment|/* 	 * For MSI-X, we check to see if we have this IRQ.  If we do, 	 * we request the updated mapping info.  If that works, we go 	 * through all the slots that use this IRQ and update them. 	 */
if|if
condition|(
name|cfg
operator|->
name|msix
operator|.
name|msix_alloc
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cfg
operator|->
name|msix
operator|.
name|msix_alloc
condition|;
name|i
operator|++
control|)
block|{
name|mv
operator|=
operator|&
name|cfg
operator|->
name|msix
operator|.
name|msix_vectors
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|mv
operator|->
name|mv_irq
operator|==
name|irq
condition|)
block|{
name|error
operator|=
name|PCIB_MAP_MSI
argument_list|(
name|device_get_parent
argument_list|(
name|bus
argument_list|)
argument_list|,
name|dev
argument_list|,
name|irq
argument_list|,
operator|&
name|addr
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|mv
operator|->
name|mv_address
operator|=
name|addr
expr_stmt|;
name|mv
operator|->
name|mv_data
operator|=
name|data
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|cfg
operator|->
name|msix
operator|.
name|msix_table_len
condition|;
name|j
operator|++
control|)
block|{
name|mte
operator|=
operator|&
name|cfg
operator|->
name|msix
operator|.
name|msix_table
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|mte
operator|->
name|mte_vector
operator|!=
name|i
operator|+
literal|1
condition|)
continue|continue;
if|if
condition|(
name|mte
operator|->
name|mte_handlers
operator|==
literal|0
condition|)
continue|continue;
name|pci_mask_msix
argument_list|(
name|dev
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|pci_enable_msix
argument_list|(
name|dev
argument_list|,
name|j
argument_list|,
name|addr
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|pci_unmask_msix
argument_list|(
name|dev
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns true if the specified device is blacklisted because MSI  * doesn't work.  */
end_comment

begin_function
name|int
name|pci_msi_device_blacklisted
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
specifier|const
name|struct
name|pci_quirk
modifier|*
name|q
decl_stmt|;
if|if
condition|(
operator|!
name|pci_honor_msi_blacklist
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|q
operator|=
operator|&
name|pci_quirks
index|[
literal|0
index|]
init|;
name|q
operator|->
name|devid
condition|;
name|q
operator|++
control|)
block|{
if|if
condition|(
name|q
operator|->
name|devid
operator|==
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
operator|&&
name|q
operator|->
name|type
operator|==
name|PCI_QUIRK_DISABLE_MSI
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns true if a specified chipset supports MSI when it is  * emulated hardware in a virtual machine.  */
end_comment

begin_function
specifier|static
name|int
name|pci_msi_vm_chipset
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
specifier|const
name|struct
name|pci_quirk
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|q
operator|=
operator|&
name|pci_quirks
index|[
literal|0
index|]
init|;
name|q
operator|->
name|devid
condition|;
name|q
operator|++
control|)
block|{
if|if
condition|(
name|q
operator|->
name|devid
operator|==
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
operator|&&
name|q
operator|->
name|type
operator|==
name|PCI_QUIRK_ENABLE_MSI_VM
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine if MSI is blacklisted globally on this sytem.  Currently,  * we just check for blacklisted chipsets as represented by the  * host-PCI bridge at device 0:0:0.  In the future, it may become  * necessary to check other system attributes, such as the kenv values  * that give the motherboard manufacturer and model number.  */
end_comment

begin_function
specifier|static
name|int
name|pci_msi_blacklisted
parameter_list|(
name|void
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
if|if
condition|(
operator|!
name|pci_honor_msi_blacklist
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Blacklist all non-PCI-express and non-PCI-X chipsets. */
if|if
condition|(
operator|!
operator|(
name|pcie_chipset
operator|||
name|pcix_chipset
operator|)
condition|)
block|{
if|if
condition|(
name|vm_guest
operator|!=
name|VM_GUEST_NO
condition|)
block|{
name|dev
operator|=
name|pci_find_bsf
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|!=
name|NULL
condition|)
return|return
operator|(
name|pci_msi_vm_chipset
argument_list|(
name|dev
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|dev
operator|=
name|pci_find_bsf
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|!=
name|NULL
condition|)
return|return
operator|(
name|pci_msi_device_blacklisted
argument_list|(
name|dev
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attempt to allocate *count MSI messages.  The actual number allocated is  * returned in *count.  After this function returns, each message will be  * available to the driver as SYS_RES_IRQ resources starting at a rid 1.  */
end_comment

begin_function
name|int
name|pci_alloc_msi_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
modifier|*
name|count
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
name|int
name|actual
decl_stmt|,
name|error
decl_stmt|,
name|i
decl_stmt|,
name|irqs
index|[
literal|32
index|]
decl_stmt|;
name|uint16_t
name|ctrl
decl_stmt|;
comment|/* Don't let count == 0 get us into trouble. */
if|if
condition|(
operator|*
name|count
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* If rid 0 is allocated, then fail. */
name|rle
operator|=
name|resource_list_find
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rle
operator|!=
name|NULL
operator|&&
name|rle
operator|->
name|res
operator|!=
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Already have allocated messages? */
if|if
condition|(
name|cfg
operator|->
name|msi
operator|.
name|msi_alloc
operator|!=
literal|0
operator|||
name|cfg
operator|->
name|msix
operator|.
name|msix_alloc
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* If MSI is blacklisted for this system, fail. */
if|if
condition|(
name|pci_msi_blacklisted
argument_list|()
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* MSI capability present? */
if|if
condition|(
name|cfg
operator|->
name|msi
operator|.
name|msi_location
operator|==
literal|0
operator|||
operator|!
name|pci_do_msi
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|child
argument_list|,
literal|"attempting to allocate %d MSI vectors (%d supported)\n"
argument_list|,
operator|*
name|count
argument_list|,
name|cfg
operator|->
name|msi
operator|.
name|msi_msgnum
argument_list|)
expr_stmt|;
comment|/* Don't ask for more than the device supports. */
name|actual
operator|=
name|min
argument_list|(
operator|*
name|count
argument_list|,
name|cfg
operator|->
name|msi
operator|.
name|msi_msgnum
argument_list|)
expr_stmt|;
comment|/* Don't ask for more than 32 messages. */
name|actual
operator|=
name|min
argument_list|(
name|actual
argument_list|,
literal|32
argument_list|)
expr_stmt|;
comment|/* MSI requires power of 2 number of messages. */
if|if
condition|(
operator|!
name|powerof2
argument_list|(
name|actual
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Try to allocate N messages. */
name|error
operator|=
name|PCIB_ALLOC_MSI
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|actual
argument_list|,
name|actual
argument_list|,
name|irqs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|actual
operator|==
literal|1
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Try N / 2. */
name|actual
operator|>>=
literal|1
expr_stmt|;
block|}
comment|/* 	 * We now have N actual messages mapped onto SYS_RES_IRQ 	 * resources in the irqs[] array, so add new resources 	 * starting at rid 1. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|actual
condition|;
name|i
operator|++
control|)
name|resource_list_add
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|irqs
index|[
name|i
index|]
argument_list|,
name|irqs
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
if|if
condition|(
name|actual
operator|==
literal|1
condition|)
name|device_printf
argument_list|(
name|child
argument_list|,
literal|"using IRQ %d for MSI\n"
argument_list|,
name|irqs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|run
decl_stmt|;
comment|/* 			 * Be fancy and try to print contiguous runs 			 * of IRQ values as ranges.  'run' is true if 			 * we are in a range. 			 */
name|device_printf
argument_list|(
name|child
argument_list|,
literal|"using IRQs %d"
argument_list|,
name|irqs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|run
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|actual
condition|;
name|i
operator|++
control|)
block|{
comment|/* Still in a run? */
if|if
condition|(
name|irqs
index|[
name|i
index|]
operator|==
name|irqs
index|[
name|i
operator|-
literal|1
index|]
operator|+
literal|1
condition|)
block|{
name|run
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* Finish previous range. */
if|if
condition|(
name|run
condition|)
block|{
name|printf
argument_list|(
literal|"-%d"
argument_list|,
name|irqs
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|run
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Start new range. */
name|printf
argument_list|(
literal|",%d"
argument_list|,
name|irqs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Unfinished range? */
if|if
condition|(
name|run
condition|)
name|printf
argument_list|(
literal|"-%d"
argument_list|,
name|irqs
index|[
name|actual
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" for MSI\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Update control register with actual count. */
name|ctrl
operator|=
name|cfg
operator|->
name|msi
operator|.
name|msi_ctrl
expr_stmt|;
name|ctrl
operator|&=
operator|~
name|PCIM_MSICTRL_MME_MASK
expr_stmt|;
name|ctrl
operator||=
operator|(
name|ffs
argument_list|(
name|actual
argument_list|)
operator|-
literal|1
operator|)
operator|<<
literal|4
expr_stmt|;
name|cfg
operator|->
name|msi
operator|.
name|msi_ctrl
operator|=
name|ctrl
expr_stmt|;
name|pci_write_config
argument_list|(
name|child
argument_list|,
name|cfg
operator|->
name|msi
operator|.
name|msi_location
operator|+
name|PCIR_MSI_CTRL
argument_list|,
name|ctrl
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Update counts of alloc'd messages. */
name|cfg
operator|->
name|msi
operator|.
name|msi_alloc
operator|=
name|actual
expr_stmt|;
name|cfg
operator|->
name|msi
operator|.
name|msi_handlers
operator|=
literal|0
expr_stmt|;
operator|*
name|count
operator|=
name|actual
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Release the MSI messages associated with this device. */
end_comment

begin_function
name|int
name|pci_release_msi_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|struct
name|pcicfg_msi
modifier|*
name|msi
init|=
operator|&
name|dinfo
operator|->
name|cfg
operator|.
name|msi
decl_stmt|;
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|irqs
index|[
literal|32
index|]
decl_stmt|;
comment|/* Try MSI-X first. */
name|error
operator|=
name|pci_release_msix
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENODEV
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Do we have any messages to release? */
if|if
condition|(
name|msi
operator|->
name|msi_alloc
operator|==
literal|0
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
name|KASSERT
argument_list|(
name|msi
operator|->
name|msi_alloc
operator|<=
literal|32
argument_list|,
operator|(
literal|"more than 32 alloc'd messages"
operator|)
argument_list|)
expr_stmt|;
comment|/* Make sure none of the resources are allocated. */
if|if
condition|(
name|msi
operator|->
name|msi_handlers
operator|>
literal|0
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msi
operator|->
name|msi_alloc
condition|;
name|i
operator|++
control|)
block|{
name|rle
operator|=
name|resource_list_find
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|rle
operator|!=
name|NULL
argument_list|,
operator|(
literal|"missing MSI resource"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rle
operator|->
name|res
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|irqs
index|[
name|i
index|]
operator|=
name|rle
operator|->
name|start
expr_stmt|;
block|}
comment|/* Update control register with 0 count. */
name|KASSERT
argument_list|(
operator|!
operator|(
name|msi
operator|->
name|msi_ctrl
operator|&
name|PCIM_MSICTRL_MSI_ENABLE
operator|)
argument_list|,
operator|(
literal|"%s: MSI still enabled"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|msi
operator|->
name|msi_ctrl
operator|&=
operator|~
name|PCIM_MSICTRL_MME_MASK
expr_stmt|;
name|pci_write_config
argument_list|(
name|child
argument_list|,
name|msi
operator|->
name|msi_location
operator|+
name|PCIR_MSI_CTRL
argument_list|,
name|msi
operator|->
name|msi_ctrl
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Release the messages. */
name|PCIB_RELEASE_MSI
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|msi
operator|->
name|msi_alloc
argument_list|,
name|irqs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msi
operator|->
name|msi_alloc
condition|;
name|i
operator|++
control|)
name|resource_list_delete
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Update alloc count. */
name|msi
operator|->
name|msi_alloc
operator|=
literal|0
expr_stmt|;
name|msi
operator|->
name|msi_addr
operator|=
literal|0
expr_stmt|;
name|msi
operator|->
name|msi_data
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the max supported MSI messages this device supports.  * Basically, assuming the MD code can alloc messages, this function  * should return the maximum value that pci_alloc_msi() can return.  * Thus, it is subject to the tunables, etc.  */
end_comment

begin_function
name|int
name|pci_msi_count_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|struct
name|pcicfg_msi
modifier|*
name|msi
init|=
operator|&
name|dinfo
operator|->
name|cfg
operator|.
name|msi
decl_stmt|;
if|if
condition|(
name|pci_do_msi
operator|&&
name|msi
operator|->
name|msi_location
operator|!=
literal|0
condition|)
return|return
operator|(
name|msi
operator|->
name|msi_msgnum
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* free pcicfgregs structure and all depending data structures */
end_comment

begin_function
name|int
name|pci_freecfg
parameter_list|(
name|struct
name|pci_devinfo
modifier|*
name|dinfo
parameter_list|)
block|{
name|struct
name|devlist
modifier|*
name|devlist_head
decl_stmt|;
name|struct
name|pci_map
modifier|*
name|pm
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|int
name|i
decl_stmt|;
name|devlist_head
operator|=
operator|&
name|pci_devq
expr_stmt|;
if|if
condition|(
name|dinfo
operator|->
name|cfg
operator|.
name|vpd
operator|.
name|vpd_reg
condition|)
block|{
name|free
argument_list|(
name|dinfo
operator|->
name|cfg
operator|.
name|vpd
operator|.
name|vpd_ident
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dinfo
operator|->
name|cfg
operator|.
name|vpd
operator|.
name|vpd_rocnt
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|dinfo
operator|->
name|cfg
operator|.
name|vpd
operator|.
name|vpd_ros
index|[
name|i
index|]
operator|.
name|value
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dinfo
operator|->
name|cfg
operator|.
name|vpd
operator|.
name|vpd_ros
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dinfo
operator|->
name|cfg
operator|.
name|vpd
operator|.
name|vpd_wcnt
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|dinfo
operator|->
name|cfg
operator|.
name|vpd
operator|.
name|vpd_w
index|[
name|i
index|]
operator|.
name|value
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dinfo
operator|->
name|cfg
operator|.
name|vpd
operator|.
name|vpd_w
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|pm
argument_list|,
argument|&dinfo->cfg.maps
argument_list|,
argument|pm_link
argument_list|,
argument|next
argument_list|)
block|{
name|free
argument_list|(
name|pm
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|STAILQ_REMOVE
argument_list|(
name|devlist_head
argument_list|,
name|dinfo
argument_list|,
name|pci_devinfo
argument_list|,
name|pci_links
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dinfo
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
comment|/* increment the generation count */
name|pci_generation
operator|++
expr_stmt|;
comment|/* we're losing one device */
name|pci_numdevs
operator|--
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * PCI power manangement  */
end_comment

begin_function
name|int
name|pci_set_powerstate_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
name|uint16_t
name|status
decl_stmt|;
name|int
name|result
decl_stmt|,
name|oldstate
decl_stmt|,
name|highest
decl_stmt|,
name|delay
decl_stmt|;
if|if
condition|(
name|cfg
operator|->
name|pp
operator|.
name|pp_cap
operator|==
literal|0
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
comment|/* 	 * Optimize a no state change request away.  While it would be OK to 	 * write to the hardware in theory, some devices have shown odd 	 * behavior when going from D3 -> D3. 	 */
name|oldstate
operator|=
name|pci_get_powerstate
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldstate
operator|==
name|state
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * The PCI power management specification states that after a state 	 * transition between PCI power states, system software must 	 * guarantee a minimal delay before the function accesses the device. 	 * Compute the worst case delay that we need to guarantee before we 	 * access the device.  Many devices will be responsive much more 	 * quickly than this delay, but there are some that don't respond 	 * instantly to state changes.  Transitions to/from D3 state require 	 * 10ms, while D2 requires 200us, and D0/1 require none.  The delay 	 * is done below with DELAY rather than a sleeper function because 	 * this function can be called from contexts where we cannot sleep. 	 */
name|highest
operator|=
operator|(
name|oldstate
operator|>
name|state
operator|)
condition|?
name|oldstate
else|:
name|state
expr_stmt|;
if|if
condition|(
name|highest
operator|==
name|PCI_POWERSTATE_D3
condition|)
name|delay
operator|=
literal|10000
expr_stmt|;
elseif|else
if|if
condition|(
name|highest
operator|==
name|PCI_POWERSTATE_D2
condition|)
name|delay
operator|=
literal|200
expr_stmt|;
else|else
name|delay
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|PCI_READ_CONFIG
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|cfg
operator|->
name|pp
operator|.
name|pp_status
argument_list|,
literal|2
argument_list|)
operator|&
operator|~
name|PCIM_PSTAT_DMASK
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|PCI_POWERSTATE_D0
case|:
name|status
operator||=
name|PCIM_PSTAT_D0
expr_stmt|;
break|break;
case|case
name|PCI_POWERSTATE_D1
case|:
if|if
condition|(
operator|(
name|cfg
operator|->
name|pp
operator|.
name|pp_cap
operator|&
name|PCIM_PCAP_D1SUPP
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
name|status
operator||=
name|PCIM_PSTAT_D1
expr_stmt|;
break|break;
case|case
name|PCI_POWERSTATE_D2
case|:
if|if
condition|(
operator|(
name|cfg
operator|->
name|pp
operator|.
name|pp_cap
operator|&
name|PCIM_PCAP_D2SUPP
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
name|status
operator||=
name|PCIM_PSTAT_D2
expr_stmt|;
break|break;
case|case
name|PCI_POWERSTATE_D3
case|:
name|status
operator||=
name|PCIM_PSTAT_D3
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|pci_printf
argument_list|(
name|cfg
argument_list|,
literal|"Transition from D%d to D%d\n"
argument_list|,
name|oldstate
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|PCI_WRITE_CONFIG
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|cfg
operator|->
name|pp
operator|.
name|pp_status
argument_list|,
name|status
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|delay
condition|)
name|DELAY
argument_list|(
name|delay
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_get_powerstate_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
name|uint16_t
name|status
decl_stmt|;
name|int
name|result
decl_stmt|;
if|if
condition|(
name|cfg
operator|->
name|pp
operator|.
name|pp_cap
operator|!=
literal|0
condition|)
block|{
name|status
operator|=
name|PCI_READ_CONFIG
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|cfg
operator|->
name|pp
operator|.
name|pp_status
argument_list|,
literal|2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|status
operator|&
name|PCIM_PSTAT_DMASK
condition|)
block|{
case|case
name|PCIM_PSTAT_D0
case|:
name|result
operator|=
name|PCI_POWERSTATE_D0
expr_stmt|;
break|break;
case|case
name|PCIM_PSTAT_D1
case|:
name|result
operator|=
name|PCI_POWERSTATE_D1
expr_stmt|;
break|break;
case|case
name|PCIM_PSTAT_D2
case|:
name|result
operator|=
name|PCI_POWERSTATE_D2
expr_stmt|;
break|break;
case|case
name|PCIM_PSTAT_D3
case|:
name|result
operator|=
name|PCI_POWERSTATE_D3
expr_stmt|;
break|break;
default|default:
name|result
operator|=
name|PCI_POWERSTATE_UNKNOWN
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* No support, device is always at D0 */
name|result
operator|=
name|PCI_POWERSTATE_D0
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Some convenience functions for PCI device drivers.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|pci_set_command_bit
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|uint16_t
name|bit
parameter_list|)
block|{
name|uint16_t
name|command
decl_stmt|;
name|command
operator|=
name|PCI_READ_CONFIG
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|command
operator||=
name|bit
expr_stmt|;
name|PCI_WRITE_CONFIG
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|command
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|pci_clear_command_bit
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|uint16_t
name|bit
parameter_list|)
block|{
name|uint16_t
name|command
decl_stmt|;
name|command
operator|=
name|PCI_READ_CONFIG
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|command
operator|&=
operator|~
name|bit
expr_stmt|;
name|PCI_WRITE_CONFIG
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|command
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pci_enable_busmaster_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|pci_set_command_bit
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|PCIM_CMD_BUSMASTEREN
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_disable_busmaster_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|pci_clear_command_bit
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|PCIM_CMD_BUSMASTEREN
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_enable_io_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|space
parameter_list|)
block|{
name|uint16_t
name|bit
decl_stmt|;
switch|switch
condition|(
name|space
condition|)
block|{
case|case
name|SYS_RES_IOPORT
case|:
name|bit
operator|=
name|PCIM_CMD_PORTEN
expr_stmt|;
break|break;
case|case
name|SYS_RES_MEMORY
case|:
name|bit
operator|=
name|PCIM_CMD_MEMEN
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|pci_set_command_bit
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|bit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_disable_io_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|space
parameter_list|)
block|{
name|uint16_t
name|bit
decl_stmt|;
switch|switch
condition|(
name|space
condition|)
block|{
case|case
name|SYS_RES_IOPORT
case|:
name|bit
operator|=
name|PCIM_CMD_PORTEN
expr_stmt|;
break|break;
case|case
name|SYS_RES_MEMORY
case|:
name|bit
operator|=
name|PCIM_CMD_MEMEN
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|pci_clear_command_bit
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|bit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * New style pci driver.  Parent device is either a pci-host-bridge or a  * pci-pci-bridge.  Both kinds are represented by instances of pcib.  */
end_comment

begin_function
name|void
name|pci_print_verbose
parameter_list|(
name|struct
name|pci_devinfo
modifier|*
name|dinfo
parameter_list|)
block|{
if|if
condition|(
name|bootverbose
condition|)
block|{
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
name|printf
argument_list|(
literal|"found->\tvendor=0x%04x, dev=0x%04x, revid=0x%02x\n"
argument_list|,
name|cfg
operator|->
name|vendor
argument_list|,
name|cfg
operator|->
name|device
argument_list|,
name|cfg
operator|->
name|revid
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tdomain=%d, bus=%d, slot=%d, func=%d\n"
argument_list|,
name|cfg
operator|->
name|domain
argument_list|,
name|cfg
operator|->
name|bus
argument_list|,
name|cfg
operator|->
name|slot
argument_list|,
name|cfg
operator|->
name|func
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tclass=%02x-%02x-%02x, hdrtype=0x%02x, mfdev=%d\n"
argument_list|,
name|cfg
operator|->
name|baseclass
argument_list|,
name|cfg
operator|->
name|subclass
argument_list|,
name|cfg
operator|->
name|progif
argument_list|,
name|cfg
operator|->
name|hdrtype
argument_list|,
name|cfg
operator|->
name|mfdev
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tcmdreg=0x%04x, statreg=0x%04x, cachelnsz=%d (dwords)\n"
argument_list|,
name|cfg
operator|->
name|cmdreg
argument_list|,
name|cfg
operator|->
name|statreg
argument_list|,
name|cfg
operator|->
name|cachelnsz
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tlattimer=0x%02x (%d ns), mingnt=0x%02x (%d ns), maxlat=0x%02x (%d ns)\n"
argument_list|,
name|cfg
operator|->
name|lattimer
argument_list|,
name|cfg
operator|->
name|lattimer
operator|*
literal|30
argument_list|,
name|cfg
operator|->
name|mingnt
argument_list|,
name|cfg
operator|->
name|mingnt
operator|*
literal|250
argument_list|,
name|cfg
operator|->
name|maxlat
argument_list|,
name|cfg
operator|->
name|maxlat
operator|*
literal|250
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|intpin
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"\tintpin=%c, irq=%d\n"
argument_list|,
name|cfg
operator|->
name|intpin
operator|+
literal|'a'
operator|-
literal|1
argument_list|,
name|cfg
operator|->
name|intline
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|pp
operator|.
name|pp_cap
condition|)
block|{
name|uint16_t
name|status
decl_stmt|;
name|status
operator|=
name|pci_read_config
argument_list|(
name|cfg
operator|->
name|dev
argument_list|,
name|cfg
operator|->
name|pp
operator|.
name|pp_status
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tpowerspec %d  supports D0%s%s D3  current D%d\n"
argument_list|,
name|cfg
operator|->
name|pp
operator|.
name|pp_cap
operator|&
name|PCIM_PCAP_SPEC
argument_list|,
name|cfg
operator|->
name|pp
operator|.
name|pp_cap
operator|&
name|PCIM_PCAP_D1SUPP
condition|?
literal|" D1"
else|:
literal|""
argument_list|,
name|cfg
operator|->
name|pp
operator|.
name|pp_cap
operator|&
name|PCIM_PCAP_D2SUPP
condition|?
literal|" D2"
else|:
literal|""
argument_list|,
name|status
operator|&
name|PCIM_PSTAT_DMASK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cfg
operator|->
name|msi
operator|.
name|msi_location
condition|)
block|{
name|int
name|ctrl
decl_stmt|;
name|ctrl
operator|=
name|cfg
operator|->
name|msi
operator|.
name|msi_ctrl
expr_stmt|;
name|printf
argument_list|(
literal|"\tMSI supports %d message%s%s%s\n"
argument_list|,
name|cfg
operator|->
name|msi
operator|.
name|msi_msgnum
argument_list|,
operator|(
name|cfg
operator|->
name|msi
operator|.
name|msi_msgnum
operator|==
literal|1
operator|)
condition|?
literal|""
else|:
literal|"s"
argument_list|,
operator|(
name|ctrl
operator|&
name|PCIM_MSICTRL_64BIT
operator|)
condition|?
literal|", 64 bit"
else|:
literal|""
argument_list|,
operator|(
name|ctrl
operator|&
name|PCIM_MSICTRL_VECTOR
operator|)
condition|?
literal|", vector masks"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cfg
operator|->
name|msix
operator|.
name|msix_location
condition|)
block|{
name|printf
argument_list|(
literal|"\tMSI-X supports %d message%s "
argument_list|,
name|cfg
operator|->
name|msix
operator|.
name|msix_msgnum
argument_list|,
operator|(
name|cfg
operator|->
name|msix
operator|.
name|msix_msgnum
operator|==
literal|1
operator|)
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|msix
operator|.
name|msix_table_bar
operator|==
name|cfg
operator|->
name|msix
operator|.
name|msix_pba_bar
condition|)
name|printf
argument_list|(
literal|"in map 0x%x\n"
argument_list|,
name|cfg
operator|->
name|msix
operator|.
name|msix_table_bar
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"in maps 0x%x and 0x%x\n"
argument_list|,
name|cfg
operator|->
name|msix
operator|.
name|msix_table_bar
argument_list|,
name|cfg
operator|->
name|msix
operator|.
name|msix_pba_bar
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|pci_porten
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
operator|&
name|PCIM_CMD_PORTEN
operator|)
operator|!=
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pci_memen
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
operator|&
name|PCIM_CMD_MEMEN
operator|)
operator|!=
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pci_read_bar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|reg
parameter_list|,
name|pci_addr_t
modifier|*
name|mapp
parameter_list|,
name|pci_addr_t
modifier|*
name|testvalp
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|pci_addr_t
name|map
decl_stmt|,
name|testval
decl_stmt|;
name|int
name|ln2range
decl_stmt|;
name|uint16_t
name|cmd
decl_stmt|;
comment|/* 	 * The device ROM BAR is special.  It is always a 32-bit 	 * memory BAR.  Bit 0 is special and should not be set when 	 * sizing the BAR. 	 */
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|PCIR_IS_BIOS
argument_list|(
operator|&
name|dinfo
operator|->
name|cfg
argument_list|,
name|reg
argument_list|)
condition|)
block|{
name|map
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|reg
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|reg
argument_list|,
literal|0xfffffffe
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|testval
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|reg
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|reg
argument_list|,
name|map
argument_list|,
literal|4
argument_list|)
expr_stmt|;
operator|*
name|mapp
operator|=
name|map
expr_stmt|;
operator|*
name|testvalp
operator|=
name|testval
expr_stmt|;
return|return;
block|}
name|map
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|reg
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ln2range
operator|=
name|pci_maprange
argument_list|(
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln2range
operator|==
literal|64
condition|)
name|map
operator||=
operator|(
name|pci_addr_t
operator|)
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|reg
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
operator|<<
literal|32
expr_stmt|;
comment|/* 	 * Disable decoding via the command register before 	 * determining the BAR's length since we will be placing it in 	 * a weird state. 	 */
name|cmd
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|cmd
operator|&
operator|~
operator|(
name|PCI_BAR_MEM
argument_list|(
name|map
argument_list|)
condition|?
name|PCIM_CMD_MEMEN
else|:
name|PCIM_CMD_PORTEN
operator|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* 	 * Determine the BAR's length by writing all 1's.  The bottom 	 * log_2(size) bits of the BAR will stick as 0 when we read 	 * the value back. 	 */
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|reg
argument_list|,
literal|0xffffffff
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|testval
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|reg
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln2range
operator|==
literal|64
condition|)
block|{
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|reg
operator|+
literal|4
argument_list|,
literal|0xffffffff
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|testval
operator||=
operator|(
name|pci_addr_t
operator|)
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|reg
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
operator|<<
literal|32
expr_stmt|;
block|}
comment|/* 	 * Restore the original value of the BAR.  We may have reprogrammed 	 * the BAR of the low-level console device and when booting verbose, 	 * we need the console device addressable. 	 */
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|reg
argument_list|,
name|map
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln2range
operator|==
literal|64
condition|)
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|reg
operator|+
literal|4
argument_list|,
name|map
operator|>>
literal|32
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|cmd
argument_list|,
literal|2
argument_list|)
expr_stmt|;
operator|*
name|mapp
operator|=
name|map
expr_stmt|;
operator|*
name|testvalp
operator|=
name|testval
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pci_write_bar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|pci_map
modifier|*
name|pm
parameter_list|,
name|pci_addr_t
name|base
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|int
name|ln2range
decl_stmt|;
comment|/* The device ROM BAR is always a 32-bit memory BAR. */
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|PCIR_IS_BIOS
argument_list|(
operator|&
name|dinfo
operator|->
name|cfg
argument_list|,
name|pm
operator|->
name|pm_reg
argument_list|)
condition|)
name|ln2range
operator|=
literal|32
expr_stmt|;
else|else
name|ln2range
operator|=
name|pci_maprange
argument_list|(
name|pm
operator|->
name|pm_value
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|pm
operator|->
name|pm_reg
argument_list|,
name|base
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln2range
operator|==
literal|64
condition|)
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|pm
operator|->
name|pm_reg
operator|+
literal|4
argument_list|,
name|base
operator|>>
literal|32
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pm
operator|->
name|pm_value
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|pm
operator|->
name|pm_reg
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln2range
operator|==
literal|64
condition|)
name|pm
operator|->
name|pm_value
operator||=
operator|(
name|pci_addr_t
operator|)
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|pm
operator|->
name|pm_reg
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
operator|<<
literal|32
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|pci_map
modifier|*
name|pci_find_bar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|struct
name|pci_map
modifier|*
name|pm
decl_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|pm
argument_list|,
argument|&dinfo->cfg.maps
argument_list|,
argument|pm_link
argument_list|)
block|{
if|if
condition|(
name|pm
operator|->
name|pm_reg
operator|==
name|reg
condition|)
return|return
operator|(
name|pm
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_bar_enabled
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|pci_map
modifier|*
name|pm
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|uint16_t
name|cmd
decl_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|PCIR_IS_BIOS
argument_list|(
operator|&
name|dinfo
operator|->
name|cfg
argument_list|,
name|pm
operator|->
name|pm_reg
argument_list|)
operator|&&
operator|!
operator|(
name|pm
operator|->
name|pm_value
operator|&
name|PCIM_BIOS_ENABLE
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|cmd
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|PCIR_IS_BIOS
argument_list|(
operator|&
name|dinfo
operator|->
name|cfg
argument_list|,
name|pm
operator|->
name|pm_reg
argument_list|)
operator|||
name|PCI_BAR_MEM
argument_list|(
name|pm
operator|->
name|pm_value
argument_list|)
condition|)
return|return
operator|(
operator|(
name|cmd
operator|&
name|PCIM_CMD_MEMEN
operator|)
operator|!=
literal|0
operator|)
return|;
else|else
return|return
operator|(
operator|(
name|cmd
operator|&
name|PCIM_CMD_PORTEN
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|pci_map
modifier|*
name|pci_add_bar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|reg
parameter_list|,
name|pci_addr_t
name|value
parameter_list|,
name|pci_addr_t
name|size
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|struct
name|pci_map
modifier|*
name|pm
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pm
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pm
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|pm
operator|->
name|pm_reg
operator|=
name|reg
expr_stmt|;
name|pm
operator|->
name|pm_value
operator|=
name|value
expr_stmt|;
name|pm
operator|->
name|pm_size
operator|=
name|size
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|prev
argument_list|,
argument|&dinfo->cfg.maps
argument_list|,
argument|pm_link
argument_list|)
block|{
name|KASSERT
argument_list|(
name|prev
operator|->
name|pm_reg
operator|!=
name|pm
operator|->
name|pm_reg
argument_list|,
operator|(
literal|"duplicate map %02x"
operator|,
name|reg
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|STAILQ_NEXT
argument_list|(
name|prev
argument_list|,
name|pm_link
argument_list|)
operator|==
name|NULL
operator|||
name|STAILQ_NEXT
argument_list|(
name|prev
argument_list|,
name|pm_link
argument_list|)
operator|->
name|pm_reg
operator|>
name|pm
operator|->
name|pm_reg
condition|)
break|break;
block|}
if|if
condition|(
name|prev
operator|!=
name|NULL
condition|)
name|STAILQ_INSERT_AFTER
argument_list|(
operator|&
name|dinfo
operator|->
name|cfg
operator|.
name|maps
argument_list|,
name|prev
argument_list|,
name|pm
argument_list|,
name|pm_link
argument_list|)
expr_stmt|;
else|else
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|dinfo
operator|->
name|cfg
operator|.
name|maps
argument_list|,
name|pm
argument_list|,
name|pm_link
argument_list|)
expr_stmt|;
return|return
operator|(
name|pm
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pci_restore_bars
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|struct
name|pci_map
modifier|*
name|pm
decl_stmt|;
name|int
name|ln2range
decl_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|pm
argument_list|,
argument|&dinfo->cfg.maps
argument_list|,
argument|pm_link
argument_list|)
block|{
if|if
condition|(
name|PCIR_IS_BIOS
argument_list|(
operator|&
name|dinfo
operator|->
name|cfg
argument_list|,
name|pm
operator|->
name|pm_reg
argument_list|)
condition|)
name|ln2range
operator|=
literal|32
expr_stmt|;
else|else
name|ln2range
operator|=
name|pci_maprange
argument_list|(
name|pm
operator|->
name|pm_value
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|pm
operator|->
name|pm_reg
argument_list|,
name|pm
operator|->
name|pm_value
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln2range
operator|==
literal|64
condition|)
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|pm
operator|->
name|pm_reg
operator|+
literal|4
argument_list|,
name|pm
operator|->
name|pm_value
operator|>>
literal|32
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Add a resource based on a pci map register. Return 1 if the map  * register is a 32bit map register or 2 if it is a 64bit register.  */
end_comment

begin_function
specifier|static
name|int
name|pci_add_map
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|int
name|reg
parameter_list|,
name|struct
name|resource_list
modifier|*
name|rl
parameter_list|,
name|int
name|force
parameter_list|,
name|int
name|prefetch
parameter_list|)
block|{
name|struct
name|pci_map
modifier|*
name|pm
decl_stmt|;
name|pci_addr_t
name|base
decl_stmt|,
name|map
decl_stmt|,
name|testval
decl_stmt|;
name|pci_addr_t
name|start
decl_stmt|,
name|end
decl_stmt|,
name|count
decl_stmt|;
name|int
name|barlen
decl_stmt|,
name|basezero
decl_stmt|,
name|maprange
decl_stmt|,
name|mapsize
decl_stmt|,
name|type
decl_stmt|;
name|uint16_t
name|cmd
decl_stmt|;
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
comment|/* 	 * The BAR may already exist if the device is a CardBus card 	 * whose CIS is stored in this BAR. 	 */
name|pm
operator|=
name|pci_find_bar
argument_list|(
name|dev
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|pm
operator|!=
name|NULL
condition|)
block|{
name|maprange
operator|=
name|pci_maprange
argument_list|(
name|pm
operator|->
name|pm_value
argument_list|)
expr_stmt|;
name|barlen
operator|=
name|maprange
operator|==
literal|64
condition|?
literal|2
else|:
literal|1
expr_stmt|;
return|return
operator|(
name|barlen
operator|)
return|;
block|}
name|pci_read_bar
argument_list|(
name|dev
argument_list|,
name|reg
argument_list|,
operator|&
name|map
argument_list|,
operator|&
name|testval
argument_list|)
expr_stmt|;
if|if
condition|(
name|PCI_BAR_MEM
argument_list|(
name|map
argument_list|)
condition|)
block|{
name|type
operator|=
name|SYS_RES_MEMORY
expr_stmt|;
if|if
condition|(
name|map
operator|&
name|PCIM_BAR_MEM_PREFETCH
condition|)
name|prefetch
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|type
operator|=
name|SYS_RES_IOPORT
expr_stmt|;
name|mapsize
operator|=
name|pci_mapsize
argument_list|(
name|testval
argument_list|)
expr_stmt|;
name|base
operator|=
name|pci_mapbase
argument_list|(
name|map
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__PCI_BAR_ZERO_VALID
name|basezero
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|basezero
operator|=
name|base
operator|==
literal|0
expr_stmt|;
endif|#
directive|endif
name|maprange
operator|=
name|pci_maprange
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|barlen
operator|=
name|maprange
operator|==
literal|64
condition|?
literal|2
else|:
literal|1
expr_stmt|;
comment|/* 	 * For I/O registers, if bottom bit is set, and the next bit up 	 * isn't clear, we know we have a BAR that doesn't conform to the 	 * spec, so ignore it.  Also, sanity check the size of the data 	 * areas to the type of memory involved.  Memory must be at least 	 * 16 bytes in size, while I/O ranges must be at least 4. 	 */
if|if
condition|(
name|PCI_BAR_IO
argument_list|(
name|testval
argument_list|)
operator|&&
operator|(
name|testval
operator|&
name|PCIM_BAR_IO_RESERVED
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|barlen
operator|)
return|;
if|if
condition|(
operator|(
name|type
operator|==
name|SYS_RES_MEMORY
operator|&&
name|mapsize
operator|<
literal|4
operator|)
operator|||
operator|(
name|type
operator|==
name|SYS_RES_IOPORT
operator|&&
name|mapsize
operator|<
literal|2
operator|)
condition|)
return|return
operator|(
name|barlen
operator|)
return|;
comment|/* Save a record of this BAR. */
name|pm
operator|=
name|pci_add_bar
argument_list|(
name|dev
argument_list|,
name|reg
argument_list|,
name|map
argument_list|,
name|mapsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"\tmap[%02x]: type %s, range %2d, base %#jx, size %2d"
argument_list|,
name|reg
argument_list|,
name|pci_maptype
argument_list|(
name|map
argument_list|)
argument_list|,
name|maprange
argument_list|,
operator|(
name|uintmax_t
operator|)
name|base
argument_list|,
name|mapsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|SYS_RES_IOPORT
operator|&&
operator|!
name|pci_porten
argument_list|(
name|dev
argument_list|)
condition|)
name|printf
argument_list|(
literal|", port disabled\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|SYS_RES_MEMORY
operator|&&
operator|!
name|pci_memen
argument_list|(
name|dev
argument_list|)
condition|)
name|printf
argument_list|(
literal|", memory disabled\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|", enabled\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If base is 0, then we have problems if this architecture does 	 * not allow that.  It is best to ignore such entries for the 	 * moment.  These will be allocated later if the driver specifically 	 * requests them.  However, some removable busses look better when 	 * all resources are allocated, so allow '0' to be overriden. 	 * 	 * Similarly treat maps whose values is the same as the test value 	 * read back.  These maps have had all f's written to them by the 	 * BIOS in an attempt to disable the resources. 	 */
if|if
condition|(
operator|!
name|force
operator|&&
operator|(
name|basezero
operator|||
name|map
operator|==
name|testval
operator|)
condition|)
return|return
operator|(
name|barlen
operator|)
return|;
if|if
condition|(
operator|(
name|u_long
operator|)
name|base
operator|!=
name|base
condition|)
block|{
name|device_printf
argument_list|(
name|bus
argument_list|,
literal|"pci%d:%d:%d:%d bar %#x too many address bits"
argument_list|,
name|pci_get_domain
argument_list|(
name|dev
argument_list|)
argument_list|,
name|pci_get_bus
argument_list|(
name|dev
argument_list|)
argument_list|,
name|pci_get_slot
argument_list|(
name|dev
argument_list|)
argument_list|,
name|pci_get_function
argument_list|(
name|dev
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
name|barlen
operator|)
return|;
block|}
comment|/* 	 * This code theoretically does the right thing, but has 	 * undesirable side effects in some cases where peripherals 	 * respond oddly to having these bits enabled.  Let the user 	 * be able to turn them off (since pci_enable_io_modes is 1 by 	 * default). 	 */
if|if
condition|(
name|pci_enable_io_modes
condition|)
block|{
comment|/* Turn on resources that have been left off by a lazy BIOS */
if|if
condition|(
name|type
operator|==
name|SYS_RES_IOPORT
operator|&&
operator|!
name|pci_porten
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|cmd
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cmd
operator||=
name|PCIM_CMD_PORTEN
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|cmd
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|SYS_RES_MEMORY
operator|&&
operator|!
name|pci_memen
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|cmd
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cmd
operator||=
name|PCIM_CMD_MEMEN
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|cmd
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|type
operator|==
name|SYS_RES_IOPORT
operator|&&
operator|!
name|pci_porten
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
name|barlen
operator|)
return|;
if|if
condition|(
name|type
operator|==
name|SYS_RES_MEMORY
operator|&&
operator|!
name|pci_memen
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
name|barlen
operator|)
return|;
block|}
name|count
operator|=
operator|(
name|pci_addr_t
operator|)
literal|1
operator|<<
name|mapsize
expr_stmt|;
if|if
condition|(
name|basezero
operator|||
name|base
operator|==
name|pci_mapbase
argument_list|(
name|testval
argument_list|)
condition|)
block|{
name|start
operator|=
literal|0
expr_stmt|;
comment|/* Let the parent decide. */
name|end
operator|=
operator|~
literal|0ul
expr_stmt|;
block|}
else|else
block|{
name|start
operator|=
name|base
expr_stmt|;
name|end
operator|=
name|base
operator|+
name|count
operator|-
literal|1
expr_stmt|;
block|}
name|resource_list_add
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
name|reg
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/* 	 * Try to allocate the resource for this BAR from our parent 	 * so that this resource range is already reserved.  The 	 * driver for this device will later inherit this resource in 	 * pci_alloc_resource(). 	 */
name|res
operator|=
name|resource_list_alloc
argument_list|(
name|rl
argument_list|,
name|bus
argument_list|,
name|dev
argument_list|,
name|type
argument_list|,
operator|&
name|reg
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|prefetch
condition|?
name|RF_PREFETCHABLE
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * If the allocation fails, clear the BAR and delete 		 * the resource list entry to force 		 * pci_alloc_resource() to allocate resources from the 		 * parent. 		 */
name|resource_list_delete
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|start
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|start
operator|=
name|rman_get_start
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|rman_set_device
argument_list|(
name|res
argument_list|,
name|bus
argument_list|)
expr_stmt|;
block|}
name|pci_write_bar
argument_list|(
name|dev
argument_list|,
name|pm
argument_list|,
name|start
argument_list|)
expr_stmt|;
return|return
operator|(
name|barlen
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * For ATA devices we need to decide early what addressing mode to use.  * Legacy demands that the primary and secondary ATA ports sits on the  * same addresses that old ISA hardware did. This dictates that we use  * those addresses and ignore the BAR's if we cannot set PCI native  * addressing mode.  */
end_comment

begin_function
specifier|static
name|void
name|pci_ata_maps
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|struct
name|resource_list
modifier|*
name|rl
parameter_list|,
name|int
name|force
parameter_list|,
name|uint32_t
name|prefetchmask
parameter_list|)
block|{
name|struct
name|resource
modifier|*
name|r
decl_stmt|;
name|int
name|rid
decl_stmt|,
name|type
decl_stmt|,
name|progif
decl_stmt|;
if|#
directive|if
literal|0
comment|/* if this device supports PCI native addressing use it */
block|progif = pci_read_config(dev, PCIR_PROGIF, 1); 	if ((progif& 0x8a) == 0x8a) { 		if (pci_mapbase(pci_read_config(dev, PCIR_BAR(0), 4))&& 		    pci_mapbase(pci_read_config(dev, PCIR_BAR(2), 4))) { 			printf("Trying ATA native PCI addressing mode\n"); 			pci_write_config(dev, PCIR_PROGIF, progif | 0x05, 1); 		} 	}
endif|#
directive|endif
name|progif
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PROGIF
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|type
operator|=
name|SYS_RES_IOPORT
expr_stmt|;
if|if
condition|(
name|progif
operator|&
name|PCIP_STORAGE_IDE_MODEPRIM
condition|)
block|{
name|pci_add_map
argument_list|(
name|bus
argument_list|,
name|dev
argument_list|,
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|rl
argument_list|,
name|force
argument_list|,
name|prefetchmask
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
argument_list|)
expr_stmt|;
name|pci_add_map
argument_list|(
name|bus
argument_list|,
name|dev
argument_list|,
name|PCIR_BAR
argument_list|(
literal|1
argument_list|)
argument_list|,
name|rl
argument_list|,
name|force
argument_list|,
name|prefetchmask
operator|&
operator|(
literal|1
operator|<<
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|resource_list_add
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
literal|0x1f0
argument_list|,
literal|0x1f7
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|r
operator|=
name|resource_list_alloc
argument_list|(
name|rl
argument_list|,
name|bus
argument_list|,
name|dev
argument_list|,
name|type
argument_list|,
operator|&
name|rid
argument_list|,
literal|0x1f0
argument_list|,
literal|0x1f7
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rman_set_device
argument_list|(
name|r
argument_list|,
name|bus
argument_list|)
expr_stmt|;
name|rid
operator|=
name|PCIR_BAR
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|resource_list_add
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
literal|0x3f6
argument_list|,
literal|0x3f6
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|r
operator|=
name|resource_list_alloc
argument_list|(
name|rl
argument_list|,
name|bus
argument_list|,
name|dev
argument_list|,
name|type
argument_list|,
operator|&
name|rid
argument_list|,
literal|0x3f6
argument_list|,
literal|0x3f6
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rman_set_device
argument_list|(
name|r
argument_list|,
name|bus
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|progif
operator|&
name|PCIP_STORAGE_IDE_MODESEC
condition|)
block|{
name|pci_add_map
argument_list|(
name|bus
argument_list|,
name|dev
argument_list|,
name|PCIR_BAR
argument_list|(
literal|2
argument_list|)
argument_list|,
name|rl
argument_list|,
name|force
argument_list|,
name|prefetchmask
operator|&
operator|(
literal|1
operator|<<
literal|2
operator|)
argument_list|)
expr_stmt|;
name|pci_add_map
argument_list|(
name|bus
argument_list|,
name|dev
argument_list|,
name|PCIR_BAR
argument_list|(
literal|3
argument_list|)
argument_list|,
name|rl
argument_list|,
name|force
argument_list|,
name|prefetchmask
operator|&
operator|(
literal|1
operator|<<
literal|3
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rid
operator|=
name|PCIR_BAR
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|resource_list_add
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
literal|0x170
argument_list|,
literal|0x177
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|r
operator|=
name|resource_list_alloc
argument_list|(
name|rl
argument_list|,
name|bus
argument_list|,
name|dev
argument_list|,
name|type
argument_list|,
operator|&
name|rid
argument_list|,
literal|0x170
argument_list|,
literal|0x177
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rman_set_device
argument_list|(
name|r
argument_list|,
name|bus
argument_list|)
expr_stmt|;
name|rid
operator|=
name|PCIR_BAR
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|resource_list_add
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
literal|0x376
argument_list|,
literal|0x376
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|r
operator|=
name|resource_list_alloc
argument_list|(
name|rl
argument_list|,
name|bus
argument_list|,
name|dev
argument_list|,
name|type
argument_list|,
operator|&
name|rid
argument_list|,
literal|0x376
argument_list|,
literal|0x376
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rman_set_device
argument_list|(
name|r
argument_list|,
name|bus
argument_list|)
expr_stmt|;
block|}
name|pci_add_map
argument_list|(
name|bus
argument_list|,
name|dev
argument_list|,
name|PCIR_BAR
argument_list|(
literal|4
argument_list|)
argument_list|,
name|rl
argument_list|,
name|force
argument_list|,
name|prefetchmask
operator|&
operator|(
literal|1
operator|<<
literal|4
operator|)
argument_list|)
expr_stmt|;
name|pci_add_map
argument_list|(
name|bus
argument_list|,
name|dev
argument_list|,
name|PCIR_BAR
argument_list|(
literal|5
argument_list|)
argument_list|,
name|rl
argument_list|,
name|force
argument_list|,
name|prefetchmask
operator|&
operator|(
literal|1
operator|<<
literal|5
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pci_assign_interrupt
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|int
name|force_route
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
name|char
name|tunable_name
index|[
literal|64
index|]
decl_stmt|;
name|int
name|irq
decl_stmt|;
comment|/* Has to have an intpin to have an interrupt. */
if|if
condition|(
name|cfg
operator|->
name|intpin
operator|==
literal|0
condition|)
return|return;
comment|/* Let the user override the IRQ with a tunable. */
name|irq
operator|=
name|PCI_INVALID_IRQ
expr_stmt|;
name|snprintf
argument_list|(
name|tunable_name
argument_list|,
sizeof|sizeof
argument_list|(
name|tunable_name
argument_list|)
argument_list|,
literal|"hw.pci%d.%d.%d.INT%c.irq"
argument_list|,
name|cfg
operator|->
name|domain
argument_list|,
name|cfg
operator|->
name|bus
argument_list|,
name|cfg
operator|->
name|slot
argument_list|,
name|cfg
operator|->
name|intpin
operator|+
literal|'A'
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TUNABLE_INT_FETCH
argument_list|(
name|tunable_name
argument_list|,
operator|&
name|irq
argument_list|)
operator|&&
operator|(
name|irq
operator|>=
literal|255
operator|||
name|irq
operator|<=
literal|0
operator|)
condition|)
name|irq
operator|=
name|PCI_INVALID_IRQ
expr_stmt|;
comment|/* 	 * If we didn't get an IRQ via the tunable, then we either use the 	 * IRQ value in the intline register or we ask the bus to route an 	 * interrupt for us.  If force_route is true, then we only use the 	 * value in the intline register if the bus was unable to assign an 	 * IRQ. 	 */
if|if
condition|(
operator|!
name|PCI_INTERRUPT_VALID
argument_list|(
name|irq
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|PCI_INTERRUPT_VALID
argument_list|(
name|cfg
operator|->
name|intline
argument_list|)
operator|||
name|force_route
condition|)
name|irq
operator|=
name|PCI_ASSIGN_INTERRUPT
argument_list|(
name|bus
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PCI_INTERRUPT_VALID
argument_list|(
name|irq
argument_list|)
condition|)
name|irq
operator|=
name|cfg
operator|->
name|intline
expr_stmt|;
block|}
comment|/* If after all that we don't have an IRQ, just bail. */
if|if
condition|(
operator|!
name|PCI_INTERRUPT_VALID
argument_list|(
name|irq
argument_list|)
condition|)
return|return;
comment|/* Update the config register if it changed. */
if|if
condition|(
name|irq
operator|!=
name|cfg
operator|->
name|intline
condition|)
block|{
name|cfg
operator|->
name|intline
operator|=
name|irq
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_INTLINE
argument_list|,
name|irq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Add this IRQ as rid 0 interrupt resource. */
name|resource_list_add
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|irq
argument_list|,
name|irq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform early OHCI takeover from SMM. */
end_comment

begin_function
specifier|static
name|void
name|ohci_early_takeover
parameter_list|(
name|device_t
name|self
parameter_list|)
block|{
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|uint32_t
name|ctl
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|self
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
return|return;
name|ctl
operator|=
name|bus_read_4
argument_list|(
name|res
argument_list|,
name|OHCI_CONTROL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl
operator|&
name|OHCI_IR
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"ohci early: "
literal|"SMM active, request owner change\n"
argument_list|)
expr_stmt|;
name|bus_write_4
argument_list|(
name|res
argument_list|,
name|OHCI_COMMAND_STATUS
argument_list|,
name|OHCI_OCR
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
literal|100
operator|)
operator|&&
operator|(
name|ctl
operator|&
name|OHCI_IR
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|ctl
operator|=
name|bus_read_4
argument_list|(
name|res
argument_list|,
name|OHCI_CONTROL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctl
operator|&
name|OHCI_IR
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"ohci early: "
literal|"SMM does not respond, resetting\n"
argument_list|)
expr_stmt|;
name|bus_write_4
argument_list|(
name|res
argument_list|,
name|OHCI_CONTROL
argument_list|,
name|OHCI_HCFS_RESET
argument_list|)
expr_stmt|;
block|}
comment|/* Disable interrupts */
name|bus_write_4
argument_list|(
name|res
argument_list|,
name|OHCI_INTERRUPT_DISABLE
argument_list|,
name|OHCI_ALL_INTRS
argument_list|)
expr_stmt|;
block|}
name|bus_release_resource
argument_list|(
name|self
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|rid
argument_list|,
name|res
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform early UHCI takeover from SMM. */
end_comment

begin_function
specifier|static
name|void
name|uhci_early_takeover
parameter_list|(
name|device_t
name|self
parameter_list|)
block|{
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|int
name|rid
decl_stmt|;
comment|/* 	 * Set the PIRQD enable bit and switch off all the others. We don't 	 * want legacy support to interfere with us XXX Does this also mean 	 * that the BIOS won't touch the keyboard anymore if it is connected 	 * to the ports of the root hub? 	 */
name|pci_write_config
argument_list|(
name|self
argument_list|,
name|PCI_LEGSUP
argument_list|,
name|PCI_LEGSUP_USBPIRQDEN
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Disable interrupts */
name|rid
operator|=
name|PCI_UHCI_BASE_REG
expr_stmt|;
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|self
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|NULL
condition|)
block|{
name|bus_write_2
argument_list|(
name|res
argument_list|,
name|UHCI_INTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|self
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|rid
argument_list|,
name|res
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Perform early EHCI takeover from SMM. */
end_comment

begin_function
specifier|static
name|void
name|ehci_early_takeover
parameter_list|(
name|device_t
name|self
parameter_list|)
block|{
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|uint32_t
name|cparams
decl_stmt|;
name|uint32_t
name|eec
decl_stmt|;
name|uint8_t
name|eecp
decl_stmt|;
name|uint8_t
name|bios_sem
decl_stmt|;
name|uint8_t
name|offs
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|self
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
return|return;
name|cparams
operator|=
name|bus_read_4
argument_list|(
name|res
argument_list|,
name|EHCI_HCCPARAMS
argument_list|)
expr_stmt|;
comment|/* Synchronise with the BIOS if it owns the controller. */
for|for
control|(
name|eecp
operator|=
name|EHCI_HCC_EECP
argument_list|(
name|cparams
argument_list|)
init|;
name|eecp
operator|!=
literal|0
condition|;
name|eecp
operator|=
name|EHCI_EECP_NEXT
argument_list|(
name|eec
argument_list|)
control|)
block|{
name|eec
operator|=
name|pci_read_config
argument_list|(
name|self
argument_list|,
name|eecp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|EHCI_EECP_ID
argument_list|(
name|eec
argument_list|)
operator|!=
name|EHCI_EC_LEGSUP
condition|)
block|{
continue|continue;
block|}
name|bios_sem
operator|=
name|pci_read_config
argument_list|(
name|self
argument_list|,
name|eecp
operator|+
name|EHCI_LEGSUP_BIOS_SEM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bios_sem
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"ehci early: "
literal|"SMM active, request owner change\n"
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|self
argument_list|,
name|eecp
operator|+
name|EHCI_LEGSUP_OS_SEM
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
literal|100
operator|)
operator|&&
operator|(
name|bios_sem
operator|!=
literal|0
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|bios_sem
operator|=
name|pci_read_config
argument_list|(
name|self
argument_list|,
name|eecp
operator|+
name|EHCI_LEGSUP_BIOS_SEM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bios_sem
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"ehci early: "
literal|"SMM does not respond\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Disable interrupts */
name|offs
operator|=
name|EHCI_CAPLENGTH
argument_list|(
name|bus_read_4
argument_list|(
name|res
argument_list|,
name|EHCI_CAPLEN_HCIVERSION
argument_list|)
argument_list|)
expr_stmt|;
name|bus_write_4
argument_list|(
name|res
argument_list|,
name|offs
operator|+
name|EHCI_USBINTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|bus_release_resource
argument_list|(
name|self
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|rid
argument_list|,
name|res
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pci_add_resources
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|int
name|force
parameter_list|,
name|uint32_t
name|prefetchmask
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
decl_stmt|;
name|struct
name|resource_list
modifier|*
name|rl
decl_stmt|;
specifier|const
name|struct
name|pci_quirk
modifier|*
name|q
decl_stmt|;
name|uint32_t
name|devid
decl_stmt|;
name|int
name|i
decl_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|cfg
operator|=
operator|&
name|dinfo
operator|->
name|cfg
expr_stmt|;
name|rl
operator|=
operator|&
name|dinfo
operator|->
name|resources
expr_stmt|;
name|devid
operator|=
operator|(
name|cfg
operator|->
name|device
operator|<<
literal|16
operator|)
operator||
name|cfg
operator|->
name|vendor
expr_stmt|;
comment|/* ATA devices needs special map treatment */
if|if
condition|(
operator|(
name|pci_get_class
argument_list|(
name|dev
argument_list|)
operator|==
name|PCIC_STORAGE
operator|)
operator|&&
operator|(
name|pci_get_subclass
argument_list|(
name|dev
argument_list|)
operator|==
name|PCIS_STORAGE_IDE
operator|)
operator|&&
operator|(
operator|(
name|pci_get_progif
argument_list|(
name|dev
argument_list|)
operator|&
name|PCIP_STORAGE_IDE_MASTERDEV
operator|)
operator|||
operator|(
operator|!
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|4
argument_list|)
operator|&&
operator|!
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_BAR
argument_list|(
literal|2
argument_list|)
argument_list|,
literal|4
argument_list|)
operator|)
operator|)
condition|)
name|pci_ata_maps
argument_list|(
name|bus
argument_list|,
name|dev
argument_list|,
name|rl
argument_list|,
name|force
argument_list|,
name|prefetchmask
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cfg
operator|->
name|nummaps
condition|;
control|)
block|{
comment|/* 			 * Skip quirked resources. 			 */
for|for
control|(
name|q
operator|=
operator|&
name|pci_quirks
index|[
literal|0
index|]
init|;
name|q
operator|->
name|devid
operator|!=
literal|0
condition|;
name|q
operator|++
control|)
if|if
condition|(
name|q
operator|->
name|devid
operator|==
name|devid
operator|&&
name|q
operator|->
name|type
operator|==
name|PCI_QUIRK_UNMAP_REG
operator|&&
name|q
operator|->
name|arg1
operator|==
name|PCIR_BAR
argument_list|(
name|i
argument_list|)
condition|)
break|break;
if|if
condition|(
name|q
operator|->
name|devid
operator|!=
literal|0
condition|)
block|{
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
name|i
operator|+=
name|pci_add_map
argument_list|(
name|bus
argument_list|,
name|dev
argument_list|,
name|PCIR_BAR
argument_list|(
name|i
argument_list|)
argument_list|,
name|rl
argument_list|,
name|force
argument_list|,
name|prefetchmask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Add additional, quirked resources. 	 */
for|for
control|(
name|q
operator|=
operator|&
name|pci_quirks
index|[
literal|0
index|]
init|;
name|q
operator|->
name|devid
operator|!=
literal|0
condition|;
name|q
operator|++
control|)
if|if
condition|(
name|q
operator|->
name|devid
operator|==
name|devid
operator|&&
name|q
operator|->
name|type
operator|==
name|PCI_QUIRK_MAP_REG
condition|)
name|pci_add_map
argument_list|(
name|bus
argument_list|,
name|dev
argument_list|,
name|q
operator|->
name|arg1
argument_list|,
name|rl
argument_list|,
name|force
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|intpin
operator|>
literal|0
operator|&&
name|PCI_INTERRUPT_VALID
argument_list|(
name|cfg
operator|->
name|intline
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|__PCI_REROUTE_INTERRUPT
comment|/* 		 * Try to re-route interrupts. Sometimes the BIOS or 		 * firmware may leave bogus values in these registers. 		 * If the re-route fails, then just stick with what we 		 * have. 		 */
name|pci_assign_interrupt
argument_list|(
name|bus
argument_list|,
name|dev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|pci_assign_interrupt
argument_list|(
name|bus
argument_list|,
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|pci_usb_takeover
operator|&&
name|pci_get_class
argument_list|(
name|dev
argument_list|)
operator|==
name|PCIC_SERIALBUS
operator|&&
name|pci_get_subclass
argument_list|(
name|dev
argument_list|)
operator|==
name|PCIS_SERIALBUS_USB
condition|)
block|{
if|if
condition|(
name|pci_get_progif
argument_list|(
name|dev
argument_list|)
operator|==
name|PCIP_SERIALBUS_USB_EHCI
condition|)
name|ehci_early_takeover
argument_list|(
name|dev
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pci_get_progif
argument_list|(
name|dev
argument_list|)
operator|==
name|PCIP_SERIALBUS_USB_OHCI
condition|)
name|ohci_early_takeover
argument_list|(
name|dev
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pci_get_progif
argument_list|(
name|dev
argument_list|)
operator|==
name|PCIP_SERIALBUS_USB_UHCI
condition|)
name|uhci_early_takeover
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|pci_add_children
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|domain
parameter_list|,
name|int
name|busno
parameter_list|,
name|size_t
name|dinfo_size
parameter_list|)
block|{
define|#
directive|define
name|REG
parameter_list|(
name|n
parameter_list|,
name|w
parameter_list|)
value|PCIB_READ_CONFIG(pcib, busno, s, f, n, w)
name|device_t
name|pcib
init|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|int
name|maxslots
decl_stmt|;
name|int
name|s
decl_stmt|,
name|f
decl_stmt|,
name|pcifunchigh
decl_stmt|;
name|uint8_t
name|hdrtype
decl_stmt|;
name|KASSERT
argument_list|(
name|dinfo_size
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|pci_devinfo
argument_list|)
argument_list|,
operator|(
literal|"dinfo_size too small"
operator|)
argument_list|)
expr_stmt|;
name|maxslots
operator|=
name|PCIB_MAXSLOTS
argument_list|(
name|pcib
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<=
name|maxslots
condition|;
name|s
operator|++
control|)
block|{
name|pcifunchigh
operator|=
literal|0
expr_stmt|;
name|f
operator|=
literal|0
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|hdrtype
operator|=
name|REG
argument_list|(
name|PCIR_HDRTYPE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hdrtype
operator|&
name|PCIM_HDRTYPE
operator|)
operator|>
name|PCI_MAXHDRTYPE
condition|)
continue|continue;
if|if
condition|(
name|hdrtype
operator|&
name|PCIM_MFDEV
condition|)
name|pcifunchigh
operator|=
name|PCI_FUNCMAX
expr_stmt|;
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<=
name|pcifunchigh
condition|;
name|f
operator|++
control|)
block|{
name|dinfo
operator|=
name|pci_read_device
argument_list|(
name|pcib
argument_list|,
name|domain
argument_list|,
name|busno
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|dinfo_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|dinfo
operator|!=
name|NULL
condition|)
block|{
name|pci_add_child
argument_list|(
name|dev
argument_list|,
name|dinfo
argument_list|)
expr_stmt|;
block|}
block|}
block|}
undef|#
directive|undef
name|REG
block|}
end_function

begin_function
name|void
name|pci_add_child
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|struct
name|pci_devinfo
modifier|*
name|dinfo
parameter_list|)
block|{
name|dinfo
operator|->
name|cfg
operator|.
name|dev
operator|=
name|device_add_child
argument_list|(
name|bus
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|device_set_ivars
argument_list|(
name|dinfo
operator|->
name|cfg
operator|.
name|dev
argument_list|,
name|dinfo
argument_list|)
expr_stmt|;
name|resource_list_init
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|)
expr_stmt|;
name|pci_cfg_save
argument_list|(
name|dinfo
operator|->
name|cfg
operator|.
name|dev
argument_list|,
name|dinfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pci_cfg_restore
argument_list|(
name|dinfo
operator|->
name|cfg
operator|.
name|dev
argument_list|,
name|dinfo
argument_list|)
expr_stmt|;
name|pci_print_verbose
argument_list|(
name|dinfo
argument_list|)
expr_stmt|;
name|pci_add_resources
argument_list|(
name|bus
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|dev
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pci_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"PCI bus"
argument_list|)
expr_stmt|;
comment|/* Allow other subclasses to override this driver. */
return|return
operator|(
name|BUS_PROBE_GENERIC
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_attach_common
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|pci_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|busno
decl_stmt|,
name|domain
decl_stmt|;
ifdef|#
directive|ifdef
name|PCI_DMA_BOUNDARY
name|int
name|error
decl_stmt|,
name|tag_valid
decl_stmt|;
endif|#
directive|endif
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|domain
operator|=
name|pcib_get_domain
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|busno
operator|=
name|pcib_get_bus
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"domain=%d, physical bus=%d\n"
argument_list|,
name|domain
argument_list|,
name|busno
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PCI_DMA_BOUNDARY
name|tag_valid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|device_get_devclass
argument_list|(
name|device_get_parent
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|devclass_find
argument_list|(
literal|"pci"
argument_list|)
condition|)
block|{
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|1
argument_list|,
name|PCI_DMA_BOUNDARY
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|BUS_SPACE_MAXSIZE
argument_list|,
name|BUS_SPACE_UNRESTRICTED
argument_list|,
name|BUS_SPACE_MAXSIZE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|sc_dma_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to create DMA tag: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
else|else
name|tag_valid
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|tag_valid
condition|)
endif|#
directive|endif
name|sc
operator|->
name|sc_dma_tag
operator|=
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pci_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|busno
decl_stmt|,
name|domain
decl_stmt|,
name|error
decl_stmt|;
name|error
operator|=
name|pci_attach_common
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Since there can be multiple independantly numbered PCI 	 * busses on systems with multiple PCI domains, we can't use 	 * the unit number to decide which bus we are probing. We ask 	 * the parent pcib what our domain and bus numbers are. 	 */
name|domain
operator|=
name|pcib_get_domain
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|busno
operator|=
name|pcib_get_bus
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_add_children
argument_list|(
name|dev
argument_list|,
name|domain
argument_list|,
name|busno
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pci_devinfo
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|dstate
decl_stmt|,
name|error
decl_stmt|,
name|i
decl_stmt|,
name|numdevs
decl_stmt|;
name|device_t
name|acpi_dev
decl_stmt|,
name|child
decl_stmt|,
modifier|*
name|devlist
decl_stmt|;
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
comment|/* 	 * Save the PCI configuration space for each child and set the 	 * device in the appropriate power state for this sleep state. 	 */
name|acpi_dev
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|pci_do_power_resume
condition|)
name|acpi_dev
operator|=
name|devclass_get_device
argument_list|(
name|devclass_find
argument_list|(
literal|"acpi"
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|device_get_children
argument_list|(
name|dev
argument_list|,
operator|&
name|devlist
argument_list|,
operator|&
name|numdevs
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numdevs
condition|;
name|i
operator|++
control|)
block|{
name|child
operator|=
name|devlist
index|[
name|i
index|]
expr_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|pci_cfg_save
argument_list|(
name|child
argument_list|,
name|dinfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Suspend devices before potentially powering them down. */
name|error
operator|=
name|bus_generic_suspend
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|devlist
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Always set the device to D3.  If ACPI suggests a different 	 * power state, use it instead.  If ACPI is not present, the 	 * firmware is responsible for managing device power.  Skip 	 * children who aren't attached since they are powered down 	 * separately.  Only manage type 0 devices for now. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|acpi_dev
operator|&&
name|i
operator|<
name|numdevs
condition|;
name|i
operator|++
control|)
block|{
name|child
operator|=
name|devlist
index|[
name|i
index|]
expr_stmt|;
name|dinfo
operator|=
operator|(
expr|struct
name|pci_devinfo
operator|*
operator|)
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_is_attached
argument_list|(
name|child
argument_list|)
operator|&&
name|dinfo
operator|->
name|cfg
operator|.
name|hdrtype
operator|==
literal|0
condition|)
block|{
name|dstate
operator|=
name|PCI_POWERSTATE_D3
expr_stmt|;
name|ACPI_PWR_FOR_SLEEP
argument_list|(
name|acpi_dev
argument_list|,
name|child
argument_list|,
operator|&
name|dstate
argument_list|)
expr_stmt|;
name|pci_set_powerstate
argument_list|(
name|child
argument_list|,
name|dstate
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|devlist
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|numdevs
decl_stmt|,
name|error
decl_stmt|;
name|device_t
name|acpi_dev
decl_stmt|,
name|child
decl_stmt|,
modifier|*
name|devlist
decl_stmt|;
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
comment|/* 	 * Set each child to D0 and restore its PCI configuration space. 	 */
name|acpi_dev
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|pci_do_power_resume
condition|)
name|acpi_dev
operator|=
name|devclass_get_device
argument_list|(
name|devclass_find
argument_list|(
literal|"acpi"
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|device_get_children
argument_list|(
name|dev
argument_list|,
operator|&
name|devlist
argument_list|,
operator|&
name|numdevs
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numdevs
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * Notify ACPI we're going to D0 but ignore the result.  If 		 * ACPI is not present, the firmware is responsible for 		 * managing device power.  Only manage type 0 devices for now. 		 */
name|child
operator|=
name|devlist
index|[
name|i
index|]
expr_stmt|;
name|dinfo
operator|=
operator|(
expr|struct
name|pci_devinfo
operator|*
operator|)
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|acpi_dev
operator|&&
name|device_is_attached
argument_list|(
name|child
argument_list|)
operator|&&
name|dinfo
operator|->
name|cfg
operator|.
name|hdrtype
operator|==
literal|0
condition|)
block|{
name|ACPI_PWR_FOR_SLEEP
argument_list|(
name|acpi_dev
argument_list|,
name|child
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pci_set_powerstate
argument_list|(
name|child
argument_list|,
name|PCI_POWERSTATE_D0
argument_list|)
expr_stmt|;
block|}
comment|/* Now the device is powered up, restore its config space. */
name|pci_cfg_restore
argument_list|(
name|child
argument_list|,
name|dinfo
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|devlist
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|bus_generic_resume
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pci_load_vendor_data
parameter_list|(
name|void
parameter_list|)
block|{
name|caddr_t
name|vendordata
decl_stmt|,
name|info
decl_stmt|;
if|if
condition|(
operator|(
name|vendordata
operator|=
name|preload_search_by_type
argument_list|(
literal|"pci_vendor_data"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|info
operator|=
name|preload_search_info
argument_list|(
name|vendordata
argument_list|,
name|MODINFO_ADDR
argument_list|)
expr_stmt|;
name|pci_vendordata
operator|=
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
name|info
expr_stmt|;
name|info
operator|=
name|preload_search_info
argument_list|(
name|vendordata
argument_list|,
name|MODINFO_SIZE
argument_list|)
expr_stmt|;
name|pci_vendordata_size
operator|=
operator|*
operator|(
name|size_t
operator|*
operator|)
name|info
expr_stmt|;
comment|/* terminate the database */
name|pci_vendordata
index|[
name|pci_vendordata_size
index|]
operator|=
literal|'\n'
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|pci_driver_added
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|driver_t
modifier|*
name|driver
parameter_list|)
block|{
name|int
name|numdevs
decl_stmt|;
name|device_t
modifier|*
name|devlist
decl_stmt|;
name|device_t
name|child
decl_stmt|;
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"driver added\n"
argument_list|)
expr_stmt|;
name|DEVICE_IDENTIFY
argument_list|(
name|driver
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_get_children
argument_list|(
name|dev
argument_list|,
operator|&
name|devlist
argument_list|,
operator|&
name|numdevs
argument_list|)
operator|!=
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numdevs
condition|;
name|i
operator|++
control|)
block|{
name|child
operator|=
name|devlist
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|device_get_state
argument_list|(
name|child
argument_list|)
operator|!=
name|DS_NOTPRESENT
condition|)
continue|continue;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|pci_print_verbose
argument_list|(
name|dinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|pci_printf
argument_list|(
operator|&
name|dinfo
operator|->
name|cfg
argument_list|,
literal|"reprobing on driver added\n"
argument_list|)
expr_stmt|;
name|pci_cfg_restore
argument_list|(
name|child
argument_list|,
name|dinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_probe_and_attach
argument_list|(
name|child
argument_list|)
operator|!=
literal|0
condition|)
name|pci_cfg_save
argument_list|(
name|child
argument_list|,
name|dinfo
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|devlist
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pci_setup_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|resource
modifier|*
name|irq
parameter_list|,
name|int
name|flags
parameter_list|,
name|driver_filter_t
modifier|*
name|filter
parameter_list|,
name|driver_intr_t
modifier|*
name|intr
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|void
modifier|*
modifier|*
name|cookiep
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|struct
name|msix_table_entry
modifier|*
name|mte
decl_stmt|;
name|struct
name|msix_vector
modifier|*
name|mv
decl_stmt|;
name|uint64_t
name|addr
decl_stmt|;
name|uint32_t
name|data
decl_stmt|;
name|void
modifier|*
name|cookie
decl_stmt|;
name|int
name|error
decl_stmt|,
name|rid
decl_stmt|;
name|error
operator|=
name|bus_generic_setup_intr
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|irq
argument_list|,
name|flags
argument_list|,
name|filter
argument_list|,
name|intr
argument_list|,
name|arg
argument_list|,
operator|&
name|cookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* If this is not a direct child, just bail out. */
if|if
condition|(
name|device_get_parent
argument_list|(
name|child
argument_list|)
operator|!=
name|dev
condition|)
block|{
operator|*
name|cookiep
operator|=
name|cookie
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|rid
operator|=
name|rman_get_rid
argument_list|(
name|irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|rid
operator|==
literal|0
condition|)
block|{
comment|/* Make sure that INTx is enabled */
name|pci_clear_command_bit
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|PCIM_CMD_INTxDIS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Check to see if the interrupt is MSI or MSI-X. 		 * Ask our parent to map the MSI and give 		 * us the address and data register values. 		 * If we fail for some reason, teardown the 		 * interrupt handler. 		 */
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|dinfo
operator|->
name|cfg
operator|.
name|msi
operator|.
name|msi_alloc
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|dinfo
operator|->
name|cfg
operator|.
name|msi
operator|.
name|msi_addr
operator|==
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
name|dinfo
operator|->
name|cfg
operator|.
name|msi
operator|.
name|msi_handlers
operator|==
literal|0
argument_list|,
operator|(
literal|"MSI has handlers, but vectors not mapped"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|PCIB_MAP_MSI
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|rman_get_start
argument_list|(
name|irq
argument_list|)
argument_list|,
operator|&
name|addr
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
name|dinfo
operator|->
name|cfg
operator|.
name|msi
operator|.
name|msi_addr
operator|=
name|addr
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|msi
operator|.
name|msi_data
operator|=
name|data
expr_stmt|;
block|}
if|if
condition|(
name|dinfo
operator|->
name|cfg
operator|.
name|msi
operator|.
name|msi_handlers
operator|==
literal|0
condition|)
name|pci_enable_msi
argument_list|(
name|child
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|msi
operator|.
name|msi_addr
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|msi
operator|.
name|msi_data
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|msi
operator|.
name|msi_handlers
operator|++
expr_stmt|;
block|}
else|else
block|{
name|KASSERT
argument_list|(
name|dinfo
operator|->
name|cfg
operator|.
name|msix
operator|.
name|msix_alloc
operator|>
literal|0
argument_list|,
operator|(
literal|"No MSI or MSI-X interrupts allocated"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|rid
operator|<=
name|dinfo
operator|->
name|cfg
operator|.
name|msix
operator|.
name|msix_table_len
argument_list|,
operator|(
literal|"MSI-X index too high"
operator|)
argument_list|)
expr_stmt|;
name|mte
operator|=
operator|&
name|dinfo
operator|->
name|cfg
operator|.
name|msix
operator|.
name|msix_table
index|[
name|rid
operator|-
literal|1
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|mte
operator|->
name|mte_vector
operator|!=
literal|0
argument_list|,
operator|(
literal|"no message vector"
operator|)
argument_list|)
expr_stmt|;
name|mv
operator|=
operator|&
name|dinfo
operator|->
name|cfg
operator|.
name|msix
operator|.
name|msix_vectors
index|[
name|mte
operator|->
name|mte_vector
operator|-
literal|1
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|mv
operator|->
name|mv_irq
operator|==
name|rman_get_start
argument_list|(
name|irq
argument_list|)
argument_list|,
operator|(
literal|"IRQ mismatch"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mv
operator|->
name|mv_address
operator|==
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
name|mte
operator|->
name|mte_handlers
operator|==
literal|0
argument_list|,
operator|(
literal|"MSI-X table entry has handlers, but vector not mapped"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|PCIB_MAP_MSI
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|rman_get_start
argument_list|(
name|irq
argument_list|)
argument_list|,
operator|&
name|addr
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
name|mv
operator|->
name|mv_address
operator|=
name|addr
expr_stmt|;
name|mv
operator|->
name|mv_data
operator|=
name|data
expr_stmt|;
block|}
if|if
condition|(
name|mte
operator|->
name|mte_handlers
operator|==
literal|0
condition|)
block|{
name|pci_enable_msix
argument_list|(
name|child
argument_list|,
name|rid
operator|-
literal|1
argument_list|,
name|mv
operator|->
name|mv_address
argument_list|,
name|mv
operator|->
name|mv_data
argument_list|)
expr_stmt|;
name|pci_unmask_msix
argument_list|(
name|child
argument_list|,
name|rid
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|mte
operator|->
name|mte_handlers
operator|++
expr_stmt|;
block|}
comment|/* Make sure that INTx is disabled if we are using MSI/MSIX */
name|pci_set_command_bit
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|PCIM_CMD_INTxDIS
argument_list|)
expr_stmt|;
name|bad
label|:
if|if
condition|(
name|error
condition|)
block|{
operator|(
name|void
operator|)
name|bus_generic_teardown_intr
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|irq
argument_list|,
name|cookie
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
operator|*
name|cookiep
operator|=
name|cookie
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_teardown_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|resource
modifier|*
name|irq
parameter_list|,
name|void
modifier|*
name|cookie
parameter_list|)
block|{
name|struct
name|msix_table_entry
modifier|*
name|mte
decl_stmt|;
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|int
name|error
decl_stmt|,
name|rid
decl_stmt|;
if|if
condition|(
name|irq
operator|==
name|NULL
operator|||
operator|!
operator|(
name|rman_get_flags
argument_list|(
name|irq
argument_list|)
operator|&
name|RF_ACTIVE
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* If this isn't a direct child, just bail out */
if|if
condition|(
name|device_get_parent
argument_list|(
name|child
argument_list|)
operator|!=
name|dev
condition|)
return|return
operator|(
name|bus_generic_teardown_intr
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|irq
argument_list|,
name|cookie
argument_list|)
operator|)
return|;
name|rid
operator|=
name|rman_get_rid
argument_list|(
name|irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|rid
operator|==
literal|0
condition|)
block|{
comment|/* Mask INTx */
name|pci_set_command_bit
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|PCIM_CMD_INTxDIS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Check to see if the interrupt is MSI or MSI-X.  If so, 		 * decrement the appropriate handlers count and mask the 		 * MSI-X message, or disable MSI messages if the count 		 * drops to 0. 		 */
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|rle
operator|=
name|resource_list_find
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rid
argument_list|)
expr_stmt|;
if|if
condition|(
name|rle
operator|->
name|res
operator|!=
name|irq
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|dinfo
operator|->
name|cfg
operator|.
name|msi
operator|.
name|msi_alloc
operator|>
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
name|rid
operator|<=
name|dinfo
operator|->
name|cfg
operator|.
name|msi
operator|.
name|msi_alloc
argument_list|,
operator|(
literal|"MSI-X index too high"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dinfo
operator|->
name|cfg
operator|.
name|msi
operator|.
name|msi_handlers
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|dinfo
operator|->
name|cfg
operator|.
name|msi
operator|.
name|msi_handlers
operator|--
expr_stmt|;
if|if
condition|(
name|dinfo
operator|->
name|cfg
operator|.
name|msi
operator|.
name|msi_handlers
operator|==
literal|0
condition|)
name|pci_disable_msi
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|KASSERT
argument_list|(
name|dinfo
operator|->
name|cfg
operator|.
name|msix
operator|.
name|msix_alloc
operator|>
literal|0
argument_list|,
operator|(
literal|"No MSI or MSI-X interrupts allocated"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|rid
operator|<=
name|dinfo
operator|->
name|cfg
operator|.
name|msix
operator|.
name|msix_table_len
argument_list|,
operator|(
literal|"MSI-X index too high"
operator|)
argument_list|)
expr_stmt|;
name|mte
operator|=
operator|&
name|dinfo
operator|->
name|cfg
operator|.
name|msix
operator|.
name|msix_table
index|[
name|rid
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|mte
operator|->
name|mte_handlers
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|mte
operator|->
name|mte_handlers
operator|--
expr_stmt|;
if|if
condition|(
name|mte
operator|->
name|mte_handlers
operator|==
literal|0
condition|)
name|pci_mask_msix
argument_list|(
name|child
argument_list|,
name|rid
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|error
operator|=
name|bus_generic_teardown_intr
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|irq
argument_list|,
name|cookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|rid
operator|>
literal|0
condition|)
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: generic teardown failed for MSI/MSI-X"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_print_child
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|struct
name|resource_list
modifier|*
name|rl
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|rl
operator|=
operator|&
name|dinfo
operator|->
name|resources
expr_stmt|;
name|retval
operator|+=
name|bus_print_child_header
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|resource_list_print_type
argument_list|(
name|rl
argument_list|,
literal|"port"
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|"%#lx"
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|resource_list_print_type
argument_list|(
name|rl
argument_list|,
literal|"mem"
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|"%#lx"
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|resource_list_print_type
argument_list|(
name|rl
argument_list|,
literal|"irq"
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|"%ld"
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_get_flags
argument_list|(
name|dev
argument_list|)
condition|)
name|retval
operator|+=
name|printf
argument_list|(
literal|" flags %#x"
argument_list|,
name|device_get_flags
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|printf
argument_list|(
literal|" at device %d.%d"
argument_list|,
name|pci_get_slot
argument_list|(
name|child
argument_list|)
argument_list|,
name|pci_get_function
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|bus_print_child_footer
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_struct
specifier|static
struct|struct
block|{
name|int
name|class
decl_stmt|;
name|int
name|subclass
decl_stmt|;
name|char
modifier|*
name|desc
decl_stmt|;
block|}
name|pci_nomatch_tab
index|[]
init|=
block|{
block|{
name|PCIC_OLD
block|,
operator|-
literal|1
block|,
literal|"old"
block|}
block|,
block|{
name|PCIC_OLD
block|,
name|PCIS_OLD_NONVGA
block|,
literal|"non-VGA display device"
block|}
block|,
block|{
name|PCIC_OLD
block|,
name|PCIS_OLD_VGA
block|,
literal|"VGA-compatible display device"
block|}
block|,
block|{
name|PCIC_STORAGE
block|,
operator|-
literal|1
block|,
literal|"mass storage"
block|}
block|,
block|{
name|PCIC_STORAGE
block|,
name|PCIS_STORAGE_SCSI
block|,
literal|"SCSI"
block|}
block|,
block|{
name|PCIC_STORAGE
block|,
name|PCIS_STORAGE_IDE
block|,
literal|"ATA"
block|}
block|,
block|{
name|PCIC_STORAGE
block|,
name|PCIS_STORAGE_FLOPPY
block|,
literal|"floppy disk"
block|}
block|,
block|{
name|PCIC_STORAGE
block|,
name|PCIS_STORAGE_IPI
block|,
literal|"IPI"
block|}
block|,
block|{
name|PCIC_STORAGE
block|,
name|PCIS_STORAGE_RAID
block|,
literal|"RAID"
block|}
block|,
block|{
name|PCIC_STORAGE
block|,
name|PCIS_STORAGE_ATA_ADMA
block|,
literal|"ATA (ADMA)"
block|}
block|,
block|{
name|PCIC_STORAGE
block|,
name|PCIS_STORAGE_SATA
block|,
literal|"SATA"
block|}
block|,
block|{
name|PCIC_STORAGE
block|,
name|PCIS_STORAGE_SAS
block|,
literal|"SAS"
block|}
block|,
block|{
name|PCIC_STORAGE
block|,
name|PCIS_STORAGE_NVM
block|,
literal|"NVM"
block|}
block|,
block|{
name|PCIC_NETWORK
block|,
operator|-
literal|1
block|,
literal|"network"
block|}
block|,
block|{
name|PCIC_NETWORK
block|,
name|PCIS_NETWORK_ETHERNET
block|,
literal|"ethernet"
block|}
block|,
block|{
name|PCIC_NETWORK
block|,
name|PCIS_NETWORK_TOKENRING
block|,
literal|"token ring"
block|}
block|,
block|{
name|PCIC_NETWORK
block|,
name|PCIS_NETWORK_FDDI
block|,
literal|"fddi"
block|}
block|,
block|{
name|PCIC_NETWORK
block|,
name|PCIS_NETWORK_ATM
block|,
literal|"ATM"
block|}
block|,
block|{
name|PCIC_NETWORK
block|,
name|PCIS_NETWORK_ISDN
block|,
literal|"ISDN"
block|}
block|,
block|{
name|PCIC_DISPLAY
block|,
operator|-
literal|1
block|,
literal|"display"
block|}
block|,
block|{
name|PCIC_DISPLAY
block|,
name|PCIS_DISPLAY_VGA
block|,
literal|"VGA"
block|}
block|,
block|{
name|PCIC_DISPLAY
block|,
name|PCIS_DISPLAY_XGA
block|,
literal|"XGA"
block|}
block|,
block|{
name|PCIC_DISPLAY
block|,
name|PCIS_DISPLAY_3D
block|,
literal|"3D"
block|}
block|,
block|{
name|PCIC_MULTIMEDIA
block|,
operator|-
literal|1
block|,
literal|"multimedia"
block|}
block|,
block|{
name|PCIC_MULTIMEDIA
block|,
name|PCIS_MULTIMEDIA_VIDEO
block|,
literal|"video"
block|}
block|,
block|{
name|PCIC_MULTIMEDIA
block|,
name|PCIS_MULTIMEDIA_AUDIO
block|,
literal|"audio"
block|}
block|,
block|{
name|PCIC_MULTIMEDIA
block|,
name|PCIS_MULTIMEDIA_TELE
block|,
literal|"telephony"
block|}
block|,
block|{
name|PCIC_MULTIMEDIA
block|,
name|PCIS_MULTIMEDIA_HDA
block|,
literal|"HDA"
block|}
block|,
block|{
name|PCIC_MEMORY
block|,
operator|-
literal|1
block|,
literal|"memory"
block|}
block|,
block|{
name|PCIC_MEMORY
block|,
name|PCIS_MEMORY_RAM
block|,
literal|"RAM"
block|}
block|,
block|{
name|PCIC_MEMORY
block|,
name|PCIS_MEMORY_FLASH
block|,
literal|"flash"
block|}
block|,
block|{
name|PCIC_BRIDGE
block|,
operator|-
literal|1
block|,
literal|"bridge"
block|}
block|,
block|{
name|PCIC_BRIDGE
block|,
name|PCIS_BRIDGE_HOST
block|,
literal|"HOST-PCI"
block|}
block|,
block|{
name|PCIC_BRIDGE
block|,
name|PCIS_BRIDGE_ISA
block|,
literal|"PCI-ISA"
block|}
block|,
block|{
name|PCIC_BRIDGE
block|,
name|PCIS_BRIDGE_EISA
block|,
literal|"PCI-EISA"
block|}
block|,
block|{
name|PCIC_BRIDGE
block|,
name|PCIS_BRIDGE_MCA
block|,
literal|"PCI-MCA"
block|}
block|,
block|{
name|PCIC_BRIDGE
block|,
name|PCIS_BRIDGE_PCI
block|,
literal|"PCI-PCI"
block|}
block|,
block|{
name|PCIC_BRIDGE
block|,
name|PCIS_BRIDGE_PCMCIA
block|,
literal|"PCI-PCMCIA"
block|}
block|,
block|{
name|PCIC_BRIDGE
block|,
name|PCIS_BRIDGE_NUBUS
block|,
literal|"PCI-NuBus"
block|}
block|,
block|{
name|PCIC_BRIDGE
block|,
name|PCIS_BRIDGE_CARDBUS
block|,
literal|"PCI-CardBus"
block|}
block|,
block|{
name|PCIC_BRIDGE
block|,
name|PCIS_BRIDGE_RACEWAY
block|,
literal|"PCI-RACEway"
block|}
block|,
block|{
name|PCIC_SIMPLECOMM
block|,
operator|-
literal|1
block|,
literal|"simple comms"
block|}
block|,
block|{
name|PCIC_SIMPLECOMM
block|,
name|PCIS_SIMPLECOMM_UART
block|,
literal|"UART"
block|}
block|,
comment|/* could detect 16550 */
block|{
name|PCIC_SIMPLECOMM
block|,
name|PCIS_SIMPLECOMM_PAR
block|,
literal|"parallel port"
block|}
block|,
block|{
name|PCIC_SIMPLECOMM
block|,
name|PCIS_SIMPLECOMM_MULSER
block|,
literal|"multiport serial"
block|}
block|,
block|{
name|PCIC_SIMPLECOMM
block|,
name|PCIS_SIMPLECOMM_MODEM
block|,
literal|"generic modem"
block|}
block|,
block|{
name|PCIC_BASEPERIPH
block|,
operator|-
literal|1
block|,
literal|"base peripheral"
block|}
block|,
block|{
name|PCIC_BASEPERIPH
block|,
name|PCIS_BASEPERIPH_PIC
block|,
literal|"interrupt controller"
block|}
block|,
block|{
name|PCIC_BASEPERIPH
block|,
name|PCIS_BASEPERIPH_DMA
block|,
literal|"DMA controller"
block|}
block|,
block|{
name|PCIC_BASEPERIPH
block|,
name|PCIS_BASEPERIPH_TIMER
block|,
literal|"timer"
block|}
block|,
block|{
name|PCIC_BASEPERIPH
block|,
name|PCIS_BASEPERIPH_RTC
block|,
literal|"realtime clock"
block|}
block|,
block|{
name|PCIC_BASEPERIPH
block|,
name|PCIS_BASEPERIPH_PCIHOT
block|,
literal|"PCI hot-plug controller"
block|}
block|,
block|{
name|PCIC_BASEPERIPH
block|,
name|PCIS_BASEPERIPH_SDHC
block|,
literal|"SD host controller"
block|}
block|,
block|{
name|PCIC_INPUTDEV
block|,
operator|-
literal|1
block|,
literal|"input device"
block|}
block|,
block|{
name|PCIC_INPUTDEV
block|,
name|PCIS_INPUTDEV_KEYBOARD
block|,
literal|"keyboard"
block|}
block|,
block|{
name|PCIC_INPUTDEV
block|,
name|PCIS_INPUTDEV_DIGITIZER
block|,
literal|"digitizer"
block|}
block|,
block|{
name|PCIC_INPUTDEV
block|,
name|PCIS_INPUTDEV_MOUSE
block|,
literal|"mouse"
block|}
block|,
block|{
name|PCIC_INPUTDEV
block|,
name|PCIS_INPUTDEV_SCANNER
block|,
literal|"scanner"
block|}
block|,
block|{
name|PCIC_INPUTDEV
block|,
name|PCIS_INPUTDEV_GAMEPORT
block|,
literal|"gameport"
block|}
block|,
block|{
name|PCIC_DOCKING
block|,
operator|-
literal|1
block|,
literal|"docking station"
block|}
block|,
block|{
name|PCIC_PROCESSOR
block|,
operator|-
literal|1
block|,
literal|"processor"
block|}
block|,
block|{
name|PCIC_SERIALBUS
block|,
operator|-
literal|1
block|,
literal|"serial bus"
block|}
block|,
block|{
name|PCIC_SERIALBUS
block|,
name|PCIS_SERIALBUS_FW
block|,
literal|"FireWire"
block|}
block|,
block|{
name|PCIC_SERIALBUS
block|,
name|PCIS_SERIALBUS_ACCESS
block|,
literal|"AccessBus"
block|}
block|,
block|{
name|PCIC_SERIALBUS
block|,
name|PCIS_SERIALBUS_SSA
block|,
literal|"SSA"
block|}
block|,
block|{
name|PCIC_SERIALBUS
block|,
name|PCIS_SERIALBUS_USB
block|,
literal|"USB"
block|}
block|,
block|{
name|PCIC_SERIALBUS
block|,
name|PCIS_SERIALBUS_FC
block|,
literal|"Fibre Channel"
block|}
block|,
block|{
name|PCIC_SERIALBUS
block|,
name|PCIS_SERIALBUS_SMBUS
block|,
literal|"SMBus"
block|}
block|,
block|{
name|PCIC_WIRELESS
block|,
operator|-
literal|1
block|,
literal|"wireless controller"
block|}
block|,
block|{
name|PCIC_WIRELESS
block|,
name|PCIS_WIRELESS_IRDA
block|,
literal|"iRDA"
block|}
block|,
block|{
name|PCIC_WIRELESS
block|,
name|PCIS_WIRELESS_IR
block|,
literal|"IR"
block|}
block|,
block|{
name|PCIC_WIRELESS
block|,
name|PCIS_WIRELESS_RF
block|,
literal|"RF"
block|}
block|,
block|{
name|PCIC_INTELLIIO
block|,
operator|-
literal|1
block|,
literal|"intelligent I/O controller"
block|}
block|,
block|{
name|PCIC_INTELLIIO
block|,
name|PCIS_INTELLIIO_I2O
block|,
literal|"I2O"
block|}
block|,
block|{
name|PCIC_SATCOM
block|,
operator|-
literal|1
block|,
literal|"satellite communication"
block|}
block|,
block|{
name|PCIC_SATCOM
block|,
name|PCIS_SATCOM_TV
block|,
literal|"sat TV"
block|}
block|,
block|{
name|PCIC_SATCOM
block|,
name|PCIS_SATCOM_AUDIO
block|,
literal|"sat audio"
block|}
block|,
block|{
name|PCIC_SATCOM
block|,
name|PCIS_SATCOM_VOICE
block|,
literal|"sat voice"
block|}
block|,
block|{
name|PCIC_SATCOM
block|,
name|PCIS_SATCOM_DATA
block|,
literal|"sat data"
block|}
block|,
block|{
name|PCIC_CRYPTO
block|,
operator|-
literal|1
block|,
literal|"encrypt/decrypt"
block|}
block|,
block|{
name|PCIC_CRYPTO
block|,
name|PCIS_CRYPTO_NETCOMP
block|,
literal|"network/computer crypto"
block|}
block|,
block|{
name|PCIC_CRYPTO
block|,
name|PCIS_CRYPTO_ENTERTAIN
block|,
literal|"entertainment crypto"
block|}
block|,
block|{
name|PCIC_DASP
block|,
operator|-
literal|1
block|,
literal|"dasp"
block|}
block|,
block|{
name|PCIC_DASP
block|,
name|PCIS_DASP_DPIO
block|,
literal|"DPIO module"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_function
name|void
name|pci_probe_nomatch
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|scp
decl_stmt|,
modifier|*
name|device
decl_stmt|;
comment|/* 	 * Look for a listing for this device in a loaded device database. 	 */
if|if
condition|(
operator|(
name|device
operator|=
name|pci_describe_device
argument_list|(
name|child
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"<%s>"
argument_list|,
name|device
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|device
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Scan the class/subclass descriptions for a general 		 * description. 		 */
name|cp
operator|=
literal|"unknown"
expr_stmt|;
name|scp
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|pci_nomatch_tab
index|[
name|i
index|]
operator|.
name|desc
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pci_nomatch_tab
index|[
name|i
index|]
operator|.
name|class
operator|==
name|pci_get_class
argument_list|(
name|child
argument_list|)
condition|)
block|{
if|if
condition|(
name|pci_nomatch_tab
index|[
name|i
index|]
operator|.
name|subclass
operator|==
operator|-
literal|1
condition|)
block|{
name|cp
operator|=
name|pci_nomatch_tab
index|[
name|i
index|]
operator|.
name|desc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pci_nomatch_tab
index|[
name|i
index|]
operator|.
name|subclass
operator|==
name|pci_get_subclass
argument_list|(
name|child
argument_list|)
condition|)
block|{
name|scp
operator|=
name|pci_nomatch_tab
index|[
name|i
index|]
operator|.
name|desc
expr_stmt|;
block|}
block|}
block|}
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"<%s%s%s>"
argument_list|,
name|cp
condition|?
name|cp
else|:
literal|""
argument_list|,
operator|(
operator|(
name|cp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|scp
operator|!=
name|NULL
operator|)
operator|)
condition|?
literal|", "
else|:
literal|""
argument_list|,
name|scp
condition|?
name|scp
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" at device %d.%d (no driver attached)\n"
argument_list|,
name|pci_get_slot
argument_list|(
name|child
argument_list|)
argument_list|,
name|pci_get_function
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
name|pci_cfg_save
argument_list|(
name|child
argument_list|,
name|device_get_ivars
argument_list|(
name|child
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Parse the PCI device database, if loaded, and return a pointer to a  * description of the device.  *  * The database is flat text formatted as follows:  *  * Any line not in a valid format is ignored.  * Lines are terminated with newline '\n' characters.  *  * A VENDOR line consists of the 4 digit (hex) vendor code, a TAB, then  * the vendor name.  *  * A DEVICE line is entered immediately below the corresponding VENDOR ID.  * - devices cannot be listed without a corresponding VENDOR line.  * A DEVICE line consists of a TAB, the 4 digit (hex) device code,  * another TAB, then the device name.  */
end_comment

begin_comment
comment|/*  * Assuming (ptr) points to the beginning of a line in the database,  * return the vendor or device and description of the next entry.  * The value of (vendor) or (device) inappropriate for the entry type  * is set to -1.  Returns nonzero at the end of the database.  *  * Note that this is slightly unrobust in the face of corrupt data;  * we attempt to safeguard against this by spamming the end of the  * database with a newline when we initialise.  */
end_comment

begin_function
specifier|static
name|int
name|pci_describe_parse_line
parameter_list|(
name|char
modifier|*
modifier|*
name|ptr
parameter_list|,
name|int
modifier|*
name|vendor
parameter_list|,
name|int
modifier|*
name|device
parameter_list|,
name|char
modifier|*
modifier|*
name|desc
parameter_list|)
block|{
name|char
modifier|*
name|cp
init|=
operator|*
name|ptr
decl_stmt|;
name|int
name|left
decl_stmt|;
operator|*
name|device
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|vendor
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
operator|*
name|desc
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|left
operator|=
name|pci_vendordata_size
operator|-
operator|(
name|cp
operator|-
name|pci_vendordata
operator|)
expr_stmt|;
if|if
condition|(
name|left
operator|<=
literal|0
condition|)
block|{
operator|*
name|ptr
operator|=
name|cp
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* vendor entry? */
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'\t'
operator|&&
name|sscanf
argument_list|(
name|cp
argument_list|,
literal|"%x\t%80[^\n]"
argument_list|,
name|vendor
argument_list|,
operator|*
name|desc
argument_list|)
operator|==
literal|2
condition|)
break|break;
comment|/* device entry? */
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\t'
operator|&&
name|sscanf
argument_list|(
name|cp
argument_list|,
literal|"%x\t%80[^\n]"
argument_list|,
name|device
argument_list|,
operator|*
name|desc
argument_list|)
operator|==
literal|2
condition|)
break|break;
comment|/* skip to next line */
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\n'
operator|&&
name|left
operator|>
literal|0
condition|)
block|{
name|cp
operator|++
expr_stmt|;
name|left
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\n'
condition|)
block|{
name|cp
operator|++
expr_stmt|;
name|left
operator|--
expr_stmt|;
block|}
block|}
comment|/* skip to next line */
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\n'
operator|&&
name|left
operator|>
literal|0
condition|)
block|{
name|cp
operator|++
expr_stmt|;
name|left
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\n'
operator|&&
name|left
operator|>
literal|0
condition|)
name|cp
operator|++
expr_stmt|;
operator|*
name|ptr
operator|=
name|cp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|pci_describe_device
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|vendor
decl_stmt|,
name|device
decl_stmt|;
name|char
modifier|*
name|desc
decl_stmt|,
modifier|*
name|vp
decl_stmt|,
modifier|*
name|dp
decl_stmt|,
modifier|*
name|line
decl_stmt|;
name|desc
operator|=
name|vp
operator|=
name|dp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * If we have no vendor data, we can't do anything. 	 */
if|if
condition|(
name|pci_vendordata
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Scan the vendor data looking for this device 	 */
name|line
operator|=
name|pci_vendordata
expr_stmt|;
if|if
condition|(
operator|(
name|vp
operator|=
name|malloc
argument_list|(
literal|80
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|pci_describe_parse_line
argument_list|(
operator|&
name|line
argument_list|,
operator|&
name|vendor
argument_list|,
operator|&
name|device
argument_list|,
operator|&
name|vp
argument_list|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|vendor
operator|==
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|dp
operator|=
name|malloc
argument_list|(
literal|80
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|pci_describe_parse_line
argument_list|(
operator|&
name|line
argument_list|,
operator|&
name|vendor
argument_list|,
operator|&
name|device
argument_list|,
operator|&
name|dp
argument_list|)
condition|)
block|{
operator|*
name|dp
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|vendor
operator|!=
operator|-
literal|1
condition|)
block|{
operator|*
name|dp
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|device
operator|==
name|pci_get_device
argument_list|(
name|dev
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|dp
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|snprintf
argument_list|(
name|dp
argument_list|,
literal|80
argument_list|,
literal|"0x%x"
argument_list|,
name|pci_get_device
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|desc
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|vp
argument_list|)
operator|+
name|strlen
argument_list|(
name|dp
argument_list|)
operator|+
literal|3
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|sprintf
argument_list|(
name|desc
argument_list|,
literal|"%s, %s"
argument_list|,
name|vp
argument_list|,
name|dp
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|vp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|vp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|dp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|desc
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_read_ivar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|which
parameter_list|,
name|uintptr_t
modifier|*
name|result
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
decl_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|cfg
operator|=
operator|&
name|dinfo
operator|->
name|cfg
expr_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|PCI_IVAR_ETHADDR
case|:
comment|/* 		 * The generic accessor doesn't deal with failure, so 		 * we set the return value, then return an error. 		 */
operator|*
operator|(
operator|(
name|uint8_t
operator|*
operator|*
operator|)
name|result
operator|)
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
case|case
name|PCI_IVAR_SUBVENDOR
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|subvendor
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_SUBDEVICE
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|subdevice
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_VENDOR
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|vendor
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_DEVICE
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|device
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_DEVID
case|:
operator|*
name|result
operator|=
operator|(
name|cfg
operator|->
name|device
operator|<<
literal|16
operator|)
operator||
name|cfg
operator|->
name|vendor
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_CLASS
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|baseclass
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_SUBCLASS
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|subclass
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_PROGIF
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|progif
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_REVID
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|revid
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_INTPIN
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|intpin
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_IRQ
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|intline
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_DOMAIN
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|domain
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_BUS
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|bus
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_SLOT
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|slot
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_FUNCTION
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|func
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_CMDREG
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|cmdreg
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_CACHELNSZ
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|cachelnsz
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_MINGNT
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|mingnt
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_MAXLAT
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|maxlat
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_LATTIMER
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|lattimer
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_write_ivar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|which
parameter_list|,
name|uintptr_t
name|value
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|PCI_IVAR_INTPIN
case|:
name|dinfo
operator|->
name|cfg
operator|.
name|intpin
operator|=
name|value
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|PCI_IVAR_ETHADDR
case|:
case|case
name|PCI_IVAR_SUBVENDOR
case|:
case|case
name|PCI_IVAR_SUBDEVICE
case|:
case|case
name|PCI_IVAR_VENDOR
case|:
case|case
name|PCI_IVAR_DEVICE
case|:
case|case
name|PCI_IVAR_DEVID
case|:
case|case
name|PCI_IVAR_CLASS
case|:
case|case
name|PCI_IVAR_SUBCLASS
case|:
case|case
name|PCI_IVAR_PROGIF
case|:
case|case
name|PCI_IVAR_REVID
case|:
case|case
name|PCI_IVAR_IRQ
case|:
case|case
name|PCI_IVAR_DOMAIN
case|:
case|case
name|PCI_IVAR_BUS
case|:
case|case
name|PCI_IVAR_SLOT
case|:
case|case
name|PCI_IVAR_FUNCTION
case|:
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* disallow for now */
default|default:
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
block|}
end_function

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_include
include|#
directive|include
file|<sys/cons.h>
end_include

begin_comment
comment|/*  * List resources based on pci map registers, used for within ddb  */
end_comment

begin_macro
name|DB_SHOW_COMMAND
argument_list|(
argument|pciregs
argument_list|,
argument|db_pci_dump
argument_list|)
end_macro

begin_block
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|struct
name|devlist
modifier|*
name|devlist_head
decl_stmt|;
name|struct
name|pci_conf
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|,
name|none_count
decl_stmt|;
name|none_count
operator|=
literal|0
expr_stmt|;
comment|/* get the head of the device queue */
name|devlist_head
operator|=
operator|&
name|pci_devq
expr_stmt|;
comment|/* 	 * Go through the list of devices and print out devices 	 */
for|for
control|(
name|error
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
operator|,
name|dinfo
operator|=
name|STAILQ_FIRST
argument_list|(
name|devlist_head
argument_list|)
init|;
operator|(
name|dinfo
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|error
operator|==
literal|0
operator|)
operator|&&
operator|(
name|i
operator|<
name|pci_numdevs
operator|)
operator|&&
operator|!
name|db_pager_quit
condition|;
name|dinfo
operator|=
name|STAILQ_NEXT
argument_list|(
name|dinfo
argument_list|,
name|pci_links
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
comment|/* Populate pd_name and pd_unit */
name|name
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dinfo
operator|->
name|cfg
operator|.
name|dev
condition|)
name|name
operator|=
name|device_get_name
argument_list|(
name|dinfo
operator|->
name|cfg
operator|.
name|dev
argument_list|)
expr_stmt|;
name|p
operator|=
operator|&
name|dinfo
operator|->
name|conf
expr_stmt|;
name|db_printf
argument_list|(
literal|"%s%d@pci%d:%d:%d:%d:\tclass=0x%06x card=0x%08x "
literal|"chip=0x%08x rev=0x%02x hdr=0x%02x\n"
argument_list|,
operator|(
name|name
operator|&&
operator|*
name|name
operator|)
condition|?
name|name
else|:
literal|"none"
argument_list|,
operator|(
name|name
operator|&&
operator|*
name|name
operator|)
condition|?
operator|(
name|int
operator|)
name|device_get_unit
argument_list|(
name|dinfo
operator|->
name|cfg
operator|.
name|dev
argument_list|)
else|:
name|none_count
operator|++
argument_list|,
name|p
operator|->
name|pc_sel
operator|.
name|pc_domain
argument_list|,
name|p
operator|->
name|pc_sel
operator|.
name|pc_bus
argument_list|,
name|p
operator|->
name|pc_sel
operator|.
name|pc_dev
argument_list|,
name|p
operator|->
name|pc_sel
operator|.
name|pc_func
argument_list|,
operator|(
name|p
operator|->
name|pc_class
operator|<<
literal|16
operator|)
operator||
operator|(
name|p
operator|->
name|pc_subclass
operator|<<
literal|8
operator|)
operator||
name|p
operator|->
name|pc_progif
argument_list|,
operator|(
name|p
operator|->
name|pc_subdevice
operator|<<
literal|16
operator|)
operator||
name|p
operator|->
name|pc_subvendor
argument_list|,
operator|(
name|p
operator|->
name|pc_device
operator|<<
literal|16
operator|)
operator||
name|p
operator|->
name|pc_vendor
argument_list|,
name|p
operator|->
name|pc_revid
argument_list|,
name|p
operator|->
name|pc_hdr
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DDB */
end_comment

begin_function
specifier|static
name|struct
name|resource
modifier|*
name|pci_alloc_map
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|rid
parameter_list|,
name|u_long
name|start
parameter_list|,
name|u_long
name|end
parameter_list|,
name|u_long
name|count
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|struct
name|resource_list
modifier|*
name|rl
init|=
operator|&
name|dinfo
operator|->
name|resources
decl_stmt|;
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|struct
name|pci_map
modifier|*
name|pm
decl_stmt|;
name|pci_addr_t
name|map
decl_stmt|,
name|testval
decl_stmt|;
name|int
name|mapsize
decl_stmt|;
name|res
operator|=
name|NULL
expr_stmt|;
name|pm
operator|=
name|pci_find_bar
argument_list|(
name|child
argument_list|,
operator|*
name|rid
argument_list|)
expr_stmt|;
if|if
condition|(
name|pm
operator|!=
name|NULL
condition|)
block|{
comment|/* This is a BAR that we failed to allocate earlier. */
name|mapsize
operator|=
name|pm
operator|->
name|pm_size
expr_stmt|;
name|map
operator|=
name|pm
operator|->
name|pm_value
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Weed out the bogons, and figure out how large the 		 * BAR/map is.  BARs that read back 0 here are bogus 		 * and unimplemented.  Note: atapci in legacy mode are 		 * special and handled elsewhere in the code.  If you 		 * have a atapci device in legacy mode and it fails 		 * here, that other code is broken. 		 */
name|pci_read_bar
argument_list|(
name|child
argument_list|,
operator|*
name|rid
argument_list|,
operator|&
name|map
argument_list|,
operator|&
name|testval
argument_list|)
expr_stmt|;
comment|/* 		 * Determine the size of the BAR and ignore BARs with a size 		 * of 0.  Device ROM BARs use a different mask value. 		 */
if|if
condition|(
name|PCIR_IS_BIOS
argument_list|(
operator|&
name|dinfo
operator|->
name|cfg
argument_list|,
operator|*
name|rid
argument_list|)
condition|)
name|mapsize
operator|=
name|pci_romsize
argument_list|(
name|testval
argument_list|)
expr_stmt|;
else|else
name|mapsize
operator|=
name|pci_mapsize
argument_list|(
name|testval
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapsize
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
name|pm
operator|=
name|pci_add_bar
argument_list|(
name|child
argument_list|,
operator|*
name|rid
argument_list|,
name|map
argument_list|,
name|mapsize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|PCI_BAR_MEM
argument_list|(
name|map
argument_list|)
operator|||
name|PCIR_IS_BIOS
argument_list|(
operator|&
name|dinfo
operator|->
name|cfg
argument_list|,
operator|*
name|rid
argument_list|)
condition|)
block|{
if|if
condition|(
name|type
operator|!=
name|SYS_RES_MEMORY
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"child %s requested type %d for rid %#x,"
literal|" but the BAR says it is an memio\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|child
argument_list|)
argument_list|,
name|type
argument_list|,
operator|*
name|rid
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|type
operator|!=
name|SYS_RES_IOPORT
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"child %s requested type %d for rid %#x,"
literal|" but the BAR says it is an ioport\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|child
argument_list|)
argument_list|,
name|type
argument_list|,
operator|*
name|rid
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
comment|/* 	 * For real BARs, we need to override the size that 	 * the driver requests, because that's what the BAR 	 * actually uses and we would otherwise have a 	 * situation where we might allocate the excess to 	 * another driver, which won't work. 	 */
name|count
operator|=
operator|(
name|pci_addr_t
operator|)
literal|1
operator|<<
name|mapsize
expr_stmt|;
if|if
condition|(
name|RF_ALIGNMENT
argument_list|(
name|flags
argument_list|)
operator|<
name|mapsize
condition|)
name|flags
operator|=
operator|(
name|flags
operator|&
operator|~
name|RF_ALIGNMENT_MASK
operator|)
operator||
name|RF_ALIGNMENT_LOG2
argument_list|(
name|mapsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|PCI_BAR_MEM
argument_list|(
name|map
argument_list|)
operator|&&
operator|(
name|map
operator|&
name|PCIM_BAR_MEM_PREFETCH
operator|)
condition|)
name|flags
operator||=
name|RF_PREFETCHABLE
expr_stmt|;
comment|/* 	 * Allocate enough resource, and then write back the 	 * appropriate BAR for that resource. 	 */
name|res
operator|=
name|BUS_ALLOC_RESOURCE
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
operator|&
operator|~
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|child
argument_list|,
literal|"%#lx bytes of rid %#x res %d failed (%#lx, %#lx).\n"
argument_list|,
name|count
argument_list|,
operator|*
name|rid
argument_list|,
name|type
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|rman_set_device
argument_list|(
name|res
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|resource_list_add
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
operator|*
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|rle
operator|=
name|resource_list_find
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
operator|*
name|rid
argument_list|)
expr_stmt|;
if|if
condition|(
name|rle
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"pci_alloc_map: unexpectedly can't find resource."
argument_list|)
expr_stmt|;
name|rle
operator|->
name|res
operator|=
name|res
expr_stmt|;
name|rle
operator|->
name|start
operator|=
name|rman_get_start
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|rle
operator|->
name|end
operator|=
name|rman_get_end
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|rle
operator|->
name|count
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|child
argument_list|,
literal|"Lazy allocation of %#lx bytes rid %#x type %d at %#lx\n"
argument_list|,
name|count
argument_list|,
operator|*
name|rid
argument_list|,
name|type
argument_list|,
name|rman_get_start
argument_list|(
name|res
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|=
name|rman_get_start
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|pci_write_bar
argument_list|(
name|child
argument_list|,
name|pm
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|out
label|:
empty_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|resource
modifier|*
name|pci_alloc_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|rid
parameter_list|,
name|u_long
name|start
parameter_list|,
name|u_long
name|end
parameter_list|,
name|u_long
name|count
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|struct
name|resource_list
modifier|*
name|rl
init|=
operator|&
name|dinfo
operator|->
name|resources
decl_stmt|;
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
if|if
condition|(
name|device_get_parent
argument_list|(
name|child
argument_list|)
operator|!=
name|dev
condition|)
return|return
operator|(
name|BUS_ALLOC_RESOURCE
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
operator|)
return|;
comment|/* 	 * Perform lazy resource allocation 	 */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SYS_RES_IRQ
case|:
comment|/* 		 * Can't alloc legacy interrupt once MSI messages have 		 * been allocated. 		 */
if|if
condition|(
operator|*
name|rid
operator|==
literal|0
operator|&&
operator|(
name|cfg
operator|->
name|msi
operator|.
name|msi_alloc
operator|>
literal|0
operator|||
name|cfg
operator|->
name|msix
operator|.
name|msix_alloc
operator|>
literal|0
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 		 * If the child device doesn't have an interrupt 		 * routed and is deserving of an interrupt, try to 		 * assign it one. 		 */
if|if
condition|(
operator|*
name|rid
operator|==
literal|0
operator|&&
operator|!
name|PCI_INTERRUPT_VALID
argument_list|(
name|cfg
operator|->
name|intline
argument_list|)
operator|&&
operator|(
name|cfg
operator|->
name|intpin
operator|!=
literal|0
operator|)
condition|)
name|pci_assign_interrupt
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYS_RES_IOPORT
case|:
case|case
name|SYS_RES_MEMORY
case|:
ifdef|#
directive|ifdef
name|NEW_PCIB
comment|/* 		 * PCI-PCI bridge I/O window resources are not BARs. 		 * For those allocations just pass the request up the 		 * tree. 		 */
if|if
condition|(
name|cfg
operator|->
name|hdrtype
operator|==
name|PCIM_HDRTYPE_BRIDGE
condition|)
block|{
switch|switch
condition|(
operator|*
name|rid
condition|)
block|{
case|case
name|PCIR_IOBASEL_1
case|:
case|case
name|PCIR_MEMBASE_1
case|:
case|case
name|PCIR_PMBASEL_1
case|:
comment|/* 				 * XXX: Should we bother creating a resource 				 * list entry? 				 */
return|return
operator|(
name|bus_generic_alloc_resource
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
block|}
endif|#
directive|endif
comment|/* Allocate resources for this BAR if needed. */
name|rle
operator|=
name|resource_list_find
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
operator|*
name|rid
argument_list|)
expr_stmt|;
if|if
condition|(
name|rle
operator|==
name|NULL
condition|)
block|{
name|res
operator|=
name|pci_alloc_map
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|rle
operator|=
name|resource_list_find
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
operator|*
name|rid
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If the resource belongs to the bus, then give it to 		 * the child.  We need to activate it if requested 		 * since the bus always allocates inactive resources. 		 */
if|if
condition|(
name|rle
operator|!=
name|NULL
operator|&&
name|rle
operator|->
name|res
operator|!=
name|NULL
operator|&&
name|rman_get_device
argument_list|(
name|rle
operator|->
name|res
argument_list|)
operator|==
name|dev
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|child
argument_list|,
literal|"Reserved %#lx bytes for rid %#x type %d at %#lx\n"
argument_list|,
name|rman_get_size
argument_list|(
name|rle
operator|->
name|res
argument_list|)
argument_list|,
operator|*
name|rid
argument_list|,
name|type
argument_list|,
name|rman_get_start
argument_list|(
name|rle
operator|->
name|res
argument_list|)
argument_list|)
expr_stmt|;
name|rman_set_device
argument_list|(
name|rle
operator|->
name|res
argument_list|,
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|RF_ACTIVE
operator|)
operator|&&
name|bus_activate_resource
argument_list|(
name|child
argument_list|,
name|type
argument_list|,
operator|*
name|rid
argument_list|,
name|rle
operator|->
name|res
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|rle
operator|->
name|res
operator|)
return|;
block|}
block|}
return|return
operator|(
name|resource_list_alloc
argument_list|(
name|rl
argument_list|,
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_release_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|device_get_parent
argument_list|(
name|child
argument_list|)
operator|!=
name|dev
condition|)
return|return
operator|(
name|BUS_RELEASE_RESOURCE
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
operator|)
return|;
comment|/* 	 * For BARs we don't actually want to release the resource. 	 * Instead, we deactivate the resource if needed and then give 	 * ownership of the BAR back to the bus. 	 */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SYS_RES_IOPORT
case|:
case|case
name|SYS_RES_MEMORY
case|:
if|if
condition|(
name|rman_get_device
argument_list|(
name|r
argument_list|)
operator|!=
name|child
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|rman_get_flags
argument_list|(
name|r
argument_list|)
operator|&
name|RF_ACTIVE
condition|)
block|{
name|error
operator|=
name|bus_deactivate_resource
argument_list|(
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|rman_set_device
argument_list|(
name|r
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|bus_generic_rl_release_resource
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_activate_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|bus_generic_activate_resource
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Enable decoding in the command register when activating BARs. */
if|if
condition|(
name|device_get_parent
argument_list|(
name|child
argument_list|)
operator|==
name|dev
condition|)
block|{
comment|/* Device ROMs need their decoding explicitly enabled. */
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|SYS_RES_MEMORY
operator|&&
name|PCIR_IS_BIOS
argument_list|(
operator|&
name|dinfo
operator|->
name|cfg
argument_list|,
name|rid
argument_list|)
condition|)
name|pci_write_bar
argument_list|(
name|child
argument_list|,
name|pci_find_bar
argument_list|(
name|child
argument_list|,
name|rid
argument_list|)
argument_list|,
name|rman_get_start
argument_list|(
name|r
argument_list|)
operator||
name|PCIM_BIOS_ENABLE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SYS_RES_IOPORT
case|:
case|case
name|SYS_RES_MEMORY
case|:
name|error
operator|=
name|PCI_ENABLE_IO
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_deactivate_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|bus_generic_deactivate_resource
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Disable decoding for device ROMs. */
if|if
condition|(
name|device_get_parent
argument_list|(
name|child
argument_list|)
operator|==
name|dev
condition|)
block|{
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|SYS_RES_MEMORY
operator|&&
name|PCIR_IS_BIOS
argument_list|(
operator|&
name|dinfo
operator|->
name|cfg
argument_list|,
name|rid
argument_list|)
condition|)
name|pci_write_bar
argument_list|(
name|child
argument_list|,
name|pci_find_bar
argument_list|(
name|child
argument_list|,
name|rid
argument_list|)
argument_list|,
name|rman_get_start
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pci_delete_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|struct
name|resource_list
modifier|*
name|rl
decl_stmt|;
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
if|if
condition|(
name|device_get_parent
argument_list|(
name|child
argument_list|)
operator|!=
name|dev
condition|)
return|return;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|rl
operator|=
operator|&
name|dinfo
operator|->
name|resources
expr_stmt|;
name|rle
operator|=
name|resource_list_find
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
name|rid
argument_list|)
expr_stmt|;
if|if
condition|(
name|rle
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|rle
operator|->
name|res
condition|)
block|{
if|if
condition|(
name|rman_get_device
argument_list|(
name|rle
operator|->
name|res
argument_list|)
operator|!=
name|dev
operator|||
name|rman_get_flags
argument_list|(
name|rle
operator|->
name|res
argument_list|)
operator|&
name|RF_ACTIVE
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"delete_resource: "
literal|"Resource still owned by child, oops. "
literal|"(type=%d, rid=%d, addr=%lx)\n"
argument_list|,
name|rle
operator|->
name|type
argument_list|,
name|rle
operator|->
name|rid
argument_list|,
name|rman_get_start
argument_list|(
name|rle
operator|->
name|res
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
ifndef|#
directive|ifndef
name|__PCI_BAR_ZERO_VALID
comment|/* 		 * If this is a BAR, clear the BAR so it stops 		 * decoding before releasing the resource. 		 */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SYS_RES_IOPORT
case|:
case|case
name|SYS_RES_MEMORY
case|:
name|pci_write_bar
argument_list|(
name|child
argument_list|,
name|pci_find_bar
argument_list|(
name|child
argument_list|,
name|rid
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|rle
operator|->
name|res
argument_list|)
expr_stmt|;
block|}
name|resource_list_delete
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
name|rid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|resource_list
modifier|*
name|pci_get_resource_list
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
return|return
operator|(
operator|&
name|dinfo
operator|->
name|resources
operator|)
return|;
block|}
end_function

begin_function
name|bus_dma_tag_t
name|pci_get_dma_tag
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|pci_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|bus
argument_list|)
decl_stmt|;
return|return
operator|(
name|sc
operator|->
name|sc_dma_tag
operator|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|pci_read_config_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|width
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
return|return
operator|(
name|PCIB_READ_CONFIG
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|cfg
operator|->
name|bus
argument_list|,
name|cfg
operator|->
name|slot
argument_list|,
name|cfg
operator|->
name|func
argument_list|,
name|reg
argument_list|,
name|width
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pci_write_config_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|reg
parameter_list|,
name|uint32_t
name|val
parameter_list|,
name|int
name|width
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
name|PCIB_WRITE_CONFIG
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|cfg
operator|->
name|bus
argument_list|,
name|cfg
operator|->
name|slot
argument_list|,
name|cfg
operator|->
name|func
argument_list|,
name|reg
argument_list|,
name|val
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pci_child_location_str_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
literal|"slot=%d function=%d"
argument_list|,
name|pci_get_slot
argument_list|(
name|child
argument_list|)
argument_list|,
name|pci_get_function
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_child_pnpinfo_str_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
decl_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|cfg
operator|=
operator|&
name|dinfo
operator|->
name|cfg
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
literal|"vendor=0x%04x device=0x%04x subvendor=0x%04x "
literal|"subdevice=0x%04x class=0x%02x%02x%02x"
argument_list|,
name|cfg
operator|->
name|vendor
argument_list|,
name|cfg
operator|->
name|device
argument_list|,
name|cfg
operator|->
name|subvendor
argument_list|,
name|cfg
operator|->
name|subdevice
argument_list|,
name|cfg
operator|->
name|baseclass
argument_list|,
name|cfg
operator|->
name|subclass
argument_list|,
name|cfg
operator|->
name|progif
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_assign_interrupt_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
return|return
operator|(
name|PCIB_ROUTE_INTERRUPT
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|cfg
operator|->
name|intpin
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pci_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|what
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
specifier|static
name|struct
name|cdev
modifier|*
name|pci_cdev
decl_stmt|;
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|STAILQ_INIT
argument_list|(
operator|&
name|pci_devq
argument_list|)
expr_stmt|;
name|pci_generation
operator|=
literal|0
expr_stmt|;
name|pci_cdev
operator|=
name|make_dev
argument_list|(
operator|&
name|pcicdev
argument_list|,
literal|0
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0644
argument_list|,
literal|"pci"
argument_list|)
expr_stmt|;
name|pci_load_vendor_data
argument_list|()
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|destroy_dev
argument_list|(
name|pci_cdev
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pci_cfg_restore
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|pci_devinfo
modifier|*
name|dinfo
parameter_list|)
block|{
comment|/* 	 * Only do header type 0 devices.  Type 1 devices are bridges, 	 * which we know need special treatment.  Type 2 devices are 	 * cardbus bridges which also require special treatment. 	 * Other types are unknown, and we err on the side of safety 	 * by ignoring them. 	 */
if|if
condition|(
name|dinfo
operator|->
name|cfg
operator|.
name|hdrtype
operator|!=
literal|0
condition|)
return|return;
comment|/* 	 * Restore the device to full power mode.  We must do this 	 * before we restore the registers because moving from D3 to 	 * D0 will cause the chip's BARs and some other registers to 	 * be reset to some unknown power on reset values.  Cut down 	 * the noise on boot by doing nothing if we are already in 	 * state D0. 	 */
if|if
condition|(
name|pci_get_powerstate
argument_list|(
name|dev
argument_list|)
operator|!=
name|PCI_POWERSTATE_D0
condition|)
name|pci_set_powerstate
argument_list|(
name|dev
argument_list|,
name|PCI_POWERSTATE_D0
argument_list|)
expr_stmt|;
name|pci_restore_bars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|cmdreg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_INTLINE
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|intline
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_INTPIN
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|intpin
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_MINGNT
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|mingnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_MAXLAT
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|maxlat
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_CACHELNSZ
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|cachelnsz
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_LATTIMER
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|lattimer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PROGIF
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|progif
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_REVID
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|revid
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Restore MSI and MSI-X configurations if they are present. */
if|if
condition|(
name|dinfo
operator|->
name|cfg
operator|.
name|msi
operator|.
name|msi_location
operator|!=
literal|0
condition|)
name|pci_resume_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dinfo
operator|->
name|cfg
operator|.
name|msix
operator|.
name|msix_location
operator|!=
literal|0
condition|)
name|pci_resume_msix
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pci_cfg_save
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|pci_devinfo
modifier|*
name|dinfo
parameter_list|,
name|int
name|setstate
parameter_list|)
block|{
name|uint32_t
name|cls
decl_stmt|;
name|int
name|ps
decl_stmt|;
comment|/* 	 * Only do header type 0 devices.  Type 1 devices are bridges, which 	 * we know need special treatment.  Type 2 devices are cardbus bridges 	 * which also require special treatment.  Other types are unknown, and 	 * we err on the side of safety by ignoring them.  Powering down 	 * bridges should not be undertaken lightly. 	 */
if|if
condition|(
name|dinfo
operator|->
name|cfg
operator|.
name|hdrtype
operator|!=
literal|0
condition|)
return|return;
comment|/* 	 * Some drivers apparently write to these registers w/o updating our 	 * cached copy.  No harm happens if we update the copy, so do so here 	 * so we can restore them.  The COMMAND register is modified by the 	 * bus w/o updating the cache.  This should represent the normally 	 * writable portion of the 'defined' part of type 0 headers.  In 	 * theory we also need to save/restore the PCI capability structures 	 * we know about, but apart from power we don't know any that are 	 * writable. 	 */
name|dinfo
operator|->
name|cfg
operator|.
name|subvendor
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SUBVEND_0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|subdevice
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SUBDEV_0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|vendor
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_VENDOR
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|device
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_DEVICE
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|cmdreg
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|intline
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_INTLINE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|intpin
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_INTPIN
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|mingnt
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_MINGNT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|maxlat
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_MAXLAT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|cachelnsz
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_CACHELNSZ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|lattimer
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_LATTIMER
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|baseclass
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_CLASS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|subclass
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SUBCLASS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|progif
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PROGIF
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|revid
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_REVID
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * don't set the state for display devices, base peripherals and 	 * memory devices since bad things happen when they are powered down. 	 * We should (a) have drivers that can easily detach and (b) use 	 * generic drivers for these devices so that some device actually 	 * attaches.  We need to make sure that when we implement (a) we don't 	 * power the device down on a reattach. 	 */
name|cls
operator|=
name|pci_get_class
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|setstate
condition|)
return|return;
switch|switch
condition|(
name|pci_do_power_nodriver
condition|)
block|{
case|case
literal|0
case|:
comment|/* NO powerdown at all */
return|return;
case|case
literal|1
case|:
comment|/* Conservative about what to power down */
if|if
condition|(
name|cls
operator|==
name|PCIC_STORAGE
condition|)
return|return;
comment|/*FALLTHROUGH*/
case|case
literal|2
case|:
comment|/* Agressive about what to power down */
if|if
condition|(
name|cls
operator|==
name|PCIC_DISPLAY
operator|||
name|cls
operator|==
name|PCIC_MEMORY
operator|||
name|cls
operator|==
name|PCIC_BASEPERIPH
condition|)
return|return;
comment|/*FALLTHROUGH*/
case|case
literal|3
case|:
comment|/* Power down everything */
break|break;
block|}
comment|/* 	 * PCI spec says we can only go into D3 state from D0 state. 	 * Transition from D[12] into D0 before going to D3 state. 	 */
name|ps
operator|=
name|pci_get_powerstate
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|!=
name|PCI_POWERSTATE_D0
operator|&&
name|ps
operator|!=
name|PCI_POWERSTATE_D3
condition|)
name|pci_set_powerstate
argument_list|(
name|dev
argument_list|,
name|PCI_POWERSTATE_D0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_get_powerstate
argument_list|(
name|dev
argument_list|)
operator|!=
name|PCI_POWERSTATE_D3
condition|)
name|pci_set_powerstate
argument_list|(
name|dev
argument_list|,
name|PCI_POWERSTATE_D3
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Wrapper APIs suitable for device driver use. */
end_comment

begin_function
name|void
name|pci_save_state
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_cfg_save
argument_list|(
name|dev
argument_list|,
name|dinfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pci_restore_state
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_cfg_restore
argument_list|(
name|dev
argument_list|,
name|dinfo
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

