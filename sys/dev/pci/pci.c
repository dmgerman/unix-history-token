begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1997, Stefan Esser<se@freebsd.org>  * Copyright (c) 2000, Michael Smith<msmith@freebsd.org>  * Copyright (c) 2000, BSDi  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_bus.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<machine/intr_machdep.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/pciio.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pci_private.h>
end_include

begin_include
include|#
directive|include
file|"pcib_if.h"
end_include

begin_include
include|#
directive|include
file|"pci_if.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__HAVE_ACPI
end_ifdef

begin_include
include|#
directive|include
file|<contrib/dev/acpica/acpi.h>
end_include

begin_include
include|#
directive|include
file|"acpi_if.h"
end_include

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ACPI_PWR_FOR_SLEEP
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|uint32_t
name|pci_mapbase
parameter_list|(
name|unsigned
name|mapreg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_maptype
parameter_list|(
name|unsigned
name|mapreg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_mapsize
parameter_list|(
name|unsigned
name|testval
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_maprange
parameter_list|(
name|unsigned
name|mapreg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pci_fixancient
parameter_list|(
name|pcicfgregs
modifier|*
name|cfg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_porten
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|s
parameter_list|,
name|int
name|f
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_memen
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|s
parameter_list|,
name|int
name|f
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pci_assign_interrupt
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|int
name|force_route
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_add_map
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|s
parameter_list|,
name|int
name|f
parameter_list|,
name|int
name|reg
parameter_list|,
name|struct
name|resource_list
modifier|*
name|rl
parameter_list|,
name|int
name|force
parameter_list|,
name|int
name|prefetch
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pci_load_vendor_data
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_describe_parse_line
parameter_list|(
name|char
modifier|*
modifier|*
name|ptr
parameter_list|,
name|int
modifier|*
name|vendor
parameter_list|,
name|int
modifier|*
name|device
parameter_list|,
name|char
modifier|*
modifier|*
name|desc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|pci_describe_device
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|what
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pci_hdrtypedata
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|s
parameter_list|,
name|int
name|f
parameter_list|,
name|pcicfgregs
modifier|*
name|cfg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pci_read_extcap
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|pcicfgregs
modifier|*
name|cfg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|pci_read_vpd_reg
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|pcicfgregs
modifier|*
name|cfg
parameter_list|,
name|int
name|reg
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void		pci_write_vpd_reg(device_t pcib, pcicfgregs *cfg, 			    int reg, uint32_t data);
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|pci_read_vpd
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|pcicfgregs
modifier|*
name|cfg
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|pci_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|pci_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|pci_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|bus_generic_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bus_generic_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|pci_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|pci_resume
argument_list|)
block|,
comment|/* Bus interface */
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|pci_print_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_probe_nomatch
argument_list|,
name|pci_probe_nomatch
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_read_ivar
argument_list|,
name|pci_read_ivar
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_write_ivar
argument_list|,
name|pci_write_ivar
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_driver_added
argument_list|,
name|pci_driver_added
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_setup_intr
argument_list|,
name|bus_generic_setup_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_teardown_intr
argument_list|,
name|bus_generic_teardown_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_get_resource_list
argument_list|,
name|pci_get_resource_list
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_set_resource
argument_list|,
name|bus_generic_rl_set_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_get_resource
argument_list|,
name|bus_generic_rl_get_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_delete_resource
argument_list|,
name|pci_delete_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_alloc_resource
argument_list|,
name|pci_alloc_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_release_resource
argument_list|,
name|bus_generic_rl_release_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_activate_resource
argument_list|,
name|bus_generic_activate_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_deactivate_resource
argument_list|,
name|bus_generic_deactivate_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_child_pnpinfo_str
argument_list|,
name|pci_child_pnpinfo_str_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_child_location_str
argument_list|,
name|pci_child_location_str_method
argument_list|)
block|,
comment|/* PCI interface */
name|DEVMETHOD
argument_list|(
name|pci_read_config
argument_list|,
name|pci_read_config_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_write_config
argument_list|,
name|pci_write_config_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_enable_busmaster
argument_list|,
name|pci_enable_busmaster_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_disable_busmaster
argument_list|,
name|pci_disable_busmaster_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_enable_io
argument_list|,
name|pci_enable_io_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_disable_io
argument_list|,
name|pci_disable_io_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_get_vpd_ident
argument_list|,
name|pci_get_vpd_ident_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_get_vpd_readonly
argument_list|,
name|pci_get_vpd_readonly_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_get_powerstate
argument_list|,
name|pci_get_powerstate_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_set_powerstate
argument_list|,
name|pci_set_powerstate_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_assign_interrupt
argument_list|,
name|pci_assign_interrupt_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_find_extcap
argument_list|,
name|pci_find_extcap_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_alloc_msi
argument_list|,
name|pci_alloc_msi_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_release_msi
argument_list|,
name|pci_release_msi_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_msi_count
argument_list|,
name|pci_msi_count_method
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DEFINE_CLASS_0
argument_list|(
name|pci
argument_list|,
name|pci_driver
argument_list|,
name|pci_methods
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|pci_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|pci
argument_list|,
name|pcib
argument_list|,
name|pci_driver
argument_list|,
name|pci_devclass
argument_list|,
name|pci_modevent
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|pci
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pci_vendordata
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|pci_vendordata_size
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|pci_quirk
block|{
name|uint32_t
name|devid
decl_stmt|;
comment|/* Vendor/device of the card */
name|int
name|type
decl_stmt|;
define|#
directive|define
name|PCI_QUIRK_MAP_REG
value|1
comment|/* PCI map register in weird place */
define|#
directive|define
name|PCI_QUIRK_DISABLE_MSI
value|2
comment|/* MSI/MSI-X doesn't work */
name|int
name|arg1
decl_stmt|;
name|int
name|arg2
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|pci_quirk
name|pci_quirks
index|[]
init|=
block|{
comment|/* The Intel 82371AB and 82443MX has a map register at offset 0x90. */
block|{
literal|0x71138086
block|,
name|PCI_QUIRK_MAP_REG
block|,
literal|0x90
block|,
literal|0
block|}
block|,
block|{
literal|0x719b8086
block|,
name|PCI_QUIRK_MAP_REG
block|,
literal|0x90
block|,
literal|0
block|}
block|,
comment|/* As does the Serverworks OSB4 (the SMBus mapping register) */
block|{
literal|0x02001166
block|,
name|PCI_QUIRK_MAP_REG
block|,
literal|0x90
block|,
literal|0
block|}
block|,
comment|/* 	 * MSI doesn't work with the ServerWorks CNB20-HE Host Bridge 	 * or the CMIC-SL (AKA ServerWorks GC_LE). 	 */
block|{
literal|0x00141166
block|,
name|PCI_QUIRK_DISABLE_MSI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0x00171166
block|,
name|PCI_QUIRK_DISABLE_MSI
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* 	 * MSI doesn't work on earlier Intel chipsets including 	 * E7500, E7501, E7505, E7210, and 855. 	 */
block|{
literal|0x25408086
block|,
name|PCI_QUIRK_DISABLE_MSI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0x254c8086
block|,
name|PCI_QUIRK_DISABLE_MSI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0x25508086
block|,
name|PCI_QUIRK_DISABLE_MSI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0x25788086
block|,
name|PCI_QUIRK_DISABLE_MSI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0x35808086
block|,
name|PCI_QUIRK_DISABLE_MSI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* map register information */
end_comment

begin_define
define|#
directive|define
name|PCI_MAPMEM
value|0x01
end_define

begin_comment
comment|/* memory map */
end_comment

begin_define
define|#
directive|define
name|PCI_MAPMEMP
value|0x02
end_define

begin_comment
comment|/* prefetchable memory map */
end_comment

begin_define
define|#
directive|define
name|PCI_MAPPORT
value|0x04
end_define

begin_comment
comment|/* port map */
end_comment

begin_decl_stmt
name|struct
name|devlist
name|pci_devq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|pci_generation
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|pci_numdevs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sysctl vars */
end_comment

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|pci
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"PCI bus tuning parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|pci_enable_io_modes
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.pci.enable_io_modes"
argument_list|,
operator|&
name|pci_enable_io_modes
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_pci
argument_list|,
name|OID_AUTO
argument_list|,
name|enable_io_modes
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|pci_enable_io_modes
argument_list|,
literal|1
argument_list|,
literal|"Enable I/O and memory bits in the config register.  Some BIOSes do not\n\ enable these bits correctly.  We'd like to do this all the time, but there\n\ are some peripherals that this causes problems with."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|pci_do_power_nodriver
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.pci.do_power_nodriver"
argument_list|,
operator|&
name|pci_do_power_nodriver
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_pci
argument_list|,
name|OID_AUTO
argument_list|,
name|do_power_nodriver
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|pci_do_power_nodriver
argument_list|,
literal|0
argument_list|,
literal|"Place a function into D3 state when no driver attaches to it.  0 means\n\ disable.  1 means conservatively place devices into D3 state.  2 means\n\ agressively place devices into D3 state.  3 means put absolutely everything\n\ in D3 state."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|pci_do_power_resume
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.pci.do_power_resume"
argument_list|,
operator|&
name|pci_do_power_resume
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_pci
argument_list|,
name|OID_AUTO
argument_list|,
name|do_power_resume
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|pci_do_power_resume
argument_list|,
literal|1
argument_list|,
literal|"Transition from D3 -> D0 on resume."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|pci_do_msi
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.pci.enable_msi"
argument_list|,
operator|&
name|pci_do_msi
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_pci
argument_list|,
name|OID_AUTO
argument_list|,
name|enable_msi
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|pci_do_msi
argument_list|,
literal|1
argument_list|,
literal|"Enable support for MSI interrupts"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|pci_do_msix
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.pci.enable_msix"
argument_list|,
operator|&
name|pci_do_msix
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_pci
argument_list|,
name|OID_AUTO
argument_list|,
name|enable_msix
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|pci_do_msix
argument_list|,
literal|1
argument_list|,
literal|"Enable support for MSI-X interrupts"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|pci_honor_msi_blacklist
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.pci.honor_msi_blacklist"
argument_list|,
operator|&
name|pci_honor_msi_blacklist
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_pci
argument_list|,
name|OID_AUTO
argument_list|,
name|honor_msi_blacklist
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pci_honor_msi_blacklist
argument_list|,
literal|1
argument_list|,
literal|"Honor chipset blacklist for MSI"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Find a device_t by bus/slot/function */
end_comment

begin_function
name|device_t
name|pci_find_bsf
parameter_list|(
name|uint8_t
name|bus
parameter_list|,
name|uint8_t
name|slot
parameter_list|,
name|uint8_t
name|func
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|dinfo
argument_list|,
argument|&pci_devq
argument_list|,
argument|pci_links
argument_list|)
block|{
if|if
condition|(
operator|(
name|dinfo
operator|->
name|cfg
operator|.
name|bus
operator|==
name|bus
operator|)
operator|&&
operator|(
name|dinfo
operator|->
name|cfg
operator|.
name|slot
operator|==
name|slot
operator|)
operator|&&
operator|(
name|dinfo
operator|->
name|cfg
operator|.
name|func
operator|==
name|func
operator|)
condition|)
block|{
return|return
operator|(
name|dinfo
operator|->
name|cfg
operator|.
name|dev
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Find a device_t by vendor/device ID */
end_comment

begin_function
name|device_t
name|pci_find_device
parameter_list|(
name|uint16_t
name|vendor
parameter_list|,
name|uint16_t
name|device
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|dinfo
argument_list|,
argument|&pci_devq
argument_list|,
argument|pci_links
argument_list|)
block|{
if|if
condition|(
operator|(
name|dinfo
operator|->
name|cfg
operator|.
name|vendor
operator|==
name|vendor
operator|)
operator|&&
operator|(
name|dinfo
operator|->
name|cfg
operator|.
name|device
operator|==
name|device
operator|)
condition|)
block|{
return|return
operator|(
name|dinfo
operator|->
name|cfg
operator|.
name|dev
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* return base address of memory or port map */
end_comment

begin_function
specifier|static
name|uint32_t
name|pci_mapbase
parameter_list|(
name|uint32_t
name|mapreg
parameter_list|)
block|{
name|int
name|mask
init|=
literal|0x03
decl_stmt|;
if|if
condition|(
operator|(
name|mapreg
operator|&
literal|0x01
operator|)
operator|==
literal|0
condition|)
name|mask
operator|=
literal|0x0f
expr_stmt|;
return|return
operator|(
name|mapreg
operator|&
operator|~
name|mask
operator|)
return|;
block|}
end_function

begin_comment
comment|/* return map type of memory or port map */
end_comment

begin_function
specifier|static
name|int
name|pci_maptype
parameter_list|(
name|unsigned
name|mapreg
parameter_list|)
block|{
specifier|static
name|uint8_t
name|maptype
index|[
literal|0x10
index|]
init|=
block|{
name|PCI_MAPMEM
block|,
name|PCI_MAPPORT
block|,
name|PCI_MAPMEM
block|,
literal|0
block|,
name|PCI_MAPMEM
block|,
name|PCI_MAPPORT
block|,
literal|0
block|,
literal|0
block|,
name|PCI_MAPMEM
operator||
name|PCI_MAPMEMP
block|,
name|PCI_MAPPORT
block|,
name|PCI_MAPMEM
operator||
name|PCI_MAPMEMP
block|,
literal|0
block|,
name|PCI_MAPMEM
operator||
name|PCI_MAPMEMP
block|,
name|PCI_MAPPORT
block|,
literal|0
block|,
literal|0
block|, 	}
decl_stmt|;
return|return
name|maptype
index|[
name|mapreg
operator|&
literal|0x0f
index|]
return|;
block|}
end_function

begin_comment
comment|/* return log2 of map size decoded for memory or port map */
end_comment

begin_function
specifier|static
name|int
name|pci_mapsize
parameter_list|(
name|uint32_t
name|testval
parameter_list|)
block|{
name|int
name|ln2size
decl_stmt|;
name|testval
operator|=
name|pci_mapbase
argument_list|(
name|testval
argument_list|)
expr_stmt|;
name|ln2size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|testval
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
operator|(
name|testval
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|ln2size
operator|++
expr_stmt|;
name|testval
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ln2size
operator|)
return|;
block|}
end_function

begin_comment
comment|/* return log2 of address range supported by map register */
end_comment

begin_function
specifier|static
name|int
name|pci_maprange
parameter_list|(
name|unsigned
name|mapreg
parameter_list|)
block|{
name|int
name|ln2range
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|mapreg
operator|&
literal|0x07
condition|)
block|{
case|case
literal|0x00
case|:
case|case
literal|0x01
case|:
case|case
literal|0x05
case|:
name|ln2range
operator|=
literal|32
expr_stmt|;
break|break;
case|case
literal|0x02
case|:
name|ln2range
operator|=
literal|20
expr_stmt|;
break|break;
case|case
literal|0x04
case|:
name|ln2range
operator|=
literal|64
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|ln2range
operator|)
return|;
block|}
end_function

begin_comment
comment|/* adjust some values from PCI 1.0 devices to match 2.0 standards ... */
end_comment

begin_function
specifier|static
name|void
name|pci_fixancient
parameter_list|(
name|pcicfgregs
modifier|*
name|cfg
parameter_list|)
block|{
if|if
condition|(
name|cfg
operator|->
name|hdrtype
operator|!=
literal|0
condition|)
return|return;
comment|/* PCI to PCI bridges use header type 1 */
if|if
condition|(
name|cfg
operator|->
name|baseclass
operator|==
name|PCIC_BRIDGE
operator|&&
name|cfg
operator|->
name|subclass
operator|==
name|PCIS_BRIDGE_PCI
condition|)
name|cfg
operator|->
name|hdrtype
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* extract header type specific config data */
end_comment

begin_function
specifier|static
name|void
name|pci_hdrtypedata
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|s
parameter_list|,
name|int
name|f
parameter_list|,
name|pcicfgregs
modifier|*
name|cfg
parameter_list|)
block|{
define|#
directive|define
name|REG
parameter_list|(
name|n
parameter_list|,
name|w
parameter_list|)
value|PCIB_READ_CONFIG(pcib, b, s, f, n, w)
switch|switch
condition|(
name|cfg
operator|->
name|hdrtype
condition|)
block|{
case|case
literal|0
case|:
name|cfg
operator|->
name|subvendor
operator|=
name|REG
argument_list|(
name|PCIR_SUBVEND_0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|subdevice
operator|=
name|REG
argument_list|(
name|PCIR_SUBDEV_0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|nummaps
operator|=
name|PCI_MAXMAPS_0
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|cfg
operator|->
name|subvendor
operator|=
name|REG
argument_list|(
name|PCIR_SUBVEND_1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|subdevice
operator|=
name|REG
argument_list|(
name|PCIR_SUBDEV_1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|nummaps
operator|=
name|PCI_MAXMAPS_1
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|cfg
operator|->
name|subvendor
operator|=
name|REG
argument_list|(
name|PCIR_SUBVEND_2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|subdevice
operator|=
name|REG
argument_list|(
name|PCIR_SUBDEV_2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|nummaps
operator|=
name|PCI_MAXMAPS_2
expr_stmt|;
break|break;
block|}
undef|#
directive|undef
name|REG
block|}
end_function

begin_comment
comment|/* read configuration header into pcicfgregs structure */
end_comment

begin_function
name|struct
name|pci_devinfo
modifier|*
name|pci_read_device
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|s
parameter_list|,
name|int
name|f
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
define|#
directive|define
name|REG
parameter_list|(
name|n
parameter_list|,
name|w
parameter_list|)
value|PCIB_READ_CONFIG(pcib, b, s, f, n, w)
name|pcicfgregs
modifier|*
name|cfg
init|=
name|NULL
decl_stmt|;
name|struct
name|pci_devinfo
modifier|*
name|devlist_entry
decl_stmt|;
name|struct
name|devlist
modifier|*
name|devlist_head
decl_stmt|;
name|devlist_head
operator|=
operator|&
name|pci_devq
expr_stmt|;
name|devlist_entry
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|REG
argument_list|(
name|PCIR_DEVVENDOR
argument_list|,
literal|4
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|devlist_entry
operator|=
name|malloc
argument_list|(
name|size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|devlist_entry
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|cfg
operator|=
operator|&
name|devlist_entry
operator|->
name|cfg
expr_stmt|;
name|cfg
operator|->
name|bus
operator|=
name|b
expr_stmt|;
name|cfg
operator|->
name|slot
operator|=
name|s
expr_stmt|;
name|cfg
operator|->
name|func
operator|=
name|f
expr_stmt|;
name|cfg
operator|->
name|vendor
operator|=
name|REG
argument_list|(
name|PCIR_VENDOR
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|device
operator|=
name|REG
argument_list|(
name|PCIR_DEVICE
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|cmdreg
operator|=
name|REG
argument_list|(
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|statreg
operator|=
name|REG
argument_list|(
name|PCIR_STATUS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|baseclass
operator|=
name|REG
argument_list|(
name|PCIR_CLASS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|subclass
operator|=
name|REG
argument_list|(
name|PCIR_SUBCLASS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|progif
operator|=
name|REG
argument_list|(
name|PCIR_PROGIF
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|revid
operator|=
name|REG
argument_list|(
name|PCIR_REVID
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|hdrtype
operator|=
name|REG
argument_list|(
name|PCIR_HDRTYPE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|cachelnsz
operator|=
name|REG
argument_list|(
name|PCIR_CACHELNSZ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|lattimer
operator|=
name|REG
argument_list|(
name|PCIR_LATTIMER
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|intpin
operator|=
name|REG
argument_list|(
name|PCIR_INTPIN
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|intline
operator|=
name|REG
argument_list|(
name|PCIR_INTLINE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|mingnt
operator|=
name|REG
argument_list|(
name|PCIR_MINGNT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|maxlat
operator|=
name|REG
argument_list|(
name|PCIR_MAXLAT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|mfdev
operator|=
operator|(
name|cfg
operator|->
name|hdrtype
operator|&
name|PCIM_MFDEV
operator|)
operator|!=
literal|0
expr_stmt|;
name|cfg
operator|->
name|hdrtype
operator|&=
operator|~
name|PCIM_MFDEV
expr_stmt|;
name|pci_fixancient
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
name|pci_hdrtypedata
argument_list|(
name|pcib
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|cfg
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG
argument_list|(
name|PCIR_STATUS
argument_list|,
literal|2
argument_list|)
operator|&
name|PCIM_STATUS_CAPPRESENT
condition|)
name|pci_read_extcap
argument_list|(
name|pcib
argument_list|,
name|cfg
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
name|devlist_head
argument_list|,
name|devlist_entry
argument_list|,
name|pci_links
argument_list|)
expr_stmt|;
name|devlist_entry
operator|->
name|conf
operator|.
name|pc_sel
operator|.
name|pc_bus
operator|=
name|cfg
operator|->
name|bus
expr_stmt|;
name|devlist_entry
operator|->
name|conf
operator|.
name|pc_sel
operator|.
name|pc_dev
operator|=
name|cfg
operator|->
name|slot
expr_stmt|;
name|devlist_entry
operator|->
name|conf
operator|.
name|pc_sel
operator|.
name|pc_func
operator|=
name|cfg
operator|->
name|func
expr_stmt|;
name|devlist_entry
operator|->
name|conf
operator|.
name|pc_hdr
operator|=
name|cfg
operator|->
name|hdrtype
expr_stmt|;
name|devlist_entry
operator|->
name|conf
operator|.
name|pc_subvendor
operator|=
name|cfg
operator|->
name|subvendor
expr_stmt|;
name|devlist_entry
operator|->
name|conf
operator|.
name|pc_subdevice
operator|=
name|cfg
operator|->
name|subdevice
expr_stmt|;
name|devlist_entry
operator|->
name|conf
operator|.
name|pc_vendor
operator|=
name|cfg
operator|->
name|vendor
expr_stmt|;
name|devlist_entry
operator|->
name|conf
operator|.
name|pc_device
operator|=
name|cfg
operator|->
name|device
expr_stmt|;
name|devlist_entry
operator|->
name|conf
operator|.
name|pc_class
operator|=
name|cfg
operator|->
name|baseclass
expr_stmt|;
name|devlist_entry
operator|->
name|conf
operator|.
name|pc_subclass
operator|=
name|cfg
operator|->
name|subclass
expr_stmt|;
name|devlist_entry
operator|->
name|conf
operator|.
name|pc_progif
operator|=
name|cfg
operator|->
name|progif
expr_stmt|;
name|devlist_entry
operator|->
name|conf
operator|.
name|pc_revid
operator|=
name|cfg
operator|->
name|revid
expr_stmt|;
name|pci_numdevs
operator|++
expr_stmt|;
name|pci_generation
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|devlist_entry
operator|)
return|;
undef|#
directive|undef
name|REG
block|}
end_function

begin_function
specifier|static
name|void
name|pci_read_extcap
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|pcicfgregs
modifier|*
name|cfg
parameter_list|)
block|{
define|#
directive|define
name|REG
parameter_list|(
name|n
parameter_list|,
name|w
parameter_list|)
value|PCIB_READ_CONFIG(pcib, cfg->bus, cfg->slot, cfg->func, n, w)
define|#
directive|define
name|WREG
parameter_list|(
name|n
parameter_list|,
name|v
parameter_list|,
name|w
parameter_list|)
value|PCIB_WRITE_CONFIG(pcib, cfg->bus, cfg->slot, cfg->func, n, v, w)
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
name|uint64_t
name|addr
decl_stmt|;
endif|#
directive|endif
name|uint32_t
name|val
decl_stmt|;
name|int
name|ptr
decl_stmt|,
name|nextptr
decl_stmt|,
name|ptrptr
decl_stmt|;
switch|switch
condition|(
name|cfg
operator|->
name|hdrtype
operator|&
name|PCIM_HDRTYPE
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
name|ptrptr
operator|=
name|PCIR_CAP_PTR
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|ptrptr
operator|=
name|PCIR_CAP_PTR_2
expr_stmt|;
comment|/* cardbus capabilities ptr */
break|break;
default|default:
return|return;
comment|/* no extended capabilities support */
block|}
name|nextptr
operator|=
name|REG
argument_list|(
name|ptrptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* sanity check? */
comment|/* 	 * Read capability entries. 	 */
while|while
condition|(
name|nextptr
operator|!=
literal|0
condition|)
block|{
comment|/* Sanity check */
if|if
condition|(
name|nextptr
operator|>
literal|255
condition|)
block|{
name|printf
argument_list|(
literal|"illegal PCI extended capability offset %d\n"
argument_list|,
name|nextptr
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Find the next entry */
name|ptr
operator|=
name|nextptr
expr_stmt|;
name|nextptr
operator|=
name|REG
argument_list|(
name|ptr
operator|+
name|PCICAP_NEXTPTR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Process this entry */
switch|switch
condition|(
name|REG
argument_list|(
name|ptr
operator|+
name|PCICAP_ID
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
name|PCIY_PMG
case|:
comment|/* PCI power management */
if|if
condition|(
name|cfg
operator|->
name|pp
operator|.
name|pp_cap
operator|==
literal|0
condition|)
block|{
name|cfg
operator|->
name|pp
operator|.
name|pp_cap
operator|=
name|REG
argument_list|(
name|ptr
operator|+
name|PCIR_POWER_CAP
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|pp
operator|.
name|pp_status
operator|=
name|ptr
operator|+
name|PCIR_POWER_STATUS
expr_stmt|;
name|cfg
operator|->
name|pp
operator|.
name|pp_pmcsr
operator|=
name|ptr
operator|+
name|PCIR_POWER_PMCSR
expr_stmt|;
if|if
condition|(
operator|(
name|nextptr
operator|-
name|ptr
operator|)
operator|>
name|PCIR_POWER_DATA
condition|)
name|cfg
operator|->
name|pp
operator|.
name|pp_data
operator|=
name|ptr
operator|+
name|PCIR_POWER_DATA
expr_stmt|;
block|}
break|break;
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
case|case
name|PCIY_HT
case|:
comment|/* HyperTransport */
comment|/* Determine HT-specific capability type. */
name|val
operator|=
name|REG
argument_list|(
name|ptr
operator|+
name|PCIR_HT_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|val
operator|&
name|PCIM_HTCMD_CAP_MASK
condition|)
block|{
case|case
name|PCIM_HTCAP_MSI_MAPPING
case|:
comment|/* Sanity check the mapping window. */
name|addr
operator|=
name|REG
argument_list|(
name|ptr
operator|+
name|PCIR_HTMSI_ADDRESS_HI
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|addr
operator|<<=
literal|32
expr_stmt|;
name|addr
operator|=
name|REG
argument_list|(
name|ptr
operator|+
name|PCIR_HTMSI_ADDRESS_LO
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|!=
name|MSI_INTEL_ADDR_BASE
condition|)
name|device_printf
argument_list|(
name|pcib
argument_list|,
literal|"HT Bridge at %d:%d:%d has non-default MSI window 0x%llx\n"
argument_list|,
name|cfg
operator|->
name|bus
argument_list|,
name|cfg
operator|->
name|slot
argument_list|,
name|cfg
operator|->
name|func
argument_list|,
operator|(
name|long
name|long
operator|)
name|addr
argument_list|)
expr_stmt|;
comment|/* Enable MSI -> HT mapping. */
name|val
operator||=
name|PCIM_HTCMD_MSI_ENABLE
expr_stmt|;
name|WREG
argument_list|(
name|ptr
operator|+
name|PCIR_HT_COMMAND
argument_list|,
name|val
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
endif|#
directive|endif
case|case
name|PCIY_MSI
case|:
comment|/* PCI MSI */
name|cfg
operator|->
name|msi
operator|.
name|msi_location
operator|=
name|ptr
expr_stmt|;
name|cfg
operator|->
name|msi
operator|.
name|msi_ctrl
operator|=
name|REG
argument_list|(
name|ptr
operator|+
name|PCIR_MSI_CTRL
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|msi
operator|.
name|msi_msgnum
operator|=
literal|1
operator|<<
operator|(
operator|(
name|cfg
operator|->
name|msi
operator|.
name|msi_ctrl
operator|&
name|PCIM_MSICTRL_MMC_MASK
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
break|break;
case|case
name|PCIY_MSIX
case|:
comment|/* PCI MSI-X */
name|cfg
operator|->
name|msix
operator|.
name|msix_location
operator|=
name|ptr
expr_stmt|;
name|cfg
operator|->
name|msix
operator|.
name|msix_ctrl
operator|=
name|REG
argument_list|(
name|ptr
operator|+
name|PCIR_MSIX_CTRL
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|msix
operator|.
name|msix_msgnum
operator|=
operator|(
name|cfg
operator|->
name|msix
operator|.
name|msix_ctrl
operator|&
name|PCIM_MSIXCTRL_TABLE_SIZE
operator|)
operator|+
literal|1
expr_stmt|;
name|val
operator|=
name|REG
argument_list|(
name|ptr
operator|+
name|PCIR_MSIX_TABLE
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|msix
operator|.
name|msix_table_bar
operator|=
name|PCIR_BAR
argument_list|(
name|val
operator|&
name|PCIM_MSIX_BIR_MASK
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|msix
operator|.
name|msix_table_offset
operator|=
name|val
operator|&
operator|~
name|PCIM_MSIX_BIR_MASK
expr_stmt|;
name|val
operator|=
name|REG
argument_list|(
name|ptr
operator|+
name|PCIR_MSIX_PBA
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|msix
operator|.
name|msix_pba_bar
operator|=
name|PCIR_BAR
argument_list|(
name|val
operator|&
name|PCIM_MSIX_BIR_MASK
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|msix
operator|.
name|msix_pba_offset
operator|=
name|val
operator|&
operator|~
name|PCIM_MSIX_BIR_MASK
expr_stmt|;
break|break;
case|case
name|PCIY_VPD
case|:
comment|/* PCI Vital Product Data */
name|cfg
operator|->
name|vpd
operator|.
name|vpd_reg
operator|=
name|ptr
expr_stmt|;
name|pci_read_vpd
argument_list|(
name|pcib
argument_list|,
name|cfg
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* REG and WREG use carry through to next functions */
block|}
end_function

begin_comment
comment|/*  * PCI Vital Product Data  */
end_comment

begin_function
specifier|static
name|uint32_t
name|pci_read_vpd_reg
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|pcicfgregs
modifier|*
name|cfg
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|KASSERT
argument_list|(
operator|(
name|reg
operator|&
literal|3
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"VPD register must by 4 byte aligned"
operator|)
argument_list|)
expr_stmt|;
name|WREG
argument_list|(
name|cfg
operator|->
name|vpd
operator|.
name|vpd_reg
operator|+
literal|2
argument_list|,
name|reg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|REG
argument_list|(
name|cfg
operator|->
name|vpd
operator|.
name|vpd_reg
operator|+
literal|2
argument_list|,
literal|2
argument_list|)
operator|&
literal|0x8000
operator|)
operator|!=
literal|0x8000
condition|)
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* limit looping */
return|return
name|REG
argument_list|(
name|cfg
operator|->
name|vpd
operator|.
name|vpd_reg
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static void pci_write_vpd_reg(device_t pcib, pcicfgregs *cfg, int reg, uint32_t data) { 	KASSERT((reg& 3) == 0, ("VPD register must by 4 byte aligned"));  	WREG(cfg->vpd.vpd_reg + 4, data, 4); 	WREG(cfg->vpd.vpd_reg + 2, reg | 0x8000, 2); 	while ((REG(cfg->vpd.vpd_reg + 2, 2)& 0x8000) == 0x8000) 		DELAY(1);
comment|/* limit looping */
end_comment

begin_endif
unit|return; }
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|vpd_readstate
block|{
name|device_t
name|pcib
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|int
name|bytesinval
decl_stmt|;
name|int
name|off
decl_stmt|;
name|uint8_t
name|cksum
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|uint8_t
name|vpd_nextbyte
parameter_list|(
name|struct
name|vpd_readstate
modifier|*
name|vrs
parameter_list|)
block|{
name|uint8_t
name|byte
decl_stmt|;
if|if
condition|(
name|vrs
operator|->
name|bytesinval
operator|==
literal|0
condition|)
block|{
name|vrs
operator|->
name|val
operator|=
name|le32toh
argument_list|(
name|pci_read_vpd_reg
argument_list|(
name|vrs
operator|->
name|pcib
argument_list|,
name|vrs
operator|->
name|cfg
argument_list|,
name|vrs
operator|->
name|off
argument_list|)
argument_list|)
expr_stmt|;
name|vrs
operator|->
name|off
operator|+=
literal|4
expr_stmt|;
name|byte
operator|=
name|vrs
operator|->
name|val
operator|&
literal|0xff
expr_stmt|;
name|vrs
operator|->
name|bytesinval
operator|=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|vrs
operator|->
name|val
operator|=
name|vrs
operator|->
name|val
operator|>>
literal|8
expr_stmt|;
name|byte
operator|=
name|vrs
operator|->
name|val
operator|&
literal|0xff
expr_stmt|;
name|vrs
operator|->
name|bytesinval
operator|--
expr_stmt|;
block|}
name|vrs
operator|->
name|cksum
operator|+=
name|byte
expr_stmt|;
return|return
name|byte
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pci_read_vpd
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|pcicfgregs
modifier|*
name|cfg
parameter_list|)
block|{
name|struct
name|vpd_readstate
name|vrs
decl_stmt|;
name|int
name|state
decl_stmt|;
name|int
name|name
decl_stmt|;
name|int
name|remain
decl_stmt|;
name|int
name|end
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint8_t
name|byte
decl_stmt|;
name|int
name|alloc
decl_stmt|,
name|off
decl_stmt|;
comment|/* alloc/off for RO/W arrays */
name|int
name|cksumvalid
decl_stmt|;
name|int
name|dflen
decl_stmt|;
comment|/* init vpd reader */
name|vrs
operator|.
name|bytesinval
operator|=
literal|0
expr_stmt|;
name|vrs
operator|.
name|off
operator|=
literal|0
expr_stmt|;
name|vrs
operator|.
name|pcib
operator|=
name|pcib
expr_stmt|;
name|vrs
operator|.
name|cfg
operator|=
name|cfg
expr_stmt|;
name|vrs
operator|.
name|cksum
operator|=
literal|0
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
name|name
operator|=
name|remain
operator|=
name|i
operator|=
literal|0
expr_stmt|;
comment|/* shut up stupid gcc */
name|alloc
operator|=
name|off
operator|=
literal|0
expr_stmt|;
comment|/* shut up stupid gcc */
name|dflen
operator|=
literal|0
expr_stmt|;
comment|/* shut up stupid gcc */
name|end
operator|=
literal|0
expr_stmt|;
name|cksumvalid
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
operator|!
name|end
condition|;
control|)
block|{
name|byte
operator|=
name|vpd_nextbyte
argument_list|(
operator|&
name|vrs
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf("vpd: val: %#x, off: %d, bytesinval: %d, byte: %#hhx, " \ 		    "state: %d, remain: %d, name: %#x, i: %d\n", vrs.val, 		    vrs.off, vrs.bytesinval, byte, state, remain, name, i);
endif|#
directive|endif
switch|switch
condition|(
name|state
condition|)
block|{
case|case
literal|0
case|:
comment|/* item name */
if|if
condition|(
name|byte
operator|&
literal|0x80
condition|)
block|{
name|remain
operator|=
name|vpd_nextbyte
argument_list|(
operator|&
name|vrs
argument_list|)
expr_stmt|;
name|remain
operator||=
name|vpd_nextbyte
argument_list|(
operator|&
name|vrs
argument_list|)
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
name|remain
operator|>
operator|(
literal|0x7f
operator|*
literal|4
operator|-
name|vrs
operator|.
name|off
operator|)
condition|)
block|{
name|end
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"pci%d:%d:%d: invalid vpd data, remain %#x\n"
argument_list|,
name|cfg
operator|->
name|bus
argument_list|,
name|cfg
operator|->
name|slot
argument_list|,
name|cfg
operator|->
name|func
argument_list|,
name|remain
argument_list|)
expr_stmt|;
block|}
name|name
operator|=
name|byte
operator|&
literal|0x7f
expr_stmt|;
block|}
else|else
block|{
name|remain
operator|=
name|byte
operator|&
literal|0x7
expr_stmt|;
name|name
operator|=
operator|(
name|byte
operator|>>
literal|3
operator|)
operator|&
literal|0xf
expr_stmt|;
block|}
switch|switch
condition|(
name|name
condition|)
block|{
case|case
literal|0x2
case|:
comment|/* String */
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ident
operator|=
name|malloc
argument_list|(
name|remain
operator|+
literal|1
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|state
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|0xf
case|:
comment|/* End */
name|end
operator|=
literal|1
expr_stmt|;
name|state
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|0x10
case|:
comment|/* VPD-R */
name|alloc
operator|=
literal|8
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
operator|=
name|malloc
argument_list|(
name|alloc
operator|*
sizeof|sizeof
expr|*
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|state
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|0x11
case|:
comment|/* VPD-W */
name|alloc
operator|=
literal|8
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
operator|=
name|malloc
argument_list|(
name|alloc
operator|*
sizeof|sizeof
expr|*
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|state
operator|=
literal|5
expr_stmt|;
break|break;
default|default:
comment|/* Invalid data, abort */
name|end
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|1
case|:
comment|/* Identifier String */
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ident
index|[
name|i
operator|++
index|]
operator|=
name|byte
expr_stmt|;
name|remain
operator|--
expr_stmt|;
if|if
condition|(
name|remain
operator|==
literal|0
condition|)
block|{
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ident
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
comment|/* VPD-R Keyword Header */
if|if
condition|(
name|off
operator|==
name|alloc
condition|)
block|{
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
operator|=
name|reallocf
argument_list|(
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
argument_list|,
operator|(
name|alloc
operator|*=
literal|2
operator|)
operator|*
sizeof|sizeof
expr|*
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
index|[
name|off
index|]
operator|.
name|keyword
index|[
literal|0
index|]
operator|=
name|byte
expr_stmt|;
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
index|[
name|off
index|]
operator|.
name|keyword
index|[
literal|1
index|]
operator|=
name|vpd_nextbyte
argument_list|(
operator|&
name|vrs
argument_list|)
expr_stmt|;
name|dflen
operator|=
name|vpd_nextbyte
argument_list|(
operator|&
name|vrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|dflen
operator|==
literal|0
operator|&&
name|strncmp
argument_list|(
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
index|[
name|off
index|]
operator|.
name|keyword
argument_list|,
literal|"RV"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * if this happens, we can't trust the rest 				 * of the VPD. 				 */
name|printf
argument_list|(
literal|"pci%d:%d:%d: bad keyword length: %d\n"
argument_list|,
name|cfg
operator|->
name|bus
argument_list|,
name|cfg
operator|->
name|slot
argument_list|,
name|cfg
operator|->
name|func
argument_list|,
name|dflen
argument_list|)
expr_stmt|;
name|cksumvalid
operator|=
literal|0
expr_stmt|;
name|end
operator|=
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|dflen
operator|==
literal|0
condition|)
block|{
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
index|[
name|off
index|]
operator|.
name|value
operator|=
name|malloc
argument_list|(
literal|1
operator|*
sizeof|sizeof
expr|*
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
index|[
name|off
index|]
operator|.
name|value
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
index|[
name|off
index|]
operator|.
name|value
index|[
literal|0
index|]
operator|=
literal|'\x00'
expr_stmt|;
block|}
else|else
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
index|[
name|off
index|]
operator|.
name|value
operator|=
name|malloc
argument_list|(
operator|(
name|dflen
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
expr|*
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
index|[
name|off
index|]
operator|.
name|value
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|remain
operator|-=
literal|3
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
comment|/* keep in sync w/ state 3's transistions */
if|if
condition|(
name|dflen
operator|==
literal|0
operator|&&
name|remain
operator|==
literal|0
condition|)
name|state
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|dflen
operator|==
literal|0
condition|)
name|state
operator|=
literal|2
expr_stmt|;
else|else
name|state
operator|=
literal|3
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* VPD-R Keyword Value */
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
index|[
name|off
index|]
operator|.
name|value
index|[
name|i
operator|++
index|]
operator|=
name|byte
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
index|[
name|off
index|]
operator|.
name|keyword
argument_list|,
literal|"RV"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|&&
name|cksumvalid
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|vrs
operator|.
name|cksum
operator|==
literal|0
condition|)
name|cksumvalid
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"pci%d:%d:%d: bad VPD cksum, remain %hhu\n"
argument_list|,
name|cfg
operator|->
name|bus
argument_list|,
name|cfg
operator|->
name|slot
argument_list|,
name|cfg
operator|->
name|func
argument_list|,
name|vrs
operator|.
name|cksum
argument_list|)
expr_stmt|;
name|cksumvalid
operator|=
literal|0
expr_stmt|;
name|end
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|dflen
operator|--
expr_stmt|;
name|remain
operator|--
expr_stmt|;
comment|/* keep in sync w/ state 2's transistions */
if|if
condition|(
name|dflen
operator|==
literal|0
condition|)
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
index|[
name|off
operator|++
index|]
operator|.
name|value
index|[
name|i
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|dflen
operator|==
literal|0
operator|&&
name|remain
operator|==
literal|0
condition|)
block|{
name|cfg
operator|->
name|vpd
operator|.
name|vpd_rocnt
operator|=
name|off
expr_stmt|;
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
operator|=
name|reallocf
argument_list|(
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
argument_list|,
name|off
operator|*
sizeof|sizeof
expr|*
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dflen
operator|==
literal|0
condition|)
name|state
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|remain
operator|--
expr_stmt|;
if|if
condition|(
name|remain
operator|==
literal|0
condition|)
name|state
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* VPD-W Keyword Header */
if|if
condition|(
name|off
operator|==
name|alloc
condition|)
block|{
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
operator|=
name|reallocf
argument_list|(
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
argument_list|,
operator|(
name|alloc
operator|*=
literal|2
operator|)
operator|*
sizeof|sizeof
expr|*
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
index|[
name|off
index|]
operator|.
name|keyword
index|[
literal|0
index|]
operator|=
name|byte
expr_stmt|;
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
index|[
name|off
index|]
operator|.
name|keyword
index|[
literal|1
index|]
operator|=
name|vpd_nextbyte
argument_list|(
operator|&
name|vrs
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
index|[
name|off
index|]
operator|.
name|len
operator|=
name|dflen
operator|=
name|vpd_nextbyte
argument_list|(
operator|&
name|vrs
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
index|[
name|off
index|]
operator|.
name|start
operator|=
name|vrs
operator|.
name|off
operator|-
name|vrs
operator|.
name|bytesinval
expr_stmt|;
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
index|[
name|off
index|]
operator|.
name|value
operator|=
name|malloc
argument_list|(
operator|(
name|dflen
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
expr|*
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
index|[
name|off
index|]
operator|.
name|value
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|remain
operator|-=
literal|3
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
comment|/* keep in sync w/ state 6's transistions */
if|if
condition|(
name|dflen
operator|==
literal|0
operator|&&
name|remain
operator|==
literal|0
condition|)
name|state
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|dflen
operator|==
literal|0
condition|)
name|state
operator|=
literal|5
expr_stmt|;
else|else
name|state
operator|=
literal|6
expr_stmt|;
break|break;
case|case
literal|6
case|:
comment|/* VPD-W Keyword Value */
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
index|[
name|off
index|]
operator|.
name|value
index|[
name|i
operator|++
index|]
operator|=
name|byte
expr_stmt|;
name|dflen
operator|--
expr_stmt|;
name|remain
operator|--
expr_stmt|;
comment|/* keep in sync w/ state 5's transistions */
if|if
condition|(
name|dflen
operator|==
literal|0
condition|)
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
index|[
name|off
operator|++
index|]
operator|.
name|value
index|[
name|i
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|dflen
operator|==
literal|0
operator|&&
name|remain
operator|==
literal|0
condition|)
block|{
name|cfg
operator|->
name|vpd
operator|.
name|vpd_wcnt
operator|=
name|off
expr_stmt|;
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
operator|=
name|reallocf
argument_list|(
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
argument_list|,
name|off
operator|*
sizeof|sizeof
expr|*
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dflen
operator|==
literal|0
condition|)
name|state
operator|=
literal|5
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"pci%d:%d:%d: invalid state: %d\n"
argument_list|,
name|cfg
operator|->
name|bus
argument_list|,
name|cfg
operator|->
name|slot
argument_list|,
name|cfg
operator|->
name|func
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|end
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|cksumvalid
operator|==
literal|0
condition|)
block|{
comment|/* read-only data bad, clean up */
for|for
control|(
init|;
name|off
condition|;
name|off
operator|--
control|)
name|free
argument_list|(
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
index|[
name|off
index|]
operator|.
name|value
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
operator|=
name|NULL
expr_stmt|;
block|}
undef|#
directive|undef
name|REG
undef|#
directive|undef
name|WREG
block|}
end_function

begin_function
name|int
name|pci_get_vpd_ident_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|identptr
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
operator|*
name|identptr
operator|=
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ident
expr_stmt|;
if|if
condition|(
operator|*
name|identptr
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|pci_get_vpd_readonly_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
specifier|const
name|char
modifier|*
name|kw
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|vptr
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cfg
operator|->
name|vpd
operator|.
name|vpd_rocnt
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|memcmp
argument_list|(
name|kw
argument_list|,
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
index|[
name|i
index|]
operator|.
name|keyword
argument_list|,
sizeof|sizeof
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
index|[
name|i
index|]
operator|.
name|keyword
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|vptr
operator|=
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
index|[
name|i
index|]
operator|.
name|value
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
name|cfg
operator|->
name|vpd
operator|.
name|vpd_rocnt
condition|)
return|return
literal|0
return|;
operator|*
name|vptr
operator|=
name|NULL
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
end_function

begin_comment
comment|/*  * Return the offset in configuration space of the requested extended  * capability entry or 0 if the specified capability was not found.  */
end_comment

begin_function
name|int
name|pci_find_extcap_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|capability
parameter_list|,
name|int
modifier|*
name|capreg
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
name|u_int32_t
name|status
decl_stmt|;
name|u_int8_t
name|ptr
decl_stmt|;
comment|/* 	 * Check the CAP_LIST bit of the PCI status register first. 	 */
name|status
operator|=
name|pci_read_config
argument_list|(
name|child
argument_list|,
name|PCIR_STATUS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|status
operator|&
name|PCIM_STATUS_CAPPRESENT
operator|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* 	 * Determine the start pointer of the capabilities list. 	 */
switch|switch
condition|(
name|cfg
operator|->
name|hdrtype
operator|&
name|PCIM_HDRTYPE
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
name|ptr
operator|=
name|PCIR_CAP_PTR
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|ptr
operator|=
name|PCIR_CAP_PTR_2
expr_stmt|;
break|break;
default|default:
comment|/* XXX: panic? */
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* no extended capabilities support */
block|}
name|ptr
operator|=
name|pci_read_config
argument_list|(
name|child
argument_list|,
name|ptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Traverse the capabilities list. 	 */
while|while
condition|(
name|ptr
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|pci_read_config
argument_list|(
name|child
argument_list|,
name|ptr
operator|+
name|PCICAP_ID
argument_list|,
literal|1
argument_list|)
operator|==
name|capability
condition|)
block|{
if|if
condition|(
name|capreg
operator|!=
name|NULL
condition|)
operator|*
name|capreg
operator|=
name|ptr
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ptr
operator|=
name|pci_read_config
argument_list|(
name|child
argument_list|,
name|ptr
operator|+
name|PCICAP_NEXTPTR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Support for MSI-X message interrupts.  */
end_comment

begin_function
name|void
name|pci_enable_msix
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|index
parameter_list|,
name|uint64_t
name|address
parameter_list|,
name|uint32_t
name|data
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
name|uint32_t
name|offset
decl_stmt|;
name|KASSERT
argument_list|(
name|cfg
operator|->
name|msix
operator|.
name|msix_alloc
operator|>
name|index
argument_list|,
operator|(
literal|"bogus index"
operator|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|cfg
operator|->
name|msix
operator|.
name|msix_table_offset
operator|+
name|index
operator|*
literal|16
expr_stmt|;
name|bus_write_4
argument_list|(
name|cfg
operator|->
name|msix
operator|.
name|msix_table_res
argument_list|,
name|offset
argument_list|,
name|address
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|bus_write_4
argument_list|(
name|cfg
operator|->
name|msix
operator|.
name|msix_table_res
argument_list|,
name|offset
operator|+
literal|4
argument_list|,
name|address
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|bus_write_4
argument_list|(
name|cfg
operator|->
name|msix
operator|.
name|msix_table_res
argument_list|,
name|offset
operator|+
literal|8
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pci_mask_msix
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|index
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
name|uint32_t
name|offset
decl_stmt|,
name|val
decl_stmt|;
name|KASSERT
argument_list|(
name|cfg
operator|->
name|msix
operator|.
name|msix_msgnum
operator|>
name|index
argument_list|,
operator|(
literal|"bogus index"
operator|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|cfg
operator|->
name|msix
operator|.
name|msix_table_offset
operator|+
name|index
operator|*
literal|16
operator|+
literal|12
expr_stmt|;
name|val
operator|=
name|bus_read_4
argument_list|(
name|cfg
operator|->
name|msix
operator|.
name|msix_table_res
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|val
operator|&
name|PCIM_MSIX_VCTRL_MASK
operator|)
condition|)
block|{
name|val
operator||=
name|PCIM_MSIX_VCTRL_MASK
expr_stmt|;
name|bus_write_4
argument_list|(
name|cfg
operator|->
name|msix
operator|.
name|msix_table_res
argument_list|,
name|offset
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|pci_unmask_msix
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|index
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
name|uint32_t
name|offset
decl_stmt|,
name|val
decl_stmt|;
name|KASSERT
argument_list|(
name|cfg
operator|->
name|msix
operator|.
name|msix_alloc
operator|>
name|index
argument_list|,
operator|(
literal|"bogus index"
operator|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|cfg
operator|->
name|msix
operator|.
name|msix_table_offset
operator|+
name|index
operator|*
literal|16
operator|+
literal|12
expr_stmt|;
name|val
operator|=
name|bus_read_4
argument_list|(
name|cfg
operator|->
name|msix
operator|.
name|msix_table_res
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|PCIM_MSIX_VCTRL_MASK
condition|)
block|{
name|val
operator|&=
operator|~
name|PCIM_MSIX_VCTRL_MASK
expr_stmt|;
name|bus_write_4
argument_list|(
name|cfg
operator|->
name|msix
operator|.
name|msix_table_res
argument_list|,
name|offset
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|pci_pending_msix
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|index
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
name|uint32_t
name|offset
decl_stmt|,
name|bit
decl_stmt|;
name|KASSERT
argument_list|(
name|cfg
operator|->
name|msix
operator|.
name|msix_alloc
operator|>
name|index
argument_list|,
operator|(
literal|"bogus index"
operator|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|cfg
operator|->
name|msix
operator|.
name|msix_pba_offset
operator|+
operator|(
name|index
operator|/
literal|4
operator|)
operator|*
literal|4
expr_stmt|;
name|bit
operator|=
literal|1
operator|<<
name|index
operator|%
literal|32
expr_stmt|;
return|return
operator|(
name|bus_read_4
argument_list|(
name|cfg
operator|->
name|msix
operator|.
name|msix_pba_res
argument_list|,
name|offset
argument_list|)
operator|&
name|bit
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pci_alloc_msix
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
modifier|*
name|count
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
name|int
name|actual
decl_stmt|,
name|error
decl_stmt|,
name|i
decl_stmt|,
name|irq
decl_stmt|,
name|max
decl_stmt|;
comment|/* MSI-X capability present? */
if|if
condition|(
name|cfg
operator|->
name|msix
operator|.
name|msix_location
operator|==
literal|0
operator|||
operator|!
name|pci_do_msix
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
comment|/* Make sure the appropriate BARs are mapped. */
name|rle
operator|=
name|resource_list_find
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|cfg
operator|->
name|msix
operator|.
name|msix_table_bar
argument_list|)
expr_stmt|;
if|if
condition|(
name|rle
operator|==
name|NULL
operator|||
name|rle
operator|->
name|res
operator|==
name|NULL
operator|||
operator|!
operator|(
name|rman_get_flags
argument_list|(
name|rle
operator|->
name|res
argument_list|)
operator|&
name|RF_ACTIVE
operator|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|cfg
operator|->
name|msix
operator|.
name|msix_table_res
operator|=
name|rle
operator|->
name|res
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|msix
operator|.
name|msix_pba_bar
operator|!=
name|cfg
operator|->
name|msix
operator|.
name|msix_table_bar
condition|)
block|{
name|rle
operator|=
name|resource_list_find
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|cfg
operator|->
name|msix
operator|.
name|msix_pba_bar
argument_list|)
expr_stmt|;
if|if
condition|(
name|rle
operator|==
name|NULL
operator|||
name|rle
operator|->
name|res
operator|==
name|NULL
operator|||
operator|!
operator|(
name|rman_get_flags
argument_list|(
name|rle
operator|->
name|res
argument_list|)
operator|&
name|RF_ACTIVE
operator|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|cfg
operator|->
name|msix
operator|.
name|msix_pba_res
operator|=
name|rle
operator|->
name|res
expr_stmt|;
comment|/* Already have allocated messages? */
if|if
condition|(
name|cfg
operator|->
name|msix
operator|.
name|msix_alloc
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|child
argument_list|,
literal|"attempting to allocate %d MSI-X vectors (%d supported)\n"
argument_list|,
operator|*
name|count
argument_list|,
name|cfg
operator|->
name|msix
operator|.
name|msix_msgnum
argument_list|)
expr_stmt|;
name|max
operator|=
name|min
argument_list|(
operator|*
name|count
argument_list|,
name|cfg
operator|->
name|msix
operator|.
name|msix_msgnum
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
comment|/* Allocate a message. */
name|error
operator|=
name|PCIB_ALLOC_MSIX
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|i
argument_list|,
operator|&
name|irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|resource_list_add
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|irq
argument_list|,
name|irq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|actual
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|rle
operator|=
name|resource_list_find
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|actual
operator|==
literal|1
condition|)
name|device_printf
argument_list|(
name|child
argument_list|,
literal|"using IRQ %lu for MSI-X\n"
argument_list|,
name|rle
operator|->
name|start
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|run
decl_stmt|;
comment|/* 			 * Be fancy and try to print contiguous runs of 			 * IRQ values as ranges.  'irq' is the previous IRQ. 			 * 'run' is true if we are in a range. 			 */
name|device_printf
argument_list|(
name|child
argument_list|,
literal|"using IRQs %lu"
argument_list|,
name|rle
operator|->
name|start
argument_list|)
expr_stmt|;
name|irq
operator|=
name|rle
operator|->
name|start
expr_stmt|;
name|run
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|actual
condition|;
name|i
operator|++
control|)
block|{
name|rle
operator|=
name|resource_list_find
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Still in a run? */
if|if
condition|(
name|rle
operator|->
name|start
operator|==
name|irq
operator|+
literal|1
condition|)
block|{
name|run
operator|=
literal|1
expr_stmt|;
name|irq
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Finish previous range. */
if|if
condition|(
name|run
condition|)
block|{
name|printf
argument_list|(
literal|"-%d"
argument_list|,
name|irq
argument_list|)
expr_stmt|;
name|run
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Start new range. */
name|printf
argument_list|(
literal|",%lu"
argument_list|,
name|rle
operator|->
name|start
argument_list|)
expr_stmt|;
name|irq
operator|=
name|rle
operator|->
name|start
expr_stmt|;
block|}
comment|/* Unfinished range? */
if|if
condition|(
name|run
condition|)
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|irq
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" for MSI-X\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Mask all vectors. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cfg
operator|->
name|msix
operator|.
name|msix_msgnum
condition|;
name|i
operator|++
control|)
name|pci_mask_msix
argument_list|(
name|child
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Update control register to enable MSI-X. */
name|cfg
operator|->
name|msix
operator|.
name|msix_ctrl
operator||=
name|PCIM_MSIXCTRL_MSIX_ENABLE
expr_stmt|;
name|pci_write_config
argument_list|(
name|child
argument_list|,
name|cfg
operator|->
name|msix
operator|.
name|msix_location
operator|+
name|PCIR_MSIX_CTRL
argument_list|,
name|cfg
operator|->
name|msix
operator|.
name|msix_ctrl
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Update counts of alloc'd messages. */
name|cfg
operator|->
name|msix
operator|.
name|msix_alloc
operator|=
name|actual
expr_stmt|;
operator|*
name|count
operator|=
name|actual
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pci_release_msix
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Do we have any messages to release? */
if|if
condition|(
name|cfg
operator|->
name|msix
operator|.
name|msix_alloc
operator|==
literal|0
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
comment|/* Make sure none of the resources are allocated. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cfg
operator|->
name|msix
operator|.
name|msix_alloc
condition|;
name|i
operator|++
control|)
block|{
name|rle
operator|=
name|resource_list_find
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|rle
operator|!=
name|NULL
argument_list|,
operator|(
literal|"missing MSI resource"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rle
operator|->
name|res
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
comment|/* Update control register with to disable MSI-X. */
name|cfg
operator|->
name|msix
operator|.
name|msix_ctrl
operator|&=
operator|~
name|PCIM_MSIXCTRL_MSIX_ENABLE
expr_stmt|;
name|pci_write_config
argument_list|(
name|child
argument_list|,
name|cfg
operator|->
name|msix
operator|.
name|msix_location
operator|+
name|PCIR_MSIX_CTRL
argument_list|,
name|cfg
operator|->
name|msix
operator|.
name|msix_ctrl
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Release the messages. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cfg
operator|->
name|msix
operator|.
name|msix_alloc
condition|;
name|i
operator|++
control|)
block|{
name|rle
operator|=
name|resource_list_find
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|PCIB_RELEASE_MSIX
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|rle
operator|->
name|start
argument_list|)
expr_stmt|;
name|resource_list_delete
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Update alloc count. */
name|cfg
operator|->
name|msix
operator|.
name|msix_alloc
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Support for MSI message signalled interrupts.  */
end_comment

begin_function
name|void
name|pci_enable_msi
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|uint64_t
name|address
parameter_list|,
name|uint16_t
name|data
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
comment|/* Write data and address values. */
name|cfg
operator|->
name|msi
operator|.
name|msi_addr
operator|=
name|address
expr_stmt|;
name|cfg
operator|->
name|msi
operator|.
name|msi_data
operator|=
name|data
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|cfg
operator|->
name|msi
operator|.
name|msi_location
operator|+
name|PCIR_MSI_ADDR
argument_list|,
name|address
operator|&
literal|0xffffffff
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|msi
operator|.
name|msi_ctrl
operator|&
name|PCIM_MSICTRL_64BIT
condition|)
block|{
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|cfg
operator|->
name|msi
operator|.
name|msi_location
operator|+
name|PCIR_MSI_ADDR_HIGH
argument_list|,
name|address
operator|>>
literal|32
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|cfg
operator|->
name|msi
operator|.
name|msi_location
operator|+
name|PCIR_MSI_DATA_64BIT
argument_list|,
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|cfg
operator|->
name|msi
operator|.
name|msi_location
operator|+
name|PCIR_MSI_DATA
argument_list|,
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Enable MSI in the control register. */
name|cfg
operator|->
name|msi
operator|.
name|msi_ctrl
operator||=
name|PCIM_MSICTRL_MSI_ENABLE
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|cfg
operator|->
name|msi
operator|.
name|msi_location
operator|+
name|PCIR_MSI_CTRL
argument_list|,
name|cfg
operator|->
name|msi
operator|.
name|msi_ctrl
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Restore MSI registers during resume.  If MSI is enabled then  * restore the data and address registers in addition to the control  * register.  */
end_comment

begin_function
specifier|static
name|void
name|pci_resume_msi
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
name|uint64_t
name|address
decl_stmt|;
name|uint16_t
name|data
decl_stmt|;
if|if
condition|(
name|cfg
operator|->
name|msi
operator|.
name|msi_ctrl
operator|&
name|PCIM_MSICTRL_MSI_ENABLE
condition|)
block|{
name|address
operator|=
name|cfg
operator|->
name|msi
operator|.
name|msi_addr
expr_stmt|;
name|data
operator|=
name|cfg
operator|->
name|msi
operator|.
name|msi_data
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|cfg
operator|->
name|msi
operator|.
name|msi_location
operator|+
name|PCIR_MSI_ADDR
argument_list|,
name|address
operator|&
literal|0xffffffff
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|msi
operator|.
name|msi_ctrl
operator|&
name|PCIM_MSICTRL_64BIT
condition|)
block|{
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|cfg
operator|->
name|msi
operator|.
name|msi_location
operator|+
name|PCIR_MSI_ADDR_HIGH
argument_list|,
name|address
operator|>>
literal|32
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|cfg
operator|->
name|msi
operator|.
name|msi_location
operator|+
name|PCIR_MSI_DATA_64BIT
argument_list|,
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|cfg
operator|->
name|msi
operator|.
name|msi_location
operator|+
name|PCIR_MSI_DATA
argument_list|,
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|cfg
operator|->
name|msi
operator|.
name|msi_location
operator|+
name|PCIR_MSI_CTRL
argument_list|,
name|cfg
operator|->
name|msi
operator|.
name|msi_ctrl
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns true if the specified device is blacklisted because MSI  * doesn't work.  */
end_comment

begin_function
name|int
name|pci_msi_device_blacklisted
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|pci_quirk
modifier|*
name|q
decl_stmt|;
if|if
condition|(
operator|!
name|pci_honor_msi_blacklist
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|q
operator|=
operator|&
name|pci_quirks
index|[
literal|0
index|]
init|;
name|q
operator|->
name|devid
condition|;
name|q
operator|++
control|)
block|{
if|if
condition|(
name|q
operator|->
name|devid
operator|==
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
operator|&&
name|q
operator|->
name|type
operator|==
name|PCI_QUIRK_DISABLE_MSI
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine if MSI is blacklisted globally on this sytem.  Currently,  * we just check for blacklisted chipsets as represented by the  * host-PCI bridge at device 0:0:0.  In the future, it may become  * necessary to check other system attributes, such as the kenv values  * that give the motherboard manufacturer and model number.  */
end_comment

begin_function
specifier|static
name|int
name|pci_msi_blacklisted
parameter_list|(
name|void
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
if|if
condition|(
operator|!
name|pci_honor_msi_blacklist
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|dev
operator|=
name|pci_find_bsf
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|!=
name|NULL
condition|)
return|return
operator|(
name|pci_msi_device_blacklisted
argument_list|(
name|dev
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attempt to allocate *count MSI messages.  The actual number allocated is  * returned in *count.  After this function returns, each message will be  * available to the driver as SYS_RES_IRQ resources starting at a rid 1.  */
end_comment

begin_function
name|int
name|pci_alloc_msi_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
modifier|*
name|count
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
name|int
name|actual
decl_stmt|,
name|error
decl_stmt|,
name|i
decl_stmt|,
name|irqs
index|[
literal|32
index|]
decl_stmt|;
name|uint16_t
name|ctrl
decl_stmt|;
comment|/* Don't let count == 0 get us into trouble. */
if|if
condition|(
operator|*
name|count
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* If rid 0 is allocated, then fail. */
name|rle
operator|=
name|resource_list_find
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rle
operator|!=
name|NULL
operator|&&
name|rle
operator|->
name|res
operator|!=
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* If MSI is blacklisted for this system, fail. */
if|if
condition|(
name|pci_msi_blacklisted
argument_list|()
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Try MSI-X first. */
name|error
operator|=
name|pci_alloc_msix
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENODEV
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* MSI capability present? */
if|if
condition|(
name|cfg
operator|->
name|msi
operator|.
name|msi_location
operator|==
literal|0
operator|||
operator|!
name|pci_do_msi
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
comment|/* Already have allocated messages? */
if|if
condition|(
name|cfg
operator|->
name|msi
operator|.
name|msi_alloc
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|child
argument_list|,
literal|"attempting to allocate %d MSI vectors (%d supported)\n"
argument_list|,
operator|*
name|count
argument_list|,
name|cfg
operator|->
name|msi
operator|.
name|msi_msgnum
argument_list|)
expr_stmt|;
comment|/* Don't ask for more than the device supports. */
name|actual
operator|=
name|min
argument_list|(
operator|*
name|count
argument_list|,
name|cfg
operator|->
name|msi
operator|.
name|msi_msgnum
argument_list|)
expr_stmt|;
comment|/* Don't ask for more than 32 messages. */
name|actual
operator|=
name|min
argument_list|(
name|actual
argument_list|,
literal|32
argument_list|)
expr_stmt|;
comment|/* MSI requires power of 2 number of messages. */
if|if
condition|(
operator|!
name|powerof2
argument_list|(
name|actual
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Try to allocate N messages. */
name|error
operator|=
name|PCIB_ALLOC_MSI
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|actual
argument_list|,
name|cfg
operator|->
name|msi
operator|.
name|msi_msgnum
argument_list|,
name|irqs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|actual
operator|==
literal|1
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Try N / 2. */
name|actual
operator|>>=
literal|1
expr_stmt|;
block|}
comment|/* 	 * We now have N actual messages mapped onto SYS_RES_IRQ 	 * resources in the irqs[] array, so add new resources 	 * starting at rid 1. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|actual
condition|;
name|i
operator|++
control|)
name|resource_list_add
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|irqs
index|[
name|i
index|]
argument_list|,
name|irqs
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
if|if
condition|(
name|actual
operator|==
literal|1
condition|)
name|device_printf
argument_list|(
name|child
argument_list|,
literal|"using IRQ %d for MSI\n"
argument_list|,
name|irqs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|run
decl_stmt|;
comment|/* 			 * Be fancy and try to print contiguous runs 			 * of IRQ values as ranges.  'run' is true if 			 * we are in a range. 			 */
name|device_printf
argument_list|(
name|child
argument_list|,
literal|"using IRQs %d"
argument_list|,
name|irqs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|run
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|actual
condition|;
name|i
operator|++
control|)
block|{
comment|/* Still in a run? */
if|if
condition|(
name|irqs
index|[
name|i
index|]
operator|==
name|irqs
index|[
name|i
operator|-
literal|1
index|]
operator|+
literal|1
condition|)
block|{
name|run
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* Finish previous range. */
if|if
condition|(
name|run
condition|)
block|{
name|printf
argument_list|(
literal|"-%d"
argument_list|,
name|irqs
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|run
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Start new range. */
name|printf
argument_list|(
literal|",%d"
argument_list|,
name|irqs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Unfinished range? */
if|if
condition|(
name|run
condition|)
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|irqs
index|[
name|actual
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" for MSI\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Update control register with actual count and enable MSI. */
name|ctrl
operator|=
name|cfg
operator|->
name|msi
operator|.
name|msi_ctrl
expr_stmt|;
name|ctrl
operator|&=
operator|~
name|PCIM_MSICTRL_MME_MASK
expr_stmt|;
name|ctrl
operator||=
operator|(
name|ffs
argument_list|(
name|actual
argument_list|)
operator|-
literal|1
operator|)
operator|<<
literal|4
expr_stmt|;
name|cfg
operator|->
name|msi
operator|.
name|msi_ctrl
operator|=
name|ctrl
expr_stmt|;
name|pci_write_config
argument_list|(
name|child
argument_list|,
name|cfg
operator|->
name|msi
operator|.
name|msi_location
operator|+
name|PCIR_MSI_CTRL
argument_list|,
name|ctrl
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Update counts of alloc'd messages. */
name|cfg
operator|->
name|msi
operator|.
name|msi_alloc
operator|=
name|actual
expr_stmt|;
operator|*
name|count
operator|=
name|actual
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Release the MSI messages associated with this device. */
end_comment

begin_function
name|int
name|pci_release_msi_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|irqs
index|[
literal|32
index|]
decl_stmt|;
comment|/* Try MSI-X first. */
name|error
operator|=
name|pci_release_msix
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENODEV
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Do we have any messages to release? */
if|if
condition|(
name|cfg
operator|->
name|msi
operator|.
name|msi_alloc
operator|==
literal|0
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
name|KASSERT
argument_list|(
name|cfg
operator|->
name|msi
operator|.
name|msi_alloc
operator|<=
literal|32
argument_list|,
operator|(
literal|"more than 32 alloc'd messages"
operator|)
argument_list|)
expr_stmt|;
comment|/* Make sure none of the resources are allocated. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cfg
operator|->
name|msi
operator|.
name|msi_alloc
condition|;
name|i
operator|++
control|)
block|{
name|rle
operator|=
name|resource_list_find
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|rle
operator|!=
name|NULL
argument_list|,
operator|(
literal|"missing MSI resource"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rle
operator|->
name|res
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|irqs
index|[
name|i
index|]
operator|=
name|rle
operator|->
name|start
expr_stmt|;
block|}
comment|/* Update control register with 0 count and disable MSI. */
name|cfg
operator|->
name|msi
operator|.
name|msi_ctrl
operator|&=
operator|~
operator|(
name|PCIM_MSICTRL_MME_MASK
operator||
name|PCIM_MSICTRL_MSI_ENABLE
operator|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|child
argument_list|,
name|cfg
operator|->
name|msi
operator|.
name|msi_location
operator|+
name|PCIR_MSI_CTRL
argument_list|,
name|cfg
operator|->
name|msi
operator|.
name|msi_ctrl
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Release the messages. */
name|PCIB_RELEASE_MSI
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|cfg
operator|->
name|msi
operator|.
name|msi_alloc
argument_list|,
name|irqs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cfg
operator|->
name|msi
operator|.
name|msi_alloc
condition|;
name|i
operator|++
control|)
name|resource_list_delete
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Update alloc count. */
name|cfg
operator|->
name|msi
operator|.
name|msi_alloc
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the max supported MSI or MSI-X messages this device supports.  * Basically, assuming the MD code can alloc messages, this function  * should return the maximum value that pci_alloc_msi() can return.  Thus,  * it is subject to the tunables, etc.  */
end_comment

begin_function
name|int
name|pci_msi_count_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
if|if
condition|(
name|pci_do_msix
operator|&&
name|cfg
operator|->
name|msix
operator|.
name|msix_location
operator|!=
literal|0
condition|)
return|return
operator|(
name|cfg
operator|->
name|msix
operator|.
name|msix_msgnum
operator|)
return|;
if|if
condition|(
name|pci_do_msi
operator|&&
name|cfg
operator|->
name|msi
operator|.
name|msi_location
operator|!=
literal|0
condition|)
return|return
operator|(
name|cfg
operator|->
name|msi
operator|.
name|msi_msgnum
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* free pcicfgregs structure and all depending data structures */
end_comment

begin_function
name|int
name|pci_freecfg
parameter_list|(
name|struct
name|pci_devinfo
modifier|*
name|dinfo
parameter_list|)
block|{
name|struct
name|devlist
modifier|*
name|devlist_head
decl_stmt|;
name|int
name|i
decl_stmt|;
name|devlist_head
operator|=
operator|&
name|pci_devq
expr_stmt|;
if|if
condition|(
name|dinfo
operator|->
name|cfg
operator|.
name|vpd
operator|.
name|vpd_reg
condition|)
block|{
name|free
argument_list|(
name|dinfo
operator|->
name|cfg
operator|.
name|vpd
operator|.
name|vpd_ident
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dinfo
operator|->
name|cfg
operator|.
name|vpd
operator|.
name|vpd_rocnt
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|dinfo
operator|->
name|cfg
operator|.
name|vpd
operator|.
name|vpd_ros
index|[
name|i
index|]
operator|.
name|value
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dinfo
operator|->
name|cfg
operator|.
name|vpd
operator|.
name|vpd_ros
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dinfo
operator|->
name|cfg
operator|.
name|vpd
operator|.
name|vpd_wcnt
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|dinfo
operator|->
name|cfg
operator|.
name|vpd
operator|.
name|vpd_w
index|[
name|i
index|]
operator|.
name|value
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dinfo
operator|->
name|cfg
operator|.
name|vpd
operator|.
name|vpd_w
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|STAILQ_REMOVE
argument_list|(
name|devlist_head
argument_list|,
name|dinfo
argument_list|,
name|pci_devinfo
argument_list|,
name|pci_links
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dinfo
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
comment|/* increment the generation count */
name|pci_generation
operator|++
expr_stmt|;
comment|/* we're losing one device */
name|pci_numdevs
operator|--
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * PCI power manangement  */
end_comment

begin_function
name|int
name|pci_set_powerstate_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
name|uint16_t
name|status
decl_stmt|;
name|int
name|result
decl_stmt|,
name|oldstate
decl_stmt|,
name|highest
decl_stmt|,
name|delay
decl_stmt|;
if|if
condition|(
name|cfg
operator|->
name|pp
operator|.
name|pp_cap
operator|==
literal|0
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
comment|/* 	 * Optimize a no state change request away.  While it would be OK to 	 * write to the hardware in theory, some devices have shown odd 	 * behavior when going from D3 -> D3. 	 */
name|oldstate
operator|=
name|pci_get_powerstate
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldstate
operator|==
name|state
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * The PCI power management specification states that after a state 	 * transition between PCI power states, system software must 	 * guarantee a minimal delay before the function accesses the device. 	 * Compute the worst case delay that we need to guarantee before we 	 * access the device.  Many devices will be responsive much more 	 * quickly than this delay, but there are some that don't respond 	 * instantly to state changes.  Transitions to/from D3 state require 	 * 10ms, while D2 requires 200us, and D0/1 require none.  The delay 	 * is done below with DELAY rather than a sleeper function because 	 * this function can be called from contexts where we cannot sleep. 	 */
name|highest
operator|=
operator|(
name|oldstate
operator|>
name|state
operator|)
condition|?
name|oldstate
else|:
name|state
expr_stmt|;
if|if
condition|(
name|highest
operator|==
name|PCI_POWERSTATE_D3
condition|)
name|delay
operator|=
literal|10000
expr_stmt|;
elseif|else
if|if
condition|(
name|highest
operator|==
name|PCI_POWERSTATE_D2
condition|)
name|delay
operator|=
literal|200
expr_stmt|;
else|else
name|delay
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|PCI_READ_CONFIG
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|cfg
operator|->
name|pp
operator|.
name|pp_status
argument_list|,
literal|2
argument_list|)
operator|&
operator|~
name|PCIM_PSTAT_DMASK
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|PCI_POWERSTATE_D0
case|:
name|status
operator||=
name|PCIM_PSTAT_D0
expr_stmt|;
break|break;
case|case
name|PCI_POWERSTATE_D1
case|:
if|if
condition|(
operator|(
name|cfg
operator|->
name|pp
operator|.
name|pp_cap
operator|&
name|PCIM_PCAP_D1SUPP
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
name|status
operator||=
name|PCIM_PSTAT_D1
expr_stmt|;
break|break;
case|case
name|PCI_POWERSTATE_D2
case|:
if|if
condition|(
operator|(
name|cfg
operator|->
name|pp
operator|.
name|pp_cap
operator|&
name|PCIM_PCAP_D2SUPP
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
name|status
operator||=
name|PCIM_PSTAT_D2
expr_stmt|;
break|break;
case|case
name|PCI_POWERSTATE_D3
case|:
name|status
operator||=
name|PCIM_PSTAT_D3
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"pci%d:%d:%d: Transition from D%d to D%d\n"
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|bus
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|slot
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|func
argument_list|,
name|oldstate
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|PCI_WRITE_CONFIG
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|cfg
operator|->
name|pp
operator|.
name|pp_status
argument_list|,
name|status
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|delay
condition|)
name|DELAY
argument_list|(
name|delay
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_get_powerstate_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
name|uint16_t
name|status
decl_stmt|;
name|int
name|result
decl_stmt|;
if|if
condition|(
name|cfg
operator|->
name|pp
operator|.
name|pp_cap
operator|!=
literal|0
condition|)
block|{
name|status
operator|=
name|PCI_READ_CONFIG
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|cfg
operator|->
name|pp
operator|.
name|pp_status
argument_list|,
literal|2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|status
operator|&
name|PCIM_PSTAT_DMASK
condition|)
block|{
case|case
name|PCIM_PSTAT_D0
case|:
name|result
operator|=
name|PCI_POWERSTATE_D0
expr_stmt|;
break|break;
case|case
name|PCIM_PSTAT_D1
case|:
name|result
operator|=
name|PCI_POWERSTATE_D1
expr_stmt|;
break|break;
case|case
name|PCIM_PSTAT_D2
case|:
name|result
operator|=
name|PCI_POWERSTATE_D2
expr_stmt|;
break|break;
case|case
name|PCIM_PSTAT_D3
case|:
name|result
operator|=
name|PCI_POWERSTATE_D3
expr_stmt|;
break|break;
default|default:
name|result
operator|=
name|PCI_POWERSTATE_UNKNOWN
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* No support, device is always at D0 */
name|result
operator|=
name|PCI_POWERSTATE_D0
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Some convenience functions for PCI device drivers.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|pci_set_command_bit
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|uint16_t
name|bit
parameter_list|)
block|{
name|uint16_t
name|command
decl_stmt|;
name|command
operator|=
name|PCI_READ_CONFIG
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|command
operator||=
name|bit
expr_stmt|;
name|PCI_WRITE_CONFIG
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|command
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|pci_clear_command_bit
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|uint16_t
name|bit
parameter_list|)
block|{
name|uint16_t
name|command
decl_stmt|;
name|command
operator|=
name|PCI_READ_CONFIG
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|command
operator|&=
operator|~
name|bit
expr_stmt|;
name|PCI_WRITE_CONFIG
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|command
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pci_enable_busmaster_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|pci_set_command_bit
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|PCIM_CMD_BUSMASTEREN
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_disable_busmaster_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|pci_clear_command_bit
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|PCIM_CMD_BUSMASTEREN
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_enable_io_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|space
parameter_list|)
block|{
name|uint16_t
name|command
decl_stmt|;
name|uint16_t
name|bit
decl_stmt|;
name|char
modifier|*
name|error
decl_stmt|;
name|bit
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|space
condition|)
block|{
case|case
name|SYS_RES_IOPORT
case|:
name|bit
operator|=
name|PCIM_CMD_PORTEN
expr_stmt|;
name|error
operator|=
literal|"port"
expr_stmt|;
break|break;
case|case
name|SYS_RES_MEMORY
case|:
name|bit
operator|=
name|PCIM_CMD_MEMEN
expr_stmt|;
name|error
operator|=
literal|"memory"
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|pci_set_command_bit
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|bit
argument_list|)
expr_stmt|;
comment|/* Some devices seem to need a brief stall here, what do to? */
name|command
operator|=
name|PCI_READ_CONFIG
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
operator|&
name|bit
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|device_printf
argument_list|(
name|child
argument_list|,
literal|"failed to enable %s mapping!\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_disable_io_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|space
parameter_list|)
block|{
name|uint16_t
name|command
decl_stmt|;
name|uint16_t
name|bit
decl_stmt|;
name|char
modifier|*
name|error
decl_stmt|;
name|bit
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|space
condition|)
block|{
case|case
name|SYS_RES_IOPORT
case|:
name|bit
operator|=
name|PCIM_CMD_PORTEN
expr_stmt|;
name|error
operator|=
literal|"port"
expr_stmt|;
break|break;
case|case
name|SYS_RES_MEMORY
case|:
name|bit
operator|=
name|PCIM_CMD_MEMEN
expr_stmt|;
name|error
operator|=
literal|"memory"
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|pci_clear_command_bit
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|bit
argument_list|)
expr_stmt|;
name|command
operator|=
name|PCI_READ_CONFIG
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
operator|&
name|bit
condition|)
block|{
name|device_printf
argument_list|(
name|child
argument_list|,
literal|"failed to disable %s mapping!\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * New style pci driver.  Parent device is either a pci-host-bridge or a  * pci-pci-bridge.  Both kinds are represented by instances of pcib.  */
end_comment

begin_function
name|void
name|pci_print_verbose
parameter_list|(
name|struct
name|pci_devinfo
modifier|*
name|dinfo
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
name|printf
argument_list|(
literal|"found->\tvendor=0x%04x, dev=0x%04x, revid=0x%02x\n"
argument_list|,
name|cfg
operator|->
name|vendor
argument_list|,
name|cfg
operator|->
name|device
argument_list|,
name|cfg
operator|->
name|revid
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tbus=%d, slot=%d, func=%d\n"
argument_list|,
name|cfg
operator|->
name|bus
argument_list|,
name|cfg
operator|->
name|slot
argument_list|,
name|cfg
operator|->
name|func
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tclass=%02x-%02x-%02x, hdrtype=0x%02x, mfdev=%d\n"
argument_list|,
name|cfg
operator|->
name|baseclass
argument_list|,
name|cfg
operator|->
name|subclass
argument_list|,
name|cfg
operator|->
name|progif
argument_list|,
name|cfg
operator|->
name|hdrtype
argument_list|,
name|cfg
operator|->
name|mfdev
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tcmdreg=0x%04x, statreg=0x%04x, cachelnsz=%d (dwords)\n"
argument_list|,
name|cfg
operator|->
name|cmdreg
argument_list|,
name|cfg
operator|->
name|statreg
argument_list|,
name|cfg
operator|->
name|cachelnsz
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tlattimer=0x%02x (%d ns), mingnt=0x%02x (%d ns), maxlat=0x%02x (%d ns)\n"
argument_list|,
name|cfg
operator|->
name|lattimer
argument_list|,
name|cfg
operator|->
name|lattimer
operator|*
literal|30
argument_list|,
name|cfg
operator|->
name|mingnt
argument_list|,
name|cfg
operator|->
name|mingnt
operator|*
literal|250
argument_list|,
name|cfg
operator|->
name|maxlat
argument_list|,
name|cfg
operator|->
name|maxlat
operator|*
literal|250
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|intpin
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"\tintpin=%c, irq=%d\n"
argument_list|,
name|cfg
operator|->
name|intpin
operator|+
literal|'a'
operator|-
literal|1
argument_list|,
name|cfg
operator|->
name|intline
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|pp
operator|.
name|pp_cap
condition|)
block|{
name|uint16_t
name|status
decl_stmt|;
name|status
operator|=
name|pci_read_config
argument_list|(
name|cfg
operator|->
name|dev
argument_list|,
name|cfg
operator|->
name|pp
operator|.
name|pp_status
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tpowerspec %d  supports D0%s%s D3  current D%d\n"
argument_list|,
name|cfg
operator|->
name|pp
operator|.
name|pp_cap
operator|&
name|PCIM_PCAP_SPEC
argument_list|,
name|cfg
operator|->
name|pp
operator|.
name|pp_cap
operator|&
name|PCIM_PCAP_D1SUPP
condition|?
literal|" D1"
else|:
literal|""
argument_list|,
name|cfg
operator|->
name|pp
operator|.
name|pp_cap
operator|&
name|PCIM_PCAP_D2SUPP
condition|?
literal|" D2"
else|:
literal|""
argument_list|,
name|status
operator|&
name|PCIM_PSTAT_DMASK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cfg
operator|->
name|vpd
operator|.
name|vpd_reg
condition|)
block|{
name|printf
argument_list|(
literal|"\tVPD Ident: %s\n"
argument_list|,
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ident
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cfg
operator|->
name|vpd
operator|.
name|vpd_rocnt
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|vpd_readonly
modifier|*
name|vrop
decl_stmt|;
name|vrop
operator|=
operator|&
name|cfg
operator|->
name|vpd
operator|.
name|vpd_ros
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
literal|"CP"
argument_list|,
name|vrop
operator|->
name|keyword
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\tCP: id %d, BAR%d, off %#x\n"
argument_list|,
name|vrop
operator|->
name|value
index|[
literal|0
index|]
argument_list|,
name|vrop
operator|->
name|value
index|[
literal|1
index|]
argument_list|,
name|le16toh
argument_list|(
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|&
name|vrop
operator|->
name|value
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
literal|"RV"
argument_list|,
name|vrop
operator|->
name|keyword
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\tRV: %#hhx\n"
argument_list|,
name|vrop
operator|->
name|value
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\t%.2s: %s\n"
argument_list|,
name|vrop
operator|->
name|keyword
argument_list|,
name|vrop
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cfg
operator|->
name|vpd
operator|.
name|vpd_wcnt
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|vpd_write
modifier|*
name|vwp
decl_stmt|;
name|vwp
operator|=
operator|&
name|cfg
operator|->
name|vpd
operator|.
name|vpd_w
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
literal|"RW"
argument_list|,
name|vwp
operator|->
name|keyword
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"\t%.2s(%#x-%#x): %s\n"
argument_list|,
name|vwp
operator|->
name|keyword
argument_list|,
name|vwp
operator|->
name|start
argument_list|,
name|vwp
operator|->
name|start
operator|+
name|vwp
operator|->
name|len
argument_list|,
name|vwp
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cfg
operator|->
name|msi
operator|.
name|msi_location
condition|)
block|{
name|int
name|ctrl
decl_stmt|;
name|ctrl
operator|=
name|cfg
operator|->
name|msi
operator|.
name|msi_ctrl
expr_stmt|;
name|printf
argument_list|(
literal|"\tMSI supports %d message%s%s%s\n"
argument_list|,
name|cfg
operator|->
name|msi
operator|.
name|msi_msgnum
argument_list|,
operator|(
name|cfg
operator|->
name|msi
operator|.
name|msi_msgnum
operator|==
literal|1
operator|)
condition|?
literal|""
else|:
literal|"s"
argument_list|,
operator|(
name|ctrl
operator|&
name|PCIM_MSICTRL_64BIT
operator|)
condition|?
literal|", 64 bit"
else|:
literal|""
argument_list|,
operator|(
name|ctrl
operator|&
name|PCIM_MSICTRL_VECTOR
operator|)
condition|?
literal|", vector masks"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cfg
operator|->
name|msix
operator|.
name|msix_location
condition|)
block|{
name|printf
argument_list|(
literal|"\tMSI-X supports %d message%s "
argument_list|,
name|cfg
operator|->
name|msix
operator|.
name|msix_msgnum
argument_list|,
operator|(
name|cfg
operator|->
name|msix
operator|.
name|msix_msgnum
operator|==
literal|1
operator|)
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|msix
operator|.
name|msix_table_bar
operator|==
name|cfg
operator|->
name|msix
operator|.
name|msix_pba_bar
condition|)
name|printf
argument_list|(
literal|"in map 0x%x\n"
argument_list|,
name|cfg
operator|->
name|msix
operator|.
name|msix_table_bar
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"in maps 0x%x and 0x%x\n"
argument_list|,
name|cfg
operator|->
name|msix
operator|.
name|msix_table_bar
argument_list|,
name|cfg
operator|->
name|msix
operator|.
name|msix_pba_bar
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|pci_porten
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|s
parameter_list|,
name|int
name|f
parameter_list|)
block|{
return|return
operator|(
name|PCIB_READ_CONFIG
argument_list|(
name|pcib
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
operator|&
name|PCIM_CMD_PORTEN
operator|)
operator|!=
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pci_memen
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|s
parameter_list|,
name|int
name|f
parameter_list|)
block|{
return|return
operator|(
name|PCIB_READ_CONFIG
argument_list|(
name|pcib
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
operator|&
name|PCIM_CMD_MEMEN
operator|)
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Add a resource based on a pci map register. Return 1 if the map  * register is a 32bit map register or 2 if it is a 64bit register.  */
end_comment

begin_function
specifier|static
name|int
name|pci_add_map
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|s
parameter_list|,
name|int
name|f
parameter_list|,
name|int
name|reg
parameter_list|,
name|struct
name|resource_list
modifier|*
name|rl
parameter_list|,
name|int
name|force
parameter_list|,
name|int
name|prefetch
parameter_list|)
block|{
name|uint32_t
name|map
decl_stmt|;
name|pci_addr_t
name|base
decl_stmt|;
name|pci_addr_t
name|start
decl_stmt|,
name|end
decl_stmt|,
name|count
decl_stmt|;
name|uint8_t
name|ln2size
decl_stmt|;
name|uint8_t
name|ln2range
decl_stmt|;
name|uint32_t
name|testval
decl_stmt|;
name|uint16_t
name|cmd
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|barlen
decl_stmt|;
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|map
operator|=
name|PCIB_READ_CONFIG
argument_list|(
name|pcib
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|reg
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|PCIB_WRITE_CONFIG
argument_list|(
name|pcib
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|reg
argument_list|,
literal|0xffffffff
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|testval
operator|=
name|PCIB_READ_CONFIG
argument_list|(
name|pcib
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|reg
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|PCIB_WRITE_CONFIG
argument_list|(
name|pcib
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|reg
argument_list|,
name|map
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_maptype
argument_list|(
name|map
argument_list|)
operator|&
name|PCI_MAPMEM
condition|)
name|type
operator|=
name|SYS_RES_MEMORY
expr_stmt|;
else|else
name|type
operator|=
name|SYS_RES_IOPORT
expr_stmt|;
name|ln2size
operator|=
name|pci_mapsize
argument_list|(
name|testval
argument_list|)
expr_stmt|;
name|ln2range
operator|=
name|pci_maprange
argument_list|(
name|testval
argument_list|)
expr_stmt|;
name|base
operator|=
name|pci_mapbase
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|barlen
operator|=
name|ln2range
operator|==
literal|64
condition|?
literal|2
else|:
literal|1
expr_stmt|;
comment|/* 	 * For I/O registers, if bottom bit is set, and the next bit up 	 * isn't clear, we know we have a BAR that doesn't conform to the 	 * spec, so ignore it.  Also, sanity check the size of the data 	 * areas to the type of memory involved.  Memory must be at least 	 * 16 bytes in size, while I/O ranges must be at least 4. 	 */
if|if
condition|(
operator|(
name|testval
operator|&
literal|0x1
operator|)
operator|==
literal|0x1
operator|&&
operator|(
name|testval
operator|&
literal|0x2
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|barlen
operator|)
return|;
if|if
condition|(
operator|(
name|type
operator|==
name|SYS_RES_MEMORY
operator|&&
name|ln2size
operator|<
literal|4
operator|)
operator|||
operator|(
name|type
operator|==
name|SYS_RES_IOPORT
operator|&&
name|ln2size
operator|<
literal|2
operator|)
condition|)
return|return
operator|(
name|barlen
operator|)
return|;
if|if
condition|(
name|ln2range
operator|==
literal|64
condition|)
comment|/* Read the other half of a 64bit map register */
name|base
operator||=
operator|(
name|uint64_t
operator|)
name|PCIB_READ_CONFIG
argument_list|(
name|pcib
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|reg
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
operator|<<
literal|32
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"\tmap[%02x]: type %x, range %2d, base %#jx, size %2d"
argument_list|,
name|reg
argument_list|,
name|pci_maptype
argument_list|(
name|map
argument_list|)
argument_list|,
name|ln2range
argument_list|,
operator|(
name|uintmax_t
operator|)
name|base
argument_list|,
name|ln2size
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|SYS_RES_IOPORT
operator|&&
operator|!
name|pci_porten
argument_list|(
name|pcib
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|)
condition|)
name|printf
argument_list|(
literal|", port disabled\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|SYS_RES_MEMORY
operator|&&
operator|!
name|pci_memen
argument_list|(
name|pcib
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|)
condition|)
name|printf
argument_list|(
literal|", memory disabled\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|", enabled\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If base is 0, then we have problems.  It is best to ignore 	 * such entries for the moment.  These will be allocated later if 	 * the driver specifically requests them.  However, some 	 * removable busses look better when all resources are allocated, 	 * so allow '0' to be overriden. 	 * 	 * Similarly treat maps whose values is the same as the test value 	 * read back.  These maps have had all f's written to them by the 	 * BIOS in an attempt to disable the resources. 	 */
if|if
condition|(
operator|!
name|force
operator|&&
operator|(
name|base
operator|==
literal|0
operator|||
name|map
operator|==
name|testval
operator|)
condition|)
return|return
operator|(
name|barlen
operator|)
return|;
if|if
condition|(
operator|(
name|u_long
operator|)
name|base
operator|!=
name|base
condition|)
block|{
name|device_printf
argument_list|(
name|bus
argument_list|,
literal|"pci%d:%d:%d bar %#x too many address bits"
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
name|barlen
operator|)
return|;
block|}
comment|/* 	 * This code theoretically does the right thing, but has 	 * undesirable side effects in some cases where peripherals 	 * respond oddly to having these bits enabled.  Let the user 	 * be able to turn them off (since pci_enable_io_modes is 1 by 	 * default). 	 */
if|if
condition|(
name|pci_enable_io_modes
condition|)
block|{
comment|/* Turn on resources that have been left off by a lazy BIOS */
if|if
condition|(
name|type
operator|==
name|SYS_RES_IOPORT
operator|&&
operator|!
name|pci_porten
argument_list|(
name|pcib
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|cmd
operator|=
name|PCIB_READ_CONFIG
argument_list|(
name|pcib
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cmd
operator||=
name|PCIM_CMD_PORTEN
expr_stmt|;
name|PCIB_WRITE_CONFIG
argument_list|(
name|pcib
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|cmd
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|SYS_RES_MEMORY
operator|&&
operator|!
name|pci_memen
argument_list|(
name|pcib
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|cmd
operator|=
name|PCIB_READ_CONFIG
argument_list|(
name|pcib
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cmd
operator||=
name|PCIM_CMD_MEMEN
expr_stmt|;
name|PCIB_WRITE_CONFIG
argument_list|(
name|pcib
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|cmd
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|type
operator|==
name|SYS_RES_IOPORT
operator|&&
operator|!
name|pci_porten
argument_list|(
name|pcib
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|)
condition|)
return|return
operator|(
name|barlen
operator|)
return|;
if|if
condition|(
name|type
operator|==
name|SYS_RES_MEMORY
operator|&&
operator|!
name|pci_memen
argument_list|(
name|pcib
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|)
condition|)
return|return
operator|(
name|barlen
operator|)
return|;
block|}
name|count
operator|=
literal|1
operator|<<
name|ln2size
expr_stmt|;
if|if
condition|(
name|base
operator|==
literal|0
operator|||
name|base
operator|==
name|pci_mapbase
argument_list|(
name|testval
argument_list|)
condition|)
block|{
name|start
operator|=
literal|0
expr_stmt|;
comment|/* Let the parent deside */
name|end
operator|=
operator|~
literal|0ULL
expr_stmt|;
block|}
else|else
block|{
name|start
operator|=
name|base
expr_stmt|;
name|end
operator|=
name|base
operator|+
operator|(
literal|1
operator|<<
name|ln2size
operator|)
operator|-
literal|1
expr_stmt|;
block|}
name|resource_list_add
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
name|reg
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/* 	 * Not quite sure what to do on failure of allocating the resource 	 * since I can postulate several right answers. 	 */
name|res
operator|=
name|resource_list_alloc
argument_list|(
name|rl
argument_list|,
name|bus
argument_list|,
name|dev
argument_list|,
name|type
argument_list|,
operator|&
name|reg
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|prefetch
condition|?
name|RF_PREFETCHABLE
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
return|return
operator|(
name|barlen
operator|)
return|;
name|start
operator|=
name|rman_get_start
argument_list|(
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|u_long
operator|)
name|start
operator|!=
name|start
condition|)
block|{
comment|/* Wait a minute!  this platform can't do this address. */
name|device_printf
argument_list|(
name|bus
argument_list|,
literal|"pci%d.%d.%x bar %#x start %#jx, too many bits."
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|reg
argument_list|,
operator|(
name|uintmax_t
operator|)
name|start
argument_list|)
expr_stmt|;
name|resource_list_release
argument_list|(
name|rl
argument_list|,
name|bus
argument_list|,
name|dev
argument_list|,
name|type
argument_list|,
name|reg
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
operator|(
name|barlen
operator|)
return|;
block|}
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|reg
argument_list|,
name|start
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln2range
operator|==
literal|64
condition|)
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|reg
operator|+
literal|4
argument_list|,
name|start
operator|>>
literal|32
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return
operator|(
name|barlen
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * For ATA devices we need to decide early what addressing mode to use.  * Legacy demands that the primary and secondary ATA ports sits on the  * same addresses that old ISA hardware did. This dictates that we use  * those addresses and ignore the BAR's if we cannot set PCI native  * addressing mode.  */
end_comment

begin_function
specifier|static
name|void
name|pci_ata_maps
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|s
parameter_list|,
name|int
name|f
parameter_list|,
name|struct
name|resource_list
modifier|*
name|rl
parameter_list|,
name|int
name|force
parameter_list|,
name|uint32_t
name|prefetchmask
parameter_list|)
block|{
name|int
name|rid
decl_stmt|,
name|type
decl_stmt|,
name|progif
decl_stmt|;
if|#
directive|if
literal|0
comment|/* if this device supports PCI native addressing use it */
block|progif = pci_read_config(dev, PCIR_PROGIF, 1); 	if ((progif& 0x8a) == 0x8a) { 		if (pci_mapbase(pci_read_config(dev, PCIR_BAR(0), 4))&& 		    pci_mapbase(pci_read_config(dev, PCIR_BAR(2), 4))) { 			printf("Trying ATA native PCI addressing mode\n"); 			pci_write_config(dev, PCIR_PROGIF, progif | 0x05, 1); 		} 	}
endif|#
directive|endif
name|progif
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PROGIF
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|type
operator|=
name|SYS_RES_IOPORT
expr_stmt|;
if|if
condition|(
name|progif
operator|&
name|PCIP_STORAGE_IDE_MODEPRIM
condition|)
block|{
name|pci_add_map
argument_list|(
name|pcib
argument_list|,
name|bus
argument_list|,
name|dev
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|rl
argument_list|,
name|force
argument_list|,
name|prefetchmask
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
argument_list|)
expr_stmt|;
name|pci_add_map
argument_list|(
name|pcib
argument_list|,
name|bus
argument_list|,
name|dev
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|PCIR_BAR
argument_list|(
literal|1
argument_list|)
argument_list|,
name|rl
argument_list|,
name|force
argument_list|,
name|prefetchmask
operator|&
operator|(
literal|1
operator|<<
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|resource_list_add
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
literal|0x1f0
argument_list|,
literal|0x1f7
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|resource_list_alloc
argument_list|(
name|rl
argument_list|,
name|bus
argument_list|,
name|dev
argument_list|,
name|type
argument_list|,
operator|&
name|rid
argument_list|,
literal|0x1f0
argument_list|,
literal|0x1f7
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rid
operator|=
name|PCIR_BAR
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|resource_list_add
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
literal|0x3f6
argument_list|,
literal|0x3f6
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|resource_list_alloc
argument_list|(
name|rl
argument_list|,
name|bus
argument_list|,
name|dev
argument_list|,
name|type
argument_list|,
operator|&
name|rid
argument_list|,
literal|0x3f6
argument_list|,
literal|0x3f6
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|progif
operator|&
name|PCIP_STORAGE_IDE_MODESEC
condition|)
block|{
name|pci_add_map
argument_list|(
name|pcib
argument_list|,
name|bus
argument_list|,
name|dev
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|PCIR_BAR
argument_list|(
literal|2
argument_list|)
argument_list|,
name|rl
argument_list|,
name|force
argument_list|,
name|prefetchmask
operator|&
operator|(
literal|1
operator|<<
literal|2
operator|)
argument_list|)
expr_stmt|;
name|pci_add_map
argument_list|(
name|pcib
argument_list|,
name|bus
argument_list|,
name|dev
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|PCIR_BAR
argument_list|(
literal|3
argument_list|)
argument_list|,
name|rl
argument_list|,
name|force
argument_list|,
name|prefetchmask
operator|&
operator|(
literal|1
operator|<<
literal|3
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rid
operator|=
name|PCIR_BAR
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|resource_list_add
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
literal|0x170
argument_list|,
literal|0x177
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|resource_list_alloc
argument_list|(
name|rl
argument_list|,
name|bus
argument_list|,
name|dev
argument_list|,
name|type
argument_list|,
operator|&
name|rid
argument_list|,
literal|0x170
argument_list|,
literal|0x177
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rid
operator|=
name|PCIR_BAR
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|resource_list_add
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
literal|0x376
argument_list|,
literal|0x376
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|resource_list_alloc
argument_list|(
name|rl
argument_list|,
name|bus
argument_list|,
name|dev
argument_list|,
name|type
argument_list|,
operator|&
name|rid
argument_list|,
literal|0x376
argument_list|,
literal|0x376
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|pci_add_map
argument_list|(
name|pcib
argument_list|,
name|bus
argument_list|,
name|dev
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|PCIR_BAR
argument_list|(
literal|4
argument_list|)
argument_list|,
name|rl
argument_list|,
name|force
argument_list|,
name|prefetchmask
operator|&
operator|(
literal|1
operator|<<
literal|4
operator|)
argument_list|)
expr_stmt|;
name|pci_add_map
argument_list|(
name|pcib
argument_list|,
name|bus
argument_list|,
name|dev
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|PCIR_BAR
argument_list|(
literal|5
argument_list|)
argument_list|,
name|rl
argument_list|,
name|force
argument_list|,
name|prefetchmask
operator|&
operator|(
literal|1
operator|<<
literal|5
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pci_assign_interrupt
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|int
name|force_route
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
name|char
name|tunable_name
index|[
literal|64
index|]
decl_stmt|;
name|int
name|irq
decl_stmt|;
comment|/* Has to have an intpin to have an interrupt. */
if|if
condition|(
name|cfg
operator|->
name|intpin
operator|==
literal|0
condition|)
return|return;
comment|/* Let the user override the IRQ with a tunable. */
name|irq
operator|=
name|PCI_INVALID_IRQ
expr_stmt|;
name|snprintf
argument_list|(
name|tunable_name
argument_list|,
sizeof|sizeof
argument_list|(
name|tunable_name
argument_list|)
argument_list|,
literal|"hw.pci%d.%d.INT%c.irq"
argument_list|,
name|cfg
operator|->
name|bus
argument_list|,
name|cfg
operator|->
name|slot
argument_list|,
name|cfg
operator|->
name|intpin
operator|+
literal|'A'
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TUNABLE_INT_FETCH
argument_list|(
name|tunable_name
argument_list|,
operator|&
name|irq
argument_list|)
operator|&&
operator|(
name|irq
operator|>=
literal|255
operator|||
name|irq
operator|<=
literal|0
operator|)
condition|)
name|irq
operator|=
name|PCI_INVALID_IRQ
expr_stmt|;
comment|/* 	 * If we didn't get an IRQ via the tunable, then we either use the 	 * IRQ value in the intline register or we ask the bus to route an 	 * interrupt for us.  If force_route is true, then we only use the 	 * value in the intline register if the bus was unable to assign an 	 * IRQ. 	 */
if|if
condition|(
operator|!
name|PCI_INTERRUPT_VALID
argument_list|(
name|irq
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|PCI_INTERRUPT_VALID
argument_list|(
name|cfg
operator|->
name|intline
argument_list|)
operator|||
name|force_route
condition|)
name|irq
operator|=
name|PCI_ASSIGN_INTERRUPT
argument_list|(
name|bus
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PCI_INTERRUPT_VALID
argument_list|(
name|irq
argument_list|)
condition|)
name|irq
operator|=
name|cfg
operator|->
name|intline
expr_stmt|;
block|}
comment|/* If after all that we don't have an IRQ, just bail. */
if|if
condition|(
operator|!
name|PCI_INTERRUPT_VALID
argument_list|(
name|irq
argument_list|)
condition|)
return|return;
comment|/* Update the config register if it changed. */
if|if
condition|(
name|irq
operator|!=
name|cfg
operator|->
name|intline
condition|)
block|{
name|cfg
operator|->
name|intline
operator|=
name|irq
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_INTLINE
argument_list|,
name|irq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Add this IRQ as rid 0 interrupt resource. */
name|resource_list_add
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|irq
argument_list|,
name|irq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pci_add_resources
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|int
name|force
parameter_list|,
name|uint32_t
name|prefetchmask
parameter_list|)
block|{
name|device_t
name|pcib
decl_stmt|;
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
name|struct
name|resource_list
modifier|*
name|rl
init|=
operator|&
name|dinfo
operator|->
name|resources
decl_stmt|;
name|struct
name|pci_quirk
modifier|*
name|q
decl_stmt|;
name|int
name|b
decl_stmt|,
name|i
decl_stmt|,
name|f
decl_stmt|,
name|s
decl_stmt|;
name|pcib
operator|=
name|device_get_parent
argument_list|(
name|bus
argument_list|)
expr_stmt|;
name|b
operator|=
name|cfg
operator|->
name|bus
expr_stmt|;
name|s
operator|=
name|cfg
operator|->
name|slot
expr_stmt|;
name|f
operator|=
name|cfg
operator|->
name|func
expr_stmt|;
comment|/* ATA devices needs special map treatment */
if|if
condition|(
operator|(
name|pci_get_class
argument_list|(
name|dev
argument_list|)
operator|==
name|PCIC_STORAGE
operator|)
operator|&&
operator|(
name|pci_get_subclass
argument_list|(
name|dev
argument_list|)
operator|==
name|PCIS_STORAGE_IDE
operator|)
operator|&&
operator|(
name|pci_get_progif
argument_list|(
name|dev
argument_list|)
operator|&
name|PCIP_STORAGE_IDE_MASTERDEV
operator|)
condition|)
name|pci_ata_maps
argument_list|(
name|pcib
argument_list|,
name|bus
argument_list|,
name|dev
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|rl
argument_list|,
name|force
argument_list|,
name|prefetchmask
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cfg
operator|->
name|nummaps
condition|;
control|)
name|i
operator|+=
name|pci_add_map
argument_list|(
name|pcib
argument_list|,
name|bus
argument_list|,
name|dev
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|PCIR_BAR
argument_list|(
name|i
argument_list|)
argument_list|,
name|rl
argument_list|,
name|force
argument_list|,
name|prefetchmask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Add additional, quirked resources. 	 */
for|for
control|(
name|q
operator|=
operator|&
name|pci_quirks
index|[
literal|0
index|]
init|;
name|q
operator|->
name|devid
condition|;
name|q
operator|++
control|)
block|{
if|if
condition|(
name|q
operator|->
name|devid
operator|==
operator|(
operator|(
name|cfg
operator|->
name|device
operator|<<
literal|16
operator|)
operator||
name|cfg
operator|->
name|vendor
operator|)
operator|&&
name|q
operator|->
name|type
operator|==
name|PCI_QUIRK_MAP_REG
condition|)
name|pci_add_map
argument_list|(
name|pcib
argument_list|,
name|bus
argument_list|,
name|dev
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|q
operator|->
name|arg1
argument_list|,
name|rl
argument_list|,
name|force
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cfg
operator|->
name|intpin
operator|>
literal|0
operator|&&
name|PCI_INTERRUPT_VALID
argument_list|(
name|cfg
operator|->
name|intline
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|__PCI_REROUTE_INTERRUPT
comment|/* 		 * Try to re-route interrupts. Sometimes the BIOS or 		 * firmware may leave bogus values in these registers. 		 * If the re-route fails, then just stick with what we 		 * have. 		 */
name|pci_assign_interrupt
argument_list|(
name|bus
argument_list|,
name|dev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|pci_assign_interrupt
argument_list|(
name|bus
argument_list|,
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_function
name|void
name|pci_add_children
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|busno
parameter_list|,
name|size_t
name|dinfo_size
parameter_list|)
block|{
define|#
directive|define
name|REG
parameter_list|(
name|n
parameter_list|,
name|w
parameter_list|)
value|PCIB_READ_CONFIG(pcib, busno, s, f, n, w)
name|device_t
name|pcib
init|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|int
name|maxslots
decl_stmt|;
name|int
name|s
decl_stmt|,
name|f
decl_stmt|,
name|pcifunchigh
decl_stmt|;
name|uint8_t
name|hdrtype
decl_stmt|;
name|KASSERT
argument_list|(
name|dinfo_size
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|pci_devinfo
argument_list|)
argument_list|,
operator|(
literal|"dinfo_size too small"
operator|)
argument_list|)
expr_stmt|;
name|maxslots
operator|=
name|PCIB_MAXSLOTS
argument_list|(
name|pcib
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<=
name|maxslots
condition|;
name|s
operator|++
control|)
block|{
name|pcifunchigh
operator|=
literal|0
expr_stmt|;
name|f
operator|=
literal|0
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|hdrtype
operator|=
name|REG
argument_list|(
name|PCIR_HDRTYPE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hdrtype
operator|&
name|PCIM_HDRTYPE
operator|)
operator|>
name|PCI_MAXHDRTYPE
condition|)
continue|continue;
if|if
condition|(
name|hdrtype
operator|&
name|PCIM_MFDEV
condition|)
name|pcifunchigh
operator|=
name|PCI_FUNCMAX
expr_stmt|;
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<=
name|pcifunchigh
condition|;
name|f
operator|++
control|)
block|{
name|dinfo
operator|=
name|pci_read_device
argument_list|(
name|pcib
argument_list|,
name|busno
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|dinfo_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|dinfo
operator|!=
name|NULL
condition|)
block|{
name|pci_add_child
argument_list|(
name|dev
argument_list|,
name|dinfo
argument_list|)
expr_stmt|;
block|}
block|}
block|}
undef|#
directive|undef
name|REG
block|}
end_function

begin_function
name|void
name|pci_add_child
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|struct
name|pci_devinfo
modifier|*
name|dinfo
parameter_list|)
block|{
name|dinfo
operator|->
name|cfg
operator|.
name|dev
operator|=
name|device_add_child
argument_list|(
name|bus
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|device_set_ivars
argument_list|(
name|dinfo
operator|->
name|cfg
operator|.
name|dev
argument_list|,
name|dinfo
argument_list|)
expr_stmt|;
name|resource_list_init
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|)
expr_stmt|;
name|pci_cfg_save
argument_list|(
name|dinfo
operator|->
name|cfg
operator|.
name|dev
argument_list|,
name|dinfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pci_cfg_restore
argument_list|(
name|dinfo
operator|->
name|cfg
operator|.
name|dev
argument_list|,
name|dinfo
argument_list|)
expr_stmt|;
name|pci_print_verbose
argument_list|(
name|dinfo
argument_list|)
expr_stmt|;
name|pci_add_resources
argument_list|(
name|bus
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|dev
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pci_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"PCI bus"
argument_list|)
expr_stmt|;
comment|/* Allow other subclasses to override this driver. */
return|return
operator|(
operator|-
literal|1000
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pci_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|busno
decl_stmt|;
comment|/* 	 * Since there can be multiple independantly numbered PCI 	 * busses on systems with multiple PCI domains, we can't use 	 * the unit number to decide which bus we are probing. We ask 	 * the parent pcib what our bus number is. 	 */
name|busno
operator|=
name|pcib_get_bus
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"physical bus=%d\n"
argument_list|,
name|busno
argument_list|)
expr_stmt|;
name|pci_add_children
argument_list|(
name|dev
argument_list|,
name|busno
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pci_devinfo
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|dstate
decl_stmt|,
name|error
decl_stmt|,
name|i
decl_stmt|,
name|numdevs
decl_stmt|;
name|device_t
name|acpi_dev
decl_stmt|,
name|child
decl_stmt|,
modifier|*
name|devlist
decl_stmt|;
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
comment|/* 	 * Save the PCI configuration space for each child and set the 	 * device in the appropriate power state for this sleep state. 	 */
name|acpi_dev
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|pci_do_power_resume
condition|)
name|acpi_dev
operator|=
name|devclass_get_device
argument_list|(
name|devclass_find
argument_list|(
literal|"acpi"
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|device_get_children
argument_list|(
name|dev
argument_list|,
operator|&
name|devlist
argument_list|,
operator|&
name|numdevs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numdevs
condition|;
name|i
operator|++
control|)
block|{
name|child
operator|=
name|devlist
index|[
name|i
index|]
expr_stmt|;
name|dinfo
operator|=
operator|(
expr|struct
name|pci_devinfo
operator|*
operator|)
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|pci_cfg_save
argument_list|(
name|child
argument_list|,
name|dinfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Suspend devices before potentially powering them down. */
name|error
operator|=
name|bus_generic_suspend
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|devlist
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Always set the device to D3.  If ACPI suggests a different 	 * power state, use it instead.  If ACPI is not present, the 	 * firmware is responsible for managing device power.  Skip 	 * children who aren't attached since they are powered down 	 * separately.  Only manage type 0 devices for now. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|acpi_dev
operator|&&
name|i
operator|<
name|numdevs
condition|;
name|i
operator|++
control|)
block|{
name|child
operator|=
name|devlist
index|[
name|i
index|]
expr_stmt|;
name|dinfo
operator|=
operator|(
expr|struct
name|pci_devinfo
operator|*
operator|)
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_is_attached
argument_list|(
name|child
argument_list|)
operator|&&
name|dinfo
operator|->
name|cfg
operator|.
name|hdrtype
operator|==
literal|0
condition|)
block|{
name|dstate
operator|=
name|PCI_POWERSTATE_D3
expr_stmt|;
name|ACPI_PWR_FOR_SLEEP
argument_list|(
name|acpi_dev
argument_list|,
name|child
argument_list|,
operator|&
name|dstate
argument_list|)
expr_stmt|;
name|pci_set_powerstate
argument_list|(
name|child
argument_list|,
name|dstate
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|devlist
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|numdevs
decl_stmt|;
name|device_t
name|acpi_dev
decl_stmt|,
name|child
decl_stmt|,
modifier|*
name|devlist
decl_stmt|;
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
comment|/* 	 * Set each child to D0 and restore its PCI configuration space. 	 */
name|acpi_dev
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|pci_do_power_resume
condition|)
name|acpi_dev
operator|=
name|devclass_get_device
argument_list|(
name|devclass_find
argument_list|(
literal|"acpi"
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|device_get_children
argument_list|(
name|dev
argument_list|,
operator|&
name|devlist
argument_list|,
operator|&
name|numdevs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numdevs
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * Notify ACPI we're going to D0 but ignore the result.  If 		 * ACPI is not present, the firmware is responsible for 		 * managing device power.  Only manage type 0 devices for now. 		 */
name|child
operator|=
name|devlist
index|[
name|i
index|]
expr_stmt|;
name|dinfo
operator|=
operator|(
expr|struct
name|pci_devinfo
operator|*
operator|)
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|acpi_dev
operator|&&
name|device_is_attached
argument_list|(
name|child
argument_list|)
operator|&&
name|dinfo
operator|->
name|cfg
operator|.
name|hdrtype
operator|==
literal|0
condition|)
block|{
name|ACPI_PWR_FOR_SLEEP
argument_list|(
name|acpi_dev
argument_list|,
name|child
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pci_set_powerstate
argument_list|(
name|child
argument_list|,
name|PCI_POWERSTATE_D0
argument_list|)
expr_stmt|;
block|}
comment|/* Now the device is powered up, restore its config space. */
name|pci_cfg_restore
argument_list|(
name|child
argument_list|,
name|dinfo
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|devlist
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|bus_generic_resume
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pci_load_vendor_data
parameter_list|(
name|void
parameter_list|)
block|{
name|caddr_t
name|vendordata
decl_stmt|,
name|info
decl_stmt|;
if|if
condition|(
operator|(
name|vendordata
operator|=
name|preload_search_by_type
argument_list|(
literal|"pci_vendor_data"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|info
operator|=
name|preload_search_info
argument_list|(
name|vendordata
argument_list|,
name|MODINFO_ADDR
argument_list|)
expr_stmt|;
name|pci_vendordata
operator|=
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
name|info
expr_stmt|;
name|info
operator|=
name|preload_search_info
argument_list|(
name|vendordata
argument_list|,
name|MODINFO_SIZE
argument_list|)
expr_stmt|;
name|pci_vendordata_size
operator|=
operator|*
operator|(
name|size_t
operator|*
operator|)
name|info
expr_stmt|;
comment|/* terminate the database */
name|pci_vendordata
index|[
name|pci_vendordata_size
index|]
operator|=
literal|'\n'
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|pci_driver_added
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|driver_t
modifier|*
name|driver
parameter_list|)
block|{
name|int
name|numdevs
decl_stmt|;
name|device_t
modifier|*
name|devlist
decl_stmt|;
name|device_t
name|child
decl_stmt|;
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"driver added\n"
argument_list|)
expr_stmt|;
name|DEVICE_IDENTIFY
argument_list|(
name|driver
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|device_get_children
argument_list|(
name|dev
argument_list|,
operator|&
name|devlist
argument_list|,
operator|&
name|numdevs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numdevs
condition|;
name|i
operator|++
control|)
block|{
name|child
operator|=
name|devlist
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|device_get_state
argument_list|(
name|child
argument_list|)
operator|!=
name|DS_NOTPRESENT
condition|)
continue|continue;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|pci_print_verbose
argument_list|(
name|dinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"pci%d:%d:%d: reprobing on driver added\n"
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|bus
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|slot
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|func
argument_list|)
expr_stmt|;
name|pci_cfg_restore
argument_list|(
name|child
argument_list|,
name|dinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_probe_and_attach
argument_list|(
name|child
argument_list|)
operator|!=
literal|0
condition|)
name|pci_cfg_save
argument_list|(
name|child
argument_list|,
name|dinfo
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|devlist
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pci_print_child
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|struct
name|resource_list
modifier|*
name|rl
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|rl
operator|=
operator|&
name|dinfo
operator|->
name|resources
expr_stmt|;
name|retval
operator|+=
name|bus_print_child_header
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|resource_list_print_type
argument_list|(
name|rl
argument_list|,
literal|"port"
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|"%#lx"
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|resource_list_print_type
argument_list|(
name|rl
argument_list|,
literal|"mem"
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|"%#lx"
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|resource_list_print_type
argument_list|(
name|rl
argument_list|,
literal|"irq"
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|"%ld"
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_get_flags
argument_list|(
name|dev
argument_list|)
condition|)
name|retval
operator|+=
name|printf
argument_list|(
literal|" flags %#x"
argument_list|,
name|device_get_flags
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|printf
argument_list|(
literal|" at device %d.%d"
argument_list|,
name|pci_get_slot
argument_list|(
name|child
argument_list|)
argument_list|,
name|pci_get_function
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|bus_print_child_footer
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_struct
specifier|static
struct|struct
block|{
name|int
name|class
decl_stmt|;
name|int
name|subclass
decl_stmt|;
name|char
modifier|*
name|desc
decl_stmt|;
block|}
name|pci_nomatch_tab
index|[]
init|=
block|{
block|{
name|PCIC_OLD
block|,
operator|-
literal|1
block|,
literal|"old"
block|}
block|,
block|{
name|PCIC_OLD
block|,
name|PCIS_OLD_NONVGA
block|,
literal|"non-VGA display device"
block|}
block|,
block|{
name|PCIC_OLD
block|,
name|PCIS_OLD_VGA
block|,
literal|"VGA-compatible display device"
block|}
block|,
block|{
name|PCIC_STORAGE
block|,
operator|-
literal|1
block|,
literal|"mass storage"
block|}
block|,
block|{
name|PCIC_STORAGE
block|,
name|PCIS_STORAGE_SCSI
block|,
literal|"SCSI"
block|}
block|,
block|{
name|PCIC_STORAGE
block|,
name|PCIS_STORAGE_IDE
block|,
literal|"ATA"
block|}
block|,
block|{
name|PCIC_STORAGE
block|,
name|PCIS_STORAGE_FLOPPY
block|,
literal|"floppy disk"
block|}
block|,
block|{
name|PCIC_STORAGE
block|,
name|PCIS_STORAGE_IPI
block|,
literal|"IPI"
block|}
block|,
block|{
name|PCIC_STORAGE
block|,
name|PCIS_STORAGE_RAID
block|,
literal|"RAID"
block|}
block|,
block|{
name|PCIC_NETWORK
block|,
operator|-
literal|1
block|,
literal|"network"
block|}
block|,
block|{
name|PCIC_NETWORK
block|,
name|PCIS_NETWORK_ETHERNET
block|,
literal|"ethernet"
block|}
block|,
block|{
name|PCIC_NETWORK
block|,
name|PCIS_NETWORK_TOKENRING
block|,
literal|"token ring"
block|}
block|,
block|{
name|PCIC_NETWORK
block|,
name|PCIS_NETWORK_FDDI
block|,
literal|"fddi"
block|}
block|,
block|{
name|PCIC_NETWORK
block|,
name|PCIS_NETWORK_ATM
block|,
literal|"ATM"
block|}
block|,
block|{
name|PCIC_NETWORK
block|,
name|PCIS_NETWORK_ISDN
block|,
literal|"ISDN"
block|}
block|,
block|{
name|PCIC_DISPLAY
block|,
operator|-
literal|1
block|,
literal|"display"
block|}
block|,
block|{
name|PCIC_DISPLAY
block|,
name|PCIS_DISPLAY_VGA
block|,
literal|"VGA"
block|}
block|,
block|{
name|PCIC_DISPLAY
block|,
name|PCIS_DISPLAY_XGA
block|,
literal|"XGA"
block|}
block|,
block|{
name|PCIC_DISPLAY
block|,
name|PCIS_DISPLAY_3D
block|,
literal|"3D"
block|}
block|,
block|{
name|PCIC_MULTIMEDIA
block|,
operator|-
literal|1
block|,
literal|"multimedia"
block|}
block|,
block|{
name|PCIC_MULTIMEDIA
block|,
name|PCIS_MULTIMEDIA_VIDEO
block|,
literal|"video"
block|}
block|,
block|{
name|PCIC_MULTIMEDIA
block|,
name|PCIS_MULTIMEDIA_AUDIO
block|,
literal|"audio"
block|}
block|,
block|{
name|PCIC_MULTIMEDIA
block|,
name|PCIS_MULTIMEDIA_TELE
block|,
literal|"telephony"
block|}
block|,
block|{
name|PCIC_MEMORY
block|,
operator|-
literal|1
block|,
literal|"memory"
block|}
block|,
block|{
name|PCIC_MEMORY
block|,
name|PCIS_MEMORY_RAM
block|,
literal|"RAM"
block|}
block|,
block|{
name|PCIC_MEMORY
block|,
name|PCIS_MEMORY_FLASH
block|,
literal|"flash"
block|}
block|,
block|{
name|PCIC_BRIDGE
block|,
operator|-
literal|1
block|,
literal|"bridge"
block|}
block|,
block|{
name|PCIC_BRIDGE
block|,
name|PCIS_BRIDGE_HOST
block|,
literal|"HOST-PCI"
block|}
block|,
block|{
name|PCIC_BRIDGE
block|,
name|PCIS_BRIDGE_ISA
block|,
literal|"PCI-ISA"
block|}
block|,
block|{
name|PCIC_BRIDGE
block|,
name|PCIS_BRIDGE_EISA
block|,
literal|"PCI-EISA"
block|}
block|,
block|{
name|PCIC_BRIDGE
block|,
name|PCIS_BRIDGE_MCA
block|,
literal|"PCI-MCA"
block|}
block|,
block|{
name|PCIC_BRIDGE
block|,
name|PCIS_BRIDGE_PCI
block|,
literal|"PCI-PCI"
block|}
block|,
block|{
name|PCIC_BRIDGE
block|,
name|PCIS_BRIDGE_PCMCIA
block|,
literal|"PCI-PCMCIA"
block|}
block|,
block|{
name|PCIC_BRIDGE
block|,
name|PCIS_BRIDGE_NUBUS
block|,
literal|"PCI-NuBus"
block|}
block|,
block|{
name|PCIC_BRIDGE
block|,
name|PCIS_BRIDGE_CARDBUS
block|,
literal|"PCI-CardBus"
block|}
block|,
block|{
name|PCIC_BRIDGE
block|,
name|PCIS_BRIDGE_RACEWAY
block|,
literal|"PCI-RACEway"
block|}
block|,
block|{
name|PCIC_SIMPLECOMM
block|,
operator|-
literal|1
block|,
literal|"simple comms"
block|}
block|,
block|{
name|PCIC_SIMPLECOMM
block|,
name|PCIS_SIMPLECOMM_UART
block|,
literal|"UART"
block|}
block|,
comment|/* could detect 16550 */
block|{
name|PCIC_SIMPLECOMM
block|,
name|PCIS_SIMPLECOMM_PAR
block|,
literal|"parallel port"
block|}
block|,
block|{
name|PCIC_SIMPLECOMM
block|,
name|PCIS_SIMPLECOMM_MULSER
block|,
literal|"multiport serial"
block|}
block|,
block|{
name|PCIC_SIMPLECOMM
block|,
name|PCIS_SIMPLECOMM_MODEM
block|,
literal|"generic modem"
block|}
block|,
block|{
name|PCIC_BASEPERIPH
block|,
operator|-
literal|1
block|,
literal|"base peripheral"
block|}
block|,
block|{
name|PCIC_BASEPERIPH
block|,
name|PCIS_BASEPERIPH_PIC
block|,
literal|"interrupt controller"
block|}
block|,
block|{
name|PCIC_BASEPERIPH
block|,
name|PCIS_BASEPERIPH_DMA
block|,
literal|"DMA controller"
block|}
block|,
block|{
name|PCIC_BASEPERIPH
block|,
name|PCIS_BASEPERIPH_TIMER
block|,
literal|"timer"
block|}
block|,
block|{
name|PCIC_BASEPERIPH
block|,
name|PCIS_BASEPERIPH_RTC
block|,
literal|"realtime clock"
block|}
block|,
block|{
name|PCIC_BASEPERIPH
block|,
name|PCIS_BASEPERIPH_PCIHOT
block|,
literal|"PCI hot-plug controller"
block|}
block|,
block|{
name|PCIC_INPUTDEV
block|,
operator|-
literal|1
block|,
literal|"input device"
block|}
block|,
block|{
name|PCIC_INPUTDEV
block|,
name|PCIS_INPUTDEV_KEYBOARD
block|,
literal|"keyboard"
block|}
block|,
block|{
name|PCIC_INPUTDEV
block|,
name|PCIS_INPUTDEV_DIGITIZER
block|,
literal|"digitizer"
block|}
block|,
block|{
name|PCIC_INPUTDEV
block|,
name|PCIS_INPUTDEV_MOUSE
block|,
literal|"mouse"
block|}
block|,
block|{
name|PCIC_INPUTDEV
block|,
name|PCIS_INPUTDEV_SCANNER
block|,
literal|"scanner"
block|}
block|,
block|{
name|PCIC_INPUTDEV
block|,
name|PCIS_INPUTDEV_GAMEPORT
block|,
literal|"gameport"
block|}
block|,
block|{
name|PCIC_DOCKING
block|,
operator|-
literal|1
block|,
literal|"docking station"
block|}
block|,
block|{
name|PCIC_PROCESSOR
block|,
operator|-
literal|1
block|,
literal|"processor"
block|}
block|,
block|{
name|PCIC_SERIALBUS
block|,
operator|-
literal|1
block|,
literal|"serial bus"
block|}
block|,
block|{
name|PCIC_SERIALBUS
block|,
name|PCIS_SERIALBUS_FW
block|,
literal|"FireWire"
block|}
block|,
block|{
name|PCIC_SERIALBUS
block|,
name|PCIS_SERIALBUS_ACCESS
block|,
literal|"AccessBus"
block|}
block|,
block|{
name|PCIC_SERIALBUS
block|,
name|PCIS_SERIALBUS_SSA
block|,
literal|"SSA"
block|}
block|,
block|{
name|PCIC_SERIALBUS
block|,
name|PCIS_SERIALBUS_USB
block|,
literal|"USB"
block|}
block|,
block|{
name|PCIC_SERIALBUS
block|,
name|PCIS_SERIALBUS_FC
block|,
literal|"Fibre Channel"
block|}
block|,
block|{
name|PCIC_SERIALBUS
block|,
name|PCIS_SERIALBUS_SMBUS
block|,
literal|"SMBus"
block|}
block|,
block|{
name|PCIC_WIRELESS
block|,
operator|-
literal|1
block|,
literal|"wireless controller"
block|}
block|,
block|{
name|PCIC_WIRELESS
block|,
name|PCIS_WIRELESS_IRDA
block|,
literal|"iRDA"
block|}
block|,
block|{
name|PCIC_WIRELESS
block|,
name|PCIS_WIRELESS_IR
block|,
literal|"IR"
block|}
block|,
block|{
name|PCIC_WIRELESS
block|,
name|PCIS_WIRELESS_RF
block|,
literal|"RF"
block|}
block|,
block|{
name|PCIC_INTELLIIO
block|,
operator|-
literal|1
block|,
literal|"intelligent I/O controller"
block|}
block|,
block|{
name|PCIC_INTELLIIO
block|,
name|PCIS_INTELLIIO_I2O
block|,
literal|"I2O"
block|}
block|,
block|{
name|PCIC_SATCOM
block|,
operator|-
literal|1
block|,
literal|"satellite communication"
block|}
block|,
block|{
name|PCIC_SATCOM
block|,
name|PCIS_SATCOM_TV
block|,
literal|"sat TV"
block|}
block|,
block|{
name|PCIC_SATCOM
block|,
name|PCIS_SATCOM_AUDIO
block|,
literal|"sat audio"
block|}
block|,
block|{
name|PCIC_SATCOM
block|,
name|PCIS_SATCOM_VOICE
block|,
literal|"sat voice"
block|}
block|,
block|{
name|PCIC_SATCOM
block|,
name|PCIS_SATCOM_DATA
block|,
literal|"sat data"
block|}
block|,
block|{
name|PCIC_CRYPTO
block|,
operator|-
literal|1
block|,
literal|"encrypt/decrypt"
block|}
block|,
block|{
name|PCIC_CRYPTO
block|,
name|PCIS_CRYPTO_NETCOMP
block|,
literal|"network/computer crypto"
block|}
block|,
block|{
name|PCIC_CRYPTO
block|,
name|PCIS_CRYPTO_ENTERTAIN
block|,
literal|"entertainment crypto"
block|}
block|,
block|{
name|PCIC_DASP
block|,
operator|-
literal|1
block|,
literal|"dasp"
block|}
block|,
block|{
name|PCIC_DASP
block|,
name|PCIS_DASP_DPIO
block|,
literal|"DPIO module"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_function
name|void
name|pci_probe_nomatch
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|scp
decl_stmt|,
modifier|*
name|device
decl_stmt|;
comment|/* 	 * Look for a listing for this device in a loaded device database. 	 */
if|if
condition|(
operator|(
name|device
operator|=
name|pci_describe_device
argument_list|(
name|child
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"<%s>"
argument_list|,
name|device
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|device
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Scan the class/subclass descriptions for a general 		 * description. 		 */
name|cp
operator|=
literal|"unknown"
expr_stmt|;
name|scp
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|pci_nomatch_tab
index|[
name|i
index|]
operator|.
name|desc
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pci_nomatch_tab
index|[
name|i
index|]
operator|.
name|class
operator|==
name|pci_get_class
argument_list|(
name|child
argument_list|)
condition|)
block|{
if|if
condition|(
name|pci_nomatch_tab
index|[
name|i
index|]
operator|.
name|subclass
operator|==
operator|-
literal|1
condition|)
block|{
name|cp
operator|=
name|pci_nomatch_tab
index|[
name|i
index|]
operator|.
name|desc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pci_nomatch_tab
index|[
name|i
index|]
operator|.
name|subclass
operator|==
name|pci_get_subclass
argument_list|(
name|child
argument_list|)
condition|)
block|{
name|scp
operator|=
name|pci_nomatch_tab
index|[
name|i
index|]
operator|.
name|desc
expr_stmt|;
block|}
block|}
block|}
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"<%s%s%s>"
argument_list|,
name|cp
condition|?
name|cp
else|:
literal|""
argument_list|,
operator|(
operator|(
name|cp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|scp
operator|!=
name|NULL
operator|)
operator|)
condition|?
literal|", "
else|:
literal|""
argument_list|,
name|scp
condition|?
name|scp
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" at device %d.%d (no driver attached)\n"
argument_list|,
name|pci_get_slot
argument_list|(
name|child
argument_list|)
argument_list|,
name|pci_get_function
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_do_power_nodriver
condition|)
name|pci_cfg_save
argument_list|(
name|child
argument_list|,
operator|(
expr|struct
name|pci_devinfo
operator|*
operator|)
name|device_get_ivars
argument_list|(
name|child
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Parse the PCI device database, if loaded, and return a pointer to a  * description of the device.  *  * The database is flat text formatted as follows:  *  * Any line not in a valid format is ignored.  * Lines are terminated with newline '\n' characters.  *  * A VENDOR line consists of the 4 digit (hex) vendor code, a TAB, then  * the vendor name.  *  * A DEVICE line is entered immediately below the corresponding VENDOR ID.  * - devices cannot be listed without a corresponding VENDOR line.  * A DEVICE line consists of a TAB, the 4 digit (hex) device code,  * another TAB, then the device name.  */
end_comment

begin_comment
comment|/*  * Assuming (ptr) points to the beginning of a line in the database,  * return the vendor or device and description of the next entry.  * The value of (vendor) or (device) inappropriate for the entry type  * is set to -1.  Returns nonzero at the end of the database.  *  * Note that this is slightly unrobust in the face of corrupt data;  * we attempt to safeguard against this by spamming the end of the  * database with a newline when we initialise.  */
end_comment

begin_function
specifier|static
name|int
name|pci_describe_parse_line
parameter_list|(
name|char
modifier|*
modifier|*
name|ptr
parameter_list|,
name|int
modifier|*
name|vendor
parameter_list|,
name|int
modifier|*
name|device
parameter_list|,
name|char
modifier|*
modifier|*
name|desc
parameter_list|)
block|{
name|char
modifier|*
name|cp
init|=
operator|*
name|ptr
decl_stmt|;
name|int
name|left
decl_stmt|;
operator|*
name|device
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|vendor
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
operator|*
name|desc
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|left
operator|=
name|pci_vendordata_size
operator|-
operator|(
name|cp
operator|-
name|pci_vendordata
operator|)
expr_stmt|;
if|if
condition|(
name|left
operator|<=
literal|0
condition|)
block|{
operator|*
name|ptr
operator|=
name|cp
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* vendor entry? */
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'\t'
operator|&&
name|sscanf
argument_list|(
name|cp
argument_list|,
literal|"%x\t%80[^\n]"
argument_list|,
name|vendor
argument_list|,
operator|*
name|desc
argument_list|)
operator|==
literal|2
condition|)
break|break;
comment|/* device entry? */
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\t'
operator|&&
name|sscanf
argument_list|(
name|cp
argument_list|,
literal|"%x\t%80[^\n]"
argument_list|,
name|device
argument_list|,
operator|*
name|desc
argument_list|)
operator|==
literal|2
condition|)
break|break;
comment|/* skip to next line */
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\n'
operator|&&
name|left
operator|>
literal|0
condition|)
block|{
name|cp
operator|++
expr_stmt|;
name|left
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\n'
condition|)
block|{
name|cp
operator|++
expr_stmt|;
name|left
operator|--
expr_stmt|;
block|}
block|}
comment|/* skip to next line */
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\n'
operator|&&
name|left
operator|>
literal|0
condition|)
block|{
name|cp
operator|++
expr_stmt|;
name|left
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\n'
operator|&&
name|left
operator|>
literal|0
condition|)
name|cp
operator|++
expr_stmt|;
operator|*
name|ptr
operator|=
name|cp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|pci_describe_device
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|vendor
decl_stmt|,
name|device
decl_stmt|;
name|char
modifier|*
name|desc
decl_stmt|,
modifier|*
name|vp
decl_stmt|,
modifier|*
name|dp
decl_stmt|,
modifier|*
name|line
decl_stmt|;
name|desc
operator|=
name|vp
operator|=
name|dp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * If we have no vendor data, we can't do anything. 	 */
if|if
condition|(
name|pci_vendordata
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Scan the vendor data looking for this device 	 */
name|line
operator|=
name|pci_vendordata
expr_stmt|;
if|if
condition|(
operator|(
name|vp
operator|=
name|malloc
argument_list|(
literal|80
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|pci_describe_parse_line
argument_list|(
operator|&
name|line
argument_list|,
operator|&
name|vendor
argument_list|,
operator|&
name|device
argument_list|,
operator|&
name|vp
argument_list|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|vendor
operator|==
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|dp
operator|=
name|malloc
argument_list|(
literal|80
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|pci_describe_parse_line
argument_list|(
operator|&
name|line
argument_list|,
operator|&
name|vendor
argument_list|,
operator|&
name|device
argument_list|,
operator|&
name|dp
argument_list|)
condition|)
block|{
operator|*
name|dp
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|vendor
operator|!=
operator|-
literal|1
condition|)
block|{
operator|*
name|dp
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|device
operator|==
name|pci_get_device
argument_list|(
name|dev
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|dp
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|snprintf
argument_list|(
name|dp
argument_list|,
literal|80
argument_list|,
literal|"0x%x"
argument_list|,
name|pci_get_device
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|desc
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|vp
argument_list|)
operator|+
name|strlen
argument_list|(
name|dp
argument_list|)
operator|+
literal|3
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|sprintf
argument_list|(
name|desc
argument_list|,
literal|"%s, %s"
argument_list|,
name|vp
argument_list|,
name|dp
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|vp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|vp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|dp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|desc
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_read_ivar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|which
parameter_list|,
name|uintptr_t
modifier|*
name|result
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
decl_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|cfg
operator|=
operator|&
name|dinfo
operator|->
name|cfg
expr_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|PCI_IVAR_ETHADDR
case|:
comment|/* 		 * The generic accessor doesn't deal with failure, so 		 * we set the return value, then return an error. 		 */
operator|*
operator|(
operator|(
name|uint8_t
operator|*
operator|*
operator|)
name|result
operator|)
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
case|case
name|PCI_IVAR_SUBVENDOR
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|subvendor
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_SUBDEVICE
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|subdevice
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_VENDOR
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|vendor
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_DEVICE
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|device
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_DEVID
case|:
operator|*
name|result
operator|=
operator|(
name|cfg
operator|->
name|device
operator|<<
literal|16
operator|)
operator||
name|cfg
operator|->
name|vendor
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_CLASS
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|baseclass
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_SUBCLASS
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|subclass
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_PROGIF
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|progif
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_REVID
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|revid
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_INTPIN
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|intpin
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_IRQ
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|intline
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_BUS
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|bus
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_SLOT
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|slot
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_FUNCTION
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|func
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_CMDREG
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|cmdreg
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_CACHELNSZ
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|cachelnsz
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_MINGNT
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|mingnt
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_MAXLAT
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|maxlat
expr_stmt|;
break|break;
case|case
name|PCI_IVAR_LATTIMER
case|:
operator|*
name|result
operator|=
name|cfg
operator|->
name|lattimer
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_write_ivar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|which
parameter_list|,
name|uintptr_t
name|value
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|PCI_IVAR_INTPIN
case|:
name|dinfo
operator|->
name|cfg
operator|.
name|intpin
operator|=
name|value
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|PCI_IVAR_ETHADDR
case|:
case|case
name|PCI_IVAR_SUBVENDOR
case|:
case|case
name|PCI_IVAR_SUBDEVICE
case|:
case|case
name|PCI_IVAR_VENDOR
case|:
case|case
name|PCI_IVAR_DEVICE
case|:
case|case
name|PCI_IVAR_DEVID
case|:
case|case
name|PCI_IVAR_CLASS
case|:
case|case
name|PCI_IVAR_SUBCLASS
case|:
case|case
name|PCI_IVAR_PROGIF
case|:
case|case
name|PCI_IVAR_REVID
case|:
case|case
name|PCI_IVAR_IRQ
case|:
case|case
name|PCI_IVAR_BUS
case|:
case|case
name|PCI_IVAR_SLOT
case|:
case|case
name|PCI_IVAR_FUNCTION
case|:
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* disallow for now */
default|default:
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
block|}
end_function

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_include
include|#
directive|include
file|<sys/cons.h>
end_include

begin_comment
comment|/*  * List resources based on pci map registers, used for within ddb  */
end_comment

begin_macro
name|DB_SHOW_COMMAND
argument_list|(
argument|pciregs
argument_list|,
argument|db_pci_dump
argument_list|)
end_macro

begin_block
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|struct
name|devlist
modifier|*
name|devlist_head
decl_stmt|;
name|struct
name|pci_conf
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|,
name|none_count
decl_stmt|;
name|none_count
operator|=
literal|0
expr_stmt|;
comment|/* get the head of the device queue */
name|devlist_head
operator|=
operator|&
name|pci_devq
expr_stmt|;
comment|/* 	 * Go through the list of devices and print out devices 	 */
for|for
control|(
name|error
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
operator|,
name|dinfo
operator|=
name|STAILQ_FIRST
argument_list|(
name|devlist_head
argument_list|)
init|;
operator|(
name|dinfo
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|error
operator|==
literal|0
operator|)
operator|&&
operator|(
name|i
operator|<
name|pci_numdevs
operator|)
operator|&&
operator|!
name|db_pager_quit
condition|;
name|dinfo
operator|=
name|STAILQ_NEXT
argument_list|(
name|dinfo
argument_list|,
name|pci_links
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
comment|/* Populate pd_name and pd_unit */
name|name
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dinfo
operator|->
name|cfg
operator|.
name|dev
condition|)
name|name
operator|=
name|device_get_name
argument_list|(
name|dinfo
operator|->
name|cfg
operator|.
name|dev
argument_list|)
expr_stmt|;
name|p
operator|=
operator|&
name|dinfo
operator|->
name|conf
expr_stmt|;
name|db_printf
argument_list|(
literal|"%s%d@pci%d:%d:%d:\tclass=0x%06x card=0x%08x "
literal|"chip=0x%08x rev=0x%02x hdr=0x%02x\n"
argument_list|,
operator|(
name|name
operator|&&
operator|*
name|name
operator|)
condition|?
name|name
else|:
literal|"none"
argument_list|,
operator|(
name|name
operator|&&
operator|*
name|name
operator|)
condition|?
operator|(
name|int
operator|)
name|device_get_unit
argument_list|(
name|dinfo
operator|->
name|cfg
operator|.
name|dev
argument_list|)
else|:
name|none_count
operator|++
argument_list|,
name|p
operator|->
name|pc_sel
operator|.
name|pc_bus
argument_list|,
name|p
operator|->
name|pc_sel
operator|.
name|pc_dev
argument_list|,
name|p
operator|->
name|pc_sel
operator|.
name|pc_func
argument_list|,
operator|(
name|p
operator|->
name|pc_class
operator|<<
literal|16
operator|)
operator||
operator|(
name|p
operator|->
name|pc_subclass
operator|<<
literal|8
operator|)
operator||
name|p
operator|->
name|pc_progif
argument_list|,
operator|(
name|p
operator|->
name|pc_subdevice
operator|<<
literal|16
operator|)
operator||
name|p
operator|->
name|pc_subvendor
argument_list|,
operator|(
name|p
operator|->
name|pc_device
operator|<<
literal|16
operator|)
operator||
name|p
operator|->
name|pc_vendor
argument_list|,
name|p
operator|->
name|pc_revid
argument_list|,
name|p
operator|->
name|pc_hdr
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DDB */
end_comment

begin_function
specifier|static
name|struct
name|resource
modifier|*
name|pci_alloc_map
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|rid
parameter_list|,
name|u_long
name|start
parameter_list|,
name|u_long
name|end
parameter_list|,
name|u_long
name|count
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|struct
name|resource_list
modifier|*
name|rl
init|=
operator|&
name|dinfo
operator|->
name|resources
decl_stmt|;
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|pci_addr_t
name|map
decl_stmt|,
name|testval
decl_stmt|;
name|int
name|mapsize
decl_stmt|;
comment|/* 	 * Weed out the bogons, and figure out how large the BAR/map 	 * is.  Bars that read back 0 here are bogus and unimplemented. 	 * Note: atapci in legacy mode are special and handled elsewhere 	 * in the code.  If you have a atapci device in legacy mode and 	 * it fails here, that other code is broken. 	 */
name|res
operator|=
name|NULL
expr_stmt|;
name|map
operator|=
name|pci_read_config
argument_list|(
name|child
argument_list|,
operator|*
name|rid
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|child
argument_list|,
operator|*
name|rid
argument_list|,
literal|0xffffffff
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|testval
operator|=
name|pci_read_config
argument_list|(
name|child
argument_list|,
operator|*
name|rid
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_maprange
argument_list|(
name|testval
argument_list|)
operator|==
literal|64
condition|)
name|map
operator||=
operator|(
name|pci_addr_t
operator|)
name|pci_read_config
argument_list|(
name|child
argument_list|,
operator|*
name|rid
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
operator|<<
literal|32
expr_stmt|;
if|if
condition|(
name|pci_mapbase
argument_list|(
name|testval
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|pci_maptype
argument_list|(
name|testval
argument_list|)
operator|&
name|PCI_MAPMEM
condition|)
block|{
if|if
condition|(
name|type
operator|!=
name|SYS_RES_MEMORY
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"child %s requested type %d for rid %#x,"
literal|" but the BAR says it is an memio\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|child
argument_list|)
argument_list|,
name|type
argument_list|,
operator|*
name|rid
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|type
operator|!=
name|SYS_RES_IOPORT
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"child %s requested type %d for rid %#x,"
literal|" but the BAR says it is an ioport\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|child
argument_list|)
argument_list|,
name|type
argument_list|,
operator|*
name|rid
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
comment|/* 	 * For real BARs, we need to override the size that 	 * the driver requests, because that's what the BAR 	 * actually uses and we would otherwise have a 	 * situation where we might allocate the excess to 	 * another driver, which won't work. 	 */
name|mapsize
operator|=
name|pci_mapsize
argument_list|(
name|testval
argument_list|)
expr_stmt|;
name|count
operator|=
literal|1UL
operator|<<
name|mapsize
expr_stmt|;
if|if
condition|(
name|RF_ALIGNMENT
argument_list|(
name|flags
argument_list|)
operator|<
name|mapsize
condition|)
name|flags
operator|=
operator|(
name|flags
operator|&
operator|~
name|RF_ALIGNMENT_MASK
operator|)
operator||
name|RF_ALIGNMENT_LOG2
argument_list|(
name|mapsize
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate enough resource, and then write back the 	 * appropriate bar for that resource. 	 */
name|res
operator|=
name|BUS_ALLOC_RESOURCE
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|child
argument_list|,
literal|"%#lx bytes of rid %#x res %d failed (%#lx, %#lx).\n"
argument_list|,
name|count
argument_list|,
operator|*
name|rid
argument_list|,
name|type
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|resource_list_add
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
operator|*
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|rle
operator|=
name|resource_list_find
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
operator|*
name|rid
argument_list|)
expr_stmt|;
if|if
condition|(
name|rle
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"pci_alloc_map: unexpectedly can't find resource."
argument_list|)
expr_stmt|;
name|rle
operator|->
name|res
operator|=
name|res
expr_stmt|;
name|rle
operator|->
name|start
operator|=
name|rman_get_start
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|rle
operator|->
name|end
operator|=
name|rman_get_end
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|rle
operator|->
name|count
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|child
argument_list|,
literal|"Lazy allocation of %#lx bytes rid %#x type %d at %#lx\n"
argument_list|,
name|count
argument_list|,
operator|*
name|rid
argument_list|,
name|type
argument_list|,
name|rman_get_start
argument_list|(
name|res
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|=
name|rman_get_start
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|out
label|:
empty_stmt|;
name|pci_write_config
argument_list|(
name|child
argument_list|,
operator|*
name|rid
argument_list|,
name|map
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_maprange
argument_list|(
name|testval
argument_list|)
operator|==
literal|64
condition|)
name|pci_write_config
argument_list|(
name|child
argument_list|,
operator|*
name|rid
operator|+
literal|4
argument_list|,
name|map
operator|>>
literal|32
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|resource
modifier|*
name|pci_alloc_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|rid
parameter_list|,
name|u_long
name|start
parameter_list|,
name|u_long
name|end
parameter_list|,
name|u_long
name|count
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|struct
name|resource_list
modifier|*
name|rl
init|=
operator|&
name|dinfo
operator|->
name|resources
decl_stmt|;
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
comment|/* 	 * Perform lazy resource allocation 	 */
if|if
condition|(
name|device_get_parent
argument_list|(
name|child
argument_list|)
operator|==
name|dev
condition|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SYS_RES_IRQ
case|:
comment|/* 			 * Can't alloc legacy interrupt once MSI messages 			 * have been allocated. 			 */
if|if
condition|(
operator|*
name|rid
operator|==
literal|0
operator|&&
operator|(
name|cfg
operator|->
name|msi
operator|.
name|msi_alloc
operator|>
literal|0
operator|||
name|cfg
operator|->
name|msix
operator|.
name|msix_alloc
operator|>
literal|0
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 			 * If the child device doesn't have an 			 * interrupt routed and is deserving of an 			 * interrupt, try to assign it one. 			 */
if|if
condition|(
operator|*
name|rid
operator|==
literal|0
operator|&&
operator|!
name|PCI_INTERRUPT_VALID
argument_list|(
name|cfg
operator|->
name|intline
argument_list|)
operator|&&
operator|(
name|cfg
operator|->
name|intpin
operator|!=
literal|0
operator|)
condition|)
name|pci_assign_interrupt
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYS_RES_IOPORT
case|:
case|case
name|SYS_RES_MEMORY
case|:
if|if
condition|(
operator|*
name|rid
operator|<
name|PCIR_BAR
argument_list|(
name|cfg
operator|->
name|nummaps
argument_list|)
condition|)
block|{
comment|/* 				 * Enable the I/O mode.  We should 				 * also be assigning resources too 				 * when none are present.  The 				 * resource_list_alloc kind of sorta does 				 * this... 				 */
if|if
condition|(
name|PCI_ENABLE_IO
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|rle
operator|=
name|resource_list_find
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
operator|*
name|rid
argument_list|)
expr_stmt|;
if|if
condition|(
name|rle
operator|==
name|NULL
condition|)
return|return
operator|(
name|pci_alloc_map
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
operator|)
return|;
break|break;
block|}
comment|/* 		 * If we've already allocated the resource, then 		 * return it now.  But first we may need to activate 		 * it, since we don't allocate the resource as active 		 * above.  Normally this would be done down in the 		 * nexus, but since we short-circuit that path we have 		 * to do its job here.  Not sure if we should free the 		 * resource if it fails to activate. 		 */
name|rle
operator|=
name|resource_list_find
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
operator|*
name|rid
argument_list|)
expr_stmt|;
if|if
condition|(
name|rle
operator|!=
name|NULL
operator|&&
name|rle
operator|->
name|res
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|child
argument_list|,
literal|"Reserved %#lx bytes for rid %#x type %d at %#lx\n"
argument_list|,
name|rman_get_size
argument_list|(
name|rle
operator|->
name|res
argument_list|)
argument_list|,
operator|*
name|rid
argument_list|,
name|type
argument_list|,
name|rman_get_start
argument_list|(
name|rle
operator|->
name|res
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|RF_ACTIVE
operator|)
operator|&&
name|bus_generic_activate_resource
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
operator|*
name|rid
argument_list|,
name|rle
operator|->
name|res
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|NULL
return|;
return|return
operator|(
name|rle
operator|->
name|res
operator|)
return|;
block|}
block|}
return|return
operator|(
name|resource_list_alloc
argument_list|(
name|rl
argument_list|,
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pci_delete_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|struct
name|resource_list
modifier|*
name|rl
decl_stmt|;
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
if|if
condition|(
name|device_get_parent
argument_list|(
name|child
argument_list|)
operator|!=
name|dev
condition|)
return|return;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|rl
operator|=
operator|&
name|dinfo
operator|->
name|resources
expr_stmt|;
name|rle
operator|=
name|resource_list_find
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
name|rid
argument_list|)
expr_stmt|;
if|if
condition|(
name|rle
condition|)
block|{
if|if
condition|(
name|rle
operator|->
name|res
condition|)
block|{
if|if
condition|(
name|rman_get_device
argument_list|(
name|rle
operator|->
name|res
argument_list|)
operator|!=
name|dev
operator|||
name|rman_get_flags
argument_list|(
name|rle
operator|->
name|res
argument_list|)
operator|&
name|RF_ACTIVE
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"delete_resource: "
literal|"Resource still owned by child, oops. "
literal|"(type=%d, rid=%d, addr=%lx)\n"
argument_list|,
name|rle
operator|->
name|type
argument_list|,
name|rle
operator|->
name|rid
argument_list|,
name|rman_get_start
argument_list|(
name|rle
operator|->
name|res
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|rle
operator|->
name|res
argument_list|)
expr_stmt|;
block|}
name|resource_list_delete
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
name|rid
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Why do we turn off the PCI configuration BAR when we delete a 	 * resource? -- imp 	 */
name|pci_write_config
argument_list|(
name|child
argument_list|,
name|rid
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|BUS_DELETE_RESOURCE
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|resource_list
modifier|*
name|pci_get_resource_list
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
return|return
operator|(
operator|&
name|dinfo
operator|->
name|resources
operator|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|pci_read_config_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|width
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
return|return
operator|(
name|PCIB_READ_CONFIG
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|cfg
operator|->
name|bus
argument_list|,
name|cfg
operator|->
name|slot
argument_list|,
name|cfg
operator|->
name|func
argument_list|,
name|reg
argument_list|,
name|width
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pci_write_config_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|reg
parameter_list|,
name|uint32_t
name|val
parameter_list|,
name|int
name|width
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
name|PCIB_WRITE_CONFIG
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|cfg
operator|->
name|bus
argument_list|,
name|cfg
operator|->
name|slot
argument_list|,
name|cfg
operator|->
name|func
argument_list|,
name|reg
argument_list|,
name|val
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pci_child_location_str_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
literal|"slot=%d function=%d"
argument_list|,
name|pci_get_slot
argument_list|(
name|child
argument_list|)
argument_list|,
name|pci_get_function
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_child_pnpinfo_str_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
decl_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|cfg
operator|=
operator|&
name|dinfo
operator|->
name|cfg
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
literal|"vendor=0x%04x device=0x%04x subvendor=0x%04x "
literal|"subdevice=0x%04x class=0x%02x%02x%02x"
argument_list|,
name|cfg
operator|->
name|vendor
argument_list|,
name|cfg
operator|->
name|device
argument_list|,
name|cfg
operator|->
name|subvendor
argument_list|,
name|cfg
operator|->
name|subdevice
argument_list|,
name|cfg
operator|->
name|baseclass
argument_list|,
name|cfg
operator|->
name|subclass
argument_list|,
name|cfg
operator|->
name|progif
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_assign_interrupt_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
init|=
operator|&
name|dinfo
operator|->
name|cfg
decl_stmt|;
return|return
operator|(
name|PCIB_ROUTE_INTERRUPT
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|cfg
operator|->
name|intpin
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pci_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|what
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
specifier|static
name|struct
name|cdev
modifier|*
name|pci_cdev
decl_stmt|;
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|STAILQ_INIT
argument_list|(
operator|&
name|pci_devq
argument_list|)
expr_stmt|;
name|pci_generation
operator|=
literal|0
expr_stmt|;
name|pci_cdev
operator|=
name|make_dev
argument_list|(
operator|&
name|pcicdev
argument_list|,
literal|0
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0644
argument_list|,
literal|"pci"
argument_list|)
expr_stmt|;
name|pci_load_vendor_data
argument_list|()
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|destroy_dev
argument_list|(
name|pci_cdev
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pci_cfg_restore
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|pci_devinfo
modifier|*
name|dinfo
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* 	 * Only do header type 0 devices.  Type 1 devices are bridges, 	 * which we know need special treatment.  Type 2 devices are 	 * cardbus bridges which also require special treatment. 	 * Other types are unknown, and we err on the side of safety 	 * by ignoring them. 	 */
if|if
condition|(
name|dinfo
operator|->
name|cfg
operator|.
name|hdrtype
operator|!=
literal|0
condition|)
return|return;
comment|/* 	 * Restore the device to full power mode.  We must do this 	 * before we restore the registers because moving from D3 to 	 * D0 will cause the chip's BARs and some other registers to 	 * be reset to some unknown power on reset values.  Cut down 	 * the noise on boot by doing nothing if we are already in 	 * state D0. 	 */
if|if
condition|(
name|pci_get_powerstate
argument_list|(
name|dev
argument_list|)
operator|!=
name|PCI_POWERSTATE_D0
condition|)
block|{
name|pci_set_powerstate
argument_list|(
name|dev
argument_list|,
name|PCI_POWERSTATE_D0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dinfo
operator|->
name|cfg
operator|.
name|nummaps
condition|;
name|i
operator|++
control|)
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_BAR
argument_list|(
name|i
argument_list|)
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|bar
index|[
name|i
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_BIOS
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|bios
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|cmdreg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_INTLINE
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|intline
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_INTPIN
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|intpin
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_MINGNT
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|mingnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_MAXLAT
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|maxlat
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_CACHELNSZ
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|cachelnsz
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_LATTIMER
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|lattimer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PROGIF
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|progif
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_REVID
argument_list|,
name|dinfo
operator|->
name|cfg
operator|.
name|revid
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Restore MSI configuration if it is present.  If MSI is enabled, 	 * then restore the data and addr registers. 	 */
if|if
condition|(
name|dinfo
operator|->
name|cfg
operator|.
name|msi
operator|.
name|msi_location
operator|!=
literal|0
condition|)
name|pci_resume_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pci_cfg_save
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|pci_devinfo
modifier|*
name|dinfo
parameter_list|,
name|int
name|setstate
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint32_t
name|cls
decl_stmt|;
name|int
name|ps
decl_stmt|;
comment|/* 	 * Only do header type 0 devices.  Type 1 devices are bridges, which 	 * we know need special treatment.  Type 2 devices are cardbus bridges 	 * which also require special treatment.  Other types are unknown, and 	 * we err on the side of safety by ignoring them.  Powering down 	 * bridges should not be undertaken lightly. 	 */
if|if
condition|(
name|dinfo
operator|->
name|cfg
operator|.
name|hdrtype
operator|!=
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dinfo
operator|->
name|cfg
operator|.
name|nummaps
condition|;
name|i
operator|++
control|)
name|dinfo
operator|->
name|cfg
operator|.
name|bar
index|[
name|i
index|]
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_BAR
argument_list|(
name|i
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|bios
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_BIOS
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* 	 * Some drivers apparently write to these registers w/o updating our 	 * cached copy.  No harm happens if we update the copy, so do so here 	 * so we can restore them.  The COMMAND register is modified by the 	 * bus w/o updating the cache.  This should represent the normally 	 * writable portion of the 'defined' part of type 0 headers.  In 	 * theory we also need to save/restore the PCI capability structures 	 * we know about, but apart from power we don't know any that are 	 * writable. 	 */
name|dinfo
operator|->
name|cfg
operator|.
name|subvendor
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SUBVEND_0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|subdevice
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SUBDEV_0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|vendor
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_VENDOR
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|device
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_DEVICE
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|cmdreg
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|intline
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_INTLINE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|intpin
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_INTPIN
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|mingnt
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_MINGNT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|maxlat
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_MAXLAT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|cachelnsz
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_CACHELNSZ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|lattimer
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_LATTIMER
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|baseclass
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_CLASS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|subclass
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SUBCLASS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|progif
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PROGIF
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|cfg
operator|.
name|revid
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_REVID
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * don't set the state for display devices, base peripherals and 	 * memory devices since bad things happen when they are powered down. 	 * We should (a) have drivers that can easily detach and (b) use 	 * generic drivers for these devices so that some device actually 	 * attaches.  We need to make sure that when we implement (a) we don't 	 * power the device down on a reattach. 	 */
name|cls
operator|=
name|pci_get_class
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|setstate
condition|)
return|return;
switch|switch
condition|(
name|pci_do_power_nodriver
condition|)
block|{
case|case
literal|0
case|:
comment|/* NO powerdown at all */
return|return;
case|case
literal|1
case|:
comment|/* Conservative about what to power down */
if|if
condition|(
name|cls
operator|==
name|PCIC_STORAGE
condition|)
return|return;
comment|/*FALLTHROUGH*/
case|case
literal|2
case|:
comment|/* Agressive about what to power down */
if|if
condition|(
name|cls
operator|==
name|PCIC_DISPLAY
operator|||
name|cls
operator|==
name|PCIC_MEMORY
operator|||
name|cls
operator|==
name|PCIC_BASEPERIPH
condition|)
return|return;
comment|/*FALLTHROUGH*/
case|case
literal|3
case|:
comment|/* Power down everything */
break|break;
block|}
comment|/* 	 * PCI spec says we can only go into D3 state from D0 state. 	 * Transition from D[12] into D0 before going to D3 state. 	 */
name|ps
operator|=
name|pci_get_powerstate
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|!=
name|PCI_POWERSTATE_D0
operator|&&
name|ps
operator|!=
name|PCI_POWERSTATE_D3
condition|)
name|pci_set_powerstate
argument_list|(
name|dev
argument_list|,
name|PCI_POWERSTATE_D0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_get_powerstate
argument_list|(
name|dev
argument_list|)
operator|!=
name|PCI_POWERSTATE_D3
condition|)
name|pci_set_powerstate
argument_list|(
name|dev
argument_list|,
name|PCI_POWERSTATE_D3
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

