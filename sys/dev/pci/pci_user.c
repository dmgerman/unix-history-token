begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1997, Stefan Esser<se@freebsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_bus.h"
end_include

begin_comment
comment|/* XXX trim includes */
end_comment

begin_include
include|#
directive|include
file|"opt_compat.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/pciio.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|"pcib_if.h"
end_include

begin_include
include|#
directive|include
file|"pci_if.h"
end_include

begin_comment
comment|/*  * This is the user interface to PCI configuration space.  */
end_comment

begin_decl_stmt
specifier|static
name|d_open_t
name|pci_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|pci_close
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|pci_conf_match
parameter_list|(
name|struct
name|pci_match_conf
modifier|*
name|matches
parameter_list|,
name|int
name|num_matches
parameter_list|,
name|struct
name|pci_conf
modifier|*
name|match_buf
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|pci_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cdevsw
name|pcicdev
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_flags
operator|=
name|D_NEEDGIANT
block|,
operator|.
name|d_open
operator|=
name|pci_open
block|,
operator|.
name|d_close
operator|=
name|pci_close
block|,
operator|.
name|d_ioctl
operator|=
name|pci_ioctl
block|,
operator|.
name|d_name
operator|=
literal|"pci"
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|pci_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|oflags
parameter_list|,
name|int
name|devtype
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|oflags
operator|&
name|FWRITE
condition|)
block|{
name|error
operator|=
name|securelevel_gt
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pci_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|devtype
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Match a single pci_conf structure against an array of pci_match_conf  * structures.  The first argument, 'matches', is an array of num_matches  * pci_match_conf structures.  match_buf is a pointer to the pci_conf  * structure that will be compared to every entry in the matches array.  * This function returns 1 on failure, 0 on success.  */
end_comment

begin_function
specifier|static
name|int
name|pci_conf_match
parameter_list|(
name|struct
name|pci_match_conf
modifier|*
name|matches
parameter_list|,
name|int
name|num_matches
parameter_list|,
name|struct
name|pci_conf
modifier|*
name|match_buf
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|matches
operator|==
name|NULL
operator|)
operator|||
operator|(
name|match_buf
operator|==
name|NULL
operator|)
operator|||
operator|(
name|num_matches
operator|<=
literal|0
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_matches
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * I'm not sure why someone would do this...but... 		 */
if|if
condition|(
name|matches
index|[
name|i
index|]
operator|.
name|flags
operator|==
name|PCI_GETCONF_NO_MATCH
condition|)
continue|continue;
comment|/* 		 * Look at each of the match flags.  If it's set, do the 		 * comparison.  If the comparison fails, we don't have a 		 * match, go on to the next item if there is one. 		 */
if|if
condition|(
operator|(
operator|(
name|matches
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|PCI_GETCONF_MATCH_DOMAIN
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|match_buf
operator|->
name|pc_sel
operator|.
name|pc_domain
operator|!=
name|matches
index|[
name|i
index|]
operator|.
name|pc_sel
operator|.
name|pc_domain
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|matches
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|PCI_GETCONF_MATCH_BUS
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|match_buf
operator|->
name|pc_sel
operator|.
name|pc_bus
operator|!=
name|matches
index|[
name|i
index|]
operator|.
name|pc_sel
operator|.
name|pc_bus
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|matches
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|PCI_GETCONF_MATCH_DEV
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|match_buf
operator|->
name|pc_sel
operator|.
name|pc_dev
operator|!=
name|matches
index|[
name|i
index|]
operator|.
name|pc_sel
operator|.
name|pc_dev
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|matches
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|PCI_GETCONF_MATCH_FUNC
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|match_buf
operator|->
name|pc_sel
operator|.
name|pc_func
operator|!=
name|matches
index|[
name|i
index|]
operator|.
name|pc_sel
operator|.
name|pc_func
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|matches
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|PCI_GETCONF_MATCH_VENDOR
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|match_buf
operator|->
name|pc_vendor
operator|!=
name|matches
index|[
name|i
index|]
operator|.
name|pc_vendor
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|matches
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|PCI_GETCONF_MATCH_DEVICE
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|match_buf
operator|->
name|pc_device
operator|!=
name|matches
index|[
name|i
index|]
operator|.
name|pc_device
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|matches
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|PCI_GETCONF_MATCH_CLASS
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|match_buf
operator|->
name|pc_class
operator|!=
name|matches
index|[
name|i
index|]
operator|.
name|pc_class
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|matches
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|PCI_GETCONF_MATCH_UNIT
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|match_buf
operator|->
name|pd_unit
operator|!=
name|matches
index|[
name|i
index|]
operator|.
name|pd_unit
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|matches
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|PCI_GETCONF_MATCH_NAME
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|matches
index|[
name|i
index|]
operator|.
name|pd_name
argument_list|,
name|match_buf
operator|->
name|pd_name
argument_list|,
sizeof|sizeof
argument_list|(
name|match_buf
operator|->
name|pd_name
argument_list|)
argument_list|)
operator|!=
literal|0
operator|)
condition|)
continue|continue;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_FREEBSD4
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_FREEBSD5
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|COMPAT_FREEBSD6
argument_list|)
end_if

begin_define
define|#
directive|define
name|PRE7_COMPAT
end_define

begin_typedef
typedef|typedef
enum|enum
block|{
name|PCI_GETCONF_NO_MATCH_OLD
init|=
literal|0x00
block|,
name|PCI_GETCONF_MATCH_BUS_OLD
init|=
literal|0x01
block|,
name|PCI_GETCONF_MATCH_DEV_OLD
init|=
literal|0x02
block|,
name|PCI_GETCONF_MATCH_FUNC_OLD
init|=
literal|0x04
block|,
name|PCI_GETCONF_MATCH_NAME_OLD
init|=
literal|0x08
block|,
name|PCI_GETCONF_MATCH_UNIT_OLD
init|=
literal|0x10
block|,
name|PCI_GETCONF_MATCH_VENDOR_OLD
init|=
literal|0x20
block|,
name|PCI_GETCONF_MATCH_DEVICE_OLD
init|=
literal|0x40
block|,
name|PCI_GETCONF_MATCH_CLASS_OLD
init|=
literal|0x80
block|}
name|pci_getconf_flags_old
typedef|;
end_typedef

begin_struct
struct|struct
name|pcisel_old
block|{
name|u_int8_t
name|pc_bus
decl_stmt|;
comment|/* bus number */
name|u_int8_t
name|pc_dev
decl_stmt|;
comment|/* device on this bus */
name|u_int8_t
name|pc_func
decl_stmt|;
comment|/* function on this device */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|pci_conf_old
block|{
name|struct
name|pcisel_old
name|pc_sel
decl_stmt|;
comment|/* bus+slot+function */
name|u_int8_t
name|pc_hdr
decl_stmt|;
comment|/* PCI header type */
name|u_int16_t
name|pc_subvendor
decl_stmt|;
comment|/* card vendor ID */
name|u_int16_t
name|pc_subdevice
decl_stmt|;
comment|/* card device ID, assigned by 					   card vendor */
name|u_int16_t
name|pc_vendor
decl_stmt|;
comment|/* chip vendor ID */
name|u_int16_t
name|pc_device
decl_stmt|;
comment|/* chip device ID, assigned by 					   chip vendor */
name|u_int8_t
name|pc_class
decl_stmt|;
comment|/* chip PCI class */
name|u_int8_t
name|pc_subclass
decl_stmt|;
comment|/* chip PCI subclass */
name|u_int8_t
name|pc_progif
decl_stmt|;
comment|/* chip PCI programming interface */
name|u_int8_t
name|pc_revid
decl_stmt|;
comment|/* chip revision ID */
name|char
name|pd_name
index|[
name|PCI_MAXNAMELEN
operator|+
literal|1
index|]
decl_stmt|;
comment|/* device name */
name|u_long
name|pd_unit
decl_stmt|;
comment|/* device unit number */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|pci_match_conf_old
block|{
name|struct
name|pcisel_old
name|pc_sel
decl_stmt|;
comment|/* bus+slot+function */
name|char
name|pd_name
index|[
name|PCI_MAXNAMELEN
operator|+
literal|1
index|]
decl_stmt|;
comment|/* device name */
name|u_long
name|pd_unit
decl_stmt|;
comment|/* Unit number */
name|u_int16_t
name|pc_vendor
decl_stmt|;
comment|/* PCI Vendor ID */
name|u_int16_t
name|pc_device
decl_stmt|;
comment|/* PCI Device ID */
name|u_int8_t
name|pc_class
decl_stmt|;
comment|/* PCI class */
name|pci_getconf_flags_old
name|flags
decl_stmt|;
comment|/* Matching expression */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|pci_io_old
block|{
name|struct
name|pcisel_old
name|pi_sel
decl_stmt|;
comment|/* device to operate on */
name|int
name|pi_reg
decl_stmt|;
comment|/* configuration register to examine */
name|int
name|pi_width
decl_stmt|;
comment|/* width (in bytes) of read or write */
name|u_int32_t
name|pi_data
decl_stmt|;
comment|/* data to write or result of read */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|PCIOCGETCONF_OLD
value|_IOWR('p', 1, struct pci_conf_io)
end_define

begin_define
define|#
directive|define
name|PCIOCREAD_OLD
value|_IOWR('p', 2, struct pci_io_old)
end_define

begin_define
define|#
directive|define
name|PCIOCWRITE_OLD
value|_IOWR('p', 3, struct pci_io_old)
end_define

begin_function_decl
specifier|static
name|int
name|pci_conf_match_old
parameter_list|(
name|struct
name|pci_match_conf_old
modifier|*
name|matches
parameter_list|,
name|int
name|num_matches
parameter_list|,
name|struct
name|pci_conf
modifier|*
name|match_buf
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|pci_conf_match_old
parameter_list|(
name|struct
name|pci_match_conf_old
modifier|*
name|matches
parameter_list|,
name|int
name|num_matches
parameter_list|,
name|struct
name|pci_conf
modifier|*
name|match_buf
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|matches
operator|==
name|NULL
operator|)
operator|||
operator|(
name|match_buf
operator|==
name|NULL
operator|)
operator|||
operator|(
name|num_matches
operator|<=
literal|0
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_matches
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|match_buf
operator|->
name|pc_sel
operator|.
name|pc_domain
operator|!=
literal|0
condition|)
continue|continue;
comment|/* 		 * I'm not sure why someone would do this...but... 		 */
if|if
condition|(
name|matches
index|[
name|i
index|]
operator|.
name|flags
operator|==
name|PCI_GETCONF_NO_MATCH_OLD
condition|)
continue|continue;
comment|/* 		 * Look at each of the match flags.  If it's set, do the 		 * comparison.  If the comparison fails, we don't have a 		 * match, go on to the next item if there is one. 		 */
if|if
condition|(
operator|(
operator|(
name|matches
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|PCI_GETCONF_MATCH_BUS_OLD
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|match_buf
operator|->
name|pc_sel
operator|.
name|pc_bus
operator|!=
name|matches
index|[
name|i
index|]
operator|.
name|pc_sel
operator|.
name|pc_bus
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|matches
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|PCI_GETCONF_MATCH_DEV_OLD
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|match_buf
operator|->
name|pc_sel
operator|.
name|pc_dev
operator|!=
name|matches
index|[
name|i
index|]
operator|.
name|pc_sel
operator|.
name|pc_dev
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|matches
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|PCI_GETCONF_MATCH_FUNC_OLD
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|match_buf
operator|->
name|pc_sel
operator|.
name|pc_func
operator|!=
name|matches
index|[
name|i
index|]
operator|.
name|pc_sel
operator|.
name|pc_func
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|matches
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|PCI_GETCONF_MATCH_VENDOR_OLD
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|match_buf
operator|->
name|pc_vendor
operator|!=
name|matches
index|[
name|i
index|]
operator|.
name|pc_vendor
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|matches
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|PCI_GETCONF_MATCH_DEVICE_OLD
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|match_buf
operator|->
name|pc_device
operator|!=
name|matches
index|[
name|i
index|]
operator|.
name|pc_device
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|matches
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|PCI_GETCONF_MATCH_CLASS_OLD
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|match_buf
operator|->
name|pc_class
operator|!=
name|matches
index|[
name|i
index|]
operator|.
name|pc_class
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|matches
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|PCI_GETCONF_MATCH_UNIT_OLD
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|match_buf
operator|->
name|pd_unit
operator|!=
name|matches
index|[
name|i
index|]
operator|.
name|pd_unit
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|matches
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|PCI_GETCONF_MATCH_NAME_OLD
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|matches
index|[
name|i
index|]
operator|.
name|pd_name
argument_list|,
name|match_buf
operator|->
name|pd_name
argument_list|,
sizeof|sizeof
argument_list|(
name|match_buf
operator|->
name|pd_name
argument_list|)
argument_list|)
operator|!=
literal|0
operator|)
condition|)
continue|continue;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|pci_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|device_t
name|pcidev
decl_stmt|,
name|brdev
decl_stmt|;
name|void
modifier|*
name|confdata
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|devlist
modifier|*
name|devlist_head
decl_stmt|;
name|struct
name|pci_conf_io
modifier|*
name|cio
decl_stmt|;
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|struct
name|pci_io
modifier|*
name|io
decl_stmt|;
name|struct
name|pci_bar_io
modifier|*
name|bio
decl_stmt|;
name|struct
name|pci_match_conf
modifier|*
name|pattern_buf
decl_stmt|;
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
name|uint32_t
name|value
decl_stmt|;
name|size_t
name|confsz
decl_stmt|,
name|iolen
decl_stmt|,
name|pbufsz
decl_stmt|;
name|int
name|error
decl_stmt|,
name|ionum
decl_stmt|,
name|i
decl_stmt|,
name|num_patterns
decl_stmt|;
ifdef|#
directive|ifdef
name|PRE7_COMPAT
name|struct
name|pci_conf_old
name|conf_old
decl_stmt|;
name|struct
name|pci_io
name|iodata
decl_stmt|;
name|struct
name|pci_io_old
modifier|*
name|io_old
decl_stmt|;
name|struct
name|pci_match_conf_old
modifier|*
name|pattern_buf_old
decl_stmt|;
name|io_old
operator|=
name|NULL
expr_stmt|;
name|pattern_buf_old
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|&&
name|cmd
operator|!=
name|PCIOCGETBAR
operator|&&
name|cmd
operator|!=
name|PCIOCGETCONF
operator|&&
name|cmd
operator|!=
name|PCIOCGETCONF_OLD
condition|)
return|return
name|EPERM
return|;
else|#
directive|else
if|if
condition|(
operator|!
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|&&
name|cmd
operator|!=
name|PCIOCGETBAR
operator|&&
name|cmd
operator|!=
name|PCIOCGETCONF
condition|)
return|return
name|EPERM
return|;
endif|#
directive|endif
switch|switch
condition|(
name|cmd
condition|)
block|{
ifdef|#
directive|ifdef
name|PRE7_COMPAT
case|case
name|PCIOCGETCONF_OLD
case|:
comment|/* FALLTHROUGH */
endif|#
directive|endif
case|case
name|PCIOCGETCONF
case|:
name|cio
operator|=
operator|(
expr|struct
name|pci_conf_io
operator|*
operator|)
name|data
expr_stmt|;
name|pattern_buf
operator|=
name|NULL
expr_stmt|;
name|num_patterns
operator|=
literal|0
expr_stmt|;
name|dinfo
operator|=
name|NULL
expr_stmt|;
name|cio
operator|->
name|num_matches
operator|=
literal|0
expr_stmt|;
comment|/* 		 * If the user specified an offset into the device list, 		 * but the list has changed since they last called this 		 * ioctl, tell them that the list has changed.  They will 		 * have to get the list from the beginning. 		 */
if|if
condition|(
operator|(
name|cio
operator|->
name|offset
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|cio
operator|->
name|generation
operator|!=
name|pci_generation
operator|)
condition|)
block|{
name|cio
operator|->
name|status
operator|=
name|PCI_GETCONF_LIST_CHANGED
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* 		 * Check to see whether the user has asked for an offset 		 * past the end of our list. 		 */
if|if
condition|(
name|cio
operator|->
name|offset
operator|>=
name|pci_numdevs
condition|)
block|{
name|cio
operator|->
name|status
operator|=
name|PCI_GETCONF_LAST_DEVICE
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* get the head of the device queue */
name|devlist_head
operator|=
operator|&
name|pci_devq
expr_stmt|;
comment|/* 		 * Determine how much room we have for pci_conf structures. 		 * Round the user's buffer size down to the nearest 		 * multiple of sizeof(struct pci_conf) in case the user 		 * didn't specify a multiple of that size. 		 */
ifdef|#
directive|ifdef
name|PRE7_COMPAT
if|if
condition|(
name|cmd
operator|==
name|PCIOCGETCONF_OLD
condition|)
name|confsz
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|pci_conf_old
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|confsz
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|pci_conf
argument_list|)
expr_stmt|;
name|iolen
operator|=
name|min
argument_list|(
name|cio
operator|->
name|match_buf_len
operator|-
operator|(
name|cio
operator|->
name|match_buf_len
operator|%
name|confsz
operator|)
argument_list|,
name|pci_numdevs
operator|*
name|confsz
argument_list|)
expr_stmt|;
comment|/* 		 * Since we know that iolen is a multiple of the size of 		 * the pciconf union, it's okay to do this. 		 */
name|ionum
operator|=
name|iolen
operator|/
name|confsz
expr_stmt|;
comment|/* 		 * If this test is true, the user wants the pci_conf 		 * structures returned to match the supplied entries. 		 */
if|if
condition|(
operator|(
name|cio
operator|->
name|num_patterns
operator|>
literal|0
operator|)
operator|&&
operator|(
name|cio
operator|->
name|num_patterns
operator|<
name|pci_numdevs
operator|)
operator|&&
operator|(
name|cio
operator|->
name|pat_buf_len
operator|>
literal|0
operator|)
condition|)
block|{
comment|/* 			 * pat_buf_len needs to be: 			 * num_patterns * sizeof(struct pci_match_conf) 			 * While it is certainly possible the user just 			 * allocated a large buffer, but set the number of 			 * matches correctly, it is far more likely that 			 * their kernel doesn't match the userland utility 			 * they're using.  It's also possible that the user 			 * forgot to initialize some variables.  Yes, this 			 * may be overly picky, but I hazard to guess that 			 * it's far more likely to just catch folks that 			 * updated their kernel but not their userland. 			 */
ifdef|#
directive|ifdef
name|PRE7_COMPAT
if|if
condition|(
name|cmd
operator|==
name|PCIOCGETCONF_OLD
condition|)
name|pbufsz
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|pci_match_conf_old
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|pbufsz
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|pci_match_conf
argument_list|)
expr_stmt|;
if|if
condition|(
name|cio
operator|->
name|num_patterns
operator|*
name|pbufsz
operator|!=
name|cio
operator|->
name|pat_buf_len
condition|)
block|{
comment|/* The user made a mistake, return an error. */
name|cio
operator|->
name|status
operator|=
name|PCI_GETCONF_ERROR
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* 			 * Allocate a buffer to hold the patterns. 			 */
ifdef|#
directive|ifdef
name|PRE7_COMPAT
if|if
condition|(
name|cmd
operator|==
name|PCIOCGETCONF_OLD
condition|)
block|{
name|pattern_buf_old
operator|=
name|malloc
argument_list|(
name|cio
operator|->
name|pat_buf_len
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|cio
operator|->
name|patterns
argument_list|,
name|pattern_buf_old
argument_list|,
name|cio
operator|->
name|pat_buf_len
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|pattern_buf
operator|=
name|malloc
argument_list|(
name|cio
operator|->
name|pat_buf_len
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|cio
operator|->
name|patterns
argument_list|,
name|pattern_buf
argument_list|,
name|cio
operator|->
name|pat_buf_len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|getconfexit
goto|;
block|}
name|num_patterns
operator|=
name|cio
operator|->
name|num_patterns
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|cio
operator|->
name|num_patterns
operator|>
literal|0
operator|)
operator|||
operator|(
name|cio
operator|->
name|pat_buf_len
operator|>
literal|0
operator|)
condition|)
block|{
comment|/* 			 * The user made a mistake, spit out an error. 			 */
name|cio
operator|->
name|status
operator|=
name|PCI_GETCONF_ERROR
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* 		 * Go through the list of devices and copy out the devices 		 * that match the user's criteria. 		 */
for|for
control|(
name|cio
operator|->
name|num_matches
operator|=
literal|0
operator|,
name|error
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
operator|,
name|dinfo
operator|=
name|STAILQ_FIRST
argument_list|(
name|devlist_head
argument_list|)
init|;
operator|(
name|dinfo
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|cio
operator|->
name|num_matches
operator|<
name|ionum
operator|)
operator|&&
operator|(
name|error
operator|==
literal|0
operator|)
operator|&&
operator|(
name|i
operator|<
name|pci_numdevs
operator|)
operator|&&
operator|(
name|dinfo
operator|!=
name|NULL
operator|)
condition|;
name|dinfo
operator|=
name|STAILQ_NEXT
argument_list|(
name|dinfo
argument_list|,
name|pci_links
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|<
name|cio
operator|->
name|offset
condition|)
continue|continue;
comment|/* Populate pd_name and pd_unit */
name|name
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dinfo
operator|->
name|cfg
operator|.
name|dev
condition|)
name|name
operator|=
name|device_get_name
argument_list|(
name|dinfo
operator|->
name|cfg
operator|.
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|strncpy
argument_list|(
name|dinfo
operator|->
name|conf
operator|.
name|pd_name
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|dinfo
operator|->
name|conf
operator|.
name|pd_name
argument_list|)
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|conf
operator|.
name|pd_name
index|[
name|PCI_MAXNAMELEN
index|]
operator|=
literal|0
expr_stmt|;
name|dinfo
operator|->
name|conf
operator|.
name|pd_unit
operator|=
name|device_get_unit
argument_list|(
name|dinfo
operator|->
name|cfg
operator|.
name|dev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dinfo
operator|->
name|conf
operator|.
name|pd_name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|dinfo
operator|->
name|conf
operator|.
name|pd_unit
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PRE7_COMPAT
if|if
condition|(
operator|(
name|cmd
operator|==
name|PCIOCGETCONF_OLD
operator|&&
operator|(
name|pattern_buf_old
operator|==
name|NULL
operator|||
name|pci_conf_match_old
argument_list|(
name|pattern_buf_old
argument_list|,
name|num_patterns
argument_list|,
operator|&
name|dinfo
operator|->
name|conf
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
name|cmd
operator|==
name|PCIOCGETCONF
operator|&&
operator|(
name|pattern_buf
operator|==
name|NULL
operator|||
name|pci_conf_match
argument_list|(
name|pattern_buf
argument_list|,
name|num_patterns
argument_list|,
operator|&
name|dinfo
operator|->
name|conf
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|pattern_buf
operator|==
name|NULL
operator|||
name|pci_conf_match
argument_list|(
name|pattern_buf
argument_list|,
name|num_patterns
argument_list|,
operator|&
name|dinfo
operator|->
name|conf
argument_list|)
operator|==
literal|0
condition|)
block|{
endif|#
directive|endif
comment|/* 				 * If we've filled up the user's buffer, 				 * break out at this point.  Since we've 				 * got a match here, we'll pick right back 				 * up at the matching entry.  We can also 				 * tell the user that there are more matches 				 * left. 				 */
if|if
condition|(
name|cio
operator|->
name|num_matches
operator|>=
name|ionum
condition|)
break|break;
ifdef|#
directive|ifdef
name|PRE7_COMPAT
if|if
condition|(
name|cmd
operator|==
name|PCIOCGETCONF_OLD
condition|)
block|{
name|conf_old
operator|.
name|pc_sel
operator|.
name|pc_bus
operator|=
name|dinfo
operator|->
name|conf
operator|.
name|pc_sel
operator|.
name|pc_bus
expr_stmt|;
name|conf_old
operator|.
name|pc_sel
operator|.
name|pc_dev
operator|=
name|dinfo
operator|->
name|conf
operator|.
name|pc_sel
operator|.
name|pc_dev
expr_stmt|;
name|conf_old
operator|.
name|pc_sel
operator|.
name|pc_func
operator|=
name|dinfo
operator|->
name|conf
operator|.
name|pc_sel
operator|.
name|pc_func
expr_stmt|;
name|conf_old
operator|.
name|pc_hdr
operator|=
name|dinfo
operator|->
name|conf
operator|.
name|pc_hdr
expr_stmt|;
name|conf_old
operator|.
name|pc_subvendor
operator|=
name|dinfo
operator|->
name|conf
operator|.
name|pc_subvendor
expr_stmt|;
name|conf_old
operator|.
name|pc_subdevice
operator|=
name|dinfo
operator|->
name|conf
operator|.
name|pc_subdevice
expr_stmt|;
name|conf_old
operator|.
name|pc_vendor
operator|=
name|dinfo
operator|->
name|conf
operator|.
name|pc_vendor
expr_stmt|;
name|conf_old
operator|.
name|pc_device
operator|=
name|dinfo
operator|->
name|conf
operator|.
name|pc_device
expr_stmt|;
name|conf_old
operator|.
name|pc_class
operator|=
name|dinfo
operator|->
name|conf
operator|.
name|pc_class
expr_stmt|;
name|conf_old
operator|.
name|pc_subclass
operator|=
name|dinfo
operator|->
name|conf
operator|.
name|pc_subclass
expr_stmt|;
name|conf_old
operator|.
name|pc_progif
operator|=
name|dinfo
operator|->
name|conf
operator|.
name|pc_progif
expr_stmt|;
name|conf_old
operator|.
name|pc_revid
operator|=
name|dinfo
operator|->
name|conf
operator|.
name|pc_revid
expr_stmt|;
name|strncpy
argument_list|(
name|conf_old
operator|.
name|pd_name
argument_list|,
name|dinfo
operator|->
name|conf
operator|.
name|pd_name
argument_list|,
sizeof|sizeof
argument_list|(
name|conf_old
operator|.
name|pd_name
argument_list|)
argument_list|)
expr_stmt|;
name|conf_old
operator|.
name|pd_name
index|[
name|PCI_MAXNAMELEN
index|]
operator|=
literal|0
expr_stmt|;
name|conf_old
operator|.
name|pd_unit
operator|=
name|dinfo
operator|->
name|conf
operator|.
name|pd_unit
expr_stmt|;
name|confdata
operator|=
operator|&
name|conf_old
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|confdata
operator|=
operator|&
name|dinfo
operator|->
name|conf
expr_stmt|;
comment|/* Only if we can copy it out do we count it. */
if|if
condition|(
operator|!
operator|(
name|error
operator|=
name|copyout
argument_list|(
name|confdata
argument_list|,
operator|(
name|caddr_t
operator|)
name|cio
operator|->
name|matches
operator|+
name|confsz
operator|*
name|cio
operator|->
name|num_matches
argument_list|,
name|confsz
argument_list|)
operator|)
condition|)
name|cio
operator|->
name|num_matches
operator|++
expr_stmt|;
block|}
block|}
comment|/* 		 * Set the pointer into the list, so if the user is getting 		 * n records at a time, where n< pci_numdevs, 		 */
name|cio
operator|->
name|offset
operator|=
name|i
expr_stmt|;
comment|/* 		 * Set the generation, the user will need this if they make 		 * another ioctl call with offset != 0. 		 */
name|cio
operator|->
name|generation
operator|=
name|pci_generation
expr_stmt|;
comment|/* 		 * If this is the last device, inform the user so he won't 		 * bother asking for more devices.  If dinfo isn't NULL, we 		 * know that there are more matches in the list because of 		 * the way the traversal is done. 		 */
if|if
condition|(
name|dinfo
operator|==
name|NULL
condition|)
name|cio
operator|->
name|status
operator|=
name|PCI_GETCONF_LAST_DEVICE
expr_stmt|;
else|else
name|cio
operator|->
name|status
operator|=
name|PCI_GETCONF_MORE_DEVS
expr_stmt|;
name|getconfexit
label|:
if|if
condition|(
name|pattern_buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|pattern_buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PRE7_COMPAT
if|if
condition|(
name|pattern_buf_old
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|pattern_buf_old
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
ifdef|#
directive|ifdef
name|PRE7_COMPAT
case|case
name|PCIOCREAD_OLD
case|:
case|case
name|PCIOCWRITE_OLD
case|:
name|io_old
operator|=
operator|(
expr|struct
name|pci_io_old
operator|*
operator|)
name|data
expr_stmt|;
name|iodata
operator|.
name|pi_sel
operator|.
name|pc_domain
operator|=
literal|0
expr_stmt|;
name|iodata
operator|.
name|pi_sel
operator|.
name|pc_bus
operator|=
name|io_old
operator|->
name|pi_sel
operator|.
name|pc_bus
expr_stmt|;
name|iodata
operator|.
name|pi_sel
operator|.
name|pc_dev
operator|=
name|io_old
operator|->
name|pi_sel
operator|.
name|pc_dev
expr_stmt|;
name|iodata
operator|.
name|pi_sel
operator|.
name|pc_func
operator|=
name|io_old
operator|->
name|pi_sel
operator|.
name|pc_func
expr_stmt|;
name|iodata
operator|.
name|pi_reg
operator|=
name|io_old
operator|->
name|pi_reg
expr_stmt|;
name|iodata
operator|.
name|pi_width
operator|=
name|io_old
operator|->
name|pi_width
expr_stmt|;
name|iodata
operator|.
name|pi_data
operator|=
name|io_old
operator|->
name|pi_data
expr_stmt|;
name|data
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|iodata
expr_stmt|;
comment|/* FALLTHROUGH */
endif|#
directive|endif
case|case
name|PCIOCREAD
case|:
case|case
name|PCIOCWRITE
case|:
name|io
operator|=
operator|(
expr|struct
name|pci_io
operator|*
operator|)
name|data
expr_stmt|;
switch|switch
condition|(
name|io
operator|->
name|pi_width
condition|)
block|{
case|case
literal|4
case|:
case|case
literal|2
case|:
case|case
literal|1
case|:
comment|/* Make sure register is not negative and aligned. */
if|if
condition|(
name|io
operator|->
name|pi_reg
operator|<
literal|0
operator|||
name|io
operator|->
name|pi_reg
operator|&
operator|(
name|io
operator|->
name|pi_width
operator|-
literal|1
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* 			 * Assume that the user-level bus number is 			 * in fact the physical PCI bus number. 			 * Look up the grandparent, i.e. the bridge device, 			 * so that we can issue configuration space cycles. 			 */
name|pcidev
operator|=
name|pci_find_dbsf
argument_list|(
name|io
operator|->
name|pi_sel
operator|.
name|pc_domain
argument_list|,
name|io
operator|->
name|pi_sel
operator|.
name|pc_bus
argument_list|,
name|io
operator|->
name|pi_sel
operator|.
name|pc_dev
argument_list|,
name|io
operator|->
name|pi_sel
operator|.
name|pc_func
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcidev
condition|)
block|{
name|brdev
operator|=
name|device_get_parent
argument_list|(
name|device_get_parent
argument_list|(
name|pcidev
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PRE7_COMPAT
if|if
condition|(
name|cmd
operator|==
name|PCIOCWRITE
operator|||
name|cmd
operator|==
name|PCIOCWRITE_OLD
condition|)
else|#
directive|else
if|if
condition|(
name|cmd
operator|==
name|PCIOCWRITE
condition|)
endif|#
directive|endif
name|PCIB_WRITE_CONFIG
argument_list|(
name|brdev
argument_list|,
name|io
operator|->
name|pi_sel
operator|.
name|pc_bus
argument_list|,
name|io
operator|->
name|pi_sel
operator|.
name|pc_dev
argument_list|,
name|io
operator|->
name|pi_sel
operator|.
name|pc_func
argument_list|,
name|io
operator|->
name|pi_reg
argument_list|,
name|io
operator|->
name|pi_data
argument_list|,
name|io
operator|->
name|pi_width
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PRE7_COMPAT
elseif|else
if|if
condition|(
name|cmd
operator|==
name|PCIOCREAD_OLD
condition|)
name|io_old
operator|->
name|pi_data
operator|=
name|PCIB_READ_CONFIG
argument_list|(
name|brdev
argument_list|,
name|io
operator|->
name|pi_sel
operator|.
name|pc_bus
argument_list|,
name|io
operator|->
name|pi_sel
operator|.
name|pc_dev
argument_list|,
name|io
operator|->
name|pi_sel
operator|.
name|pc_func
argument_list|,
name|io
operator|->
name|pi_reg
argument_list|,
name|io
operator|->
name|pi_width
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|else
name|io
operator|->
name|pi_data
operator|=
name|PCIB_READ_CONFIG
argument_list|(
name|brdev
argument_list|,
name|io
operator|->
name|pi_sel
operator|.
name|pc_bus
argument_list|,
name|io
operator|->
name|pi_sel
operator|.
name|pc_dev
argument_list|,
name|io
operator|->
name|pi_sel
operator|.
name|pc_func
argument_list|,
name|io
operator|->
name|pi_reg
argument_list|,
name|io
operator|->
name|pi_width
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD4
if|if
condition|(
name|cmd
operator|==
name|PCIOCREAD_OLD
condition|)
block|{
name|io_old
operator|->
name|pi_data
operator|=
operator|-
literal|1
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|error
operator|=
name|ENODEV
expr_stmt|;
block|}
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|PCIOCGETBAR
case|:
name|bio
operator|=
operator|(
expr|struct
name|pci_bar_io
operator|*
operator|)
name|data
expr_stmt|;
comment|/* 		 * Assume that the user-level bus number is 		 * in fact the physical PCI bus number. 		 */
name|pcidev
operator|=
name|pci_find_dbsf
argument_list|(
name|bio
operator|->
name|pbi_sel
operator|.
name|pc_domain
argument_list|,
name|bio
operator|->
name|pbi_sel
operator|.
name|pc_bus
argument_list|,
name|bio
operator|->
name|pbi_sel
operator|.
name|pc_dev
argument_list|,
name|bio
operator|->
name|pbi_sel
operator|.
name|pc_func
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcidev
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|pcidev
argument_list|)
expr_stmt|;
comment|/* 		 * Look for a resource list entry matching the requested BAR. 		 * 		 * XXX: This will not find BARs that are not initialized, but 		 * maybe that is ok? 		 */
name|rle
operator|=
name|resource_list_find
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|bio
operator|->
name|pbi_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|rle
operator|==
name|NULL
condition|)
name|rle
operator|=
name|resource_list_find
argument_list|(
operator|&
name|dinfo
operator|->
name|resources
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|bio
operator|->
name|pbi_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|rle
operator|==
name|NULL
operator|||
name|rle
operator|->
name|res
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* 		 * Ok, we have a resource for this BAR.  Read the lower 		 * 32 bits to get any flags. 		 */
name|value
operator|=
name|pci_read_config
argument_list|(
name|pcidev
argument_list|,
name|bio
operator|->
name|pbi_reg
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|PCI_BAR_MEM
argument_list|(
name|value
argument_list|)
condition|)
block|{
if|if
condition|(
name|rle
operator|->
name|type
operator|!=
name|SYS_RES_MEMORY
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|value
operator|&=
operator|~
name|PCIM_BAR_MEM_BASE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|rle
operator|->
name|type
operator|!=
name|SYS_RES_IOPORT
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|value
operator|&=
operator|~
name|PCIM_BAR_IO_BASE
expr_stmt|;
block|}
name|bio
operator|->
name|pbi_base
operator|=
name|rman_get_start
argument_list|(
name|rle
operator|->
name|res
argument_list|)
operator||
name|value
expr_stmt|;
name|bio
operator|->
name|pbi_length
operator|=
name|rman_get_size
argument_list|(
name|rle
operator|->
name|res
argument_list|)
expr_stmt|;
comment|/* 		 * Check the command register to determine if this BAR 		 * is enabled. 		 */
name|value
operator|=
name|pci_read_config
argument_list|(
name|pcidev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|rle
operator|->
name|type
operator|==
name|SYS_RES_MEMORY
condition|)
name|bio
operator|->
name|pbi_enabled
operator|=
operator|(
name|value
operator|&
name|PCIM_CMD_MEMEN
operator|)
operator|!=
literal|0
expr_stmt|;
else|else
name|bio
operator|->
name|pbi_enabled
operator|=
operator|(
name|value
operator|&
name|PCIM_CMD_PORTEN
operator|)
operator|!=
literal|0
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ENOTTY
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

