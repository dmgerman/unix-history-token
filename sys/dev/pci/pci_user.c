begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997, Stefan Esser<se@freebsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  *  */
end_comment

begin_include
include|#
directive|include
file|"opt_bus.h"
end_include

begin_comment
comment|/* XXX trim includes */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/pciio.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|"pcib_if.h"
end_include

begin_include
include|#
directive|include
file|"pci_if.h"
end_include

begin_comment
comment|/*  * This is the user interface to PCI configuration space.  */
end_comment

begin_decl_stmt
specifier|static
name|d_open_t
name|pci_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|pci_close
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|pci_conf_match
parameter_list|(
name|struct
name|pci_match_conf
modifier|*
name|matches
parameter_list|,
name|int
name|num_matches
parameter_list|,
name|struct
name|pci_conf
modifier|*
name|match_buf
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|pci_ioctl
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PCI_CDEV
value|78
end_define

begin_decl_stmt
name|struct
name|cdevsw
name|pcicdev
init|=
block|{
comment|/* open */
name|pci_open
block|,
comment|/* close */
name|pci_close
block|,
comment|/* read */
name|noread
block|,
comment|/* write */
name|nowrite
block|,
comment|/* ioctl */
name|pci_ioctl
block|,
comment|/* poll */
name|nopoll
block|,
comment|/* mmap */
name|nommap
block|,
comment|/* strategy */
name|nostrategy
block|,
comment|/* name */
literal|"pci"
block|,
comment|/* maj */
name|PCI_CDEV
block|,
comment|/* dump */
name|nodump
block|,
comment|/* psize */
name|nopsize
block|,
comment|/* flags */
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|pci_open
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|oflags
parameter_list|,
name|int
name|devtype
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|oflags
operator|&
name|FWRITE
condition|)
block|{
name|error
operator|=
name|securelevel_gt
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pci_close
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|devtype
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Match a single pci_conf structure against an array of pci_match_conf  * structures.  The first argument, 'matches', is an array of num_matches  * pci_match_conf structures.  match_buf is a pointer to the pci_conf  * structure that will be compared to every entry in the matches array.  * This function returns 1 on failure, 0 on success.  */
end_comment

begin_function
specifier|static
name|int
name|pci_conf_match
parameter_list|(
name|struct
name|pci_match_conf
modifier|*
name|matches
parameter_list|,
name|int
name|num_matches
parameter_list|,
name|struct
name|pci_conf
modifier|*
name|match_buf
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|matches
operator|==
name|NULL
operator|)
operator|||
operator|(
name|match_buf
operator|==
name|NULL
operator|)
operator|||
operator|(
name|num_matches
operator|<=
literal|0
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_matches
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * I'm not sure why someone would do this...but... 		 */
if|if
condition|(
name|matches
index|[
name|i
index|]
operator|.
name|flags
operator|==
name|PCI_GETCONF_NO_MATCH
condition|)
continue|continue;
comment|/* 		 * Look at each of the match flags.  If it's set, do the 		 * comparison.  If the comparison fails, we don't have a 		 * match, go on to the next item if there is one. 		 */
if|if
condition|(
operator|(
operator|(
name|matches
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|PCI_GETCONF_MATCH_BUS
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|match_buf
operator|->
name|pc_sel
operator|.
name|pc_bus
operator|!=
name|matches
index|[
name|i
index|]
operator|.
name|pc_sel
operator|.
name|pc_bus
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|matches
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|PCI_GETCONF_MATCH_DEV
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|match_buf
operator|->
name|pc_sel
operator|.
name|pc_dev
operator|!=
name|matches
index|[
name|i
index|]
operator|.
name|pc_sel
operator|.
name|pc_dev
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|matches
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|PCI_GETCONF_MATCH_FUNC
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|match_buf
operator|->
name|pc_sel
operator|.
name|pc_func
operator|!=
name|matches
index|[
name|i
index|]
operator|.
name|pc_sel
operator|.
name|pc_func
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|matches
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|PCI_GETCONF_MATCH_VENDOR
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|match_buf
operator|->
name|pc_vendor
operator|!=
name|matches
index|[
name|i
index|]
operator|.
name|pc_vendor
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|matches
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|PCI_GETCONF_MATCH_DEVICE
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|match_buf
operator|->
name|pc_device
operator|!=
name|matches
index|[
name|i
index|]
operator|.
name|pc_device
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|matches
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|PCI_GETCONF_MATCH_CLASS
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|match_buf
operator|->
name|pc_class
operator|!=
name|matches
index|[
name|i
index|]
operator|.
name|pc_class
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|matches
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|PCI_GETCONF_MATCH_UNIT
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|match_buf
operator|->
name|pd_unit
operator|!=
name|matches
index|[
name|i
index|]
operator|.
name|pd_unit
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|matches
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|PCI_GETCONF_MATCH_NAME
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|matches
index|[
name|i
index|]
operator|.
name|pd_name
argument_list|,
name|match_buf
operator|->
name|pd_name
argument_list|,
sizeof|sizeof
argument_list|(
name|match_buf
operator|->
name|pd_name
argument_list|)
argument_list|)
operator|!=
literal|0
operator|)
condition|)
continue|continue;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pci_ioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|device_t
name|pci
decl_stmt|,
name|pcib
decl_stmt|;
name|struct
name|pci_io
modifier|*
name|io
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flag
operator|&
name|FWRITE
operator|)
condition|)
return|return
name|EPERM
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|PCIOCGETCONF
case|:
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|struct
name|pci_conf_io
modifier|*
name|cio
decl_stmt|;
name|struct
name|devlist
modifier|*
name|devlist_head
decl_stmt|;
name|struct
name|pci_match_conf
modifier|*
name|pattern_buf
decl_stmt|;
name|int
name|num_patterns
decl_stmt|;
name|size_t
name|iolen
decl_stmt|;
name|int
name|ionum
decl_stmt|,
name|i
decl_stmt|;
name|cio
operator|=
operator|(
expr|struct
name|pci_conf_io
operator|*
operator|)
name|data
expr_stmt|;
name|num_patterns
operator|=
literal|0
expr_stmt|;
name|dinfo
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * Hopefully the user won't pass in a null pointer, but it 		 * can't hurt to check. 		 */
if|if
condition|(
name|cio
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* 		 * If the user specified an offset into the device list, 		 * but the list has changed since they last called this 		 * ioctl, tell them that the list has changed.  They will 		 * have to get the list from the beginning. 		 */
if|if
condition|(
operator|(
name|cio
operator|->
name|offset
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|cio
operator|->
name|generation
operator|!=
name|pci_generation
operator|)
condition|)
block|{
name|cio
operator|->
name|num_matches
operator|=
literal|0
expr_stmt|;
name|cio
operator|->
name|status
operator|=
name|PCI_GETCONF_LIST_CHANGED
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* 		 * Check to see whether the user has asked for an offset 		 * past the end of our list. 		 */
if|if
condition|(
name|cio
operator|->
name|offset
operator|>=
name|pci_numdevs
condition|)
block|{
name|cio
operator|->
name|num_matches
operator|=
literal|0
expr_stmt|;
name|cio
operator|->
name|status
operator|=
name|PCI_GETCONF_LAST_DEVICE
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* get the head of the device queue */
name|devlist_head
operator|=
operator|&
name|pci_devq
expr_stmt|;
comment|/* 		 * Determine how much room we have for pci_conf structures. 		 * Round the user's buffer size down to the nearest 		 * multiple of sizeof(struct pci_conf) in case the user 		 * didn't specify a multiple of that size. 		 */
name|iolen
operator|=
name|min
argument_list|(
name|cio
operator|->
name|match_buf_len
operator|-
operator|(
name|cio
operator|->
name|match_buf_len
operator|%
sizeof|sizeof
argument_list|(
expr|struct
name|pci_conf
argument_list|)
operator|)
argument_list|,
name|pci_numdevs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pci_conf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Since we know that iolen is a multiple of the size of 		 * the pciconf union, it's okay to do this. 		 */
name|ionum
operator|=
name|iolen
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|pci_conf
argument_list|)
expr_stmt|;
comment|/* 		 * If this test is true, the user wants the pci_conf 		 * structures returned to match the supplied entries. 		 */
if|if
condition|(
operator|(
name|cio
operator|->
name|num_patterns
operator|>
literal|0
operator|)
operator|&&
operator|(
name|cio
operator|->
name|pat_buf_len
operator|>
literal|0
operator|)
condition|)
block|{
comment|/* 			 * pat_buf_len needs to be: 			 * num_patterns * sizeof(struct pci_match_conf) 			 * While it is certainly possible the user just 			 * allocated a large buffer, but set the number of 			 * matches correctly, it is far more likely that 			 * their kernel doesn't match the userland utility 			 * they're using.  It's also possible that the user 			 * forgot to initialize some variables.  Yes, this 			 * may be overly picky, but I hazard to guess that 			 * it's far more likely to just catch folks that 			 * updated their kernel but not their userland. 			 */
if|if
condition|(
operator|(
name|cio
operator|->
name|num_patterns
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pci_match_conf
argument_list|)
operator|)
operator|!=
name|cio
operator|->
name|pat_buf_len
condition|)
block|{
comment|/* The user made a mistake, return an error*/
name|cio
operator|->
name|status
operator|=
name|PCI_GETCONF_ERROR
expr_stmt|;
name|printf
argument_list|(
literal|"pci_ioctl: pat_buf_len %d != "
literal|"num_patterns (%d) * sizeof(struct "
literal|"pci_match_conf) (%d)\npci_ioctl: "
literal|"pat_buf_len should be = %d\n"
argument_list|,
name|cio
operator|->
name|pat_buf_len
argument_list|,
name|cio
operator|->
name|num_patterns
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|pci_match_conf
argument_list|)
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|pci_match_conf
argument_list|)
operator|*
name|cio
operator|->
name|num_patterns
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"pci_ioctl: do your headers match your "
literal|"kernel?\n"
argument_list|)
expr_stmt|;
name|cio
operator|->
name|num_matches
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* 			 * Check the user's buffer to make sure it's readable. 			 */
if|if
condition|(
operator|!
name|useracc
argument_list|(
operator|(
name|caddr_t
operator|)
name|cio
operator|->
name|patterns
argument_list|,
name|cio
operator|->
name|pat_buf_len
argument_list|,
name|VM_PROT_READ
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"pci_ioctl: pattern buffer %p, "
literal|"length %u isn't user accessible for"
literal|" READ\n"
argument_list|,
name|cio
operator|->
name|patterns
argument_list|,
name|cio
operator|->
name|pat_buf_len
argument_list|)
expr_stmt|;
name|error
operator|=
name|EACCES
expr_stmt|;
break|break;
block|}
comment|/* 			 * Allocate a buffer to hold the patterns. 			 */
name|pattern_buf
operator|=
name|malloc
argument_list|(
name|cio
operator|->
name|pat_buf_len
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|cio
operator|->
name|patterns
argument_list|,
name|pattern_buf
argument_list|,
name|cio
operator|->
name|pat_buf_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|num_patterns
operator|=
name|cio
operator|->
name|num_patterns
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|cio
operator|->
name|num_patterns
operator|>
literal|0
operator|)
operator|||
operator|(
name|cio
operator|->
name|pat_buf_len
operator|>
literal|0
operator|)
condition|)
block|{
comment|/* 			 * The user made a mistake, spit out an error. 			 */
name|cio
operator|->
name|status
operator|=
name|PCI_GETCONF_ERROR
expr_stmt|;
name|cio
operator|->
name|num_matches
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"pci_ioctl: invalid GETCONF arguments\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
else|else
name|pattern_buf
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * Make sure we can write to the match buffer. 		 */
if|if
condition|(
operator|!
name|useracc
argument_list|(
operator|(
name|caddr_t
operator|)
name|cio
operator|->
name|matches
argument_list|,
name|cio
operator|->
name|match_buf_len
argument_list|,
name|VM_PROT_WRITE
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"pci_ioctl: match buffer %p, length %u "
literal|"isn't user accessible for WRITE\n"
argument_list|,
name|cio
operator|->
name|matches
argument_list|,
name|cio
operator|->
name|match_buf_len
argument_list|)
expr_stmt|;
name|error
operator|=
name|EACCES
expr_stmt|;
break|break;
block|}
comment|/* 		 * Go through the list of devices and copy out the devices 		 * that match the user's criteria. 		 */
for|for
control|(
name|cio
operator|->
name|num_matches
operator|=
literal|0
operator|,
name|error
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
operator|,
name|dinfo
operator|=
name|STAILQ_FIRST
argument_list|(
name|devlist_head
argument_list|)
init|;
operator|(
name|dinfo
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|cio
operator|->
name|num_matches
operator|<
name|ionum
operator|)
operator|&&
operator|(
name|error
operator|==
literal|0
operator|)
operator|&&
operator|(
name|i
operator|<
name|pci_numdevs
operator|)
condition|;
name|dinfo
operator|=
name|STAILQ_NEXT
argument_list|(
name|dinfo
argument_list|,
name|pci_links
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|<
name|cio
operator|->
name|offset
condition|)
continue|continue;
comment|/* Populate pd_name and pd_unit */
name|name
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dinfo
operator|->
name|cfg
operator|.
name|dev
operator|&&
name|dinfo
operator|->
name|conf
operator|.
name|pd_name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|name
operator|=
name|device_get_name
argument_list|(
name|dinfo
operator|->
name|cfg
operator|.
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|strncpy
argument_list|(
name|dinfo
operator|->
name|conf
operator|.
name|pd_name
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|dinfo
operator|->
name|conf
operator|.
name|pd_name
argument_list|)
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|conf
operator|.
name|pd_name
index|[
name|PCI_MAXNAMELEN
index|]
operator|=
literal|0
expr_stmt|;
name|dinfo
operator|->
name|conf
operator|.
name|pd_unit
operator|=
name|device_get_unit
argument_list|(
name|dinfo
operator|->
name|cfg
operator|.
name|dev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pattern_buf
operator|==
name|NULL
operator|)
operator|||
operator|(
name|pci_conf_match
argument_list|(
name|pattern_buf
argument_list|,
name|num_patterns
argument_list|,
operator|&
name|dinfo
operator|->
name|conf
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 				 * If we've filled up the user's buffer, 				 * break out at this point.  Since we've 				 * got a match here, we'll pick right back 				 * up at the matching entry.  We can also 				 * tell the user that there are more matches 				 * left. 				 */
if|if
condition|(
name|cio
operator|->
name|num_matches
operator|>=
name|ionum
condition|)
break|break;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|dinfo
operator|->
name|conf
argument_list|,
operator|&
name|cio
operator|->
name|matches
index|[
name|cio
operator|->
name|num_matches
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pci_conf
argument_list|)
argument_list|)
expr_stmt|;
name|cio
operator|->
name|num_matches
operator|++
expr_stmt|;
block|}
block|}
comment|/* 		 * Set the pointer into the list, so if the user is getting 		 * n records at a time, where n< pci_numdevs, 		 */
name|cio
operator|->
name|offset
operator|=
name|i
expr_stmt|;
comment|/* 		 * Set the generation, the user will need this if they make 		 * another ioctl call with offset != 0. 		 */
name|cio
operator|->
name|generation
operator|=
name|pci_generation
expr_stmt|;
comment|/* 		 * If this is the last device, inform the user so he won't 		 * bother asking for more devices.  If dinfo isn't NULL, we 		 * know that there are more matches in the list because of 		 * the way the traversal is done. 		 */
if|if
condition|(
name|dinfo
operator|==
name|NULL
condition|)
name|cio
operator|->
name|status
operator|=
name|PCI_GETCONF_LAST_DEVICE
expr_stmt|;
else|else
name|cio
operator|->
name|status
operator|=
name|PCI_GETCONF_MORE_DEVS
expr_stmt|;
if|if
condition|(
name|pattern_buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|pattern_buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|PCIOCREAD
case|:
name|io
operator|=
operator|(
expr|struct
name|pci_io
operator|*
operator|)
name|data
expr_stmt|;
switch|switch
condition|(
name|io
operator|->
name|pi_width
condition|)
block|{
case|case
literal|4
case|:
case|case
literal|2
case|:
case|case
literal|1
case|:
comment|/* 			 * Assume that the user-level bus number is 			 * actually the pciN instance number. We map 			 * from that to the real pcib+bus combination. 			 */
name|pci
operator|=
name|devclass_get_device
argument_list|(
name|devclass_find
argument_list|(
literal|"pci"
argument_list|)
argument_list|,
name|io
operator|->
name|pi_sel
operator|.
name|pc_bus
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci
condition|)
block|{
name|int
name|b
init|=
name|pcib_get_bus
argument_list|(
name|pci
argument_list|)
decl_stmt|;
name|pcib
operator|=
name|device_get_parent
argument_list|(
name|pci
argument_list|)
expr_stmt|;
name|io
operator|->
name|pi_data
operator|=
name|PCIB_READ_CONFIG
argument_list|(
name|pcib
argument_list|,
name|b
argument_list|,
name|io
operator|->
name|pi_sel
operator|.
name|pc_dev
argument_list|,
name|io
operator|->
name|pi_sel
operator|.
name|pc_func
argument_list|,
name|io
operator|->
name|pi_reg
argument_list|,
name|io
operator|->
name|pi_width
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
block|}
break|break;
default|default:
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|PCIOCWRITE
case|:
name|io
operator|=
operator|(
expr|struct
name|pci_io
operator|*
operator|)
name|data
expr_stmt|;
switch|switch
condition|(
name|io
operator|->
name|pi_width
condition|)
block|{
case|case
literal|4
case|:
case|case
literal|2
case|:
case|case
literal|1
case|:
comment|/* 			 * Assume that the user-level bus number is 			 * actually the pciN instance number. We map 			 * from that to the real pcib+bus combination. 			 */
name|pci
operator|=
name|devclass_get_device
argument_list|(
name|devclass_find
argument_list|(
literal|"pci"
argument_list|)
argument_list|,
name|io
operator|->
name|pi_sel
operator|.
name|pc_bus
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci
condition|)
block|{
name|int
name|b
init|=
name|pcib_get_bus
argument_list|(
name|pci
argument_list|)
decl_stmt|;
name|pcib
operator|=
name|device_get_parent
argument_list|(
name|pci
argument_list|)
expr_stmt|;
name|PCIB_WRITE_CONFIG
argument_list|(
name|pcib
argument_list|,
name|b
argument_list|,
name|io
operator|->
name|pi_sel
operator|.
name|pc_dev
argument_list|,
name|io
operator|->
name|pi_sel
operator|.
name|pc_func
argument_list|,
name|io
operator|->
name|pi_reg
argument_list|,
name|io
operator|->
name|pi_data
argument_list|,
name|io
operator|->
name|pi_width
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
block|}
break|break;
default|default:
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|error
operator|=
name|ENOTTY
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

