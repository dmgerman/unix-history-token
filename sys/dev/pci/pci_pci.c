begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1994,1995 Stefan Esser, Wolfgang StanglMeier  * Copyright (c) 2000 Michael Smith<msmith@freebsd.org>  * Copyright (c) 2000 BSDi  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * PCI:PCI bridge support.  */
end_comment

begin_include
include|#
directive|include
file|"opt_pci.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pci_private.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcib_private.h>
end_include

begin_include
include|#
directive|include
file|"pcib_if.h"
end_include

begin_function_decl
specifier|static
name|int
name|pcib_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcib_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcib_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcib_power_for_sleep
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|int
modifier|*
name|pstate
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcib_ari_get_id
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|enum
name|pci_id_type
name|type
parameter_list|,
name|uintptr_t
modifier|*
name|id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|pcib_read_config
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|b
parameter_list|,
name|u_int
name|s
parameter_list|,
name|u_int
name|f
parameter_list|,
name|u_int
name|reg
parameter_list|,
name|int
name|width
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pcib_write_config
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|b
parameter_list|,
name|u_int
name|s
parameter_list|,
name|u_int
name|f
parameter_list|,
name|u_int
name|reg
parameter_list|,
name|uint32_t
name|val
parameter_list|,
name|int
name|width
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcib_ari_maxslots
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcib_ari_maxfuncs
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcib_try_enable_ari
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcib_ari_enabled
parameter_list|(
name|device_t
name|pcib
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pcib_ari_decode_rid
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|uint16_t
name|rid
parameter_list|,
name|int
modifier|*
name|bus
parameter_list|,
name|int
modifier|*
name|slot
parameter_list|,
name|int
modifier|*
name|func
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|PCI_HP
end_ifdef

begin_function_decl
specifier|static
name|void
name|pcib_pcie_ab_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pcib_pcie_cc_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pcib_pcie_dll_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|pcib_request_feature_default
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|enum
name|pci_feature
name|feature
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|pcib_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|pcib_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|pcib_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|pcib_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bus_generic_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|pcib_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|pcib_resume
argument_list|)
block|,
comment|/* Bus interface */
name|DEVMETHOD
argument_list|(
name|bus_child_present
argument_list|,
name|pcib_child_present
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_read_ivar
argument_list|,
name|pcib_read_ivar
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_write_ivar
argument_list|,
name|pcib_write_ivar
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_alloc_resource
argument_list|,
name|pcib_alloc_resource
argument_list|)
block|,
ifdef|#
directive|ifdef
name|NEW_PCIB
name|DEVMETHOD
argument_list|(
name|bus_adjust_resource
argument_list|,
name|pcib_adjust_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_release_resource
argument_list|,
name|pcib_release_resource
argument_list|)
block|,
else|#
directive|else
name|DEVMETHOD
argument_list|(
name|bus_adjust_resource
argument_list|,
name|bus_generic_adjust_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_release_resource
argument_list|,
name|bus_generic_release_resource
argument_list|)
block|,
endif|#
directive|endif
name|DEVMETHOD
argument_list|(
name|bus_activate_resource
argument_list|,
name|bus_generic_activate_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_deactivate_resource
argument_list|,
name|bus_generic_deactivate_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_setup_intr
argument_list|,
name|bus_generic_setup_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_teardown_intr
argument_list|,
name|bus_generic_teardown_intr
argument_list|)
block|,
comment|/* pcib interface */
name|DEVMETHOD
argument_list|(
name|pcib_maxslots
argument_list|,
name|pcib_ari_maxslots
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pcib_maxfuncs
argument_list|,
name|pcib_ari_maxfuncs
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pcib_read_config
argument_list|,
name|pcib_read_config
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pcib_write_config
argument_list|,
name|pcib_write_config
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pcib_route_interrupt
argument_list|,
name|pcib_route_interrupt
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pcib_alloc_msi
argument_list|,
name|pcib_alloc_msi
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pcib_release_msi
argument_list|,
name|pcib_release_msi
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pcib_alloc_msix
argument_list|,
name|pcib_alloc_msix
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pcib_release_msix
argument_list|,
name|pcib_release_msix
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pcib_map_msi
argument_list|,
name|pcib_map_msi
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pcib_power_for_sleep
argument_list|,
name|pcib_power_for_sleep
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pcib_get_id
argument_list|,
name|pcib_ari_get_id
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pcib_try_enable_ari
argument_list|,
name|pcib_try_enable_ari
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pcib_ari_enabled
argument_list|,
name|pcib_ari_enabled
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pcib_decode_rid
argument_list|,
name|pcib_ari_decode_rid
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pcib_request_feature
argument_list|,
name|pcib_request_feature_default
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|pcib_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DEFINE_CLASS_0
argument_list|(
name|pcib
argument_list|,
name|pcib_driver
argument_list|,
name|pcib_methods
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pcib_softc
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|pcib
argument_list|,
name|pci
argument_list|,
name|pcib_driver
argument_list|,
name|pcib_devclass
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEW_PCIB
argument_list|)
operator|||
name|defined
argument_list|(
name|PCI_HP
argument_list|)
end_if

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_hw_pci
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NEW_PCIB
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|pci_clear_pcib
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_pci
argument_list|,
name|OID_AUTO
argument_list|,
name|clear_pcib
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|pci_clear_pcib
argument_list|,
literal|0
argument_list|,
literal|"Clear firmware-assigned resources for PCI-PCI bridge I/O windows."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Is a resource from a child device sub-allocated from one of our  * resource managers?  */
end_comment

begin_function
specifier|static
name|int
name|pcib_is_resource_managed
parameter_list|(
name|struct
name|pcib_softc
modifier|*
name|sc
parameter_list|,
name|int
name|type
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
ifdef|#
directive|ifdef
name|PCI_RES_BUS
case|case
name|PCI_RES_BUS
case|:
return|return
operator|(
name|rman_is_region_manager
argument_list|(
name|r
argument_list|,
operator|&
name|sc
operator|->
name|bus
operator|.
name|rman
argument_list|)
operator|)
return|;
endif|#
directive|endif
case|case
name|SYS_RES_IOPORT
case|:
return|return
operator|(
name|rman_is_region_manager
argument_list|(
name|r
argument_list|,
operator|&
name|sc
operator|->
name|io
operator|.
name|rman
argument_list|)
operator|)
return|;
case|case
name|SYS_RES_MEMORY
case|:
comment|/* Prefetchable resources may live in either memory rman. */
if|if
condition|(
name|rman_get_flags
argument_list|(
name|r
argument_list|)
operator|&
name|RF_PREFETCHABLE
operator|&&
name|rman_is_region_manager
argument_list|(
name|r
argument_list|,
operator|&
name|sc
operator|->
name|pmem
operator|.
name|rman
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
name|rman_is_region_manager
argument_list|(
name|r
argument_list|,
operator|&
name|sc
operator|->
name|mem
operator|.
name|rman
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcib_is_window_open
parameter_list|(
name|struct
name|pcib_window
modifier|*
name|pw
parameter_list|)
block|{
return|return
operator|(
name|pw
operator|->
name|valid
operator|&&
name|pw
operator|->
name|base
operator|<
name|pw
operator|->
name|limit
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * XXX: If RF_ACTIVE did not also imply allocating a bus space tag and  * handle for the resource, we could pass RF_ACTIVE up to the PCI bus  * when allocating the resource windows and rely on the PCI bus driver  * to do this for us.  */
end_comment

begin_function
specifier|static
name|void
name|pcib_activate_window
parameter_list|(
name|struct
name|pcib_softc
modifier|*
name|sc
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|PCI_ENABLE_IO
argument_list|(
name|device_get_parent
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|sc
operator|->
name|dev
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pcib_write_windows
parameter_list|(
name|struct
name|pcib_softc
modifier|*
name|sc
parameter_list|,
name|int
name|mask
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|io
operator|.
name|valid
operator|&&
name|mask
operator|&
name|WIN_IO
condition|)
block|{
name|val
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_IOBASEL_1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|PCIM_BRIO_MASK
operator|)
operator|==
name|PCIM_BRIO_32
condition|)
block|{
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_IOBASEH_1
argument_list|,
name|sc
operator|->
name|io
operator|.
name|base
operator|>>
literal|16
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_IOLIMITH_1
argument_list|,
name|sc
operator|->
name|io
operator|.
name|limit
operator|>>
literal|16
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_IOBASEL_1
argument_list|,
name|sc
operator|->
name|io
operator|.
name|base
operator|>>
literal|8
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_IOLIMITL_1
argument_list|,
name|sc
operator|->
name|io
operator|.
name|limit
operator|>>
literal|8
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|WIN_MEM
condition|)
block|{
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_MEMBASE_1
argument_list|,
name|sc
operator|->
name|mem
operator|.
name|base
operator|>>
literal|16
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_MEMLIMIT_1
argument_list|,
name|sc
operator|->
name|mem
operator|.
name|limit
operator|>>
literal|16
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|pmem
operator|.
name|valid
operator|&&
name|mask
operator|&
name|WIN_PMEM
condition|)
block|{
name|val
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PMBASEL_1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|PCIM_BRPM_MASK
operator|)
operator|==
name|PCIM_BRPM_64
condition|)
block|{
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PMBASEH_1
argument_list|,
name|sc
operator|->
name|pmem
operator|.
name|base
operator|>>
literal|32
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PMLIMITH_1
argument_list|,
name|sc
operator|->
name|pmem
operator|.
name|limit
operator|>>
literal|32
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PMBASEL_1
argument_list|,
name|sc
operator|->
name|pmem
operator|.
name|base
operator|>>
literal|16
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PMLIMITL_1
argument_list|,
name|sc
operator|->
name|pmem
operator|.
name|limit
operator|>>
literal|16
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This is used to reject I/O port allocations that conflict with an  * ISA alias range.  */
end_comment

begin_function
specifier|static
name|int
name|pcib_is_isa_range
parameter_list|(
name|struct
name|pcib_softc
modifier|*
name|sc
parameter_list|,
name|rman_res_t
name|start
parameter_list|,
name|rman_res_t
name|end
parameter_list|,
name|rman_res_t
name|count
parameter_list|)
block|{
name|rman_res_t
name|next_alias
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|bridgectl
operator|&
name|PCIB_BCR_ISA_ENABLE
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Only check fixed ranges for overlap. */
if|if
condition|(
name|start
operator|+
name|count
operator|-
literal|1
operator|!=
name|end
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* ISA aliases are only in the lower 64KB of I/O space. */
if|if
condition|(
name|start
operator|>=
literal|65536
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Check for overlap with 0x000 - 0x0ff as a special case. */
if|if
condition|(
name|start
operator|<
literal|0x100
condition|)
goto|goto
name|alias
goto|;
comment|/* 	 * If the start address is an alias, the range is an alias. 	 * Otherwise, compute the start of the next alias range and 	 * check if it is before the end of the candidate range. 	 */
if|if
condition|(
operator|(
name|start
operator|&
literal|0x300
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|alias
goto|;
name|next_alias
operator|=
operator|(
name|start
operator|&
operator|~
literal|0x3fful
operator|)
operator||
literal|0x100
expr_stmt|;
if|if
condition|(
name|next_alias
operator|<=
name|end
condition|)
goto|goto
name|alias
goto|;
return|return
operator|(
literal|0
operator|)
return|;
name|alias
label|:
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"I/O range %#jx-%#jx overlaps with an ISA alias\n"
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pcib_add_window_resources
parameter_list|(
name|struct
name|pcib_window
modifier|*
name|w
parameter_list|,
name|struct
name|resource
modifier|*
modifier|*
name|res
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|resource
modifier|*
modifier|*
name|newarray
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|newarray
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|resource
operator|*
argument_list|)
operator|*
operator|(
name|w
operator|->
name|count
operator|+
name|count
operator|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|res
operator|!=
name|NULL
condition|)
name|bcopy
argument_list|(
name|w
operator|->
name|res
argument_list|,
name|newarray
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|resource
operator|*
argument_list|)
operator|*
name|w
operator|->
name|count
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|res
argument_list|,
name|newarray
operator|+
name|w
operator|->
name|count
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|resource
operator|*
argument_list|)
operator|*
name|count
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|w
operator|->
name|res
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|w
operator|->
name|res
operator|=
name|newarray
expr_stmt|;
name|w
operator|->
name|count
operator|+=
name|count
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|rman_manage_region
argument_list|(
operator|&
name|w
operator|->
name|rman
argument_list|,
name|rman_get_start
argument_list|(
name|res
index|[
name|i
index|]
argument_list|)
argument_list|,
name|rman_get_end
argument_list|(
name|res
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|panic
argument_list|(
literal|"Failed to add resource to rman"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_typedef
typedef|typedef
name|void
function_decl|(
name|nonisa_callback
function_decl|)
parameter_list|(
name|rman_res_t
name|start
parameter_list|,
name|rman_res_t
name|end
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_typedef

begin_function
specifier|static
name|void
name|pcib_walk_nonisa_ranges
parameter_list|(
name|rman_res_t
name|start
parameter_list|,
name|rman_res_t
name|end
parameter_list|,
name|nonisa_callback
modifier|*
name|cb
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|rman_res_t
name|next_end
decl_stmt|;
comment|/* 	 * If start is within an ISA alias range, move up to the start 	 * of the next non-alias range.  As a special case, addresses 	 * in the range 0x000 - 0x0ff should also be skipped since 	 * those are used for various system I/O devices in ISA 	 * systems. 	 */
if|if
condition|(
name|start
operator|<=
literal|65535
condition|)
block|{
if|if
condition|(
name|start
operator|<
literal|0x100
operator|||
operator|(
name|start
operator|&
literal|0x300
operator|)
operator|!=
literal|0
condition|)
block|{
name|start
operator|&=
operator|~
literal|0x3ff
expr_stmt|;
name|start
operator|+=
literal|0x400
expr_stmt|;
block|}
block|}
comment|/* ISA aliases are only in the lower 64KB of I/O space. */
while|while
condition|(
name|start
operator|<=
name|MIN
argument_list|(
name|end
argument_list|,
literal|65535
argument_list|)
condition|)
block|{
name|next_end
operator|=
name|MIN
argument_list|(
name|start
operator||
literal|0xff
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|cb
argument_list|(
name|start
argument_list|,
name|next_end
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|start
operator|+=
literal|0x400
expr_stmt|;
block|}
if|if
condition|(
name|start
operator|<=
name|end
condition|)
name|cb
argument_list|(
name|start
argument_list|,
name|end
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|count_ranges
parameter_list|(
name|rman_res_t
name|start
parameter_list|,
name|rman_res_t
name|end
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
modifier|*
name|countp
decl_stmt|;
name|countp
operator|=
name|arg
expr_stmt|;
operator|(
operator|*
name|countp
operator|)
operator|++
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|alloc_state
block|{
name|struct
name|resource
modifier|*
modifier|*
name|res
decl_stmt|;
name|struct
name|pcib_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|count
decl_stmt|,
name|error
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|alloc_ranges
parameter_list|(
name|rman_res_t
name|start
parameter_list|,
name|rman_res_t
name|end
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|alloc_state
modifier|*
name|as
decl_stmt|;
name|struct
name|pcib_window
modifier|*
name|w
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|as
operator|=
name|arg
expr_stmt|;
if|if
condition|(
name|as
operator|->
name|error
operator|!=
literal|0
condition|)
return|return;
name|w
operator|=
operator|&
name|as
operator|->
name|sc
operator|->
name|io
expr_stmt|;
name|rid
operator|=
name|w
operator|->
name|reg
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|as
operator|->
name|sc
operator|->
name|dev
argument_list|,
literal|"allocating non-ISA range %#jx-%#jx\n"
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|as
operator|->
name|res
index|[
name|as
operator|->
name|count
index|]
operator|=
name|bus_alloc_resource
argument_list|(
name|as
operator|->
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|end
operator|-
name|start
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|as
operator|->
name|res
index|[
name|as
operator|->
name|count
index|]
operator|==
name|NULL
condition|)
name|as
operator|->
name|error
operator|=
name|ENXIO
expr_stmt|;
else|else
name|as
operator|->
name|count
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcib_alloc_nonisa_ranges
parameter_list|(
name|struct
name|pcib_softc
modifier|*
name|sc
parameter_list|,
name|rman_res_t
name|start
parameter_list|,
name|rman_res_t
name|end
parameter_list|)
block|{
name|struct
name|alloc_state
name|as
decl_stmt|;
name|int
name|i
decl_stmt|,
name|new_count
decl_stmt|;
comment|/* First, see how many ranges we need. */
name|new_count
operator|=
literal|0
expr_stmt|;
name|pcib_walk_nonisa_ranges
argument_list|(
name|start
argument_list|,
name|end
argument_list|,
name|count_ranges
argument_list|,
operator|&
name|new_count
argument_list|)
expr_stmt|;
comment|/* Second, allocate the ranges. */
name|as
operator|.
name|res
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|resource
operator|*
argument_list|)
operator|*
name|new_count
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|as
operator|.
name|sc
operator|=
name|sc
expr_stmt|;
name|as
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|as
operator|.
name|error
operator|=
literal|0
expr_stmt|;
name|pcib_walk_nonisa_ranges
argument_list|(
name|start
argument_list|,
name|end
argument_list|,
name|alloc_ranges
argument_list|,
operator|&
name|as
argument_list|)
expr_stmt|;
if|if
condition|(
name|as
operator|.
name|error
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|as
operator|.
name|count
condition|;
name|i
operator|++
control|)
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|io
operator|.
name|reg
argument_list|,
name|as
operator|.
name|res
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|as
operator|.
name|res
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|as
operator|.
name|error
operator|)
return|;
block|}
name|KASSERT
argument_list|(
name|as
operator|.
name|count
operator|==
name|new_count
argument_list|,
operator|(
literal|"%s: count mismatch"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* Third, add the ranges to the window. */
name|pcib_add_window_resources
argument_list|(
operator|&
name|sc
operator|->
name|io
argument_list|,
name|as
operator|.
name|res
argument_list|,
name|as
operator|.
name|count
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|as
operator|.
name|res
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pcib_alloc_window
parameter_list|(
name|struct
name|pcib_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|pcib_window
modifier|*
name|w
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|flags
parameter_list|,
name|pci_addr_t
name|max_address
parameter_list|)
block|{
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|int
name|error
decl_stmt|,
name|rid
decl_stmt|;
if|if
condition|(
name|max_address
operator|!=
operator|(
name|rman_res_t
operator|)
name|max_address
condition|)
name|max_address
operator|=
operator|~
literal|0
expr_stmt|;
name|w
operator|->
name|rman
operator|.
name|rm_start
operator|=
literal|0
expr_stmt|;
name|w
operator|->
name|rman
operator|.
name|rm_end
operator|=
name|max_address
expr_stmt|;
name|w
operator|->
name|rman
operator|.
name|rm_type
operator|=
name|RMAN_ARRAY
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s %s window"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|w
operator|->
name|name
argument_list|)
expr_stmt|;
name|w
operator|->
name|rman
operator|.
name|rm_descr
operator|=
name|strdup
argument_list|(
name|buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|error
operator|=
name|rman_init
argument_list|(
operator|&
name|w
operator|->
name|rman
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|panic
argument_list|(
literal|"Failed to initialize %s %s rman"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|w
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pcib_is_window_open
argument_list|(
name|w
argument_list|)
condition|)
return|return;
if|if
condition|(
name|w
operator|->
name|base
operator|>
name|max_address
operator|||
name|w
operator|->
name|limit
operator|>
name|max_address
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"initial %s window has too many bits, ignoring\n"
argument_list|,
name|w
operator|->
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|type
operator|==
name|SYS_RES_IOPORT
operator|&&
name|sc
operator|->
name|bridgectl
operator|&
name|PCIB_BCR_ISA_ENABLE
condition|)
operator|(
name|void
operator|)
name|pcib_alloc_nonisa_ranges
argument_list|(
name|sc
argument_list|,
name|w
operator|->
name|base
argument_list|,
name|w
operator|->
name|limit
argument_list|)
expr_stmt|;
else|else
block|{
name|rid
operator|=
name|w
operator|->
name|reg
expr_stmt|;
name|res
operator|=
name|bus_alloc_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|type
argument_list|,
operator|&
name|rid
argument_list|,
name|w
operator|->
name|base
argument_list|,
name|w
operator|->
name|limit
argument_list|,
name|w
operator|->
name|limit
operator|-
name|w
operator|->
name|base
operator|+
literal|1
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|NULL
condition|)
name|pcib_add_window_resources
argument_list|(
name|w
argument_list|,
operator|&
name|res
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|w
operator|->
name|res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to allocate initial %s window: %#jx-%#jx\n"
argument_list|,
name|w
operator|->
name|name
argument_list|,
operator|(
name|uintmax_t
operator|)
name|w
operator|->
name|base
argument_list|,
operator|(
name|uintmax_t
operator|)
name|w
operator|->
name|limit
argument_list|)
expr_stmt|;
name|w
operator|->
name|base
operator|=
name|max_address
expr_stmt|;
name|w
operator|->
name|limit
operator|=
literal|0
expr_stmt|;
name|pcib_write_windows
argument_list|(
name|sc
argument_list|,
name|w
operator|->
name|mask
argument_list|)
expr_stmt|;
return|return;
block|}
name|pcib_activate_window
argument_list|(
name|sc
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize I/O windows.  */
end_comment

begin_function
specifier|static
name|void
name|pcib_probe_windows
parameter_list|(
name|struct
name|pcib_softc
modifier|*
name|sc
parameter_list|)
block|{
name|pci_addr_t
name|max
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
if|if
condition|(
name|pci_clear_pcib
condition|)
block|{
name|pcib_bridge_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
comment|/* Determine if the I/O port window is implemented. */
name|val
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_IOBASEL_1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
block|{
comment|/* 		 * If 'val' is zero, then only 16-bits of I/O space 		 * are supported. 		 */
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_IOBASEL_1
argument_list|,
literal|0xff
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_IOBASEL_1
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|io
operator|.
name|valid
operator|=
literal|1
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_IOBASEL_1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|sc
operator|->
name|io
operator|.
name|valid
operator|=
literal|1
expr_stmt|;
comment|/* Read the existing I/O port window. */
if|if
condition|(
name|sc
operator|->
name|io
operator|.
name|valid
condition|)
block|{
name|sc
operator|->
name|io
operator|.
name|reg
operator|=
name|PCIR_IOBASEL_1
expr_stmt|;
name|sc
operator|->
name|io
operator|.
name|step
operator|=
literal|12
expr_stmt|;
name|sc
operator|->
name|io
operator|.
name|mask
operator|=
name|WIN_IO
expr_stmt|;
name|sc
operator|->
name|io
operator|.
name|name
operator|=
literal|"I/O port"
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|PCIM_BRIO_MASK
operator|)
operator|==
name|PCIM_BRIO_32
condition|)
block|{
name|sc
operator|->
name|io
operator|.
name|base
operator|=
name|PCI_PPBIOBASE
argument_list|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_IOBASEH_1
argument_list|,
literal|2
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|sc
operator|->
name|io
operator|.
name|limit
operator|=
name|PCI_PPBIOLIMIT
argument_list|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_IOLIMITH_1
argument_list|,
literal|2
argument_list|)
argument_list|,
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_IOLIMITL_1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|max
operator|=
literal|0xffffffff
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|io
operator|.
name|base
operator|=
name|PCI_PPBIOBASE
argument_list|(
literal|0
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|sc
operator|->
name|io
operator|.
name|limit
operator|=
name|PCI_PPBIOLIMIT
argument_list|(
literal|0
argument_list|,
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_IOLIMITL_1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|max
operator|=
literal|0xffff
expr_stmt|;
block|}
name|pcib_alloc_window
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|io
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|0
argument_list|,
name|max
argument_list|)
expr_stmt|;
block|}
comment|/* Read the existing memory window. */
name|sc
operator|->
name|mem
operator|.
name|valid
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|mem
operator|.
name|reg
operator|=
name|PCIR_MEMBASE_1
expr_stmt|;
name|sc
operator|->
name|mem
operator|.
name|step
operator|=
literal|20
expr_stmt|;
name|sc
operator|->
name|mem
operator|.
name|mask
operator|=
name|WIN_MEM
expr_stmt|;
name|sc
operator|->
name|mem
operator|.
name|name
operator|=
literal|"memory"
expr_stmt|;
name|sc
operator|->
name|mem
operator|.
name|base
operator|=
name|PCI_PPBMEMBASE
argument_list|(
literal|0
argument_list|,
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_MEMBASE_1
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mem
operator|.
name|limit
operator|=
name|PCI_PPBMEMLIMIT
argument_list|(
literal|0
argument_list|,
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_MEMLIMIT_1
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|pcib_alloc_window
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
comment|/* Determine if the prefetchable memory window is implemented. */
name|val
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PMBASEL_1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
block|{
comment|/* 		 * If 'val' is zero, then only 32-bits of memory space 		 * are supported. 		 */
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PMBASEL_1
argument_list|,
literal|0xffff
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PMBASEL_1
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|pmem
operator|.
name|valid
operator|=
literal|1
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PMBASEL_1
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|sc
operator|->
name|pmem
operator|.
name|valid
operator|=
literal|1
expr_stmt|;
comment|/* Read the existing prefetchable memory window. */
if|if
condition|(
name|sc
operator|->
name|pmem
operator|.
name|valid
condition|)
block|{
name|sc
operator|->
name|pmem
operator|.
name|reg
operator|=
name|PCIR_PMBASEL_1
expr_stmt|;
name|sc
operator|->
name|pmem
operator|.
name|step
operator|=
literal|20
expr_stmt|;
name|sc
operator|->
name|pmem
operator|.
name|mask
operator|=
name|WIN_PMEM
expr_stmt|;
name|sc
operator|->
name|pmem
operator|.
name|name
operator|=
literal|"prefetch"
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|PCIM_BRPM_MASK
operator|)
operator|==
name|PCIM_BRPM_64
condition|)
block|{
name|sc
operator|->
name|pmem
operator|.
name|base
operator|=
name|PCI_PPBMEMBASE
argument_list|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PMBASEH_1
argument_list|,
literal|4
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|sc
operator|->
name|pmem
operator|.
name|limit
operator|=
name|PCI_PPBMEMLIMIT
argument_list|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PMLIMITH_1
argument_list|,
literal|4
argument_list|)
argument_list|,
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PMLIMITL_1
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|max
operator|=
literal|0xffffffffffffffff
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|pmem
operator|.
name|base
operator|=
name|PCI_PPBMEMBASE
argument_list|(
literal|0
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|sc
operator|->
name|pmem
operator|.
name|limit
operator|=
name|PCI_PPBMEMLIMIT
argument_list|(
literal|0
argument_list|,
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PMLIMITL_1
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|max
operator|=
literal|0xffffffff
expr_stmt|;
block|}
name|pcib_alloc_window
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|pmem
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|RF_PREFETCHABLE
argument_list|,
name|max
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pcib_release_window
parameter_list|(
name|struct
name|pcib_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|pcib_window
modifier|*
name|w
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|w
operator|->
name|valid
condition|)
return|return;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
name|error
operator|=
name|rman_fini
argument_list|(
operator|&
name|w
operator|->
name|rman
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to release %s rman\n"
argument_list|,
name|w
operator|->
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
name|free
argument_list|(
name|__DECONST
argument_list|(
name|char
operator|*
argument_list|,
name|w
operator|->
name|rman
operator|.
name|rm_descr
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|w
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|bus_free_resource
argument_list|(
name|dev
argument_list|,
name|type
argument_list|,
name|w
operator|->
name|res
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to release %s resource: %d\n"
argument_list|,
name|w
operator|->
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|w
operator|->
name|res
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pcib_free_windows
parameter_list|(
name|struct
name|pcib_softc
modifier|*
name|sc
parameter_list|)
block|{
name|pcib_release_window
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|pmem
argument_list|,
name|SYS_RES_MEMORY
argument_list|)
expr_stmt|;
name|pcib_release_window
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|SYS_RES_MEMORY
argument_list|)
expr_stmt|;
name|pcib_release_window
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|io
argument_list|,
name|SYS_RES_IOPORT
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PCI_RES_BUS
end_ifdef

begin_comment
comment|/*  * Allocate a suitable secondary bus for this bridge if needed and  * initialize the resource manager for the secondary bus range.  Note  * that the minimum count is a desired value and this may allocate a  * smaller range.  */
end_comment

begin_function
name|void
name|pcib_setup_secbus
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|pcib_secbus
modifier|*
name|bus
parameter_list|,
name|int
name|min_count
parameter_list|)
block|{
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|int
name|error
decl_stmt|,
name|rid
decl_stmt|,
name|sec_reg
decl_stmt|;
switch|switch
condition|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_HDRTYPE
argument_list|,
literal|1
argument_list|)
operator|&
name|PCIM_HDRTYPE
condition|)
block|{
case|case
name|PCIM_HDRTYPE_BRIDGE
case|:
name|sec_reg
operator|=
name|PCIR_SECBUS_1
expr_stmt|;
name|bus
operator|->
name|sub_reg
operator|=
name|PCIR_SUBBUS_1
expr_stmt|;
break|break;
case|case
name|PCIM_HDRTYPE_CARDBUS
case|:
name|sec_reg
operator|=
name|PCIR_SECBUS_2
expr_stmt|;
name|bus
operator|->
name|sub_reg
operator|=
name|PCIR_SUBBUS_2
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"not a PCI bridge"
argument_list|)
expr_stmt|;
block|}
name|bus
operator|->
name|sec
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|sec_reg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bus
operator|->
name|sub
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|bus
operator|->
name|sub_reg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bus
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|bus
operator|->
name|rman
operator|.
name|rm_start
operator|=
literal|0
expr_stmt|;
name|bus
operator|->
name|rman
operator|.
name|rm_end
operator|=
name|PCI_BUSMAX
expr_stmt|;
name|bus
operator|->
name|rman
operator|.
name|rm_type
operator|=
name|RMAN_ARRAY
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s bus numbers"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|bus
operator|->
name|rman
operator|.
name|rm_descr
operator|=
name|strdup
argument_list|(
name|buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|error
operator|=
name|rman_init
argument_list|(
operator|&
name|bus
operator|->
name|rman
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|panic
argument_list|(
literal|"Failed to initialize %s bus number rman"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate a bus range.  This will return an existing bus range 	 * if one exists, or a new bus range if one does not. 	 */
name|rid
operator|=
literal|0
expr_stmt|;
name|bus
operator|->
name|res
operator|=
name|bus_alloc_resource_anywhere
argument_list|(
name|dev
argument_list|,
name|PCI_RES_BUS
argument_list|,
operator|&
name|rid
argument_list|,
name|min_count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus
operator|->
name|res
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Fall back to just allocating a range of a single bus 		 * number. 		 */
name|bus
operator|->
name|res
operator|=
name|bus_alloc_resource_anywhere
argument_list|(
name|dev
argument_list|,
name|PCI_RES_BUS
argument_list|,
operator|&
name|rid
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rman_get_size
argument_list|(
name|bus
operator|->
name|res
argument_list|)
operator|<
name|min_count
condition|)
comment|/* 		 * Attempt to grow the existing range to satisfy the 		 * minimum desired count. 		 */
operator|(
name|void
operator|)
name|bus_adjust_resource
argument_list|(
name|dev
argument_list|,
name|PCI_RES_BUS
argument_list|,
name|bus
operator|->
name|res
argument_list|,
name|rman_get_start
argument_list|(
name|bus
operator|->
name|res
argument_list|)
argument_list|,
name|rman_get_start
argument_list|(
name|bus
operator|->
name|res
argument_list|)
operator|+
name|min_count
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Add the initial resource to the rman. 	 */
if|if
condition|(
name|bus
operator|->
name|res
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|rman_manage_region
argument_list|(
operator|&
name|bus
operator|->
name|rman
argument_list|,
name|rman_get_start
argument_list|(
name|bus
operator|->
name|res
argument_list|)
argument_list|,
name|rman_get_end
argument_list|(
name|bus
operator|->
name|res
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|panic
argument_list|(
literal|"Failed to add resource to rman"
argument_list|)
expr_stmt|;
name|bus
operator|->
name|sec
operator|=
name|rman_get_start
argument_list|(
name|bus
operator|->
name|res
argument_list|)
expr_stmt|;
name|bus
operator|->
name|sub
operator|=
name|rman_get_end
argument_list|(
name|bus
operator|->
name|res
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|pcib_free_secbus
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|pcib_secbus
modifier|*
name|bus
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|rman_fini
argument_list|(
operator|&
name|bus
operator|->
name|rman
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to release bus number rman\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|free
argument_list|(
name|__DECONST
argument_list|(
name|char
operator|*
argument_list|,
name|bus
operator|->
name|rman
operator|.
name|rm_descr
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_free_resource
argument_list|(
name|dev
argument_list|,
name|PCI_RES_BUS
argument_list|,
name|bus
operator|->
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to release bus numbers resource: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|resource
modifier|*
name|pcib_suballoc_bus
parameter_list|(
name|struct
name|pcib_secbus
modifier|*
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
modifier|*
name|rid
parameter_list|,
name|rman_res_t
name|start
parameter_list|,
name|rman_res_t
name|end
parameter_list|,
name|rman_res_t
name|count
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|res
operator|=
name|rman_reserve_resource
argument_list|(
operator|&
name|bus
operator|->
name|rman
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|,
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|bus
operator|->
name|dev
argument_list|,
literal|"allocated bus range (%ju-%ju) for rid %d of %s\n"
argument_list|,
name|rman_get_start
argument_list|(
name|res
argument_list|)
argument_list|,
name|rman_get_end
argument_list|(
name|res
argument_list|)
argument_list|,
operator|*
name|rid
argument_list|,
name|pcib_child_name
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
name|rman_set_rid
argument_list|(
name|res
argument_list|,
operator|*
name|rid
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attempt to grow the secondary bus range.  This is much simpler than  * for I/O windows as the range can only be grown by increasing  * subbus.  */
end_comment

begin_function
specifier|static
name|int
name|pcib_grow_subbus
parameter_list|(
name|struct
name|pcib_secbus
modifier|*
name|bus
parameter_list|,
name|rman_res_t
name|new_end
parameter_list|)
block|{
name|rman_res_t
name|old_end
decl_stmt|;
name|int
name|error
decl_stmt|;
name|old_end
operator|=
name|rman_get_end
argument_list|(
name|bus
operator|->
name|res
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|new_end
operator|>
name|old_end
argument_list|,
operator|(
literal|"attempt to shrink subbus"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_adjust_resource
argument_list|(
name|bus
operator|->
name|dev
argument_list|,
name|PCI_RES_BUS
argument_list|,
name|bus
operator|->
name|res
argument_list|,
name|rman_get_start
argument_list|(
name|bus
operator|->
name|res
argument_list|)
argument_list|,
name|new_end
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|bus
operator|->
name|dev
argument_list|,
literal|"grew bus range to %ju-%ju\n"
argument_list|,
name|rman_get_start
argument_list|(
name|bus
operator|->
name|res
argument_list|)
argument_list|,
name|rman_get_end
argument_list|(
name|bus
operator|->
name|res
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|rman_manage_region
argument_list|(
operator|&
name|bus
operator|->
name|rman
argument_list|,
name|old_end
operator|+
literal|1
argument_list|,
name|rman_get_end
argument_list|(
name|bus
operator|->
name|res
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|panic
argument_list|(
literal|"Failed to add resource to rman"
argument_list|)
expr_stmt|;
name|bus
operator|->
name|sub
operator|=
name|rman_get_end
argument_list|(
name|bus
operator|->
name|res
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|bus
operator|->
name|dev
argument_list|,
name|bus
operator|->
name|sub_reg
argument_list|,
name|bus
operator|->
name|sub
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|resource
modifier|*
name|pcib_alloc_subbus
parameter_list|(
name|struct
name|pcib_secbus
modifier|*
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
modifier|*
name|rid
parameter_list|,
name|rman_res_t
name|start
parameter_list|,
name|rman_res_t
name|end
parameter_list|,
name|rman_res_t
name|count
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|rman_res_t
name|start_free
decl_stmt|,
name|end_free
decl_stmt|,
name|new_end
decl_stmt|;
comment|/* 	 * First, see if the request can be satisified by the existing 	 * bus range. 	 */
name|res
operator|=
name|pcib_suballoc_bus
argument_list|(
name|bus
argument_list|,
name|child
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|NULL
condition|)
return|return
operator|(
name|res
operator|)
return|;
comment|/* 	 * Figure out a range to grow the bus range.  First, find the 	 * first bus number after the last allocated bus in the rman and 	 * enforce that as a minimum starting point for the range. 	 */
if|if
condition|(
name|rman_last_free_region
argument_list|(
operator|&
name|bus
operator|->
name|rman
argument_list|,
operator|&
name|start_free
argument_list|,
operator|&
name|end_free
argument_list|)
operator|!=
literal|0
operator|||
name|end_free
operator|!=
name|bus
operator|->
name|sub
condition|)
name|start_free
operator|=
name|bus
operator|->
name|sub
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|start_free
operator|<
name|start
condition|)
name|start_free
operator|=
name|start
expr_stmt|;
name|new_end
operator|=
name|start_free
operator|+
name|count
operator|-
literal|1
expr_stmt|;
comment|/* 	 * See if this new range would satisfy the request if it 	 * succeeds. 	 */
if|if
condition|(
name|new_end
operator|>
name|end
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Finally, attempt to grow the existing resource. */
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|bus
operator|->
name|dev
argument_list|,
literal|"attempting to grow bus range for %ju buses\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tback candidate range: %ju-%ju\n"
argument_list|,
name|start_free
argument_list|,
name|new_end
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pcib_grow_subbus
argument_list|(
name|bus
argument_list|,
name|new_end
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|pcib_suballoc_bus
argument_list|(
name|bus
argument_list|,
name|child
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*  * Is the prefetch window open (eg, can we allocate memory in it?)  */
end_comment

begin_function
specifier|static
name|int
name|pcib_is_prefetch_open
parameter_list|(
name|struct
name|pcib_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
name|sc
operator|->
name|pmembase
operator|>
literal|0
operator|&&
name|sc
operator|->
name|pmembase
operator|<
name|sc
operator|->
name|pmemlimit
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Is the nonprefetch window open (eg, can we allocate memory in it?)  */
end_comment

begin_function
specifier|static
name|int
name|pcib_is_nonprefetch_open
parameter_list|(
name|struct
name|pcib_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
name|sc
operator|->
name|membase
operator|>
literal|0
operator|&&
name|sc
operator|->
name|membase
operator|<
name|sc
operator|->
name|memlimit
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Is the io window open (eg, can we allocate ports in it?)  */
end_comment

begin_function
specifier|static
name|int
name|pcib_is_io_open
parameter_list|(
name|struct
name|pcib_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
name|sc
operator|->
name|iobase
operator|>
literal|0
operator|&&
name|sc
operator|->
name|iobase
operator|<
name|sc
operator|->
name|iolimit
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get current I/O decode.  */
end_comment

begin_function
specifier|static
name|void
name|pcib_get_io_decode
parameter_list|(
name|struct
name|pcib_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|uint32_t
name|iolow
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
name|iolow
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_IOBASEL_1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|iolow
operator|&
name|PCIM_BRIO_MASK
operator|)
operator|==
name|PCIM_BRIO_32
condition|)
name|sc
operator|->
name|iobase
operator|=
name|PCI_PPBIOBASE
argument_list|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_IOBASEH_1
argument_list|,
literal|2
argument_list|)
argument_list|,
name|iolow
argument_list|)
expr_stmt|;
else|else
name|sc
operator|->
name|iobase
operator|=
name|PCI_PPBIOBASE
argument_list|(
literal|0
argument_list|,
name|iolow
argument_list|)
expr_stmt|;
name|iolow
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_IOLIMITL_1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|iolow
operator|&
name|PCIM_BRIO_MASK
operator|)
operator|==
name|PCIM_BRIO_32
condition|)
name|sc
operator|->
name|iolimit
operator|=
name|PCI_PPBIOLIMIT
argument_list|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_IOLIMITH_1
argument_list|,
literal|2
argument_list|)
argument_list|,
name|iolow
argument_list|)
expr_stmt|;
else|else
name|sc
operator|->
name|iolimit
operator|=
name|PCI_PPBIOLIMIT
argument_list|(
literal|0
argument_list|,
name|iolow
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get current memory decode.  */
end_comment

begin_function
specifier|static
name|void
name|pcib_get_mem_decode
parameter_list|(
name|struct
name|pcib_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|pci_addr_t
name|pmemlow
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
name|sc
operator|->
name|membase
operator|=
name|PCI_PPBMEMBASE
argument_list|(
literal|0
argument_list|,
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_MEMBASE_1
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|memlimit
operator|=
name|PCI_PPBMEMLIMIT
argument_list|(
literal|0
argument_list|,
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_MEMLIMIT_1
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|pmemlow
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PMBASEL_1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pmemlow
operator|&
name|PCIM_BRPM_MASK
operator|)
operator|==
name|PCIM_BRPM_64
condition|)
name|sc
operator|->
name|pmembase
operator|=
name|PCI_PPBMEMBASE
argument_list|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PMBASEH_1
argument_list|,
literal|4
argument_list|)
argument_list|,
name|pmemlow
argument_list|)
expr_stmt|;
else|else
name|sc
operator|->
name|pmembase
operator|=
name|PCI_PPBMEMBASE
argument_list|(
literal|0
argument_list|,
name|pmemlow
argument_list|)
expr_stmt|;
name|pmemlow
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PMLIMITL_1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pmemlow
operator|&
name|PCIM_BRPM_MASK
operator|)
operator|==
name|PCIM_BRPM_64
condition|)
name|sc
operator|->
name|pmemlimit
operator|=
name|PCI_PPBMEMLIMIT
argument_list|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PMLIMITH_1
argument_list|,
literal|4
argument_list|)
argument_list|,
name|pmemlow
argument_list|)
expr_stmt|;
else|else
name|sc
operator|->
name|pmemlimit
operator|=
name|PCI_PPBMEMLIMIT
argument_list|(
literal|0
argument_list|,
name|pmemlow
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Restore previous I/O decode.  */
end_comment

begin_function
specifier|static
name|void
name|pcib_set_io_decode
parameter_list|(
name|struct
name|pcib_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|uint32_t
name|iohi
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
name|iohi
operator|=
name|sc
operator|->
name|iobase
operator|>>
literal|16
expr_stmt|;
if|if
condition|(
name|iohi
operator|>
literal|0
condition|)
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_IOBASEH_1
argument_list|,
name|iohi
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_IOBASEL_1
argument_list|,
name|sc
operator|->
name|iobase
operator|>>
literal|8
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|iohi
operator|=
name|sc
operator|->
name|iolimit
operator|>>
literal|16
expr_stmt|;
if|if
condition|(
name|iohi
operator|>
literal|0
condition|)
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_IOLIMITH_1
argument_list|,
name|iohi
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_IOLIMITL_1
argument_list|,
name|sc
operator|->
name|iolimit
operator|>>
literal|8
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Restore previous memory decode.  */
end_comment

begin_function
specifier|static
name|void
name|pcib_set_mem_decode
parameter_list|(
name|struct
name|pcib_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|pci_addr_t
name|pmemhi
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_MEMBASE_1
argument_list|,
name|sc
operator|->
name|membase
operator|>>
literal|16
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_MEMLIMIT_1
argument_list|,
name|sc
operator|->
name|memlimit
operator|>>
literal|16
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pmemhi
operator|=
name|sc
operator|->
name|pmembase
operator|>>
literal|32
expr_stmt|;
if|if
condition|(
name|pmemhi
operator|>
literal|0
condition|)
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PMBASEH_1
argument_list|,
name|pmemhi
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PMBASEL_1
argument_list|,
name|sc
operator|->
name|pmembase
operator|>>
literal|16
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pmemhi
operator|=
name|sc
operator|->
name|pmemlimit
operator|>>
literal|32
expr_stmt|;
if|if
condition|(
name|pmemhi
operator|>
literal|0
condition|)
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PMLIMITH_1
argument_list|,
name|pmemhi
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PMLIMITL_1
argument_list|,
name|sc
operator|->
name|pmemlimit
operator|>>
literal|16
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PCI_HP
end_ifdef

begin_comment
comment|/*  * PCI-express HotPlug support.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pci_enable_pcie_hp
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_pci
argument_list|,
name|OID_AUTO
argument_list|,
name|enable_pcie_hp
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|pci_enable_pcie_hp
argument_list|,
literal|0
argument_list|,
literal|"Enable support for native PCI-express HotPlug."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|pcib_probe_hotplug
parameter_list|(
name|struct
name|pcib_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|uint32_t
name|link_cap
decl_stmt|;
name|uint16_t
name|link_sta
decl_stmt|,
name|slot_sta
decl_stmt|;
if|if
condition|(
operator|!
name|pci_enable_pcie_hp
condition|)
return|return;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
if|if
condition|(
name|pci_find_cap
argument_list|(
name|dev
argument_list|,
name|PCIY_EXPRESS
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|pcie_read_config
argument_list|(
name|dev
argument_list|,
name|PCIER_FLAGS
argument_list|,
literal|2
argument_list|)
operator|&
name|PCIEM_FLAGS_SLOT
operator|)
condition|)
return|return;
name|sc
operator|->
name|pcie_slot_cap
operator|=
name|pcie_read_config
argument_list|(
name|dev
argument_list|,
name|PCIER_SLOT_CAP
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|pcie_slot_cap
operator|&
name|PCIEM_SLOT_CAP_HPC
operator|)
operator|==
literal|0
condition|)
return|return;
name|link_cap
operator|=
name|pcie_read_config
argument_list|(
name|dev
argument_list|,
name|PCIER_LINK_CAP
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|link_cap
operator|&
name|PCIEM_LINK_CAP_DL_ACTIVE
operator|)
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * Some devices report that they have an MRL when they actually 	 * do not.  Since they always report that the MRL is open, child 	 * devices would be ignored.  Try to detect these devices and 	 * ignore their claim of HotPlug support. 	 * 	 * If there is an open MRL but the Data Link Layer is active, 	 * the MRL is not real. 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|pcie_slot_cap
operator|&
name|PCIEM_SLOT_CAP_MRLSP
operator|)
operator|!=
literal|0
condition|)
block|{
name|link_sta
operator|=
name|pcie_read_config
argument_list|(
name|dev
argument_list|,
name|PCIER_LINK_STA
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|slot_sta
operator|=
name|pcie_read_config
argument_list|(
name|dev
argument_list|,
name|PCIER_SLOT_STA
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|slot_sta
operator|&
name|PCIEM_SLOT_STA_MRLSS
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|link_sta
operator|&
name|PCIEM_LINK_STA_DL_ACTIVE
operator|)
operator|!=
literal|0
condition|)
block|{
return|return;
block|}
block|}
comment|/* 	 * Now that we're sure we want to do hot plug, ask the 	 * firmware, if any, if that's OK. 	 */
if|if
condition|(
name|pcib_request_feature
argument_list|(
name|dev
argument_list|,
name|PCI_FEATURE_HP
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to activate hot plug feature.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc
operator|->
name|flags
operator||=
name|PCIB_HOTPLUG
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send a HotPlug command to the slot control register.  If this slot  * uses command completion interrupts and a previous command is still  * in progress, then the command is dropped.  Once the previous  * command completes or times out, pcib_pcie_hotplug_update() will be  * invoked to post a new command based on the slot's state at that  * time.  */
end_comment

begin_function
specifier|static
name|void
name|pcib_pcie_hotplug_command
parameter_list|(
name|struct
name|pcib_softc
modifier|*
name|sc
parameter_list|,
name|uint16_t
name|val
parameter_list|,
name|uint16_t
name|mask
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|uint16_t
name|ctl
decl_stmt|,
name|new
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|PCIB_HOTPLUG_CMD_PENDING
condition|)
return|return;
name|ctl
operator|=
name|pcie_read_config
argument_list|(
name|dev
argument_list|,
name|PCIER_SLOT_CTL
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|new
operator|=
operator|(
name|ctl
operator|&
operator|~
name|mask
operator|)
operator||
name|val
expr_stmt|;
if|if
condition|(
name|new
operator|==
name|ctl
condition|)
return|return;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"HotPlug command: %04x -> %04x\n"
argument_list|,
name|ctl
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|pcie_write_config
argument_list|(
name|dev
argument_list|,
name|PCIER_SLOT_CTL
argument_list|,
name|new
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|pcie_slot_cap
operator|&
name|PCIEM_SLOT_CAP_NCCS
operator|)
operator|&&
operator|(
name|ctl
operator|&
name|new
operator|)
operator|&
name|PCIEM_SLOT_CTL_CCIE
condition|)
block|{
name|sc
operator|->
name|flags
operator||=
name|PCIB_HOTPLUG_CMD_PENDING
expr_stmt|;
if|if
condition|(
operator|!
name|cold
condition|)
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|pcie_cc_timer
argument_list|,
name|hz
argument_list|,
name|pcib_pcie_cc_timeout
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pcib_pcie_hotplug_command_completed
parameter_list|(
name|struct
name|pcib_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Command Completed\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|PCIB_HOTPLUG_CMD_PENDING
operator|)
condition|)
return|return;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|pcie_cc_timer
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator|&=
operator|~
name|PCIB_HOTPLUG_CMD_PENDING
expr_stmt|;
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns true if a card is fully inserted from the user's  * perspective.  It may not yet be ready for access, but the driver  * can now start enabling access if necessary.  */
end_comment

begin_function
specifier|static
name|bool
name|pcib_hotplug_inserted
parameter_list|(
name|struct
name|pcib_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Pretend the card isn't present if a detach is forced. */
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|PCIB_DETACHING
condition|)
return|return
operator|(
name|false
operator|)
return|;
comment|/* Card must be present in the slot. */
if|if
condition|(
operator|(
name|sc
operator|->
name|pcie_slot_sta
operator|&
name|PCIEM_SLOT_STA_PDS
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|false
operator|)
return|;
comment|/* A power fault implicitly turns off power to the slot. */
if|if
condition|(
name|sc
operator|->
name|pcie_slot_sta
operator|&
name|PCIEM_SLOT_STA_PFD
condition|)
return|return
operator|(
name|false
operator|)
return|;
comment|/* If the MRL is disengaged, the slot is powered off. */
if|if
condition|(
name|sc
operator|->
name|pcie_slot_cap
operator|&
name|PCIEM_SLOT_CAP_MRLSP
operator|&&
operator|(
name|sc
operator|->
name|pcie_slot_sta
operator|&
name|PCIEM_SLOT_STA_MRLSS
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|false
operator|)
return|;
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns -1 if the card is fully inserted, powered, and ready for  * access.  Otherwise, returns 0.  */
end_comment

begin_function
specifier|static
name|int
name|pcib_hotplug_present
parameter_list|(
name|struct
name|pcib_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Card must be inserted. */
if|if
condition|(
operator|!
name|pcib_hotplug_inserted
argument_list|(
name|sc
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Require the Electromechanical Interlock to be engaged if 	 * present. 	 */
if|if
condition|(
name|sc
operator|->
name|pcie_slot_cap
operator|&
name|PCIEM_SLOT_CAP_EIP
operator|&&
operator|(
name|sc
operator|->
name|pcie_slot_sta
operator|&
name|PCIEM_SLOT_STA_EIS
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Require the Data Link Layer to be active. */
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|pcie_link_sta
operator|&
name|PCIEM_LINK_STA_DL_ACTIVE
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pcib_pcie_hotplug_update
parameter_list|(
name|struct
name|pcib_softc
modifier|*
name|sc
parameter_list|,
name|uint16_t
name|val
parameter_list|,
name|uint16_t
name|mask
parameter_list|,
name|bool
name|schedule_task
parameter_list|)
block|{
name|bool
name|card_inserted
decl_stmt|,
name|ei_engaged
decl_stmt|;
comment|/* Clear DETACHING if Presence Detect has cleared. */
if|if
condition|(
operator|(
name|sc
operator|->
name|pcie_slot_sta
operator|&
operator|(
name|PCIEM_SLOT_STA_PDC
operator||
name|PCIEM_SLOT_STA_PDS
operator|)
operator|)
operator|==
name|PCIEM_SLOT_STA_PDC
condition|)
name|sc
operator|->
name|flags
operator|&=
operator|~
name|PCIB_DETACHING
expr_stmt|;
name|card_inserted
operator|=
name|pcib_hotplug_inserted
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Turn the power indicator on if a card is inserted. */
if|if
condition|(
name|sc
operator|->
name|pcie_slot_cap
operator|&
name|PCIEM_SLOT_CAP_PIP
condition|)
block|{
name|mask
operator||=
name|PCIEM_SLOT_CTL_PIC
expr_stmt|;
if|if
condition|(
name|card_inserted
condition|)
name|val
operator||=
name|PCIEM_SLOT_CTL_PI_ON
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|PCIB_DETACH_PENDING
condition|)
name|val
operator||=
name|PCIEM_SLOT_CTL_PI_BLINK
expr_stmt|;
else|else
name|val
operator||=
name|PCIEM_SLOT_CTL_PI_OFF
expr_stmt|;
block|}
comment|/* Turn the power on via the Power Controller if a card is inserted. */
if|if
condition|(
name|sc
operator|->
name|pcie_slot_cap
operator|&
name|PCIEM_SLOT_CAP_PCP
condition|)
block|{
name|mask
operator||=
name|PCIEM_SLOT_CTL_PCC
expr_stmt|;
if|if
condition|(
name|card_inserted
condition|)
name|val
operator||=
name|PCIEM_SLOT_CTL_PC_ON
expr_stmt|;
else|else
name|val
operator||=
name|PCIEM_SLOT_CTL_PC_OFF
expr_stmt|;
block|}
comment|/* 	 * If a card is inserted, enable the Electromechanical 	 * Interlock.  If a card is not inserted (or we are in the 	 * process of detaching), disable the Electromechanical 	 * Interlock. 	 */
if|if
condition|(
name|sc
operator|->
name|pcie_slot_cap
operator|&
name|PCIEM_SLOT_CAP_EIP
condition|)
block|{
name|mask
operator||=
name|PCIEM_SLOT_CTL_EIC
expr_stmt|;
name|ei_engaged
operator|=
operator|(
name|sc
operator|->
name|pcie_slot_sta
operator|&
name|PCIEM_SLOT_STA_EIS
operator|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|card_inserted
operator|!=
name|ei_engaged
condition|)
name|val
operator||=
name|PCIEM_SLOT_CTL_EIC
expr_stmt|;
block|}
comment|/* 	 * Start a timer to see if the Data Link Layer times out. 	 * Note that we only start the timer if Presence Detect or MRL Sensor 	 * changed on this interrupt.  Stop any scheduled timer if 	 * the Data Link Layer is active. 	 */
if|if
condition|(
name|card_inserted
operator|&&
operator|!
operator|(
name|sc
operator|->
name|pcie_link_sta
operator|&
name|PCIEM_LINK_STA_DL_ACTIVE
operator|)
operator|&&
name|sc
operator|->
name|pcie_slot_sta
operator|&
operator|(
name|PCIEM_SLOT_STA_MRLSC
operator||
name|PCIEM_SLOT_STA_PDC
operator|)
condition|)
block|{
if|if
condition|(
name|cold
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Data Link Layer inactive\n"
argument_list|)
expr_stmt|;
else|else
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|pcie_dll_timer
argument_list|,
name|hz
argument_list|,
name|pcib_pcie_dll_timeout
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|pcie_link_sta
operator|&
name|PCIEM_LINK_STA_DL_ACTIVE
condition|)
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|pcie_dll_timer
argument_list|)
expr_stmt|;
name|pcib_pcie_hotplug_command
argument_list|(
name|sc
argument_list|,
name|val
argument_list|,
name|mask
argument_list|)
expr_stmt|;
comment|/* 	 * During attach the child "pci" device is added synchronously; 	 * otherwise, the task is scheduled to manage the child 	 * device. 	 */
if|if
condition|(
name|schedule_task
operator|&&
operator|(
name|pcib_hotplug_present
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
operator|)
operator|!=
operator|(
name|sc
operator|->
name|child
operator|!=
name|NULL
operator|)
condition|)
name|taskqueue_enqueue
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|sc
operator|->
name|pcie_hp_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pcib_pcie_intr_hotplug
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|pcib_softc
modifier|*
name|sc
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
name|sc
operator|->
name|pcie_slot_sta
operator|=
name|pcie_read_config
argument_list|(
name|dev
argument_list|,
name|PCIER_SLOT_STA
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Clear the events just reported. */
name|pcie_write_config
argument_list|(
name|dev
argument_list|,
name|PCIER_SLOT_STA
argument_list|,
name|sc
operator|->
name|pcie_slot_sta
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"HotPlug interrupt: %#x\n"
argument_list|,
name|sc
operator|->
name|pcie_slot_sta
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|pcie_slot_sta
operator|&
name|PCIEM_SLOT_STA_ABP
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|PCIB_DETACH_PENDING
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Attention Button Pressed: Detach Cancelled\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator|&=
operator|~
name|PCIB_DETACH_PENDING
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|pcie_ab_timer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Attention Button Pressed: Detaching in 5 seconds\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator||=
name|PCIB_DETACH_PENDING
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|pcie_ab_timer
argument_list|,
literal|5
operator|*
name|hz
argument_list|,
name|pcib_pcie_ab_timeout
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|pcie_slot_sta
operator|&
name|PCIEM_SLOT_STA_PFD
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Power Fault Detected\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|pcie_slot_sta
operator|&
name|PCIEM_SLOT_STA_MRLSC
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"MRL Sensor Changed to %s\n"
argument_list|,
name|sc
operator|->
name|pcie_slot_sta
operator|&
name|PCIEM_SLOT_STA_MRLSS
condition|?
literal|"open"
else|:
literal|"closed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
operator|&&
name|sc
operator|->
name|pcie_slot_sta
operator|&
name|PCIEM_SLOT_STA_PDC
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Presence Detect Changed to %s\n"
argument_list|,
name|sc
operator|->
name|pcie_slot_sta
operator|&
name|PCIEM_SLOT_STA_PDS
condition|?
literal|"card present"
else|:
literal|"empty"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|pcie_slot_sta
operator|&
name|PCIEM_SLOT_STA_CC
condition|)
name|pcib_pcie_hotplug_command_completed
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|pcie_slot_sta
operator|&
name|PCIEM_SLOT_STA_DLLSC
condition|)
block|{
name|sc
operator|->
name|pcie_link_sta
operator|=
name|pcie_read_config
argument_list|(
name|dev
argument_list|,
name|PCIER_LINK_STA
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Data Link Layer State Changed to %s\n"
argument_list|,
name|sc
operator|->
name|pcie_link_sta
operator|&
name|PCIEM_LINK_STA_DL_ACTIVE
condition|?
literal|"active"
else|:
literal|"inactive"
argument_list|)
expr_stmt|;
block|}
name|pcib_pcie_hotplug_update
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pcib_pcie_hotplug_task
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|pcib_softc
modifier|*
name|sc
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|sc
operator|=
name|context
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
if|if
condition|(
name|pcib_hotplug_present
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|child
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|child
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"pci"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|child
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|device_delete_child
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|child
argument_list|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|child
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pcib_pcie_ab_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|pcib_softc
modifier|*
name|sc
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|Giant
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|PCIB_DETACH_PENDING
condition|)
block|{
name|sc
operator|->
name|flags
operator||=
name|PCIB_DETACHING
expr_stmt|;
name|sc
operator|->
name|flags
operator|&=
operator|~
name|PCIB_DETACH_PENDING
expr_stmt|;
name|pcib_pcie_hotplug_update
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pcib_pcie_cc_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|pcib_softc
modifier|*
name|sc
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|uint16_t
name|sta
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|Giant
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|sta
operator|=
name|pcie_read_config
argument_list|(
name|dev
argument_list|,
name|PCIER_SLOT_STA
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sta
operator|&
name|PCIEM_SLOT_STA_CC
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"HotPlug Command Timed Out - forcing detach\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator|&=
operator|~
operator|(
name|PCIB_HOTPLUG_CMD_PENDING
operator||
name|PCIB_DETACH_PENDING
operator|)
expr_stmt|;
name|sc
operator|->
name|flags
operator||=
name|PCIB_DETACHING
expr_stmt|;
name|pcib_pcie_hotplug_update
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Missed HotPlug interrupt waiting for Command Completion\n"
argument_list|)
expr_stmt|;
name|pcib_pcie_intr_hotplug
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pcib_pcie_dll_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|pcib_softc
modifier|*
name|sc
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|uint16_t
name|sta
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|Giant
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|sta
operator|=
name|pcie_read_config
argument_list|(
name|dev
argument_list|,
name|PCIER_LINK_STA
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sta
operator|&
name|PCIEM_LINK_STA_DL_ACTIVE
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Timed out waiting for Data Link Layer Active\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator||=
name|PCIB_DETACHING
expr_stmt|;
name|pcib_pcie_hotplug_update
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sta
operator|!=
name|sc
operator|->
name|pcie_link_sta
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Missed HotPlug interrupt waiting for DLL Active\n"
argument_list|)
expr_stmt|;
name|pcib_pcie_intr_hotplug
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|pcib_alloc_pcie_irq
parameter_list|(
name|struct
name|pcib_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|int
name|count
decl_stmt|,
name|error
decl_stmt|,
name|rid
decl_stmt|;
name|rid
operator|=
operator|-
literal|1
expr_stmt|;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
comment|/* 	 * For simplicity, only use MSI-X if there is a single message. 	 * To support a device with multiple messages we would have to 	 * use remap intr if the MSI number is not 0. 	 */
name|count
operator|=
name|pci_msix_count
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|1
condition|)
block|{
name|error
operator|=
name|pci_alloc_msix
argument_list|(
name|dev
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|rid
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|rid
operator|<
literal|0
operator|&&
name|pci_msi_count
argument_list|(
name|dev
argument_list|)
operator|>
literal|0
condition|)
block|{
name|count
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|pci_alloc_msi
argument_list|(
name|dev
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|rid
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|rid
operator|<
literal|0
condition|)
name|rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|pcie_irq
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|pcie_irq
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to allocate interrupt for PCI-e events\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rid
operator|>
literal|0
condition|)
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|pcie_irq
argument_list|,
name|INTR_TYPE_MISC
argument_list|,
name|NULL
argument_list|,
name|pcib_pcie_intr_hotplug
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|pcie_ihand
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to setup PCI-e interrupt handler\n"
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rid
argument_list|,
name|sc
operator|->
name|pcie_irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|rid
operator|>
literal|0
condition|)
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcib_release_pcie_irq
parameter_list|(
name|struct
name|pcib_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|int
name|error
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
name|error
operator|=
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|pcie_irq
argument_list|,
name|sc
operator|->
name|pcie_ihand
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|bus_free_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|pcie_irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pcib_setup_hotplug
parameter_list|(
name|struct
name|pcib_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|uint16_t
name|mask
decl_stmt|,
name|val
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|pcie_ab_timer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|pcie_cc_timer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|pcie_dll_timer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|pcie_hp_task
argument_list|,
literal|0
argument_list|,
name|pcib_pcie_hotplug_task
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* Allocate IRQ. */
if|if
condition|(
name|pcib_alloc_pcie_irq
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|sc
operator|->
name|pcie_link_sta
operator|=
name|pcie_read_config
argument_list|(
name|dev
argument_list|,
name|PCIER_LINK_STA
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|->
name|pcie_slot_sta
operator|=
name|pcie_read_config
argument_list|(
name|dev
argument_list|,
name|PCIER_SLOT_STA
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Clear any events previously pending. */
name|pcie_write_config
argument_list|(
name|dev
argument_list|,
name|PCIER_SLOT_STA
argument_list|,
name|sc
operator|->
name|pcie_slot_sta
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Enable HotPlug events. */
name|mask
operator|=
name|PCIEM_SLOT_CTL_DLLSCE
operator||
name|PCIEM_SLOT_CTL_HPIE
operator||
name|PCIEM_SLOT_CTL_CCIE
operator||
name|PCIEM_SLOT_CTL_PDCE
operator||
name|PCIEM_SLOT_CTL_MRLSCE
operator||
name|PCIEM_SLOT_CTL_PFDE
operator||
name|PCIEM_SLOT_CTL_ABPE
expr_stmt|;
name|val
operator|=
name|PCIEM_SLOT_CTL_DLLSCE
operator||
name|PCIEM_SLOT_CTL_HPIE
operator||
name|PCIEM_SLOT_CTL_PDCE
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|pcie_slot_cap
operator|&
name|PCIEM_SLOT_CAP_APB
condition|)
name|val
operator||=
name|PCIEM_SLOT_CTL_ABPE
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|pcie_slot_cap
operator|&
name|PCIEM_SLOT_CAP_PCP
condition|)
name|val
operator||=
name|PCIEM_SLOT_CTL_PFDE
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|pcie_slot_cap
operator|&
name|PCIEM_SLOT_CAP_MRLSP
condition|)
name|val
operator||=
name|PCIEM_SLOT_CTL_MRLSCE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|pcie_slot_cap
operator|&
name|PCIEM_SLOT_CAP_NCCS
operator|)
condition|)
name|val
operator||=
name|PCIEM_SLOT_CTL_CCIE
expr_stmt|;
comment|/* Turn the attention indicator off. */
if|if
condition|(
name|sc
operator|->
name|pcie_slot_cap
operator|&
name|PCIEM_SLOT_CAP_AIP
condition|)
block|{
name|mask
operator||=
name|PCIEM_SLOT_CTL_AIC
expr_stmt|;
name|val
operator||=
name|PCIEM_SLOT_CTL_AI_OFF
expr_stmt|;
block|}
name|pcib_pcie_hotplug_update
argument_list|(
name|sc
argument_list|,
name|val
argument_list|,
name|mask
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcib_detach_hotplug
parameter_list|(
name|struct
name|pcib_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint16_t
name|mask
decl_stmt|,
name|val
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Disable the card in the slot and force it to detach. */
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|PCIB_DETACH_PENDING
condition|)
block|{
name|sc
operator|->
name|flags
operator|&=
operator|~
name|PCIB_DETACH_PENDING
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|pcie_ab_timer
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|flags
operator||=
name|PCIB_DETACHING
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|PCIB_HOTPLUG_CMD_PENDING
condition|)
block|{
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|pcie_cc_timer
argument_list|)
expr_stmt|;
name|tsleep
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|"hpcmd"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator|&=
operator|~
name|PCIB_HOTPLUG_CMD_PENDING
expr_stmt|;
block|}
comment|/* Disable HotPlug events. */
name|mask
operator|=
name|PCIEM_SLOT_CTL_DLLSCE
operator||
name|PCIEM_SLOT_CTL_HPIE
operator||
name|PCIEM_SLOT_CTL_CCIE
operator||
name|PCIEM_SLOT_CTL_PDCE
operator||
name|PCIEM_SLOT_CTL_MRLSCE
operator||
name|PCIEM_SLOT_CTL_PFDE
operator||
name|PCIEM_SLOT_CTL_ABPE
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
comment|/* Turn the attention indicator off. */
if|if
condition|(
name|sc
operator|->
name|pcie_slot_cap
operator|&
name|PCIEM_SLOT_CAP_AIP
condition|)
block|{
name|mask
operator||=
name|PCIEM_SLOT_CTL_AIC
expr_stmt|;
name|val
operator||=
name|PCIEM_SLOT_CTL_AI_OFF
expr_stmt|;
block|}
name|pcib_pcie_hotplug_update
argument_list|(
name|sc
argument_list|,
name|val
argument_list|,
name|mask
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|error
operator|=
name|pcib_release_pcie_irq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|taskqueue_drain
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|sc
operator|->
name|pcie_hp_task
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|pcie_ab_timer
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|pcie_cc_timer
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|pcie_dll_timer
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Get current bridge configuration.  */
end_comment

begin_function
specifier|static
name|void
name|pcib_cfg_save
parameter_list|(
name|struct
name|pcib_softc
modifier|*
name|sc
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|NEW_PCIB
name|device_t
name|dev
decl_stmt|;
name|uint16_t
name|command
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
name|command
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
operator|&
name|PCIM_CMD_PORTEN
condition|)
name|pcib_get_io_decode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
operator|&
name|PCIM_CMD_MEMEN
condition|)
name|pcib_get_mem_decode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Restore previous bridge configuration.  */
end_comment

begin_function
specifier|static
name|void
name|pcib_cfg_restore
parameter_list|(
name|struct
name|pcib_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
ifndef|#
directive|ifndef
name|NEW_PCIB
name|uint16_t
name|command
decl_stmt|;
endif|#
directive|endif
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
ifdef|#
directive|ifdef
name|NEW_PCIB
name|pcib_write_windows
argument_list|(
name|sc
argument_list|,
name|WIN_IO
operator||
name|WIN_MEM
operator||
name|WIN_PMEM
argument_list|)
expr_stmt|;
else|#
directive|else
name|command
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
operator|&
name|PCIM_CMD_PORTEN
condition|)
name|pcib_set_io_decode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
operator|&
name|PCIM_CMD_MEMEN
condition|)
name|pcib_set_mem_decode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Generic device interface  */
end_comment

begin_function
specifier|static
name|int
name|pcib_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
operator|(
name|pci_get_class
argument_list|(
name|dev
argument_list|)
operator|==
name|PCIC_BRIDGE
operator|)
operator|&&
operator|(
name|pci_get_subclass
argument_list|(
name|dev
argument_list|)
operator|==
name|PCIS_BRIDGE_PCI
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"PCI-PCI bridge"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|10000
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pcib_attach_common
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|pcib_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|sysctl_ctx_list
modifier|*
name|sctx
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|soid
decl_stmt|;
name|int
name|comma
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
comment|/*      * Get current bridge configuration.      */
name|sc
operator|->
name|domain
operator|=
name|pci_get_domain
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|NEW_PCIB
argument_list|)
operator|&&
name|defined
argument_list|(
name|PCI_RES_BUS
argument_list|)
operator|)
name|sc
operator|->
name|bus
operator|.
name|sec
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SECBUS_1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bus
operator|.
name|sub
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SUBBUS_1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|bridgectl
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_BRIDGECTL_1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pcib_cfg_save
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*      * The primary bus register should always be the bus of the      * parent.      */
name|sc
operator|->
name|pribus
operator|=
name|pci_get_bus
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PRIBUS_1
argument_list|,
name|sc
operator|->
name|pribus
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*      * Setup sysctl reporting nodes      */
name|sctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|soid
operator|=
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|sctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|soid
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"domain"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|domain
argument_list|,
literal|0
argument_list|,
literal|"Domain number"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|sctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|soid
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"pribus"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|pribus
argument_list|,
literal|0
argument_list|,
literal|"Primary bus number"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|sctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|soid
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"secbus"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|bus
operator|.
name|sec
argument_list|,
literal|0
argument_list|,
literal|"Secondary bus number"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|sctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|soid
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"subbus"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|bus
operator|.
name|sub
argument_list|,
literal|0
argument_list|,
literal|"Subordinate bus number"
argument_list|)
expr_stmt|;
comment|/*      * Quirk handling.      */
switch|switch
condition|(
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|NEW_PCIB
argument_list|)
operator|&&
name|defined
argument_list|(
name|PCI_RES_BUS
argument_list|)
operator|)
case|case
literal|0x12258086
case|:
comment|/* Intel 82454KX/GX (Orion) */
block|{
name|uint8_t
name|supbus
decl_stmt|;
name|supbus
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
literal|0x41
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|supbus
operator|!=
literal|0xff
condition|)
block|{
name|sc
operator|->
name|bus
operator|.
name|sec
operator|=
name|supbus
operator|+
literal|1
expr_stmt|;
name|sc
operator|->
name|bus
operator|.
name|sub
operator|=
name|supbus
operator|+
literal|1
expr_stmt|;
block|}
break|break;
block|}
endif|#
directive|endif
comment|/*      * The i82380FB mobile docking controller is a PCI-PCI bridge,      * and it is a subtractive bridge.  However, the ProgIf is wrong      * so the normal setting of PCIB_SUBTRACTIVE bit doesn't      * happen.  There are also Toshiba and Cavium ThunderX bridges      * that behave this way.      */
case|case
literal|0xa002177d
case|:
comment|/* Cavium ThunderX */
case|case
literal|0x124b8086
case|:
comment|/* Intel 82380FB Mobile */
case|case
literal|0x060513d7
case|:
comment|/* Toshiba ???? */
name|sc
operator|->
name|flags
operator||=
name|PCIB_SUBTRACTIVE
expr_stmt|;
break|break;
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|NEW_PCIB
argument_list|)
operator|&&
name|defined
argument_list|(
name|PCI_RES_BUS
argument_list|)
operator|)
comment|/* Compaq R3000 BIOS sets wrong subordinate bus number. */
case|case
literal|0x00dd10de
case|:
block|{
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|kern_getenv
argument_list|(
literal|"smbios.planar.maker"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"Compal"
argument_list|,
literal|6
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|freeenv
argument_list|(
name|cp
argument_list|)
expr_stmt|;
break|break;
block|}
name|freeenv
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|kern_getenv
argument_list|(
literal|"smbios.planar.product"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"08A0"
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|freeenv
argument_list|(
name|cp
argument_list|)
expr_stmt|;
break|break;
block|}
name|freeenv
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|bus
operator|.
name|sub
operator|<
literal|0xa
condition|)
block|{
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SUBBUS_1
argument_list|,
literal|0xa
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bus
operator|.
name|sub
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SUBBUS_1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|pci_msi_device_blacklisted
argument_list|(
name|dev
argument_list|)
condition|)
name|sc
operator|->
name|flags
operator||=
name|PCIB_DISABLE_MSI
expr_stmt|;
if|if
condition|(
name|pci_msix_device_blacklisted
argument_list|(
name|dev
argument_list|)
condition|)
name|sc
operator|->
name|flags
operator||=
name|PCIB_DISABLE_MSIX
expr_stmt|;
comment|/*      * Intel 815, 845 and other chipsets say they are PCI-PCI bridges,      * but have a ProgIF of 0x80.  The 82801 family (AA, AB, BAM/CAM,      * BA/CA/DB and E) PCI bridges are HUB-PCI bridges, in Intelese.      * This means they act as if they were subtractively decoding      * bridges and pass all transactions.  Mark them and real ProgIf 1      * parts as subtractive.      */
if|if
condition|(
operator|(
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
operator|&
literal|0xff00ffff
operator|)
operator|==
literal|0x24008086
operator|||
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PROGIF
argument_list|,
literal|1
argument_list|)
operator|==
name|PCIP_BRIDGE_PCI_SUBTRACTIVE
condition|)
name|sc
operator|->
name|flags
operator||=
name|PCIB_SUBTRACTIVE
expr_stmt|;
ifdef|#
directive|ifdef
name|PCI_HP
name|pcib_probe_hotplug
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NEW_PCIB
ifdef|#
directive|ifdef
name|PCI_RES_BUS
name|pcib_setup_secbus
argument_list|(
name|dev
argument_list|,
operator|&
name|sc
operator|->
name|bus
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pcib_probe_windows
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PCI_HP
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|PCIB_HOTPLUG
condition|)
name|pcib_setup_hotplug
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"  domain            %d\n"
argument_list|,
name|sc
operator|->
name|domain
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"  secondary bus     %d\n"
argument_list|,
name|sc
operator|->
name|bus
operator|.
name|sec
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"  subordinate bus   %d\n"
argument_list|,
name|sc
operator|->
name|bus
operator|.
name|sub
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NEW_PCIB
if|if
condition|(
name|pcib_is_window_open
argument_list|(
operator|&
name|sc
operator|->
name|io
argument_list|)
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"  I/O decode        0x%jx-0x%jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sc
operator|->
name|io
operator|.
name|base
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sc
operator|->
name|io
operator|.
name|limit
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcib_is_window_open
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|)
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"  memory decode     0x%jx-0x%jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sc
operator|->
name|mem
operator|.
name|base
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sc
operator|->
name|mem
operator|.
name|limit
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcib_is_window_open
argument_list|(
operator|&
name|sc
operator|->
name|pmem
argument_list|)
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"  prefetched decode 0x%jx-0x%jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sc
operator|->
name|pmem
operator|.
name|base
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sc
operator|->
name|pmem
operator|.
name|limit
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|pcib_is_io_open
argument_list|(
name|sc
argument_list|)
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"  I/O decode        0x%x-0x%x\n"
argument_list|,
name|sc
operator|->
name|iobase
argument_list|,
name|sc
operator|->
name|iolimit
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcib_is_nonprefetch_open
argument_list|(
name|sc
argument_list|)
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"  memory decode     0x%jx-0x%jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sc
operator|->
name|membase
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sc
operator|->
name|memlimit
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcib_is_prefetch_open
argument_list|(
name|sc
argument_list|)
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"  prefetched decode 0x%jx-0x%jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sc
operator|->
name|pmembase
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sc
operator|->
name|pmemlimit
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|bridgectl
operator|&
operator|(
name|PCIB_BCR_ISA_ENABLE
operator||
name|PCIB_BCR_VGA_ENABLE
operator|)
operator|||
name|sc
operator|->
name|flags
operator|&
name|PCIB_SUBTRACTIVE
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"  special decode    "
argument_list|)
expr_stmt|;
name|comma
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|bridgectl
operator|&
name|PCIB_BCR_ISA_ENABLE
condition|)
block|{
name|printf
argument_list|(
literal|"ISA"
argument_list|)
expr_stmt|;
name|comma
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|bridgectl
operator|&
name|PCIB_BCR_VGA_ENABLE
condition|)
block|{
name|printf
argument_list|(
literal|"%sVGA"
argument_list|,
name|comma
condition|?
literal|", "
else|:
literal|""
argument_list|)
expr_stmt|;
name|comma
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|PCIB_SUBTRACTIVE
condition|)
name|printf
argument_list|(
literal|"%ssubtractive"
argument_list|,
name|comma
condition|?
literal|", "
else|:
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Always enable busmastering on bridges so that transactions      * initiated on the secondary bus are passed through to the      * primary bus.      */
name|pci_enable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PCI_HP
end_ifdef

begin_function
specifier|static
name|int
name|pcib_present
parameter_list|(
name|struct
name|pcib_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|PCIB_HOTPLUG
condition|)
return|return
operator|(
name|pcib_hotplug_present
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|pcib_attach_child
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|pcib_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|bus
operator|.
name|sec
operator|==
literal|0
condition|)
block|{
comment|/* no secondary bus; we should have fixed this */
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|PCI_HP
if|if
condition|(
operator|!
name|pcib_present
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* An empty HotPlug slot, so don't add a PCI bus yet. */
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
name|sc
operator|->
name|child
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"pci"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcib_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|pcib_attach_common
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|pcib_attach_child
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcib_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|PCI_HP
argument_list|)
operator|||
name|defined
argument_list|(
name|NEW_PCIB
argument_list|)
name|struct
name|pcib_softc
modifier|*
name|sc
decl_stmt|;
endif|#
directive|endif
name|int
name|error
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PCI_HP
argument_list|)
operator|||
name|defined
argument_list|(
name|NEW_PCIB
argument_list|)
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|bus_generic_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
ifdef|#
directive|ifdef
name|PCI_HP
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|PCIB_HOTPLUG
condition|)
block|{
name|error
operator|=
name|pcib_detach_hotplug
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
endif|#
directive|endif
name|error
operator|=
name|device_delete_children
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
ifdef|#
directive|ifdef
name|NEW_PCIB
name|pcib_free_windows
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PCI_RES_BUS
name|pcib_free_secbus
argument_list|(
name|dev
argument_list|,
operator|&
name|sc
operator|->
name|bus
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcib_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|pcib_cfg_save
argument_list|(
name|device_get_softc
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|bus_generic_suspend
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcib_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|pcib_cfg_restore
argument_list|(
name|device_get_softc
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|bus_generic_resume
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pcib_bridge_init
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_IOBASEL_1
argument_list|,
literal|0xff
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_IOBASEH_1
argument_list|,
literal|0xffff
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_IOLIMITL_1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_IOLIMITH_1
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_MEMBASE_1
argument_list|,
literal|0xffff
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_MEMLIMIT_1
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PMBASEL_1
argument_list|,
literal|0xffff
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PMBASEH_1
argument_list|,
literal|0xffffffff
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PMLIMITL_1
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PMLIMITH_1
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pcib_child_present
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PCI_HP
name|struct
name|pcib_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|bus_child_present
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
operator|&&
name|sc
operator|->
name|flags
operator|&
name|PCIB_HOTPLUG
condition|)
name|retval
operator|=
name|pcib_hotplug_present
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|bus_child_present
argument_list|(
name|dev
argument_list|)
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|pcib_read_ivar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|which
parameter_list|,
name|uintptr_t
modifier|*
name|result
parameter_list|)
block|{
name|struct
name|pcib_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|PCIB_IVAR_DOMAIN
case|:
operator|*
name|result
operator|=
name|sc
operator|->
name|domain
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|PCIB_IVAR_BUS
case|:
operator|*
name|result
operator|=
name|sc
operator|->
name|bus
operator|.
name|sec
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcib_write_ivar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|which
parameter_list|,
name|uintptr_t
name|value
parameter_list|)
block|{
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|PCIB_IVAR_DOMAIN
case|:
return|return
operator|(
name|EINVAL
operator|)
return|;
case|case
name|PCIB_IVAR_BUS
case|:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|NEW_PCIB
end_ifdef

begin_comment
comment|/*  * Attempt to allocate a resource from the existing resources assigned  * to a window.  */
end_comment

begin_function
specifier|static
name|struct
name|resource
modifier|*
name|pcib_suballoc_resource
parameter_list|(
name|struct
name|pcib_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|pcib_window
modifier|*
name|w
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|rid
parameter_list|,
name|rman_res_t
name|start
parameter_list|,
name|rman_res_t
name|end
parameter_list|,
name|rman_res_t
name|count
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
if|if
condition|(
operator|!
name|pcib_is_window_open
argument_list|(
name|w
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|res
operator|=
name|rman_reserve_resource
argument_list|(
operator|&
name|w
operator|->
name|rman
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
operator|&
operator|~
name|RF_ACTIVE
argument_list|,
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"allocated %s range (%#jx-%#jx) for rid %x of %s\n"
argument_list|,
name|w
operator|->
name|name
argument_list|,
name|rman_get_start
argument_list|(
name|res
argument_list|)
argument_list|,
name|rman_get_end
argument_list|(
name|res
argument_list|)
argument_list|,
operator|*
name|rid
argument_list|,
name|pcib_child_name
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
name|rman_set_rid
argument_list|(
name|res
argument_list|,
operator|*
name|rid
argument_list|)
expr_stmt|;
comment|/* 	 * If the resource should be active, pass that request up the 	 * tree.  This assumes the parent drivers can handle 	 * activating sub-allocated resources. 	 */
if|if
condition|(
name|flags
operator|&
name|RF_ACTIVE
condition|)
block|{
if|if
condition|(
name|bus_activate_resource
argument_list|(
name|child
argument_list|,
name|type
argument_list|,
operator|*
name|rid
argument_list|,
name|res
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|rman_release_resource
argument_list|(
name|res
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Allocate a fresh resource range for an unconfigured window. */
end_comment

begin_function
specifier|static
name|int
name|pcib_alloc_new_window
parameter_list|(
name|struct
name|pcib_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|pcib_window
modifier|*
name|w
parameter_list|,
name|int
name|type
parameter_list|,
name|rman_res_t
name|start
parameter_list|,
name|rman_res_t
name|end
parameter_list|,
name|rman_res_t
name|count
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|rman_res_t
name|base
decl_stmt|,
name|limit
decl_stmt|,
name|wmask
decl_stmt|;
name|int
name|rid
decl_stmt|;
comment|/* 	 * If this is an I/O window on a bridge with ISA enable set 	 * and the start address is below 64k, then try to allocate an 	 * initial window of 0x1000 bytes long starting at address 	 * 0xf000 and walking down.  Note that if the original request 	 * was larger than the non-aliased range size of 0x100 our 	 * caller would have raised the start address up to 64k 	 * already. 	 */
if|if
condition|(
name|type
operator|==
name|SYS_RES_IOPORT
operator|&&
name|sc
operator|->
name|bridgectl
operator|&
name|PCIB_BCR_ISA_ENABLE
operator|&&
name|start
operator|<
literal|65536
condition|)
block|{
for|for
control|(
name|base
operator|=
literal|0xf000
init|;
operator|(
name|long
operator|)
name|base
operator|>=
literal|0
condition|;
name|base
operator|-=
literal|0x1000
control|)
block|{
name|limit
operator|=
name|base
operator|+
literal|0xfff
expr_stmt|;
comment|/* 			 * Skip ranges that wouldn't work for the 			 * original request.  Note that the actual 			 * window that overlaps are the non-alias 			 * ranges within [base, limit], so this isn't 			 * quite a simple comparison. 			 */
if|if
condition|(
name|start
operator|+
name|count
operator|>
name|limit
operator|-
literal|0x400
condition|)
continue|continue;
if|if
condition|(
name|base
operator|==
literal|0
condition|)
block|{
comment|/* 				 * The first open region for the window at 				 * 0 is 0x400-0x4ff. 				 */
if|if
condition|(
name|end
operator|-
name|count
operator|+
literal|1
operator|<
literal|0x400
condition|)
continue|continue;
block|}
else|else
block|{
if|if
condition|(
name|end
operator|-
name|count
operator|+
literal|1
operator|<
name|base
condition|)
continue|continue;
block|}
if|if
condition|(
name|pcib_alloc_nonisa_ranges
argument_list|(
name|sc
argument_list|,
name|base
argument_list|,
name|limit
argument_list|)
operator|==
literal|0
condition|)
block|{
name|w
operator|->
name|base
operator|=
name|base
expr_stmt|;
name|w
operator|->
name|limit
operator|=
name|limit
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
name|wmask
operator|=
operator|(
operator|(
name|rman_res_t
operator|)
literal|1
operator|<<
name|w
operator|->
name|step
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|RF_ALIGNMENT
argument_list|(
name|flags
argument_list|)
operator|<
name|w
operator|->
name|step
condition|)
block|{
name|flags
operator|&=
operator|~
name|RF_ALIGNMENT_MASK
expr_stmt|;
name|flags
operator||=
name|RF_ALIGNMENT_LOG2
argument_list|(
name|w
operator|->
name|step
argument_list|)
expr_stmt|;
block|}
name|start
operator|&=
operator|~
name|wmask
expr_stmt|;
name|end
operator||=
name|wmask
expr_stmt|;
name|count
operator|=
name|roundup2
argument_list|(
name|count
argument_list|,
operator|(
name|rman_res_t
operator|)
literal|1
operator|<<
name|w
operator|->
name|step
argument_list|)
expr_stmt|;
name|rid
operator|=
name|w
operator|->
name|reg
expr_stmt|;
name|res
operator|=
name|bus_alloc_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|type
argument_list|,
operator|&
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
operator|&
operator|~
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
name|pcib_add_window_resources
argument_list|(
name|w
argument_list|,
operator|&
name|res
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pcib_activate_window
argument_list|(
name|sc
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|w
operator|->
name|base
operator|=
name|rman_get_start
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|w
operator|->
name|limit
operator|=
name|rman_get_end
argument_list|(
name|res
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Try to expand an existing window to the requested base and limit. */
end_comment

begin_function
specifier|static
name|int
name|pcib_expand_window
parameter_list|(
name|struct
name|pcib_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|pcib_window
modifier|*
name|w
parameter_list|,
name|int
name|type
parameter_list|,
name|rman_res_t
name|base
parameter_list|,
name|rman_res_t
name|limit
parameter_list|)
block|{
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|force_64k_base
decl_stmt|;
name|KASSERT
argument_list|(
name|base
operator|<=
name|w
operator|->
name|base
operator|&&
name|limit
operator|>=
name|w
operator|->
name|limit
argument_list|,
operator|(
literal|"attempting to shrink window"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * XXX: pcib_grow_window() doesn't try to do this anyway and 	 * the error handling for all the edge cases would be tedious. 	 */
name|KASSERT
argument_list|(
name|limit
operator|==
name|w
operator|->
name|limit
operator|||
name|base
operator|==
name|w
operator|->
name|base
argument_list|,
operator|(
literal|"attempting to grow both ends of a window"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Yet more special handling for requests to expand an I/O 	 * window behind an ISA-enabled bridge.  Since I/O windows 	 * have to grow in 0x1000 increments and the end of the 0xffff 	 * range is an alias, growing a window below 64k will always 	 * result in allocating new resources and never adjusting an 	 * existing resource. 	 */
if|if
condition|(
name|type
operator|==
name|SYS_RES_IOPORT
operator|&&
name|sc
operator|->
name|bridgectl
operator|&
name|PCIB_BCR_ISA_ENABLE
operator|&&
operator|(
name|limit
operator|<=
literal|65535
operator|||
operator|(
name|base
operator|<=
literal|65535
operator|&&
name|base
operator|!=
name|w
operator|->
name|base
operator|)
operator|)
condition|)
block|{
name|KASSERT
argument_list|(
name|limit
operator|==
name|w
operator|->
name|limit
operator|||
name|limit
operator|<=
literal|65535
argument_list|,
operator|(
literal|"attempting to grow both ends across 64k ISA alias"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|!=
name|w
operator|->
name|base
condition|)
name|error
operator|=
name|pcib_alloc_nonisa_ranges
argument_list|(
name|sc
argument_list|,
name|base
argument_list|,
name|w
operator|->
name|base
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|pcib_alloc_nonisa_ranges
argument_list|(
name|sc
argument_list|,
name|w
operator|->
name|limit
operator|+
literal|1
argument_list|,
name|limit
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|w
operator|->
name|base
operator|=
name|base
expr_stmt|;
name|w
operator|->
name|limit
operator|=
name|limit
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Find the existing resource to adjust.  Usually there is only one, 	 * but for an ISA-enabled bridge we might be growing the I/O window 	 * above 64k and need to find the existing resource that maps all 	 * of the area above 64k. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|w
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rman_get_end
argument_list|(
name|w
operator|->
name|res
index|[
name|i
index|]
argument_list|)
operator|==
name|w
operator|->
name|limit
condition|)
break|break;
block|}
name|KASSERT
argument_list|(
name|i
operator|!=
name|w
operator|->
name|count
argument_list|,
operator|(
literal|"did not find existing resource"
operator|)
argument_list|)
expr_stmt|;
name|res
operator|=
name|w
operator|->
name|res
index|[
name|i
index|]
expr_stmt|;
comment|/* 	 * Usually the resource we found should match the window's 	 * existing range.  The one exception is the ISA-enabled case 	 * mentioned above in which case the resource should start at 	 * 64k. 	 */
if|if
condition|(
name|type
operator|==
name|SYS_RES_IOPORT
operator|&&
name|sc
operator|->
name|bridgectl
operator|&
name|PCIB_BCR_ISA_ENABLE
operator|&&
name|w
operator|->
name|base
operator|<=
literal|65535
condition|)
block|{
name|KASSERT
argument_list|(
name|rman_get_start
argument_list|(
name|res
argument_list|)
operator|==
literal|65536
argument_list|,
operator|(
literal|"existing resource mismatch"
operator|)
argument_list|)
expr_stmt|;
name|force_64k_base
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|KASSERT
argument_list|(
name|w
operator|->
name|base
operator|==
name|rman_get_start
argument_list|(
name|res
argument_list|)
argument_list|,
operator|(
literal|"existing resource mismatch"
operator|)
argument_list|)
expr_stmt|;
name|force_64k_base
operator|=
literal|0
expr_stmt|;
block|}
name|error
operator|=
name|bus_adjust_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|type
argument_list|,
name|res
argument_list|,
name|force_64k_base
condition|?
name|rman_get_start
argument_list|(
name|res
argument_list|)
else|:
name|base
argument_list|,
name|limit
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Add the newly allocated region to the resource manager. */
if|if
condition|(
name|w
operator|->
name|base
operator|!=
name|base
condition|)
block|{
name|error
operator|=
name|rman_manage_region
argument_list|(
operator|&
name|w
operator|->
name|rman
argument_list|,
name|base
argument_list|,
name|w
operator|->
name|base
operator|-
literal|1
argument_list|)
expr_stmt|;
name|w
operator|->
name|base
operator|=
name|base
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|rman_manage_region
argument_list|(
operator|&
name|w
operator|->
name|rman
argument_list|,
name|w
operator|->
name|limit
operator|+
literal|1
argument_list|,
name|limit
argument_list|)
expr_stmt|;
name|w
operator|->
name|limit
operator|=
name|limit
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to expand %s resource manager\n"
argument_list|,
name|w
operator|->
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bus_adjust_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|type
argument_list|,
name|res
argument_list|,
name|force_64k_base
condition|?
name|rman_get_start
argument_list|(
name|res
argument_list|)
else|:
name|w
operator|->
name|base
argument_list|,
name|w
operator|->
name|limit
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attempt to grow a window to make room for a given resource request.  */
end_comment

begin_function
specifier|static
name|int
name|pcib_grow_window
parameter_list|(
name|struct
name|pcib_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|pcib_window
modifier|*
name|w
parameter_list|,
name|int
name|type
parameter_list|,
name|rman_res_t
name|start
parameter_list|,
name|rman_res_t
name|end
parameter_list|,
name|rman_res_t
name|count
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|rman_res_t
name|align
decl_stmt|,
name|start_free
decl_stmt|,
name|end_free
decl_stmt|,
name|front
decl_stmt|,
name|back
decl_stmt|,
name|wmask
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Clamp the desired resource range to the maximum address 	 * this window supports.  Reject impossible requests. 	 * 	 * For I/O port requests behind a bridge with the ISA enable 	 * bit set, force large allocations to start above 64k. 	 */
if|if
condition|(
operator|!
name|w
operator|->
name|valid
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|bridgectl
operator|&
name|PCIB_BCR_ISA_ENABLE
operator|&&
name|count
operator|>
literal|0x100
operator|&&
name|start
operator|<
literal|65536
condition|)
name|start
operator|=
literal|65536
expr_stmt|;
if|if
condition|(
name|end
operator|>
name|w
operator|->
name|rman
operator|.
name|rm_end
condition|)
name|end
operator|=
name|w
operator|->
name|rman
operator|.
name|rm_end
expr_stmt|;
if|if
condition|(
name|start
operator|+
name|count
operator|-
literal|1
operator|>
name|end
operator|||
name|start
operator|+
name|count
operator|<
name|start
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|wmask
operator|=
operator|(
operator|(
name|rman_res_t
operator|)
literal|1
operator|<<
name|w
operator|->
name|step
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* 	 * If there is no resource at all, just try to allocate enough 	 * aligned space for this resource. 	 */
if|if
condition|(
name|w
operator|->
name|res
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|pcib_alloc_new_window
argument_list|(
name|sc
argument_list|,
name|w
argument_list|,
name|type
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to allocate initial %s window (%#jx-%#jx,%#jx)\n"
argument_list|,
name|w
operator|->
name|name
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"allocated initial %s window of %#jx-%#jx\n"
argument_list|,
name|w
operator|->
name|name
argument_list|,
operator|(
name|uintmax_t
operator|)
name|w
operator|->
name|base
argument_list|,
operator|(
name|uintmax_t
operator|)
name|w
operator|->
name|limit
argument_list|)
expr_stmt|;
goto|goto
name|updatewin
goto|;
block|}
comment|/* 	 * See if growing the window would help.  Compute the minimum 	 * amount of address space needed on both the front and back 	 * ends of the existing window to satisfy the allocation. 	 * 	 * For each end, build a candidate region adjusting for the 	 * required alignment, etc.  If there is a free region at the 	 * edge of the window, grow from the inner edge of the free 	 * region.  Otherwise grow from the window boundary. 	 * 	 * Growing an I/O window below 64k for a bridge with the ISA 	 * enable bit doesn't require any special magic as the step 	 * size of an I/O window (1k) always includes multiple 	 * non-alias ranges when it is grown in either direction. 	 * 	 * XXX: Special case: if w->res is completely empty and the 	 * request size is larger than w->res, we should find the 	 * optimal aligned buffer containing w->res and allocate that. 	 */
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"attempting to grow %s window for (%#jx-%#jx,%#jx)\n"
argument_list|,
name|w
operator|->
name|name
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|align
operator|=
operator|(
name|rman_res_t
operator|)
literal|1
operator|<<
name|RF_ALIGNMENT
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|<
name|w
operator|->
name|base
condition|)
block|{
if|if
condition|(
name|rman_first_free_region
argument_list|(
operator|&
name|w
operator|->
name|rman
argument_list|,
operator|&
name|start_free
argument_list|,
operator|&
name|end_free
argument_list|)
operator|!=
literal|0
operator|||
name|start_free
operator|!=
name|w
operator|->
name|base
condition|)
name|end_free
operator|=
name|w
operator|->
name|base
expr_stmt|;
if|if
condition|(
name|end_free
operator|>
name|end
condition|)
name|end_free
operator|=
name|end
operator|+
literal|1
expr_stmt|;
comment|/* Move end_free down until it is properly aligned. */
name|end_free
operator|&=
operator|~
operator|(
name|align
operator|-
literal|1
operator|)
expr_stmt|;
name|end_free
operator|--
expr_stmt|;
name|front
operator|=
name|end_free
operator|-
operator|(
name|count
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* 		 * The resource would now be allocated at (front, 		 * end_free).  Ensure that fits in the (start, end) 		 * bounds.  end_free is checked above.  If 'front' is 		 * ok, ensure it is properly aligned for this window. 		 * Also check for underflow. 		 */
if|if
condition|(
name|front
operator|>=
name|start
operator|&&
name|front
operator|<=
name|end_free
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"\tfront candidate range: %#jx-%#jx\n"
argument_list|,
name|front
argument_list|,
name|end_free
argument_list|)
expr_stmt|;
name|front
operator|&=
operator|~
name|wmask
expr_stmt|;
name|front
operator|=
name|w
operator|->
name|base
operator|-
name|front
expr_stmt|;
block|}
else|else
name|front
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|front
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|end
operator|>
name|w
operator|->
name|limit
condition|)
block|{
if|if
condition|(
name|rman_last_free_region
argument_list|(
operator|&
name|w
operator|->
name|rman
argument_list|,
operator|&
name|start_free
argument_list|,
operator|&
name|end_free
argument_list|)
operator|!=
literal|0
operator|||
name|end_free
operator|!=
name|w
operator|->
name|limit
condition|)
name|start_free
operator|=
name|w
operator|->
name|limit
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|start_free
operator|<
name|start
condition|)
name|start_free
operator|=
name|start
expr_stmt|;
comment|/* Move start_free up until it is properly aligned. */
name|start_free
operator|=
name|roundup2
argument_list|(
name|start_free
argument_list|,
name|align
argument_list|)
expr_stmt|;
name|back
operator|=
name|start_free
operator|+
name|count
operator|-
literal|1
expr_stmt|;
comment|/* 		 * The resource would now be allocated at (start_free, 		 * back).  Ensure that fits in the (start, end) 		 * bounds.  start_free is checked above.  If 'back' is 		 * ok, ensure it is properly aligned for this window. 		 * Also check for overflow. 		 */
if|if
condition|(
name|back
operator|<=
name|end
operator|&&
name|start_free
operator|<=
name|back
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"\tback candidate range: %#jx-%#jx\n"
argument_list|,
name|start_free
argument_list|,
name|back
argument_list|)
expr_stmt|;
name|back
operator||=
name|wmask
expr_stmt|;
name|back
operator|-=
name|w
operator|->
name|limit
expr_stmt|;
block|}
else|else
name|back
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|back
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Try to allocate the smallest needed region first. 	 * If that fails, fall back to the other region. 	 */
name|error
operator|=
name|ENOSPC
expr_stmt|;
while|while
condition|(
name|front
operator|!=
literal|0
operator|||
name|back
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|front
operator|!=
literal|0
operator|&&
operator|(
name|front
operator|<=
name|back
operator|||
name|back
operator|==
literal|0
operator|)
condition|)
block|{
name|error
operator|=
name|pcib_expand_window
argument_list|(
name|sc
argument_list|,
name|w
argument_list|,
name|type
argument_list|,
name|w
operator|->
name|base
operator|-
name|front
argument_list|,
name|w
operator|->
name|limit
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
break|break;
name|front
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|pcib_expand_window
argument_list|(
name|sc
argument_list|,
name|w
argument_list|,
name|type
argument_list|,
name|w
operator|->
name|base
argument_list|,
name|w
operator|->
name|limit
operator|+
name|back
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
break|break;
name|back
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"grew %s window to %#jx-%#jx\n"
argument_list|,
name|w
operator|->
name|name
argument_list|,
operator|(
name|uintmax_t
operator|)
name|w
operator|->
name|base
argument_list|,
operator|(
name|uintmax_t
operator|)
name|w
operator|->
name|limit
argument_list|)
expr_stmt|;
name|updatewin
label|:
comment|/* Write the new window. */
name|KASSERT
argument_list|(
operator|(
name|w
operator|->
name|base
operator|&
name|wmask
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"start address is not aligned"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|w
operator|->
name|limit
operator|&
name|wmask
operator|)
operator|==
name|wmask
argument_list|,
operator|(
literal|"end address is not aligned"
operator|)
argument_list|)
expr_stmt|;
name|pcib_write_windows
argument_list|(
name|sc
argument_list|,
name|w
operator|->
name|mask
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We have to trap resource allocation requests and ensure that the bridge  * is set up to, or capable of handling them.  */
end_comment

begin_function
name|struct
name|resource
modifier|*
name|pcib_alloc_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|rid
parameter_list|,
name|rman_res_t
name|start
parameter_list|,
name|rman_res_t
name|end
parameter_list|,
name|rman_res_t
name|count
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|struct
name|pcib_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|resource
modifier|*
name|r
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * VGA resources are decoded iff the VGA enable bit is set in 	 * the bridge control register.  VGA resources do not fall into 	 * the resource windows and are passed up to the parent. 	 */
if|if
condition|(
operator|(
name|type
operator|==
name|SYS_RES_IOPORT
operator|&&
name|pci_is_vga_ioport_range
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
operator|)
operator|||
operator|(
name|type
operator|==
name|SYS_RES_MEMORY
operator|&&
name|pci_is_vga_memory_range
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|bridgectl
operator|&
name|PCIB_BCR_VGA_ENABLE
condition|)
return|return
operator|(
name|bus_generic_alloc_resource
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|NULL
operator|)
return|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
ifdef|#
directive|ifdef
name|PCI_RES_BUS
case|case
name|PCI_RES_BUS
case|:
return|return
operator|(
name|pcib_alloc_subbus
argument_list|(
operator|&
name|sc
operator|->
name|bus
argument_list|,
name|child
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
operator|)
return|;
endif|#
directive|endif
case|case
name|SYS_RES_IOPORT
case|:
if|if
condition|(
name|pcib_is_isa_range
argument_list|(
name|sc
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|r
operator|=
name|pcib_suballoc_resource
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|io
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|NULL
operator|||
operator|(
name|sc
operator|->
name|flags
operator|&
name|PCIB_SUBTRACTIVE
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|pcib_grow_window
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|io
argument_list|,
name|type
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
operator|==
literal|0
condition|)
name|r
operator|=
name|pcib_suballoc_resource
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|io
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYS_RES_MEMORY
case|:
comment|/* 		 * For prefetchable resources, prefer the prefetchable 		 * memory window, but fall back to the regular memory 		 * window if that fails.  Try both windows before 		 * attempting to grow a window in case the firmware 		 * has used a range in the regular memory window to 		 * map a prefetchable BAR. 		 */
if|if
condition|(
name|flags
operator|&
name|RF_PREFETCHABLE
condition|)
block|{
name|r
operator|=
name|pcib_suballoc_resource
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|pmem
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|NULL
condition|)
break|break;
block|}
name|r
operator|=
name|pcib_suballoc_resource
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|NULL
operator|||
operator|(
name|sc
operator|->
name|flags
operator|&
name|PCIB_SUBTRACTIVE
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|flags
operator|&
name|RF_PREFETCHABLE
condition|)
block|{
if|if
condition|(
name|pcib_grow_window
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|pmem
argument_list|,
name|type
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
operator|==
literal|0
condition|)
block|{
name|r
operator|=
name|pcib_suballoc_resource
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|pmem
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|NULL
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|pcib_grow_window
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|type
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
operator|&
operator|~
name|RF_PREFETCHABLE
argument_list|)
operator|==
literal|0
condition|)
name|r
operator|=
name|pcib_suballoc_resource
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|bus_generic_alloc_resource
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * If attempts to suballocate from the window fail but this is a 	 * subtractive bridge, pass the request up the tree. 	 */
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|PCIB_SUBTRACTIVE
operator|&&
name|r
operator|==
name|NULL
condition|)
return|return
operator|(
name|bus_generic_alloc_resource
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
operator|)
return|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcib_adjust_resource
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|,
name|rman_res_t
name|start
parameter_list|,
name|rman_res_t
name|end
parameter_list|)
block|{
name|struct
name|pcib_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|bus
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcib_is_resource_managed
argument_list|(
name|sc
argument_list|,
name|type
argument_list|,
name|r
argument_list|)
condition|)
return|return
operator|(
name|rman_adjust_resource
argument_list|(
name|r
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
operator|)
return|;
return|return
operator|(
name|bus_generic_adjust_resource
argument_list|(
name|bus
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|r
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcib_release_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
block|{
name|struct
name|pcib_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcib_is_resource_managed
argument_list|(
name|sc
argument_list|,
name|type
argument_list|,
name|r
argument_list|)
condition|)
block|{
if|if
condition|(
name|rman_get_flags
argument_list|(
name|r
argument_list|)
operator|&
name|RF_ACTIVE
condition|)
block|{
name|error
operator|=
name|bus_deactivate_resource
argument_list|(
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
name|rman_release_resource
argument_list|(
name|r
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|bus_generic_release_resource
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*  * We have to trap resource allocation requests and ensure that the bridge  * is set up to, or capable of handling them.  */
end_comment

begin_function
name|struct
name|resource
modifier|*
name|pcib_alloc_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|rid
parameter_list|,
name|rman_res_t
name|start
parameter_list|,
name|rman_res_t
name|end
parameter_list|,
name|rman_res_t
name|count
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|struct
name|pcib_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|suffix
decl_stmt|;
name|int
name|ok
decl_stmt|;
comment|/* 	 * Fail the allocation for this range if it's not supported. 	 */
name|name
operator|=
name|device_get_nameunit
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|name
operator|=
literal|""
expr_stmt|;
name|suffix
operator|=
literal|""
expr_stmt|;
block|}
else|else
name|suffix
operator|=
literal|" "
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SYS_RES_IOPORT
case|:
name|ok
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|pcib_is_io_open
argument_list|(
name|sc
argument_list|)
condition|)
break|break;
name|ok
operator|=
operator|(
name|start
operator|>=
name|sc
operator|->
name|iobase
operator|&&
name|end
operator|<=
name|sc
operator|->
name|iolimit
operator|)
expr_stmt|;
comment|/* 		 * Make sure we allow access to VGA I/O addresses when the 		 * bridge has the "VGA Enable" bit set. 		 */
if|if
condition|(
operator|!
name|ok
operator|&&
name|pci_is_vga_ioport_range
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
condition|)
name|ok
operator|=
operator|(
name|sc
operator|->
name|bridgectl
operator|&
name|PCIB_BCR_VGA_ENABLE
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|flags
operator|&
name|PCIB_SUBTRACTIVE
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|ok
condition|)
block|{
if|if
condition|(
name|start
operator|<
name|sc
operator|->
name|iobase
condition|)
name|start
operator|=
name|sc
operator|->
name|iobase
expr_stmt|;
if|if
condition|(
name|end
operator|>
name|sc
operator|->
name|iolimit
condition|)
name|end
operator|=
name|sc
operator|->
name|iolimit
expr_stmt|;
if|if
condition|(
name|start
operator|<
name|end
condition|)
name|ok
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|ok
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 			 * If we overlap with the subtractive range, then 			 * pick the upper range to use. 			 */
block|if (start< sc->iolimit&& end> sc->iobase) 				start = sc->iolimit + 1;
endif|#
directive|endif
block|}
if|if
condition|(
name|end
operator|<
name|start
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ioport: end (%jx)< start (%jx)\n"
argument_list|,
name|end
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|start
operator|=
literal|0
expr_stmt|;
name|end
operator|=
literal|0
expr_stmt|;
name|ok
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s%srequested unsupported I/O "
literal|"range 0x%jx-0x%jx (decoding 0x%x-0x%x)\n"
argument_list|,
name|name
argument_list|,
name|suffix
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|sc
operator|->
name|iobase
argument_list|,
name|sc
operator|->
name|iolimit
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s%srequested I/O range 0x%jx-0x%jx: in range\n"
argument_list|,
name|name
argument_list|,
name|suffix
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYS_RES_MEMORY
case|:
name|ok
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pcib_is_nonprefetch_open
argument_list|(
name|sc
argument_list|)
condition|)
name|ok
operator|=
name|ok
operator|||
operator|(
name|start
operator|>=
name|sc
operator|->
name|membase
operator|&&
name|end
operator|<=
name|sc
operator|->
name|memlimit
operator|)
expr_stmt|;
if|if
condition|(
name|pcib_is_prefetch_open
argument_list|(
name|sc
argument_list|)
condition|)
name|ok
operator|=
name|ok
operator|||
operator|(
name|start
operator|>=
name|sc
operator|->
name|pmembase
operator|&&
name|end
operator|<=
name|sc
operator|->
name|pmemlimit
operator|)
expr_stmt|;
comment|/* 		 * Make sure we allow access to VGA memory addresses when the 		 * bridge has the "VGA Enable" bit set. 		 */
if|if
condition|(
operator|!
name|ok
operator|&&
name|pci_is_vga_memory_range
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
condition|)
name|ok
operator|=
operator|(
name|sc
operator|->
name|bridgectl
operator|&
name|PCIB_BCR_VGA_ENABLE
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|flags
operator|&
name|PCIB_SUBTRACTIVE
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|ok
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|RF_PREFETCHABLE
condition|)
block|{
if|if
condition|(
name|pcib_is_prefetch_open
argument_list|(
name|sc
argument_list|)
condition|)
block|{
if|if
condition|(
name|start
operator|<
name|sc
operator|->
name|pmembase
condition|)
name|start
operator|=
name|sc
operator|->
name|pmembase
expr_stmt|;
if|if
condition|(
name|end
operator|>
name|sc
operator|->
name|pmemlimit
condition|)
name|end
operator|=
name|sc
operator|->
name|pmemlimit
expr_stmt|;
block|}
else|else
block|{
name|ok
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* non-prefetchable */
if|if
condition|(
name|pcib_is_nonprefetch_open
argument_list|(
name|sc
argument_list|)
condition|)
block|{
if|if
condition|(
name|start
operator|<
name|sc
operator|->
name|membase
condition|)
name|start
operator|=
name|sc
operator|->
name|membase
expr_stmt|;
if|if
condition|(
name|end
operator|>
name|sc
operator|->
name|memlimit
condition|)
name|end
operator|=
name|sc
operator|->
name|memlimit
expr_stmt|;
block|}
else|else
block|{
name|ok
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|ok
operator|=
literal|1
expr_stmt|;
comment|/* subtractive bridge: always ok */
if|#
directive|if
literal|0
block|if (pcib_is_nonprefetch_open(sc)) { 				if (start< sc->memlimit&& end> sc->membase) 					start = sc->memlimit + 1; 			} 			if (pcib_is_prefetch_open(sc)) { 				if (start< sc->pmemlimit&& end> sc->pmembase) 					start = sc->pmemlimit + 1; 			}
endif|#
directive|endif
block|}
if|if
condition|(
name|end
operator|<
name|start
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"memory: end (%jx)< start (%jx)\n"
argument_list|,
name|end
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|start
operator|=
literal|0
expr_stmt|;
name|end
operator|=
literal|0
expr_stmt|;
name|ok
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ok
operator|&&
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s%srequested unsupported memory range %#jx-%#jx "
literal|"(decoding %#jx-%#jx, %#jx-%#jx)\n"
argument_list|,
name|name
argument_list|,
name|suffix
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sc
operator|->
name|membase
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sc
operator|->
name|memlimit
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sc
operator|->
name|pmembase
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sc
operator|->
name|pmemlimit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s%srequested memory range "
literal|"0x%jx-0x%jx: good\n"
argument_list|,
name|name
argument_list|,
name|suffix
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* 	 * Bridge is OK decoding this resource, so pass it up. 	 */
return|return
operator|(
name|bus_generic_alloc_resource
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * If ARI is enabled on this downstream port, translate the function number  * to the non-ARI slot/function.  The downstream port will convert it back in  * hardware.  If ARI is not enabled slot and func are not modified.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|pcib_xlate_ari
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|int
name|bus
parameter_list|,
name|int
modifier|*
name|slot
parameter_list|,
name|int
modifier|*
name|func
parameter_list|)
block|{
name|struct
name|pcib_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|ari_func
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|pcib
argument_list|)
expr_stmt|;
name|ari_func
operator|=
operator|*
name|func
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|PCIB_ENABLE_ARI
condition|)
block|{
name|KASSERT
argument_list|(
operator|*
name|slot
operator|==
literal|0
argument_list|,
operator|(
literal|"Non-zero slot number with ARI enabled!"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|slot
operator|=
name|PCIE_ARI_SLOT
argument_list|(
name|ari_func
argument_list|)
expr_stmt|;
operator|*
name|func
operator|=
name|PCIE_ARI_FUNC
argument_list|(
name|ari_func
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pcib_enable_ari
parameter_list|(
name|struct
name|pcib_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|pcie_pos
parameter_list|)
block|{
name|uint32_t
name|ctl2
decl_stmt|;
name|ctl2
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|pcie_pos
operator|+
name|PCIER_DEVICE_CTL2
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ctl2
operator||=
name|PCIEM_CTL2_ARI
expr_stmt|;
name|pci_write_config
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|pcie_pos
operator|+
name|PCIER_DEVICE_CTL2
argument_list|,
name|ctl2
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator||=
name|PCIB_ENABLE_ARI
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * PCIB interface.  */
end_comment

begin_function
name|int
name|pcib_maxslots
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
name|PCI_SLOTMAX
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcib_ari_maxslots
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|pcib_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|PCIB_ENABLE_ARI
condition|)
return|return
operator|(
name|PCIE_ARI_SLOTMAX
operator|)
return|;
else|else
return|return
operator|(
name|PCI_SLOTMAX
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcib_ari_maxfuncs
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|pcib_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|PCIB_ENABLE_ARI
condition|)
return|return
operator|(
name|PCIE_ARI_FUNCMAX
operator|)
return|;
else|else
return|return
operator|(
name|PCI_FUNCMAX
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pcib_ari_decode_rid
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|uint16_t
name|rid
parameter_list|,
name|int
modifier|*
name|bus
parameter_list|,
name|int
modifier|*
name|slot
parameter_list|,
name|int
modifier|*
name|func
parameter_list|)
block|{
name|struct
name|pcib_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|pcib
argument_list|)
expr_stmt|;
operator|*
name|bus
operator|=
name|PCI_RID2BUS
argument_list|(
name|rid
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|PCIB_ENABLE_ARI
condition|)
block|{
operator|*
name|slot
operator|=
name|PCIE_ARI_RID2SLOT
argument_list|(
name|rid
argument_list|)
expr_stmt|;
operator|*
name|func
operator|=
name|PCIE_ARI_RID2FUNC
argument_list|(
name|rid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|slot
operator|=
name|PCI_RID2SLOT
argument_list|(
name|rid
argument_list|)
expr_stmt|;
operator|*
name|func
operator|=
name|PCI_RID2FUNC
argument_list|(
name|rid
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Since we are a child of a PCI bus, its parent must support the pcib interface.  */
end_comment

begin_function
specifier|static
name|uint32_t
name|pcib_read_config
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|b
parameter_list|,
name|u_int
name|s
parameter_list|,
name|u_int
name|f
parameter_list|,
name|u_int
name|reg
parameter_list|,
name|int
name|width
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PCI_HP
name|struct
name|pcib_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pcib_present
argument_list|(
name|sc
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|width
condition|)
block|{
case|case
literal|2
case|:
return|return
operator|(
literal|0xffff
operator|)
return|;
case|case
literal|1
case|:
return|return
operator|(
literal|0xff
operator|)
return|;
default|default:
return|return
operator|(
literal|0xffffffff
operator|)
return|;
block|}
block|}
endif|#
directive|endif
name|pcib_xlate_ari
argument_list|(
name|dev
argument_list|,
name|b
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCIB_READ_CONFIG
argument_list|(
name|device_get_parent
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|reg
argument_list|,
name|width
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pcib_write_config
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|b
parameter_list|,
name|u_int
name|s
parameter_list|,
name|u_int
name|f
parameter_list|,
name|u_int
name|reg
parameter_list|,
name|uint32_t
name|val
parameter_list|,
name|int
name|width
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PCI_HP
name|struct
name|pcib_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pcib_present
argument_list|(
name|sc
argument_list|)
condition|)
return|return;
endif|#
directive|endif
name|pcib_xlate_ari
argument_list|(
name|dev
argument_list|,
name|b
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|f
argument_list|)
expr_stmt|;
name|PCIB_WRITE_CONFIG
argument_list|(
name|device_get_parent
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|reg
argument_list|,
name|val
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Route an interrupt across a PCI bridge.  */
end_comment

begin_function
name|int
name|pcib_route_interrupt
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|int
name|pin
parameter_list|)
block|{
name|device_t
name|bus
decl_stmt|;
name|int
name|parent_intpin
decl_stmt|;
name|int
name|intnum
decl_stmt|;
comment|/*      *      * The PCI standard defines a swizzle of the child-side device/intpin to      * the parent-side intpin as follows.      *      * device = device on child bus      * child_intpin = intpin on child bus slot (0-3)      * parent_intpin = intpin on parent bus slot (0-3)      *      * parent_intpin = (device + child_intpin) % 4      */
name|parent_intpin
operator|=
operator|(
name|pci_get_slot
argument_list|(
name|dev
argument_list|)
operator|+
operator|(
name|pin
operator|-
literal|1
operator|)
operator|)
operator|%
literal|4
expr_stmt|;
comment|/*      * Our parent is a PCI bus.  Its parent must export the pcib interface      * which includes the ability to route interrupts.      */
name|bus
operator|=
name|device_get_parent
argument_list|(
name|pcib
argument_list|)
expr_stmt|;
name|intnum
operator|=
name|PCIB_ROUTE_INTERRUPT
argument_list|(
name|device_get_parent
argument_list|(
name|bus
argument_list|)
argument_list|,
name|pcib
argument_list|,
name|parent_intpin
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|PCI_INTERRUPT_VALID
argument_list|(
name|intnum
argument_list|)
operator|&&
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|pcib
argument_list|,
literal|"slot %d INT%c is routed to irq %d\n"
argument_list|,
name|pci_get_slot
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|'A'
operator|+
name|pin
operator|-
literal|1
argument_list|,
name|intnum
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|intnum
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Pass request to alloc MSI/MSI-X messages up to the parent bridge. */
end_comment

begin_function
name|int
name|pcib_alloc_msi
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|maxcount
parameter_list|,
name|int
modifier|*
name|irqs
parameter_list|)
block|{
name|struct
name|pcib_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|pcib
argument_list|)
decl_stmt|;
name|device_t
name|bus
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|PCIB_DISABLE_MSI
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|bus
operator|=
name|device_get_parent
argument_list|(
name|pcib
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCIB_ALLOC_MSI
argument_list|(
name|device_get_parent
argument_list|(
name|bus
argument_list|)
argument_list|,
name|dev
argument_list|,
name|count
argument_list|,
name|maxcount
argument_list|,
name|irqs
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Pass request to release MSI/MSI-X messages up to the parent bridge. */
end_comment

begin_function
name|int
name|pcib_release_msi
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|int
name|count
parameter_list|,
name|int
modifier|*
name|irqs
parameter_list|)
block|{
name|device_t
name|bus
decl_stmt|;
name|bus
operator|=
name|device_get_parent
argument_list|(
name|pcib
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCIB_RELEASE_MSI
argument_list|(
name|device_get_parent
argument_list|(
name|bus
argument_list|)
argument_list|,
name|dev
argument_list|,
name|count
argument_list|,
name|irqs
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Pass request to alloc an MSI-X message up to the parent bridge. */
end_comment

begin_function
name|int
name|pcib_alloc_msix
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|int
modifier|*
name|irq
parameter_list|)
block|{
name|struct
name|pcib_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|pcib
argument_list|)
decl_stmt|;
name|device_t
name|bus
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|PCIB_DISABLE_MSIX
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|bus
operator|=
name|device_get_parent
argument_list|(
name|pcib
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCIB_ALLOC_MSIX
argument_list|(
name|device_get_parent
argument_list|(
name|bus
argument_list|)
argument_list|,
name|dev
argument_list|,
name|irq
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Pass request to release an MSI-X message up to the parent bridge. */
end_comment

begin_function
name|int
name|pcib_release_msix
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|int
name|irq
parameter_list|)
block|{
name|device_t
name|bus
decl_stmt|;
name|bus
operator|=
name|device_get_parent
argument_list|(
name|pcib
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCIB_RELEASE_MSIX
argument_list|(
name|device_get_parent
argument_list|(
name|bus
argument_list|)
argument_list|,
name|dev
argument_list|,
name|irq
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Pass request to map MSI/MSI-X message up to parent bridge. */
end_comment

begin_function
name|int
name|pcib_map_msi
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|int
name|irq
parameter_list|,
name|uint64_t
modifier|*
name|addr
parameter_list|,
name|uint32_t
modifier|*
name|data
parameter_list|)
block|{
name|device_t
name|bus
decl_stmt|;
name|int
name|error
decl_stmt|;
name|bus
operator|=
name|device_get_parent
argument_list|(
name|pcib
argument_list|)
expr_stmt|;
name|error
operator|=
name|PCIB_MAP_MSI
argument_list|(
name|device_get_parent
argument_list|(
name|bus
argument_list|)
argument_list|,
name|dev
argument_list|,
name|irq
argument_list|,
name|addr
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|pci_ht_map_msi
argument_list|(
name|pcib
argument_list|,
operator|*
name|addr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Pass request for device power state up to parent bridge. */
end_comment

begin_function
name|int
name|pcib_power_for_sleep
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|int
modifier|*
name|pstate
parameter_list|)
block|{
name|device_t
name|bus
decl_stmt|;
name|bus
operator|=
name|device_get_parent
argument_list|(
name|pcib
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCIB_POWER_FOR_SLEEP
argument_list|(
name|bus
argument_list|,
name|dev
argument_list|,
name|pstate
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcib_ari_enabled
parameter_list|(
name|device_t
name|pcib
parameter_list|)
block|{
name|struct
name|pcib_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|pcib
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|sc
operator|->
name|flags
operator|&
name|PCIB_ENABLE_ARI
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcib_ari_get_id
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|enum
name|pci_id_type
name|type
parameter_list|,
name|uintptr_t
modifier|*
name|id
parameter_list|)
block|{
name|struct
name|pcib_softc
modifier|*
name|sc
decl_stmt|;
name|device_t
name|bus_dev
decl_stmt|;
name|uint8_t
name|bus
decl_stmt|,
name|slot
decl_stmt|,
name|func
decl_stmt|;
if|if
condition|(
name|type
operator|!=
name|PCI_ID_RID
condition|)
block|{
name|bus_dev
operator|=
name|device_get_parent
argument_list|(
name|pcib
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCIB_GET_ID
argument_list|(
name|device_get_parent
argument_list|(
name|bus_dev
argument_list|)
argument_list|,
name|dev
argument_list|,
name|type
argument_list|,
name|id
argument_list|)
operator|)
return|;
block|}
name|sc
operator|=
name|device_get_softc
argument_list|(
name|pcib
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|PCIB_ENABLE_ARI
condition|)
block|{
name|bus
operator|=
name|pci_get_bus
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|func
operator|=
name|pci_get_function
argument_list|(
name|dev
argument_list|)
expr_stmt|;
operator|*
name|id
operator|=
operator|(
name|PCI_ARI_RID
argument_list|(
name|bus
argument_list|,
name|func
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|bus
operator|=
name|pci_get_bus
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|slot
operator|=
name|pci_get_slot
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|func
operator|=
name|pci_get_function
argument_list|(
name|dev
argument_list|)
expr_stmt|;
operator|*
name|id
operator|=
operator|(
name|PCI_RID
argument_list|(
name|bus
argument_list|,
name|slot
argument_list|,
name|func
argument_list|)
operator|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check that the downstream port (pcib) and the endpoint device (dev) both  * support ARI.  If so, enable it and return 0, otherwise return an error.  */
end_comment

begin_function
specifier|static
name|int
name|pcib_try_enable_ari
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|pcib_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint32_t
name|cap2
decl_stmt|;
name|int
name|ari_cap_off
decl_stmt|;
name|uint32_t
name|ari_ver
decl_stmt|;
name|uint32_t
name|pcie_pos
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|pcib
argument_list|)
expr_stmt|;
comment|/* 	 * ARI is controlled in a register in the PCIe capability structure. 	 * If the downstream port does not have the PCIe capability structure 	 * then it does not support ARI. 	 */
name|error
operator|=
name|pci_find_cap
argument_list|(
name|pcib
argument_list|,
name|PCIY_EXPRESS
argument_list|,
operator|&
name|pcie_pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
comment|/* Check that the PCIe port advertises ARI support. */
name|cap2
operator|=
name|pci_read_config
argument_list|(
name|pcib
argument_list|,
name|pcie_pos
operator|+
name|PCIER_DEVICE_CAP2
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cap2
operator|&
name|PCIEM_CAP2_ARI
operator|)
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
comment|/* 	 * Check that the endpoint device advertises ARI support via the ARI 	 * extended capability structure. 	 */
name|error
operator|=
name|pci_find_extcap
argument_list|(
name|dev
argument_list|,
name|PCIZ_ARI
argument_list|,
operator|&
name|ari_cap_off
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
comment|/* 	 * Finally, check that the endpoint device supports the same version 	 * of ARI that we do. 	 */
name|ari_ver
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|ari_cap_off
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|PCI_EXTCAP_VER
argument_list|(
name|ari_ver
argument_list|)
operator|!=
name|PCIB_SUPPORTED_ARI_VER
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|pcib
argument_list|,
literal|"Unsupported version of ARI (%d) detected\n"
argument_list|,
name|PCI_EXTCAP_VER
argument_list|(
name|ari_ver
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|pcib_enable_ari
argument_list|(
name|sc
argument_list|,
name|pcie_pos
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcib_request_feature_allow
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|enum
name|pci_feature
name|feature
parameter_list|)
block|{
comment|/* 	 * No host firmware we have to negotiate with, so we allow 	 * every valid feature requested. 	 */
switch|switch
condition|(
name|feature
condition|)
block|{
case|case
name|PCI_FEATURE_AER
case|:
case|case
name|PCI_FEATURE_HP
case|:
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcib_request_feature
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|enum
name|pci_feature
name|feature
parameter_list|)
block|{
comment|/* 	 * Invoke PCIB_REQUEST_FEATURE of this bridge first in case 	 * the firmware overrides the method of PCI-PCI bridges. 	 */
return|return
operator|(
name|PCIB_REQUEST_FEATURE
argument_list|(
name|dev
argument_list|,
name|dev
argument_list|,
name|feature
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Pass the request to use this PCI feature up the tree. Either there's a  * firmware like ACPI that's using this feature that will approve (or deny) the  * request to take it over, or the platform has no such firmware, in which case  * the request will be approved. If the request is approved, the OS is expected  * to make use of the feature or render it harmless.  */
end_comment

begin_function
specifier|static
name|int
name|pcib_request_feature_default
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|enum
name|pci_feature
name|feature
parameter_list|)
block|{
name|device_t
name|bus
decl_stmt|;
comment|/* 	 * Our parent is necessarily a pci bus. Its parent will either be 	 * another pci bridge (which passes it up) or a host bridge that can 	 * approve or reject the request. 	 */
name|bus
operator|=
name|device_get_parent
argument_list|(
name|pcib
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCIB_REQUEST_FEATURE
argument_list|(
name|device_get_parent
argument_list|(
name|bus
argument_list|)
argument_list|,
name|dev
argument_list|,
name|feature
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

