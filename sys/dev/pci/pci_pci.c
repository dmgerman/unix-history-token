begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1994,1995 Stefan Esser, Wolfgang StanglMeier  * Copyright (c) 2000 Michael Smith<msmith@freebsd.org>  * Copyright (c) 2000 BSDi  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * PCI:PCI bridge support.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pci_private.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcib_private.h>
end_include

begin_include
include|#
directive|include
file|"pcib_if.h"
end_include

begin_function_decl
specifier|static
name|int
name|pcib_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcib_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcib_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcib_power_for_sleep
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|int
modifier|*
name|pstate
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|pcib_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|pcib_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|pcib_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|bus_generic_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bus_generic_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|pcib_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|pcib_resume
argument_list|)
block|,
comment|/* Bus interface */
name|DEVMETHOD
argument_list|(
name|bus_read_ivar
argument_list|,
name|pcib_read_ivar
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_write_ivar
argument_list|,
name|pcib_write_ivar
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_alloc_resource
argument_list|,
name|pcib_alloc_resource
argument_list|)
block|,
ifdef|#
directive|ifdef
name|NEW_PCIB
name|DEVMETHOD
argument_list|(
name|bus_adjust_resource
argument_list|,
name|pcib_adjust_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_release_resource
argument_list|,
name|pcib_release_resource
argument_list|)
block|,
else|#
directive|else
name|DEVMETHOD
argument_list|(
name|bus_adjust_resource
argument_list|,
name|bus_generic_adjust_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_release_resource
argument_list|,
name|bus_generic_release_resource
argument_list|)
block|,
endif|#
directive|endif
name|DEVMETHOD
argument_list|(
name|bus_activate_resource
argument_list|,
name|bus_generic_activate_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_deactivate_resource
argument_list|,
name|bus_generic_deactivate_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_setup_intr
argument_list|,
name|bus_generic_setup_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_teardown_intr
argument_list|,
name|bus_generic_teardown_intr
argument_list|)
block|,
comment|/* pcib interface */
name|DEVMETHOD
argument_list|(
name|pcib_maxslots
argument_list|,
name|pcib_maxslots
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pcib_read_config
argument_list|,
name|pcib_read_config
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pcib_write_config
argument_list|,
name|pcib_write_config
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pcib_route_interrupt
argument_list|,
name|pcib_route_interrupt
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pcib_alloc_msi
argument_list|,
name|pcib_alloc_msi
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pcib_release_msi
argument_list|,
name|pcib_release_msi
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pcib_alloc_msix
argument_list|,
name|pcib_alloc_msix
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pcib_release_msix
argument_list|,
name|pcib_release_msix
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pcib_map_msi
argument_list|,
name|pcib_map_msi
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pcib_power_for_sleep
argument_list|,
name|pcib_power_for_sleep
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|pcib_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DEFINE_CLASS_0
argument_list|(
name|pcib
argument_list|,
name|pcib_driver
argument_list|,
name|pcib_methods
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pcib_softc
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|pcib
argument_list|,
name|pci
argument_list|,
name|pcib_driver
argument_list|,
name|pcib_devclass
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|NEW_PCIB
end_ifdef

begin_comment
comment|/*  * XXX Todo:  * - properly handle the ISA enable bit.  If it is set, we should change  *   the behavior of the I/O window resource and rman to not allocate the  *   blocked ranges (upper 768 bytes of each 1K in the first 64k of the  *   I/O port address space).  */
end_comment

begin_comment
comment|/*  * Is a resource from a child device sub-allocated from one of our  * resource managers?  */
end_comment

begin_function
specifier|static
name|int
name|pcib_is_resource_managed
parameter_list|(
name|struct
name|pcib_softc
modifier|*
name|sc
parameter_list|,
name|int
name|type
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SYS_RES_IOPORT
case|:
return|return
operator|(
name|rman_is_region_manager
argument_list|(
name|r
argument_list|,
operator|&
name|sc
operator|->
name|io
operator|.
name|rman
argument_list|)
operator|)
return|;
case|case
name|SYS_RES_MEMORY
case|:
comment|/* Prefetchable resources may live in either memory rman. */
if|if
condition|(
name|rman_get_flags
argument_list|(
name|r
argument_list|)
operator|&
name|RF_PREFETCHABLE
operator|&&
name|rman_is_region_manager
argument_list|(
name|r
argument_list|,
operator|&
name|sc
operator|->
name|pmem
operator|.
name|rman
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
name|rman_is_region_manager
argument_list|(
name|r
argument_list|,
operator|&
name|sc
operator|->
name|mem
operator|.
name|rman
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcib_is_window_open
parameter_list|(
name|struct
name|pcib_window
modifier|*
name|pw
parameter_list|)
block|{
return|return
operator|(
name|pw
operator|->
name|valid
operator|&&
name|pw
operator|->
name|base
operator|<
name|pw
operator|->
name|limit
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * XXX: If RF_ACTIVE did not also imply allocating a bus space tag and  * handle for the resource, we could pass RF_ACTIVE up to the PCI bus  * when allocating the resource windows and rely on the PCI bus driver  * to do this for us.  */
end_comment

begin_function
specifier|static
name|void
name|pcib_activate_window
parameter_list|(
name|struct
name|pcib_softc
modifier|*
name|sc
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|PCI_ENABLE_IO
argument_list|(
name|device_get_parent
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|sc
operator|->
name|dev
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pcib_write_windows
parameter_list|(
name|struct
name|pcib_softc
modifier|*
name|sc
parameter_list|,
name|int
name|mask
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|io
operator|.
name|valid
operator|&&
name|mask
operator|&
name|WIN_IO
condition|)
block|{
name|val
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_IOBASEL_1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|PCIM_BRIO_MASK
operator|)
operator|==
name|PCIM_BRIO_32
condition|)
block|{
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_IOBASEH_1
argument_list|,
name|sc
operator|->
name|io
operator|.
name|base
operator|>>
literal|16
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_IOLIMITH_1
argument_list|,
name|sc
operator|->
name|io
operator|.
name|limit
operator|>>
literal|16
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_IOBASEL_1
argument_list|,
name|sc
operator|->
name|io
operator|.
name|base
operator|>>
literal|8
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_IOLIMITL_1
argument_list|,
name|sc
operator|->
name|io
operator|.
name|limit
operator|>>
literal|8
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|WIN_MEM
condition|)
block|{
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_MEMBASE_1
argument_list|,
name|sc
operator|->
name|mem
operator|.
name|base
operator|>>
literal|16
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_MEMLIMIT_1
argument_list|,
name|sc
operator|->
name|mem
operator|.
name|limit
operator|>>
literal|16
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|pmem
operator|.
name|valid
operator|&&
name|mask
operator|&
name|WIN_PMEM
condition|)
block|{
name|val
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PMBASEL_1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|PCIM_BRPM_MASK
operator|)
operator|==
name|PCIM_BRPM_64
condition|)
block|{
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PMBASEH_1
argument_list|,
name|sc
operator|->
name|pmem
operator|.
name|base
operator|>>
literal|32
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PMLIMITH_1
argument_list|,
name|sc
operator|->
name|pmem
operator|.
name|limit
operator|>>
literal|32
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PMBASEL_1
argument_list|,
name|sc
operator|->
name|pmem
operator|.
name|base
operator|>>
literal|16
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PMLIMITL_1
argument_list|,
name|sc
operator|->
name|pmem
operator|.
name|limit
operator|>>
literal|16
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pcib_alloc_window
parameter_list|(
name|struct
name|pcib_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|pcib_window
modifier|*
name|w
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|flags
parameter_list|,
name|pci_addr_t
name|max_address
parameter_list|)
block|{
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|int
name|error
decl_stmt|,
name|rid
decl_stmt|;
if|if
condition|(
name|max_address
operator|!=
operator|(
name|u_long
operator|)
name|max_address
condition|)
name|max_address
operator|=
operator|~
literal|0ul
expr_stmt|;
name|w
operator|->
name|rman
operator|.
name|rm_start
operator|=
literal|0
expr_stmt|;
name|w
operator|->
name|rman
operator|.
name|rm_end
operator|=
name|max_address
expr_stmt|;
name|w
operator|->
name|rman
operator|.
name|rm_type
operator|=
name|RMAN_ARRAY
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s %s window"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|w
operator|->
name|name
argument_list|)
expr_stmt|;
name|w
operator|->
name|rman
operator|.
name|rm_descr
operator|=
name|strdup
argument_list|(
name|buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|error
operator|=
name|rman_init
argument_list|(
operator|&
name|w
operator|->
name|rman
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|panic
argument_list|(
literal|"Failed to initialize %s %s rman"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|w
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pcib_is_window_open
argument_list|(
name|w
argument_list|)
condition|)
return|return;
if|if
condition|(
name|w
operator|->
name|base
operator|>
name|max_address
operator|||
name|w
operator|->
name|limit
operator|>
name|max_address
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"initial %s window has too many bits, ignoring\n"
argument_list|,
name|w
operator|->
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
name|rid
operator|=
name|w
operator|->
name|reg
expr_stmt|;
name|w
operator|->
name|res
operator|=
name|bus_alloc_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|type
argument_list|,
operator|&
name|rid
argument_list|,
name|w
operator|->
name|base
argument_list|,
name|w
operator|->
name|limit
argument_list|,
name|w
operator|->
name|limit
operator|-
name|w
operator|->
name|base
operator|+
literal|1
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to allocate initial %s window: %#jx-%#jx\n"
argument_list|,
name|w
operator|->
name|name
argument_list|,
operator|(
name|uintmax_t
operator|)
name|w
operator|->
name|base
argument_list|,
operator|(
name|uintmax_t
operator|)
name|w
operator|->
name|limit
argument_list|)
expr_stmt|;
name|w
operator|->
name|base
operator|=
name|max_address
expr_stmt|;
name|w
operator|->
name|limit
operator|=
literal|0
expr_stmt|;
name|pcib_write_windows
argument_list|(
name|sc
argument_list|,
name|w
operator|->
name|mask
argument_list|)
expr_stmt|;
return|return;
block|}
name|pcib_activate_window
argument_list|(
name|sc
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|error
operator|=
name|rman_manage_region
argument_list|(
operator|&
name|w
operator|->
name|rman
argument_list|,
name|rman_get_start
argument_list|(
name|w
operator|->
name|res
argument_list|)
argument_list|,
name|rman_get_end
argument_list|(
name|w
operator|->
name|res
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|panic
argument_list|(
literal|"Failed to initialize rman with resource"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize I/O windows.  */
end_comment

begin_function
specifier|static
name|void
name|pcib_probe_windows
parameter_list|(
name|struct
name|pcib_softc
modifier|*
name|sc
parameter_list|)
block|{
name|pci_addr_t
name|max
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
comment|/* Determine if the I/O port window is implemented. */
name|val
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_IOBASEL_1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
block|{
comment|/* 		 * If 'val' is zero, then only 16-bits of I/O space 		 * are supported. 		 */
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_IOBASEL_1
argument_list|,
literal|0xff
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_IOBASEL_1
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|io
operator|.
name|valid
operator|=
literal|1
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_IOBASEL_1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|sc
operator|->
name|io
operator|.
name|valid
operator|=
literal|1
expr_stmt|;
comment|/* Read the existing I/O port window. */
if|if
condition|(
name|sc
operator|->
name|io
operator|.
name|valid
condition|)
block|{
name|sc
operator|->
name|io
operator|.
name|reg
operator|=
name|PCIR_IOBASEL_1
expr_stmt|;
name|sc
operator|->
name|io
operator|.
name|step
operator|=
literal|12
expr_stmt|;
name|sc
operator|->
name|io
operator|.
name|mask
operator|=
name|WIN_IO
expr_stmt|;
name|sc
operator|->
name|io
operator|.
name|name
operator|=
literal|"I/O port"
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|PCIM_BRIO_MASK
operator|)
operator|==
name|PCIM_BRIO_32
condition|)
block|{
name|sc
operator|->
name|io
operator|.
name|base
operator|=
name|PCI_PPBIOBASE
argument_list|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_IOBASEH_1
argument_list|,
literal|2
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|sc
operator|->
name|io
operator|.
name|limit
operator|=
name|PCI_PPBIOLIMIT
argument_list|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_IOLIMITH_1
argument_list|,
literal|2
argument_list|)
argument_list|,
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_IOLIMITL_1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|max
operator|=
literal|0xffffffff
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|io
operator|.
name|base
operator|=
name|PCI_PPBIOBASE
argument_list|(
literal|0
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|sc
operator|->
name|io
operator|.
name|limit
operator|=
name|PCI_PPBIOLIMIT
argument_list|(
literal|0
argument_list|,
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_IOLIMITL_1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|max
operator|=
literal|0xffff
expr_stmt|;
block|}
name|pcib_alloc_window
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|io
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|0
argument_list|,
name|max
argument_list|)
expr_stmt|;
block|}
comment|/* Read the existing memory window. */
name|sc
operator|->
name|mem
operator|.
name|valid
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|mem
operator|.
name|reg
operator|=
name|PCIR_MEMBASE_1
expr_stmt|;
name|sc
operator|->
name|mem
operator|.
name|step
operator|=
literal|20
expr_stmt|;
name|sc
operator|->
name|mem
operator|.
name|mask
operator|=
name|WIN_MEM
expr_stmt|;
name|sc
operator|->
name|mem
operator|.
name|name
operator|=
literal|"memory"
expr_stmt|;
name|sc
operator|->
name|mem
operator|.
name|base
operator|=
name|PCI_PPBMEMBASE
argument_list|(
literal|0
argument_list|,
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_MEMBASE_1
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mem
operator|.
name|limit
operator|=
name|PCI_PPBMEMLIMIT
argument_list|(
literal|0
argument_list|,
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_MEMLIMIT_1
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|pcib_alloc_window
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
comment|/* Determine if the prefetchable memory window is implemented. */
name|val
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PMBASEL_1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
block|{
comment|/* 		 * If 'val' is zero, then only 32-bits of memory space 		 * are supported. 		 */
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PMBASEL_1
argument_list|,
literal|0xffff
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PMBASEL_1
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|pmem
operator|.
name|valid
operator|=
literal|1
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PMBASEL_1
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|sc
operator|->
name|pmem
operator|.
name|valid
operator|=
literal|1
expr_stmt|;
comment|/* Read the existing prefetchable memory window. */
if|if
condition|(
name|sc
operator|->
name|pmem
operator|.
name|valid
condition|)
block|{
name|sc
operator|->
name|pmem
operator|.
name|reg
operator|=
name|PCIR_PMBASEL_1
expr_stmt|;
name|sc
operator|->
name|pmem
operator|.
name|step
operator|=
literal|20
expr_stmt|;
name|sc
operator|->
name|pmem
operator|.
name|mask
operator|=
name|WIN_PMEM
expr_stmt|;
name|sc
operator|->
name|pmem
operator|.
name|name
operator|=
literal|"prefetch"
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|PCIM_BRPM_MASK
operator|)
operator|==
name|PCIM_BRPM_64
condition|)
block|{
name|sc
operator|->
name|pmem
operator|.
name|base
operator|=
name|PCI_PPBMEMBASE
argument_list|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PMBASEH_1
argument_list|,
literal|4
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|sc
operator|->
name|pmem
operator|.
name|limit
operator|=
name|PCI_PPBMEMLIMIT
argument_list|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PMLIMITH_1
argument_list|,
literal|4
argument_list|)
argument_list|,
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PMLIMITL_1
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|max
operator|=
literal|0xffffffffffffffff
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|pmem
operator|.
name|base
operator|=
name|PCI_PPBMEMBASE
argument_list|(
literal|0
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|sc
operator|->
name|pmem
operator|.
name|limit
operator|=
name|PCI_PPBMEMLIMIT
argument_list|(
literal|0
argument_list|,
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PMLIMITL_1
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|max
operator|=
literal|0xffffffff
expr_stmt|;
block|}
name|pcib_alloc_window
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|pmem
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|RF_PREFETCHABLE
argument_list|,
name|max
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*  * Is the prefetch window open (eg, can we allocate memory in it?)  */
end_comment

begin_function
specifier|static
name|int
name|pcib_is_prefetch_open
parameter_list|(
name|struct
name|pcib_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
name|sc
operator|->
name|pmembase
operator|>
literal|0
operator|&&
name|sc
operator|->
name|pmembase
operator|<
name|sc
operator|->
name|pmemlimit
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Is the nonprefetch window open (eg, can we allocate memory in it?)  */
end_comment

begin_function
specifier|static
name|int
name|pcib_is_nonprefetch_open
parameter_list|(
name|struct
name|pcib_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
name|sc
operator|->
name|membase
operator|>
literal|0
operator|&&
name|sc
operator|->
name|membase
operator|<
name|sc
operator|->
name|memlimit
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Is the io window open (eg, can we allocate ports in it?)  */
end_comment

begin_function
specifier|static
name|int
name|pcib_is_io_open
parameter_list|(
name|struct
name|pcib_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
name|sc
operator|->
name|iobase
operator|>
literal|0
operator|&&
name|sc
operator|->
name|iobase
operator|<
name|sc
operator|->
name|iolimit
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get current I/O decode.  */
end_comment

begin_function
specifier|static
name|void
name|pcib_get_io_decode
parameter_list|(
name|struct
name|pcib_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|uint32_t
name|iolow
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
name|iolow
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_IOBASEL_1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|iolow
operator|&
name|PCIM_BRIO_MASK
operator|)
operator|==
name|PCIM_BRIO_32
condition|)
name|sc
operator|->
name|iobase
operator|=
name|PCI_PPBIOBASE
argument_list|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_IOBASEH_1
argument_list|,
literal|2
argument_list|)
argument_list|,
name|iolow
argument_list|)
expr_stmt|;
else|else
name|sc
operator|->
name|iobase
operator|=
name|PCI_PPBIOBASE
argument_list|(
literal|0
argument_list|,
name|iolow
argument_list|)
expr_stmt|;
name|iolow
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_IOLIMITL_1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|iolow
operator|&
name|PCIM_BRIO_MASK
operator|)
operator|==
name|PCIM_BRIO_32
condition|)
name|sc
operator|->
name|iolimit
operator|=
name|PCI_PPBIOLIMIT
argument_list|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_IOLIMITH_1
argument_list|,
literal|2
argument_list|)
argument_list|,
name|iolow
argument_list|)
expr_stmt|;
else|else
name|sc
operator|->
name|iolimit
operator|=
name|PCI_PPBIOLIMIT
argument_list|(
literal|0
argument_list|,
name|iolow
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get current memory decode.  */
end_comment

begin_function
specifier|static
name|void
name|pcib_get_mem_decode
parameter_list|(
name|struct
name|pcib_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|pci_addr_t
name|pmemlow
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
name|sc
operator|->
name|membase
operator|=
name|PCI_PPBMEMBASE
argument_list|(
literal|0
argument_list|,
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_MEMBASE_1
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|memlimit
operator|=
name|PCI_PPBMEMLIMIT
argument_list|(
literal|0
argument_list|,
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_MEMLIMIT_1
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|pmemlow
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PMBASEL_1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pmemlow
operator|&
name|PCIM_BRPM_MASK
operator|)
operator|==
name|PCIM_BRPM_64
condition|)
name|sc
operator|->
name|pmembase
operator|=
name|PCI_PPBMEMBASE
argument_list|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PMBASEH_1
argument_list|,
literal|4
argument_list|)
argument_list|,
name|pmemlow
argument_list|)
expr_stmt|;
else|else
name|sc
operator|->
name|pmembase
operator|=
name|PCI_PPBMEMBASE
argument_list|(
literal|0
argument_list|,
name|pmemlow
argument_list|)
expr_stmt|;
name|pmemlow
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PMLIMITL_1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pmemlow
operator|&
name|PCIM_BRPM_MASK
operator|)
operator|==
name|PCIM_BRPM_64
condition|)
name|sc
operator|->
name|pmemlimit
operator|=
name|PCI_PPBMEMLIMIT
argument_list|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PMLIMITH_1
argument_list|,
literal|4
argument_list|)
argument_list|,
name|pmemlow
argument_list|)
expr_stmt|;
else|else
name|sc
operator|->
name|pmemlimit
operator|=
name|PCI_PPBMEMLIMIT
argument_list|(
literal|0
argument_list|,
name|pmemlow
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Restore previous I/O decode.  */
end_comment

begin_function
specifier|static
name|void
name|pcib_set_io_decode
parameter_list|(
name|struct
name|pcib_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|uint32_t
name|iohi
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
name|iohi
operator|=
name|sc
operator|->
name|iobase
operator|>>
literal|16
expr_stmt|;
if|if
condition|(
name|iohi
operator|>
literal|0
condition|)
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_IOBASEH_1
argument_list|,
name|iohi
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_IOBASEL_1
argument_list|,
name|sc
operator|->
name|iobase
operator|>>
literal|8
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|iohi
operator|=
name|sc
operator|->
name|iolimit
operator|>>
literal|16
expr_stmt|;
if|if
condition|(
name|iohi
operator|>
literal|0
condition|)
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_IOLIMITH_1
argument_list|,
name|iohi
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_IOLIMITL_1
argument_list|,
name|sc
operator|->
name|iolimit
operator|>>
literal|8
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Restore previous memory decode.  */
end_comment

begin_function
specifier|static
name|void
name|pcib_set_mem_decode
parameter_list|(
name|struct
name|pcib_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|pci_addr_t
name|pmemhi
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_MEMBASE_1
argument_list|,
name|sc
operator|->
name|membase
operator|>>
literal|16
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_MEMLIMIT_1
argument_list|,
name|sc
operator|->
name|memlimit
operator|>>
literal|16
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pmemhi
operator|=
name|sc
operator|->
name|pmembase
operator|>>
literal|32
expr_stmt|;
if|if
condition|(
name|pmemhi
operator|>
literal|0
condition|)
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PMBASEH_1
argument_list|,
name|pmemhi
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PMBASEL_1
argument_list|,
name|sc
operator|->
name|pmembase
operator|>>
literal|16
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pmemhi
operator|=
name|sc
operator|->
name|pmemlimit
operator|>>
literal|32
expr_stmt|;
if|if
condition|(
name|pmemhi
operator|>
literal|0
condition|)
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PMLIMITH_1
argument_list|,
name|pmemhi
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PMLIMITL_1
argument_list|,
name|sc
operator|->
name|pmemlimit
operator|>>
literal|16
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Get current bridge configuration.  */
end_comment

begin_function
specifier|static
name|void
name|pcib_cfg_save
parameter_list|(
name|struct
name|pcib_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
name|sc
operator|->
name|command
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|->
name|pribus
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PRIBUS_1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|secbus
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SECBUS_1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|subbus
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SUBBUS_1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bridgectl
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_BRIDGECTL_1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|->
name|seclat
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SECLAT_1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NEW_PCIB
if|if
condition|(
name|sc
operator|->
name|command
operator|&
name|PCIM_CMD_PORTEN
condition|)
name|pcib_get_io_decode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|command
operator|&
name|PCIM_CMD_MEMEN
condition|)
name|pcib_get_mem_decode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Restore previous bridge configuration.  */
end_comment

begin_function
specifier|static
name|void
name|pcib_cfg_restore
parameter_list|(
name|struct
name|pcib_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|sc
operator|->
name|command
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PRIBUS_1
argument_list|,
name|sc
operator|->
name|pribus
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SECBUS_1
argument_list|,
name|sc
operator|->
name|secbus
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SUBBUS_1
argument_list|,
name|sc
operator|->
name|subbus
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_BRIDGECTL_1
argument_list|,
name|sc
operator|->
name|bridgectl
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SECLAT_1
argument_list|,
name|sc
operator|->
name|seclat
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NEW_PCIB
name|pcib_write_windows
argument_list|(
name|sc
argument_list|,
name|WIN_IO
operator||
name|WIN_MEM
operator||
name|WIN_PMEM
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|sc
operator|->
name|command
operator|&
name|PCIM_CMD_PORTEN
condition|)
name|pcib_set_io_decode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|command
operator|&
name|PCIM_CMD_MEMEN
condition|)
name|pcib_set_mem_decode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Generic device interface  */
end_comment

begin_function
specifier|static
name|int
name|pcib_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
operator|(
name|pci_get_class
argument_list|(
name|dev
argument_list|)
operator|==
name|PCIC_BRIDGE
operator|)
operator|&&
operator|(
name|pci_get_subclass
argument_list|(
name|dev
argument_list|)
operator|==
name|PCIS_BRIDGE_PCI
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"PCI-PCI bridge"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|10000
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pcib_attach_common
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|pcib_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|sysctl_ctx_list
modifier|*
name|sctx
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|soid
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
comment|/*      * Get current bridge configuration.      */
name|sc
operator|->
name|domain
operator|=
name|pci_get_domain
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|secstat
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SECSTAT_1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pcib_cfg_save
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*      * Setup sysctl reporting nodes      */
name|sctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|soid
operator|=
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|sctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|soid
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"domain"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|domain
argument_list|,
literal|0
argument_list|,
literal|"Domain number"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|sctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|soid
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"pribus"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|pribus
argument_list|,
literal|0
argument_list|,
literal|"Primary bus number"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|sctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|soid
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"secbus"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|secbus
argument_list|,
literal|0
argument_list|,
literal|"Secondary bus number"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|sctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|soid
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"subbus"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|subbus
argument_list|,
literal|0
argument_list|,
literal|"Subordinate bus number"
argument_list|)
expr_stmt|;
comment|/*      * Quirk handling.      */
switch|switch
condition|(
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
condition|)
block|{
case|case
literal|0x12258086
case|:
comment|/* Intel 82454KX/GX (Orion) */
block|{
name|uint8_t
name|supbus
decl_stmt|;
name|supbus
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
literal|0x41
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|supbus
operator|!=
literal|0xff
condition|)
block|{
name|sc
operator|->
name|secbus
operator|=
name|supbus
operator|+
literal|1
expr_stmt|;
name|sc
operator|->
name|subbus
operator|=
name|supbus
operator|+
literal|1
expr_stmt|;
block|}
break|break;
block|}
comment|/*      * The i82380FB mobile docking controller is a PCI-PCI bridge,      * and it is a subtractive bridge.  However, the ProgIf is wrong      * so the normal setting of PCIB_SUBTRACTIVE bit doesn't      * happen.  There's also a Toshiba bridge that behaves this      * way.      */
case|case
literal|0x124b8086
case|:
comment|/* Intel 82380FB Mobile */
case|case
literal|0x060513d7
case|:
comment|/* Toshiba ???? */
name|sc
operator|->
name|flags
operator||=
name|PCIB_SUBTRACTIVE
expr_stmt|;
break|break;
comment|/* Compaq R3000 BIOS sets wrong subordinate bus number. */
case|case
literal|0x00dd10de
case|:
block|{
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"smbios.planar.maker"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"Compal"
argument_list|,
literal|6
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|freeenv
argument_list|(
name|cp
argument_list|)
expr_stmt|;
break|break;
block|}
name|freeenv
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"smbios.planar.product"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"08A0"
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|freeenv
argument_list|(
name|cp
argument_list|)
expr_stmt|;
break|break;
block|}
name|freeenv
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|subbus
operator|<
literal|0xa
condition|)
block|{
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SUBBUS_1
argument_list|,
literal|0xa
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|subbus
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SUBBUS_1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|pci_msi_device_blacklisted
argument_list|(
name|dev
argument_list|)
condition|)
name|sc
operator|->
name|flags
operator||=
name|PCIB_DISABLE_MSI
expr_stmt|;
if|if
condition|(
name|pci_msix_device_blacklisted
argument_list|(
name|dev
argument_list|)
condition|)
name|sc
operator|->
name|flags
operator||=
name|PCIB_DISABLE_MSIX
expr_stmt|;
comment|/*      * Intel 815, 845 and other chipsets say they are PCI-PCI bridges,      * but have a ProgIF of 0x80.  The 82801 family (AA, AB, BAM/CAM,      * BA/CA/DB and E) PCI bridges are HUB-PCI bridges, in Intelese.      * This means they act as if they were subtractively decoding      * bridges and pass all transactions.  Mark them and real ProgIf 1      * parts as subtractive.      */
if|if
condition|(
operator|(
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
operator|&
literal|0xff00ffff
operator|)
operator|==
literal|0x24008086
operator|||
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_PROGIF
argument_list|,
literal|1
argument_list|)
operator|==
name|PCIP_BRIDGE_PCI_SUBTRACTIVE
condition|)
name|sc
operator|->
name|flags
operator||=
name|PCIB_SUBTRACTIVE
expr_stmt|;
ifdef|#
directive|ifdef
name|NEW_PCIB
name|pcib_probe_windows
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"  domain            %d\n"
argument_list|,
name|sc
operator|->
name|domain
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"  secondary bus     %d\n"
argument_list|,
name|sc
operator|->
name|secbus
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"  subordinate bus   %d\n"
argument_list|,
name|sc
operator|->
name|subbus
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NEW_PCIB
if|if
condition|(
name|pcib_is_window_open
argument_list|(
operator|&
name|sc
operator|->
name|io
argument_list|)
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"  I/O decode        0x%jx-0x%jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sc
operator|->
name|io
operator|.
name|base
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sc
operator|->
name|io
operator|.
name|limit
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcib_is_window_open
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|)
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"  memory decode     0x%jx-0x%jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sc
operator|->
name|mem
operator|.
name|base
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sc
operator|->
name|mem
operator|.
name|limit
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcib_is_window_open
argument_list|(
operator|&
name|sc
operator|->
name|pmem
argument_list|)
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"  prefetched decode 0x%jx-0x%jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sc
operator|->
name|pmem
operator|.
name|base
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sc
operator|->
name|pmem
operator|.
name|limit
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|pcib_is_io_open
argument_list|(
name|sc
argument_list|)
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"  I/O decode        0x%x-0x%x\n"
argument_list|,
name|sc
operator|->
name|iobase
argument_list|,
name|sc
operator|->
name|iolimit
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcib_is_nonprefetch_open
argument_list|(
name|sc
argument_list|)
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"  memory decode     0x%jx-0x%jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sc
operator|->
name|membase
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sc
operator|->
name|memlimit
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcib_is_prefetch_open
argument_list|(
name|sc
argument_list|)
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"  prefetched decode 0x%jx-0x%jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sc
operator|->
name|pmembase
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sc
operator|->
name|pmemlimit
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|else
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"  no prefetched decode\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|PCIB_SUBTRACTIVE
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"  Subtractively decoded bridge.\n"
argument_list|)
expr_stmt|;
block|}
comment|/*      * XXX If the secondary bus number is zero, we should assign a bus number      *     since the BIOS hasn't, then initialise the bridge.  A simple      *     bus_alloc_resource with the a couple of busses seems like the right      *     approach, but we don't know what busses the BIOS might have already      *     assigned to other bridges on this bus that probe later than we do.      *      *     If the subordinate bus number is less than the secondary bus number,      *     we should pick a better value.  One sensible alternative would be to      *     pick 255; the only tradeoff here is that configuration transactions      *     would be more widely routed than absolutely necessary.  We could      *     then do a walk of the tree later and fix it.      */
comment|/*      * Always enable busmastering on bridges so that transactions      * initiated on the secondary bus are passed through to the      * primary bus.      */
name|pci_enable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pcib_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|pcib_softc
modifier|*
name|sc
decl_stmt|;
name|device_t
name|child
decl_stmt|;
name|pcib_attach_common
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|secbus
operator|!=
literal|0
condition|)
block|{
name|child
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"pci"
argument_list|,
name|sc
operator|->
name|secbus
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|!=
name|NULL
condition|)
return|return
operator|(
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
comment|/* no secondary bus; we should have fixed this */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcib_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_t
name|pcib
decl_stmt|;
name|int
name|dstate
decl_stmt|,
name|error
decl_stmt|;
name|pcib_cfg_save
argument_list|(
name|device_get_softc
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_generic_suspend
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|pci_do_power_suspend
condition|)
block|{
name|dstate
operator|=
name|PCI_POWERSTATE_D3
expr_stmt|;
name|pcib
operator|=
name|device_get_parent
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|PCIB_POWER_FOR_SLEEP
argument_list|(
name|pcib
argument_list|,
name|dev
argument_list|,
operator|&
name|dstate
argument_list|)
operator|==
literal|0
condition|)
name|pci_set_powerstate
argument_list|(
name|dev
argument_list|,
name|dstate
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcib_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_t
name|pcib
decl_stmt|;
if|if
condition|(
name|pci_do_power_resume
condition|)
block|{
name|pcib
operator|=
name|device_get_parent
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|PCIB_POWER_FOR_SLEEP
argument_list|(
name|pcib
argument_list|,
name|dev
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
name|pci_set_powerstate
argument_list|(
name|dev
argument_list|,
name|PCI_POWERSTATE_D0
argument_list|)
expr_stmt|;
block|}
name|pcib_cfg_restore
argument_list|(
name|device_get_softc
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|bus_generic_resume
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcib_read_ivar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|which
parameter_list|,
name|uintptr_t
modifier|*
name|result
parameter_list|)
block|{
name|struct
name|pcib_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|PCIB_IVAR_DOMAIN
case|:
operator|*
name|result
operator|=
name|sc
operator|->
name|domain
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|PCIB_IVAR_BUS
case|:
operator|*
name|result
operator|=
name|sc
operator|->
name|secbus
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcib_write_ivar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|which
parameter_list|,
name|uintptr_t
name|value
parameter_list|)
block|{
name|struct
name|pcib_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|PCIB_IVAR_DOMAIN
case|:
return|return
operator|(
name|EINVAL
operator|)
return|;
case|case
name|PCIB_IVAR_BUS
case|:
name|sc
operator|->
name|secbus
operator|=
name|value
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|NEW_PCIB
end_ifdef

begin_comment
comment|/*  * Attempt to allocate a resource from the existing resources assigned  * to a window.  */
end_comment

begin_function
specifier|static
name|struct
name|resource
modifier|*
name|pcib_suballoc_resource
parameter_list|(
name|struct
name|pcib_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|pcib_window
modifier|*
name|w
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|rid
parameter_list|,
name|u_long
name|start
parameter_list|,
name|u_long
name|end
parameter_list|,
name|u_long
name|count
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
if|if
condition|(
operator|!
name|pcib_is_window_open
argument_list|(
name|w
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|res
operator|=
name|rman_reserve_resource
argument_list|(
operator|&
name|w
operator|->
name|rman
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
operator|&
operator|~
name|RF_ACTIVE
argument_list|,
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"allocated %s range (%#lx-%#lx) for rid %x of %s\n"
argument_list|,
name|w
operator|->
name|name
argument_list|,
name|rman_get_start
argument_list|(
name|res
argument_list|)
argument_list|,
name|rman_get_end
argument_list|(
name|res
argument_list|)
argument_list|,
operator|*
name|rid
argument_list|,
name|pcib_child_name
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
name|rman_set_rid
argument_list|(
name|res
argument_list|,
operator|*
name|rid
argument_list|)
expr_stmt|;
comment|/* 	 * If the resource should be active, pass that request up the 	 * tree.  This assumes the parent drivers can handle 	 * activating sub-allocated resources. 	 */
if|if
condition|(
name|flags
operator|&
name|RF_ACTIVE
condition|)
block|{
if|if
condition|(
name|bus_activate_resource
argument_list|(
name|child
argument_list|,
name|type
argument_list|,
operator|*
name|rid
argument_list|,
name|res
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|rman_release_resource
argument_list|(
name|res
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attempt to grow a window to make room for a given resource request.  * The 'step' parameter is log_2 of the desired I/O window's alignment.  */
end_comment

begin_function
specifier|static
name|int
name|pcib_grow_window
parameter_list|(
name|struct
name|pcib_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|pcib_window
modifier|*
name|w
parameter_list|,
name|int
name|type
parameter_list|,
name|u_long
name|start
parameter_list|,
name|u_long
name|end
parameter_list|,
name|u_long
name|count
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|u_long
name|align
decl_stmt|,
name|start_free
decl_stmt|,
name|end_free
decl_stmt|,
name|front
decl_stmt|,
name|back
decl_stmt|,
name|wmask
decl_stmt|;
name|int
name|error
decl_stmt|,
name|rid
decl_stmt|;
comment|/* 	 * Clamp the desired resource range to the maximum address 	 * this window supports.  Reject impossible requests. 	 */
if|if
condition|(
operator|!
name|w
operator|->
name|valid
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|end
operator|>
name|w
operator|->
name|rman
operator|.
name|rm_end
condition|)
name|end
operator|=
name|w
operator|->
name|rman
operator|.
name|rm_end
expr_stmt|;
if|if
condition|(
name|start
operator|+
name|count
operator|-
literal|1
operator|>
name|end
operator|||
name|start
operator|+
name|count
operator|<
name|start
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|wmask
operator|=
operator|(
literal|1ul
operator|<<
name|w
operator|->
name|step
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* 	 * If there is no resource at all, just try to allocate enough 	 * aligned space for this resource. 	 */
if|if
condition|(
name|w
operator|->
name|res
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|RF_ALIGNMENT
argument_list|(
name|flags
argument_list|)
operator|<
name|w
operator|->
name|step
condition|)
block|{
name|flags
operator|&=
operator|~
name|RF_ALIGNMENT_MASK
expr_stmt|;
name|flags
operator||=
name|RF_ALIGNMENT_LOG2
argument_list|(
name|w
operator|->
name|step
argument_list|)
expr_stmt|;
block|}
name|start
operator|&=
operator|~
name|wmask
expr_stmt|;
name|end
operator||=
name|wmask
expr_stmt|;
name|count
operator|=
name|roundup2
argument_list|(
name|count
argument_list|,
literal|1ul
operator|<<
name|w
operator|->
name|step
argument_list|)
expr_stmt|;
name|rid
operator|=
name|w
operator|->
name|reg
expr_stmt|;
name|w
operator|->
name|res
operator|=
name|bus_alloc_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|type
argument_list|,
operator|&
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
operator|&
operator|~
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|res
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to allocate initial %s window (%#lx-%#lx,%#lx)\n"
argument_list|,
name|w
operator|->
name|name
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"allocated initial %s window of %#lx-%#lx\n"
argument_list|,
name|w
operator|->
name|name
argument_list|,
name|rman_get_start
argument_list|(
name|w
operator|->
name|res
argument_list|)
argument_list|,
name|rman_get_end
argument_list|(
name|w
operator|->
name|res
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|rman_manage_region
argument_list|(
operator|&
name|w
operator|->
name|rman
argument_list|,
name|rman_get_start
argument_list|(
name|w
operator|->
name|res
argument_list|)
argument_list|,
name|rman_get_end
argument_list|(
name|w
operator|->
name|res
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to add initial %s window to rman\n"
argument_list|,
name|w
operator|->
name|name
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|type
argument_list|,
name|w
operator|->
name|reg
argument_list|,
name|w
operator|->
name|res
argument_list|)
expr_stmt|;
name|w
operator|->
name|res
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|pcib_activate_window
argument_list|(
name|sc
argument_list|,
name|type
argument_list|)
expr_stmt|;
goto|goto
name|updatewin
goto|;
block|}
comment|/* 	 * See if growing the window would help.  Compute the minimum 	 * amount of address space needed on both the front and back 	 * ends of the existing window to satisfy the allocation. 	 * 	 * For each end, build a candidate region adjusting for the 	 * required alignment, etc.  If there is a free region at the 	 * edge of the window, grow from the inner edge of the free 	 * region.  Otherwise grow from the window boundary. 	 * 	 * XXX: Special case: if w->res is completely empty and the 	 * request size is larger than w->res, we should find the 	 * optimal aligned buffer containing w->res and allocate that. 	 */
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"attempting to grow %s window for (%#lx-%#lx,%#lx)\n"
argument_list|,
name|w
operator|->
name|name
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|align
operator|=
literal|1ul
operator|<<
name|RF_ALIGNMENT
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|<
name|rman_get_start
argument_list|(
name|w
operator|->
name|res
argument_list|)
condition|)
block|{
if|if
condition|(
name|rman_first_free_region
argument_list|(
operator|&
name|w
operator|->
name|rman
argument_list|,
operator|&
name|start_free
argument_list|,
operator|&
name|end_free
argument_list|)
operator|!=
literal|0
operator|||
name|start_free
operator|!=
name|rman_get_start
argument_list|(
name|w
operator|->
name|res
argument_list|)
condition|)
name|end_free
operator|=
name|rman_get_start
argument_list|(
name|w
operator|->
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|end_free
operator|>
name|end
condition|)
name|end_free
operator|=
name|end
operator|+
literal|1
expr_stmt|;
comment|/* Move end_free down until it is properly aligned. */
name|end_free
operator|&=
operator|~
operator|(
name|align
operator|-
literal|1
operator|)
expr_stmt|;
name|end_free
operator|--
expr_stmt|;
name|front
operator|=
name|end_free
operator|-
operator|(
name|count
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* 		 * The resource would now be allocated at (front, 		 * end_free).  Ensure that fits in the (start, end) 		 * bounds.  end_free is checked above.  If 'front' is 		 * ok, ensure it is properly aligned for this window. 		 * Also check for underflow. 		 */
if|if
condition|(
name|front
operator|>=
name|start
operator|&&
name|front
operator|<=
name|end_free
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"\tfront candidate range: %#lx-%#lx\n"
argument_list|,
name|front
argument_list|,
name|end_free
argument_list|)
expr_stmt|;
name|front
operator|&=
operator|~
name|wmask
expr_stmt|;
name|front
operator|=
name|rman_get_start
argument_list|(
name|w
operator|->
name|res
argument_list|)
operator|-
name|front
expr_stmt|;
block|}
else|else
name|front
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|front
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|end
operator|>
name|rman_get_end
argument_list|(
name|w
operator|->
name|res
argument_list|)
condition|)
block|{
if|if
condition|(
name|rman_last_free_region
argument_list|(
operator|&
name|w
operator|->
name|rman
argument_list|,
operator|&
name|start_free
argument_list|,
operator|&
name|end_free
argument_list|)
operator|!=
literal|0
operator|||
name|end_free
operator|!=
name|rman_get_end
argument_list|(
name|w
operator|->
name|res
argument_list|)
condition|)
name|start_free
operator|=
name|rman_get_end
argument_list|(
name|w
operator|->
name|res
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|start_free
operator|<
name|start
condition|)
name|start_free
operator|=
name|start
expr_stmt|;
comment|/* Move start_free up until it is properly aligned. */
name|start_free
operator|=
name|roundup2
argument_list|(
name|start_free
argument_list|,
name|align
argument_list|)
expr_stmt|;
name|back
operator|=
name|start_free
operator|+
name|count
operator|-
literal|1
expr_stmt|;
comment|/* 		 * The resource would now be allocated at (start_free, 		 * back).  Ensure that fits in the (start, end) 		 * bounds.  start_free is checked above.  If 'back' is 		 * ok, ensure it is properly aligned for this window. 		 * Also check for overflow. 		 */
if|if
condition|(
name|back
operator|<=
name|end
operator|&&
name|start_free
operator|<=
name|back
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"\tback candidate range: %#lx-%#lx\n"
argument_list|,
name|start_free
argument_list|,
name|back
argument_list|)
expr_stmt|;
name|back
operator||=
name|wmask
expr_stmt|;
name|back
operator|-=
name|rman_get_end
argument_list|(
name|w
operator|->
name|res
argument_list|)
expr_stmt|;
block|}
else|else
name|back
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|back
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Try to allocate the smallest needed region first. 	 * If that fails, fall back to the other region. 	 */
name|error
operator|=
name|ENOSPC
expr_stmt|;
while|while
condition|(
name|front
operator|!=
literal|0
operator|||
name|back
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|front
operator|!=
literal|0
operator|&&
operator|(
name|front
operator|<=
name|back
operator|||
name|back
operator|==
literal|0
operator|)
condition|)
block|{
name|error
operator|=
name|bus_adjust_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|type
argument_list|,
name|w
operator|->
name|res
argument_list|,
name|rman_get_start
argument_list|(
name|w
operator|->
name|res
argument_list|)
operator|-
name|front
argument_list|,
name|rman_get_end
argument_list|(
name|w
operator|->
name|res
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
break|break;
name|front
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|bus_adjust_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|type
argument_list|,
name|w
operator|->
name|res
argument_list|,
name|rman_get_start
argument_list|(
name|w
operator|->
name|res
argument_list|)
argument_list|,
name|rman_get_end
argument_list|(
name|w
operator|->
name|res
argument_list|)
operator|+
name|back
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
break|break;
name|back
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"grew %s window to %#lx-%#lx\n"
argument_list|,
name|w
operator|->
name|name
argument_list|,
name|rman_get_start
argument_list|(
name|w
operator|->
name|res
argument_list|)
argument_list|,
name|rman_get_end
argument_list|(
name|w
operator|->
name|res
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add the newly allocated region to the resource manager. */
if|if
condition|(
name|w
operator|->
name|base
operator|!=
name|rman_get_start
argument_list|(
name|w
operator|->
name|res
argument_list|)
condition|)
block|{
name|KASSERT
argument_list|(
name|w
operator|->
name|limit
operator|==
name|rman_get_end
argument_list|(
name|w
operator|->
name|res
argument_list|)
argument_list|,
operator|(
literal|"both ends moved"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|rman_manage_region
argument_list|(
operator|&
name|w
operator|->
name|rman
argument_list|,
name|rman_get_start
argument_list|(
name|w
operator|->
name|res
argument_list|)
argument_list|,
name|w
operator|->
name|base
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|KASSERT
argument_list|(
name|w
operator|->
name|limit
operator|!=
name|rman_get_end
argument_list|(
name|w
operator|->
name|res
argument_list|)
argument_list|,
operator|(
literal|"neither end moved"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|rman_manage_region
argument_list|(
operator|&
name|w
operator|->
name|rman
argument_list|,
name|w
operator|->
name|limit
operator|+
literal|1
argument_list|,
name|rman_get_end
argument_list|(
name|w
operator|->
name|res
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to expand %s resource manager\n"
argument_list|,
name|w
operator|->
name|name
argument_list|)
expr_stmt|;
name|bus_adjust_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|type
argument_list|,
name|w
operator|->
name|res
argument_list|,
name|w
operator|->
name|base
argument_list|,
name|w
operator|->
name|limit
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|updatewin
label|:
comment|/* Save the new window. */
name|w
operator|->
name|base
operator|=
name|rman_get_start
argument_list|(
name|w
operator|->
name|res
argument_list|)
expr_stmt|;
name|w
operator|->
name|limit
operator|=
name|rman_get_end
argument_list|(
name|w
operator|->
name|res
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|w
operator|->
name|base
operator|&
name|wmask
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"start address is not aligned"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|w
operator|->
name|limit
operator|&
name|wmask
operator|)
operator|==
name|wmask
argument_list|,
operator|(
literal|"end address is not aligned"
operator|)
argument_list|)
expr_stmt|;
name|pcib_write_windows
argument_list|(
name|sc
argument_list|,
name|w
operator|->
name|mask
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We have to trap resource allocation requests and ensure that the bridge  * is set up to, or capable of handling them.  */
end_comment

begin_function
name|struct
name|resource
modifier|*
name|pcib_alloc_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|rid
parameter_list|,
name|u_long
name|start
parameter_list|,
name|u_long
name|end
parameter_list|,
name|u_long
name|count
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|struct
name|pcib_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|resource
modifier|*
name|r
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * VGA resources are decoded iff the VGA enable bit is set in 	 * the bridge control register.  VGA resources do not fall into 	 * the resource windows and are passed up to the parent. 	 */
if|if
condition|(
operator|(
name|type
operator|==
name|SYS_RES_IOPORT
operator|&&
name|pci_is_vga_ioport_range
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
operator|)
operator|||
operator|(
name|type
operator|==
name|SYS_RES_MEMORY
operator|&&
name|pci_is_vga_memory_range
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|bridgectl
operator|&
name|PCIB_BCR_VGA_ENABLE
condition|)
return|return
operator|(
name|bus_generic_alloc_resource
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|NULL
operator|)
return|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SYS_RES_IOPORT
case|:
name|r
operator|=
name|pcib_suballoc_resource
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|io
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|NULL
operator|||
operator|(
name|sc
operator|->
name|flags
operator|&
name|PCIB_SUBTRACTIVE
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|pcib_grow_window
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|io
argument_list|,
name|type
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
operator|==
literal|0
condition|)
name|r
operator|=
name|pcib_suballoc_resource
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|io
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYS_RES_MEMORY
case|:
comment|/* 		 * For prefetchable resources, prefer the prefetchable 		 * memory window, but fall back to the regular memory 		 * window if that fails.  Try both windows before 		 * attempting to grow a window in case the firmware 		 * has used a range in the regular memory window to 		 * map a prefetchable BAR. 		 */
if|if
condition|(
name|flags
operator|&
name|RF_PREFETCHABLE
condition|)
block|{
name|r
operator|=
name|pcib_suballoc_resource
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|pmem
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|NULL
condition|)
break|break;
block|}
name|r
operator|=
name|pcib_suballoc_resource
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|NULL
operator|||
operator|(
name|sc
operator|->
name|flags
operator|&
name|PCIB_SUBTRACTIVE
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|flags
operator|&
name|RF_PREFETCHABLE
condition|)
block|{
if|if
condition|(
name|pcib_grow_window
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|pmem
argument_list|,
name|type
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
operator|==
literal|0
condition|)
block|{
name|r
operator|=
name|pcib_suballoc_resource
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|pmem
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|NULL
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|pcib_grow_window
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|type
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
operator|&
operator|~
name|RF_PREFETCHABLE
argument_list|)
operator|==
literal|0
condition|)
name|r
operator|=
name|pcib_suballoc_resource
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|bus_generic_alloc_resource
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * If attempts to suballocate from the window fail but this is a 	 * subtractive bridge, pass the request up the tree. 	 */
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|PCIB_SUBTRACTIVE
operator|&&
name|r
operator|==
name|NULL
condition|)
return|return
operator|(
name|bus_generic_alloc_resource
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
operator|)
return|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcib_adjust_resource
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|,
name|u_long
name|start
parameter_list|,
name|u_long
name|end
parameter_list|)
block|{
name|struct
name|pcib_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|bus
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcib_is_resource_managed
argument_list|(
name|sc
argument_list|,
name|type
argument_list|,
name|r
argument_list|)
condition|)
return|return
operator|(
name|rman_adjust_resource
argument_list|(
name|r
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
operator|)
return|;
return|return
operator|(
name|bus_generic_adjust_resource
argument_list|(
name|bus
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|r
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcib_release_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
block|{
name|struct
name|pcib_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcib_is_resource_managed
argument_list|(
name|sc
argument_list|,
name|type
argument_list|,
name|r
argument_list|)
condition|)
block|{
if|if
condition|(
name|rman_get_flags
argument_list|(
name|r
argument_list|)
operator|&
name|RF_ACTIVE
condition|)
block|{
name|error
operator|=
name|bus_deactivate_resource
argument_list|(
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
name|rman_release_resource
argument_list|(
name|r
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|bus_generic_release_resource
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*  * We have to trap resource allocation requests and ensure that the bridge  * is set up to, or capable of handling them.  */
end_comment

begin_function
name|struct
name|resource
modifier|*
name|pcib_alloc_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|rid
parameter_list|,
name|u_long
name|start
parameter_list|,
name|u_long
name|end
parameter_list|,
name|u_long
name|count
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|struct
name|pcib_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|suffix
decl_stmt|;
name|int
name|ok
decl_stmt|;
comment|/* 	 * Fail the allocation for this range if it's not supported. 	 */
name|name
operator|=
name|device_get_nameunit
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|name
operator|=
literal|""
expr_stmt|;
name|suffix
operator|=
literal|""
expr_stmt|;
block|}
else|else
name|suffix
operator|=
literal|" "
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SYS_RES_IOPORT
case|:
name|ok
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|pcib_is_io_open
argument_list|(
name|sc
argument_list|)
condition|)
break|break;
name|ok
operator|=
operator|(
name|start
operator|>=
name|sc
operator|->
name|iobase
operator|&&
name|end
operator|<=
name|sc
operator|->
name|iolimit
operator|)
expr_stmt|;
comment|/* 		 * Make sure we allow access to VGA I/O addresses when the 		 * bridge has the "VGA Enable" bit set. 		 */
if|if
condition|(
operator|!
name|ok
operator|&&
name|pci_is_vga_ioport_range
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
condition|)
name|ok
operator|=
operator|(
name|sc
operator|->
name|bridgectl
operator|&
name|PCIB_BCR_VGA_ENABLE
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|flags
operator|&
name|PCIB_SUBTRACTIVE
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|ok
condition|)
block|{
if|if
condition|(
name|start
operator|<
name|sc
operator|->
name|iobase
condition|)
name|start
operator|=
name|sc
operator|->
name|iobase
expr_stmt|;
if|if
condition|(
name|end
operator|>
name|sc
operator|->
name|iolimit
condition|)
name|end
operator|=
name|sc
operator|->
name|iolimit
expr_stmt|;
if|if
condition|(
name|start
operator|<
name|end
condition|)
name|ok
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|ok
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 			 * If we overlap with the subtractive range, then 			 * pick the upper range to use. 			 */
block|if (start< sc->iolimit&& end> sc->iobase) 				start = sc->iolimit + 1;
endif|#
directive|endif
block|}
if|if
condition|(
name|end
operator|<
name|start
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ioport: end (%lx)< start (%lx)\n"
argument_list|,
name|end
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|start
operator|=
literal|0
expr_stmt|;
name|end
operator|=
literal|0
expr_stmt|;
name|ok
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s%srequested unsupported I/O "
literal|"range 0x%lx-0x%lx (decoding 0x%x-0x%x)\n"
argument_list|,
name|name
argument_list|,
name|suffix
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|sc
operator|->
name|iobase
argument_list|,
name|sc
operator|->
name|iolimit
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s%srequested I/O range 0x%lx-0x%lx: in range\n"
argument_list|,
name|name
argument_list|,
name|suffix
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYS_RES_MEMORY
case|:
name|ok
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pcib_is_nonprefetch_open
argument_list|(
name|sc
argument_list|)
condition|)
name|ok
operator|=
name|ok
operator|||
operator|(
name|start
operator|>=
name|sc
operator|->
name|membase
operator|&&
name|end
operator|<=
name|sc
operator|->
name|memlimit
operator|)
expr_stmt|;
if|if
condition|(
name|pcib_is_prefetch_open
argument_list|(
name|sc
argument_list|)
condition|)
name|ok
operator|=
name|ok
operator|||
operator|(
name|start
operator|>=
name|sc
operator|->
name|pmembase
operator|&&
name|end
operator|<=
name|sc
operator|->
name|pmemlimit
operator|)
expr_stmt|;
comment|/* 		 * Make sure we allow access to VGA memory addresses when the 		 * bridge has the "VGA Enable" bit set. 		 */
if|if
condition|(
operator|!
name|ok
operator|&&
name|pci_is_vga_memory_range
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
condition|)
name|ok
operator|=
operator|(
name|sc
operator|->
name|bridgectl
operator|&
name|PCIB_BCR_VGA_ENABLE
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|flags
operator|&
name|PCIB_SUBTRACTIVE
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|ok
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|RF_PREFETCHABLE
condition|)
block|{
if|if
condition|(
name|pcib_is_prefetch_open
argument_list|(
name|sc
argument_list|)
condition|)
block|{
if|if
condition|(
name|start
operator|<
name|sc
operator|->
name|pmembase
condition|)
name|start
operator|=
name|sc
operator|->
name|pmembase
expr_stmt|;
if|if
condition|(
name|end
operator|>
name|sc
operator|->
name|pmemlimit
condition|)
name|end
operator|=
name|sc
operator|->
name|pmemlimit
expr_stmt|;
block|}
else|else
block|{
name|ok
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* non-prefetchable */
if|if
condition|(
name|pcib_is_nonprefetch_open
argument_list|(
name|sc
argument_list|)
condition|)
block|{
if|if
condition|(
name|start
operator|<
name|sc
operator|->
name|membase
condition|)
name|start
operator|=
name|sc
operator|->
name|membase
expr_stmt|;
if|if
condition|(
name|end
operator|>
name|sc
operator|->
name|memlimit
condition|)
name|end
operator|=
name|sc
operator|->
name|memlimit
expr_stmt|;
block|}
else|else
block|{
name|ok
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|ok
operator|=
literal|1
expr_stmt|;
comment|/* subtractive bridge: always ok */
if|#
directive|if
literal|0
block|if (pcib_is_nonprefetch_open(sc)) { 				if (start< sc->memlimit&& end> sc->membase) 					start = sc->memlimit + 1; 			} 			if (pcib_is_prefetch_open(sc)) { 				if (start< sc->pmemlimit&& end> sc->pmembase) 					start = sc->pmemlimit + 1; 			}
endif|#
directive|endif
block|}
if|if
condition|(
name|end
operator|<
name|start
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"memory: end (%lx)< start (%lx)\n"
argument_list|,
name|end
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|start
operator|=
literal|0
expr_stmt|;
name|end
operator|=
literal|0
expr_stmt|;
name|ok
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ok
operator|&&
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s%srequested unsupported memory range %#lx-%#lx "
literal|"(decoding %#jx-%#jx, %#jx-%#jx)\n"
argument_list|,
name|name
argument_list|,
name|suffix
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sc
operator|->
name|membase
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sc
operator|->
name|memlimit
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sc
operator|->
name|pmembase
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sc
operator|->
name|pmemlimit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s%srequested memory range "
literal|"0x%lx-0x%lx: good\n"
argument_list|,
name|name
argument_list|,
name|suffix
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* 	 * Bridge is OK decoding this resource, so pass it up. 	 */
return|return
operator|(
name|bus_generic_alloc_resource
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * PCIB interface.  */
end_comment

begin_function
name|int
name|pcib_maxslots
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
name|PCI_SLOTMAX
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Since we are a child of a PCI bus, its parent must support the pcib interface.  */
end_comment

begin_function
name|uint32_t
name|pcib_read_config
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|b
parameter_list|,
name|u_int
name|s
parameter_list|,
name|u_int
name|f
parameter_list|,
name|u_int
name|reg
parameter_list|,
name|int
name|width
parameter_list|)
block|{
return|return
operator|(
name|PCIB_READ_CONFIG
argument_list|(
name|device_get_parent
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|reg
argument_list|,
name|width
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pcib_write_config
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|b
parameter_list|,
name|u_int
name|s
parameter_list|,
name|u_int
name|f
parameter_list|,
name|u_int
name|reg
parameter_list|,
name|uint32_t
name|val
parameter_list|,
name|int
name|width
parameter_list|)
block|{
name|PCIB_WRITE_CONFIG
argument_list|(
name|device_get_parent
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|reg
argument_list|,
name|val
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Route an interrupt across a PCI bridge.  */
end_comment

begin_function
name|int
name|pcib_route_interrupt
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|int
name|pin
parameter_list|)
block|{
name|device_t
name|bus
decl_stmt|;
name|int
name|parent_intpin
decl_stmt|;
name|int
name|intnum
decl_stmt|;
comment|/*	      *      * The PCI standard defines a swizzle of the child-side device/intpin to      * the parent-side intpin as follows.      *      * device = device on child bus      * child_intpin = intpin on child bus slot (0-3)      * parent_intpin = intpin on parent bus slot (0-3)      *      * parent_intpin = (device + child_intpin) % 4      */
name|parent_intpin
operator|=
operator|(
name|pci_get_slot
argument_list|(
name|dev
argument_list|)
operator|+
operator|(
name|pin
operator|-
literal|1
operator|)
operator|)
operator|%
literal|4
expr_stmt|;
comment|/*      * Our parent is a PCI bus.  Its parent must export the pcib interface      * which includes the ability to route interrupts.      */
name|bus
operator|=
name|device_get_parent
argument_list|(
name|pcib
argument_list|)
expr_stmt|;
name|intnum
operator|=
name|PCIB_ROUTE_INTERRUPT
argument_list|(
name|device_get_parent
argument_list|(
name|bus
argument_list|)
argument_list|,
name|pcib
argument_list|,
name|parent_intpin
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|PCI_INTERRUPT_VALID
argument_list|(
name|intnum
argument_list|)
operator|&&
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|pcib
argument_list|,
literal|"slot %d INT%c is routed to irq %d\n"
argument_list|,
name|pci_get_slot
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|'A'
operator|+
name|pin
operator|-
literal|1
argument_list|,
name|intnum
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|intnum
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Pass request to alloc MSI/MSI-X messages up to the parent bridge. */
end_comment

begin_function
name|int
name|pcib_alloc_msi
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|maxcount
parameter_list|,
name|int
modifier|*
name|irqs
parameter_list|)
block|{
name|struct
name|pcib_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|pcib
argument_list|)
decl_stmt|;
name|device_t
name|bus
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|PCIB_DISABLE_MSI
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|bus
operator|=
name|device_get_parent
argument_list|(
name|pcib
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCIB_ALLOC_MSI
argument_list|(
name|device_get_parent
argument_list|(
name|bus
argument_list|)
argument_list|,
name|dev
argument_list|,
name|count
argument_list|,
name|maxcount
argument_list|,
name|irqs
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Pass request to release MSI/MSI-X messages up to the parent bridge. */
end_comment

begin_function
name|int
name|pcib_release_msi
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|int
name|count
parameter_list|,
name|int
modifier|*
name|irqs
parameter_list|)
block|{
name|device_t
name|bus
decl_stmt|;
name|bus
operator|=
name|device_get_parent
argument_list|(
name|pcib
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCIB_RELEASE_MSI
argument_list|(
name|device_get_parent
argument_list|(
name|bus
argument_list|)
argument_list|,
name|dev
argument_list|,
name|count
argument_list|,
name|irqs
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Pass request to alloc an MSI-X message up to the parent bridge. */
end_comment

begin_function
name|int
name|pcib_alloc_msix
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|int
modifier|*
name|irq
parameter_list|)
block|{
name|struct
name|pcib_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|pcib
argument_list|)
decl_stmt|;
name|device_t
name|bus
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|PCIB_DISABLE_MSIX
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|bus
operator|=
name|device_get_parent
argument_list|(
name|pcib
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCIB_ALLOC_MSIX
argument_list|(
name|device_get_parent
argument_list|(
name|bus
argument_list|)
argument_list|,
name|dev
argument_list|,
name|irq
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Pass request to release an MSI-X message up to the parent bridge. */
end_comment

begin_function
name|int
name|pcib_release_msix
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|int
name|irq
parameter_list|)
block|{
name|device_t
name|bus
decl_stmt|;
name|bus
operator|=
name|device_get_parent
argument_list|(
name|pcib
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCIB_RELEASE_MSIX
argument_list|(
name|device_get_parent
argument_list|(
name|bus
argument_list|)
argument_list|,
name|dev
argument_list|,
name|irq
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Pass request to map MSI/MSI-X message up to parent bridge. */
end_comment

begin_function
name|int
name|pcib_map_msi
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|int
name|irq
parameter_list|,
name|uint64_t
modifier|*
name|addr
parameter_list|,
name|uint32_t
modifier|*
name|data
parameter_list|)
block|{
name|device_t
name|bus
decl_stmt|;
name|int
name|error
decl_stmt|;
name|bus
operator|=
name|device_get_parent
argument_list|(
name|pcib
argument_list|)
expr_stmt|;
name|error
operator|=
name|PCIB_MAP_MSI
argument_list|(
name|device_get_parent
argument_list|(
name|bus
argument_list|)
argument_list|,
name|dev
argument_list|,
name|irq
argument_list|,
name|addr
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|pci_ht_map_msi
argument_list|(
name|pcib
argument_list|,
operator|*
name|addr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Pass request for device power state up to parent bridge. */
end_comment

begin_function
name|int
name|pcib_power_for_sleep
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|int
modifier|*
name|pstate
parameter_list|)
block|{
name|device_t
name|bus
decl_stmt|;
name|bus
operator|=
name|device_get_parent
argument_list|(
name|pcib
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCIB_POWER_FOR_SLEEP
argument_list|(
name|bus
argument_list|,
name|dev
argument_list|,
name|pstate
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

