begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2006 IronPort Systems  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2007 LSI Corp.  * Copyright (c) 2007 Rajesh Prabhakaran.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_mfi.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus_dma.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<dev/mfi/mfireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/mfi/mfi_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<dev/mfi/mfivar.h>
end_include

begin_function_decl
specifier|static
name|int
name|mfi_alloc_commands
parameter_list|(
name|struct
name|mfi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mfi_comms_init
parameter_list|(
name|struct
name|mfi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mfi_wait_command
parameter_list|(
name|struct
name|mfi_softc
modifier|*
parameter_list|,
name|struct
name|mfi_command
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mfi_get_controller_info
parameter_list|(
name|struct
name|mfi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mfi_get_log_state
parameter_list|(
name|struct
name|mfi_softc
modifier|*
parameter_list|,
name|struct
name|mfi_evt_log_state
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mfi_parse_entries
parameter_list|(
name|struct
name|mfi_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mfi_dcmd_command
parameter_list|(
name|struct
name|mfi_softc
modifier|*
parameter_list|,
name|struct
name|mfi_command
modifier|*
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|void
modifier|*
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mfi_data_cb
parameter_list|(
name|void
modifier|*
parameter_list|,
name|bus_dma_segment_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mfi_startup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mfi_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mfi_ldprobe
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mfi_aen_register
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|seq
parameter_list|,
name|int
name|locale
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mfi_aen_complete
parameter_list|(
name|struct
name|mfi_command
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mfi_aen_setup
parameter_list|(
name|struct
name|mfi_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mfi_add_ld
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mfi_add_ld_complete
parameter_list|(
name|struct
name|mfi_command
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mfi_command
modifier|*
name|mfi_bio_command
parameter_list|(
name|struct
name|mfi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mfi_bio_complete
parameter_list|(
name|struct
name|mfi_command
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mfi_mapcmd
parameter_list|(
name|struct
name|mfi_softc
modifier|*
parameter_list|,
name|struct
name|mfi_command
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mfi_send_frame
parameter_list|(
name|struct
name|mfi_softc
modifier|*
parameter_list|,
name|struct
name|mfi_command
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mfi_complete
parameter_list|(
name|struct
name|mfi_softc
modifier|*
parameter_list|,
name|struct
name|mfi_command
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mfi_abort
parameter_list|(
name|struct
name|mfi_softc
modifier|*
parameter_list|,
name|struct
name|mfi_command
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mfi_linux_ioctl_int
parameter_list|(
name|struct
name|cdev
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|,
name|int
parameter_list|,
name|struct
name|thread
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mfi_timeout
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mfi_user_command
parameter_list|(
name|struct
name|mfi_softc
modifier|*
parameter_list|,
name|struct
name|mfi_ioc_passthru
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mfi_enable_intr_xscale
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mfi_enable_intr_ppc
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|mfi_read_fw_status_xscale
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|mfi_read_fw_status_ppc
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mfi_check_clear_intr_xscale
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mfi_check_clear_intr_ppc
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mfi_issue_cmd_xscale
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|bus_add
parameter_list|,
name|uint32_t
name|frame_cnt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mfi_issue_cmd_ppc
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|bus_add
parameter_list|,
name|uint32_t
name|frame_cnt
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|mfi
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"MFI driver parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|mfi_event_locale
init|=
name|MFI_EVT_LOCALE_ALL
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.mfi.event_locale"
argument_list|,
operator|&
name|mfi_event_locale
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_mfi
argument_list|,
name|OID_AUTO
argument_list|,
name|event_locale
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|mfi_event_locale
argument_list|,
literal|0
argument_list|,
literal|"event message locale"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|mfi_event_class
init|=
name|MFI_EVT_CLASS_INFO
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.mfi.event_class"
argument_list|,
operator|&
name|mfi_event_class
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_mfi
argument_list|,
name|OID_AUTO
argument_list|,
name|event_class
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|mfi_event_class
argument_list|,
literal|0
argument_list|,
literal|"event message class"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|mfi_max_cmds
init|=
literal|128
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.mfi.max_cmds"
argument_list|,
operator|&
name|mfi_max_cmds
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_mfi
argument_list|,
name|OID_AUTO
argument_list|,
name|max_cmds
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|mfi_max_cmds
argument_list|,
literal|0
argument_list|,
literal|"Max commands"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Management interface */
end_comment

begin_decl_stmt
specifier|static
name|d_open_t
name|mfi_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|mfi_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|mfi_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_poll_t
name|mfi_poll
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|mfi_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_flags
operator|=
literal|0
block|,
operator|.
name|d_open
operator|=
name|mfi_open
block|,
operator|.
name|d_close
operator|=
name|mfi_close
block|,
operator|.
name|d_ioctl
operator|=
name|mfi_ioctl
block|,
operator|.
name|d_poll
operator|=
name|mfi_poll
block|,
operator|.
name|d_name
operator|=
literal|"mfi"
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_MFIBUF
argument_list|,
literal|"mfibuf"
argument_list|,
literal|"Buffers for the MFI driver"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|MFI_INQ_LENGTH
value|SHORT_INQUIRY_LENGTH
end_define

begin_function
specifier|static
name|void
name|mfi_enable_intr_xscale
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|MFI_WRITE4
argument_list|(
name|sc
argument_list|,
name|MFI_OMSK
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mfi_enable_intr_ppc
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|MFI_WRITE4
argument_list|(
name|sc
argument_list|,
name|MFI_ODCR0
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_flags
operator|&
name|MFI_FLAGS_1078
condition|)
block|{
name|MFI_WRITE4
argument_list|(
name|sc
argument_list|,
name|MFI_OMSK
argument_list|,
operator|~
name|MFI_1078_EIM
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|mfi_flags
operator|&
name|MFI_FLAGS_GEN2
condition|)
block|{
name|MFI_WRITE4
argument_list|(
name|sc
argument_list|,
name|MFI_OMSK
argument_list|,
operator|~
name|MFI_GEN2_EIM
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int32_t
name|mfi_read_fw_status_xscale
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return
name|MFI_READ4
argument_list|(
name|sc
argument_list|,
name|MFI_OMSG0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|mfi_read_fw_status_ppc
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return
name|MFI_READ4
argument_list|(
name|sc
argument_list|,
name|MFI_OSP0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_check_clear_intr_xscale
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int32_t
name|status
decl_stmt|;
name|status
operator|=
name|MFI_READ4
argument_list|(
name|sc
argument_list|,
name|MFI_OSTS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|MFI_OSTS_INTR_VALID
operator|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|MFI_WRITE4
argument_list|(
name|sc
argument_list|,
name|MFI_OSTS
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_check_clear_intr_ppc
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int32_t
name|status
decl_stmt|;
name|status
operator|=
name|MFI_READ4
argument_list|(
name|sc
argument_list|,
name|MFI_OSTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_flags
operator|&
name|MFI_FLAGS_1078
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|status
operator|&
name|MFI_1078_RM
operator|)
condition|)
block|{
return|return
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|mfi_flags
operator|&
name|MFI_FLAGS_GEN2
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|status
operator|&
name|MFI_GEN2_RM
operator|)
condition|)
block|{
return|return
literal|1
return|;
block|}
block|}
name|MFI_WRITE4
argument_list|(
name|sc
argument_list|,
name|MFI_ODCR0
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mfi_issue_cmd_xscale
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|bus_add
parameter_list|,
name|uint32_t
name|frame_cnt
parameter_list|)
block|{
name|MFI_WRITE4
argument_list|(
name|sc
argument_list|,
name|MFI_IQP
argument_list|,
operator|(
name|bus_add
operator|>>
literal|3
operator|)
operator||
name|frame_cnt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mfi_issue_cmd_ppc
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|bus_add
parameter_list|,
name|uint32_t
name|frame_cnt
parameter_list|)
block|{
name|MFI_WRITE4
argument_list|(
name|sc
argument_list|,
name|MFI_IQP
argument_list|,
operator|(
name|bus_add
operator||
name|frame_cnt
operator|<<
literal|1
operator|)
operator||
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_transition_firmware
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|fw_state
decl_stmt|,
name|cur_state
decl_stmt|;
name|int
name|max_wait
decl_stmt|,
name|i
decl_stmt|;
name|fw_state
operator|=
name|sc
operator|->
name|mfi_read_fw_status
argument_list|(
name|sc
argument_list|)
operator|&
name|MFI_FWSTATE_MASK
expr_stmt|;
while|while
condition|(
name|fw_state
operator|!=
name|MFI_FWSTATE_READY
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Waiting for firmware to "
literal|"become ready\n"
argument_list|)
expr_stmt|;
name|cur_state
operator|=
name|fw_state
expr_stmt|;
switch|switch
condition|(
name|fw_state
condition|)
block|{
case|case
name|MFI_FWSTATE_FAULT
case|:
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Firmware fault\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
case|case
name|MFI_FWSTATE_WAIT_HANDSHAKE
case|:
name|MFI_WRITE4
argument_list|(
name|sc
argument_list|,
name|MFI_IDB
argument_list|,
name|MFI_FWINIT_CLEAR_HANDSHAKE
argument_list|)
expr_stmt|;
name|max_wait
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|MFI_FWSTATE_OPERATIONAL
case|:
name|MFI_WRITE4
argument_list|(
name|sc
argument_list|,
name|MFI_IDB
argument_list|,
name|MFI_FWINIT_READY
argument_list|)
expr_stmt|;
name|max_wait
operator|=
literal|10
expr_stmt|;
break|break;
case|case
name|MFI_FWSTATE_UNDEFINED
case|:
case|case
name|MFI_FWSTATE_BB_INIT
case|:
name|max_wait
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|MFI_FWSTATE_FW_INIT
case|:
case|case
name|MFI_FWSTATE_DEVICE_SCAN
case|:
case|case
name|MFI_FWSTATE_FLUSH_CACHE
case|:
name|max_wait
operator|=
literal|20
expr_stmt|;
break|break;
case|case
name|MFI_FWSTATE_BOOT_MESSAGE_PENDING
case|:
name|MFI_WRITE4
argument_list|(
name|sc
argument_list|,
name|MFI_IDB
argument_list|,
name|MFI_FWINIT_HOTPLUG
argument_list|)
expr_stmt|;
name|max_wait
operator|=
literal|10
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Unknown firmware state %#x\n"
argument_list|,
name|fw_state
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|max_wait
operator|*
literal|10
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|fw_state
operator|=
name|sc
operator|->
name|mfi_read_fw_status
argument_list|(
name|sc
argument_list|)
operator|&
name|MFI_FWSTATE_MASK
expr_stmt|;
if|if
condition|(
name|fw_state
operator|==
name|cur_state
condition|)
name|DELAY
argument_list|(
literal|100000
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
name|fw_state
operator|==
name|cur_state
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Firmware stuck in state "
literal|"%#x\n"
argument_list|,
name|fw_state
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mfi_addr32_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|uint32_t
modifier|*
name|addr
decl_stmt|;
name|addr
operator|=
name|arg
expr_stmt|;
operator|*
name|addr
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
name|int
name|mfi_attach
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|status
decl_stmt|;
name|int
name|error
decl_stmt|,
name|commsz
decl_stmt|,
name|framessz
decl_stmt|,
name|sensesz
decl_stmt|;
name|int
name|frames
decl_stmt|,
name|unit
decl_stmt|,
name|max_fw_sge
decl_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Megaraid SAS driver Ver 3.00 \n"
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|,
literal|"MFI I/O lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|sx_init
argument_list|(
operator|&
name|sc
operator|->
name|mfi_config_lock
argument_list|,
literal|"MFI config"
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|mfi_ld_tqh
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|mfi_aen_pids
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|mfi_cam_ccbq
argument_list|)
expr_stmt|;
name|mfi_initq_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mfi_initq_ready
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mfi_initq_busy
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mfi_initq_bio
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_flags
operator|&
name|MFI_FLAGS_1064R
condition|)
block|{
name|sc
operator|->
name|mfi_enable_intr
operator|=
name|mfi_enable_intr_xscale
expr_stmt|;
name|sc
operator|->
name|mfi_read_fw_status
operator|=
name|mfi_read_fw_status_xscale
expr_stmt|;
name|sc
operator|->
name|mfi_check_clear_intr
operator|=
name|mfi_check_clear_intr_xscale
expr_stmt|;
name|sc
operator|->
name|mfi_issue_cmd
operator|=
name|mfi_issue_cmd_xscale
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|mfi_enable_intr
operator|=
name|mfi_enable_intr_ppc
expr_stmt|;
name|sc
operator|->
name|mfi_read_fw_status
operator|=
name|mfi_read_fw_status_ppc
expr_stmt|;
name|sc
operator|->
name|mfi_check_clear_intr
operator|=
name|mfi_check_clear_intr_ppc
expr_stmt|;
name|sc
operator|->
name|mfi_issue_cmd
operator|=
name|mfi_issue_cmd_ppc
expr_stmt|;
block|}
comment|/* Before we get too far, see if the firmware is working */
if|if
condition|(
operator|(
name|error
operator|=
name|mfi_transition_firmware
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Firmware not in READY state, "
literal|"error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * Get information needed for sizing the contiguous memory for the 	 * frame pool.  Size down the sgl parameter since we know that 	 * we will never need more than what's required for MAXPHYS. 	 * It would be nice if these constants were available at runtime 	 * instead of compile time. 	 */
name|status
operator|=
name|sc
operator|->
name|mfi_read_fw_status
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mfi_max_fw_cmds
operator|=
name|status
operator|&
name|MFI_FWSTATE_MAXCMD_MASK
expr_stmt|;
name|max_fw_sge
operator|=
operator|(
name|status
operator|&
name|MFI_FWSTATE_MAXSGL_MASK
operator|)
operator|>>
literal|16
expr_stmt|;
name|sc
operator|->
name|mfi_max_sge
operator|=
name|min
argument_list|(
name|max_fw_sge
argument_list|,
operator|(
operator|(
name|MFI_MAXPHYS
operator|/
name|PAGE_SIZE
operator|)
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Create the dma tag for data buffers.  Used both for block I/O 	 * and for various internal data queries. 	 */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|mfi_parent_dmat
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* maxsize */
name|sc
operator|->
name|mfi_max_sge
argument_list|,
comment|/* nsegments */
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* maxsegsize */
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/* flags */
name|busdma_lock_mutex
argument_list|,
comment|/* lockfunc */
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|,
comment|/* lockfuncarg */
operator|&
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Cannot allocate buffer DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* 	 * Allocate DMA memory for the comms queues.  Keep it under 4GB for 	 * efficiency.  The mfi_hwcomms struct includes space for 1 reply queue 	 * entry, so the calculated size here will be will be 1 more than 	 * mfi_max_fw_cmds.  This is apparently a requirement of the hardware. 	 */
name|commsz
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
name|sc
operator|->
name|mfi_max_fw_cmds
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|mfi_hwcomms
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|mfi_parent_dmat
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|commsz
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* msegments */
name|commsz
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|mfi_comms_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Cannot allocate comms DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|mfi_comms_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|mfi_comms
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|mfi_comms_dmamap
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Cannot allocate comms memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|sc
operator|->
name|mfi_comms
argument_list|,
name|commsz
argument_list|)
expr_stmt|;
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|mfi_comms_dmat
argument_list|,
name|sc
operator|->
name|mfi_comms_dmamap
argument_list|,
name|sc
operator|->
name|mfi_comms
argument_list|,
name|commsz
argument_list|,
name|mfi_addr32_cb
argument_list|,
operator|&
name|sc
operator|->
name|mfi_comms_busaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate DMA memory for the command frames.  Keep them in the 	 * lower 4GB for efficiency.  Calculate the size of the commands at 	 * the same time; each command is one 64 byte frame plus a set of          * additional frames for holding sg lists or other data. 	 * The assumption here is that the SG list will start at the second 	 * frame and not use the unused bytes in the first frame.  While this 	 * isn't technically correct, it simplifies the calculation and allows 	 * for command frames that might be larger than an mfi_io_frame. 	 */
if|if
condition|(
sizeof|sizeof
argument_list|(
name|bus_addr_t
argument_list|)
operator|==
literal|8
condition|)
block|{
name|sc
operator|->
name|mfi_sge_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mfi_sg64
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mfi_flags
operator||=
name|MFI_FLAGS_SG64
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|mfi_sge_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mfi_sg32
argument_list|)
expr_stmt|;
block|}
name|frames
operator|=
operator|(
name|sc
operator|->
name|mfi_sge_size
operator|*
name|sc
operator|->
name|mfi_max_sge
operator|-
literal|1
operator|)
operator|/
name|MFI_FRAME_SIZE
operator|+
literal|2
expr_stmt|;
name|sc
operator|->
name|mfi_cmd_size
operator|=
name|frames
operator|*
name|MFI_FRAME_SIZE
expr_stmt|;
name|framessz
operator|=
name|sc
operator|->
name|mfi_cmd_size
operator|*
name|sc
operator|->
name|mfi_max_fw_cmds
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|mfi_parent_dmat
argument_list|,
comment|/* parent */
literal|64
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|framessz
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|framessz
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|mfi_frames_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Cannot allocate frame DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|mfi_frames_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|mfi_frames
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|mfi_frames_dmamap
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Cannot allocate frames memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|sc
operator|->
name|mfi_frames
argument_list|,
name|framessz
argument_list|)
expr_stmt|;
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|mfi_frames_dmat
argument_list|,
name|sc
operator|->
name|mfi_frames_dmamap
argument_list|,
name|sc
operator|->
name|mfi_frames
argument_list|,
name|framessz
argument_list|,
name|mfi_addr32_cb
argument_list|,
operator|&
name|sc
operator|->
name|mfi_frames_busaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate DMA memory for the frame sense data.  Keep them in the 	 * lower 4GB for efficiency 	 */
name|sensesz
operator|=
name|sc
operator|->
name|mfi_max_fw_cmds
operator|*
name|MFI_SENSE_LEN
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|mfi_parent_dmat
argument_list|,
comment|/* parent */
literal|4
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|sensesz
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|sensesz
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|mfi_sense_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Cannot allocate sense DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|mfi_sense_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|mfi_sense
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|mfi_sense_dmamap
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Cannot allocate sense memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|mfi_sense_dmat
argument_list|,
name|sc
operator|->
name|mfi_sense_dmamap
argument_list|,
name|sc
operator|->
name|mfi_sense
argument_list|,
name|sensesz
argument_list|,
name|mfi_addr32_cb
argument_list|,
operator|&
name|sc
operator|->
name|mfi_sense_busaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|mfi_alloc_commands
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|mfi_comms_init
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|mfi_get_controller_info
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|mfi_aen_setup
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
operator|,
literal|0
operator|)
operator|!=
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Set up the interrupt handler. 	 */
if|if
condition|(
name|bus_setup_intr
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
name|sc
operator|->
name|mfi_irq
argument_list|,
name|INTR_MPSAFE
operator||
name|INTR_TYPE_BIO
argument_list|,
name|NULL
argument_list|,
name|mfi_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|mfi_intr
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Cannot set up interrupt\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Register a config hook to probe the bus for arrays */
name|sc
operator|->
name|mfi_ich
operator|.
name|ich_func
operator|=
name|mfi_startup
expr_stmt|;
name|sc
operator|->
name|mfi_ich
operator|.
name|ich_arg
operator|=
name|sc
expr_stmt|;
if|if
condition|(
name|config_intrhook_establish
argument_list|(
operator|&
name|sc
operator|->
name|mfi_ich
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Cannot establish configuration "
literal|"hook\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * Register a shutdown handler. 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|mfi_eh
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|shutdown_final
argument_list|,
name|mfi_shutdown
argument_list|,
name|sc
argument_list|,
name|SHUTDOWN_PRI_DEFAULT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Warning: shutdown event "
literal|"registration failed\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Create the control device for doing management 	 */
name|unit
operator|=
name|device_get_unit
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mfi_cdev
operator|=
name|make_dev
argument_list|(
operator|&
name|mfi_cdevsw
argument_list|,
name|unit
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0640
argument_list|,
literal|"mfi%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|==
literal|0
condition|)
name|make_dev_alias
argument_list|(
name|sc
operator|->
name|mfi_cdev
argument_list|,
literal|"megaraid_sas_ioctl_node"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_cdev
operator|!=
name|NULL
condition|)
name|sc
operator|->
name|mfi_cdev
operator|->
name|si_drv1
operator|=
name|sc
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"delete_busy_volumes"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|mfi_delete_busy_volumes
argument_list|,
literal|0
argument_list|,
literal|"Allow removal of busy volumes"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"keep_deleted_volumes"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|mfi_keep_deleted_volumes
argument_list|,
literal|0
argument_list|,
literal|"Don't detach the mfid device for a busy volume that is deleted"
argument_list|)
expr_stmt|;
name|device_add_child
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"mfip"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|bus_generic_attach
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|)
expr_stmt|;
comment|/* Start the timeout watchdog */
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|mfi_watchdog_callout
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|mfi_watchdog_callout
argument_list|,
name|MFI_CMD_TIMEOUT
operator|*
name|hz
argument_list|,
name|mfi_timeout
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_alloc_commands
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mfi_command
modifier|*
name|cm
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ncmds
decl_stmt|;
comment|/* 	 * XXX Should we allocate all the commands up front, or allocate on 	 * demand later like 'aac' does? 	 */
name|ncmds
operator|=
name|MIN
argument_list|(
name|mfi_max_cmds
argument_list|,
name|sc
operator|->
name|mfi_max_fw_cmds
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Max fw cmds= %d, sizing driver "
literal|"pool to %d\n"
argument_list|,
name|sc
operator|->
name|mfi_max_fw_cmds
argument_list|,
name|ncmds
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mfi_commands
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mfi_command
argument_list|)
operator|*
name|ncmds
argument_list|,
name|M_MFIBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncmds
condition|;
name|i
operator|++
control|)
block|{
name|cm
operator|=
operator|&
name|sc
operator|->
name|mfi_commands
index|[
name|i
index|]
expr_stmt|;
name|cm
operator|->
name|cm_frame
operator|=
operator|(
expr|union
name|mfi_frame
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|sc
operator|->
name|mfi_frames
operator|+
name|sc
operator|->
name|mfi_cmd_size
operator|*
name|i
operator|)
expr_stmt|;
name|cm
operator|->
name|cm_frame_busaddr
operator|=
name|sc
operator|->
name|mfi_frames_busaddr
operator|+
name|sc
operator|->
name|mfi_cmd_size
operator|*
name|i
expr_stmt|;
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|context
operator|=
name|i
expr_stmt|;
name|cm
operator|->
name|cm_sense
operator|=
operator|&
name|sc
operator|->
name|mfi_sense
index|[
name|i
index|]
expr_stmt|;
name|cm
operator|->
name|cm_sense_busaddr
operator|=
name|sc
operator|->
name|mfi_sense_busaddr
operator|+
name|MFI_SENSE_LEN
operator|*
name|i
expr_stmt|;
name|cm
operator|->
name|cm_sc
operator|=
name|sc
expr_stmt|;
name|cm
operator|->
name|cm_index
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|,
literal|0
argument_list|,
operator|&
name|cm
operator|->
name|cm_dmamap
argument_list|)
operator|==
literal|0
condition|)
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
else|else
break|break;
name|sc
operator|->
name|mfi_total_cmds
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|mfi_release_command
parameter_list|(
name|struct
name|mfi_command
modifier|*
name|cm
parameter_list|)
block|{
name|struct
name|mfi_frame_header
modifier|*
name|hdr
decl_stmt|;
name|uint32_t
modifier|*
name|hdr_data
decl_stmt|;
comment|/* 	 * Zero out the important fields of the frame, but make sure the 	 * context field is preserved.  For efficiency, handle the fields 	 * as 32 bit words.  Clear out the first S/G entry too for safety. 	 */
name|hdr
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|header
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_data
operator|!=
name|NULL
operator|&&
name|hdr
operator|->
name|sg_count
condition|)
block|{
name|cm
operator|->
name|cm_sg
operator|->
name|sg32
index|[
literal|0
index|]
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|cm
operator|->
name|cm_sg
operator|->
name|sg32
index|[
literal|0
index|]
operator|.
name|addr
operator|=
literal|0
expr_stmt|;
block|}
name|hdr_data
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|cm
operator|->
name|cm_frame
expr_stmt|;
name|hdr_data
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* cmd, sense_len, cmd_status, scsi_status */
name|hdr_data
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* target_id, lun_id, cdb_len, sg_count */
name|hdr_data
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
comment|/* flags, timeout */
name|hdr_data
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
comment|/* data_len */
name|cm
operator|->
name|cm_extra_frames
operator|=
literal|0
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator|=
literal|0
expr_stmt|;
name|cm
operator|->
name|cm_complete
operator|=
name|NULL
expr_stmt|;
name|cm
operator|->
name|cm_private
operator|=
name|NULL
expr_stmt|;
name|cm
operator|->
name|cm_data
operator|=
name|NULL
expr_stmt|;
name|cm
operator|->
name|cm_sg
operator|=
literal|0
expr_stmt|;
name|cm
operator|->
name|cm_total_frame_size
operator|=
literal|0
expr_stmt|;
name|mfi_enqueue_free
argument_list|(
name|cm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_dcmd_command
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mfi_command
modifier|*
modifier|*
name|cmp
parameter_list|,
name|uint32_t
name|opcode
parameter_list|,
name|void
modifier|*
modifier|*
name|bufp
parameter_list|,
name|size_t
name|bufsize
parameter_list|)
block|{
name|struct
name|mfi_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|mfi_dcmd_frame
modifier|*
name|dcmd
decl_stmt|;
name|void
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|cm
operator|=
name|mfi_dequeue_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|==
name|NULL
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
operator|(
name|bufsize
operator|>
literal|0
operator|)
operator|&&
operator|(
name|bufp
operator|!=
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|bufp
operator|==
name|NULL
condition|)
block|{
name|buf
operator|=
name|malloc
argument_list|(
name|bufsize
argument_list|,
name|M_MFIBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
operator|*
name|bufp
operator|=
name|buf
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|=
operator|*
name|bufp
expr_stmt|;
block|}
block|}
name|dcmd
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|dcmd
expr_stmt|;
name|bzero
argument_list|(
name|dcmd
operator|->
name|mbox
argument_list|,
name|MFI_MBOX_SIZE
argument_list|)
expr_stmt|;
name|dcmd
operator|->
name|header
operator|.
name|cmd
operator|=
name|MFI_CMD_DCMD
expr_stmt|;
name|dcmd
operator|->
name|header
operator|.
name|timeout
operator|=
literal|0
expr_stmt|;
name|dcmd
operator|->
name|header
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|dcmd
operator|->
name|header
operator|.
name|data_len
operator|=
name|bufsize
expr_stmt|;
name|dcmd
operator|->
name|opcode
operator|=
name|opcode
expr_stmt|;
name|cm
operator|->
name|cm_sg
operator|=
operator|&
name|dcmd
operator|->
name|sgl
expr_stmt|;
name|cm
operator|->
name|cm_total_frame_size
operator|=
name|MFI_DCMD_FRAME_SIZE
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator|=
literal|0
expr_stmt|;
name|cm
operator|->
name|cm_data
operator|=
name|buf
expr_stmt|;
name|cm
operator|->
name|cm_private
operator|=
name|buf
expr_stmt|;
name|cm
operator|->
name|cm_len
operator|=
name|bufsize
expr_stmt|;
operator|*
name|cmp
operator|=
name|cm
expr_stmt|;
if|if
condition|(
operator|(
name|bufp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|bufp
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|buf
operator|!=
name|NULL
operator|)
condition|)
operator|*
name|bufp
operator|=
name|buf
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_comms_init
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mfi_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|mfi_init_frame
modifier|*
name|init
decl_stmt|;
name|struct
name|mfi_init_qinfo
modifier|*
name|qinfo
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|=
name|mfi_dequeue_free
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* 	 * Abuse the SG list area of the frame to hold the init_qinfo 	 * object; 	 */
name|init
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|init
expr_stmt|;
name|qinfo
operator|=
operator|(
expr|struct
name|mfi_init_qinfo
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|init
operator|+
name|MFI_FRAME_SIZE
operator|)
expr_stmt|;
name|bzero
argument_list|(
name|qinfo
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mfi_init_qinfo
argument_list|)
argument_list|)
expr_stmt|;
name|qinfo
operator|->
name|rq_entries
operator|=
name|sc
operator|->
name|mfi_max_fw_cmds
operator|+
literal|1
expr_stmt|;
name|qinfo
operator|->
name|rq_addr_lo
operator|=
name|sc
operator|->
name|mfi_comms_busaddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|mfi_hwcomms
argument_list|,
name|hw_reply_q
argument_list|)
expr_stmt|;
name|qinfo
operator|->
name|pi_addr_lo
operator|=
name|sc
operator|->
name|mfi_comms_busaddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|mfi_hwcomms
argument_list|,
name|hw_pi
argument_list|)
expr_stmt|;
name|qinfo
operator|->
name|ci_addr_lo
operator|=
name|sc
operator|->
name|mfi_comms_busaddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|mfi_hwcomms
argument_list|,
name|hw_ci
argument_list|)
expr_stmt|;
name|init
operator|->
name|header
operator|.
name|cmd
operator|=
name|MFI_CMD_INIT
expr_stmt|;
name|init
operator|->
name|header
operator|.
name|data_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mfi_init_qinfo
argument_list|)
expr_stmt|;
name|init
operator|->
name|qinfo_new_addr_lo
operator|=
name|cm
operator|->
name|cm_frame_busaddr
operator|+
name|MFI_FRAME_SIZE
expr_stmt|;
name|cm
operator|->
name|cm_data
operator|=
name|NULL
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator|=
name|MFI_CMD_POLLED
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|mfi_mapcmd
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"failed to send init command\n"
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_get_controller_info
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mfi_command
modifier|*
name|cm
init|=
name|NULL
decl_stmt|;
name|struct
name|mfi_ctrl_info
modifier|*
name|ci
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|max_sectors_1
decl_stmt|,
name|max_sectors_2
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|mfi_dcmd_command
argument_list|(
name|sc
argument_list|,
operator|&
name|cm
argument_list|,
name|MFI_DCMD_CTRL_GETINFO
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|ci
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ci
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|cm
operator|->
name|cm_flags
operator|=
name|MFI_CMD_DATAIN
operator||
name|MFI_CMD_POLLED
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|mfi_mapcmd
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Failed to get controller info\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mfi_max_io
operator|=
operator|(
name|sc
operator|->
name|mfi_max_sge
operator|-
literal|1
operator|)
operator|*
name|PAGE_SIZE
operator|/
name|MFI_SECTOR_LEN
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|)
expr_stmt|;
name|max_sectors_1
operator|=
operator|(
literal|1
operator|<<
name|ci
operator|->
name|stripe_sz_ops
operator|.
name|min
operator|)
operator|*
name|ci
operator|->
name|max_strips_per_io
expr_stmt|;
name|max_sectors_2
operator|=
name|ci
operator|->
name|max_request_size
expr_stmt|;
name|sc
operator|->
name|mfi_max_io
operator|=
name|min
argument_list|(
name|max_sectors_1
argument_list|,
name|max_sectors_2
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|ci
condition|)
name|free
argument_list|(
name|ci
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
condition|)
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_get_log_state
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mfi_evt_log_state
modifier|*
modifier|*
name|log_state
parameter_list|)
block|{
name|struct
name|mfi_command
modifier|*
name|cm
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|mfi_dcmd_command
argument_list|(
name|sc
argument_list|,
operator|&
name|cm
argument_list|,
name|MFI_DCMD_CTRL_EVENT_GETINFO
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
name|log_state
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|log_state
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|cm
operator|->
name|cm_flags
operator|=
name|MFI_CMD_DATAIN
operator||
name|MFI_CMD_POLLED
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|mfi_mapcmd
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Failed to get log state\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|cm
condition|)
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_aen_setup
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|seq_start
parameter_list|)
block|{
name|struct
name|mfi_evt_log_state
modifier|*
name|log_state
init|=
name|NULL
decl_stmt|;
name|union
name|mfi_evt
name|class_locale
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|uint32_t
name|seq
decl_stmt|;
name|class_locale
operator|.
name|members
operator|.
name|reserved
operator|=
literal|0
expr_stmt|;
name|class_locale
operator|.
name|members
operator|.
name|locale
operator|=
name|mfi_event_locale
expr_stmt|;
name|class_locale
operator|.
name|members
operator|.
name|evt_class
operator|=
name|mfi_event_class
expr_stmt|;
if|if
condition|(
name|seq_start
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|mfi_get_log_state
argument_list|(
name|sc
argument_list|,
operator|&
name|log_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|log_state
condition|)
name|free
argument_list|(
name|log_state
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 		 * Walk through any events that fired since the last 		 * shutdown. 		 */
name|mfi_parse_entries
argument_list|(
name|sc
argument_list|,
name|log_state
operator|->
name|shutdown_seq_num
argument_list|,
name|log_state
operator|->
name|newest_seq_num
argument_list|)
expr_stmt|;
name|seq
operator|=
name|log_state
operator|->
name|newest_seq_num
expr_stmt|;
block|}
else|else
name|seq
operator|=
name|seq_start
expr_stmt|;
name|mfi_aen_register
argument_list|(
name|sc
argument_list|,
name|seq
argument_list|,
name|class_locale
operator|.
name|word
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|log_state
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_wait_command
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mfi_command
modifier|*
name|cm
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_complete
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * MegaCli can issue a DCMD of 0.  In this case do nothing 	 * and return 0 to it as status 	 */
if|if
condition|(
name|cm
operator|->
name|cm_frame
operator|->
name|dcmd
operator|.
name|opcode
operator|==
literal|0
condition|)
block|{
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|cmd_status
operator|=
name|MFI_STAT_OK
expr_stmt|;
name|cm
operator|->
name|cm_error
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|cm
operator|->
name|cm_error
operator|)
return|;
block|}
name|mfi_enqueue_ready
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|mfi_startio
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|->
name|cm_flags
operator|&
name|MFI_CMD_COMPLETED
operator|)
operator|==
literal|0
condition|)
name|msleep
argument_list|(
name|cm
argument_list|,
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|,
name|PRIBIO
argument_list|,
literal|"mfiwait"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|cm
operator|->
name|cm_error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|mfi_free
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mfi_command
modifier|*
name|cm
decl_stmt|;
name|int
name|i
decl_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|mfi_watchdog_callout
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_cdev
operator|!=
name|NULL
condition|)
name|destroy_dev
argument_list|(
name|sc
operator|->
name|mfi_cdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_total_cmds
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|mfi_total_cmds
condition|;
name|i
operator|++
control|)
block|{
name|cm
operator|=
operator|&
name|sc
operator|->
name|mfi_commands
index|[
name|i
index|]
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|sc
operator|->
name|mfi_commands
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|mfi_intr
condition|)
name|bus_teardown_intr
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
name|sc
operator|->
name|mfi_irq
argument_list|,
name|sc
operator|->
name|mfi_intr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_irq
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|mfi_irq_rid
argument_list|,
name|sc
operator|->
name|mfi_irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_sense_busaddr
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|mfi_sense_dmat
argument_list|,
name|sc
operator|->
name|mfi_sense_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_sense
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|mfi_sense_dmat
argument_list|,
name|sc
operator|->
name|mfi_sense
argument_list|,
name|sc
operator|->
name|mfi_sense_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_sense_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|mfi_sense_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_frames_busaddr
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|mfi_frames_dmat
argument_list|,
name|sc
operator|->
name|mfi_frames_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_frames
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|mfi_frames_dmat
argument_list|,
name|sc
operator|->
name|mfi_frames
argument_list|,
name|sc
operator|->
name|mfi_frames_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_frames_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|mfi_frames_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_comms_busaddr
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|mfi_comms_dmat
argument_list|,
name|sc
operator|->
name|mfi_comms_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_comms
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|mfi_comms_dmat
argument_list|,
name|sc
operator|->
name|mfi_comms
argument_list|,
name|sc
operator|->
name|mfi_comms_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_comms_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|mfi_comms_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_buffer_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_parent_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|mfi_parent_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
condition|)
block|{
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|sx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|mfi_config_lock
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|mfi_startup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|mfi_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|mfi_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|config_intrhook_disestablish
argument_list|(
operator|&
name|sc
operator|->
name|mfi_ich
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mfi_enable_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_config_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|mfi_ldprobe
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_config_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mfi_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|mfi_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mfi_command
modifier|*
name|cm
decl_stmt|;
name|uint32_t
name|pi
decl_stmt|,
name|ci
decl_stmt|,
name|context
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|mfi_softc
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_check_clear_intr
argument_list|(
name|sc
argument_list|)
condition|)
return|return;
comment|/* 	 * Do a dummy read to flush the interrupt ACK that we just performed, 	 * ensuring that everything is really, truly consistent. 	 */
operator|(
name|void
operator|)
name|sc
operator|->
name|mfi_read_fw_status
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|pi
operator|=
name|sc
operator|->
name|mfi_comms
operator|->
name|hw_pi
expr_stmt|;
name|ci
operator|=
name|sc
operator|->
name|mfi_comms
operator|->
name|hw_ci
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|ci
operator|!=
name|pi
condition|)
block|{
name|context
operator|=
name|sc
operator|->
name|mfi_comms
operator|->
name|hw_reply_q
index|[
name|ci
index|]
expr_stmt|;
if|if
condition|(
name|context
operator|<
name|sc
operator|->
name|mfi_max_fw_cmds
condition|)
block|{
name|cm
operator|=
operator|&
name|sc
operator|->
name|mfi_commands
index|[
name|context
index|]
expr_stmt|;
name|mfi_remove_busy
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_error
operator|=
literal|0
expr_stmt|;
name|mfi_complete
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|ci
operator|==
operator|(
name|sc
operator|->
name|mfi_max_fw_cmds
operator|+
literal|1
operator|)
condition|)
block|{
name|ci
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|mfi_comms
operator|->
name|hw_ci
operator|=
name|ci
expr_stmt|;
comment|/* Give defered I/O a chance to run */
if|if
condition|(
name|sc
operator|->
name|mfi_flags
operator|&
name|MFI_FLAGS_QFRZN
condition|)
name|sc
operator|->
name|mfi_flags
operator|&=
operator|~
name|MFI_FLAGS_QFRZN
expr_stmt|;
name|mfi_startio
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|int
name|mfi_shutdown
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mfi_dcmd_frame
modifier|*
name|dcmd
decl_stmt|;
name|struct
name|mfi_command
modifier|*
name|cm
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|mfi_dcmd_command
argument_list|(
name|sc
argument_list|,
operator|&
name|cm
argument_list|,
name|MFI_DCMD_CTRL_SHUTDOWN
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|mfi_aen_cm
operator|!=
name|NULL
condition|)
name|mfi_abort
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mfi_aen_cm
argument_list|)
expr_stmt|;
name|dcmd
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|dcmd
expr_stmt|;
name|dcmd
operator|->
name|header
operator|.
name|flags
operator|=
name|MFI_FRAME_DIR_NONE
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator|=
name|MFI_CMD_POLLED
expr_stmt|;
name|cm
operator|->
name|cm_data
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|mfi_mapcmd
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Failed to shutdown controller\n"
argument_list|)
expr_stmt|;
block|}
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mfi_ldprobe
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mfi_frame_header
modifier|*
name|hdr
decl_stmt|;
name|struct
name|mfi_command
modifier|*
name|cm
init|=
name|NULL
decl_stmt|;
name|struct
name|mfi_ld_list
modifier|*
name|list
init|=
name|NULL
decl_stmt|;
name|struct
name|mfi_disk
modifier|*
name|ld
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|sc
operator|->
name|mfi_config_lock
argument_list|,
name|SA_XLOCKED
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|error
operator|=
name|mfi_dcmd_command
argument_list|(
name|sc
argument_list|,
operator|&
name|cm
argument_list|,
name|MFI_DCMD_LD_GET_LIST
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|list
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|list
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|cm
operator|->
name|cm_flags
operator|=
name|MFI_CMD_DATAIN
expr_stmt|;
if|if
condition|(
name|mfi_wait_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Failed to get device listing\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|hdr
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|header
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|cmd_status
operator|!=
name|MFI_STAT_OK
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"MFI_DCMD_LD_GET_LIST failed %x\n"
argument_list|,
name|hdr
operator|->
name|cmd_status
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|list
operator|->
name|ld_count
condition|;
name|i
operator|++
control|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|ld
argument_list|,
argument|&sc->mfi_ld_tqh
argument_list|,
argument|ld_link
argument_list|)
block|{
if|if
condition|(
name|ld
operator|->
name|ld_id
operator|==
name|list
operator|->
name|ld_list
index|[
name|i
index|]
operator|.
name|ld
operator|.
name|v
operator|.
name|target_id
condition|)
goto|goto
name|skip_add
goto|;
block|}
name|mfi_add_ld
argument_list|(
name|sc
argument_list|,
name|list
operator|->
name|ld_list
index|[
name|i
index|]
operator|.
name|ld
operator|.
name|v
operator|.
name|target_id
argument_list|)
expr_stmt|;
name|skip_add
label|:
empty_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|list
condition|)
name|free
argument_list|(
name|list
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
condition|)
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * The timestamp is the number of seconds since 00:00 Jan 1, 2000.  If  * the bits in 24-31 are all set, then it is the number of seconds since  * boot.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|format_timestamp
parameter_list|(
name|uint32_t
name|timestamp
parameter_list|)
block|{
specifier|static
name|char
name|buffer
index|[
literal|32
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|timestamp
operator|&
literal|0xff000000
operator|)
operator|==
literal|0xff000000
condition|)
name|snprintf
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
literal|"boot + %us"
argument_list|,
name|timestamp
operator|&
literal|0x00ffffff
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
literal|"%us"
argument_list|,
name|timestamp
argument_list|)
expr_stmt|;
return|return
operator|(
name|buffer
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|format_class
parameter_list|(
name|int8_t
name|class
parameter_list|)
block|{
specifier|static
name|char
name|buffer
index|[
literal|6
index|]
decl_stmt|;
switch|switch
condition|(
name|class
condition|)
block|{
case|case
name|MFI_EVT_CLASS_DEBUG
case|:
return|return
operator|(
literal|"debug"
operator|)
return|;
case|case
name|MFI_EVT_CLASS_PROGRESS
case|:
return|return
operator|(
literal|"progress"
operator|)
return|;
case|case
name|MFI_EVT_CLASS_INFO
case|:
return|return
operator|(
literal|"info"
operator|)
return|;
case|case
name|MFI_EVT_CLASS_WARNING
case|:
return|return
operator|(
literal|"WARN"
operator|)
return|;
case|case
name|MFI_EVT_CLASS_CRITICAL
case|:
return|return
operator|(
literal|"CRIT"
operator|)
return|;
case|case
name|MFI_EVT_CLASS_FATAL
case|:
return|return
operator|(
literal|"FATAL"
operator|)
return|;
case|case
name|MFI_EVT_CLASS_DEAD
case|:
return|return
operator|(
literal|"DEAD"
operator|)
return|;
default|default:
name|snprintf
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|class
argument_list|)
expr_stmt|;
return|return
operator|(
name|buffer
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mfi_decode_evt
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mfi_evt_detail
modifier|*
name|detail
parameter_list|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"%d (%s/0x%04x/%s) - %s\n"
argument_list|,
name|detail
operator|->
name|seq
argument_list|,
name|format_timestamp
argument_list|(
name|detail
operator|->
name|time
argument_list|)
argument_list|,
name|detail
operator|->
name|evt_class
operator|.
name|members
operator|.
name|locale
argument_list|,
name|format_class
argument_list|(
name|detail
operator|->
name|evt_class
operator|.
name|members
operator|.
name|evt_class
argument_list|)
argument_list|,
name|detail
operator|->
name|description
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_aen_register
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|seq
parameter_list|,
name|int
name|locale
parameter_list|)
block|{
name|struct
name|mfi_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|mfi_dcmd_frame
modifier|*
name|dcmd
decl_stmt|;
name|union
name|mfi_evt
name|current_aen
decl_stmt|,
name|prior_aen
decl_stmt|;
name|struct
name|mfi_evt_detail
modifier|*
name|ed
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|current_aen
operator|.
name|word
operator|=
name|locale
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_aen_cm
operator|!=
name|NULL
condition|)
block|{
name|prior_aen
operator|.
name|word
operator|=
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|sc
operator|->
name|mfi_aen_cm
operator|->
name|cm_frame
operator|->
name|dcmd
operator|.
name|mbox
operator|)
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|prior_aen
operator|.
name|members
operator|.
name|evt_class
operator|<=
name|current_aen
operator|.
name|members
operator|.
name|evt_class
operator|&&
operator|!
operator|(
operator|(
name|prior_aen
operator|.
name|members
operator|.
name|locale
operator|&
name|current_aen
operator|.
name|members
operator|.
name|locale
operator|)
operator|^
name|current_aen
operator|.
name|members
operator|.
name|locale
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|prior_aen
operator|.
name|members
operator|.
name|locale
operator||=
name|current_aen
operator|.
name|members
operator|.
name|locale
expr_stmt|;
if|if
condition|(
name|prior_aen
operator|.
name|members
operator|.
name|evt_class
operator|<
name|current_aen
operator|.
name|members
operator|.
name|evt_class
condition|)
name|current_aen
operator|.
name|members
operator|.
name|evt_class
operator|=
name|prior_aen
operator|.
name|members
operator|.
name|evt_class
expr_stmt|;
name|mfi_abort
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mfi_aen_cm
argument_list|)
expr_stmt|;
block|}
block|}
name|error
operator|=
name|mfi_dcmd_command
argument_list|(
name|sc
argument_list|,
operator|&
name|cm
argument_list|,
name|MFI_DCMD_CTRL_EVENT_WAIT
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|ed
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ed
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|out
goto|;
block|}
name|dcmd
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|dcmd
expr_stmt|;
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|dcmd
operator|->
name|mbox
operator|)
index|[
literal|0
index|]
operator|=
name|seq
expr_stmt|;
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|dcmd
operator|->
name|mbox
operator|)
index|[
literal|1
index|]
operator|=
name|locale
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator|=
name|MFI_CMD_DATAIN
expr_stmt|;
name|cm
operator|->
name|cm_complete
operator|=
name|mfi_aen_complete
expr_stmt|;
name|sc
operator|->
name|mfi_aen_cm
operator|=
name|cm
expr_stmt|;
name|mfi_enqueue_ready
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|mfi_startio
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|out
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mfi_aen_complete
parameter_list|(
name|struct
name|mfi_command
modifier|*
name|cm
parameter_list|)
block|{
name|struct
name|mfi_frame_header
modifier|*
name|hdr
decl_stmt|;
name|struct
name|mfi_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mfi_evt_detail
modifier|*
name|detail
decl_stmt|;
name|struct
name|mfi_aen
modifier|*
name|mfi_aen_entry
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|int
name|seq
init|=
literal|0
decl_stmt|,
name|aborted
init|=
literal|0
decl_stmt|;
name|sc
operator|=
name|cm
operator|->
name|cm_sc
expr_stmt|;
name|hdr
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|header
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_aen_cm
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|sc
operator|->
name|mfi_aen_cm
operator|->
name|cm_aen_abort
operator|||
name|hdr
operator|->
name|cmd_status
operator|==
name|MFI_STAT_INVALID_STATUS
condition|)
block|{
name|sc
operator|->
name|mfi_aen_cm
operator|->
name|cm_aen_abort
operator|=
literal|0
expr_stmt|;
name|aborted
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|mfi_aen_triggered
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_poll_waiting
condition|)
block|{
name|sc
operator|->
name|mfi_poll_waiting
operator|=
literal|0
expr_stmt|;
name|selwakeup
argument_list|(
operator|&
name|sc
operator|->
name|mfi_select
argument_list|)
expr_stmt|;
block|}
name|detail
operator|=
name|cm
operator|->
name|cm_data
expr_stmt|;
comment|/* 		 * XXX If this function is too expensive or is recursive, then 		 * events should be put onto a queue and processed later. 		 */
name|mfi_decode_evt
argument_list|(
name|sc
argument_list|,
name|detail
argument_list|)
expr_stmt|;
name|seq
operator|=
name|detail
operator|->
name|seq
operator|+
literal|1
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|mfi_aen_entry
argument_list|,
argument|&sc->mfi_aen_pids
argument_list|,
argument|aen_link
argument_list|,
argument|tmp
argument_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|mfi_aen_pids
argument_list|,
name|mfi_aen_entry
argument_list|,
name|aen_link
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|mfi_aen_entry
operator|->
name|p
argument_list|)
expr_stmt|;
name|kern_psignal
argument_list|(
name|mfi_aen_entry
operator|->
name|p
argument_list|,
name|SIGIO
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|mfi_aen_entry
operator|->
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mfi_aen_entry
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|cm
operator|->
name|cm_data
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mfi_aen_cm
operator|=
name|NULL
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|mfi_aen_cm
argument_list|)
expr_stmt|;
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
comment|/* set it up again so the driver can catch more events */
if|if
condition|(
operator|!
name|aborted
condition|)
block|{
name|mfi_aen_setup
argument_list|(
name|sc
argument_list|,
name|seq
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|MAX_EVENTS
value|15
end_define

begin_function
specifier|static
name|int
name|mfi_parse_entries
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|start_seq
parameter_list|,
name|int
name|stop_seq
parameter_list|)
block|{
name|struct
name|mfi_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|mfi_dcmd_frame
modifier|*
name|dcmd
decl_stmt|;
name|struct
name|mfi_evt_list
modifier|*
name|el
decl_stmt|;
name|union
name|mfi_evt
name|class_locale
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|seq
decl_stmt|,
name|size
decl_stmt|;
name|class_locale
operator|.
name|members
operator|.
name|reserved
operator|=
literal|0
expr_stmt|;
name|class_locale
operator|.
name|members
operator|.
name|locale
operator|=
name|mfi_event_locale
expr_stmt|;
name|class_locale
operator|.
name|members
operator|.
name|evt_class
operator|=
name|mfi_event_class
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mfi_evt_list
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|mfi_evt_detail
argument_list|)
operator|*
operator|(
name|MAX_EVENTS
operator|-
literal|1
operator|)
expr_stmt|;
name|el
operator|=
name|malloc
argument_list|(
name|size
argument_list|,
name|M_MFIBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|el
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
for|for
control|(
name|seq
operator|=
name|start_seq
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|cm
operator|=
name|mfi_dequeue_free
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|el
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|dcmd
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|dcmd
expr_stmt|;
name|bzero
argument_list|(
name|dcmd
operator|->
name|mbox
argument_list|,
name|MFI_MBOX_SIZE
argument_list|)
expr_stmt|;
name|dcmd
operator|->
name|header
operator|.
name|cmd
operator|=
name|MFI_CMD_DCMD
expr_stmt|;
name|dcmd
operator|->
name|header
operator|.
name|timeout
operator|=
literal|0
expr_stmt|;
name|dcmd
operator|->
name|header
operator|.
name|data_len
operator|=
name|size
expr_stmt|;
name|dcmd
operator|->
name|opcode
operator|=
name|MFI_DCMD_CTRL_EVENT_GET
expr_stmt|;
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|dcmd
operator|->
name|mbox
operator|)
index|[
literal|0
index|]
operator|=
name|seq
expr_stmt|;
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|dcmd
operator|->
name|mbox
operator|)
index|[
literal|1
index|]
operator|=
name|class_locale
operator|.
name|word
expr_stmt|;
name|cm
operator|->
name|cm_sg
operator|=
operator|&
name|dcmd
operator|->
name|sgl
expr_stmt|;
name|cm
operator|->
name|cm_total_frame_size
operator|=
name|MFI_DCMD_FRAME_SIZE
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator|=
name|MFI_CMD_DATAIN
operator||
name|MFI_CMD_POLLED
expr_stmt|;
name|cm
operator|->
name|cm_data
operator|=
name|el
expr_stmt|;
name|cm
operator|->
name|cm_len
operator|=
name|size
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|mfi_mapcmd
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Failed to get controller entries\n"
argument_list|)
expr_stmt|;
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
break|break;
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|dcmd
operator|->
name|header
operator|.
name|cmd_status
operator|==
name|MFI_STAT_NOT_FOUND
condition|)
block|{
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dcmd
operator|->
name|header
operator|.
name|cmd_status
operator|!=
name|MFI_STAT_OK
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Error %d fetching controller entries\n"
argument_list|,
name|dcmd
operator|->
name|header
operator|.
name|cmd_status
argument_list|)
expr_stmt|;
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
break|break;
block|}
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|el
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
comment|/* 			 * If this event is newer than 'stop_seq' then 			 * break out of the loop.  Note that the log 			 * is a circular buffer so we have to handle 			 * the case that our stop point is earlier in 			 * the buffer than our start point. 			 */
if|if
condition|(
name|el
operator|->
name|event
index|[
name|i
index|]
operator|.
name|seq
operator|>=
name|stop_seq
condition|)
block|{
if|if
condition|(
name|start_seq
operator|<=
name|stop_seq
condition|)
break|break;
elseif|else
if|if
condition|(
name|el
operator|->
name|event
index|[
name|i
index|]
operator|.
name|seq
operator|<
name|start_seq
condition|)
break|break;
block|}
name|mfi_decode_evt
argument_list|(
name|sc
argument_list|,
operator|&
name|el
operator|->
name|event
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|seq
operator|=
name|el
operator|->
name|event
index|[
name|el
operator|->
name|count
operator|-
literal|1
index|]
operator|.
name|seq
operator|+
literal|1
expr_stmt|;
block|}
name|free
argument_list|(
name|el
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_add_ld
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|struct
name|mfi_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|mfi_dcmd_frame
modifier|*
name|dcmd
init|=
name|NULL
decl_stmt|;
name|struct
name|mfi_ld_info
modifier|*
name|ld_info
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|error
operator|=
name|mfi_dcmd_command
argument_list|(
name|sc
argument_list|,
operator|&
name|cm
argument_list|,
name|MFI_DCMD_LD_GET_INFO
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|ld_info
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ld_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Failed to allocate for MFI_DCMD_LD_GET_INFO %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|ld_info
condition|)
name|free
argument_list|(
name|ld_info
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|cm
operator|->
name|cm_flags
operator|=
name|MFI_CMD_DATAIN
expr_stmt|;
name|dcmd
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|dcmd
expr_stmt|;
name|dcmd
operator|->
name|mbox
index|[
literal|0
index|]
operator|=
name|id
expr_stmt|;
if|if
condition|(
name|mfi_wait_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Failed to get logical drive: %d\n"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ld_info
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|mfi_add_ld_complete
argument_list|(
name|cm
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mfi_add_ld_complete
parameter_list|(
name|struct
name|mfi_command
modifier|*
name|cm
parameter_list|)
block|{
name|struct
name|mfi_frame_header
modifier|*
name|hdr
decl_stmt|;
name|struct
name|mfi_ld_info
modifier|*
name|ld_info
decl_stmt|;
name|struct
name|mfi_softc
modifier|*
name|sc
decl_stmt|;
name|device_t
name|child
decl_stmt|;
name|sc
operator|=
name|cm
operator|->
name|cm_sc
expr_stmt|;
name|hdr
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|header
expr_stmt|;
name|ld_info
operator|=
name|cm
operator|->
name|cm_private
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|cmd_status
operator|!=
name|MFI_STAT_OK
condition|)
block|{
name|free
argument_list|(
name|ld_info
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
return|return;
block|}
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|child
operator|=
name|device_add_child
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"mfid"
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Failed to add logical disk\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ld_info
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|device_set_ivars
argument_list|(
name|child
argument_list|,
name|ld_info
argument_list|)
expr_stmt|;
name|device_set_desc
argument_list|(
name|child
argument_list|,
literal|"MFI Logical Disk"
argument_list|)
expr_stmt|;
name|bus_generic_attach
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mfi_command
modifier|*
name|mfi_bio_command
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mfi_io_frame
modifier|*
name|io
decl_stmt|;
name|struct
name|mfi_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|bio
modifier|*
name|bio
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|blkcount
decl_stmt|;
if|if
condition|(
operator|(
name|cm
operator|=
name|mfi_dequeue_free
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|(
name|bio
operator|=
name|mfi_dequeue_bio
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|io
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|io
expr_stmt|;
switch|switch
condition|(
name|bio
operator|->
name|bio_cmd
operator|&
literal|0x03
condition|)
block|{
case|case
name|BIO_READ
case|:
name|io
operator|->
name|header
operator|.
name|cmd
operator|=
name|MFI_CMD_LD_READ
expr_stmt|;
name|flags
operator|=
name|MFI_CMD_DATAIN
expr_stmt|;
break|break;
case|case
name|BIO_WRITE
case|:
name|io
operator|->
name|header
operator|.
name|cmd
operator|=
name|MFI_CMD_LD_WRITE
expr_stmt|;
name|flags
operator|=
name|MFI_CMD_DATAOUT
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"Invalid bio command"
argument_list|)
expr_stmt|;
block|}
comment|/* Cheat with the sector length to avoid a non-constant division */
name|blkcount
operator|=
operator|(
name|bio
operator|->
name|bio_bcount
operator|+
name|MFI_SECTOR_LEN
operator|-
literal|1
operator|)
operator|/
name|MFI_SECTOR_LEN
expr_stmt|;
name|io
operator|->
name|header
operator|.
name|target_id
operator|=
operator|(
name|uintptr_t
operator|)
name|bio
operator|->
name|bio_driver1
expr_stmt|;
name|io
operator|->
name|header
operator|.
name|timeout
operator|=
literal|0
expr_stmt|;
name|io
operator|->
name|header
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|io
operator|->
name|header
operator|.
name|sense_len
operator|=
name|MFI_SENSE_LEN
expr_stmt|;
name|io
operator|->
name|header
operator|.
name|data_len
operator|=
name|blkcount
expr_stmt|;
name|io
operator|->
name|sense_addr_lo
operator|=
name|cm
operator|->
name|cm_sense_busaddr
expr_stmt|;
name|io
operator|->
name|sense_addr_hi
operator|=
literal|0
expr_stmt|;
name|io
operator|->
name|lba_hi
operator|=
operator|(
name|bio
operator|->
name|bio_pblkno
operator|&
literal|0xffffffff00000000
operator|)
operator|>>
literal|32
expr_stmt|;
name|io
operator|->
name|lba_lo
operator|=
name|bio
operator|->
name|bio_pblkno
operator|&
literal|0xffffffff
expr_stmt|;
name|cm
operator|->
name|cm_complete
operator|=
name|mfi_bio_complete
expr_stmt|;
name|cm
operator|->
name|cm_private
operator|=
name|bio
expr_stmt|;
name|cm
operator|->
name|cm_data
operator|=
name|bio
operator|->
name|bio_data
expr_stmt|;
name|cm
operator|->
name|cm_len
operator|=
name|bio
operator|->
name|bio_bcount
expr_stmt|;
name|cm
operator|->
name|cm_sg
operator|=
operator|&
name|io
operator|->
name|sgl
expr_stmt|;
name|cm
operator|->
name|cm_total_frame_size
operator|=
name|MFI_IO_FRAME_SIZE
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator|=
name|flags
expr_stmt|;
return|return
operator|(
name|cm
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mfi_bio_complete
parameter_list|(
name|struct
name|mfi_command
modifier|*
name|cm
parameter_list|)
block|{
name|struct
name|bio
modifier|*
name|bio
decl_stmt|;
name|struct
name|mfi_frame_header
modifier|*
name|hdr
decl_stmt|;
name|struct
name|mfi_softc
modifier|*
name|sc
decl_stmt|;
name|bio
operator|=
name|cm
operator|->
name|cm_private
expr_stmt|;
name|hdr
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|header
expr_stmt|;
name|sc
operator|=
name|cm
operator|->
name|cm_sc
expr_stmt|;
if|if
condition|(
operator|(
name|hdr
operator|->
name|cmd_status
operator|!=
name|MFI_STAT_OK
operator|)
operator|||
operator|(
name|hdr
operator|->
name|scsi_status
operator|!=
literal|0
operator|)
condition|)
block|{
name|bio
operator|->
name|bio_flags
operator||=
name|BIO_ERROR
expr_stmt|;
name|bio
operator|->
name|bio_error
operator|=
name|EIO
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"I/O error, status= %d "
literal|"scsi_status= %d\n"
argument_list|,
name|hdr
operator|->
name|cmd_status
argument_list|,
name|hdr
operator|->
name|scsi_status
argument_list|)
expr_stmt|;
name|mfi_print_sense
argument_list|(
name|cm
operator|->
name|cm_sc
argument_list|,
name|cm
operator|->
name|cm_sense
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cm
operator|->
name|cm_error
operator|!=
literal|0
condition|)
block|{
name|bio
operator|->
name|bio_flags
operator||=
name|BIO_ERROR
expr_stmt|;
block|}
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|mfi_disk_complete
argument_list|(
name|bio
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mfi_startio
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mfi_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccbh
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Don't bother if we're short on resources */
if|if
condition|(
name|sc
operator|->
name|mfi_flags
operator|&
name|MFI_FLAGS_QFRZN
condition|)
break|break;
comment|/* Try a command that has already been prepared */
name|cm
operator|=
name|mfi_dequeue_ready
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|ccbh
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|mfi_cam_ccbq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|cm
operator|=
name|sc
operator|->
name|mfi_cam_start
argument_list|(
name|ccbh
argument_list|)
expr_stmt|;
block|}
comment|/* Nope, so look for work on the bioq */
if|if
condition|(
name|cm
operator|==
name|NULL
condition|)
name|cm
operator|=
name|mfi_bio_command
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* No work available, so exit */
if|if
condition|(
name|cm
operator|==
name|NULL
condition|)
break|break;
comment|/* Send the command to the controller */
if|if
condition|(
name|mfi_mapcmd
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mfi_requeue_ready
argument_list|(
name|cm
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_mapcmd
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mfi_command
modifier|*
name|cm
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|polled
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_data
operator|!=
name|NULL
condition|)
block|{
name|polled
operator|=
operator|(
name|cm
operator|->
name|cm_flags
operator|&
name|MFI_CMD_POLLED
operator|)
condition|?
name|BUS_DMA_NOWAIT
else|:
literal|0
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|,
name|cm
operator|->
name|cm_data
argument_list|,
name|cm
operator|->
name|cm_len
argument_list|,
name|mfi_data_cb
argument_list|,
name|cm
argument_list|,
name|polled
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINPROGRESS
condition|)
block|{
name|sc
operator|->
name|mfi_flags
operator||=
name|MFI_FLAGS_QFRZN
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
else|else
block|{
name|error
operator|=
name|mfi_send_frame
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mfi_data_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|mfi_frame_header
modifier|*
name|hdr
decl_stmt|;
name|struct
name|mfi_command
modifier|*
name|cm
decl_stmt|;
name|union
name|mfi_sgl
modifier|*
name|sgl
decl_stmt|;
name|struct
name|mfi_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|first
decl_stmt|,
name|dir
decl_stmt|;
name|cm
operator|=
operator|(
expr|struct
name|mfi_command
operator|*
operator|)
name|arg
expr_stmt|;
name|sc
operator|=
name|cm
operator|->
name|cm_sc
expr_stmt|;
name|hdr
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|header
expr_stmt|;
name|sgl
operator|=
name|cm
operator|->
name|cm_sg
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"error %d in callback\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_error
operator|=
name|error
expr_stmt|;
name|mfi_complete
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
return|return;
block|}
name|j
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|cmd
operator|==
name|MFI_CMD_STP
condition|)
block|{
name|first
operator|=
name|cm
operator|->
name|cm_stp_len
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|mfi_flags
operator|&
name|MFI_FLAGS_SG64
operator|)
operator|==
literal|0
condition|)
block|{
name|sgl
operator|->
name|sg32
index|[
name|j
index|]
operator|.
name|addr
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
name|sgl
operator|->
name|sg32
index|[
name|j
operator|++
index|]
operator|.
name|len
operator|=
name|first
expr_stmt|;
block|}
else|else
block|{
name|sgl
operator|->
name|sg64
index|[
name|j
index|]
operator|.
name|addr
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
name|sgl
operator|->
name|sg64
index|[
name|j
operator|++
index|]
operator|.
name|len
operator|=
name|first
expr_stmt|;
block|}
block|}
else|else
name|first
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|mfi_flags
operator|&
name|MFI_FLAGS_SG64
operator|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsegs
condition|;
name|i
operator|++
control|)
block|{
name|sgl
operator|->
name|sg32
index|[
name|j
index|]
operator|.
name|addr
operator|=
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
operator|+
name|first
expr_stmt|;
name|sgl
operator|->
name|sg32
index|[
name|j
operator|++
index|]
operator|.
name|len
operator|=
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
operator|-
name|first
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsegs
condition|;
name|i
operator|++
control|)
block|{
name|sgl
operator|->
name|sg64
index|[
name|j
index|]
operator|.
name|addr
operator|=
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
operator|+
name|first
expr_stmt|;
name|sgl
operator|->
name|sg64
index|[
name|j
operator|++
index|]
operator|.
name|len
operator|=
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
operator|-
name|first
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
name|hdr
operator|->
name|flags
operator||=
name|MFI_FRAME_SGL64
expr_stmt|;
block|}
name|hdr
operator|->
name|sg_count
operator|=
name|j
expr_stmt|;
name|dir
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|MFI_CMD_DATAIN
condition|)
block|{
name|dir
operator||=
name|BUS_DMASYNC_PREREAD
expr_stmt|;
name|hdr
operator|->
name|flags
operator||=
name|MFI_FRAME_DIR_READ
expr_stmt|;
block|}
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|MFI_CMD_DATAOUT
condition|)
block|{
name|dir
operator||=
name|BUS_DMASYNC_PREWRITE
expr_stmt|;
name|hdr
operator|->
name|flags
operator||=
name|MFI_FRAME_DIR_WRITE
expr_stmt|;
block|}
if|if
condition|(
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|cmd
operator|==
name|MFI_CMD_STP
condition|)
name|dir
operator||=
name|BUS_DMASYNC_PREWRITE
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator||=
name|MFI_CMD_MAPPED
expr_stmt|;
comment|/* 	 * Instead of calculating the total number of frames in the 	 * compound frame, it's already assumed that there will be at 	 * least 1 frame, so don't compensate for the modulo of the 	 * following division. 	 */
name|cm
operator|->
name|cm_total_frame_size
operator|+=
operator|(
name|sc
operator|->
name|mfi_sge_size
operator|*
name|nsegs
operator|)
expr_stmt|;
name|cm
operator|->
name|cm_extra_frames
operator|=
operator|(
name|cm
operator|->
name|cm_total_frame_size
operator|-
literal|1
operator|)
operator|/
name|MFI_FRAME_SIZE
expr_stmt|;
name|mfi_send_frame
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_send_frame
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mfi_command
modifier|*
name|cm
parameter_list|)
block|{
name|struct
name|mfi_frame_header
modifier|*
name|hdr
decl_stmt|;
name|int
name|tm
init|=
name|MFI_POLL_TIMEOUT_SECS
operator|*
literal|1000
decl_stmt|;
name|hdr
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|header
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|->
name|cm_flags
operator|&
name|MFI_CMD_POLLED
operator|)
operator|==
literal|0
condition|)
block|{
name|cm
operator|->
name|cm_timestamp
operator|=
name|time_uptime
expr_stmt|;
name|mfi_enqueue_busy
argument_list|(
name|cm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hdr
operator|->
name|cmd_status
operator|=
name|MFI_STAT_INVALID_STATUS
expr_stmt|;
name|hdr
operator|->
name|flags
operator||=
name|MFI_FRAME_DONT_POST_IN_REPLY_QUEUE
expr_stmt|;
block|}
comment|/* 	 * The bus address of the command is aligned on a 64 byte boundary, 	 * leaving the least 6 bits as zero.  For whatever reason, the 	 * hardware wants the address shifted right by three, leaving just 	 * 3 zero bits.  These three bits are then used as a prefetching 	 * hint for the hardware to predict how many frames need to be 	 * fetched across the bus.  If a command has more than 8 frames 	 * then the 3 bits are set to 0x7 and the firmware uses other 	 * information in the command to determine the total amount to fetch. 	 * However, FreeBSD doesn't support I/O larger than 128K, so 8 frames 	 * is enough for both 32bit and 64bit systems. 	 */
if|if
condition|(
name|cm
operator|->
name|cm_extra_frames
operator|>
literal|7
condition|)
name|cm
operator|->
name|cm_extra_frames
operator|=
literal|7
expr_stmt|;
name|sc
operator|->
name|mfi_issue_cmd
argument_list|(
name|sc
argument_list|,
name|cm
operator|->
name|cm_frame_busaddr
argument_list|,
name|cm
operator|->
name|cm_extra_frames
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|->
name|cm_flags
operator|&
name|MFI_CMD_POLLED
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* This is a polled command, so busy-wait for it to complete. */
while|while
condition|(
name|hdr
operator|->
name|cmd_status
operator|==
name|MFI_STAT_INVALID_STATUS
condition|)
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|tm
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|tm
operator|<=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|hdr
operator|->
name|cmd_status
operator|==
name|MFI_STAT_INVALID_STATUS
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Frame %p timed out "
literal|"command 0x%X\n"
argument_list|,
name|hdr
argument_list|,
name|cm
operator|->
name|cm_frame
operator|->
name|dcmd
operator|.
name|opcode
argument_list|)
expr_stmt|;
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mfi_complete
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mfi_command
modifier|*
name|cm
parameter_list|)
block|{
name|int
name|dir
decl_stmt|;
if|if
condition|(
operator|(
name|cm
operator|->
name|cm_flags
operator|&
name|MFI_CMD_MAPPED
operator|)
operator|!=
literal|0
condition|)
block|{
name|dir
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|->
name|cm_flags
operator|&
name|MFI_CMD_DATAIN
operator|)
operator|||
operator|(
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|cmd
operator|==
name|MFI_CMD_STP
operator|)
condition|)
name|dir
operator||=
name|BUS_DMASYNC_POSTREAD
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|MFI_CMD_DATAOUT
condition|)
name|dir
operator||=
name|BUS_DMASYNC_POSTWRITE
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator|&=
operator|~
name|MFI_CMD_MAPPED
expr_stmt|;
block|}
name|cm
operator|->
name|cm_flags
operator||=
name|MFI_CMD_COMPLETED
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_complete
operator|!=
name|NULL
condition|)
name|cm
operator|->
name|cm_complete
argument_list|(
name|cm
argument_list|)
expr_stmt|;
else|else
name|wakeup
argument_list|(
name|cm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_abort
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mfi_command
modifier|*
name|cm_abort
parameter_list|)
block|{
name|struct
name|mfi_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|mfi_abort_frame
modifier|*
name|abort
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|=
name|mfi_dequeue_free
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|abort
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|abort
expr_stmt|;
name|abort
operator|->
name|header
operator|.
name|cmd
operator|=
name|MFI_CMD_ABORT
expr_stmt|;
name|abort
operator|->
name|header
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|abort
operator|->
name|abort_context
operator|=
name|cm_abort
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|context
expr_stmt|;
name|abort
operator|->
name|abort_mfi_addr_lo
operator|=
name|cm_abort
operator|->
name|cm_frame_busaddr
expr_stmt|;
name|abort
operator|->
name|abort_mfi_addr_hi
operator|=
literal|0
expr_stmt|;
name|cm
operator|->
name|cm_data
operator|=
name|NULL
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator|=
name|MFI_CMD_POLLED
expr_stmt|;
name|sc
operator|->
name|mfi_aen_cm
operator|->
name|cm_aen_abort
operator|=
literal|1
expr_stmt|;
name|mfi_mapcmd
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
literal|5
operator|&&
name|sc
operator|->
name|mfi_aen_cm
operator|!=
name|NULL
condition|)
block|{
name|msleep
argument_list|(
operator|&
name|sc
operator|->
name|mfi_aen_cm
argument_list|,
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|,
literal|0
argument_list|,
literal|"mfiabort"
argument_list|,
literal|5
operator|*
name|hz
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mfi_dump_blocks
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|id
parameter_list|,
name|uint64_t
name|lba
parameter_list|,
name|void
modifier|*
name|virt
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|mfi_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|mfi_io_frame
modifier|*
name|io
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|cm
operator|=
name|mfi_dequeue_free
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|io
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|io
expr_stmt|;
name|io
operator|->
name|header
operator|.
name|cmd
operator|=
name|MFI_CMD_LD_WRITE
expr_stmt|;
name|io
operator|->
name|header
operator|.
name|target_id
operator|=
name|id
expr_stmt|;
name|io
operator|->
name|header
operator|.
name|timeout
operator|=
literal|0
expr_stmt|;
name|io
operator|->
name|header
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|io
operator|->
name|header
operator|.
name|sense_len
operator|=
name|MFI_SENSE_LEN
expr_stmt|;
name|io
operator|->
name|header
operator|.
name|data_len
operator|=
operator|(
name|len
operator|+
name|MFI_SECTOR_LEN
operator|-
literal|1
operator|)
operator|/
name|MFI_SECTOR_LEN
expr_stmt|;
name|io
operator|->
name|sense_addr_lo
operator|=
name|cm
operator|->
name|cm_sense_busaddr
expr_stmt|;
name|io
operator|->
name|sense_addr_hi
operator|=
literal|0
expr_stmt|;
name|io
operator|->
name|lba_hi
operator|=
operator|(
name|lba
operator|&
literal|0xffffffff00000000
operator|)
operator|>>
literal|32
expr_stmt|;
name|io
operator|->
name|lba_lo
operator|=
name|lba
operator|&
literal|0xffffffff
expr_stmt|;
name|cm
operator|->
name|cm_data
operator|=
name|virt
expr_stmt|;
name|cm
operator|->
name|cm_len
operator|=
name|len
expr_stmt|;
name|cm
operator|->
name|cm_sg
operator|=
operator|&
name|io
operator|->
name|sgl
expr_stmt|;
name|cm
operator|->
name|cm_total_frame_size
operator|=
name|MFI_IO_FRAME_SIZE
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator|=
name|MFI_CMD_POLLED
operator||
name|MFI_CMD_DATAOUT
expr_stmt|;
name|error
operator|=
name|mfi_mapcmd
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|)
expr_stmt|;
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|mfi_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_detaching
condition|)
name|error
operator|=
name|ENXIO
expr_stmt|;
else|else
block|{
name|sc
operator|->
name|mfi_flags
operator||=
name|MFI_FLAGS_OPEN
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|mfi_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mfi_aen
modifier|*
name|mfi_aen_entry
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mfi_flags
operator|&=
operator|~
name|MFI_FLAGS_OPEN
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|mfi_aen_entry
argument_list|,
argument|&sc->mfi_aen_pids
argument_list|,
argument|aen_link
argument_list|,
argument|tmp
argument_list|)
block|{
if|if
condition|(
name|mfi_aen_entry
operator|->
name|p
operator|==
name|curproc
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|mfi_aen_pids
argument_list|,
name|mfi_aen_entry
argument_list|,
name|aen_link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mfi_aen_entry
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_config_lock
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|opcode
parameter_list|)
block|{
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|MFI_DCMD_LD_DELETE
case|:
case|case
name|MFI_DCMD_CFG_ADD
case|:
case|case
name|MFI_DCMD_CFG_CLEAR
case|:
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_config_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mfi_config_unlock
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|locked
parameter_list|)
block|{
if|if
condition|(
name|locked
condition|)
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_config_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform pre-issue checks on commands from userland and possibly veto them. */
end_comment

begin_function
specifier|static
name|int
name|mfi_check_command_pre
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mfi_command
modifier|*
name|cm
parameter_list|)
block|{
name|struct
name|mfi_disk
modifier|*
name|ld
decl_stmt|,
modifier|*
name|ld2
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cm
operator|->
name|cm_frame
operator|->
name|dcmd
operator|.
name|opcode
condition|)
block|{
case|case
name|MFI_DCMD_LD_DELETE
case|:
name|TAILQ_FOREACH
argument_list|(
argument|ld
argument_list|,
argument|&sc->mfi_ld_tqh
argument_list|,
argument|ld_link
argument_list|)
block|{
if|if
condition|(
name|ld
operator|->
name|ld_id
operator|==
name|cm
operator|->
name|cm_frame
operator|->
name|dcmd
operator|.
name|mbox
index|[
literal|0
index|]
condition|)
break|break;
block|}
if|if
condition|(
name|ld
operator|==
name|NULL
condition|)
name|error
operator|=
name|ENOENT
expr_stmt|;
else|else
name|error
operator|=
name|mfi_disk_disable
argument_list|(
name|ld
argument_list|)
expr_stmt|;
break|break;
case|case
name|MFI_DCMD_CFG_CLEAR
case|:
name|TAILQ_FOREACH
argument_list|(
argument|ld
argument_list|,
argument|&sc->mfi_ld_tqh
argument_list|,
argument|ld_link
argument_list|)
block|{
name|error
operator|=
name|mfi_disk_disable
argument_list|(
name|ld
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|ld2
argument_list|,
argument|&sc->mfi_ld_tqh
argument_list|,
argument|ld_link
argument_list|)
block|{
if|if
condition|(
name|ld2
operator|==
name|ld
condition|)
break|break;
name|mfi_disk_enable
argument_list|(
name|ld2
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Perform post-issue checks on commands from userland. */
end_comment

begin_function
specifier|static
name|void
name|mfi_check_command_post
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mfi_command
modifier|*
name|cm
parameter_list|)
block|{
name|struct
name|mfi_disk
modifier|*
name|ld
decl_stmt|,
modifier|*
name|ldn
decl_stmt|;
switch|switch
condition|(
name|cm
operator|->
name|cm_frame
operator|->
name|dcmd
operator|.
name|opcode
condition|)
block|{
case|case
name|MFI_DCMD_LD_DELETE
case|:
name|TAILQ_FOREACH
argument_list|(
argument|ld
argument_list|,
argument|&sc->mfi_ld_tqh
argument_list|,
argument|ld_link
argument_list|)
block|{
if|if
condition|(
name|ld
operator|->
name|ld_id
operator|==
name|cm
operator|->
name|cm_frame
operator|->
name|dcmd
operator|.
name|mbox
index|[
literal|0
index|]
condition|)
break|break;
block|}
name|KASSERT
argument_list|(
name|ld
operator|!=
name|NULL
argument_list|,
operator|(
literal|"volume dissappeared"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|cmd_status
operator|==
name|MFI_STAT_OK
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|device_delete_child
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
name|ld
operator|->
name|ld_dev
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
block|}
else|else
name|mfi_disk_enable
argument_list|(
name|ld
argument_list|)
expr_stmt|;
break|break;
case|case
name|MFI_DCMD_CFG_CLEAR
case|:
if|if
condition|(
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|cmd_status
operator|==
name|MFI_STAT_OK
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|ld
argument_list|,
argument|&sc->mfi_ld_tqh
argument_list|,
argument|ld_link
argument_list|,
argument|ldn
argument_list|)
block|{
name|device_delete_child
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
name|ld
operator|->
name|ld_dev
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TAILQ_FOREACH
argument_list|(
argument|ld
argument_list|,
argument|&sc->mfi_ld_tqh
argument_list|,
argument|ld_link
argument_list|)
name|mfi_disk_enable
argument_list|(
name|ld
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MFI_DCMD_CFG_ADD
case|:
name|mfi_ldprobe
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|MFI_DCMD_CFG_FOREIGN_IMPORT
case|:
name|mfi_ldprobe
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_user_command
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mfi_ioc_passthru
modifier|*
name|ioc
parameter_list|)
block|{
name|struct
name|mfi_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|mfi_dcmd_frame
modifier|*
name|dcmd
decl_stmt|;
name|void
modifier|*
name|ioc_buf
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|context
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|locked
decl_stmt|;
if|if
condition|(
name|ioc
operator|->
name|buf_size
operator|>
literal|0
condition|)
block|{
name|ioc_buf
operator|=
name|malloc
argument_list|(
name|ioc
operator|->
name|buf_size
argument_list|,
name|M_MFIBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioc_buf
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|error
operator|=
name|copyin
argument_list|(
name|ioc
operator|->
name|buf
argument_list|,
name|ioc_buf
argument_list|,
name|ioc
operator|->
name|buf_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"failed to copyin\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ioc_buf
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|locked
operator|=
name|mfi_config_lock
argument_list|(
name|sc
argument_list|,
name|ioc
operator|->
name|ioc_frame
operator|.
name|opcode
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|cm
operator|=
name|mfi_dequeue_free
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|msleep
argument_list|(
name|mfi_user_command
argument_list|,
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|,
literal|0
argument_list|,
literal|"mfiioc"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
comment|/* Save context for later */
name|context
operator|=
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|context
expr_stmt|;
name|dcmd
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|dcmd
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|ioc
operator|->
name|ioc_frame
argument_list|,
name|dcmd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mfi_dcmd_frame
argument_list|)
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_sg
operator|=
operator|&
name|dcmd
operator|->
name|sgl
expr_stmt|;
name|cm
operator|->
name|cm_total_frame_size
operator|=
name|MFI_DCMD_FRAME_SIZE
expr_stmt|;
name|cm
operator|->
name|cm_data
operator|=
name|ioc_buf
expr_stmt|;
name|cm
operator|->
name|cm_len
operator|=
name|ioc
operator|->
name|buf_size
expr_stmt|;
comment|/* restore context */
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|context
operator|=
name|context
expr_stmt|;
comment|/* Cheat since we don't know if we're writing or reading */
name|cm
operator|->
name|cm_flags
operator|=
name|MFI_CMD_DATAIN
operator||
name|MFI_CMD_DATAOUT
expr_stmt|;
name|error
operator|=
name|mfi_check_command_pre
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
name|mfi_wait_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"ioctl failed %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|bcopy
argument_list|(
name|dcmd
argument_list|,
operator|&
name|ioc
operator|->
name|ioc_frame
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mfi_dcmd_frame
argument_list|)
argument_list|)
expr_stmt|;
name|mfi_check_command_post
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
name|out
label|:
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|mfi_config_unlock
argument_list|(
name|sc
argument_list|,
name|locked
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioc
operator|->
name|buf_size
operator|>
literal|0
condition|)
name|error
operator|=
name|copyout
argument_list|(
name|ioc_buf
argument_list|,
name|ioc
operator|->
name|buf
argument_list|,
name|ioc
operator|->
name|buf_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioc_buf
condition|)
name|free
argument_list|(
name|ioc_buf
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__amd64__
end_ifdef

begin_define
define|#
directive|define
name|PTRIN
parameter_list|(
name|p
parameter_list|)
value|((void *)(uintptr_t)(p))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PTRIN
parameter_list|(
name|p
parameter_list|)
value|(p)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|mfi_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|mfi_softc
modifier|*
name|sc
decl_stmt|;
name|union
name|mfi_statrequest
modifier|*
name|ms
decl_stmt|;
name|struct
name|mfi_ioc_packet
modifier|*
name|ioc
decl_stmt|;
ifdef|#
directive|ifdef
name|__amd64__
name|struct
name|mfi_ioc_packet32
modifier|*
name|ioc32
decl_stmt|;
endif|#
directive|endif
name|struct
name|mfi_ioc_aen
modifier|*
name|aen
decl_stmt|;
name|struct
name|mfi_command
modifier|*
name|cm
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|context
decl_stmt|;
name|union
name|mfi_sense_ptr
name|sense_ptr
decl_stmt|;
name|uint8_t
modifier|*
name|data
init|=
name|NULL
decl_stmt|,
modifier|*
name|temp
decl_stmt|,
modifier|*
name|addr
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|mfi_ioc_passthru
modifier|*
name|iop
init|=
operator|(
expr|struct
name|mfi_ioc_passthru
operator|*
operator|)
name|arg
decl_stmt|;
ifdef|#
directive|ifdef
name|__amd64__
name|struct
name|mfi_ioc_passthru32
modifier|*
name|iop32
init|=
operator|(
expr|struct
name|mfi_ioc_passthru32
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|mfi_ioc_passthru
name|iop_swab
decl_stmt|;
endif|#
directive|endif
name|int
name|error
decl_stmt|,
name|locked
decl_stmt|;
name|sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MFIIO_STATS
case|:
name|ms
operator|=
operator|(
expr|union
name|mfi_statrequest
operator|*
operator|)
name|arg
expr_stmt|;
switch|switch
condition|(
name|ms
operator|->
name|ms_item
condition|)
block|{
case|case
name|MFIQ_FREE
case|:
case|case
name|MFIQ_BIO
case|:
case|case
name|MFIQ_READY
case|:
case|case
name|MFIQ_BUSY
case|:
name|bcopy
argument_list|(
operator|&
name|sc
operator|->
name|mfi_qstat
index|[
name|ms
operator|->
name|ms_item
index|]
argument_list|,
operator|&
name|ms
operator|->
name|ms_qstat
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mfi_qstat
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ENOIOCTL
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|MFIIO_QUERY_DISK
case|:
block|{
name|struct
name|mfi_query_disk
modifier|*
name|qd
decl_stmt|;
name|struct
name|mfi_disk
modifier|*
name|ld
decl_stmt|;
name|qd
operator|=
operator|(
expr|struct
name|mfi_query_disk
operator|*
operator|)
name|arg
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ld
argument_list|,
argument|&sc->mfi_ld_tqh
argument_list|,
argument|ld_link
argument_list|)
block|{
if|if
condition|(
name|ld
operator|->
name|ld_id
operator|==
name|qd
operator|->
name|array_id
condition|)
break|break;
block|}
if|if
condition|(
name|ld
operator|==
name|NULL
condition|)
block|{
name|qd
operator|->
name|present
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|qd
operator|->
name|present
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ld
operator|->
name|ld_flags
operator|&
name|MFI_DISK_FLAGS_OPEN
condition|)
name|qd
operator|->
name|open
operator|=
literal|1
expr_stmt|;
name|bzero
argument_list|(
name|qd
operator|->
name|devname
argument_list|,
name|SPECNAMELEN
operator|+
literal|1
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|qd
operator|->
name|devname
argument_list|,
name|SPECNAMELEN
argument_list|,
literal|"mfid%d"
argument_list|,
name|ld
operator|->
name|ld_unit
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MFI_CMD
case|:
ifdef|#
directive|ifdef
name|__amd64__
case|case
name|MFI_CMD32
case|:
endif|#
directive|endif
block|{
name|devclass_t
name|devclass
decl_stmt|;
name|ioc
operator|=
operator|(
expr|struct
name|mfi_ioc_packet
operator|*
operator|)
name|arg
expr_stmt|;
name|int
name|adapter
decl_stmt|;
name|adapter
operator|=
name|ioc
operator|->
name|mfi_adapter_no
expr_stmt|;
if|if
condition|(
name|device_get_unit
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|)
operator|==
literal|0
operator|&&
name|adapter
operator|!=
literal|0
condition|)
block|{
name|devclass
operator|=
name|devclass_find
argument_list|(
literal|"mfi"
argument_list|)
expr_stmt|;
name|sc
operator|=
name|devclass_get_softc
argument_list|(
name|devclass
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|=
name|mfi_dequeue_free
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|locked
operator|=
literal|0
expr_stmt|;
comment|/* 		 * save off original context since copying from user 		 * will clobber some data 		 */
name|context
operator|=
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|context
expr_stmt|;
name|bcopy
argument_list|(
name|ioc
operator|->
name|mfi_frame
operator|.
name|raw
argument_list|,
name|cm
operator|->
name|cm_frame
argument_list|,
literal|2
operator|*
name|MFI_DCMD_FRAME_SIZE
argument_list|)
expr_stmt|;
comment|/* this isn't quite right */
name|cm
operator|->
name|cm_total_frame_size
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|union
name|mfi_sgl
argument_list|)
operator|*
name|ioc
operator|->
name|mfi_sge_count
operator|)
operator|+
name|ioc
operator|->
name|mfi_sgl_off
expr_stmt|;
if|if
condition|(
name|ioc
operator|->
name|mfi_sge_count
condition|)
block|{
name|cm
operator|->
name|cm_sg
operator|=
operator|(
expr|union
name|mfi_sgl
operator|*
operator|)
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|bytes
index|[
name|ioc
operator|->
name|mfi_sgl_off
index|]
expr_stmt|;
block|}
name|cm
operator|->
name|cm_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|flags
operator|&
name|MFI_FRAME_DATAIN
condition|)
name|cm
operator|->
name|cm_flags
operator||=
name|MFI_CMD_DATAIN
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|flags
operator|&
name|MFI_FRAME_DATAOUT
condition|)
name|cm
operator|->
name|cm_flags
operator||=
name|MFI_CMD_DATAOUT
expr_stmt|;
comment|/* Legacy app shim */
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|==
literal|0
condition|)
name|cm
operator|->
name|cm_flags
operator||=
name|MFI_CMD_DATAIN
operator||
name|MFI_CMD_DATAOUT
expr_stmt|;
name|cm
operator|->
name|cm_len
operator|=
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|data_len
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|cmd
operator|==
name|MFI_CMD_STP
condition|)
block|{
ifdef|#
directive|ifdef
name|__amd64__
if|if
condition|(
name|cmd
operator|==
name|MFI_CMD
condition|)
block|{
endif|#
directive|endif
comment|/* Native */
name|cm
operator|->
name|cm_stp_len
operator|=
name|ioc
operator|->
name|mfi_sgl
index|[
literal|0
index|]
operator|.
name|iov_len
expr_stmt|;
ifdef|#
directive|ifdef
name|__amd64__
block|}
else|else
block|{
comment|/* 32bit on 64bit */
name|ioc32
operator|=
operator|(
expr|struct
name|mfi_ioc_packet32
operator|*
operator|)
name|ioc
expr_stmt|;
name|cm
operator|->
name|cm_stp_len
operator|=
name|ioc32
operator|->
name|mfi_sgl
index|[
literal|0
index|]
operator|.
name|iov_len
expr_stmt|;
block|}
endif|#
directive|endif
name|cm
operator|->
name|cm_len
operator|+=
name|cm
operator|->
name|cm_stp_len
expr_stmt|;
block|}
if|if
condition|(
name|cm
operator|->
name|cm_len
operator|&&
operator|(
name|cm
operator|->
name|cm_flags
operator|&
operator|(
name|MFI_CMD_DATAIN
operator||
name|MFI_CMD_DATAOUT
operator|)
operator|)
condition|)
block|{
name|cm
operator|->
name|cm_data
operator|=
name|data
operator|=
name|malloc
argument_list|(
name|cm
operator|->
name|cm_len
argument_list|,
name|M_MFIBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_data
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Malloc failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
block|{
name|cm
operator|->
name|cm_data
operator|=
literal|0
expr_stmt|;
block|}
comment|/* restore header context */
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|context
operator|=
name|context
expr_stmt|;
name|temp
operator|=
name|data
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|->
name|cm_flags
operator|&
name|MFI_CMD_DATAOUT
operator|)
operator|||
operator|(
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|cmd
operator|==
name|MFI_CMD_STP
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ioc
operator|->
name|mfi_sge_count
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|__amd64__
if|if
condition|(
name|cmd
operator|==
name|MFI_CMD
condition|)
block|{
endif|#
directive|endif
comment|/* Native */
name|addr
operator|=
name|ioc
operator|->
name|mfi_sgl
index|[
name|i
index|]
operator|.
name|iov_base
expr_stmt|;
name|len
operator|=
name|ioc
operator|->
name|mfi_sgl
index|[
name|i
index|]
operator|.
name|iov_len
expr_stmt|;
ifdef|#
directive|ifdef
name|__amd64__
block|}
else|else
block|{
comment|/* 32bit on 64bit */
name|ioc32
operator|=
operator|(
expr|struct
name|mfi_ioc_packet32
operator|*
operator|)
name|ioc
expr_stmt|;
name|addr
operator|=
name|PTRIN
argument_list|(
name|ioc32
operator|->
name|mfi_sgl
index|[
name|i
index|]
operator|.
name|iov_base
argument_list|)
expr_stmt|;
name|len
operator|=
name|ioc32
operator|->
name|mfi_sgl
index|[
name|i
index|]
operator|.
name|iov_len
expr_stmt|;
block|}
endif|#
directive|endif
name|error
operator|=
name|copyin
argument_list|(
name|addr
argument_list|,
name|temp
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Copy in failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|temp
operator|=
operator|&
name|temp
index|[
name|len
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|cmd
operator|==
name|MFI_CMD_DCMD
condition|)
name|locked
operator|=
name|mfi_config_lock
argument_list|(
name|sc
argument_list|,
name|cm
operator|->
name|cm_frame
operator|->
name|dcmd
operator|.
name|opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|cmd
operator|==
name|MFI_CMD_PD_SCSI_IO
condition|)
block|{
name|cm
operator|->
name|cm_frame
operator|->
name|pass
operator|.
name|sense_addr_lo
operator|=
name|cm
operator|->
name|cm_sense_busaddr
expr_stmt|;
name|cm
operator|->
name|cm_frame
operator|->
name|pass
operator|.
name|sense_addr_hi
operator|=
literal|0
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|mfi_check_command_pre
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|mfi_wait_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Controller polled failed\n"
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|mfi_check_command_post
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|temp
operator|=
name|data
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|->
name|cm_flags
operator|&
name|MFI_CMD_DATAIN
operator|)
operator|||
operator|(
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|cmd
operator|==
name|MFI_CMD_STP
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ioc
operator|->
name|mfi_sge_count
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|__amd64__
if|if
condition|(
name|cmd
operator|==
name|MFI_CMD
condition|)
block|{
endif|#
directive|endif
comment|/* Native */
name|addr
operator|=
name|ioc
operator|->
name|mfi_sgl
index|[
name|i
index|]
operator|.
name|iov_base
expr_stmt|;
name|len
operator|=
name|ioc
operator|->
name|mfi_sgl
index|[
name|i
index|]
operator|.
name|iov_len
expr_stmt|;
ifdef|#
directive|ifdef
name|__amd64__
block|}
else|else
block|{
comment|/* 32bit on 64bit */
name|ioc32
operator|=
operator|(
expr|struct
name|mfi_ioc_packet32
operator|*
operator|)
name|ioc
expr_stmt|;
name|addr
operator|=
name|PTRIN
argument_list|(
name|ioc32
operator|->
name|mfi_sgl
index|[
name|i
index|]
operator|.
name|iov_base
argument_list|)
expr_stmt|;
name|len
operator|=
name|ioc32
operator|->
name|mfi_sgl
index|[
name|i
index|]
operator|.
name|iov_len
expr_stmt|;
block|}
endif|#
directive|endif
name|error
operator|=
name|copyout
argument_list|(
name|temp
argument_list|,
name|addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Copy out failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|temp
operator|=
operator|&
name|temp
index|[
name|len
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ioc
operator|->
name|mfi_sense_len
condition|)
block|{
comment|/* get user-space sense ptr then copy out sense */
name|bcopy
argument_list|(
operator|&
name|ioc
operator|->
name|mfi_frame
operator|.
name|raw
index|[
name|ioc
operator|->
name|mfi_sense_off
index|]
argument_list|,
operator|&
name|sense_ptr
operator|.
name|sense_ptr_data
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|sense_ptr
operator|.
name|sense_ptr_data
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__amd64__
if|if
condition|(
name|cmd
operator|!=
name|MFI_CMD
condition|)
block|{
comment|/* 				 * not 64bit native so zero out any address 				 * over 32bit */
name|sense_ptr
operator|.
name|addr
operator|.
name|high
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|error
operator|=
name|copyout
argument_list|(
name|cm
operator|->
name|cm_sense
argument_list|,
name|sense_ptr
operator|.
name|user_space
argument_list|,
name|ioc
operator|->
name|mfi_sense_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Copy out failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|ioc
operator|->
name|mfi_frame
operator|.
name|hdr
operator|.
name|cmd_status
operator|=
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|cmd_status
expr_stmt|;
name|out
label|:
name|mfi_config_unlock
argument_list|(
name|sc
argument_list|,
name|locked
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
condition|)
name|free
argument_list|(
name|data
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|MFI_SET_AEN
case|:
name|aen
operator|=
operator|(
expr|struct
name|mfi_ioc_aen
operator|*
operator|)
name|arg
expr_stmt|;
name|error
operator|=
name|mfi_aen_register
argument_list|(
name|sc
argument_list|,
name|aen
operator|->
name|aen_seq_num
argument_list|,
name|aen
operator|->
name|aen_class_locale
argument_list|)
expr_stmt|;
break|break;
case|case
name|MFI_LINUX_CMD_2
case|:
comment|/* Firmware Linux ioctl shim */
block|{
name|devclass_t
name|devclass
decl_stmt|;
name|struct
name|mfi_linux_ioc_packet
name|l_ioc
decl_stmt|;
name|int
name|adapter
decl_stmt|;
name|devclass
operator|=
name|devclass_find
argument_list|(
literal|"mfi"
argument_list|)
expr_stmt|;
if|if
condition|(
name|devclass
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|error
operator|=
name|copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|l_ioc
argument_list|,
sizeof|sizeof
argument_list|(
name|l_ioc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|adapter
operator|=
name|l_ioc
operator|.
name|lioc_adapter_no
expr_stmt|;
name|sc
operator|=
name|devclass_get_softc
argument_list|(
name|devclass
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
return|return
operator|(
name|mfi_linux_ioctl_int
argument_list|(
name|sc
operator|->
name|mfi_cdev
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|,
name|flag
argument_list|,
name|td
argument_list|)
operator|)
return|;
break|break;
block|}
case|case
name|MFI_LINUX_SET_AEN_2
case|:
comment|/* AEN Linux ioctl shim */
block|{
name|devclass_t
name|devclass
decl_stmt|;
name|struct
name|mfi_linux_ioc_aen
name|l_aen
decl_stmt|;
name|int
name|adapter
decl_stmt|;
name|devclass
operator|=
name|devclass_find
argument_list|(
literal|"mfi"
argument_list|)
expr_stmt|;
if|if
condition|(
name|devclass
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|error
operator|=
name|copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|l_aen
argument_list|,
sizeof|sizeof
argument_list|(
name|l_aen
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|adapter
operator|=
name|l_aen
operator|.
name|laen_adapter_no
expr_stmt|;
name|sc
operator|=
name|devclass_get_softc
argument_list|(
name|devclass
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
return|return
operator|(
name|mfi_linux_ioctl_int
argument_list|(
name|sc
operator|->
name|mfi_cdev
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|,
name|flag
argument_list|,
name|td
argument_list|)
operator|)
return|;
break|break;
block|}
ifdef|#
directive|ifdef
name|__amd64__
case|case
name|MFIIO_PASSTHRU32
case|:
name|iop_swab
operator|.
name|ioc_frame
operator|=
name|iop32
operator|->
name|ioc_frame
expr_stmt|;
name|iop_swab
operator|.
name|buf_size
operator|=
name|iop32
operator|->
name|buf_size
expr_stmt|;
name|iop_swab
operator|.
name|buf
operator|=
name|PTRIN
argument_list|(
name|iop32
operator|->
name|buf
argument_list|)
expr_stmt|;
name|iop
operator|=
operator|&
name|iop_swab
expr_stmt|;
comment|/* FALLTHROUGH */
endif|#
directive|endif
case|case
name|MFIIO_PASSTHRU
case|:
name|error
operator|=
name|mfi_user_command
argument_list|(
name|sc
argument_list|,
name|iop
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__amd64__
if|if
condition|(
name|cmd
operator|==
name|MFIIO_PASSTHRU32
condition|)
name|iop32
operator|->
name|ioc_frame
operator|=
name|iop_swab
operator|.
name|ioc_frame
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"IOCTL 0x%lx not handled\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_linux_ioctl_int
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|mfi_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mfi_linux_ioc_packet
name|l_ioc
decl_stmt|;
name|struct
name|mfi_linux_ioc_aen
name|l_aen
decl_stmt|;
name|struct
name|mfi_command
modifier|*
name|cm
init|=
name|NULL
decl_stmt|;
name|struct
name|mfi_aen
modifier|*
name|mfi_aen_entry
decl_stmt|;
name|union
name|mfi_sense_ptr
name|sense_ptr
decl_stmt|;
name|uint32_t
name|context
decl_stmt|;
name|uint8_t
modifier|*
name|data
init|=
name|NULL
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|error
decl_stmt|,
name|locked
decl_stmt|;
name|sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MFI_LINUX_CMD_2
case|:
comment|/* Firmware Linux ioctl shim */
name|error
operator|=
name|copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|l_ioc
argument_list|,
sizeof|sizeof
argument_list|(
name|l_ioc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|l_ioc
operator|.
name|lioc_sge_count
operator|>
name|MAX_LINUX_IOCTL_SGE
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|=
name|mfi_dequeue_free
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|locked
operator|=
literal|0
expr_stmt|;
comment|/* 		 * save off original context since copying from user 		 * will clobber some data 		 */
name|context
operator|=
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|context
expr_stmt|;
name|bcopy
argument_list|(
name|l_ioc
operator|.
name|lioc_frame
operator|.
name|raw
argument_list|,
name|cm
operator|->
name|cm_frame
argument_list|,
literal|2
operator|*
name|MFI_DCMD_FRAME_SIZE
argument_list|)
expr_stmt|;
comment|/* this isn't quite right */
name|cm
operator|->
name|cm_total_frame_size
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|union
name|mfi_sgl
argument_list|)
operator|*
name|l_ioc
operator|.
name|lioc_sge_count
operator|)
operator|+
name|l_ioc
operator|.
name|lioc_sgl_off
expr_stmt|;
if|if
condition|(
name|l_ioc
operator|.
name|lioc_sge_count
condition|)
name|cm
operator|->
name|cm_sg
operator|=
operator|(
expr|union
name|mfi_sgl
operator|*
operator|)
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|bytes
index|[
name|l_ioc
operator|.
name|lioc_sgl_off
index|]
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|flags
operator|&
name|MFI_FRAME_DATAIN
condition|)
name|cm
operator|->
name|cm_flags
operator||=
name|MFI_CMD_DATAIN
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|flags
operator|&
name|MFI_FRAME_DATAOUT
condition|)
name|cm
operator|->
name|cm_flags
operator||=
name|MFI_CMD_DATAOUT
expr_stmt|;
name|cm
operator|->
name|cm_len
operator|=
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|data_len
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_len
operator|&&
operator|(
name|cm
operator|->
name|cm_flags
operator|&
operator|(
name|MFI_CMD_DATAIN
operator||
name|MFI_CMD_DATAOUT
operator|)
operator|)
condition|)
block|{
name|cm
operator|->
name|cm_data
operator|=
name|data
operator|=
name|malloc
argument_list|(
name|cm
operator|->
name|cm_len
argument_list|,
name|M_MFIBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_data
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Malloc failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
block|{
name|cm
operator|->
name|cm_data
operator|=
literal|0
expr_stmt|;
block|}
comment|/* restore header context */
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|context
operator|=
name|context
expr_stmt|;
name|temp
operator|=
name|data
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|MFI_CMD_DATAOUT
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l_ioc
operator|.
name|lioc_sge_count
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|copyin
argument_list|(
name|PTRIN
argument_list|(
name|l_ioc
operator|.
name|lioc_sgl
index|[
name|i
index|]
operator|.
name|iov_base
argument_list|)
argument_list|,
name|temp
argument_list|,
name|l_ioc
operator|.
name|lioc_sgl
index|[
name|i
index|]
operator|.
name|iov_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Copy in failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|temp
operator|=
operator|&
name|temp
index|[
name|l_ioc
operator|.
name|lioc_sgl
index|[
name|i
index|]
operator|.
name|iov_len
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|cmd
operator|==
name|MFI_CMD_DCMD
condition|)
name|locked
operator|=
name|mfi_config_lock
argument_list|(
name|sc
argument_list|,
name|cm
operator|->
name|cm_frame
operator|->
name|dcmd
operator|.
name|opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|cmd
operator|==
name|MFI_CMD_PD_SCSI_IO
condition|)
block|{
name|cm
operator|->
name|cm_frame
operator|->
name|pass
operator|.
name|sense_addr_lo
operator|=
name|cm
operator|->
name|cm_sense_busaddr
expr_stmt|;
name|cm
operator|->
name|cm_frame
operator|->
name|pass
operator|.
name|sense_addr_hi
operator|=
literal|0
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|mfi_check_command_pre
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|mfi_wait_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Controller polled failed\n"
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|mfi_check_command_post
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|temp
operator|=
name|data
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|MFI_CMD_DATAIN
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l_ioc
operator|.
name|lioc_sge_count
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|copyout
argument_list|(
name|temp
argument_list|,
name|PTRIN
argument_list|(
name|l_ioc
operator|.
name|lioc_sgl
index|[
name|i
index|]
operator|.
name|iov_base
argument_list|)
argument_list|,
name|l_ioc
operator|.
name|lioc_sgl
index|[
name|i
index|]
operator|.
name|iov_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Copy out failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|temp
operator|=
operator|&
name|temp
index|[
name|l_ioc
operator|.
name|lioc_sgl
index|[
name|i
index|]
operator|.
name|iov_len
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|l_ioc
operator|.
name|lioc_sense_len
condition|)
block|{
comment|/* get user-space sense ptr then copy out sense */
name|bcopy
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|mfi_linux_ioc_packet
operator|*
operator|)
name|arg
operator|)
operator|->
name|lioc_frame
operator|.
name|raw
index|[
name|l_ioc
operator|.
name|lioc_sense_off
index|]
argument_list|,
operator|&
name|sense_ptr
operator|.
name|sense_ptr_data
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|sense_ptr
operator|.
name|sense_ptr_data
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__amd64__
comment|/* 			 * only 32bit Linux support so zero out any 			 * address over 32bit 			 */
name|sense_ptr
operator|.
name|addr
operator|.
name|high
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|copyout
argument_list|(
name|cm
operator|->
name|cm_sense
argument_list|,
name|sense_ptr
operator|.
name|user_space
argument_list|,
name|l_ioc
operator|.
name|lioc_sense_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Copy out failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|cmd_status
argument_list|,
operator|&
operator|(
operator|(
expr|struct
name|mfi_linux_ioc_packet
operator|*
operator|)
name|arg
operator|)
operator|->
name|lioc_frame
operator|.
name|hdr
operator|.
name|cmd_status
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Copy out failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|out
label|:
name|mfi_config_unlock
argument_list|(
name|sc
argument_list|,
name|locked
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
condition|)
name|free
argument_list|(
name|data
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
case|case
name|MFI_LINUX_SET_AEN_2
case|:
comment|/* AEN Linux ioctl shim */
name|error
operator|=
name|copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|l_aen
argument_list|,
sizeof|sizeof
argument_list|(
name|l_aen
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|printf
argument_list|(
literal|"AEN IMPLEMENTED for pid %d\n"
argument_list|,
name|curproc
operator|->
name|p_pid
argument_list|)
expr_stmt|;
name|mfi_aen_entry
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mfi_aen
argument_list|)
argument_list|,
name|M_MFIBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|mfi_aen_entry
operator|!=
name|NULL
condition|)
block|{
name|mfi_aen_entry
operator|->
name|p
operator|=
name|curproc
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|mfi_aen_pids
argument_list|,
name|mfi_aen_entry
argument_list|,
name|aen_link
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|mfi_aen_register
argument_list|(
name|sc
argument_list|,
name|l_aen
operator|.
name|laen_seq_num
argument_list|,
name|l_aen
operator|.
name|laen_class_locale
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|mfi_aen_pids
argument_list|,
name|mfi_aen_entry
argument_list|,
name|aen_link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mfi_aen_entry
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"IOCTL 0x%lx not handled\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_poll
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|poll_events
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|mfi_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|revents
init|=
literal|0
decl_stmt|;
name|sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
if|if
condition|(
name|poll_events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|mfi_aen_triggered
operator|!=
literal|0
condition|)
block|{
name|revents
operator||=
name|poll_events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
name|sc
operator|->
name|mfi_aen_triggered
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|mfi_aen_triggered
operator|==
literal|0
operator|&&
name|sc
operator|->
name|mfi_aen_cm
operator|==
name|NULL
condition|)
block|{
name|revents
operator||=
name|POLLERR
expr_stmt|;
block|}
block|}
if|if
condition|(
name|revents
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|poll_events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
condition|)
block|{
name|sc
operator|->
name|mfi_poll_waiting
operator|=
literal|1
expr_stmt|;
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|sc
operator|->
name|mfi_select
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|revents
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mfi_dump_all
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|mfi_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mfi_command
modifier|*
name|cm
decl_stmt|;
name|devclass_t
name|dc
decl_stmt|;
name|time_t
name|deadline
decl_stmt|;
name|int
name|timedout
decl_stmt|;
name|int
name|i
decl_stmt|;
name|dc
operator|=
name|devclass_find
argument_list|(
literal|"mfi"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"No mfi dev class\n"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|=
name|devclass_get_softc
argument_list|(
name|dc
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
break|break;
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Dumping\n\n"
argument_list|)
expr_stmt|;
name|timedout
operator|=
literal|0
expr_stmt|;
name|deadline
operator|=
name|time_uptime
operator|-
name|MFI_CMD_TIMEOUT
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|cm
argument_list|,
argument|&sc->mfi_busy
argument_list|,
argument|cm_link
argument_list|)
block|{
if|if
condition|(
name|cm
operator|->
name|cm_timestamp
operator|<
name|deadline
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"COMMAND %p TIMEOUT AFTER %d SECONDS\n"
argument_list|,
name|cm
argument_list|,
call|(
name|int
call|)
argument_list|(
name|time_uptime
operator|-
name|cm
operator|->
name|cm_timestamp
argument_list|)
argument_list|)
expr_stmt|;
name|MFI_PRINT_CMD
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|timedout
operator|++
expr_stmt|;
block|}
block|}
if|#
directive|if
literal|0
block|if (timedout) 			MFI_DUMP_CMDS(SC);
endif|#
directive|endif
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|mfi_timeout
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|mfi_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|mfi_softc
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|mfi_command
modifier|*
name|cm
decl_stmt|;
name|time_t
name|deadline
decl_stmt|;
name|int
name|timedout
init|=
literal|0
decl_stmt|;
name|deadline
operator|=
name|time_uptime
operator|-
name|MFI_CMD_TIMEOUT
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|cm
argument_list|,
argument|&sc->mfi_busy
argument_list|,
argument|cm_link
argument_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|mfi_aen_cm
operator|==
name|cm
condition|)
continue|continue;
if|if
condition|(
operator|(
name|sc
operator|->
name|mfi_aen_cm
operator|!=
name|cm
operator|)
operator|&&
operator|(
name|cm
operator|->
name|cm_timestamp
operator|<
name|deadline
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"COMMAND %p TIMEOUT AFTER %d SECONDS\n"
argument_list|,
name|cm
argument_list|,
call|(
name|int
call|)
argument_list|(
name|time_uptime
operator|-
name|cm
operator|->
name|cm_timestamp
argument_list|)
argument_list|)
expr_stmt|;
name|MFI_PRINT_CMD
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|MFI_VALIDATE_CMD
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
name|timedout
operator|++
expr_stmt|;
block|}
block|}
if|#
directive|if
literal|0
block|if (timedout) 		MFI_DUMP_CMDS(SC);
endif|#
directive|endif
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|mfi_watchdog_callout
argument_list|,
name|MFI_CMD_TIMEOUT
operator|*
name|hz
argument_list|,
name|mfi_timeout
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
condition|)
name|mfi_dump_all
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

end_unit

