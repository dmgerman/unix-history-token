begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2006 IronPort Systems  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2007 LSI Corp.  * Copyright (c) 2007 Rajesh Prabhakaran.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_compat.h"
end_include

begin_include
include|#
directive|include
file|"opt_mfi.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<dev/mfi/mfireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/mfi/mfi_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<dev/mfi/mfivar.h>
end_include

begin_include
include|#
directive|include
file|<sys/interrupt.h>
end_include

begin_include
include|#
directive|include
file|<sys/priority.h>
end_include

begin_function_decl
specifier|static
name|int
name|mfi_alloc_commands
parameter_list|(
name|struct
name|mfi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mfi_comms_init
parameter_list|(
name|struct
name|mfi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mfi_get_controller_info
parameter_list|(
name|struct
name|mfi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mfi_get_log_state
parameter_list|(
name|struct
name|mfi_softc
modifier|*
parameter_list|,
name|struct
name|mfi_evt_log_state
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mfi_parse_entries
parameter_list|(
name|struct
name|mfi_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mfi_data_cb
parameter_list|(
name|void
modifier|*
parameter_list|,
name|bus_dma_segment_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mfi_startup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mfi_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mfi_ldprobe
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mfi_syspdprobe
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mfi_handle_evt
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mfi_aen_register
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|seq
parameter_list|,
name|int
name|locale
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mfi_aen_complete
parameter_list|(
name|struct
name|mfi_command
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mfi_add_ld
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mfi_add_ld_complete
parameter_list|(
name|struct
name|mfi_command
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mfi_add_sys_pd
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mfi_add_sys_pd_complete
parameter_list|(
name|struct
name|mfi_command
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mfi_command
modifier|*
name|mfi_bio_command
parameter_list|(
name|struct
name|mfi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mfi_bio_complete
parameter_list|(
name|struct
name|mfi_command
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mfi_command
modifier|*
name|mfi_build_ldio
parameter_list|(
name|struct
name|mfi_softc
modifier|*
parameter_list|,
name|struct
name|bio
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mfi_command
modifier|*
name|mfi_build_syspdio
parameter_list|(
name|struct
name|mfi_softc
modifier|*
parameter_list|,
name|struct
name|bio
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mfi_send_frame
parameter_list|(
name|struct
name|mfi_softc
modifier|*
parameter_list|,
name|struct
name|mfi_command
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mfi_std_send_frame
parameter_list|(
name|struct
name|mfi_softc
modifier|*
parameter_list|,
name|struct
name|mfi_command
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mfi_abort
parameter_list|(
name|struct
name|mfi_softc
modifier|*
parameter_list|,
name|struct
name|mfi_command
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mfi_linux_ioctl_int
parameter_list|(
name|struct
name|cdev
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|,
name|int
parameter_list|,
name|struct
name|thread
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mfi_timeout
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mfi_user_command
parameter_list|(
name|struct
name|mfi_softc
modifier|*
parameter_list|,
name|struct
name|mfi_ioc_passthru
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mfi_enable_intr_xscale
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mfi_enable_intr_ppc
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|mfi_read_fw_status_xscale
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|mfi_read_fw_status_ppc
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mfi_check_clear_intr_xscale
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mfi_check_clear_intr_ppc
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mfi_issue_cmd_xscale
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|bus_addr_t
name|bus_add
parameter_list|,
name|uint32_t
name|frame_cnt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mfi_issue_cmd_ppc
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|bus_addr_t
name|bus_add
parameter_list|,
name|uint32_t
name|frame_cnt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mfi_config_lock
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|opcode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mfi_config_unlock
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|locked
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mfi_check_command_pre
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mfi_command
modifier|*
name|cm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mfi_check_command_post
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mfi_command
modifier|*
name|cm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mfi_check_for_sscd
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mfi_command
modifier|*
name|cm
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|mfi
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"MFI driver parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|mfi_event_locale
init|=
name|MFI_EVT_LOCALE_ALL
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_mfi
argument_list|,
name|OID_AUTO
argument_list|,
name|event_locale
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|mfi_event_locale
argument_list|,
literal|0
argument_list|,
literal|"event message locale"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|mfi_event_class
init|=
name|MFI_EVT_CLASS_INFO
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_mfi
argument_list|,
name|OID_AUTO
argument_list|,
name|event_class
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|mfi_event_class
argument_list|,
literal|0
argument_list|,
literal|"event message class"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|mfi_max_cmds
init|=
literal|128
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_mfi
argument_list|,
name|OID_AUTO
argument_list|,
name|max_cmds
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|mfi_max_cmds
argument_list|,
literal|0
argument_list|,
literal|"Max commands limit (-1 = controller limit)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|mfi_detect_jbod_change
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_mfi
argument_list|,
name|OID_AUTO
argument_list|,
name|detect_jbod_change
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|mfi_detect_jbod_change
argument_list|,
literal|0
argument_list|,
literal|"Detect a change to a JBOD"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|mfi_polled_cmd_timeout
init|=
name|MFI_POLL_TIMEOUT_SECS
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_mfi
argument_list|,
name|OID_AUTO
argument_list|,
name|polled_cmd_timeout
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|mfi_polled_cmd_timeout
argument_list|,
literal|0
argument_list|,
literal|"Polled command timeout - used for firmware flash etc (in seconds)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|mfi_cmd_timeout
init|=
name|MFI_CMD_TIMEOUT
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_mfi
argument_list|,
name|OID_AUTO
argument_list|,
name|cmd_timeout
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|mfi_cmd_timeout
argument_list|,
literal|0
argument_list|,
literal|"Command timeout (in seconds)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Management interface */
end_comment

begin_decl_stmt
specifier|static
name|d_open_t
name|mfi_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|mfi_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|mfi_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_poll_t
name|mfi_poll
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|mfi_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_flags
operator|=
literal|0
block|,
operator|.
name|d_open
operator|=
name|mfi_open
block|,
operator|.
name|d_close
operator|=
name|mfi_close
block|,
operator|.
name|d_ioctl
operator|=
name|mfi_ioctl
block|,
operator|.
name|d_poll
operator|=
name|mfi_poll
block|,
operator|.
name|d_name
operator|=
literal|"mfi"
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_MFIBUF
argument_list|,
literal|"mfibuf"
argument_list|,
literal|"Buffers for the MFI driver"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|MFI_INQ_LENGTH
value|SHORT_INQUIRY_LENGTH
end_define

begin_decl_stmt
name|struct
name|mfi_skinny_dma_info
name|mfi_skinny
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|mfi_enable_intr_xscale
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|MFI_WRITE4
argument_list|(
name|sc
argument_list|,
name|MFI_OMSK
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mfi_enable_intr_ppc
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|mfi_flags
operator|&
name|MFI_FLAGS_1078
condition|)
block|{
name|MFI_WRITE4
argument_list|(
name|sc
argument_list|,
name|MFI_ODCR0
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
name|MFI_WRITE4
argument_list|(
name|sc
argument_list|,
name|MFI_OMSK
argument_list|,
operator|~
name|MFI_1078_EIM
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|mfi_flags
operator|&
name|MFI_FLAGS_GEN2
condition|)
block|{
name|MFI_WRITE4
argument_list|(
name|sc
argument_list|,
name|MFI_ODCR0
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
name|MFI_WRITE4
argument_list|(
name|sc
argument_list|,
name|MFI_OMSK
argument_list|,
operator|~
name|MFI_GEN2_EIM
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|mfi_flags
operator|&
name|MFI_FLAGS_SKINNY
condition|)
block|{
name|MFI_WRITE4
argument_list|(
name|sc
argument_list|,
name|MFI_OMSK
argument_list|,
operator|~
literal|0x00000001
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int32_t
name|mfi_read_fw_status_xscale
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return
name|MFI_READ4
argument_list|(
name|sc
argument_list|,
name|MFI_OMSG0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|mfi_read_fw_status_ppc
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return
name|MFI_READ4
argument_list|(
name|sc
argument_list|,
name|MFI_OSP0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_check_clear_intr_xscale
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int32_t
name|status
decl_stmt|;
name|status
operator|=
name|MFI_READ4
argument_list|(
name|sc
argument_list|,
name|MFI_OSTS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|MFI_OSTS_INTR_VALID
operator|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|MFI_WRITE4
argument_list|(
name|sc
argument_list|,
name|MFI_OSTS
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_check_clear_intr_ppc
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int32_t
name|status
decl_stmt|;
name|status
operator|=
name|MFI_READ4
argument_list|(
name|sc
argument_list|,
name|MFI_OSTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_flags
operator|&
name|MFI_FLAGS_1078
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|status
operator|&
name|MFI_1078_RM
operator|)
condition|)
block|{
return|return
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|mfi_flags
operator|&
name|MFI_FLAGS_GEN2
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|status
operator|&
name|MFI_GEN2_RM
operator|)
condition|)
block|{
return|return
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|mfi_flags
operator|&
name|MFI_FLAGS_SKINNY
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|status
operator|&
name|MFI_SKINNY_RM
operator|)
condition|)
block|{
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|mfi_flags
operator|&
name|MFI_FLAGS_SKINNY
condition|)
name|MFI_WRITE4
argument_list|(
name|sc
argument_list|,
name|MFI_OSTS
argument_list|,
name|status
argument_list|)
expr_stmt|;
else|else
name|MFI_WRITE4
argument_list|(
name|sc
argument_list|,
name|MFI_ODCR0
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mfi_issue_cmd_xscale
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|bus_addr_t
name|bus_add
parameter_list|,
name|uint32_t
name|frame_cnt
parameter_list|)
block|{
name|MFI_WRITE4
argument_list|(
name|sc
argument_list|,
name|MFI_IQP
argument_list|,
operator|(
name|bus_add
operator|>>
literal|3
operator|)
operator||
name|frame_cnt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mfi_issue_cmd_ppc
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|bus_addr_t
name|bus_add
parameter_list|,
name|uint32_t
name|frame_cnt
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|mfi_flags
operator|&
name|MFI_FLAGS_SKINNY
condition|)
block|{
name|MFI_WRITE4
argument_list|(
name|sc
argument_list|,
name|MFI_IQPL
argument_list|,
operator|(
name|bus_add
operator||
name|frame_cnt
operator|<<
literal|1
operator|)
operator||
literal|1
argument_list|)
expr_stmt|;
name|MFI_WRITE4
argument_list|(
name|sc
argument_list|,
name|MFI_IQPH
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MFI_WRITE4
argument_list|(
name|sc
argument_list|,
name|MFI_IQP
argument_list|,
operator|(
name|bus_add
operator||
name|frame_cnt
operator|<<
literal|1
operator|)
operator||
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|mfi_transition_firmware
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|fw_state
decl_stmt|,
name|cur_state
decl_stmt|;
name|int
name|max_wait
decl_stmt|,
name|i
decl_stmt|;
name|uint32_t
name|cur_abs_reg_val
init|=
literal|0
decl_stmt|;
name|uint32_t
name|prev_abs_reg_val
init|=
literal|0
decl_stmt|;
name|cur_abs_reg_val
operator|=
name|sc
operator|->
name|mfi_read_fw_status
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|fw_state
operator|=
name|cur_abs_reg_val
operator|&
name|MFI_FWSTATE_MASK
expr_stmt|;
while|while
condition|(
name|fw_state
operator|!=
name|MFI_FWSTATE_READY
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Waiting for firmware to "
literal|"become ready\n"
argument_list|)
expr_stmt|;
name|cur_state
operator|=
name|fw_state
expr_stmt|;
switch|switch
condition|(
name|fw_state
condition|)
block|{
case|case
name|MFI_FWSTATE_FAULT
case|:
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Firmware fault\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
case|case
name|MFI_FWSTATE_WAIT_HANDSHAKE
case|:
if|if
condition|(
name|sc
operator|->
name|mfi_flags
operator|&
name|MFI_FLAGS_SKINNY
operator|||
name|sc
operator|->
name|mfi_flags
operator|&
name|MFI_FLAGS_TBOLT
condition|)
name|MFI_WRITE4
argument_list|(
name|sc
argument_list|,
name|MFI_SKINNY_IDB
argument_list|,
name|MFI_FWINIT_CLEAR_HANDSHAKE
argument_list|)
expr_stmt|;
else|else
name|MFI_WRITE4
argument_list|(
name|sc
argument_list|,
name|MFI_IDB
argument_list|,
name|MFI_FWINIT_CLEAR_HANDSHAKE
argument_list|)
expr_stmt|;
name|max_wait
operator|=
name|MFI_RESET_WAIT_TIME
expr_stmt|;
break|break;
case|case
name|MFI_FWSTATE_OPERATIONAL
case|:
if|if
condition|(
name|sc
operator|->
name|mfi_flags
operator|&
name|MFI_FLAGS_SKINNY
operator|||
name|sc
operator|->
name|mfi_flags
operator|&
name|MFI_FLAGS_TBOLT
condition|)
name|MFI_WRITE4
argument_list|(
name|sc
argument_list|,
name|MFI_SKINNY_IDB
argument_list|,
literal|7
argument_list|)
expr_stmt|;
else|else
name|MFI_WRITE4
argument_list|(
name|sc
argument_list|,
name|MFI_IDB
argument_list|,
name|MFI_FWINIT_READY
argument_list|)
expr_stmt|;
name|max_wait
operator|=
name|MFI_RESET_WAIT_TIME
expr_stmt|;
break|break;
case|case
name|MFI_FWSTATE_UNDEFINED
case|:
case|case
name|MFI_FWSTATE_BB_INIT
case|:
name|max_wait
operator|=
name|MFI_RESET_WAIT_TIME
expr_stmt|;
break|break;
case|case
name|MFI_FWSTATE_FW_INIT_2
case|:
name|max_wait
operator|=
name|MFI_RESET_WAIT_TIME
expr_stmt|;
break|break;
case|case
name|MFI_FWSTATE_FW_INIT
case|:
case|case
name|MFI_FWSTATE_FLUSH_CACHE
case|:
name|max_wait
operator|=
name|MFI_RESET_WAIT_TIME
expr_stmt|;
break|break;
case|case
name|MFI_FWSTATE_DEVICE_SCAN
case|:
name|max_wait
operator|=
name|MFI_RESET_WAIT_TIME
expr_stmt|;
comment|/* wait for 180 seconds */
name|prev_abs_reg_val
operator|=
name|cur_abs_reg_val
expr_stmt|;
break|break;
case|case
name|MFI_FWSTATE_BOOT_MESSAGE_PENDING
case|:
if|if
condition|(
name|sc
operator|->
name|mfi_flags
operator|&
name|MFI_FLAGS_SKINNY
operator|||
name|sc
operator|->
name|mfi_flags
operator|&
name|MFI_FLAGS_TBOLT
condition|)
name|MFI_WRITE4
argument_list|(
name|sc
argument_list|,
name|MFI_SKINNY_IDB
argument_list|,
name|MFI_FWINIT_HOTPLUG
argument_list|)
expr_stmt|;
else|else
name|MFI_WRITE4
argument_list|(
name|sc
argument_list|,
name|MFI_IDB
argument_list|,
name|MFI_FWINIT_HOTPLUG
argument_list|)
expr_stmt|;
name|max_wait
operator|=
name|MFI_RESET_WAIT_TIME
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Unknown firmware state %#x\n"
argument_list|,
name|fw_state
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|max_wait
operator|*
literal|10
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|cur_abs_reg_val
operator|=
name|sc
operator|->
name|mfi_read_fw_status
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|fw_state
operator|=
name|cur_abs_reg_val
operator|&
name|MFI_FWSTATE_MASK
expr_stmt|;
if|if
condition|(
name|fw_state
operator|==
name|cur_state
condition|)
name|DELAY
argument_list|(
literal|100000
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
name|fw_state
operator|==
name|MFI_FWSTATE_DEVICE_SCAN
condition|)
block|{
comment|/* Check the device scanning progress */
if|if
condition|(
name|prev_abs_reg_val
operator|!=
name|cur_abs_reg_val
condition|)
block|{
continue|continue;
block|}
block|}
if|if
condition|(
name|fw_state
operator|==
name|cur_state
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Firmware stuck in state "
literal|"%#x\n"
argument_list|,
name|fw_state
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mfi_addr_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|bus_addr_t
modifier|*
name|addr
decl_stmt|;
name|addr
operator|=
name|arg
expr_stmt|;
operator|*
name|addr
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
name|int
name|mfi_attach
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|status
decl_stmt|;
name|int
name|error
decl_stmt|,
name|commsz
decl_stmt|,
name|framessz
decl_stmt|,
name|sensesz
decl_stmt|;
name|int
name|frames
decl_stmt|,
name|unit
decl_stmt|,
name|max_fw_sge
decl_stmt|,
name|max_fw_cmds
decl_stmt|;
name|uint32_t
name|tb_mem_size
init|=
literal|0
decl_stmt|;
name|struct
name|cdev
modifier|*
name|dev_t
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
name|EINVAL
return|;
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Megaraid SAS driver Ver %s \n"
argument_list|,
name|MEGASAS_VERSION
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|,
literal|"MFI I/O lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|sx_init
argument_list|(
operator|&
name|sc
operator|->
name|mfi_config_lock
argument_list|,
literal|"MFI config"
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|mfi_ld_tqh
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|mfi_syspd_tqh
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|mfi_ld_pend_tqh
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|mfi_syspd_pend_tqh
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|mfi_evt_queue
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|mfi_evt_task
argument_list|,
literal|0
argument_list|,
name|mfi_handle_evt
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|mfi_map_sync_task
argument_list|,
literal|0
argument_list|,
name|mfi_handle_map_sync
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|mfi_aen_pids
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|mfi_cam_ccbq
argument_list|)
expr_stmt|;
name|mfi_initq_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mfi_initq_ready
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mfi_initq_busy
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mfi_initq_bio
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|adpreset
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|last_seq_num
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|disableOnlineCtrlReset
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|issuepend_done
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|hw_crit_error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_flags
operator|&
name|MFI_FLAGS_1064R
condition|)
block|{
name|sc
operator|->
name|mfi_enable_intr
operator|=
name|mfi_enable_intr_xscale
expr_stmt|;
name|sc
operator|->
name|mfi_read_fw_status
operator|=
name|mfi_read_fw_status_xscale
expr_stmt|;
name|sc
operator|->
name|mfi_check_clear_intr
operator|=
name|mfi_check_clear_intr_xscale
expr_stmt|;
name|sc
operator|->
name|mfi_issue_cmd
operator|=
name|mfi_issue_cmd_xscale
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|mfi_flags
operator|&
name|MFI_FLAGS_TBOLT
condition|)
block|{
name|sc
operator|->
name|mfi_enable_intr
operator|=
name|mfi_tbolt_enable_intr_ppc
expr_stmt|;
name|sc
operator|->
name|mfi_disable_intr
operator|=
name|mfi_tbolt_disable_intr_ppc
expr_stmt|;
name|sc
operator|->
name|mfi_read_fw_status
operator|=
name|mfi_tbolt_read_fw_status_ppc
expr_stmt|;
name|sc
operator|->
name|mfi_check_clear_intr
operator|=
name|mfi_tbolt_check_clear_intr_ppc
expr_stmt|;
name|sc
operator|->
name|mfi_issue_cmd
operator|=
name|mfi_tbolt_issue_cmd_ppc
expr_stmt|;
name|sc
operator|->
name|mfi_adp_reset
operator|=
name|mfi_tbolt_adp_reset
expr_stmt|;
name|sc
operator|->
name|mfi_tbolt
operator|=
literal|1
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|mfi_cmd_tbolt_tqh
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|mfi_enable_intr
operator|=
name|mfi_enable_intr_ppc
expr_stmt|;
name|sc
operator|->
name|mfi_read_fw_status
operator|=
name|mfi_read_fw_status_ppc
expr_stmt|;
name|sc
operator|->
name|mfi_check_clear_intr
operator|=
name|mfi_check_clear_intr_ppc
expr_stmt|;
name|sc
operator|->
name|mfi_issue_cmd
operator|=
name|mfi_issue_cmd_ppc
expr_stmt|;
block|}
comment|/* Before we get too far, see if the firmware is working */
if|if
condition|(
operator|(
name|error
operator|=
name|mfi_transition_firmware
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Firmware not in READY state, "
literal|"error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Start: LSIP200113393 */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|mfi_parent_dmat
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|MEGASAS_MAX_NAME
operator|*
sizeof|sizeof
argument_list|(
name|bus_addr_t
argument_list|)
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* msegments */
name|MEGASAS_MAX_NAME
operator|*
sizeof|sizeof
argument_list|(
name|bus_addr_t
argument_list|)
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|verbuf_h_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Cannot allocate verbuf_h_dmat DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|verbuf_h_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|verbuf
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|verbuf_h_dmamap
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Cannot allocate verbuf_h_dmamap memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|sc
operator|->
name|verbuf
argument_list|,
name|MEGASAS_MAX_NAME
operator|*
sizeof|sizeof
argument_list|(
name|bus_addr_t
argument_list|)
argument_list|)
expr_stmt|;
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|verbuf_h_dmat
argument_list|,
name|sc
operator|->
name|verbuf_h_dmamap
argument_list|,
name|sc
operator|->
name|verbuf
argument_list|,
name|MEGASAS_MAX_NAME
operator|*
sizeof|sizeof
argument_list|(
name|bus_addr_t
argument_list|)
argument_list|,
name|mfi_addr_cb
argument_list|,
operator|&
name|sc
operator|->
name|verbuf_h_busaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* End: LSIP200113393 */
comment|/* 	 * Get information needed for sizing the contiguous memory for the 	 * frame pool.  Size down the sgl parameter since we know that 	 * we will never need more than what's required for MAXPHYS. 	 * It would be nice if these constants were available at runtime 	 * instead of compile time. 	 */
name|status
operator|=
name|sc
operator|->
name|mfi_read_fw_status
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|max_fw_cmds
operator|=
name|status
operator|&
name|MFI_FWSTATE_MAXCMD_MASK
expr_stmt|;
if|if
condition|(
name|mfi_max_cmds
operator|>
literal|0
operator|&&
name|mfi_max_cmds
operator|<
name|max_fw_cmds
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"FW MaxCmds = %d, limiting to %d\n"
argument_list|,
name|max_fw_cmds
argument_list|,
name|mfi_max_cmds
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mfi_max_fw_cmds
operator|=
name|mfi_max_cmds
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|mfi_max_fw_cmds
operator|=
name|max_fw_cmds
expr_stmt|;
block|}
name|max_fw_sge
operator|=
operator|(
name|status
operator|&
name|MFI_FWSTATE_MAXSGL_MASK
operator|)
operator|>>
literal|16
expr_stmt|;
name|sc
operator|->
name|mfi_max_sge
operator|=
name|min
argument_list|(
name|max_fw_sge
argument_list|,
operator|(
operator|(
name|MFI_MAXPHYS
operator|/
name|PAGE_SIZE
operator|)
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* ThunderBolt Support get the contiguous memory */
if|if
condition|(
name|sc
operator|->
name|mfi_flags
operator|&
name|MFI_FLAGS_TBOLT
condition|)
block|{
name|mfi_tbolt_init_globals
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"MaxCmd = %d, Drv MaxCmd = %d, "
literal|"MaxSgl = %d, state = %#x\n"
argument_list|,
name|max_fw_cmds
argument_list|,
name|sc
operator|->
name|mfi_max_fw_cmds
argument_list|,
name|sc
operator|->
name|mfi_max_sge
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|tb_mem_size
operator|=
name|mfi_tbolt_get_memory_requirement
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|mfi_parent_dmat
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|tb_mem_size
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* msegments */
name|tb_mem_size
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|mfi_tb_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Cannot allocate comms DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|mfi_tb_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|request_message_pool
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|mfi_tb_dmamap
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Cannot allocate comms memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|sc
operator|->
name|request_message_pool
argument_list|,
name|tb_mem_size
argument_list|)
expr_stmt|;
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|mfi_tb_dmat
argument_list|,
name|sc
operator|->
name|mfi_tb_dmamap
argument_list|,
name|sc
operator|->
name|request_message_pool
argument_list|,
name|tb_mem_size
argument_list|,
name|mfi_addr_cb
argument_list|,
operator|&
name|sc
operator|->
name|mfi_tb_busaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* For ThunderBolt memory init */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|mfi_parent_dmat
argument_list|,
comment|/* parent */
literal|0x100
argument_list|,
literal|0
argument_list|,
comment|/* alignmnt, boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|MFI_FRAME_SIZE
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* msegments */
name|MFI_FRAME_SIZE
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|mfi_tb_init_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Cannot allocate init DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|mfi_tb_init_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|mfi_tb_init
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|mfi_tb_init_dmamap
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Cannot allocate init memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|sc
operator|->
name|mfi_tb_init
argument_list|,
name|MFI_FRAME_SIZE
argument_list|)
expr_stmt|;
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|mfi_tb_init_dmat
argument_list|,
name|sc
operator|->
name|mfi_tb_init_dmamap
argument_list|,
name|sc
operator|->
name|mfi_tb_init
argument_list|,
name|MFI_FRAME_SIZE
argument_list|,
name|mfi_addr_cb
argument_list|,
operator|&
name|sc
operator|->
name|mfi_tb_init_busaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mfi_tbolt_init_desc_pool
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|request_message_pool
argument_list|,
name|tb_mem_size
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Thunderbolt pool preparation error\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 		  Allocate DMA memory mapping for MPI2 IOC Init descriptor, 		  we are taking it different from what we have allocated for Request 		  and reply descriptors to avoid confusion later 		*/
name|tb_mem_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|MPI2_IOC_INIT_REQUEST
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|mfi_parent_dmat
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|tb_mem_size
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* msegments */
name|tb_mem_size
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|mfi_tb_ioc_init_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Cannot allocate comms DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|mfi_tb_ioc_init_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|mfi_tb_ioc_init_desc
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|mfi_tb_ioc_init_dmamap
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Cannot allocate comms memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|sc
operator|->
name|mfi_tb_ioc_init_desc
argument_list|,
name|tb_mem_size
argument_list|)
expr_stmt|;
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|mfi_tb_ioc_init_dmat
argument_list|,
name|sc
operator|->
name|mfi_tb_ioc_init_dmamap
argument_list|,
name|sc
operator|->
name|mfi_tb_ioc_init_desc
argument_list|,
name|tb_mem_size
argument_list|,
name|mfi_addr_cb
argument_list|,
operator|&
name|sc
operator|->
name|mfi_tb_ioc_init_busaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Create the dma tag for data buffers.  Used both for block I/O 	 * and for various internal data queries. 	 */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|mfi_parent_dmat
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* maxsize */
name|sc
operator|->
name|mfi_max_sge
argument_list|,
comment|/* nsegments */
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* maxsegsize */
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/* flags */
name|busdma_lock_mutex
argument_list|,
comment|/* lockfunc */
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|,
comment|/* lockfuncarg */
operator|&
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Cannot allocate buffer DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* 	 * Allocate DMA memory for the comms queues.  Keep it under 4GB for 	 * efficiency.  The mfi_hwcomms struct includes space for 1 reply queue 	 * entry, so the calculated size here will be will be 1 more than 	 * mfi_max_fw_cmds.  This is apparently a requirement of the hardware. 	 */
name|commsz
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
name|sc
operator|->
name|mfi_max_fw_cmds
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|mfi_hwcomms
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|mfi_parent_dmat
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|commsz
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* msegments */
name|commsz
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|mfi_comms_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Cannot allocate comms DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|mfi_comms_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|mfi_comms
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|mfi_comms_dmamap
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Cannot allocate comms memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|sc
operator|->
name|mfi_comms
argument_list|,
name|commsz
argument_list|)
expr_stmt|;
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|mfi_comms_dmat
argument_list|,
name|sc
operator|->
name|mfi_comms_dmamap
argument_list|,
name|sc
operator|->
name|mfi_comms
argument_list|,
name|commsz
argument_list|,
name|mfi_addr_cb
argument_list|,
operator|&
name|sc
operator|->
name|mfi_comms_busaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate DMA memory for the command frames.  Keep them in the 	 * lower 4GB for efficiency.  Calculate the size of the commands at 	 * the same time; each command is one 64 byte frame plus a set of          * additional frames for holding sg lists or other data. 	 * The assumption here is that the SG list will start at the second 	 * frame and not use the unused bytes in the first frame.  While this 	 * isn't technically correct, it simplifies the calculation and allows 	 * for command frames that might be larger than an mfi_io_frame. 	 */
if|if
condition|(
sizeof|sizeof
argument_list|(
name|bus_addr_t
argument_list|)
operator|==
literal|8
condition|)
block|{
name|sc
operator|->
name|mfi_sge_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mfi_sg64
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mfi_flags
operator||=
name|MFI_FLAGS_SG64
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|mfi_sge_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mfi_sg32
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|mfi_flags
operator|&
name|MFI_FLAGS_SKINNY
condition|)
name|sc
operator|->
name|mfi_sge_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mfi_sg_skinny
argument_list|)
expr_stmt|;
name|frames
operator|=
operator|(
name|sc
operator|->
name|mfi_sge_size
operator|*
name|sc
operator|->
name|mfi_max_sge
operator|-
literal|1
operator|)
operator|/
name|MFI_FRAME_SIZE
operator|+
literal|2
expr_stmt|;
name|sc
operator|->
name|mfi_cmd_size
operator|=
name|frames
operator|*
name|MFI_FRAME_SIZE
expr_stmt|;
name|framessz
operator|=
name|sc
operator|->
name|mfi_cmd_size
operator|*
name|sc
operator|->
name|mfi_max_fw_cmds
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|mfi_parent_dmat
argument_list|,
comment|/* parent */
literal|64
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|framessz
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|framessz
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|mfi_frames_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Cannot allocate frame DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|mfi_frames_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|mfi_frames
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|mfi_frames_dmamap
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Cannot allocate frames memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|sc
operator|->
name|mfi_frames
argument_list|,
name|framessz
argument_list|)
expr_stmt|;
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|mfi_frames_dmat
argument_list|,
name|sc
operator|->
name|mfi_frames_dmamap
argument_list|,
name|sc
operator|->
name|mfi_frames
argument_list|,
name|framessz
argument_list|,
name|mfi_addr_cb
argument_list|,
operator|&
name|sc
operator|->
name|mfi_frames_busaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate DMA memory for the frame sense data.  Keep them in the 	 * lower 4GB for efficiency 	 */
name|sensesz
operator|=
name|sc
operator|->
name|mfi_max_fw_cmds
operator|*
name|MFI_SENSE_LEN
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|mfi_parent_dmat
argument_list|,
comment|/* parent */
literal|4
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|sensesz
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|sensesz
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|mfi_sense_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Cannot allocate sense DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|mfi_sense_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|mfi_sense
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|mfi_sense_dmamap
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Cannot allocate sense memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|mfi_sense_dmat
argument_list|,
name|sc
operator|->
name|mfi_sense_dmamap
argument_list|,
name|sc
operator|->
name|mfi_sense
argument_list|,
name|sensesz
argument_list|,
name|mfi_addr_cb
argument_list|,
operator|&
name|sc
operator|->
name|mfi_sense_busaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|mfi_alloc_commands
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Before moving the FW to operational state, check whether 	 * hostmemory is required by the FW or not 	 */
comment|/* ThunderBolt MFI_IOC2 INIT */
if|if
condition|(
name|sc
operator|->
name|mfi_flags
operator|&
name|MFI_FLAGS_TBOLT
condition|)
block|{
name|sc
operator|->
name|mfi_disable_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|mfi_tbolt_init_MFI_queue
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"TB Init has failed with error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|mfi_tbolt_alloc_cmd
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
if|if
condition|(
name|bus_setup_intr
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
name|sc
operator|->
name|mfi_irq
argument_list|,
name|INTR_MPSAFE
operator||
name|INTR_TYPE_BIO
argument_list|,
name|NULL
argument_list|,
name|mfi_intr_tbolt
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|mfi_intr
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Cannot set up interrupt\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|sc
operator|->
name|mfi_intr_ptr
operator|=
name|mfi_intr_tbolt
expr_stmt|;
name|sc
operator|->
name|mfi_enable_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|mfi_comms_init
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|bus_setup_intr
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
name|sc
operator|->
name|mfi_irq
argument_list|,
name|INTR_MPSAFE
operator||
name|INTR_TYPE_BIO
argument_list|,
name|NULL
argument_list|,
name|mfi_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|mfi_intr
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Cannot set up interrupt\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|sc
operator|->
name|mfi_intr_ptr
operator|=
name|mfi_intr
expr_stmt|;
name|sc
operator|->
name|mfi_enable_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|mfi_get_controller_info
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sc
operator|->
name|disableOnlineCtrlReset
operator|=
literal|0
expr_stmt|;
comment|/* Register a config hook to probe the bus for arrays */
name|sc
operator|->
name|mfi_ich
operator|.
name|ich_func
operator|=
name|mfi_startup
expr_stmt|;
name|sc
operator|->
name|mfi_ich
operator|.
name|ich_arg
operator|=
name|sc
expr_stmt|;
if|if
condition|(
name|config_intrhook_establish
argument_list|(
operator|&
name|sc
operator|->
name|mfi_ich
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Cannot establish configuration "
literal|"hook\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|mfi_aen_setup
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
operator|,
literal|0
operator|)
operator|!=
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Register a shutdown handler. 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|mfi_eh
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|shutdown_final
argument_list|,
name|mfi_shutdown
argument_list|,
name|sc
argument_list|,
name|SHUTDOWN_PRI_DEFAULT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Warning: shutdown event "
literal|"registration failed\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Create the control device for doing management 	 */
name|unit
operator|=
name|device_get_unit
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mfi_cdev
operator|=
name|make_dev
argument_list|(
operator|&
name|mfi_cdevsw
argument_list|,
name|unit
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0640
argument_list|,
literal|"mfi%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|==
literal|0
condition|)
name|make_dev_alias_p
argument_list|(
name|MAKEDEV_CHECKNAME
operator||
name|MAKEDEV_WAITOK
argument_list|,
operator|&
name|dev_t
argument_list|,
name|sc
operator|->
name|mfi_cdev
argument_list|,
literal|"%s"
argument_list|,
literal|"megaraid_sas_ioctl_node"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_cdev
operator|!=
name|NULL
condition|)
name|sc
operator|->
name|mfi_cdev
operator|->
name|si_drv1
operator|=
name|sc
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"delete_busy_volumes"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|mfi_delete_busy_volumes
argument_list|,
literal|0
argument_list|,
literal|"Allow removal of busy volumes"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"keep_deleted_volumes"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|mfi_keep_deleted_volumes
argument_list|,
literal|0
argument_list|,
literal|"Don't detach the mfid device for a busy volume that is deleted"
argument_list|)
expr_stmt|;
name|device_add_child
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"mfip"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|bus_generic_attach
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|)
expr_stmt|;
comment|/* Start the timeout watchdog */
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|mfi_watchdog_callout
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|mfi_watchdog_callout
argument_list|,
name|mfi_cmd_timeout
operator|*
name|hz
argument_list|,
name|mfi_timeout
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_flags
operator|&
name|MFI_FLAGS_TBOLT
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|mfi_tbolt_sync_map_info
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_alloc_commands
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mfi_command
modifier|*
name|cm
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* 	 * XXX Should we allocate all the commands up front, or allocate on 	 * demand later like 'aac' does? 	 */
name|sc
operator|->
name|mfi_commands
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|mfi_commands
index|[
literal|0
index|]
argument_list|)
operator|*
name|sc
operator|->
name|mfi_max_fw_cmds
argument_list|,
name|M_MFIBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|mfi_max_fw_cmds
condition|;
name|i
operator|++
control|)
block|{
name|cm
operator|=
operator|&
name|sc
operator|->
name|mfi_commands
index|[
name|i
index|]
expr_stmt|;
name|cm
operator|->
name|cm_frame
operator|=
operator|(
expr|union
name|mfi_frame
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|sc
operator|->
name|mfi_frames
operator|+
name|sc
operator|->
name|mfi_cmd_size
operator|*
name|i
operator|)
expr_stmt|;
name|cm
operator|->
name|cm_frame_busaddr
operator|=
name|sc
operator|->
name|mfi_frames_busaddr
operator|+
name|sc
operator|->
name|mfi_cmd_size
operator|*
name|i
expr_stmt|;
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|context
operator|=
name|i
expr_stmt|;
name|cm
operator|->
name|cm_sense
operator|=
operator|&
name|sc
operator|->
name|mfi_sense
index|[
name|i
index|]
expr_stmt|;
name|cm
operator|->
name|cm_sense_busaddr
operator|=
name|sc
operator|->
name|mfi_sense_busaddr
operator|+
name|MFI_SENSE_LEN
operator|*
name|i
expr_stmt|;
name|cm
operator|->
name|cm_sc
operator|=
name|sc
expr_stmt|;
name|cm
operator|->
name|cm_index
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|,
literal|0
argument_list|,
operator|&
name|cm
operator|->
name|cm_dmamap
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Failed to allocate %d "
literal|"command blocks, only allocated %d\n"
argument_list|,
name|sc
operator|->
name|mfi_max_fw_cmds
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
name|cm
operator|=
operator|&
name|sc
operator|->
name|mfi_commands
index|[
name|i
index|]
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|sc
operator|->
name|mfi_commands
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mfi_commands
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|mfi_release_command
parameter_list|(
name|struct
name|mfi_command
modifier|*
name|cm
parameter_list|)
block|{
name|struct
name|mfi_frame_header
modifier|*
name|hdr
decl_stmt|;
name|uint32_t
modifier|*
name|hdr_data
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|cm
operator|->
name|cm_sc
operator|->
name|mfi_io_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * Zero out the important fields of the frame, but make sure the 	 * context field is preserved.  For efficiency, handle the fields 	 * as 32 bit words.  Clear out the first S/G entry too for safety. 	 */
name|hdr
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|header
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_data
operator|!=
name|NULL
operator|&&
name|hdr
operator|->
name|sg_count
condition|)
block|{
name|cm
operator|->
name|cm_sg
operator|->
name|sg32
index|[
literal|0
index|]
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|cm
operator|->
name|cm_sg
operator|->
name|sg32
index|[
literal|0
index|]
operator|.
name|addr
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Command may be on other queues e.g. busy queue depending on the 	 * flow of a previous call to mfi_mapcmd, so ensure its dequeued 	 * properly 	 */
if|if
condition|(
operator|(
name|cm
operator|->
name|cm_flags
operator|&
name|MFI_ON_MFIQ_BUSY
operator|)
operator|!=
literal|0
condition|)
name|mfi_remove_busy
argument_list|(
name|cm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|->
name|cm_flags
operator|&
name|MFI_ON_MFIQ_READY
operator|)
operator|!=
literal|0
condition|)
name|mfi_remove_ready
argument_list|(
name|cm
argument_list|)
expr_stmt|;
comment|/* We're not expecting it to be on any other queue but check */
if|if
condition|(
operator|(
name|cm
operator|->
name|cm_flags
operator|&
name|MFI_ON_MFIQ_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"Command %p is still on another queue, flags = %#x"
argument_list|,
name|cm
argument_list|,
name|cm
operator|->
name|cm_flags
argument_list|)
expr_stmt|;
block|}
comment|/* tbolt cleanup */
if|if
condition|(
operator|(
name|cm
operator|->
name|cm_flags
operator|&
name|MFI_CMD_TBOLT
operator|)
operator|!=
literal|0
condition|)
block|{
name|mfi_tbolt_return_cmd
argument_list|(
name|cm
operator|->
name|cm_sc
argument_list|,
name|cm
operator|->
name|cm_sc
operator|->
name|mfi_cmd_pool_tbolt
index|[
name|cm
operator|->
name|cm_extra_frames
operator|-
literal|1
index|]
argument_list|,
name|cm
argument_list|)
expr_stmt|;
block|}
name|hdr_data
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|cm
operator|->
name|cm_frame
expr_stmt|;
name|hdr_data
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* cmd, sense_len, cmd_status, scsi_status */
name|hdr_data
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* target_id, lun_id, cdb_len, sg_count */
name|hdr_data
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
comment|/* flags, timeout */
name|hdr_data
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
comment|/* data_len */
name|cm
operator|->
name|cm_extra_frames
operator|=
literal|0
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator|=
literal|0
expr_stmt|;
name|cm
operator|->
name|cm_complete
operator|=
name|NULL
expr_stmt|;
name|cm
operator|->
name|cm_private
operator|=
name|NULL
expr_stmt|;
name|cm
operator|->
name|cm_data
operator|=
name|NULL
expr_stmt|;
name|cm
operator|->
name|cm_sg
operator|=
literal|0
expr_stmt|;
name|cm
operator|->
name|cm_total_frame_size
operator|=
literal|0
expr_stmt|;
name|cm
operator|->
name|retry_for_fw_reset
operator|=
literal|0
expr_stmt|;
name|mfi_enqueue_free
argument_list|(
name|cm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|mfi_dcmd_command
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mfi_command
modifier|*
modifier|*
name|cmp
parameter_list|,
name|uint32_t
name|opcode
parameter_list|,
name|void
modifier|*
modifier|*
name|bufp
parameter_list|,
name|size_t
name|bufsize
parameter_list|)
block|{
name|struct
name|mfi_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|mfi_dcmd_frame
modifier|*
name|dcmd
decl_stmt|;
name|void
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|context
init|=
literal|0
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|cm
operator|=
name|mfi_dequeue_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|==
name|NULL
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* Zero out the MFI frame */
name|context
operator|=
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|context
expr_stmt|;
name|bzero
argument_list|(
name|cm
operator|->
name|cm_frame
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|mfi_frame
argument_list|)
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|context
operator|=
name|context
expr_stmt|;
if|if
condition|(
operator|(
name|bufsize
operator|>
literal|0
operator|)
operator|&&
operator|(
name|bufp
operator|!=
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|bufp
operator|==
name|NULL
condition|)
block|{
name|buf
operator|=
name|malloc
argument_list|(
name|bufsize
argument_list|,
name|M_MFIBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
operator|*
name|bufp
operator|=
name|buf
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|=
operator|*
name|bufp
expr_stmt|;
block|}
block|}
name|dcmd
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|dcmd
expr_stmt|;
name|bzero
argument_list|(
name|dcmd
operator|->
name|mbox
argument_list|,
name|MFI_MBOX_SIZE
argument_list|)
expr_stmt|;
name|dcmd
operator|->
name|header
operator|.
name|cmd
operator|=
name|MFI_CMD_DCMD
expr_stmt|;
name|dcmd
operator|->
name|header
operator|.
name|timeout
operator|=
literal|0
expr_stmt|;
name|dcmd
operator|->
name|header
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|dcmd
operator|->
name|header
operator|.
name|data_len
operator|=
name|bufsize
expr_stmt|;
name|dcmd
operator|->
name|header
operator|.
name|scsi_status
operator|=
literal|0
expr_stmt|;
name|dcmd
operator|->
name|opcode
operator|=
name|opcode
expr_stmt|;
name|cm
operator|->
name|cm_sg
operator|=
operator|&
name|dcmd
operator|->
name|sgl
expr_stmt|;
name|cm
operator|->
name|cm_total_frame_size
operator|=
name|MFI_DCMD_FRAME_SIZE
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator|=
literal|0
expr_stmt|;
name|cm
operator|->
name|cm_data
operator|=
name|buf
expr_stmt|;
name|cm
operator|->
name|cm_private
operator|=
name|buf
expr_stmt|;
name|cm
operator|->
name|cm_len
operator|=
name|bufsize
expr_stmt|;
operator|*
name|cmp
operator|=
name|cm
expr_stmt|;
if|if
condition|(
operator|(
name|bufp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|bufp
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|buf
operator|!=
name|NULL
operator|)
condition|)
operator|*
name|bufp
operator|=
name|buf
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_comms_init
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mfi_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|mfi_init_frame
modifier|*
name|init
decl_stmt|;
name|struct
name|mfi_init_qinfo
modifier|*
name|qinfo
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint32_t
name|context
init|=
literal|0
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|=
name|mfi_dequeue_free
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
comment|/* Zero out the MFI frame */
name|context
operator|=
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|context
expr_stmt|;
name|bzero
argument_list|(
name|cm
operator|->
name|cm_frame
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|mfi_frame
argument_list|)
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|context
operator|=
name|context
expr_stmt|;
comment|/* 	 * Abuse the SG list area of the frame to hold the init_qinfo 	 * object; 	 */
name|init
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|init
expr_stmt|;
name|qinfo
operator|=
operator|(
expr|struct
name|mfi_init_qinfo
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|init
operator|+
name|MFI_FRAME_SIZE
operator|)
expr_stmt|;
name|bzero
argument_list|(
name|qinfo
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mfi_init_qinfo
argument_list|)
argument_list|)
expr_stmt|;
name|qinfo
operator|->
name|rq_entries
operator|=
name|sc
operator|->
name|mfi_max_fw_cmds
operator|+
literal|1
expr_stmt|;
name|qinfo
operator|->
name|rq_addr_lo
operator|=
name|sc
operator|->
name|mfi_comms_busaddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|mfi_hwcomms
argument_list|,
name|hw_reply_q
argument_list|)
expr_stmt|;
name|qinfo
operator|->
name|pi_addr_lo
operator|=
name|sc
operator|->
name|mfi_comms_busaddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|mfi_hwcomms
argument_list|,
name|hw_pi
argument_list|)
expr_stmt|;
name|qinfo
operator|->
name|ci_addr_lo
operator|=
name|sc
operator|->
name|mfi_comms_busaddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|mfi_hwcomms
argument_list|,
name|hw_ci
argument_list|)
expr_stmt|;
name|init
operator|->
name|header
operator|.
name|cmd
operator|=
name|MFI_CMD_INIT
expr_stmt|;
name|init
operator|->
name|header
operator|.
name|data_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mfi_init_qinfo
argument_list|)
expr_stmt|;
name|init
operator|->
name|qinfo_new_addr_lo
operator|=
name|cm
operator|->
name|cm_frame_busaddr
operator|+
name|MFI_FRAME_SIZE
expr_stmt|;
name|cm
operator|->
name|cm_data
operator|=
name|NULL
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator|=
name|MFI_CMD_POLLED
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|mfi_mapcmd
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"failed to send init command\n"
argument_list|)
expr_stmt|;
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_get_controller_info
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mfi_command
modifier|*
name|cm
init|=
name|NULL
decl_stmt|;
name|struct
name|mfi_ctrl_info
modifier|*
name|ci
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|max_sectors_1
decl_stmt|,
name|max_sectors_2
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|mfi_dcmd_command
argument_list|(
name|sc
argument_list|,
operator|&
name|cm
argument_list|,
name|MFI_DCMD_CTRL_GETINFO
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|ci
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ci
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|cm
operator|->
name|cm_flags
operator|=
name|MFI_CMD_DATAIN
operator||
name|MFI_CMD_POLLED
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|mfi_mapcmd
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Failed to get controller info\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mfi_max_io
operator|=
operator|(
name|sc
operator|->
name|mfi_max_sge
operator|-
literal|1
operator|)
operator|*
name|PAGE_SIZE
operator|/
name|MFI_SECTOR_LEN
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|)
expr_stmt|;
name|max_sectors_1
operator|=
operator|(
literal|1
operator|<<
name|ci
operator|->
name|stripe_sz_ops
operator|.
name|max
operator|)
operator|*
name|ci
operator|->
name|max_strips_per_io
expr_stmt|;
name|max_sectors_2
operator|=
name|ci
operator|->
name|max_request_size
expr_stmt|;
name|sc
operator|->
name|mfi_max_io
operator|=
name|min
argument_list|(
name|max_sectors_1
argument_list|,
name|max_sectors_2
argument_list|)
expr_stmt|;
name|sc
operator|->
name|disableOnlineCtrlReset
operator|=
name|ci
operator|->
name|properties
operator|.
name|OnOffProperties
operator|.
name|disableOnlineCtrlReset
expr_stmt|;
name|out
label|:
if|if
condition|(
name|ci
condition|)
name|free
argument_list|(
name|ci
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
condition|)
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_get_log_state
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mfi_evt_log_state
modifier|*
modifier|*
name|log_state
parameter_list|)
block|{
name|struct
name|mfi_command
modifier|*
name|cm
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|error
operator|=
name|mfi_dcmd_command
argument_list|(
name|sc
argument_list|,
operator|&
name|cm
argument_list|,
name|MFI_DCMD_CTRL_EVENT_GETINFO
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
name|log_state
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|log_state
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|cm
operator|->
name|cm_flags
operator|=
name|MFI_CMD_DATAIN
operator||
name|MFI_CMD_POLLED
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|mfi_mapcmd
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Failed to get log state\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|cm
condition|)
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mfi_aen_setup
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|seq_start
parameter_list|)
block|{
name|struct
name|mfi_evt_log_state
modifier|*
name|log_state
init|=
name|NULL
decl_stmt|;
name|union
name|mfi_evt
name|class_locale
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|uint32_t
name|seq
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|class_locale
operator|.
name|members
operator|.
name|reserved
operator|=
literal|0
expr_stmt|;
name|class_locale
operator|.
name|members
operator|.
name|locale
operator|=
name|mfi_event_locale
expr_stmt|;
name|class_locale
operator|.
name|members
operator|.
name|evt_class
operator|=
name|mfi_event_class
expr_stmt|;
if|if
condition|(
name|seq_start
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|mfi_get_log_state
argument_list|(
name|sc
argument_list|,
operator|&
name|log_state
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|sc
operator|->
name|mfi_boot_seq_num
operator|=
name|log_state
operator|->
name|boot_seq_num
expr_stmt|;
comment|/* 		 * Walk through any events that fired since the last 		 * shutdown. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|mfi_parse_entries
argument_list|(
name|sc
argument_list|,
name|log_state
operator|->
name|shutdown_seq_num
argument_list|,
name|log_state
operator|->
name|newest_seq_num
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|seq
operator|=
name|log_state
operator|->
name|newest_seq_num
expr_stmt|;
block|}
else|else
name|seq
operator|=
name|seq_start
expr_stmt|;
name|error
operator|=
name|mfi_aen_register
argument_list|(
name|sc
argument_list|,
name|seq
argument_list|,
name|class_locale
operator|.
name|word
argument_list|)
expr_stmt|;
name|out
label|:
name|free
argument_list|(
name|log_state
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mfi_wait_command
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mfi_command
modifier|*
name|cm
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_complete
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * MegaCli can issue a DCMD of 0.  In this case do nothing 	 * and return 0 to it as status 	 */
if|if
condition|(
name|cm
operator|->
name|cm_frame
operator|->
name|dcmd
operator|.
name|opcode
operator|==
literal|0
condition|)
block|{
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|cmd_status
operator|=
name|MFI_STAT_OK
expr_stmt|;
name|cm
operator|->
name|cm_error
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|cm
operator|->
name|cm_error
operator|)
return|;
block|}
name|mfi_enqueue_ready
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|mfi_startio
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|->
name|cm_flags
operator|&
name|MFI_CMD_COMPLETED
operator|)
operator|==
literal|0
condition|)
name|msleep
argument_list|(
name|cm
argument_list|,
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|,
name|PRIBIO
argument_list|,
literal|"mfiwait"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|cm
operator|->
name|cm_error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|mfi_free
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mfi_command
modifier|*
name|cm
decl_stmt|;
name|int
name|i
decl_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|mfi_watchdog_callout
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_cdev
operator|!=
name|NULL
condition|)
name|destroy_dev
argument_list|(
name|sc
operator|->
name|mfi_cdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_commands
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|mfi_max_fw_cmds
condition|;
name|i
operator|++
control|)
block|{
name|cm
operator|=
operator|&
name|sc
operator|->
name|mfi_commands
index|[
name|i
index|]
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|sc
operator|->
name|mfi_commands
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mfi_commands
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|mfi_intr
condition|)
name|bus_teardown_intr
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
name|sc
operator|->
name|mfi_irq
argument_list|,
name|sc
operator|->
name|mfi_intr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_irq
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|mfi_irq_rid
argument_list|,
name|sc
operator|->
name|mfi_irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_sense_busaddr
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|mfi_sense_dmat
argument_list|,
name|sc
operator|->
name|mfi_sense_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_sense
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|mfi_sense_dmat
argument_list|,
name|sc
operator|->
name|mfi_sense
argument_list|,
name|sc
operator|->
name|mfi_sense_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_sense_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|mfi_sense_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_frames_busaddr
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|mfi_frames_dmat
argument_list|,
name|sc
operator|->
name|mfi_frames_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_frames
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|mfi_frames_dmat
argument_list|,
name|sc
operator|->
name|mfi_frames
argument_list|,
name|sc
operator|->
name|mfi_frames_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_frames_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|mfi_frames_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_comms_busaddr
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|mfi_comms_dmat
argument_list|,
name|sc
operator|->
name|mfi_comms_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_comms
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|mfi_comms_dmat
argument_list|,
name|sc
operator|->
name|mfi_comms
argument_list|,
name|sc
operator|->
name|mfi_comms_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_comms_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|mfi_comms_dmat
argument_list|)
expr_stmt|;
comment|/* ThunderBolt contiguous memory free here */
if|if
condition|(
name|sc
operator|->
name|mfi_flags
operator|&
name|MFI_FLAGS_TBOLT
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|mfi_tb_busaddr
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|mfi_tb_dmat
argument_list|,
name|sc
operator|->
name|mfi_tb_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|request_message_pool
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|mfi_tb_dmat
argument_list|,
name|sc
operator|->
name|request_message_pool
argument_list|,
name|sc
operator|->
name|mfi_tb_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_tb_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|mfi_tb_dmat
argument_list|)
expr_stmt|;
comment|/* Version buffer memory free */
comment|/* Start LSIP200113393 */
if|if
condition|(
name|sc
operator|->
name|verbuf_h_busaddr
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|verbuf_h_dmat
argument_list|,
name|sc
operator|->
name|verbuf_h_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|verbuf
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|verbuf_h_dmat
argument_list|,
name|sc
operator|->
name|verbuf
argument_list|,
name|sc
operator|->
name|verbuf_h_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|verbuf_h_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|verbuf_h_dmat
argument_list|)
expr_stmt|;
comment|/* End LSIP200113393 */
comment|/* ThunderBolt INIT packet memory Free */
if|if
condition|(
name|sc
operator|->
name|mfi_tb_init_busaddr
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|mfi_tb_init_dmat
argument_list|,
name|sc
operator|->
name|mfi_tb_init_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_tb_init
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|mfi_tb_init_dmat
argument_list|,
name|sc
operator|->
name|mfi_tb_init
argument_list|,
name|sc
operator|->
name|mfi_tb_init_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_tb_init_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|mfi_tb_init_dmat
argument_list|)
expr_stmt|;
comment|/* ThunderBolt IOC Init Desc memory free here */
if|if
condition|(
name|sc
operator|->
name|mfi_tb_ioc_init_busaddr
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|mfi_tb_ioc_init_dmat
argument_list|,
name|sc
operator|->
name|mfi_tb_ioc_init_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_tb_ioc_init_desc
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|mfi_tb_ioc_init_dmat
argument_list|,
name|sc
operator|->
name|mfi_tb_ioc_init_desc
argument_list|,
name|sc
operator|->
name|mfi_tb_ioc_init_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_tb_ioc_init_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|mfi_tb_ioc_init_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_cmd_pool_tbolt
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|mfi_max_fw_cmds
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|mfi_cmd_pool_tbolt
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sc
operator|->
name|mfi_cmd_pool_tbolt
index|[
name|i
index|]
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mfi_cmd_pool_tbolt
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|sc
operator|->
name|mfi_cmd_pool_tbolt
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mfi_cmd_pool_tbolt
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|request_desc_pool
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sc
operator|->
name|request_desc_pool
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
name|sc
operator|->
name|request_desc_pool
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|mfi_buffer_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_parent_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|mfi_parent_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
condition|)
block|{
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|sx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|mfi_config_lock
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|mfi_startup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|mfi_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|mfi_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|config_intrhook_disestablish
argument_list|(
operator|&
name|sc
operator|->
name|mfi_ich
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mfi_enable_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_config_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|mfi_ldprobe
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_flags
operator|&
name|MFI_FLAGS_SKINNY
condition|)
name|mfi_syspdprobe
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_config_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mfi_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|mfi_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mfi_command
modifier|*
name|cm
decl_stmt|;
name|uint32_t
name|pi
decl_stmt|,
name|ci
decl_stmt|,
name|context
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|mfi_softc
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_check_clear_intr
argument_list|(
name|sc
argument_list|)
condition|)
return|return;
name|restart
label|:
name|pi
operator|=
name|sc
operator|->
name|mfi_comms
operator|->
name|hw_pi
expr_stmt|;
name|ci
operator|=
name|sc
operator|->
name|mfi_comms
operator|->
name|hw_ci
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|ci
operator|!=
name|pi
condition|)
block|{
name|context
operator|=
name|sc
operator|->
name|mfi_comms
operator|->
name|hw_reply_q
index|[
name|ci
index|]
expr_stmt|;
if|if
condition|(
name|context
operator|<
name|sc
operator|->
name|mfi_max_fw_cmds
condition|)
block|{
name|cm
operator|=
operator|&
name|sc
operator|->
name|mfi_commands
index|[
name|context
index|]
expr_stmt|;
name|mfi_remove_busy
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_error
operator|=
literal|0
expr_stmt|;
name|mfi_complete
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|ci
operator|==
operator|(
name|sc
operator|->
name|mfi_max_fw_cmds
operator|+
literal|1
operator|)
condition|)
name|ci
operator|=
literal|0
expr_stmt|;
block|}
name|sc
operator|->
name|mfi_comms
operator|->
name|hw_ci
operator|=
name|ci
expr_stmt|;
comment|/* Give defered I/O a chance to run */
name|sc
operator|->
name|mfi_flags
operator|&=
operator|~
name|MFI_FLAGS_QFRZN
expr_stmt|;
name|mfi_startio
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Dummy read to flush the bus; this ensures that the indexes are up 	 * to date.  Restart processing if more commands have come it. 	 */
operator|(
name|void
operator|)
name|sc
operator|->
name|mfi_read_fw_status
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|!=
name|sc
operator|->
name|mfi_comms
operator|->
name|hw_pi
condition|)
goto|goto
name|restart
goto|;
return|return;
block|}
end_function

begin_function
name|int
name|mfi_shutdown
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mfi_dcmd_frame
modifier|*
name|dcmd
decl_stmt|;
name|struct
name|mfi_command
modifier|*
name|cm
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_aen_cm
operator|!=
name|NULL
condition|)
block|{
name|sc
operator|->
name|cm_aen_abort
operator|=
literal|1
expr_stmt|;
name|mfi_abort
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|mfi_aen_cm
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|mfi_map_sync_cm
operator|!=
name|NULL
condition|)
block|{
name|sc
operator|->
name|cm_map_abort
operator|=
literal|1
expr_stmt|;
name|mfi_abort
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|mfi_map_sync_cm
argument_list|)
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|mfi_dcmd_command
argument_list|(
name|sc
argument_list|,
operator|&
name|cm
argument_list|,
name|MFI_DCMD_CTRL_SHUTDOWN
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|dcmd
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|dcmd
expr_stmt|;
name|dcmd
operator|->
name|header
operator|.
name|flags
operator|=
name|MFI_FRAME_DIR_NONE
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator|=
name|MFI_CMD_POLLED
expr_stmt|;
name|cm
operator|->
name|cm_data
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|mfi_mapcmd
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Failed to shutdown controller\n"
argument_list|)
expr_stmt|;
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mfi_syspdprobe
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mfi_frame_header
modifier|*
name|hdr
decl_stmt|;
name|struct
name|mfi_command
modifier|*
name|cm
init|=
name|NULL
decl_stmt|;
name|struct
name|mfi_pd_list
modifier|*
name|pdlist
init|=
name|NULL
decl_stmt|;
name|struct
name|mfi_system_pd
modifier|*
name|syspd
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|struct
name|mfi_system_pending
modifier|*
name|syspd_pend
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|found
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|sc
operator|->
name|mfi_config_lock
argument_list|,
name|SA_XLOCKED
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* Add SYSTEM PD's */
name|error
operator|=
name|mfi_dcmd_command
argument_list|(
name|sc
argument_list|,
operator|&
name|cm
argument_list|,
name|MFI_DCMD_PD_LIST_QUERY
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|pdlist
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pdlist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Error while forming SYSTEM PD list\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|cm
operator|->
name|cm_flags
operator|=
name|MFI_CMD_DATAIN
operator||
name|MFI_CMD_POLLED
expr_stmt|;
name|cm
operator|->
name|cm_frame
operator|->
name|dcmd
operator|.
name|mbox
index|[
literal|0
index|]
operator|=
name|MR_PD_QUERY_TYPE_EXPOSED_TO_HOST
expr_stmt|;
name|cm
operator|->
name|cm_frame
operator|->
name|dcmd
operator|.
name|mbox
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mfi_mapcmd
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Failed to get syspd device listing\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|)
expr_stmt|;
name|hdr
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|header
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|cmd_status
operator|!=
name|MFI_STAT_OK
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"MFI_DCMD_PD_LIST_QUERY failed %x\n"
argument_list|,
name|hdr
operator|->
name|cmd_status
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Get each PD and add it to the system */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pdlist
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pdlist
operator|->
name|addr
index|[
name|i
index|]
operator|.
name|device_id
operator|==
name|pdlist
operator|->
name|addr
index|[
name|i
index|]
operator|.
name|encl_device_id
condition|)
continue|continue;
name|found
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|syspd
argument_list|,
argument|&sc->mfi_syspd_tqh
argument_list|,
argument|pd_link
argument_list|)
block|{
if|if
condition|(
name|syspd
operator|->
name|pd_id
operator|==
name|pdlist
operator|->
name|addr
index|[
name|i
index|]
operator|.
name|device_id
condition|)
name|found
operator|=
literal|1
expr_stmt|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|syspd_pend
argument_list|,
argument|&sc->mfi_syspd_pend_tqh
argument_list|,
argument|pd_link
argument_list|)
block|{
if|if
condition|(
name|syspd_pend
operator|->
name|pd_id
operator|==
name|pdlist
operator|->
name|addr
index|[
name|i
index|]
operator|.
name|device_id
condition|)
name|found
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|found
operator|==
literal|0
condition|)
name|mfi_add_sys_pd
argument_list|(
name|sc
argument_list|,
name|pdlist
operator|->
name|addr
index|[
name|i
index|]
operator|.
name|device_id
argument_list|)
expr_stmt|;
block|}
comment|/* Delete SYSPD's whose state has been changed */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|syspd
argument_list|,
argument|&sc->mfi_syspd_tqh
argument_list|,
argument|pd_link
argument_list|,
argument|tmp
argument_list|)
block|{
name|found
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pdlist
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|syspd
operator|->
name|pd_id
operator|==
name|pdlist
operator|->
name|addr
index|[
name|i
index|]
operator|.
name|device_id
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|found
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"DELETE\n"
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|device_delete_child
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
name|syspd
operator|->
name|pd_dev
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
block|}
block|}
name|out
label|:
if|if
condition|(
name|pdlist
condition|)
name|free
argument_list|(
name|pdlist
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
condition|)
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|mfi_ldprobe
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mfi_frame_header
modifier|*
name|hdr
decl_stmt|;
name|struct
name|mfi_command
modifier|*
name|cm
init|=
name|NULL
decl_stmt|;
name|struct
name|mfi_ld_list
modifier|*
name|list
init|=
name|NULL
decl_stmt|;
name|struct
name|mfi_disk
modifier|*
name|ld
decl_stmt|;
name|struct
name|mfi_disk_pending
modifier|*
name|ld_pend
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|sc
operator|->
name|mfi_config_lock
argument_list|,
name|SA_XLOCKED
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|error
operator|=
name|mfi_dcmd_command
argument_list|(
name|sc
argument_list|,
operator|&
name|cm
argument_list|,
name|MFI_DCMD_LD_GET_LIST
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|list
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|list
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|cm
operator|->
name|cm_flags
operator|=
name|MFI_CMD_DATAIN
expr_stmt|;
if|if
condition|(
name|mfi_wait_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Failed to get device listing\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|hdr
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|header
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|cmd_status
operator|!=
name|MFI_STAT_OK
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"MFI_DCMD_LD_GET_LIST failed %x\n"
argument_list|,
name|hdr
operator|->
name|cmd_status
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|list
operator|->
name|ld_count
condition|;
name|i
operator|++
control|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|ld
argument_list|,
argument|&sc->mfi_ld_tqh
argument_list|,
argument|ld_link
argument_list|)
block|{
if|if
condition|(
name|ld
operator|->
name|ld_id
operator|==
name|list
operator|->
name|ld_list
index|[
name|i
index|]
operator|.
name|ld
operator|.
name|v
operator|.
name|target_id
condition|)
goto|goto
name|skip_add
goto|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|ld_pend
argument_list|,
argument|&sc->mfi_ld_pend_tqh
argument_list|,
argument|ld_link
argument_list|)
block|{
if|if
condition|(
name|ld_pend
operator|->
name|ld_id
operator|==
name|list
operator|->
name|ld_list
index|[
name|i
index|]
operator|.
name|ld
operator|.
name|v
operator|.
name|target_id
condition|)
goto|goto
name|skip_add
goto|;
block|}
name|mfi_add_ld
argument_list|(
name|sc
argument_list|,
name|list
operator|->
name|ld_list
index|[
name|i
index|]
operator|.
name|ld
operator|.
name|v
operator|.
name|target_id
argument_list|)
expr_stmt|;
name|skip_add
label|:
empty_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|list
condition|)
name|free
argument_list|(
name|list
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
condition|)
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * The timestamp is the number of seconds since 00:00 Jan 1, 2000.  If  * the bits in 24-31 are all set, then it is the number of seconds since  * boot.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|format_timestamp
parameter_list|(
name|uint32_t
name|timestamp
parameter_list|)
block|{
specifier|static
name|char
name|buffer
index|[
literal|32
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|timestamp
operator|&
literal|0xff000000
operator|)
operator|==
literal|0xff000000
condition|)
name|snprintf
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
literal|"boot + %us"
argument_list|,
name|timestamp
operator|&
literal|0x00ffffff
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
literal|"%us"
argument_list|,
name|timestamp
argument_list|)
expr_stmt|;
return|return
operator|(
name|buffer
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|format_class
parameter_list|(
name|int8_t
name|class
parameter_list|)
block|{
specifier|static
name|char
name|buffer
index|[
literal|6
index|]
decl_stmt|;
switch|switch
condition|(
name|class
condition|)
block|{
case|case
name|MFI_EVT_CLASS_DEBUG
case|:
return|return
operator|(
literal|"debug"
operator|)
return|;
case|case
name|MFI_EVT_CLASS_PROGRESS
case|:
return|return
operator|(
literal|"progress"
operator|)
return|;
case|case
name|MFI_EVT_CLASS_INFO
case|:
return|return
operator|(
literal|"info"
operator|)
return|;
case|case
name|MFI_EVT_CLASS_WARNING
case|:
return|return
operator|(
literal|"WARN"
operator|)
return|;
case|case
name|MFI_EVT_CLASS_CRITICAL
case|:
return|return
operator|(
literal|"CRIT"
operator|)
return|;
case|case
name|MFI_EVT_CLASS_FATAL
case|:
return|return
operator|(
literal|"FATAL"
operator|)
return|;
case|case
name|MFI_EVT_CLASS_DEAD
case|:
return|return
operator|(
literal|"DEAD"
operator|)
return|;
default|default:
name|snprintf
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|class
argument_list|)
expr_stmt|;
return|return
operator|(
name|buffer
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mfi_decode_evt
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mfi_evt_detail
modifier|*
name|detail
parameter_list|)
block|{
name|struct
name|mfi_system_pd
modifier|*
name|syspd
init|=
name|NULL
decl_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"%d (%s/0x%04x/%s) - %s\n"
argument_list|,
name|detail
operator|->
name|seq
argument_list|,
name|format_timestamp
argument_list|(
name|detail
operator|->
name|time
argument_list|)
argument_list|,
name|detail
operator|->
name|evt_class
operator|.
name|members
operator|.
name|locale
argument_list|,
name|format_class
argument_list|(
name|detail
operator|->
name|evt_class
operator|.
name|members
operator|.
name|evt_class
argument_list|)
argument_list|,
name|detail
operator|->
name|description
argument_list|)
expr_stmt|;
comment|/* Don't act on old AEN's or while shutting down */
if|if
condition|(
name|detail
operator|->
name|seq
operator|<
name|sc
operator|->
name|mfi_boot_seq_num
operator|||
name|sc
operator|->
name|mfi_detaching
condition|)
return|return;
switch|switch
condition|(
name|detail
operator|->
name|arg_type
condition|)
block|{
case|case
name|MR_EVT_ARGS_NONE
case|:
if|if
condition|(
name|detail
operator|->
name|code
operator|==
name|MR_EVT_CTRL_HOST_BUS_SCAN_REQUESTED
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"HostBus scan raised\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mfi_detect_jbod_change
condition|)
block|{
comment|/* 				 * Probe for new SYSPD's and Delete 				 * invalid SYSPD's 				 */
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_config_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|mfi_syspdprobe
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_config_lock
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|MR_EVT_ARGS_LD_STATE
case|:
comment|/* During load time driver reads all the events starting 		 * from the one that has been logged after shutdown. Avoid 		 * these old events. 		 */
if|if
condition|(
name|detail
operator|->
name|args
operator|.
name|ld_state
operator|.
name|new_state
operator|==
name|MFI_LD_STATE_OFFLINE
condition|)
block|{
comment|/* Remove the LD */
name|struct
name|mfi_disk
modifier|*
name|ld
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ld
argument_list|,
argument|&sc->mfi_ld_tqh
argument_list|,
argument|ld_link
argument_list|)
block|{
if|if
condition|(
name|ld
operator|->
name|ld_id
operator|==
name|detail
operator|->
name|args
operator|.
name|ld_state
operator|.
name|ld
operator|.
name|target_id
condition|)
break|break;
block|}
comment|/* 			Fix: for kernel panics when SSCD is removed 			KASSERT(ld != NULL, ("volume dissappeared")); 			*/
if|if
condition|(
name|ld
operator|!=
name|NULL
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|device_delete_child
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
name|ld
operator|->
name|ld_dev
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|MR_EVT_ARGS_PD
case|:
if|if
condition|(
name|detail
operator|->
name|code
operator|==
name|MR_EVT_PD_REMOVED
condition|)
block|{
if|if
condition|(
name|mfi_detect_jbod_change
condition|)
block|{
comment|/* 				 * If the removed device is a SYSPD then 				 * delete it 				 */
name|TAILQ_FOREACH
argument_list|(
argument|syspd
argument_list|,
argument|&sc->mfi_syspd_tqh
argument_list|,
argument|pd_link
argument_list|)
block|{
if|if
condition|(
name|syspd
operator|->
name|pd_id
operator|==
name|detail
operator|->
name|args
operator|.
name|pd
operator|.
name|device_id
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|device_delete_child
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
name|syspd
operator|->
name|pd_dev
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
name|detail
operator|->
name|code
operator|==
name|MR_EVT_PD_INSERTED
condition|)
block|{
if|if
condition|(
name|mfi_detect_jbod_change
condition|)
block|{
comment|/* Probe for new SYSPD's */
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_config_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|mfi_syspdprobe
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_config_lock
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|mfi_cam_rescan_cb
operator|!=
name|NULL
operator|&&
operator|(
name|detail
operator|->
name|code
operator|==
name|MR_EVT_PD_INSERTED
operator|||
name|detail
operator|->
name|code
operator|==
name|MR_EVT_PD_REMOVED
operator|)
condition|)
block|{
name|sc
operator|->
name|mfi_cam_rescan_cb
argument_list|(
name|sc
argument_list|,
name|detail
operator|->
name|args
operator|.
name|pd
operator|.
name|device_id
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mfi_queue_evt
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mfi_evt_detail
modifier|*
name|detail
parameter_list|)
block|{
name|struct
name|mfi_evt_queue_elm
modifier|*
name|elm
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|elm
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|elm
argument_list|)
argument_list|,
name|M_MFIBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|elm
operator|==
name|NULL
condition|)
return|return;
name|memcpy
argument_list|(
operator|&
name|elm
operator|->
name|detail
argument_list|,
name|detail
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|detail
argument_list|)
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|mfi_evt_queue
argument_list|,
name|elm
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|taskqueue_swi
argument_list|,
operator|&
name|sc
operator|->
name|mfi_evt_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mfi_handle_evt
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|mfi_evt_queue_elm
argument_list|)
name|queue
expr_stmt|;
name|struct
name|mfi_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mfi_evt_queue_elm
modifier|*
name|elm
decl_stmt|;
name|sc
operator|=
name|context
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|queue
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|TAILQ_CONCAT
argument_list|(
operator|&
name|queue
argument_list|,
operator|&
name|sc
operator|->
name|mfi_evt_queue
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|elm
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|queue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|queue
argument_list|,
name|elm
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|mfi_decode_evt
argument_list|(
name|sc
argument_list|,
operator|&
name|elm
operator|->
name|detail
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|elm
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_aen_register
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|seq
parameter_list|,
name|int
name|locale
parameter_list|)
block|{
name|struct
name|mfi_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|mfi_dcmd_frame
modifier|*
name|dcmd
decl_stmt|;
name|union
name|mfi_evt
name|current_aen
decl_stmt|,
name|prior_aen
decl_stmt|;
name|struct
name|mfi_evt_detail
modifier|*
name|ed
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|current_aen
operator|.
name|word
operator|=
name|locale
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_aen_cm
operator|!=
name|NULL
condition|)
block|{
name|prior_aen
operator|.
name|word
operator|=
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|sc
operator|->
name|mfi_aen_cm
operator|->
name|cm_frame
operator|->
name|dcmd
operator|.
name|mbox
operator|)
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|prior_aen
operator|.
name|members
operator|.
name|evt_class
operator|<=
name|current_aen
operator|.
name|members
operator|.
name|evt_class
operator|&&
operator|!
operator|(
operator|(
name|prior_aen
operator|.
name|members
operator|.
name|locale
operator|&
name|current_aen
operator|.
name|members
operator|.
name|locale
operator|)
operator|^
name|current_aen
operator|.
name|members
operator|.
name|locale
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|prior_aen
operator|.
name|members
operator|.
name|locale
operator||=
name|current_aen
operator|.
name|members
operator|.
name|locale
expr_stmt|;
if|if
condition|(
name|prior_aen
operator|.
name|members
operator|.
name|evt_class
operator|<
name|current_aen
operator|.
name|members
operator|.
name|evt_class
condition|)
name|current_aen
operator|.
name|members
operator|.
name|evt_class
operator|=
name|prior_aen
operator|.
name|members
operator|.
name|evt_class
expr_stmt|;
name|mfi_abort
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|mfi_aen_cm
argument_list|)
expr_stmt|;
block|}
block|}
name|error
operator|=
name|mfi_dcmd_command
argument_list|(
name|sc
argument_list|,
operator|&
name|cm
argument_list|,
name|MFI_DCMD_CTRL_EVENT_WAIT
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|ed
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ed
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|dcmd
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|dcmd
expr_stmt|;
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|dcmd
operator|->
name|mbox
operator|)
index|[
literal|0
index|]
operator|=
name|seq
expr_stmt|;
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|dcmd
operator|->
name|mbox
operator|)
index|[
literal|1
index|]
operator|=
name|locale
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator|=
name|MFI_CMD_DATAIN
expr_stmt|;
name|cm
operator|->
name|cm_complete
operator|=
name|mfi_aen_complete
expr_stmt|;
name|sc
operator|->
name|last_seq_num
operator|=
name|seq
expr_stmt|;
name|sc
operator|->
name|mfi_aen_cm
operator|=
name|cm
expr_stmt|;
name|mfi_enqueue_ready
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|mfi_startio
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|out
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mfi_aen_complete
parameter_list|(
name|struct
name|mfi_command
modifier|*
name|cm
parameter_list|)
block|{
name|struct
name|mfi_frame_header
modifier|*
name|hdr
decl_stmt|;
name|struct
name|mfi_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mfi_evt_detail
modifier|*
name|detail
decl_stmt|;
name|struct
name|mfi_aen
modifier|*
name|mfi_aen_entry
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|int
name|seq
init|=
literal|0
decl_stmt|,
name|aborted
init|=
literal|0
decl_stmt|;
name|sc
operator|=
name|cm
operator|->
name|cm_sc
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_aen_cm
operator|==
name|NULL
condition|)
return|return;
name|hdr
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|header
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|cm_aen_abort
operator|||
name|hdr
operator|->
name|cmd_status
operator|==
name|MFI_STAT_INVALID_STATUS
condition|)
block|{
name|sc
operator|->
name|cm_aen_abort
operator|=
literal|0
expr_stmt|;
name|aborted
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|mfi_aen_triggered
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_poll_waiting
condition|)
block|{
name|sc
operator|->
name|mfi_poll_waiting
operator|=
literal|0
expr_stmt|;
name|selwakeup
argument_list|(
operator|&
name|sc
operator|->
name|mfi_select
argument_list|)
expr_stmt|;
block|}
name|detail
operator|=
name|cm
operator|->
name|cm_data
expr_stmt|;
name|mfi_queue_evt
argument_list|(
name|sc
argument_list|,
name|detail
argument_list|)
expr_stmt|;
name|seq
operator|=
name|detail
operator|->
name|seq
operator|+
literal|1
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|mfi_aen_entry
argument_list|,
argument|&sc->mfi_aen_pids
argument_list|,
argument|aen_link
argument_list|,
argument|tmp
argument_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|mfi_aen_pids
argument_list|,
name|mfi_aen_entry
argument_list|,
name|aen_link
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|mfi_aen_entry
operator|->
name|p
argument_list|)
expr_stmt|;
name|kern_psignal
argument_list|(
name|mfi_aen_entry
operator|->
name|p
argument_list|,
name|SIGIO
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|mfi_aen_entry
operator|->
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mfi_aen_entry
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|cm
operator|->
name|cm_data
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|mfi_aen_cm
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mfi_aen_cm
operator|=
name|NULL
expr_stmt|;
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
comment|/* set it up again so the driver can catch more events */
if|if
condition|(
operator|!
name|aborted
condition|)
name|mfi_aen_setup
argument_list|(
name|sc
argument_list|,
name|seq
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|MAX_EVENTS
value|15
end_define

begin_function
specifier|static
name|int
name|mfi_parse_entries
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|start_seq
parameter_list|,
name|int
name|stop_seq
parameter_list|)
block|{
name|struct
name|mfi_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|mfi_dcmd_frame
modifier|*
name|dcmd
decl_stmt|;
name|struct
name|mfi_evt_list
modifier|*
name|el
decl_stmt|;
name|union
name|mfi_evt
name|class_locale
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|seq
decl_stmt|,
name|size
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|class_locale
operator|.
name|members
operator|.
name|reserved
operator|=
literal|0
expr_stmt|;
name|class_locale
operator|.
name|members
operator|.
name|locale
operator|=
name|mfi_event_locale
expr_stmt|;
name|class_locale
operator|.
name|members
operator|.
name|evt_class
operator|=
name|mfi_event_class
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mfi_evt_list
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|mfi_evt_detail
argument_list|)
operator|*
operator|(
name|MAX_EVENTS
operator|-
literal|1
operator|)
expr_stmt|;
name|el
operator|=
name|malloc
argument_list|(
name|size
argument_list|,
name|M_MFIBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|el
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
for|for
control|(
name|seq
operator|=
name|start_seq
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|cm
operator|=
name|mfi_dequeue_free
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|el
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|dcmd
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|dcmd
expr_stmt|;
name|bzero
argument_list|(
name|dcmd
operator|->
name|mbox
argument_list|,
name|MFI_MBOX_SIZE
argument_list|)
expr_stmt|;
name|dcmd
operator|->
name|header
operator|.
name|cmd
operator|=
name|MFI_CMD_DCMD
expr_stmt|;
name|dcmd
operator|->
name|header
operator|.
name|timeout
operator|=
literal|0
expr_stmt|;
name|dcmd
operator|->
name|header
operator|.
name|data_len
operator|=
name|size
expr_stmt|;
name|dcmd
operator|->
name|opcode
operator|=
name|MFI_DCMD_CTRL_EVENT_GET
expr_stmt|;
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|dcmd
operator|->
name|mbox
operator|)
index|[
literal|0
index|]
operator|=
name|seq
expr_stmt|;
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|dcmd
operator|->
name|mbox
operator|)
index|[
literal|1
index|]
operator|=
name|class_locale
operator|.
name|word
expr_stmt|;
name|cm
operator|->
name|cm_sg
operator|=
operator|&
name|dcmd
operator|->
name|sgl
expr_stmt|;
name|cm
operator|->
name|cm_total_frame_size
operator|=
name|MFI_DCMD_FRAME_SIZE
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator|=
name|MFI_CMD_DATAIN
operator||
name|MFI_CMD_POLLED
expr_stmt|;
name|cm
operator|->
name|cm_data
operator|=
name|el
expr_stmt|;
name|cm
operator|->
name|cm_len
operator|=
name|size
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|mfi_mapcmd
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Failed to get controller entries\n"
argument_list|)
expr_stmt|;
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
break|break;
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|dcmd
operator|->
name|header
operator|.
name|cmd_status
operator|==
name|MFI_STAT_NOT_FOUND
condition|)
block|{
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dcmd
operator|->
name|header
operator|.
name|cmd_status
operator|!=
name|MFI_STAT_OK
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Error %d fetching controller entries\n"
argument_list|,
name|dcmd
operator|->
name|header
operator|.
name|cmd_status
argument_list|)
expr_stmt|;
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
break|break;
block|}
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|el
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
comment|/* 			 * If this event is newer than 'stop_seq' then 			 * break out of the loop.  Note that the log 			 * is a circular buffer so we have to handle 			 * the case that our stop point is earlier in 			 * the buffer than our start point. 			 */
if|if
condition|(
name|el
operator|->
name|event
index|[
name|i
index|]
operator|.
name|seq
operator|>=
name|stop_seq
condition|)
block|{
if|if
condition|(
name|start_seq
operator|<=
name|stop_seq
condition|)
break|break;
elseif|else
if|if
condition|(
name|el
operator|->
name|event
index|[
name|i
index|]
operator|.
name|seq
operator|<
name|start_seq
condition|)
break|break;
block|}
name|mfi_queue_evt
argument_list|(
name|sc
argument_list|,
operator|&
name|el
operator|->
name|event
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|seq
operator|=
name|el
operator|->
name|event
index|[
name|el
operator|->
name|count
operator|-
literal|1
index|]
operator|.
name|seq
operator|+
literal|1
expr_stmt|;
block|}
name|free
argument_list|(
name|el
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_add_ld
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|struct
name|mfi_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|mfi_dcmd_frame
modifier|*
name|dcmd
init|=
name|NULL
decl_stmt|;
name|struct
name|mfi_ld_info
modifier|*
name|ld_info
init|=
name|NULL
decl_stmt|;
name|struct
name|mfi_disk_pending
modifier|*
name|ld_pend
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|ld_pend
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ld_pend
argument_list|)
argument_list|,
name|M_MFIBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|ld_pend
operator|!=
name|NULL
condition|)
block|{
name|ld_pend
operator|->
name|ld_id
operator|=
name|id
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|mfi_ld_pend_tqh
argument_list|,
name|ld_pend
argument_list|,
name|ld_link
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|mfi_dcmd_command
argument_list|(
name|sc
argument_list|,
operator|&
name|cm
argument_list|,
name|MFI_DCMD_LD_GET_INFO
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|ld_info
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ld_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Failed to allocate for MFI_DCMD_LD_GET_INFO %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|ld_info
condition|)
name|free
argument_list|(
name|ld_info
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|cm
operator|->
name|cm_flags
operator|=
name|MFI_CMD_DATAIN
expr_stmt|;
name|dcmd
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|dcmd
expr_stmt|;
name|dcmd
operator|->
name|mbox
index|[
literal|0
index|]
operator|=
name|id
expr_stmt|;
if|if
condition|(
name|mfi_wait_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Failed to get logical drive: %d\n"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ld_info
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|ld_info
operator|->
name|ld_config
operator|.
name|params
operator|.
name|isSSCD
operator|!=
literal|1
condition|)
name|mfi_add_ld_complete
argument_list|(
name|cm
argument_list|)
expr_stmt|;
else|else
block|{
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
if|if
condition|(
name|ld_info
condition|)
comment|/* SSCD drives ld_info free here */
name|free
argument_list|(
name|ld_info
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mfi_add_ld_complete
parameter_list|(
name|struct
name|mfi_command
modifier|*
name|cm
parameter_list|)
block|{
name|struct
name|mfi_frame_header
modifier|*
name|hdr
decl_stmt|;
name|struct
name|mfi_ld_info
modifier|*
name|ld_info
decl_stmt|;
name|struct
name|mfi_softc
modifier|*
name|sc
decl_stmt|;
name|device_t
name|child
decl_stmt|;
name|sc
operator|=
name|cm
operator|->
name|cm_sc
expr_stmt|;
name|hdr
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|header
expr_stmt|;
name|ld_info
operator|=
name|cm
operator|->
name|cm_private
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|cm_map_abort
operator|||
name|hdr
operator|->
name|cmd_status
operator|!=
name|MFI_STAT_OK
condition|)
block|{
name|free
argument_list|(
name|ld_info
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|mfi_map_sync_cm
argument_list|)
expr_stmt|;
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
return|return;
block|}
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|mfi_map_sync_cm
argument_list|)
expr_stmt|;
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|child
operator|=
name|device_add_child
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"mfid"
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Failed to add logical disk\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ld_info
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|device_set_ivars
argument_list|(
name|child
argument_list|,
name|ld_info
argument_list|)
expr_stmt|;
name|device_set_desc
argument_list|(
name|child
argument_list|,
literal|"MFI Logical Disk"
argument_list|)
expr_stmt|;
name|bus_generic_attach
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_add_sys_pd
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|struct
name|mfi_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|mfi_dcmd_frame
modifier|*
name|dcmd
init|=
name|NULL
decl_stmt|;
name|struct
name|mfi_pd_info
modifier|*
name|pd_info
init|=
name|NULL
decl_stmt|;
name|struct
name|mfi_system_pending
modifier|*
name|syspd_pend
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|syspd_pend
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|syspd_pend
argument_list|)
argument_list|,
name|M_MFIBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|syspd_pend
operator|!=
name|NULL
condition|)
block|{
name|syspd_pend
operator|->
name|pd_id
operator|=
name|id
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|mfi_syspd_pend_tqh
argument_list|,
name|syspd_pend
argument_list|,
name|pd_link
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|mfi_dcmd_command
argument_list|(
name|sc
argument_list|,
operator|&
name|cm
argument_list|,
name|MFI_DCMD_PD_GET_INFO
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|pd_info
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pd_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Failed to allocated for MFI_DCMD_PD_GET_INFO %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|pd_info
condition|)
name|free
argument_list|(
name|pd_info
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|cm
operator|->
name|cm_flags
operator|=
name|MFI_CMD_DATAIN
operator||
name|MFI_CMD_POLLED
expr_stmt|;
name|dcmd
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|dcmd
expr_stmt|;
name|dcmd
operator|->
name|mbox
index|[
literal|0
index|]
operator|=
name|id
expr_stmt|;
name|dcmd
operator|->
name|header
operator|.
name|scsi_status
operator|=
literal|0
expr_stmt|;
name|dcmd
operator|->
name|header
operator|.
name|pad0
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|mfi_mapcmd
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Failed to get physical drive info %d\n"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pd_info
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|)
expr_stmt|;
name|mfi_add_sys_pd_complete
argument_list|(
name|cm
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mfi_add_sys_pd_complete
parameter_list|(
name|struct
name|mfi_command
modifier|*
name|cm
parameter_list|)
block|{
name|struct
name|mfi_frame_header
modifier|*
name|hdr
decl_stmt|;
name|struct
name|mfi_pd_info
modifier|*
name|pd_info
decl_stmt|;
name|struct
name|mfi_softc
modifier|*
name|sc
decl_stmt|;
name|device_t
name|child
decl_stmt|;
name|sc
operator|=
name|cm
operator|->
name|cm_sc
expr_stmt|;
name|hdr
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|header
expr_stmt|;
name|pd_info
operator|=
name|cm
operator|->
name|cm_private
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|cmd_status
operator|!=
name|MFI_STAT_OK
condition|)
block|{
name|free
argument_list|(
name|pd_info
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pd_info
operator|->
name|fw_state
operator|!=
name|MFI_PD_STATE_SYSTEM
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"PD=%x is not SYSTEM PD\n"
argument_list|,
name|pd_info
operator|->
name|ref
operator|.
name|v
operator|.
name|device_id
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pd_info
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
return|return;
block|}
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|child
operator|=
name|device_add_child
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"mfisyspd"
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Failed to add system pd\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pd_info
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|device_set_ivars
argument_list|(
name|child
argument_list|,
name|pd_info
argument_list|)
expr_stmt|;
name|device_set_desc
argument_list|(
name|child
argument_list|,
literal|"MFI System PD"
argument_list|)
expr_stmt|;
name|bus_generic_attach
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mfi_command
modifier|*
name|mfi_bio_command
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bio
modifier|*
name|bio
decl_stmt|;
name|struct
name|mfi_command
modifier|*
name|cm
init|=
name|NULL
decl_stmt|;
comment|/*reserving two commands to avoid starvation for IOCTL*/
if|if
condition|(
name|sc
operator|->
name|mfi_qstat
index|[
name|MFIQ_FREE
index|]
operator|.
name|q_length
operator|<
literal|2
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|bio
operator|=
name|mfi_dequeue_bio
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|bio
operator|->
name|bio_driver2
operator|==
name|MFI_LD_IO
condition|)
block|{
name|cm
operator|=
name|mfi_build_ldio
argument_list|(
name|sc
argument_list|,
name|bio
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|bio
operator|->
name|bio_driver2
operator|==
name|MFI_SYS_PD_IO
condition|)
block|{
name|cm
operator|=
name|mfi_build_syspdio
argument_list|(
name|sc
argument_list|,
name|bio
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|cm
condition|)
name|mfi_enqueue_bio
argument_list|(
name|sc
argument_list|,
name|bio
argument_list|)
expr_stmt|;
return|return
name|cm
return|;
block|}
end_function

begin_comment
comment|/*  * mostly copied from cam/scsi/scsi_all.c:scsi_read_write  */
end_comment

begin_function
name|int
name|mfi_build_cdb
parameter_list|(
name|int
name|readop
parameter_list|,
name|uint8_t
name|byte2
parameter_list|,
name|u_int64_t
name|lba
parameter_list|,
name|u_int32_t
name|block_count
parameter_list|,
name|uint8_t
modifier|*
name|cdb
parameter_list|)
block|{
name|int
name|cdb_len
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|lba
operator|&
literal|0x1fffff
operator|)
operator|==
name|lba
operator|)
operator|&&
operator|(
operator|(
name|block_count
operator|&
literal|0xff
operator|)
operator|==
name|block_count
operator|)
operator|&&
operator|(
name|byte2
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* We can fit in a 6 byte cdb */
name|struct
name|scsi_rw_6
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_rw_6
operator|*
operator|)
name|cdb
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|readop
condition|?
name|READ_6
else|:
name|WRITE_6
expr_stmt|;
name|scsi_ulto3b
argument_list|(
name|lba
argument_list|,
name|scsi_cmd
operator|->
name|addr
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|length
operator|=
name|block_count
operator|&
literal|0xff
expr_stmt|;
name|scsi_cmd
operator|->
name|control
operator|=
literal|0
expr_stmt|;
name|cdb_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|block_count
operator|&
literal|0xffff
operator|)
operator|==
name|block_count
operator|)
operator|&&
operator|(
operator|(
name|lba
operator|&
literal|0xffffffff
operator|)
operator|==
name|lba
operator|)
condition|)
block|{
comment|/* Need a 10 byte CDB */
name|struct
name|scsi_rw_10
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_rw_10
operator|*
operator|)
name|cdb
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|readop
condition|?
name|READ_10
else|:
name|WRITE_10
expr_stmt|;
name|scsi_cmd
operator|->
name|byte2
operator|=
name|byte2
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|lba
argument_list|,
name|scsi_cmd
operator|->
name|addr
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|reserved
operator|=
literal|0
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|block_count
argument_list|,
name|scsi_cmd
operator|->
name|length
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|control
operator|=
literal|0
expr_stmt|;
name|cdb_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|block_count
operator|&
literal|0xffffffff
operator|)
operator|==
name|block_count
operator|)
operator|&&
operator|(
operator|(
name|lba
operator|&
literal|0xffffffff
operator|)
operator|==
name|lba
operator|)
condition|)
block|{
comment|/* Block count is too big for 10 byte CDB use a 12 byte CDB */
name|struct
name|scsi_rw_12
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_rw_12
operator|*
operator|)
name|cdb
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|readop
condition|?
name|READ_12
else|:
name|WRITE_12
expr_stmt|;
name|scsi_cmd
operator|->
name|byte2
operator|=
name|byte2
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|lba
argument_list|,
name|scsi_cmd
operator|->
name|addr
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|reserved
operator|=
literal|0
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|block_count
argument_list|,
name|scsi_cmd
operator|->
name|length
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|control
operator|=
literal|0
expr_stmt|;
name|cdb_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * 16 byte CDB.  We'll only get here if the LBA is larger 		 * than 2^32 		 */
name|struct
name|scsi_rw_16
modifier|*
name|scsi_cmd
decl_stmt|;
name|scsi_cmd
operator|=
operator|(
expr|struct
name|scsi_rw_16
operator|*
operator|)
name|cdb
expr_stmt|;
name|scsi_cmd
operator|->
name|opcode
operator|=
name|readop
condition|?
name|READ_16
else|:
name|WRITE_16
expr_stmt|;
name|scsi_cmd
operator|->
name|byte2
operator|=
name|byte2
expr_stmt|;
name|scsi_u64to8b
argument_list|(
name|lba
argument_list|,
name|scsi_cmd
operator|->
name|addr
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|reserved
operator|=
literal|0
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|block_count
argument_list|,
name|scsi_cmd
operator|->
name|length
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|->
name|control
operator|=
literal|0
expr_stmt|;
name|cdb_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|scsi_cmd
argument_list|)
expr_stmt|;
block|}
return|return
name|cdb_len
return|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|unmapped_buf
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|struct
name|mfi_command
modifier|*
name|mfi_build_syspdio
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bio
modifier|*
name|bio
parameter_list|)
block|{
name|struct
name|mfi_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|mfi_pass_frame
modifier|*
name|pass
decl_stmt|;
name|uint32_t
name|context
init|=
literal|0
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|,
name|blkcount
init|=
literal|0
decl_stmt|,
name|readop
decl_stmt|;
name|uint8_t
name|cdb_len
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|=
name|mfi_dequeue_free
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Zero out the MFI frame */
name|context
operator|=
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|context
expr_stmt|;
name|bzero
argument_list|(
name|cm
operator|->
name|cm_frame
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|mfi_frame
argument_list|)
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|context
operator|=
name|context
expr_stmt|;
name|pass
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|pass
expr_stmt|;
name|bzero
argument_list|(
name|pass
operator|->
name|cdb
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|pass
operator|->
name|header
operator|.
name|cmd
operator|=
name|MFI_CMD_PD_SCSI_IO
expr_stmt|;
switch|switch
condition|(
name|bio
operator|->
name|bio_cmd
condition|)
block|{
case|case
name|BIO_READ
case|:
name|flags
operator|=
name|MFI_CMD_DATAIN
operator||
name|MFI_CMD_BIO
expr_stmt|;
name|readop
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|BIO_WRITE
case|:
name|flags
operator|=
name|MFI_CMD_DATAOUT
operator||
name|MFI_CMD_BIO
expr_stmt|;
name|readop
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
comment|/* TODO: what about BIO_DELETE??? */
name|panic
argument_list|(
literal|"Unsupported bio command %x\n"
argument_list|,
name|bio
operator|->
name|bio_cmd
argument_list|)
expr_stmt|;
block|}
comment|/* Cheat with the sector length to avoid a non-constant division */
name|blkcount
operator|=
name|howmany
argument_list|(
name|bio
operator|->
name|bio_bcount
argument_list|,
name|MFI_SECTOR_LEN
argument_list|)
expr_stmt|;
comment|/* Fill the LBA and Transfer length in CDB */
name|cdb_len
operator|=
name|mfi_build_cdb
argument_list|(
name|readop
argument_list|,
literal|0
argument_list|,
name|bio
operator|->
name|bio_pblkno
argument_list|,
name|blkcount
argument_list|,
name|pass
operator|->
name|cdb
argument_list|)
expr_stmt|;
name|pass
operator|->
name|header
operator|.
name|target_id
operator|=
operator|(
name|uintptr_t
operator|)
name|bio
operator|->
name|bio_driver1
expr_stmt|;
name|pass
operator|->
name|header
operator|.
name|lun_id
operator|=
literal|0
expr_stmt|;
name|pass
operator|->
name|header
operator|.
name|timeout
operator|=
literal|0
expr_stmt|;
name|pass
operator|->
name|header
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|pass
operator|->
name|header
operator|.
name|scsi_status
operator|=
literal|0
expr_stmt|;
name|pass
operator|->
name|header
operator|.
name|sense_len
operator|=
name|MFI_SENSE_LEN
expr_stmt|;
name|pass
operator|->
name|header
operator|.
name|data_len
operator|=
name|bio
operator|->
name|bio_bcount
expr_stmt|;
name|pass
operator|->
name|header
operator|.
name|cdb_len
operator|=
name|cdb_len
expr_stmt|;
name|pass
operator|->
name|sense_addr_lo
operator|=
operator|(
name|uint32_t
operator|)
name|cm
operator|->
name|cm_sense_busaddr
expr_stmt|;
name|pass
operator|->
name|sense_addr_hi
operator|=
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|uint64_t
operator|)
name|cm
operator|->
name|cm_sense_busaddr
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_complete
operator|=
name|mfi_bio_complete
expr_stmt|;
name|cm
operator|->
name|cm_private
operator|=
name|bio
expr_stmt|;
name|cm
operator|->
name|cm_data
operator|=
name|unmapped_buf
expr_stmt|;
name|cm
operator|->
name|cm_len
operator|=
name|bio
operator|->
name|bio_bcount
expr_stmt|;
name|cm
operator|->
name|cm_sg
operator|=
operator|&
name|pass
operator|->
name|sgl
expr_stmt|;
name|cm
operator|->
name|cm_total_frame_size
operator|=
name|MFI_PASS_FRAME_SIZE
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator|=
name|flags
expr_stmt|;
return|return
operator|(
name|cm
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mfi_command
modifier|*
name|mfi_build_ldio
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bio
modifier|*
name|bio
parameter_list|)
block|{
name|struct
name|mfi_io_frame
modifier|*
name|io
decl_stmt|;
name|struct
name|mfi_command
modifier|*
name|cm
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|uint32_t
name|blkcount
decl_stmt|;
name|uint32_t
name|context
init|=
literal|0
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|=
name|mfi_dequeue_free
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Zero out the MFI frame */
name|context
operator|=
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|context
expr_stmt|;
name|bzero
argument_list|(
name|cm
operator|->
name|cm_frame
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|mfi_frame
argument_list|)
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|context
operator|=
name|context
expr_stmt|;
name|io
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|io
expr_stmt|;
switch|switch
condition|(
name|bio
operator|->
name|bio_cmd
condition|)
block|{
case|case
name|BIO_READ
case|:
name|io
operator|->
name|header
operator|.
name|cmd
operator|=
name|MFI_CMD_LD_READ
expr_stmt|;
name|flags
operator|=
name|MFI_CMD_DATAIN
operator||
name|MFI_CMD_BIO
expr_stmt|;
break|break;
case|case
name|BIO_WRITE
case|:
name|io
operator|->
name|header
operator|.
name|cmd
operator|=
name|MFI_CMD_LD_WRITE
expr_stmt|;
name|flags
operator|=
name|MFI_CMD_DATAOUT
operator||
name|MFI_CMD_BIO
expr_stmt|;
break|break;
default|default:
comment|/* TODO: what about BIO_DELETE??? */
name|panic
argument_list|(
literal|"Unsupported bio command %x\n"
argument_list|,
name|bio
operator|->
name|bio_cmd
argument_list|)
expr_stmt|;
block|}
comment|/* Cheat with the sector length to avoid a non-constant division */
name|blkcount
operator|=
name|howmany
argument_list|(
name|bio
operator|->
name|bio_bcount
argument_list|,
name|MFI_SECTOR_LEN
argument_list|)
expr_stmt|;
name|io
operator|->
name|header
operator|.
name|target_id
operator|=
operator|(
name|uintptr_t
operator|)
name|bio
operator|->
name|bio_driver1
expr_stmt|;
name|io
operator|->
name|header
operator|.
name|timeout
operator|=
literal|0
expr_stmt|;
name|io
operator|->
name|header
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|io
operator|->
name|header
operator|.
name|scsi_status
operator|=
literal|0
expr_stmt|;
name|io
operator|->
name|header
operator|.
name|sense_len
operator|=
name|MFI_SENSE_LEN
expr_stmt|;
name|io
operator|->
name|header
operator|.
name|data_len
operator|=
name|blkcount
expr_stmt|;
name|io
operator|->
name|sense_addr_lo
operator|=
operator|(
name|uint32_t
operator|)
name|cm
operator|->
name|cm_sense_busaddr
expr_stmt|;
name|io
operator|->
name|sense_addr_hi
operator|=
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|uint64_t
operator|)
name|cm
operator|->
name|cm_sense_busaddr
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|io
operator|->
name|lba_hi
operator|=
operator|(
name|bio
operator|->
name|bio_pblkno
operator|&
literal|0xffffffff00000000
operator|)
operator|>>
literal|32
expr_stmt|;
name|io
operator|->
name|lba_lo
operator|=
name|bio
operator|->
name|bio_pblkno
operator|&
literal|0xffffffff
expr_stmt|;
name|cm
operator|->
name|cm_complete
operator|=
name|mfi_bio_complete
expr_stmt|;
name|cm
operator|->
name|cm_private
operator|=
name|bio
expr_stmt|;
name|cm
operator|->
name|cm_data
operator|=
name|unmapped_buf
expr_stmt|;
name|cm
operator|->
name|cm_len
operator|=
name|bio
operator|->
name|bio_bcount
expr_stmt|;
name|cm
operator|->
name|cm_sg
operator|=
operator|&
name|io
operator|->
name|sgl
expr_stmt|;
name|cm
operator|->
name|cm_total_frame_size
operator|=
name|MFI_IO_FRAME_SIZE
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator|=
name|flags
expr_stmt|;
return|return
operator|(
name|cm
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mfi_bio_complete
parameter_list|(
name|struct
name|mfi_command
modifier|*
name|cm
parameter_list|)
block|{
name|struct
name|bio
modifier|*
name|bio
decl_stmt|;
name|struct
name|mfi_frame_header
modifier|*
name|hdr
decl_stmt|;
name|struct
name|mfi_softc
modifier|*
name|sc
decl_stmt|;
name|bio
operator|=
name|cm
operator|->
name|cm_private
expr_stmt|;
name|hdr
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|header
expr_stmt|;
name|sc
operator|=
name|cm
operator|->
name|cm_sc
expr_stmt|;
if|if
condition|(
operator|(
name|hdr
operator|->
name|cmd_status
operator|!=
name|MFI_STAT_OK
operator|)
operator|||
operator|(
name|hdr
operator|->
name|scsi_status
operator|!=
literal|0
operator|)
condition|)
block|{
name|bio
operator|->
name|bio_flags
operator||=
name|BIO_ERROR
expr_stmt|;
name|bio
operator|->
name|bio_error
operator|=
name|EIO
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"I/O error, cmd=%p, status=%#x, "
literal|"scsi_status=%#x\n"
argument_list|,
name|cm
argument_list|,
name|hdr
operator|->
name|cmd_status
argument_list|,
name|hdr
operator|->
name|scsi_status
argument_list|)
expr_stmt|;
name|mfi_print_sense
argument_list|(
name|cm
operator|->
name|cm_sc
argument_list|,
name|cm
operator|->
name|cm_sense
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cm
operator|->
name|cm_error
operator|!=
literal|0
condition|)
block|{
name|bio
operator|->
name|bio_flags
operator||=
name|BIO_ERROR
expr_stmt|;
name|bio
operator|->
name|bio_error
operator|=
name|cm
operator|->
name|cm_error
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"I/O error, cmd=%p, error=%#x\n"
argument_list|,
name|cm
argument_list|,
name|cm
operator|->
name|cm_error
argument_list|)
expr_stmt|;
block|}
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|mfi_disk_complete
argument_list|(
name|bio
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mfi_startio
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mfi_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccbh
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Don't bother if we're short on resources */
if|if
condition|(
name|sc
operator|->
name|mfi_flags
operator|&
name|MFI_FLAGS_QFRZN
condition|)
break|break;
comment|/* Try a command that has already been prepared */
name|cm
operator|=
name|mfi_dequeue_ready
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|ccbh
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|mfi_cam_ccbq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|cm
operator|=
name|sc
operator|->
name|mfi_cam_start
argument_list|(
name|ccbh
argument_list|)
expr_stmt|;
block|}
comment|/* Nope, so look for work on the bioq */
if|if
condition|(
name|cm
operator|==
name|NULL
condition|)
name|cm
operator|=
name|mfi_bio_command
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* No work available, so exit */
if|if
condition|(
name|cm
operator|==
name|NULL
condition|)
break|break;
comment|/* Send the command to the controller */
if|if
condition|(
name|mfi_mapcmd
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Failed to startio\n"
argument_list|)
expr_stmt|;
name|mfi_requeue_ready
argument_list|(
name|cm
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
name|int
name|mfi_mapcmd
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mfi_command
modifier|*
name|cm
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|polled
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|->
name|cm_data
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|cmd
operator|!=
name|MFI_CMD_STP
operator|)
condition|)
block|{
name|polled
operator|=
operator|(
name|cm
operator|->
name|cm_flags
operator|&
name|MFI_CMD_POLLED
operator|)
condition|?
name|BUS_DMA_NOWAIT
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|MFI_CMD_CCB
condition|)
name|error
operator|=
name|bus_dmamap_load_ccb
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|,
name|cm
operator|->
name|cm_data
argument_list|,
name|mfi_data_cb
argument_list|,
name|cm
argument_list|,
name|polled
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|MFI_CMD_BIO
condition|)
name|error
operator|=
name|bus_dmamap_load_bio
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|,
name|cm
operator|->
name|cm_private
argument_list|,
name|mfi_data_cb
argument_list|,
name|cm
argument_list|,
name|polled
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|,
name|cm
operator|->
name|cm_data
argument_list|,
name|cm
operator|->
name|cm_len
argument_list|,
name|mfi_data_cb
argument_list|,
name|cm
argument_list|,
name|polled
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINPROGRESS
condition|)
block|{
name|sc
operator|->
name|mfi_flags
operator||=
name|MFI_FLAGS_QFRZN
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
else|else
block|{
name|error
operator|=
name|mfi_send_frame
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mfi_data_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|mfi_frame_header
modifier|*
name|hdr
decl_stmt|;
name|struct
name|mfi_command
modifier|*
name|cm
decl_stmt|;
name|union
name|mfi_sgl
modifier|*
name|sgl
decl_stmt|;
name|struct
name|mfi_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|first
decl_stmt|,
name|dir
decl_stmt|;
name|int
name|sge_size
decl_stmt|,
name|locked
decl_stmt|;
name|cm
operator|=
operator|(
expr|struct
name|mfi_command
operator|*
operator|)
name|arg
expr_stmt|;
name|sc
operator|=
name|cm
operator|->
name|cm_sc
expr_stmt|;
name|hdr
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|header
expr_stmt|;
name|sgl
operator|=
name|cm
operator|->
name|cm_sg
expr_stmt|;
comment|/* 	 * We need to check if we have the lock as this is async 	 * callback so even though our caller mfi_mapcmd asserts 	 * it has the lock, there is no guarantee that hasn't been 	 * dropped if bus_dmamap_load returned prior to our 	 * completion. 	 */
if|if
condition|(
operator|(
name|locked
operator|=
name|mtx_owned
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"error %d in callback\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_error
operator|=
name|error
expr_stmt|;
name|mfi_complete
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Use IEEE sgl only for IO's on a SKINNY controller 	 * For other commands on a SKINNY controller use either 	 * sg32 or sg64 based on the sizeof(bus_addr_t). 	 * Also calculate the total frame size based on the type 	 * of SGL used. 	 */
if|if
condition|(
operator|(
operator|(
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|cmd
operator|==
name|MFI_CMD_PD_SCSI_IO
operator|)
operator|||
operator|(
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|cmd
operator|==
name|MFI_CMD_LD_READ
operator|)
operator|||
operator|(
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|cmd
operator|==
name|MFI_CMD_LD_WRITE
operator|)
operator|)
operator|&&
operator|(
name|sc
operator|->
name|mfi_flags
operator|&
name|MFI_FLAGS_SKINNY
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsegs
condition|;
name|i
operator|++
control|)
block|{
name|sgl
operator|->
name|sg_skinny
index|[
name|i
index|]
operator|.
name|addr
operator|=
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
expr_stmt|;
name|sgl
operator|->
name|sg_skinny
index|[
name|i
index|]
operator|.
name|len
operator|=
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
expr_stmt|;
name|sgl
operator|->
name|sg_skinny
index|[
name|i
index|]
operator|.
name|flag
operator|=
literal|0
expr_stmt|;
block|}
name|hdr
operator|->
name|flags
operator||=
name|MFI_FRAME_IEEE_SGL
operator||
name|MFI_FRAME_SGL64
expr_stmt|;
name|sge_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mfi_sg_skinny
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|sg_count
operator|=
name|nsegs
expr_stmt|;
block|}
else|else
block|{
name|j
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|cmd
operator|==
name|MFI_CMD_STP
condition|)
block|{
name|first
operator|=
name|cm
operator|->
name|cm_stp_len
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|mfi_flags
operator|&
name|MFI_FLAGS_SG64
operator|)
operator|==
literal|0
condition|)
block|{
name|sgl
operator|->
name|sg32
index|[
name|j
index|]
operator|.
name|addr
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
name|sgl
operator|->
name|sg32
index|[
name|j
operator|++
index|]
operator|.
name|len
operator|=
name|first
expr_stmt|;
block|}
else|else
block|{
name|sgl
operator|->
name|sg64
index|[
name|j
index|]
operator|.
name|addr
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
name|sgl
operator|->
name|sg64
index|[
name|j
operator|++
index|]
operator|.
name|len
operator|=
name|first
expr_stmt|;
block|}
block|}
else|else
name|first
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|mfi_flags
operator|&
name|MFI_FLAGS_SG64
operator|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsegs
condition|;
name|i
operator|++
control|)
block|{
name|sgl
operator|->
name|sg32
index|[
name|j
index|]
operator|.
name|addr
operator|=
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
operator|+
name|first
expr_stmt|;
name|sgl
operator|->
name|sg32
index|[
name|j
operator|++
index|]
operator|.
name|len
operator|=
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
operator|-
name|first
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsegs
condition|;
name|i
operator|++
control|)
block|{
name|sgl
operator|->
name|sg64
index|[
name|j
index|]
operator|.
name|addr
operator|=
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
operator|+
name|first
expr_stmt|;
name|sgl
operator|->
name|sg64
index|[
name|j
operator|++
index|]
operator|.
name|len
operator|=
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
operator|-
name|first
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
name|hdr
operator|->
name|flags
operator||=
name|MFI_FRAME_SGL64
expr_stmt|;
block|}
name|hdr
operator|->
name|sg_count
operator|=
name|j
expr_stmt|;
name|sge_size
operator|=
name|sc
operator|->
name|mfi_sge_size
expr_stmt|;
block|}
name|dir
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|MFI_CMD_DATAIN
condition|)
block|{
name|dir
operator||=
name|BUS_DMASYNC_PREREAD
expr_stmt|;
name|hdr
operator|->
name|flags
operator||=
name|MFI_FRAME_DIR_READ
expr_stmt|;
block|}
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|MFI_CMD_DATAOUT
condition|)
block|{
name|dir
operator||=
name|BUS_DMASYNC_PREWRITE
expr_stmt|;
name|hdr
operator|->
name|flags
operator||=
name|MFI_FRAME_DIR_WRITE
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator||=
name|MFI_CMD_MAPPED
expr_stmt|;
comment|/* 	 * Instead of calculating the total number of frames in the 	 * compound frame, it's already assumed that there will be at 	 * least 1 frame, so don't compensate for the modulo of the 	 * following division. 	 */
name|cm
operator|->
name|cm_total_frame_size
operator|+=
operator|(
name|sc
operator|->
name|mfi_sge_size
operator|*
name|nsegs
operator|)
expr_stmt|;
name|cm
operator|->
name|cm_extra_frames
operator|=
operator|(
name|cm
operator|->
name|cm_total_frame_size
operator|-
literal|1
operator|)
operator|/
name|MFI_FRAME_SIZE
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|mfi_send_frame
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"error %d in callback from mfi_send_frame\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_error
operator|=
name|error
expr_stmt|;
name|mfi_complete
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|out
label|:
comment|/* leave the lock in the state we found it */
if|if
condition|(
name|locked
operator|==
literal|0
condition|)
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_send_frame
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mfi_command
modifier|*
name|cm
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|MFA_enabled
condition|)
name|error
operator|=
name|mfi_tbolt_send_frame
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|mfi_std_send_frame
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
operator|(
name|cm
operator|->
name|cm_flags
operator|&
name|MFI_ON_MFIQ_BUSY
operator|)
operator|!=
literal|0
condition|)
name|mfi_remove_busy
argument_list|(
name|cm
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_std_send_frame
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mfi_command
modifier|*
name|cm
parameter_list|)
block|{
name|struct
name|mfi_frame_header
modifier|*
name|hdr
decl_stmt|;
name|int
name|tm
init|=
name|mfi_polled_cmd_timeout
operator|*
literal|1000
decl_stmt|;
name|hdr
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|header
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|->
name|cm_flags
operator|&
name|MFI_CMD_POLLED
operator|)
operator|==
literal|0
condition|)
block|{
name|cm
operator|->
name|cm_timestamp
operator|=
name|time_uptime
expr_stmt|;
name|mfi_enqueue_busy
argument_list|(
name|cm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hdr
operator|->
name|cmd_status
operator|=
name|MFI_STAT_INVALID_STATUS
expr_stmt|;
name|hdr
operator|->
name|flags
operator||=
name|MFI_FRAME_DONT_POST_IN_REPLY_QUEUE
expr_stmt|;
block|}
comment|/* 	 * The bus address of the command is aligned on a 64 byte boundary, 	 * leaving the least 6 bits as zero.  For whatever reason, the 	 * hardware wants the address shifted right by three, leaving just 	 * 3 zero bits.  These three bits are then used as a prefetching 	 * hint for the hardware to predict how many frames need to be 	 * fetched across the bus.  If a command has more than 8 frames 	 * then the 3 bits are set to 0x7 and the firmware uses other 	 * information in the command to determine the total amount to fetch. 	 * However, FreeBSD doesn't support I/O larger than 128K, so 8 frames 	 * is enough for both 32bit and 64bit systems. 	 */
if|if
condition|(
name|cm
operator|->
name|cm_extra_frames
operator|>
literal|7
condition|)
name|cm
operator|->
name|cm_extra_frames
operator|=
literal|7
expr_stmt|;
name|sc
operator|->
name|mfi_issue_cmd
argument_list|(
name|sc
argument_list|,
name|cm
operator|->
name|cm_frame_busaddr
argument_list|,
name|cm
operator|->
name|cm_extra_frames
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|->
name|cm_flags
operator|&
name|MFI_CMD_POLLED
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* This is a polled command, so busy-wait for it to complete. */
while|while
condition|(
name|hdr
operator|->
name|cmd_status
operator|==
name|MFI_STAT_INVALID_STATUS
condition|)
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|tm
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|tm
operator|<=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|hdr
operator|->
name|cmd_status
operator|==
name|MFI_STAT_INVALID_STATUS
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Frame %p timed out "
literal|"command 0x%X\n"
argument_list|,
name|hdr
argument_list|,
name|cm
operator|->
name|cm_frame
operator|->
name|dcmd
operator|.
name|opcode
argument_list|)
expr_stmt|;
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|mfi_complete
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mfi_command
modifier|*
name|cm
parameter_list|)
block|{
name|int
name|dir
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|->
name|cm_flags
operator|&
name|MFI_CMD_MAPPED
operator|)
operator|!=
literal|0
condition|)
block|{
name|dir
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|->
name|cm_flags
operator|&
name|MFI_CMD_DATAIN
operator|)
operator|||
operator|(
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|cmd
operator|==
name|MFI_CMD_STP
operator|)
condition|)
name|dir
operator||=
name|BUS_DMASYNC_POSTREAD
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|MFI_CMD_DATAOUT
condition|)
name|dir
operator||=
name|BUS_DMASYNC_POSTWRITE
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator|&=
operator|~
name|MFI_CMD_MAPPED
expr_stmt|;
block|}
name|cm
operator|->
name|cm_flags
operator||=
name|MFI_CMD_COMPLETED
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_complete
operator|!=
name|NULL
condition|)
name|cm
operator|->
name|cm_complete
argument_list|(
name|cm
argument_list|)
expr_stmt|;
else|else
name|wakeup
argument_list|(
name|cm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_abort
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mfi_command
modifier|*
modifier|*
name|cm_abort
parameter_list|)
block|{
name|struct
name|mfi_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|mfi_abort_frame
modifier|*
name|abort
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|error
decl_stmt|;
name|uint32_t
name|context
init|=
literal|0
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|=
name|mfi_dequeue_free
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
comment|/* Zero out the MFI frame */
name|context
operator|=
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|context
expr_stmt|;
name|bzero
argument_list|(
name|cm
operator|->
name|cm_frame
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|mfi_frame
argument_list|)
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|context
operator|=
name|context
expr_stmt|;
name|abort
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|abort
expr_stmt|;
name|abort
operator|->
name|header
operator|.
name|cmd
operator|=
name|MFI_CMD_ABORT
expr_stmt|;
name|abort
operator|->
name|header
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|abort
operator|->
name|header
operator|.
name|scsi_status
operator|=
literal|0
expr_stmt|;
name|abort
operator|->
name|abort_context
operator|=
operator|(
operator|*
name|cm_abort
operator|)
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|context
expr_stmt|;
name|abort
operator|->
name|abort_mfi_addr_lo
operator|=
call|(
name|uint32_t
call|)
argument_list|(
operator|*
name|cm_abort
argument_list|)
operator|->
name|cm_frame_busaddr
expr_stmt|;
name|abort
operator|->
name|abort_mfi_addr_hi
operator|=
call|(
name|uint32_t
call|)
argument_list|(
call|(
name|uint64_t
call|)
argument_list|(
operator|*
name|cm_abort
argument_list|)
operator|->
name|cm_frame_busaddr
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_data
operator|=
name|NULL
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator|=
name|MFI_CMD_POLLED
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|mfi_mapcmd
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"failed to abort command\n"
argument_list|)
expr_stmt|;
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
literal|5
operator|&&
operator|*
name|cm_abort
operator|!=
name|NULL
condition|)
block|{
name|tsleep
argument_list|(
name|cm_abort
argument_list|,
literal|0
argument_list|,
literal|"mfiabort"
argument_list|,
literal|5
operator|*
name|hz
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cm_abort
operator|!=
name|NULL
condition|)
block|{
comment|/* Force a complete if command didn't abort */
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
operator|(
operator|*
name|cm_abort
operator|)
operator|->
name|cm_complete
argument_list|(
operator|*
name|cm_abort
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mfi_dump_blocks
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|id
parameter_list|,
name|uint64_t
name|lba
parameter_list|,
name|void
modifier|*
name|virt
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|mfi_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|mfi_io_frame
modifier|*
name|io
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint32_t
name|context
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|cm
operator|=
name|mfi_dequeue_free
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* Zero out the MFI frame */
name|context
operator|=
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|context
expr_stmt|;
name|bzero
argument_list|(
name|cm
operator|->
name|cm_frame
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|mfi_frame
argument_list|)
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|context
operator|=
name|context
expr_stmt|;
name|io
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|io
expr_stmt|;
name|io
operator|->
name|header
operator|.
name|cmd
operator|=
name|MFI_CMD_LD_WRITE
expr_stmt|;
name|io
operator|->
name|header
operator|.
name|target_id
operator|=
name|id
expr_stmt|;
name|io
operator|->
name|header
operator|.
name|timeout
operator|=
literal|0
expr_stmt|;
name|io
operator|->
name|header
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|io
operator|->
name|header
operator|.
name|scsi_status
operator|=
literal|0
expr_stmt|;
name|io
operator|->
name|header
operator|.
name|sense_len
operator|=
name|MFI_SENSE_LEN
expr_stmt|;
name|io
operator|->
name|header
operator|.
name|data_len
operator|=
name|howmany
argument_list|(
name|len
argument_list|,
name|MFI_SECTOR_LEN
argument_list|)
expr_stmt|;
name|io
operator|->
name|sense_addr_lo
operator|=
operator|(
name|uint32_t
operator|)
name|cm
operator|->
name|cm_sense_busaddr
expr_stmt|;
name|io
operator|->
name|sense_addr_hi
operator|=
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|uint64_t
operator|)
name|cm
operator|->
name|cm_sense_busaddr
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|io
operator|->
name|lba_hi
operator|=
operator|(
name|lba
operator|&
literal|0xffffffff00000000
operator|)
operator|>>
literal|32
expr_stmt|;
name|io
operator|->
name|lba_lo
operator|=
name|lba
operator|&
literal|0xffffffff
expr_stmt|;
name|cm
operator|->
name|cm_data
operator|=
name|virt
expr_stmt|;
name|cm
operator|->
name|cm_len
operator|=
name|len
expr_stmt|;
name|cm
operator|->
name|cm_sg
operator|=
operator|&
name|io
operator|->
name|sgl
expr_stmt|;
name|cm
operator|->
name|cm_total_frame_size
operator|=
name|MFI_IO_FRAME_SIZE
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator|=
name|MFI_CMD_POLLED
operator||
name|MFI_CMD_DATAOUT
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|mfi_mapcmd
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"failed dump blocks\n"
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|)
expr_stmt|;
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mfi_dump_syspd_blocks
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|id
parameter_list|,
name|uint64_t
name|lba
parameter_list|,
name|void
modifier|*
name|virt
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|mfi_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|mfi_pass_frame
modifier|*
name|pass
decl_stmt|;
name|int
name|error
decl_stmt|,
name|readop
decl_stmt|,
name|cdb_len
decl_stmt|;
name|uint32_t
name|blkcount
decl_stmt|;
if|if
condition|(
operator|(
name|cm
operator|=
name|mfi_dequeue_free
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|pass
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|pass
expr_stmt|;
name|bzero
argument_list|(
name|pass
operator|->
name|cdb
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|pass
operator|->
name|header
operator|.
name|cmd
operator|=
name|MFI_CMD_PD_SCSI_IO
expr_stmt|;
name|readop
operator|=
literal|0
expr_stmt|;
name|blkcount
operator|=
name|howmany
argument_list|(
name|len
argument_list|,
name|MFI_SECTOR_LEN
argument_list|)
expr_stmt|;
name|cdb_len
operator|=
name|mfi_build_cdb
argument_list|(
name|readop
argument_list|,
literal|0
argument_list|,
name|lba
argument_list|,
name|blkcount
argument_list|,
name|pass
operator|->
name|cdb
argument_list|)
expr_stmt|;
name|pass
operator|->
name|header
operator|.
name|target_id
operator|=
name|id
expr_stmt|;
name|pass
operator|->
name|header
operator|.
name|timeout
operator|=
literal|0
expr_stmt|;
name|pass
operator|->
name|header
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|pass
operator|->
name|header
operator|.
name|scsi_status
operator|=
literal|0
expr_stmt|;
name|pass
operator|->
name|header
operator|.
name|sense_len
operator|=
name|MFI_SENSE_LEN
expr_stmt|;
name|pass
operator|->
name|header
operator|.
name|data_len
operator|=
name|len
expr_stmt|;
name|pass
operator|->
name|header
operator|.
name|cdb_len
operator|=
name|cdb_len
expr_stmt|;
name|pass
operator|->
name|sense_addr_lo
operator|=
operator|(
name|uint32_t
operator|)
name|cm
operator|->
name|cm_sense_busaddr
expr_stmt|;
name|pass
operator|->
name|sense_addr_hi
operator|=
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|uint64_t
operator|)
name|cm
operator|->
name|cm_sense_busaddr
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_data
operator|=
name|virt
expr_stmt|;
name|cm
operator|->
name|cm_len
operator|=
name|len
expr_stmt|;
name|cm
operator|->
name|cm_sg
operator|=
operator|&
name|pass
operator|->
name|sgl
expr_stmt|;
name|cm
operator|->
name|cm_total_frame_size
operator|=
name|MFI_PASS_FRAME_SIZE
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator|=
name|MFI_CMD_POLLED
operator||
name|MFI_CMD_DATAOUT
operator||
name|MFI_CMD_SCSI
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|mfi_mapcmd
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"failed dump blocks\n"
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|)
expr_stmt|;
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|mfi_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_detaching
condition|)
name|error
operator|=
name|ENXIO
expr_stmt|;
else|else
block|{
name|sc
operator|->
name|mfi_flags
operator||=
name|MFI_FLAGS_OPEN
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|mfi_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mfi_aen
modifier|*
name|mfi_aen_entry
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mfi_flags
operator|&=
operator|~
name|MFI_FLAGS_OPEN
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|mfi_aen_entry
argument_list|,
argument|&sc->mfi_aen_pids
argument_list|,
argument|aen_link
argument_list|,
argument|tmp
argument_list|)
block|{
if|if
condition|(
name|mfi_aen_entry
operator|->
name|p
operator|==
name|curproc
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|mfi_aen_pids
argument_list|,
name|mfi_aen_entry
argument_list|,
name|aen_link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mfi_aen_entry
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_config_lock
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|opcode
parameter_list|)
block|{
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|MFI_DCMD_LD_DELETE
case|:
case|case
name|MFI_DCMD_CFG_ADD
case|:
case|case
name|MFI_DCMD_CFG_CLEAR
case|:
case|case
name|MFI_DCMD_CFG_FOREIGN_IMPORT
case|:
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_config_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mfi_config_unlock
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|locked
parameter_list|)
block|{
if|if
condition|(
name|locked
condition|)
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_config_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Perform pre-issue checks on commands from userland and possibly veto  * them.  */
end_comment

begin_function
specifier|static
name|int
name|mfi_check_command_pre
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mfi_command
modifier|*
name|cm
parameter_list|)
block|{
name|struct
name|mfi_disk
modifier|*
name|ld
decl_stmt|,
modifier|*
name|ld2
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|mfi_system_pd
modifier|*
name|syspd
init|=
name|NULL
decl_stmt|;
name|uint16_t
name|syspd_id
decl_stmt|;
name|uint16_t
modifier|*
name|mbox
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cm
operator|->
name|cm_frame
operator|->
name|dcmd
operator|.
name|opcode
condition|)
block|{
case|case
name|MFI_DCMD_LD_DELETE
case|:
name|TAILQ_FOREACH
argument_list|(
argument|ld
argument_list|,
argument|&sc->mfi_ld_tqh
argument_list|,
argument|ld_link
argument_list|)
block|{
if|if
condition|(
name|ld
operator|->
name|ld_id
operator|==
name|cm
operator|->
name|cm_frame
operator|->
name|dcmd
operator|.
name|mbox
index|[
literal|0
index|]
condition|)
break|break;
block|}
if|if
condition|(
name|ld
operator|==
name|NULL
condition|)
name|error
operator|=
name|ENOENT
expr_stmt|;
else|else
name|error
operator|=
name|mfi_disk_disable
argument_list|(
name|ld
argument_list|)
expr_stmt|;
break|break;
case|case
name|MFI_DCMD_CFG_CLEAR
case|:
name|TAILQ_FOREACH
argument_list|(
argument|ld
argument_list|,
argument|&sc->mfi_ld_tqh
argument_list|,
argument|ld_link
argument_list|)
block|{
name|error
operator|=
name|mfi_disk_disable
argument_list|(
name|ld
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|ld2
argument_list|,
argument|&sc->mfi_ld_tqh
argument_list|,
argument|ld_link
argument_list|)
block|{
if|if
condition|(
name|ld2
operator|==
name|ld
condition|)
break|break;
name|mfi_disk_enable
argument_list|(
name|ld2
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|MFI_DCMD_PD_STATE_SET
case|:
name|mbox
operator|=
operator|(
name|uint16_t
operator|*
operator|)
name|cm
operator|->
name|cm_frame
operator|->
name|dcmd
operator|.
name|mbox
expr_stmt|;
name|syspd_id
operator|=
name|mbox
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|mbox
index|[
literal|2
index|]
operator|==
name|MFI_PD_STATE_UNCONFIGURED_GOOD
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|syspd
argument_list|,
argument|&sc->mfi_syspd_tqh
argument_list|,
argument|pd_link
argument_list|)
block|{
if|if
condition|(
name|syspd
operator|->
name|pd_id
operator|==
name|syspd_id
condition|)
break|break;
block|}
block|}
else|else
break|break;
if|if
condition|(
name|syspd
condition|)
name|error
operator|=
name|mfi_syspd_disable
argument_list|(
name|syspd
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Perform post-issue checks on commands from userland. */
end_comment

begin_function
specifier|static
name|void
name|mfi_check_command_post
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mfi_command
modifier|*
name|cm
parameter_list|)
block|{
name|struct
name|mfi_disk
modifier|*
name|ld
decl_stmt|,
modifier|*
name|ldn
decl_stmt|;
name|struct
name|mfi_system_pd
modifier|*
name|syspd
init|=
name|NULL
decl_stmt|;
name|uint16_t
name|syspd_id
decl_stmt|;
name|uint16_t
modifier|*
name|mbox
decl_stmt|;
switch|switch
condition|(
name|cm
operator|->
name|cm_frame
operator|->
name|dcmd
operator|.
name|opcode
condition|)
block|{
case|case
name|MFI_DCMD_LD_DELETE
case|:
name|TAILQ_FOREACH
argument_list|(
argument|ld
argument_list|,
argument|&sc->mfi_ld_tqh
argument_list|,
argument|ld_link
argument_list|)
block|{
if|if
condition|(
name|ld
operator|->
name|ld_id
operator|==
name|cm
operator|->
name|cm_frame
operator|->
name|dcmd
operator|.
name|mbox
index|[
literal|0
index|]
condition|)
break|break;
block|}
name|KASSERT
argument_list|(
name|ld
operator|!=
name|NULL
argument_list|,
operator|(
literal|"volume dissappeared"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|cmd_status
operator|==
name|MFI_STAT_OK
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|device_delete_child
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
name|ld
operator|->
name|ld_dev
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
block|}
else|else
name|mfi_disk_enable
argument_list|(
name|ld
argument_list|)
expr_stmt|;
break|break;
case|case
name|MFI_DCMD_CFG_CLEAR
case|:
if|if
condition|(
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|cmd_status
operator|==
name|MFI_STAT_OK
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|ld
argument_list|,
argument|&sc->mfi_ld_tqh
argument_list|,
argument|ld_link
argument_list|,
argument|ldn
argument_list|)
block|{
name|device_delete_child
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
name|ld
operator|->
name|ld_dev
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TAILQ_FOREACH
argument_list|(
argument|ld
argument_list|,
argument|&sc->mfi_ld_tqh
argument_list|,
argument|ld_link
argument_list|)
name|mfi_disk_enable
argument_list|(
name|ld
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MFI_DCMD_CFG_ADD
case|:
name|mfi_ldprobe
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|MFI_DCMD_CFG_FOREIGN_IMPORT
case|:
name|mfi_ldprobe
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|MFI_DCMD_PD_STATE_SET
case|:
name|mbox
operator|=
operator|(
name|uint16_t
operator|*
operator|)
name|cm
operator|->
name|cm_frame
operator|->
name|dcmd
operator|.
name|mbox
expr_stmt|;
name|syspd_id
operator|=
name|mbox
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|mbox
index|[
literal|2
index|]
operator|==
name|MFI_PD_STATE_UNCONFIGURED_GOOD
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|syspd
argument_list|,
argument|&sc->mfi_syspd_tqh
argument_list|,
argument|pd_link
argument_list|)
block|{
if|if
condition|(
name|syspd
operator|->
name|pd_id
operator|==
name|syspd_id
condition|)
break|break;
block|}
block|}
else|else
break|break;
comment|/* If the transition fails then enable the syspd again */
if|if
condition|(
name|syspd
operator|&&
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|cmd_status
operator|!=
name|MFI_STAT_OK
condition|)
name|mfi_syspd_enable
argument_list|(
name|syspd
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_check_for_sscd
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mfi_command
modifier|*
name|cm
parameter_list|)
block|{
name|struct
name|mfi_config_data
modifier|*
name|conf_data
decl_stmt|;
name|struct
name|mfi_command
modifier|*
name|ld_cm
init|=
name|NULL
decl_stmt|;
name|struct
name|mfi_ld_info
modifier|*
name|ld_info
init|=
name|NULL
decl_stmt|;
name|struct
name|mfi_ld_config
modifier|*
name|ld
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|conf_data
operator|=
operator|(
expr|struct
name|mfi_config_data
operator|*
operator|)
name|cm
operator|->
name|cm_data
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_frame
operator|->
name|dcmd
operator|.
name|opcode
operator|==
name|MFI_DCMD_CFG_ADD
condition|)
block|{
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|conf_data
operator|->
name|array
expr_stmt|;
name|p
operator|+=
name|conf_data
operator|->
name|array_size
operator|*
name|conf_data
operator|->
name|array_count
expr_stmt|;
name|ld
operator|=
operator|(
expr|struct
name|mfi_ld_config
operator|*
operator|)
name|p
expr_stmt|;
if|if
condition|(
name|ld
operator|->
name|params
operator|.
name|isSSCD
operator|==
literal|1
condition|)
name|error
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cm
operator|->
name|cm_frame
operator|->
name|dcmd
operator|.
name|opcode
operator|==
name|MFI_DCMD_LD_DELETE
condition|)
block|{
name|error
operator|=
name|mfi_dcmd_command
argument_list|(
name|sc
argument_list|,
operator|&
name|ld_cm
argument_list|,
name|MFI_DCMD_LD_GET_INFO
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|ld_info
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ld_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Failed to allocate"
literal|"MFI_DCMD_LD_GET_INFO %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|ld_info
condition|)
name|free
argument_list|(
name|ld_info
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ld_cm
operator|->
name|cm_flags
operator|=
name|MFI_CMD_DATAIN
expr_stmt|;
name|ld_cm
operator|->
name|cm_frame
operator|->
name|dcmd
operator|.
name|mbox
index|[
literal|0
index|]
operator|=
name|cm
operator|->
name|cm_frame
operator|->
name|dcmd
operator|.
name|mbox
index|[
literal|0
index|]
expr_stmt|;
name|ld_cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|target_id
operator|=
name|cm
operator|->
name|cm_frame
operator|->
name|dcmd
operator|.
name|mbox
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|mfi_wait_command
argument_list|(
name|sc
argument_list|,
name|ld_cm
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"failed to get log drv\n"
argument_list|)
expr_stmt|;
name|mfi_release_command
argument_list|(
name|ld_cm
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ld_info
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|ld_cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|cmd_status
operator|!=
name|MFI_STAT_OK
condition|)
block|{
name|free
argument_list|(
name|ld_info
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
name|mfi_release_command
argument_list|(
name|ld_cm
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
name|ld_info
operator|=
operator|(
expr|struct
name|mfi_ld_info
operator|*
operator|)
name|ld_cm
operator|->
name|cm_private
expr_stmt|;
if|if
condition|(
name|ld_info
operator|->
name|ld_config
operator|.
name|params
operator|.
name|isSSCD
operator|==
literal|1
condition|)
name|error
operator|=
literal|1
expr_stmt|;
name|mfi_release_command
argument_list|(
name|ld_cm
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ld_info
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_stp_cmd
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mfi_command
modifier|*
name|cm
parameter_list|,
name|caddr_t
name|arg
parameter_list|)
block|{
name|uint8_t
name|i
decl_stmt|;
name|struct
name|mfi_ioc_packet
modifier|*
name|ioc
decl_stmt|;
name|ioc
operator|=
operator|(
expr|struct
name|mfi_ioc_packet
operator|*
operator|)
name|arg
expr_stmt|;
name|int
name|sge_size
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|megasas_sge
modifier|*
name|kern_sge
decl_stmt|;
name|memset
argument_list|(
name|sc
operator|->
name|kbuff_arr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|kbuff_arr
argument_list|)
argument_list|)
expr_stmt|;
name|kern_sge
operator|=
operator|(
expr|struct
name|megasas_sge
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|cm
operator|->
name|cm_frame
operator|+
name|ioc
operator|->
name|mfi_sgl_off
operator|)
expr_stmt|;
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|sg_count
operator|=
name|ioc
operator|->
name|mfi_sge_count
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|bus_addr_t
argument_list|)
operator|==
literal|8
condition|)
block|{
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|flags
operator||=
name|MFI_FRAME_SGL64
expr_stmt|;
name|cm
operator|->
name|cm_extra_frames
operator|=
literal|2
expr_stmt|;
name|sge_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mfi_sg64
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cm
operator|->
name|cm_extra_frames
operator|=
operator|(
name|cm
operator|->
name|cm_total_frame_size
operator|-
literal|1
operator|)
operator|/
name|MFI_FRAME_SIZE
expr_stmt|;
name|sge_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mfi_sg32
argument_list|)
expr_stmt|;
block|}
name|cm
operator|->
name|cm_total_frame_size
operator|+=
operator|(
name|sge_size
operator|*
name|ioc
operator|->
name|mfi_sge_count
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ioc
operator|->
name|mfi_sge_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|mfi_parent_dmat
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|ioc
operator|->
name|mfi_sgl
index|[
name|i
index|]
operator|.
name|iov_len
argument_list|,
comment|/* maxsize */
literal|2
argument_list|,
comment|/* nsegments */
name|ioc
operator|->
name|mfi_sgl
index|[
name|i
index|]
operator|.
name|iov_len
argument_list|,
comment|/* maxsegsize */
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|mfi_kbuff_arr_dmat
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Cannot allocate mfi_kbuff_arr_dmat tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|mfi_kbuff_arr_dmat
index|[
name|i
index|]
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|kbuff_arr
index|[
name|i
index|]
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|mfi_kbuff_arr_dmamap
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Cannot allocate mfi_kbuff_arr_dmamap memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|mfi_kbuff_arr_dmat
index|[
name|i
index|]
argument_list|,
name|sc
operator|->
name|mfi_kbuff_arr_dmamap
index|[
name|i
index|]
argument_list|,
name|sc
operator|->
name|kbuff_arr
index|[
name|i
index|]
argument_list|,
name|ioc
operator|->
name|mfi_sgl
index|[
name|i
index|]
operator|.
name|iov_len
argument_list|,
name|mfi_addr_cb
argument_list|,
operator|&
name|sc
operator|->
name|mfi_kbuff_arr_busaddr
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|kbuff_arr
index|[
name|i
index|]
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Could not allocate memory for kbuff_arr info\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|kern_sge
index|[
name|i
index|]
operator|.
name|phys_addr
operator|=
name|sc
operator|->
name|mfi_kbuff_arr_busaddr
index|[
name|i
index|]
expr_stmt|;
name|kern_sge
index|[
name|i
index|]
operator|.
name|length
operator|=
name|ioc
operator|->
name|mfi_sgl
index|[
name|i
index|]
operator|.
name|iov_len
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|bus_addr_t
argument_list|)
operator|==
literal|8
condition|)
block|{
name|cm
operator|->
name|cm_frame
operator|->
name|stp
operator|.
name|sgl
operator|.
name|sg64
index|[
name|i
index|]
operator|.
name|addr
operator|=
name|kern_sge
index|[
name|i
index|]
operator|.
name|phys_addr
expr_stmt|;
name|cm
operator|->
name|cm_frame
operator|->
name|stp
operator|.
name|sgl
operator|.
name|sg64
index|[
name|i
index|]
operator|.
name|len
operator|=
name|ioc
operator|->
name|mfi_sgl
index|[
name|i
index|]
operator|.
name|iov_len
expr_stmt|;
block|}
else|else
block|{
name|cm
operator|->
name|cm_frame
operator|->
name|stp
operator|.
name|sgl
operator|.
name|sg32
index|[
name|i
index|]
operator|.
name|addr
operator|=
name|kern_sge
index|[
name|i
index|]
operator|.
name|phys_addr
expr_stmt|;
name|cm
operator|->
name|cm_frame
operator|->
name|stp
operator|.
name|sgl
operator|.
name|sg32
index|[
name|i
index|]
operator|.
name|len
operator|=
name|ioc
operator|->
name|mfi_sgl
index|[
name|i
index|]
operator|.
name|iov_len
expr_stmt|;
block|}
name|error
operator|=
name|copyin
argument_list|(
name|ioc
operator|->
name|mfi_sgl
index|[
name|i
index|]
operator|.
name|iov_base
argument_list|,
name|sc
operator|->
name|kbuff_arr
index|[
name|i
index|]
argument_list|,
name|ioc
operator|->
name|mfi_sgl
index|[
name|i
index|]
operator|.
name|iov_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Copy in failed\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
name|cm
operator|->
name|cm_flags
operator||=
name|MFI_CMD_MAPPED
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_user_command
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mfi_ioc_passthru
modifier|*
name|ioc
parameter_list|)
block|{
name|struct
name|mfi_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|mfi_dcmd_frame
modifier|*
name|dcmd
decl_stmt|;
name|void
modifier|*
name|ioc_buf
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|context
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|locked
decl_stmt|;
if|if
condition|(
name|ioc
operator|->
name|buf_size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|ioc
operator|->
name|buf_size
operator|>
literal|1024
operator|*
literal|1024
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|ioc_buf
operator|=
name|malloc
argument_list|(
name|ioc
operator|->
name|buf_size
argument_list|,
name|M_MFIBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|ioc
operator|->
name|buf
argument_list|,
name|ioc_buf
argument_list|,
name|ioc
operator|->
name|buf_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"failed to copyin\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ioc_buf
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|locked
operator|=
name|mfi_config_lock
argument_list|(
name|sc
argument_list|,
name|ioc
operator|->
name|ioc_frame
operator|.
name|opcode
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|cm
operator|=
name|mfi_dequeue_free
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|msleep
argument_list|(
name|mfi_user_command
argument_list|,
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|,
literal|0
argument_list|,
literal|"mfiioc"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
comment|/* Save context for later */
name|context
operator|=
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|context
expr_stmt|;
name|dcmd
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|dcmd
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|ioc
operator|->
name|ioc_frame
argument_list|,
name|dcmd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mfi_dcmd_frame
argument_list|)
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_sg
operator|=
operator|&
name|dcmd
operator|->
name|sgl
expr_stmt|;
name|cm
operator|->
name|cm_total_frame_size
operator|=
name|MFI_DCMD_FRAME_SIZE
expr_stmt|;
name|cm
operator|->
name|cm_data
operator|=
name|ioc_buf
expr_stmt|;
name|cm
operator|->
name|cm_len
operator|=
name|ioc
operator|->
name|buf_size
expr_stmt|;
comment|/* restore context */
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|context
operator|=
name|context
expr_stmt|;
comment|/* Cheat since we don't know if we're writing or reading */
name|cm
operator|->
name|cm_flags
operator|=
name|MFI_CMD_DATAIN
operator||
name|MFI_CMD_DATAOUT
expr_stmt|;
name|error
operator|=
name|mfi_check_command_pre
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
name|mfi_wait_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"ioctl failed %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|bcopy
argument_list|(
name|dcmd
argument_list|,
operator|&
name|ioc
operator|->
name|ioc_frame
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mfi_dcmd_frame
argument_list|)
argument_list|)
expr_stmt|;
name|mfi_check_command_post
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
name|out
label|:
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|mfi_config_unlock
argument_list|(
name|sc
argument_list|,
name|locked
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioc
operator|->
name|buf_size
operator|>
literal|0
condition|)
name|error
operator|=
name|copyout
argument_list|(
name|ioc_buf
argument_list|,
name|ioc
operator|->
name|buf
argument_list|,
name|ioc
operator|->
name|buf_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioc_buf
condition|)
name|free
argument_list|(
name|ioc_buf
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|PTRIN
parameter_list|(
name|p
parameter_list|)
value|((void *)(uintptr_t)(p))
end_define

begin_function
specifier|static
name|int
name|mfi_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|mfi_softc
modifier|*
name|sc
decl_stmt|;
name|union
name|mfi_statrequest
modifier|*
name|ms
decl_stmt|;
name|struct
name|mfi_ioc_packet
modifier|*
name|ioc
decl_stmt|;
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD32
name|struct
name|mfi_ioc_packet32
modifier|*
name|ioc32
decl_stmt|;
endif|#
directive|endif
name|struct
name|mfi_ioc_aen
modifier|*
name|aen
decl_stmt|;
name|struct
name|mfi_command
modifier|*
name|cm
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|context
init|=
literal|0
decl_stmt|;
name|union
name|mfi_sense_ptr
name|sense_ptr
decl_stmt|;
name|uint8_t
modifier|*
name|data
init|=
name|NULL
decl_stmt|,
modifier|*
name|temp
decl_stmt|,
modifier|*
name|addr
decl_stmt|,
name|skip_pre_post
init|=
literal|0
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|i
decl_stmt|,
name|res
decl_stmt|;
name|struct
name|mfi_ioc_passthru
modifier|*
name|iop
init|=
operator|(
expr|struct
name|mfi_ioc_passthru
operator|*
operator|)
name|arg
decl_stmt|;
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD32
name|struct
name|mfi_ioc_passthru32
modifier|*
name|iop32
init|=
operator|(
expr|struct
name|mfi_ioc_passthru32
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|mfi_ioc_passthru
name|iop_swab
decl_stmt|;
endif|#
directive|endif
name|int
name|error
decl_stmt|,
name|locked
decl_stmt|;
name|union
name|mfi_sgl
modifier|*
name|sgl
decl_stmt|;
name|sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|adpreset
condition|)
return|return
name|EBUSY
return|;
if|if
condition|(
name|sc
operator|->
name|hw_crit_error
condition|)
return|return
name|EBUSY
return|;
if|if
condition|(
name|sc
operator|->
name|issuepend_done
operator|==
literal|0
condition|)
return|return
name|EBUSY
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MFIIO_STATS
case|:
name|ms
operator|=
operator|(
expr|union
name|mfi_statrequest
operator|*
operator|)
name|arg
expr_stmt|;
switch|switch
condition|(
name|ms
operator|->
name|ms_item
condition|)
block|{
case|case
name|MFIQ_FREE
case|:
case|case
name|MFIQ_BIO
case|:
case|case
name|MFIQ_READY
case|:
case|case
name|MFIQ_BUSY
case|:
name|bcopy
argument_list|(
operator|&
name|sc
operator|->
name|mfi_qstat
index|[
name|ms
operator|->
name|ms_item
index|]
argument_list|,
operator|&
name|ms
operator|->
name|ms_qstat
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mfi_qstat
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ENOIOCTL
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|MFIIO_QUERY_DISK
case|:
block|{
name|struct
name|mfi_query_disk
modifier|*
name|qd
decl_stmt|;
name|struct
name|mfi_disk
modifier|*
name|ld
decl_stmt|;
name|qd
operator|=
operator|(
expr|struct
name|mfi_query_disk
operator|*
operator|)
name|arg
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ld
argument_list|,
argument|&sc->mfi_ld_tqh
argument_list|,
argument|ld_link
argument_list|)
block|{
if|if
condition|(
name|ld
operator|->
name|ld_id
operator|==
name|qd
operator|->
name|array_id
condition|)
break|break;
block|}
if|if
condition|(
name|ld
operator|==
name|NULL
condition|)
block|{
name|qd
operator|->
name|present
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|qd
operator|->
name|present
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ld
operator|->
name|ld_flags
operator|&
name|MFI_DISK_FLAGS_OPEN
condition|)
name|qd
operator|->
name|open
operator|=
literal|1
expr_stmt|;
name|bzero
argument_list|(
name|qd
operator|->
name|devname
argument_list|,
name|SPECNAMELEN
operator|+
literal|1
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|qd
operator|->
name|devname
argument_list|,
name|SPECNAMELEN
argument_list|,
literal|"mfid%d"
argument_list|,
name|ld
operator|->
name|ld_unit
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MFI_CMD
case|:
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD32
case|case
name|MFI_CMD32
case|:
endif|#
directive|endif
block|{
name|devclass_t
name|devclass
decl_stmt|;
name|ioc
operator|=
operator|(
expr|struct
name|mfi_ioc_packet
operator|*
operator|)
name|arg
expr_stmt|;
name|int
name|adapter
decl_stmt|;
name|adapter
operator|=
name|ioc
operator|->
name|mfi_adapter_no
expr_stmt|;
if|if
condition|(
name|device_get_unit
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|)
operator|==
literal|0
operator|&&
name|adapter
operator|!=
literal|0
condition|)
block|{
name|devclass
operator|=
name|devclass_find
argument_list|(
literal|"mfi"
argument_list|)
expr_stmt|;
name|sc
operator|=
name|devclass_get_softc
argument_list|(
name|devclass
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|=
name|mfi_dequeue_free
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|locked
operator|=
literal|0
expr_stmt|;
comment|/* 		 * save off original context since copying from user 		 * will clobber some data 		 */
name|context
operator|=
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|context
expr_stmt|;
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|context
operator|=
name|cm
operator|->
name|cm_index
expr_stmt|;
name|bcopy
argument_list|(
name|ioc
operator|->
name|mfi_frame
operator|.
name|raw
argument_list|,
name|cm
operator|->
name|cm_frame
argument_list|,
literal|2
operator|*
name|MEGAMFI_FRAME_SIZE
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_total_frame_size
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|union
name|mfi_sgl
argument_list|)
operator|*
name|ioc
operator|->
name|mfi_sge_count
operator|)
operator|+
name|ioc
operator|->
name|mfi_sgl_off
expr_stmt|;
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|scsi_status
operator|=
literal|0
expr_stmt|;
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|pad0
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ioc
operator|->
name|mfi_sge_count
condition|)
block|{
name|cm
operator|->
name|cm_sg
operator|=
operator|(
expr|union
name|mfi_sgl
operator|*
operator|)
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|bytes
index|[
name|ioc
operator|->
name|mfi_sgl_off
index|]
expr_stmt|;
block|}
name|sgl
operator|=
name|cm
operator|->
name|cm_sg
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|flags
operator|&
name|MFI_FRAME_DATAIN
condition|)
name|cm
operator|->
name|cm_flags
operator||=
name|MFI_CMD_DATAIN
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|flags
operator|&
name|MFI_FRAME_DATAOUT
condition|)
name|cm
operator|->
name|cm_flags
operator||=
name|MFI_CMD_DATAOUT
expr_stmt|;
comment|/* Legacy app shim */
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|==
literal|0
condition|)
name|cm
operator|->
name|cm_flags
operator||=
name|MFI_CMD_DATAIN
operator||
name|MFI_CMD_DATAOUT
expr_stmt|;
name|cm
operator|->
name|cm_len
operator|=
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|data_len
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|cmd
operator|==
name|MFI_CMD_STP
condition|)
block|{
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD32
if|if
condition|(
name|cmd
operator|==
name|MFI_CMD
condition|)
block|{
endif|#
directive|endif
comment|/* Native */
name|cm
operator|->
name|cm_stp_len
operator|=
name|ioc
operator|->
name|mfi_sgl
index|[
literal|0
index|]
operator|.
name|iov_len
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD32
block|}
else|else
block|{
comment|/* 32bit on 64bit */
name|ioc32
operator|=
operator|(
expr|struct
name|mfi_ioc_packet32
operator|*
operator|)
name|ioc
expr_stmt|;
name|cm
operator|->
name|cm_stp_len
operator|=
name|ioc32
operator|->
name|mfi_sgl
index|[
literal|0
index|]
operator|.
name|iov_len
expr_stmt|;
block|}
endif|#
directive|endif
name|cm
operator|->
name|cm_len
operator|+=
name|cm
operator|->
name|cm_stp_len
expr_stmt|;
block|}
if|if
condition|(
name|cm
operator|->
name|cm_len
operator|&&
operator|(
name|cm
operator|->
name|cm_flags
operator|&
operator|(
name|MFI_CMD_DATAIN
operator||
name|MFI_CMD_DATAOUT
operator|)
operator|)
condition|)
block|{
name|cm
operator|->
name|cm_data
operator|=
name|data
operator|=
name|malloc
argument_list|(
name|cm
operator|->
name|cm_len
argument_list|,
name|M_MFIBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cm
operator|->
name|cm_data
operator|=
literal|0
expr_stmt|;
block|}
comment|/* restore header context */
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|context
operator|=
name|context
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|cmd
operator|==
name|MFI_CMD_STP
condition|)
block|{
name|res
operator|=
name|mfi_stp_cmd
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
else|else
block|{
name|temp
operator|=
name|data
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|->
name|cm_flags
operator|&
name|MFI_CMD_DATAOUT
operator|)
operator|||
operator|(
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|cmd
operator|==
name|MFI_CMD_STP
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ioc
operator|->
name|mfi_sge_count
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD32
if|if
condition|(
name|cmd
operator|==
name|MFI_CMD
condition|)
block|{
endif|#
directive|endif
comment|/* Native */
name|addr
operator|=
name|ioc
operator|->
name|mfi_sgl
index|[
name|i
index|]
operator|.
name|iov_base
expr_stmt|;
name|len
operator|=
name|ioc
operator|->
name|mfi_sgl
index|[
name|i
index|]
operator|.
name|iov_len
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD32
block|}
else|else
block|{
comment|/* 32bit on 64bit */
name|ioc32
operator|=
operator|(
expr|struct
name|mfi_ioc_packet32
operator|*
operator|)
name|ioc
expr_stmt|;
name|addr
operator|=
name|PTRIN
argument_list|(
name|ioc32
operator|->
name|mfi_sgl
index|[
name|i
index|]
operator|.
name|iov_base
argument_list|)
expr_stmt|;
name|len
operator|=
name|ioc32
operator|->
name|mfi_sgl
index|[
name|i
index|]
operator|.
name|iov_len
expr_stmt|;
block|}
endif|#
directive|endif
name|error
operator|=
name|copyin
argument_list|(
name|addr
argument_list|,
name|temp
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Copy in failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|temp
operator|=
operator|&
name|temp
index|[
name|len
index|]
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|cmd
operator|==
name|MFI_CMD_DCMD
condition|)
name|locked
operator|=
name|mfi_config_lock
argument_list|(
name|sc
argument_list|,
name|cm
operator|->
name|cm_frame
operator|->
name|dcmd
operator|.
name|opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|cmd
operator|==
name|MFI_CMD_PD_SCSI_IO
condition|)
block|{
name|cm
operator|->
name|cm_frame
operator|->
name|pass
operator|.
name|sense_addr_lo
operator|=
operator|(
name|uint32_t
operator|)
name|cm
operator|->
name|cm_sense_busaddr
expr_stmt|;
name|cm
operator|->
name|cm_frame
operator|->
name|pass
operator|.
name|sense_addr_hi
operator|=
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|uint64_t
operator|)
name|cm
operator|->
name|cm_sense_busaddr
operator|>>
literal|32
argument_list|)
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|skip_pre_post
operator|=
name|mfi_check_for_sscd
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|skip_pre_post
condition|)
block|{
name|error
operator|=
name|mfi_check_command_pre
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|mfi_wait_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Controller polled failed\n"
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|!
name|skip_pre_post
condition|)
block|{
name|mfi_check_command_post
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|cmd
operator|!=
name|MFI_CMD_STP
condition|)
block|{
name|temp
operator|=
name|data
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|->
name|cm_flags
operator|&
name|MFI_CMD_DATAIN
operator|)
operator|||
operator|(
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|cmd
operator|==
name|MFI_CMD_STP
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ioc
operator|->
name|mfi_sge_count
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD32
if|if
condition|(
name|cmd
operator|==
name|MFI_CMD
condition|)
block|{
endif|#
directive|endif
comment|/* Native */
name|addr
operator|=
name|ioc
operator|->
name|mfi_sgl
index|[
name|i
index|]
operator|.
name|iov_base
expr_stmt|;
name|len
operator|=
name|ioc
operator|->
name|mfi_sgl
index|[
name|i
index|]
operator|.
name|iov_len
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD32
block|}
else|else
block|{
comment|/* 32bit on 64bit */
name|ioc32
operator|=
operator|(
expr|struct
name|mfi_ioc_packet32
operator|*
operator|)
name|ioc
expr_stmt|;
name|addr
operator|=
name|PTRIN
argument_list|(
name|ioc32
operator|->
name|mfi_sgl
index|[
name|i
index|]
operator|.
name|iov_base
argument_list|)
expr_stmt|;
name|len
operator|=
name|ioc32
operator|->
name|mfi_sgl
index|[
name|i
index|]
operator|.
name|iov_len
expr_stmt|;
block|}
endif|#
directive|endif
name|error
operator|=
name|copyout
argument_list|(
name|temp
argument_list|,
name|addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Copy out failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|temp
operator|=
operator|&
name|temp
index|[
name|len
index|]
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|ioc
operator|->
name|mfi_sense_len
condition|)
block|{
comment|/* get user-space sense ptr then copy out sense */
name|bcopy
argument_list|(
operator|&
name|ioc
operator|->
name|mfi_frame
operator|.
name|raw
index|[
name|ioc
operator|->
name|mfi_sense_off
index|]
argument_list|,
operator|&
name|sense_ptr
operator|.
name|sense_ptr_data
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|sense_ptr
operator|.
name|sense_ptr_data
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD32
if|if
condition|(
name|cmd
operator|!=
name|MFI_CMD
condition|)
block|{
comment|/* 				 * not 64bit native so zero out any address 				 * over 32bit */
name|sense_ptr
operator|.
name|addr
operator|.
name|high
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|error
operator|=
name|copyout
argument_list|(
name|cm
operator|->
name|cm_sense
argument_list|,
name|sense_ptr
operator|.
name|user_space
argument_list|,
name|ioc
operator|->
name|mfi_sense_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Copy out failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|ioc
operator|->
name|mfi_frame
operator|.
name|hdr
operator|.
name|cmd_status
operator|=
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|cmd_status
expr_stmt|;
name|out
label|:
name|mfi_config_unlock
argument_list|(
name|sc
argument_list|,
name|locked
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
condition|)
name|free
argument_list|(
name|data
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|cmd
operator|==
name|MFI_CMD_STP
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|kbuff_arr
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|mfi_kbuff_arr_busaddr
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|mfi_kbuff_arr_dmat
index|[
name|i
index|]
argument_list|,
name|sc
operator|->
name|mfi_kbuff_arr_dmamap
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|kbuff_arr
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|mfi_kbuff_arr_dmat
index|[
name|i
index|]
argument_list|,
name|sc
operator|->
name|kbuff_arr
index|[
name|i
index|]
argument_list|,
name|sc
operator|->
name|mfi_kbuff_arr_dmamap
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_kbuff_arr_dmat
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|mfi_kbuff_arr_dmat
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|cm
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|MFI_SET_AEN
case|:
name|aen
operator|=
operator|(
expr|struct
name|mfi_ioc_aen
operator|*
operator|)
name|arg
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|mfi_aen_register
argument_list|(
name|sc
argument_list|,
name|aen
operator|->
name|aen_seq_num
argument_list|,
name|aen
operator|->
name|aen_class_locale
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
break|break;
case|case
name|MFI_LINUX_CMD_2
case|:
comment|/* Firmware Linux ioctl shim */
block|{
name|devclass_t
name|devclass
decl_stmt|;
name|struct
name|mfi_linux_ioc_packet
name|l_ioc
decl_stmt|;
name|int
name|adapter
decl_stmt|;
name|devclass
operator|=
name|devclass_find
argument_list|(
literal|"mfi"
argument_list|)
expr_stmt|;
if|if
condition|(
name|devclass
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|error
operator|=
name|copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|l_ioc
argument_list|,
sizeof|sizeof
argument_list|(
name|l_ioc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|adapter
operator|=
name|l_ioc
operator|.
name|lioc_adapter_no
expr_stmt|;
name|sc
operator|=
name|devclass_get_softc
argument_list|(
name|devclass
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
return|return
operator|(
name|mfi_linux_ioctl_int
argument_list|(
name|sc
operator|->
name|mfi_cdev
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|,
name|flag
argument_list|,
name|td
argument_list|)
operator|)
return|;
break|break;
block|}
case|case
name|MFI_LINUX_SET_AEN_2
case|:
comment|/* AEN Linux ioctl shim */
block|{
name|devclass_t
name|devclass
decl_stmt|;
name|struct
name|mfi_linux_ioc_aen
name|l_aen
decl_stmt|;
name|int
name|adapter
decl_stmt|;
name|devclass
operator|=
name|devclass_find
argument_list|(
literal|"mfi"
argument_list|)
expr_stmt|;
if|if
condition|(
name|devclass
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|error
operator|=
name|copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|l_aen
argument_list|,
sizeof|sizeof
argument_list|(
name|l_aen
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|adapter
operator|=
name|l_aen
operator|.
name|laen_adapter_no
expr_stmt|;
name|sc
operator|=
name|devclass_get_softc
argument_list|(
name|devclass
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
return|return
operator|(
name|mfi_linux_ioctl_int
argument_list|(
name|sc
operator|->
name|mfi_cdev
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|,
name|flag
argument_list|,
name|td
argument_list|)
operator|)
return|;
break|break;
block|}
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD32
case|case
name|MFIIO_PASSTHRU32
case|:
if|if
condition|(
operator|!
name|SV_CURPROC_FLAG
argument_list|(
name|SV_ILP32
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENOTTY
expr_stmt|;
break|break;
block|}
name|iop_swab
operator|.
name|ioc_frame
operator|=
name|iop32
operator|->
name|ioc_frame
expr_stmt|;
name|iop_swab
operator|.
name|buf_size
operator|=
name|iop32
operator|->
name|buf_size
expr_stmt|;
name|iop_swab
operator|.
name|buf
operator|=
name|PTRIN
argument_list|(
name|iop32
operator|->
name|buf
argument_list|)
expr_stmt|;
name|iop
operator|=
operator|&
name|iop_swab
expr_stmt|;
comment|/* FALLTHROUGH */
endif|#
directive|endif
case|case
name|MFIIO_PASSTHRU
case|:
name|error
operator|=
name|mfi_user_command
argument_list|(
name|sc
argument_list|,
name|iop
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD32
if|if
condition|(
name|cmd
operator|==
name|MFIIO_PASSTHRU32
condition|)
name|iop32
operator|->
name|ioc_frame
operator|=
name|iop_swab
operator|.
name|ioc_frame
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"IOCTL 0x%lx not handled\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOTTY
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_linux_ioctl_int
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|mfi_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mfi_linux_ioc_packet
name|l_ioc
decl_stmt|;
name|struct
name|mfi_linux_ioc_aen
name|l_aen
decl_stmt|;
name|struct
name|mfi_command
modifier|*
name|cm
init|=
name|NULL
decl_stmt|;
name|struct
name|mfi_aen
modifier|*
name|mfi_aen_entry
decl_stmt|;
name|union
name|mfi_sense_ptr
name|sense_ptr
decl_stmt|;
name|uint32_t
name|context
init|=
literal|0
decl_stmt|;
name|uint8_t
modifier|*
name|data
init|=
name|NULL
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|error
decl_stmt|,
name|locked
decl_stmt|;
name|sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MFI_LINUX_CMD_2
case|:
comment|/* Firmware Linux ioctl shim */
name|error
operator|=
name|copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|l_ioc
argument_list|,
sizeof|sizeof
argument_list|(
name|l_ioc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|l_ioc
operator|.
name|lioc_sge_count
operator|>
name|MAX_LINUX_IOCTL_SGE
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|=
name|mfi_dequeue_free
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|locked
operator|=
literal|0
expr_stmt|;
comment|/* 		 * save off original context since copying from user 		 * will clobber some data 		 */
name|context
operator|=
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|context
expr_stmt|;
name|bcopy
argument_list|(
name|l_ioc
operator|.
name|lioc_frame
operator|.
name|raw
argument_list|,
name|cm
operator|->
name|cm_frame
argument_list|,
literal|2
operator|*
name|MFI_DCMD_FRAME_SIZE
argument_list|)
expr_stmt|;
comment|/* this isn't quite right */
name|cm
operator|->
name|cm_total_frame_size
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|union
name|mfi_sgl
argument_list|)
operator|*
name|l_ioc
operator|.
name|lioc_sge_count
operator|)
operator|+
name|l_ioc
operator|.
name|lioc_sgl_off
expr_stmt|;
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|scsi_status
operator|=
literal|0
expr_stmt|;
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|pad0
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|l_ioc
operator|.
name|lioc_sge_count
condition|)
name|cm
operator|->
name|cm_sg
operator|=
operator|(
expr|union
name|mfi_sgl
operator|*
operator|)
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|bytes
index|[
name|l_ioc
operator|.
name|lioc_sgl_off
index|]
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|flags
operator|&
name|MFI_FRAME_DATAIN
condition|)
name|cm
operator|->
name|cm_flags
operator||=
name|MFI_CMD_DATAIN
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|flags
operator|&
name|MFI_FRAME_DATAOUT
condition|)
name|cm
operator|->
name|cm_flags
operator||=
name|MFI_CMD_DATAOUT
expr_stmt|;
name|cm
operator|->
name|cm_len
operator|=
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|data_len
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_len
operator|&&
operator|(
name|cm
operator|->
name|cm_flags
operator|&
operator|(
name|MFI_CMD_DATAIN
operator||
name|MFI_CMD_DATAOUT
operator|)
operator|)
condition|)
block|{
name|cm
operator|->
name|cm_data
operator|=
name|data
operator|=
name|malloc
argument_list|(
name|cm
operator|->
name|cm_len
argument_list|,
name|M_MFIBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cm
operator|->
name|cm_data
operator|=
literal|0
expr_stmt|;
block|}
comment|/* restore header context */
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|context
operator|=
name|context
expr_stmt|;
name|temp
operator|=
name|data
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|MFI_CMD_DATAOUT
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l_ioc
operator|.
name|lioc_sge_count
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|copyin
argument_list|(
name|PTRIN
argument_list|(
name|l_ioc
operator|.
name|lioc_sgl
index|[
name|i
index|]
operator|.
name|iov_base
argument_list|)
argument_list|,
name|temp
argument_list|,
name|l_ioc
operator|.
name|lioc_sgl
index|[
name|i
index|]
operator|.
name|iov_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Copy in failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|temp
operator|=
operator|&
name|temp
index|[
name|l_ioc
operator|.
name|lioc_sgl
index|[
name|i
index|]
operator|.
name|iov_len
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|cmd
operator|==
name|MFI_CMD_DCMD
condition|)
name|locked
operator|=
name|mfi_config_lock
argument_list|(
name|sc
argument_list|,
name|cm
operator|->
name|cm_frame
operator|->
name|dcmd
operator|.
name|opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|cmd
operator|==
name|MFI_CMD_PD_SCSI_IO
condition|)
block|{
name|cm
operator|->
name|cm_frame
operator|->
name|pass
operator|.
name|sense_addr_lo
operator|=
operator|(
name|uint32_t
operator|)
name|cm
operator|->
name|cm_sense_busaddr
expr_stmt|;
name|cm
operator|->
name|cm_frame
operator|->
name|pass
operator|.
name|sense_addr_hi
operator|=
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|uint64_t
operator|)
name|cm
operator|->
name|cm_sense_busaddr
operator|>>
literal|32
argument_list|)
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|mfi_check_command_pre
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|mfi_wait_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Controller polled failed\n"
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|mfi_check_command_post
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|temp
operator|=
name|data
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|MFI_CMD_DATAIN
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l_ioc
operator|.
name|lioc_sge_count
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|copyout
argument_list|(
name|temp
argument_list|,
name|PTRIN
argument_list|(
name|l_ioc
operator|.
name|lioc_sgl
index|[
name|i
index|]
operator|.
name|iov_base
argument_list|)
argument_list|,
name|l_ioc
operator|.
name|lioc_sgl
index|[
name|i
index|]
operator|.
name|iov_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Copy out failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|temp
operator|=
operator|&
name|temp
index|[
name|l_ioc
operator|.
name|lioc_sgl
index|[
name|i
index|]
operator|.
name|iov_len
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|l_ioc
operator|.
name|lioc_sense_len
condition|)
block|{
comment|/* get user-space sense ptr then copy out sense */
name|bcopy
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|mfi_linux_ioc_packet
operator|*
operator|)
name|arg
operator|)
operator|->
name|lioc_frame
operator|.
name|raw
index|[
name|l_ioc
operator|.
name|lioc_sense_off
index|]
argument_list|,
operator|&
name|sense_ptr
operator|.
name|sense_ptr_data
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|sense_ptr
operator|.
name|sense_ptr_data
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__amd64__
comment|/* 			 * only 32bit Linux support so zero out any 			 * address over 32bit 			 */
name|sense_ptr
operator|.
name|addr
operator|.
name|high
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|copyout
argument_list|(
name|cm
operator|->
name|cm_sense
argument_list|,
name|sense_ptr
operator|.
name|user_space
argument_list|,
name|l_ioc
operator|.
name|lioc_sense_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Copy out failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|cmd_status
argument_list|,
operator|&
operator|(
operator|(
expr|struct
name|mfi_linux_ioc_packet
operator|*
operator|)
name|arg
operator|)
operator|->
name|lioc_frame
operator|.
name|hdr
operator|.
name|cmd_status
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Copy out failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|out
label|:
name|mfi_config_unlock
argument_list|(
name|sc
argument_list|,
name|locked
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
condition|)
name|free
argument_list|(
name|data
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
case|case
name|MFI_LINUX_SET_AEN_2
case|:
comment|/* AEN Linux ioctl shim */
name|error
operator|=
name|copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|l_aen
argument_list|,
sizeof|sizeof
argument_list|(
name|l_aen
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|printf
argument_list|(
literal|"AEN IMPLEMENTED for pid %d\n"
argument_list|,
name|curproc
operator|->
name|p_pid
argument_list|)
expr_stmt|;
name|mfi_aen_entry
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mfi_aen
argument_list|)
argument_list|,
name|M_MFIBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|mfi_aen_entry
operator|!=
name|NULL
condition|)
block|{
name|mfi_aen_entry
operator|->
name|p
operator|=
name|curproc
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|mfi_aen_pids
argument_list|,
name|mfi_aen_entry
argument_list|,
name|aen_link
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|mfi_aen_register
argument_list|(
name|sc
argument_list|,
name|l_aen
operator|.
name|laen_seq_num
argument_list|,
name|l_aen
operator|.
name|laen_class_locale
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|mfi_aen_pids
argument_list|,
name|mfi_aen_entry
argument_list|,
name|aen_link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mfi_aen_entry
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"IOCTL 0x%lx not handled\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_poll
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|poll_events
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|mfi_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|revents
init|=
literal|0
decl_stmt|;
name|sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
if|if
condition|(
name|poll_events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|mfi_aen_triggered
operator|!=
literal|0
condition|)
block|{
name|revents
operator||=
name|poll_events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
name|sc
operator|->
name|mfi_aen_triggered
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|mfi_aen_triggered
operator|==
literal|0
operator|&&
name|sc
operator|->
name|mfi_aen_cm
operator|==
name|NULL
condition|)
block|{
name|revents
operator||=
name|POLLERR
expr_stmt|;
block|}
block|}
if|if
condition|(
name|revents
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|poll_events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
condition|)
block|{
name|sc
operator|->
name|mfi_poll_waiting
operator|=
literal|1
expr_stmt|;
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|sc
operator|->
name|mfi_select
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|revents
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mfi_dump_all
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|mfi_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mfi_command
modifier|*
name|cm
decl_stmt|;
name|devclass_t
name|dc
decl_stmt|;
name|time_t
name|deadline
decl_stmt|;
name|int
name|timedout
decl_stmt|;
name|int
name|i
decl_stmt|;
name|dc
operator|=
name|devclass_find
argument_list|(
literal|"mfi"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"No mfi dev class\n"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|=
name|devclass_get_softc
argument_list|(
name|dc
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
break|break;
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Dumping\n\n"
argument_list|)
expr_stmt|;
name|timedout
operator|=
literal|0
expr_stmt|;
name|deadline
operator|=
name|time_uptime
operator|-
name|mfi_cmd_timeout
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|cm
argument_list|,
argument|&sc->mfi_busy
argument_list|,
argument|cm_link
argument_list|)
block|{
if|if
condition|(
name|cm
operator|->
name|cm_timestamp
operator|<=
name|deadline
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"COMMAND %p TIMEOUT AFTER %d SECONDS\n"
argument_list|,
name|cm
argument_list|,
call|(
name|int
call|)
argument_list|(
name|time_uptime
operator|-
name|cm
operator|->
name|cm_timestamp
argument_list|)
argument_list|)
expr_stmt|;
name|MFI_PRINT_CMD
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|timedout
operator|++
expr_stmt|;
block|}
block|}
if|#
directive|if
literal|0
block|if (timedout) 			MFI_DUMP_CMDS(sc);
endif|#
directive|endif
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|mfi_timeout
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|mfi_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|mfi_softc
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|mfi_command
modifier|*
name|cm
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|time_t
name|deadline
decl_stmt|;
name|int
name|timedout
init|=
literal|0
decl_stmt|;
name|deadline
operator|=
name|time_uptime
operator|-
name|mfi_cmd_timeout
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|adpreset
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|mfi_tbolt_reset
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|mfi_watchdog_callout
argument_list|,
name|mfi_cmd_timeout
operator|*
name|hz
argument_list|,
name|mfi_timeout
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|cm
argument_list|,
argument|&sc->mfi_busy
argument_list|,
argument|cm_link
argument_list|,
argument|tmp
argument_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|mfi_aen_cm
operator|==
name|cm
operator|||
name|sc
operator|->
name|mfi_map_sync_cm
operator|==
name|cm
condition|)
continue|continue;
if|if
condition|(
name|cm
operator|->
name|cm_timestamp
operator|<=
name|deadline
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|adpreset
operator|!=
literal|0
operator|&&
name|sc
operator|->
name|issuepend_done
operator|==
literal|0
condition|)
block|{
name|cm
operator|->
name|cm_timestamp
operator|=
name|time_uptime
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"COMMAND %p TIMEOUT AFTER %d SECONDS\n"
argument_list|,
name|cm
argument_list|,
call|(
name|int
call|)
argument_list|(
name|time_uptime
operator|-
name|cm
operator|->
name|cm_timestamp
argument_list|)
argument_list|)
expr_stmt|;
name|MFI_PRINT_CMD
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|MFI_VALIDATE_CMD
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
comment|/* 				 * While commands can get stuck forever we do 				 * not fail them as there is no way to tell if 				 * the controller has actually processed them 				 * or not. 				 * 				 * In addition its very likely that force 				 * failing a command here would cause a panic 				 * e.g. in UFS. 				 */
name|timedout
operator|++
expr_stmt|;
block|}
block|}
block|}
if|#
directive|if
literal|0
block|if (timedout) 		MFI_DUMP_CMDS(sc);
endif|#
directive|endif
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|mfi_watchdog_callout
argument_list|,
name|mfi_cmd_timeout
operator|*
name|hz
argument_list|,
name|mfi_timeout
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
condition|)
name|mfi_dump_all
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

end_unit

