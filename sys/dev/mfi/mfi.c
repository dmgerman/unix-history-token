begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2006 IronPort Systems  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_mfi.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus_dma.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<dev/mfi/mfireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/mfi/mfi_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<dev/mfi/mfivar.h>
end_include

begin_function_decl
specifier|static
name|int
name|mfi_alloc_commands
parameter_list|(
name|struct
name|mfi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mfi_release_command
parameter_list|(
name|struct
name|mfi_command
modifier|*
name|cm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mfi_comms_init
parameter_list|(
name|struct
name|mfi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mfi_polled_command
parameter_list|(
name|struct
name|mfi_softc
modifier|*
parameter_list|,
name|struct
name|mfi_command
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mfi_get_controller_info
parameter_list|(
name|struct
name|mfi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mfi_get_log_state
parameter_list|(
name|struct
name|mfi_softc
modifier|*
parameter_list|,
name|struct
name|mfi_evt_log_state
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|NOTYET
end_ifdef

begin_function_decl
specifier|static
name|int
name|mfi_get_entry
parameter_list|(
name|struct
name|mfi_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|mfi_data_cb
parameter_list|(
name|void
modifier|*
parameter_list|,
name|bus_dma_segment_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mfi_startup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mfi_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mfi_enable_intr
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mfi_ldprobe_inq
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mfi_ldprobe_inq_complete
parameter_list|(
name|struct
name|mfi_command
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mfi_ldprobe_capacity
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mfi_ldprobe_capacity_complete
parameter_list|(
name|struct
name|mfi_command
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mfi_ldprobe_tur
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mfi_ldprobe_tur_complete
parameter_list|(
name|struct
name|mfi_command
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mfi_aen_register
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|seq
parameter_list|,
name|int
name|locale
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mfi_aen_complete
parameter_list|(
name|struct
name|mfi_command
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mfi_aen_setup
parameter_list|(
name|struct
name|mfi_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mfi_add_ld
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|id
parameter_list|,
name|uint64_t
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mfi_command
modifier|*
name|mfi_bio_command
parameter_list|(
name|struct
name|mfi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mfi_bio_complete
parameter_list|(
name|struct
name|mfi_command
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mfi_mapcmd
parameter_list|(
name|struct
name|mfi_softc
modifier|*
parameter_list|,
name|struct
name|mfi_command
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mfi_send_frame
parameter_list|(
name|struct
name|mfi_softc
modifier|*
parameter_list|,
name|struct
name|mfi_command
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mfi_complete
parameter_list|(
name|struct
name|mfi_softc
modifier|*
parameter_list|,
name|struct
name|mfi_command
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mfi_abort
parameter_list|(
name|struct
name|mfi_softc
modifier|*
parameter_list|,
name|struct
name|mfi_command
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mfi_linux_ioctl_int
parameter_list|(
name|struct
name|cdev
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|,
name|int
parameter_list|,
name|d_thread_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Management interface */
end_comment

begin_decl_stmt
specifier|static
name|d_open_t
name|mfi_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|mfi_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|mfi_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_poll_t
name|mfi_poll
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|mfi_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_flags
operator|=
literal|0
block|,
operator|.
name|d_open
operator|=
name|mfi_open
block|,
operator|.
name|d_close
operator|=
name|mfi_close
block|,
operator|.
name|d_ioctl
operator|=
name|mfi_ioctl
block|,
operator|.
name|d_poll
operator|=
name|mfi_poll
block|,
operator|.
name|d_name
operator|=
literal|"mfi"
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_MFIBUF
argument_list|,
literal|"mfibuf"
argument_list|,
literal|"Buffers for the MFI driver"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|MFI_INQ_LENGTH
value|SHORT_INQUIRY_LENGTH
end_define

begin_function
specifier|static
name|int
name|mfi_transition_firmware
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int32_t
name|fw_state
decl_stmt|,
name|cur_state
decl_stmt|;
name|int
name|max_wait
decl_stmt|,
name|i
decl_stmt|;
name|fw_state
operator|=
name|MFI_READ4
argument_list|(
name|sc
argument_list|,
name|MFI_OMSG0
argument_list|)
operator|&
name|MFI_FWSTATE_MASK
expr_stmt|;
while|while
condition|(
name|fw_state
operator|!=
name|MFI_FWSTATE_READY
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Waiting for firmware to "
literal|"become ready\n"
argument_list|)
expr_stmt|;
name|cur_state
operator|=
name|fw_state
expr_stmt|;
switch|switch
condition|(
name|fw_state
condition|)
block|{
case|case
name|MFI_FWSTATE_FAULT
case|:
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Firmware fault\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
case|case
name|MFI_FWSTATE_WAIT_HANDSHAKE
case|:
name|MFI_WRITE4
argument_list|(
name|sc
argument_list|,
name|MFI_IDB
argument_list|,
name|MFI_FWINIT_CLEAR_HANDSHAKE
argument_list|)
expr_stmt|;
name|max_wait
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|MFI_FWSTATE_OPERATIONAL
case|:
name|MFI_WRITE4
argument_list|(
name|sc
argument_list|,
name|MFI_IDB
argument_list|,
name|MFI_FWINIT_READY
argument_list|)
expr_stmt|;
name|max_wait
operator|=
literal|10
expr_stmt|;
break|break;
case|case
name|MFI_FWSTATE_UNDEFINED
case|:
case|case
name|MFI_FWSTATE_BB_INIT
case|:
name|max_wait
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|MFI_FWSTATE_FW_INIT
case|:
case|case
name|MFI_FWSTATE_DEVICE_SCAN
case|:
case|case
name|MFI_FWSTATE_FLUSH_CACHE
case|:
name|max_wait
operator|=
literal|20
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Unknown firmware state %d\n"
argument_list|,
name|fw_state
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|max_wait
operator|*
literal|10
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|fw_state
operator|=
name|MFI_READ4
argument_list|(
name|sc
argument_list|,
name|MFI_OMSG0
argument_list|)
operator|&
name|MFI_FWSTATE_MASK
expr_stmt|;
if|if
condition|(
name|fw_state
operator|==
name|cur_state
condition|)
name|DELAY
argument_list|(
literal|100000
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
name|fw_state
operator|==
name|cur_state
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"firmware stuck in state "
literal|"%#x\n"
argument_list|,
name|fw_state
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mfi_addr32_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|uint32_t
modifier|*
name|addr
decl_stmt|;
name|addr
operator|=
name|arg
expr_stmt|;
operator|*
name|addr
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
name|int
name|mfi_attach
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|status
decl_stmt|;
name|int
name|error
decl_stmt|,
name|commsz
decl_stmt|,
name|framessz
decl_stmt|,
name|sensesz
decl_stmt|;
name|int
name|frames
decl_stmt|,
name|unit
decl_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|,
literal|"MFI I/O lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|mfi_ld_tqh
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|mfi_aen_pids
argument_list|)
expr_stmt|;
name|mfi_initq_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mfi_initq_ready
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mfi_initq_busy
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mfi_initq_bio
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Before we get too far, see if the firmware is working */
if|if
condition|(
operator|(
name|error
operator|=
name|mfi_transition_firmware
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Firmware not in READY state, "
literal|"error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * Get information needed for sizing the contiguous memory for the 	 * frame pool.  Size down the sgl parameter since we know that 	 * we will never need more than what's required for MAXPHYS. 	 * It would be nice if these constants were available at runtime 	 * instead of compile time. 	 */
name|status
operator|=
name|MFI_READ4
argument_list|(
name|sc
argument_list|,
name|MFI_OMSG0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mfi_max_fw_cmds
operator|=
name|status
operator|&
name|MFI_FWSTATE_MAXCMD_MASK
expr_stmt|;
name|sc
operator|->
name|mfi_max_fw_sgl
operator|=
operator|(
name|status
operator|&
name|MFI_FWSTATE_MAXSGL_MASK
operator|)
operator|>>
literal|16
expr_stmt|;
name|sc
operator|->
name|mfi_total_sgl
operator|=
name|min
argument_list|(
name|sc
operator|->
name|mfi_max_fw_sgl
argument_list|,
operator|(
operator|(
name|MAXPHYS
operator|/
name|PAGE_SIZE
operator|)
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Create the dma tag for data buffers.  Used both for block I/O 	 * and for various internal data queries. 	 */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|mfi_parent_dmat
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* maxsize */
name|sc
operator|->
name|mfi_total_sgl
argument_list|,
comment|/* nsegments */
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* maxsegsize */
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/* flags */
name|busdma_lock_mutex
argument_list|,
comment|/* lockfunc */
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|,
comment|/* lockfuncarg */
operator|&
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Cannot allocate buffer DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* 	 * Allocate DMA memory for the comms queues.  Keep it under 4GB for 	 * efficiency.  The mfi_hwcomms struct includes space for 1 reply queue 	 * entry, so the calculated size here will be will be 1 more than 	 * mfi_max_fw_cmds.  This is apparently a requirement of the hardware. 	 */
name|commsz
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
name|sc
operator|->
name|mfi_max_fw_cmds
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|mfi_hwcomms
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|mfi_parent_dmat
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|commsz
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* msegments */
name|commsz
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|mfi_comms_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Cannot allocate comms DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|mfi_comms_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|mfi_comms
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|mfi_comms_dmamap
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Cannot allocate comms memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|sc
operator|->
name|mfi_comms
argument_list|,
name|commsz
argument_list|)
expr_stmt|;
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|mfi_comms_dmat
argument_list|,
name|sc
operator|->
name|mfi_comms_dmamap
argument_list|,
name|sc
operator|->
name|mfi_comms
argument_list|,
name|commsz
argument_list|,
name|mfi_addr32_cb
argument_list|,
operator|&
name|sc
operator|->
name|mfi_comms_busaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate DMA memory for the command frames.  Keep them in the 	 * lower 4GB for efficiency.  Calculate the size of the frames at 	 * the same time; the frame is 64 bytes plus space for the SG lists. 	 * The assumption here is that the SG list will start at the second 	 * 64 byte segment of the frame and not use the unused bytes in the 	 * frame.  While this might seem wasteful, apparently the frames must 	 * be 64 byte aligned, so any savings would be negated by the extra 	 * alignment padding. 	 */
if|if
condition|(
sizeof|sizeof
argument_list|(
name|bus_addr_t
argument_list|)
operator|==
literal|8
condition|)
block|{
name|sc
operator|->
name|mfi_sgsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mfi_sg64
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mfi_flags
operator||=
name|MFI_FLAGS_SG64
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|mfi_sgsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mfi_sg32
argument_list|)
expr_stmt|;
block|}
name|frames
operator|=
operator|(
name|sc
operator|->
name|mfi_sgsize
operator|*
name|sc
operator|->
name|mfi_total_sgl
operator|+
name|MFI_FRAME_SIZE
operator|-
literal|1
operator|)
operator|/
name|MFI_FRAME_SIZE
operator|+
literal|1
expr_stmt|;
name|sc
operator|->
name|mfi_frame_size
operator|=
name|frames
operator|*
name|MFI_FRAME_SIZE
expr_stmt|;
name|framessz
operator|=
name|sc
operator|->
name|mfi_frame_size
operator|*
name|sc
operator|->
name|mfi_max_fw_cmds
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|mfi_parent_dmat
argument_list|,
comment|/* parent */
literal|64
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|framessz
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|framessz
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|mfi_frames_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Cannot allocate frame DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|mfi_frames_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|mfi_frames
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|mfi_frames_dmamap
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Cannot allocate frames memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|sc
operator|->
name|mfi_frames
argument_list|,
name|framessz
argument_list|)
expr_stmt|;
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|mfi_frames_dmat
argument_list|,
name|sc
operator|->
name|mfi_frames_dmamap
argument_list|,
name|sc
operator|->
name|mfi_frames
argument_list|,
name|framessz
argument_list|,
name|mfi_addr32_cb
argument_list|,
operator|&
name|sc
operator|->
name|mfi_frames_busaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate DMA memory for the frame sense data.  Keep them in the 	 * lower 4GB for efficiency 	 */
name|sensesz
operator|=
name|sc
operator|->
name|mfi_max_fw_cmds
operator|*
name|MFI_SENSE_LEN
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|mfi_parent_dmat
argument_list|,
comment|/* parent */
literal|4
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|sensesz
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|sensesz
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|mfi_sense_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Cannot allocate sense DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|mfi_sense_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|mfi_sense
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|mfi_sense_dmamap
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Cannot allocate sense memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|mfi_sense_dmat
argument_list|,
name|sc
operator|->
name|mfi_sense_dmamap
argument_list|,
name|sc
operator|->
name|mfi_sense
argument_list|,
name|sensesz
argument_list|,
name|mfi_addr32_cb
argument_list|,
operator|&
name|sc
operator|->
name|mfi_sense_busaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|mfi_alloc_commands
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|mfi_comms_init
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|mfi_get_controller_info
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|mfi_aen_setup
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
operator|,
literal|0
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Set up the interrupt handler.  XXX This should happen in 	 * mfi_pci.c 	 */
name|sc
operator|->
name|mfi_irq_rid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|mfi_irq
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|mfi_irq_rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Cannot allocate interrupt\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|bus_setup_intr
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
name|sc
operator|->
name|mfi_irq
argument_list|,
name|INTR_MPSAFE
operator||
name|INTR_TYPE_BIO
argument_list|,
name|mfi_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|mfi_intr
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Cannot set up interrupt\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Register a config hook to probe the bus for arrays */
name|sc
operator|->
name|mfi_ich
operator|.
name|ich_func
operator|=
name|mfi_startup
expr_stmt|;
name|sc
operator|->
name|mfi_ich
operator|.
name|ich_arg
operator|=
name|sc
expr_stmt|;
if|if
condition|(
name|config_intrhook_establish
argument_list|(
operator|&
name|sc
operator|->
name|mfi_ich
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Cannot establish configuration "
literal|"hook\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * Register a shutdown handler. 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|mfi_eh
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|shutdown_final
argument_list|,
name|mfi_shutdown
argument_list|,
name|sc
argument_list|,
name|SHUTDOWN_PRI_DEFAULT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Warning: shutdown event "
literal|"registration failed\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Create the control device for doing management 	 */
name|unit
operator|=
name|device_get_unit
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mfi_cdev
operator|=
name|make_dev
argument_list|(
operator|&
name|mfi_cdevsw
argument_list|,
name|unit
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0640
argument_list|,
literal|"mfi%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|==
literal|0
condition|)
name|make_dev_alias
argument_list|(
name|sc
operator|->
name|mfi_cdev
argument_list|,
literal|"megaraid_sas_ioctl_node"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_cdev
operator|!=
name|NULL
condition|)
name|sc
operator|->
name|mfi_cdev
operator|->
name|si_drv1
operator|=
name|sc
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_alloc_commands
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mfi_command
modifier|*
name|cm
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ncmds
decl_stmt|;
comment|/* 	 * XXX Should we allocate all the commands up front, or allocate on 	 * demand later like 'aac' does? 	 */
name|ncmds
operator|=
name|sc
operator|->
name|mfi_max_fw_cmds
expr_stmt|;
name|sc
operator|->
name|mfi_commands
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mfi_command
argument_list|)
operator|*
name|ncmds
argument_list|,
name|M_MFIBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncmds
condition|;
name|i
operator|++
control|)
block|{
name|cm
operator|=
operator|&
name|sc
operator|->
name|mfi_commands
index|[
name|i
index|]
expr_stmt|;
name|cm
operator|->
name|cm_frame
operator|=
operator|(
expr|union
name|mfi_frame
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|sc
operator|->
name|mfi_frames
operator|+
name|sc
operator|->
name|mfi_frame_size
operator|*
name|i
operator|)
expr_stmt|;
name|cm
operator|->
name|cm_frame_busaddr
operator|=
name|sc
operator|->
name|mfi_frames_busaddr
operator|+
name|sc
operator|->
name|mfi_frame_size
operator|*
name|i
expr_stmt|;
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|context
operator|=
name|i
expr_stmt|;
name|cm
operator|->
name|cm_sense
operator|=
operator|&
name|sc
operator|->
name|mfi_sense
index|[
name|i
index|]
expr_stmt|;
name|cm
operator|->
name|cm_sense_busaddr
operator|=
name|sc
operator|->
name|mfi_sense_busaddr
operator|+
name|MFI_SENSE_LEN
operator|*
name|i
expr_stmt|;
name|cm
operator|->
name|cm_sc
operator|=
name|sc
expr_stmt|;
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|,
literal|0
argument_list|,
operator|&
name|cm
operator|->
name|cm_dmamap
argument_list|)
operator|==
literal|0
condition|)
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
else|else
break|break;
name|sc
operator|->
name|mfi_total_cmds
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mfi_release_command
parameter_list|(
name|struct
name|mfi_command
modifier|*
name|cm
parameter_list|)
block|{
name|uint32_t
modifier|*
name|hdr_data
decl_stmt|;
comment|/* 	 * Zero out the important fields of the frame, but make sure the 	 * context field is preserved 	 */
name|hdr_data
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|cm
operator|->
name|cm_frame
expr_stmt|;
name|hdr_data
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|hdr_data
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|cm
operator|->
name|cm_extra_frames
operator|=
literal|0
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator|=
literal|0
expr_stmt|;
name|cm
operator|->
name|cm_complete
operator|=
name|NULL
expr_stmt|;
name|cm
operator|->
name|cm_private
operator|=
name|NULL
expr_stmt|;
name|cm
operator|->
name|cm_sg
operator|=
literal|0
expr_stmt|;
name|cm
operator|->
name|cm_total_frame_size
operator|=
literal|0
expr_stmt|;
name|mfi_enqueue_free
argument_list|(
name|cm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_comms_init
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mfi_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|mfi_init_frame
modifier|*
name|init
decl_stmt|;
name|struct
name|mfi_init_qinfo
modifier|*
name|qinfo
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|cm
operator|=
name|mfi_dequeue_free
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* 	 * Abuse the SG list area of the frame to hold the init_qinfo 	 * object; 	 */
name|init
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|init
expr_stmt|;
name|qinfo
operator|=
operator|(
expr|struct
name|mfi_init_qinfo
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|init
operator|+
name|MFI_FRAME_SIZE
operator|)
expr_stmt|;
name|bzero
argument_list|(
name|qinfo
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mfi_init_qinfo
argument_list|)
argument_list|)
expr_stmt|;
name|qinfo
operator|->
name|rq_entries
operator|=
name|sc
operator|->
name|mfi_max_fw_cmds
operator|+
literal|1
expr_stmt|;
name|qinfo
operator|->
name|rq_addr_lo
operator|=
name|sc
operator|->
name|mfi_comms_busaddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|mfi_hwcomms
argument_list|,
name|hw_reply_q
argument_list|)
expr_stmt|;
name|qinfo
operator|->
name|pi_addr_lo
operator|=
name|sc
operator|->
name|mfi_comms_busaddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|mfi_hwcomms
argument_list|,
name|hw_pi
argument_list|)
expr_stmt|;
name|qinfo
operator|->
name|ci_addr_lo
operator|=
name|sc
operator|->
name|mfi_comms_busaddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|mfi_hwcomms
argument_list|,
name|hw_ci
argument_list|)
expr_stmt|;
name|init
operator|->
name|header
operator|.
name|cmd
operator|=
name|MFI_CMD_INIT
expr_stmt|;
name|init
operator|->
name|header
operator|.
name|data_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mfi_init_qinfo
argument_list|)
expr_stmt|;
name|init
operator|->
name|qinfo_new_addr_lo
operator|=
name|cm
operator|->
name|cm_frame_busaddr
operator|+
name|MFI_FRAME_SIZE
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|mfi_polled_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"failed to send init command\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_get_controller_info
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mfi_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|mfi_dcmd_frame
modifier|*
name|dcmd
decl_stmt|;
name|struct
name|mfi_ctrl_info
modifier|*
name|ci
decl_stmt|;
name|uint32_t
name|max_sectors_1
decl_stmt|,
name|max_sectors_2
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|cm
operator|=
name|mfi_dequeue_free
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|ci
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mfi_ctrl_info
argument_list|)
argument_list|,
name|M_MFIBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|ci
operator|==
name|NULL
condition|)
block|{
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|dcmd
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|dcmd
expr_stmt|;
name|bzero
argument_list|(
name|dcmd
operator|->
name|mbox
argument_list|,
name|MFI_MBOX_SIZE
argument_list|)
expr_stmt|;
name|dcmd
operator|->
name|header
operator|.
name|cmd
operator|=
name|MFI_CMD_DCMD
expr_stmt|;
name|dcmd
operator|->
name|header
operator|.
name|timeout
operator|=
literal|0
expr_stmt|;
name|dcmd
operator|->
name|header
operator|.
name|data_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mfi_ctrl_info
argument_list|)
expr_stmt|;
name|dcmd
operator|->
name|opcode
operator|=
name|MFI_DCMD_CTRL_GETINFO
expr_stmt|;
name|cm
operator|->
name|cm_sg
operator|=
operator|&
name|dcmd
operator|->
name|sgl
expr_stmt|;
name|cm
operator|->
name|cm_total_frame_size
operator|=
name|MFI_DCMD_FRAME_SIZE
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator|=
name|MFI_CMD_DATAIN
operator||
name|MFI_CMD_POLLED
expr_stmt|;
name|cm
operator|->
name|cm_data
operator|=
name|ci
expr_stmt|;
name|cm
operator|->
name|cm_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mfi_ctrl_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|mfi_mapcmd
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Controller info buffer map failed"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ci
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* It's ok if this fails, just use default info instead */
if|if
condition|(
operator|(
name|error
operator|=
name|mfi_polled_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Failed to get controller info\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mfi_max_io
operator|=
operator|(
name|sc
operator|->
name|mfi_total_sgl
operator|-
literal|1
operator|)
operator|*
name|PAGE_SIZE
operator|/
name|MFI_SECTOR_LEN
expr_stmt|;
name|free
argument_list|(
name|ci
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|)
expr_stmt|;
name|max_sectors_1
operator|=
operator|(
literal|1
operator|<<
name|ci
operator|->
name|stripe_sz_ops
operator|.
name|min
operator|)
operator|*
name|ci
operator|->
name|max_strips_per_io
expr_stmt|;
name|max_sectors_2
operator|=
name|ci
operator|->
name|max_request_size
expr_stmt|;
name|sc
operator|->
name|mfi_max_io
operator|=
name|min
argument_list|(
name|max_sectors_1
argument_list|,
name|max_sectors_2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ci
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_get_log_state
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mfi_evt_log_state
modifier|*
name|log_state
parameter_list|)
block|{
name|struct
name|mfi_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|mfi_dcmd_frame
modifier|*
name|dcmd
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|cm
operator|=
name|mfi_dequeue_free
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|dcmd
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|dcmd
expr_stmt|;
name|bzero
argument_list|(
name|dcmd
operator|->
name|mbox
argument_list|,
name|MFI_MBOX_SIZE
argument_list|)
expr_stmt|;
name|dcmd
operator|->
name|header
operator|.
name|cmd
operator|=
name|MFI_CMD_DCMD
expr_stmt|;
name|dcmd
operator|->
name|header
operator|.
name|timeout
operator|=
literal|0
expr_stmt|;
name|dcmd
operator|->
name|header
operator|.
name|data_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mfi_evt_log_state
argument_list|)
expr_stmt|;
name|dcmd
operator|->
name|opcode
operator|=
name|MFI_DCMD_CTRL_EVENT_GETINFO
expr_stmt|;
name|cm
operator|->
name|cm_sg
operator|=
operator|&
name|dcmd
operator|->
name|sgl
expr_stmt|;
name|cm
operator|->
name|cm_total_frame_size
operator|=
name|MFI_DCMD_FRAME_SIZE
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator|=
name|MFI_CMD_DATAIN
operator||
name|MFI_CMD_POLLED
expr_stmt|;
name|cm
operator|->
name|cm_data
operator|=
name|log_state
expr_stmt|;
name|cm
operator|->
name|cm_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mfi_evt_log_state
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|mfi_mapcmd
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Controller info buffer map failed"
argument_list|)
expr_stmt|;
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* It's ok if this fails, just use default info instead */
if|if
condition|(
operator|(
name|error
operator|=
name|mfi_polled_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Failed to get controller state\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mfi_max_io
operator|=
operator|(
name|sc
operator|->
name|mfi_total_sgl
operator|-
literal|1
operator|)
operator|*
name|PAGE_SIZE
operator|/
name|MFI_SECTOR_LEN
expr_stmt|;
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|)
expr_stmt|;
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_aen_setup
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|seq_start
parameter_list|)
block|{
name|struct
name|mfi_evt_log_state
name|log_state
decl_stmt|;
name|union
name|mfi_evt
name|class_locale
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|uint32_t
name|seq
decl_stmt|;
name|class_locale
operator|.
name|members
operator|.
name|reserved
operator|=
literal|0
expr_stmt|;
name|class_locale
operator|.
name|members
operator|.
name|locale
operator|=
name|MFI_EVT_LOCALE_ALL
expr_stmt|;
name|class_locale
operator|.
name|members
operator|.
name|class
operator|=
name|MFI_EVT_CLASS_DEBUG
expr_stmt|;
if|if
condition|(
name|seq_start
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|mfi_get_log_state
argument_list|(
name|sc
argument_list|,
operator|&
name|log_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 		 * Don't run them yet since we can't parse them. 		 * We can indirectly get the contents from 		 * the AEN mechanism via setting it lower then 		 * current.  The firmware will iterate through them. 		 */
ifdef|#
directive|ifdef
name|NOTYET
for|for
control|(
name|seq
operator|=
name|log_state
operator|.
name|shutdown_seq_num
init|;
name|seq
operator|<=
name|log_state
operator|.
name|newest_seq_num
condition|;
name|seq
operator|++
control|)
block|{
name|mfi_get_entry
argument_list|(
name|sc
argument_list|,
name|seq
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|seq
operator|=
name|log_state
operator|.
name|shutdown_seq_num
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|seq
operator|=
name|seq_start
expr_stmt|;
name|mfi_aen_register
argument_list|(
name|sc
argument_list|,
name|seq
argument_list|,
name|class_locale
operator|.
name|word
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_polled_command
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mfi_command
modifier|*
name|cm
parameter_list|)
block|{
name|struct
name|mfi_frame_header
modifier|*
name|hdr
decl_stmt|;
name|int
name|tm
init|=
name|MFI_POLL_TIMEOUT_SECS
operator|*
literal|1000000
decl_stmt|;
name|hdr
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|header
expr_stmt|;
name|hdr
operator|->
name|cmd_status
operator|=
literal|0xff
expr_stmt|;
name|hdr
operator|->
name|flags
operator||=
name|MFI_FRAME_DONT_POST_IN_REPLY_QUEUE
expr_stmt|;
name|mfi_send_frame
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
while|while
condition|(
name|hdr
operator|->
name|cmd_status
operator|==
literal|0xff
condition|)
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|tm
operator|-=
literal|1000
expr_stmt|;
if|if
condition|(
name|tm
operator|<=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|hdr
operator|->
name|cmd_status
operator|==
literal|0xff
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Frame %p timed out\n"
argument_list|,
name|hdr
argument_list|)
expr_stmt|;
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|mfi_free
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mfi_command
modifier|*
name|cm
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_cdev
operator|!=
name|NULL
condition|)
name|destroy_dev
argument_list|(
name|sc
operator|->
name|mfi_cdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_total_cmds
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|mfi_total_cmds
condition|;
name|i
operator|++
control|)
block|{
name|cm
operator|=
operator|&
name|sc
operator|->
name|mfi_commands
index|[
name|i
index|]
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|sc
operator|->
name|mfi_commands
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|mfi_intr
condition|)
name|bus_teardown_intr
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
name|sc
operator|->
name|mfi_irq
argument_list|,
name|sc
operator|->
name|mfi_intr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_irq
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|mfi_irq_rid
argument_list|,
name|sc
operator|->
name|mfi_irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_sense_busaddr
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|mfi_sense_dmat
argument_list|,
name|sc
operator|->
name|mfi_sense_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_sense
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|mfi_sense_dmat
argument_list|,
name|sc
operator|->
name|mfi_sense
argument_list|,
name|sc
operator|->
name|mfi_sense_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_sense_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|mfi_sense_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_frames_busaddr
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|mfi_frames_dmat
argument_list|,
name|sc
operator|->
name|mfi_frames_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_frames
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|mfi_frames_dmat
argument_list|,
name|sc
operator|->
name|mfi_frames
argument_list|,
name|sc
operator|->
name|mfi_frames_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_frames_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|mfi_frames_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_comms_busaddr
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|mfi_comms_dmat
argument_list|,
name|sc
operator|->
name|mfi_comms_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_comms
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|mfi_comms_dmat
argument_list|,
name|sc
operator|->
name|mfi_comms
argument_list|,
name|sc
operator|->
name|mfi_comms_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_comms_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|mfi_comms_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_buffer_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_parent_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|mfi_parent_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
condition|)
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|mfi_startup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|mfi_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|mfi_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|config_intrhook_disestablish
argument_list|(
operator|&
name|sc
operator|->
name|mfi_ich
argument_list|)
expr_stmt|;
name|mfi_enable_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mfi_ldprobe_inq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mfi_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|mfi_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mfi_command
modifier|*
name|cm
decl_stmt|;
name|uint32_t
name|status
decl_stmt|,
name|pi
decl_stmt|,
name|ci
decl_stmt|,
name|context
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|mfi_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|status
operator|=
name|MFI_READ4
argument_list|(
name|sc
argument_list|,
name|MFI_OSTS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|MFI_OSTS_INTR_VALID
operator|)
operator|==
literal|0
condition|)
return|return;
name|MFI_WRITE4
argument_list|(
name|sc
argument_list|,
name|MFI_OSTS
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|pi
operator|=
name|sc
operator|->
name|mfi_comms
operator|->
name|hw_pi
expr_stmt|;
name|ci
operator|=
name|sc
operator|->
name|mfi_comms
operator|->
name|hw_ci
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|ci
operator|!=
name|pi
condition|)
block|{
name|context
operator|=
name|sc
operator|->
name|mfi_comms
operator|->
name|hw_reply_q
index|[
name|ci
index|]
expr_stmt|;
name|sc
operator|->
name|mfi_comms
operator|->
name|hw_reply_q
index|[
name|ci
index|]
operator|=
literal|0xffffffff
expr_stmt|;
if|if
condition|(
name|context
operator|==
literal|0xffffffff
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"mfi_intr: invalid context "
literal|"pi= %d ci= %d\n"
argument_list|,
name|pi
argument_list|,
name|ci
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cm
operator|=
operator|&
name|sc
operator|->
name|mfi_commands
index|[
name|context
index|]
expr_stmt|;
name|mfi_remove_busy
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|mfi_complete
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
block|}
name|ci
operator|++
expr_stmt|;
if|if
condition|(
name|ci
operator|==
operator|(
name|sc
operator|->
name|mfi_max_fw_cmds
operator|+
literal|1
operator|)
condition|)
block|{
name|ci
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mfi_comms
operator|->
name|hw_ci
operator|=
name|ci
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|int
name|mfi_shutdown
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mfi_dcmd_frame
modifier|*
name|dcmd
decl_stmt|;
name|struct
name|mfi_command
modifier|*
name|cm
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|cm
operator|=
name|mfi_dequeue_free
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|mfi_aen_cm
operator|!=
name|NULL
condition|)
name|mfi_abort
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mfi_aen_cm
argument_list|)
expr_stmt|;
name|dcmd
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|dcmd
expr_stmt|;
name|bzero
argument_list|(
name|dcmd
operator|->
name|mbox
argument_list|,
name|MFI_MBOX_SIZE
argument_list|)
expr_stmt|;
name|dcmd
operator|->
name|header
operator|.
name|cmd
operator|=
name|MFI_CMD_DCMD
expr_stmt|;
name|dcmd
operator|->
name|header
operator|.
name|sg_count
operator|=
literal|0
expr_stmt|;
name|dcmd
operator|->
name|header
operator|.
name|flags
operator|=
name|MFI_FRAME_DIR_NONE
expr_stmt|;
name|dcmd
operator|->
name|header
operator|.
name|timeout
operator|=
literal|0
expr_stmt|;
name|dcmd
operator|->
name|header
operator|.
name|data_len
operator|=
literal|0
expr_stmt|;
name|dcmd
operator|->
name|opcode
operator|=
name|MFI_DCMD_CTRL_SHUTDOWN
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|mfi_polled_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Failed to shutdown controller\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mfi_enable_intr
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|MFI_WRITE4
argument_list|(
name|sc
argument_list|,
name|MFI_OMSK
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mfi_ldprobe_inq
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mfi_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|mfi_pass_frame
modifier|*
name|pass
decl_stmt|;
name|char
modifier|*
name|inq
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Probe all possible targets with a SCSI INQ command */
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mfi_probe_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MFI_MAX_CHANNEL_DEVS
condition|;
name|i
operator|++
control|)
block|{
name|inq
operator|=
name|malloc
argument_list|(
name|MFI_INQ_LENGTH
argument_list|,
name|M_MFIBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|inq
operator|==
name|NULL
condition|)
break|break;
name|cm
operator|=
name|mfi_dequeue_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|inq
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
name|msleep
argument_list|(
name|mfi_startup
argument_list|,
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|,
literal|0
argument_list|,
literal|"mfistart"
argument_list|,
literal|5
operator|*
name|hz
argument_list|)
expr_stmt|;
name|i
operator|--
expr_stmt|;
continue|continue;
block|}
name|pass
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|pass
expr_stmt|;
name|pass
operator|->
name|header
operator|.
name|cmd
operator|=
name|MFI_CMD_LD_SCSI_IO
expr_stmt|;
name|pass
operator|->
name|header
operator|.
name|target_id
operator|=
name|i
expr_stmt|;
name|pass
operator|->
name|header
operator|.
name|lun_id
operator|=
literal|0
expr_stmt|;
name|pass
operator|->
name|header
operator|.
name|cdb_len
operator|=
literal|6
expr_stmt|;
name|pass
operator|->
name|header
operator|.
name|timeout
operator|=
literal|0
expr_stmt|;
name|pass
operator|->
name|header
operator|.
name|data_len
operator|=
name|MFI_INQ_LENGTH
expr_stmt|;
name|bzero
argument_list|(
name|pass
operator|->
name|cdb
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|pass
operator|->
name|cdb
index|[
literal|0
index|]
operator|=
name|INQUIRY
expr_stmt|;
name|pass
operator|->
name|cdb
index|[
literal|4
index|]
operator|=
name|MFI_INQ_LENGTH
expr_stmt|;
name|pass
operator|->
name|header
operator|.
name|sense_len
operator|=
name|MFI_SENSE_LEN
expr_stmt|;
name|pass
operator|->
name|sense_addr_lo
operator|=
name|cm
operator|->
name|cm_sense_busaddr
expr_stmt|;
name|pass
operator|->
name|sense_addr_hi
operator|=
literal|0
expr_stmt|;
name|cm
operator|->
name|cm_complete
operator|=
name|mfi_ldprobe_inq_complete
expr_stmt|;
name|cm
operator|->
name|cm_private
operator|=
name|inq
expr_stmt|;
name|cm
operator|->
name|cm_sg
operator|=
operator|&
name|pass
operator|->
name|sgl
expr_stmt|;
name|cm
operator|->
name|cm_total_frame_size
operator|=
name|MFI_PASS_FRAME_SIZE
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator||=
name|MFI_CMD_DATAIN
expr_stmt|;
name|cm
operator|->
name|cm_data
operator|=
name|inq
expr_stmt|;
name|cm
operator|->
name|cm_len
operator|=
name|MFI_INQ_LENGTH
expr_stmt|;
name|sc
operator|->
name|mfi_probe_count
operator|++
expr_stmt|;
name|mfi_enqueue_ready
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|mfi_startio
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* Sleep while the arrays are attaching */
name|msleep
argument_list|(
name|mfi_startup
argument_list|,
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|,
literal|0
argument_list|,
literal|"mfistart"
argument_list|,
literal|60
operator|*
name|hz
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|mfi_ldprobe_inq_complete
parameter_list|(
name|struct
name|mfi_command
modifier|*
name|cm
parameter_list|)
block|{
name|struct
name|mfi_frame_header
modifier|*
name|hdr
decl_stmt|;
name|struct
name|mfi_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|scsi_inquiry_data
modifier|*
name|inq
decl_stmt|;
name|sc
operator|=
name|cm
operator|->
name|cm_sc
expr_stmt|;
name|inq
operator|=
name|cm
operator|->
name|cm_private
expr_stmt|;
name|hdr
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|header
expr_stmt|;
if|if
condition|(
operator|(
name|hdr
operator|->
name|cmd_status
operator|!=
name|MFI_STAT_OK
operator|)
operator|||
operator|(
name|hdr
operator|->
name|scsi_status
operator|!=
literal|0x00
operator|)
operator|||
operator|(
name|SID_TYPE
argument_list|(
name|inq
argument_list|)
operator|!=
name|T_DIRECT
operator|)
condition|)
block|{
name|free
argument_list|(
name|inq
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|sc
operator|->
name|mfi_probe_count
operator|<=
literal|0
condition|)
name|wakeup
argument_list|(
name|mfi_startup
argument_list|)
expr_stmt|;
return|return;
block|}
name|free
argument_list|(
name|inq
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|mfi_ldprobe_tur
argument_list|(
name|sc
argument_list|,
name|hdr
operator|->
name|target_id
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_ldprobe_tur
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|struct
name|mfi_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|mfi_pass_frame
modifier|*
name|pass
decl_stmt|;
name|cm
operator|=
name|mfi_dequeue_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|==
name|NULL
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|pass
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|pass
expr_stmt|;
name|pass
operator|->
name|header
operator|.
name|cmd
operator|=
name|MFI_CMD_LD_SCSI_IO
expr_stmt|;
name|pass
operator|->
name|header
operator|.
name|target_id
operator|=
name|id
expr_stmt|;
name|pass
operator|->
name|header
operator|.
name|lun_id
operator|=
literal|0
expr_stmt|;
name|pass
operator|->
name|header
operator|.
name|cdb_len
operator|=
literal|6
expr_stmt|;
name|pass
operator|->
name|header
operator|.
name|timeout
operator|=
literal|0
expr_stmt|;
name|pass
operator|->
name|header
operator|.
name|data_len
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|pass
operator|->
name|cdb
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|pass
operator|->
name|cdb
index|[
literal|0
index|]
operator|=
name|TEST_UNIT_READY
expr_stmt|;
name|pass
operator|->
name|header
operator|.
name|sense_len
operator|=
name|MFI_SENSE_LEN
expr_stmt|;
name|pass
operator|->
name|sense_addr_lo
operator|=
name|cm
operator|->
name|cm_sense_busaddr
expr_stmt|;
name|pass
operator|->
name|sense_addr_hi
operator|=
literal|0
expr_stmt|;
name|cm
operator|->
name|cm_complete
operator|=
name|mfi_ldprobe_tur_complete
expr_stmt|;
name|cm
operator|->
name|cm_total_frame_size
operator|=
name|MFI_PASS_FRAME_SIZE
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator|=
literal|0
expr_stmt|;
name|mfi_enqueue_ready
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|mfi_startio
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mfi_ldprobe_tur_complete
parameter_list|(
name|struct
name|mfi_command
modifier|*
name|cm
parameter_list|)
block|{
name|struct
name|mfi_frame_header
modifier|*
name|hdr
decl_stmt|;
name|struct
name|mfi_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|cm
operator|->
name|cm_sc
expr_stmt|;
name|hdr
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|header
expr_stmt|;
if|if
condition|(
operator|(
name|hdr
operator|->
name|cmd_status
operator|!=
name|MFI_STAT_OK
operator|)
operator|||
operator|(
name|hdr
operator|->
name|scsi_status
operator|!=
literal|0x00
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Logical disk %d is not ready, "
literal|"cmd_status= %d scsi_status= %d\n"
argument_list|,
name|hdr
operator|->
name|target_id
argument_list|,
name|hdr
operator|->
name|cmd_status
argument_list|,
name|hdr
operator|->
name|scsi_status
argument_list|)
expr_stmt|;
name|mfi_print_sense
argument_list|(
name|sc
argument_list|,
name|cm
operator|->
name|cm_sense
argument_list|)
expr_stmt|;
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|sc
operator|->
name|mfi_probe_count
operator|<=
literal|0
condition|)
name|wakeup
argument_list|(
name|mfi_startup
argument_list|)
expr_stmt|;
return|return;
block|}
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|mfi_ldprobe_capacity
argument_list|(
name|sc
argument_list|,
name|hdr
operator|->
name|target_id
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|NOTYET
end_ifdef

begin_function
specifier|static
name|void
name|mfi_decode_log
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mfi_log_detail
modifier|*
name|detail
parameter_list|)
block|{
switch|switch
condition|(
name|detail
operator|->
name|arg_type
condition|)
block|{
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"%d - Log entry type %d\n"
argument_list|,
name|detail
operator|->
name|seq
argument_list|,
name|detail
operator|->
name|arg_type
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|mfi_decode_evt
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mfi_evt_detail
modifier|*
name|detail
parameter_list|)
block|{
switch|switch
condition|(
name|detail
operator|->
name|arg_type
condition|)
block|{
case|case
name|MR_EVT_ARGS_NONE
case|:
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"%d - %s\n"
argument_list|,
name|detail
operator|->
name|seq
argument_list|,
name|detail
operator|->
name|description
argument_list|)
expr_stmt|;
break|break;
case|case
name|MR_EVT_ARGS_CDB_SENSE
case|:
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"%d - PD %02d(e%d/s%d) CDB %*D"
literal|"Sense %*D\n: %s\n"
argument_list|,
name|detail
operator|->
name|seq
argument_list|,
name|detail
operator|->
name|args
operator|.
name|cdb_sense
operator|.
name|pd
operator|.
name|device_id
argument_list|,
name|detail
operator|->
name|args
operator|.
name|cdb_sense
operator|.
name|pd
operator|.
name|enclosure_index
argument_list|,
name|detail
operator|->
name|args
operator|.
name|cdb_sense
operator|.
name|pd
operator|.
name|slot_number
argument_list|,
name|detail
operator|->
name|args
operator|.
name|cdb_sense
operator|.
name|cdb_len
argument_list|,
name|detail
operator|->
name|args
operator|.
name|cdb_sense
operator|.
name|cdb
argument_list|,
literal|":"
argument_list|,
name|detail
operator|->
name|args
operator|.
name|cdb_sense
operator|.
name|sense_len
argument_list|,
name|detail
operator|->
name|args
operator|.
name|cdb_sense
operator|.
name|sense
argument_list|,
literal|":"
argument_list|,
name|detail
operator|->
name|description
argument_list|)
expr_stmt|;
break|break;
case|case
name|MR_EVT_ARGS_LD
case|:
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"%d - VD %02d/%d "
literal|"event: %s\n"
argument_list|,
name|detail
operator|->
name|seq
argument_list|,
name|detail
operator|->
name|args
operator|.
name|ld
operator|.
name|ld_index
argument_list|,
name|detail
operator|->
name|args
operator|.
name|ld
operator|.
name|target_id
argument_list|,
name|detail
operator|->
name|description
argument_list|)
expr_stmt|;
break|break;
case|case
name|MR_EVT_ARGS_LD_COUNT
case|:
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"%d - VD %02d/%d "
literal|"count %lld: %s\n"
argument_list|,
name|detail
operator|->
name|seq
argument_list|,
name|detail
operator|->
name|args
operator|.
name|ld_count
operator|.
name|ld
operator|.
name|ld_index
argument_list|,
name|detail
operator|->
name|args
operator|.
name|ld_count
operator|.
name|ld
operator|.
name|target_id
argument_list|,
operator|(
name|long
name|long
operator|)
name|detail
operator|->
name|args
operator|.
name|ld_count
operator|.
name|count
argument_list|,
name|detail
operator|->
name|description
argument_list|)
expr_stmt|;
break|break;
case|case
name|MR_EVT_ARGS_LD_LBA
case|:
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"%d - VD %02d/%d "
literal|"lba %lld: %s\n"
argument_list|,
name|detail
operator|->
name|seq
argument_list|,
name|detail
operator|->
name|args
operator|.
name|ld_lba
operator|.
name|ld
operator|.
name|ld_index
argument_list|,
name|detail
operator|->
name|args
operator|.
name|ld_lba
operator|.
name|ld
operator|.
name|target_id
argument_list|,
operator|(
name|long
name|long
operator|)
name|detail
operator|->
name|args
operator|.
name|ld_lba
operator|.
name|lba
argument_list|,
name|detail
operator|->
name|description
argument_list|)
expr_stmt|;
break|break;
case|case
name|MR_EVT_ARGS_LD_OWNER
case|:
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"%d - VD %02d/%d "
literal|"owner changed: prior %d, new %d: %s\n"
argument_list|,
name|detail
operator|->
name|seq
argument_list|,
name|detail
operator|->
name|args
operator|.
name|ld_owner
operator|.
name|ld
operator|.
name|ld_index
argument_list|,
name|detail
operator|->
name|args
operator|.
name|ld_owner
operator|.
name|ld
operator|.
name|target_id
argument_list|,
name|detail
operator|->
name|args
operator|.
name|ld_owner
operator|.
name|pre_owner
argument_list|,
name|detail
operator|->
name|args
operator|.
name|ld_owner
operator|.
name|new_owner
argument_list|,
name|detail
operator|->
name|description
argument_list|)
expr_stmt|;
break|break;
case|case
name|MR_EVT_ARGS_LD_LBA_PD_LBA
case|:
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"%d - VD %02d/%d "
literal|"lba %lld, physical drive PD %02d(e%d/s%d) lba %lld: %s\n"
argument_list|,
name|detail
operator|->
name|seq
argument_list|,
name|detail
operator|->
name|args
operator|.
name|ld_lba_pd_lba
operator|.
name|ld
operator|.
name|ld_index
argument_list|,
name|detail
operator|->
name|args
operator|.
name|ld_lba_pd_lba
operator|.
name|ld
operator|.
name|target_id
argument_list|,
operator|(
name|long
name|long
operator|)
name|detail
operator|->
name|args
operator|.
name|ld_lba_pd_lba
operator|.
name|ld_lba
argument_list|,
name|detail
operator|->
name|args
operator|.
name|ld_lba_pd_lba
operator|.
name|pd
operator|.
name|device_id
argument_list|,
name|detail
operator|->
name|args
operator|.
name|ld_lba_pd_lba
operator|.
name|pd
operator|.
name|enclosure_index
argument_list|,
name|detail
operator|->
name|args
operator|.
name|ld_lba_pd_lba
operator|.
name|pd
operator|.
name|slot_number
argument_list|,
operator|(
name|long
name|long
operator|)
name|detail
operator|->
name|args
operator|.
name|ld_lba_pd_lba
operator|.
name|pd_lba
argument_list|,
name|detail
operator|->
name|description
argument_list|)
expr_stmt|;
break|break;
case|case
name|MR_EVT_ARGS_LD_PROG
case|:
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"%d - VD %02d/%d "
literal|"progress %d%% in %ds: %s\n"
argument_list|,
name|detail
operator|->
name|seq
argument_list|,
name|detail
operator|->
name|args
operator|.
name|ld_prog
operator|.
name|ld
operator|.
name|ld_index
argument_list|,
name|detail
operator|->
name|args
operator|.
name|ld_prog
operator|.
name|ld
operator|.
name|target_id
argument_list|,
name|detail
operator|->
name|args
operator|.
name|ld_prog
operator|.
name|prog
operator|.
name|progress
operator|/
literal|655
argument_list|,
name|detail
operator|->
name|args
operator|.
name|ld_prog
operator|.
name|prog
operator|.
name|elapsed_seconds
argument_list|,
name|detail
operator|->
name|description
argument_list|)
expr_stmt|;
break|break;
case|case
name|MR_EVT_ARGS_LD_STATE
case|:
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"%d - VD %02d/%d "
literal|"state prior %d new %d: %s\n"
argument_list|,
name|detail
operator|->
name|seq
argument_list|,
name|detail
operator|->
name|args
operator|.
name|ld_state
operator|.
name|ld
operator|.
name|ld_index
argument_list|,
name|detail
operator|->
name|args
operator|.
name|ld_state
operator|.
name|ld
operator|.
name|target_id
argument_list|,
name|detail
operator|->
name|args
operator|.
name|ld_state
operator|.
name|prev_state
argument_list|,
name|detail
operator|->
name|args
operator|.
name|ld_state
operator|.
name|new_state
argument_list|,
name|detail
operator|->
name|description
argument_list|)
expr_stmt|;
break|break;
case|case
name|MR_EVT_ARGS_LD_STRIP
case|:
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"%d - VD %02d/%d "
literal|"strip %lld: %s\n"
argument_list|,
name|detail
operator|->
name|seq
argument_list|,
name|detail
operator|->
name|args
operator|.
name|ld_strip
operator|.
name|ld
operator|.
name|ld_index
argument_list|,
name|detail
operator|->
name|args
operator|.
name|ld_strip
operator|.
name|ld
operator|.
name|target_id
argument_list|,
operator|(
name|long
name|long
operator|)
name|detail
operator|->
name|args
operator|.
name|ld_strip
operator|.
name|strip
argument_list|,
name|detail
operator|->
name|description
argument_list|)
expr_stmt|;
break|break;
case|case
name|MR_EVT_ARGS_PD
case|:
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"%d - PD %02d(e%d/s%d) "
literal|"event: %s\n"
argument_list|,
name|detail
operator|->
name|seq
argument_list|,
name|detail
operator|->
name|args
operator|.
name|pd
operator|.
name|device_id
argument_list|,
name|detail
operator|->
name|args
operator|.
name|pd
operator|.
name|enclosure_index
argument_list|,
name|detail
operator|->
name|args
operator|.
name|pd
operator|.
name|slot_number
argument_list|,
name|detail
operator|->
name|description
argument_list|)
expr_stmt|;
break|break;
case|case
name|MR_EVT_ARGS_PD_ERR
case|:
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"%d - PD %02d(e%d/s%d) "
literal|"err %d: %s\n"
argument_list|,
name|detail
operator|->
name|seq
argument_list|,
name|detail
operator|->
name|args
operator|.
name|pd_err
operator|.
name|pd
operator|.
name|device_id
argument_list|,
name|detail
operator|->
name|args
operator|.
name|pd_err
operator|.
name|pd
operator|.
name|enclosure_index
argument_list|,
name|detail
operator|->
name|args
operator|.
name|pd_err
operator|.
name|pd
operator|.
name|slot_number
argument_list|,
name|detail
operator|->
name|args
operator|.
name|pd_err
operator|.
name|err
argument_list|,
name|detail
operator|->
name|description
argument_list|)
expr_stmt|;
break|break;
case|case
name|MR_EVT_ARGS_PD_LBA
case|:
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"%d - PD %02d(e%d/s%d) "
literal|"lba %lld: %s\n"
argument_list|,
name|detail
operator|->
name|seq
argument_list|,
name|detail
operator|->
name|args
operator|.
name|pd_lba
operator|.
name|pd
operator|.
name|device_id
argument_list|,
name|detail
operator|->
name|args
operator|.
name|pd_lba
operator|.
name|pd
operator|.
name|enclosure_index
argument_list|,
name|detail
operator|->
name|args
operator|.
name|pd_lba
operator|.
name|pd
operator|.
name|slot_number
argument_list|,
operator|(
name|long
name|long
operator|)
name|detail
operator|->
name|args
operator|.
name|pd_lba
operator|.
name|lba
argument_list|,
name|detail
operator|->
name|description
argument_list|)
expr_stmt|;
break|break;
case|case
name|MR_EVT_ARGS_PD_LBA_LD
case|:
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"%d - PD %02d(e%d/s%d) "
literal|"lba %lld VD %02d/%d: %s\n"
argument_list|,
name|detail
operator|->
name|seq
argument_list|,
name|detail
operator|->
name|args
operator|.
name|pd_lba_ld
operator|.
name|pd
operator|.
name|device_id
argument_list|,
name|detail
operator|->
name|args
operator|.
name|pd_lba_ld
operator|.
name|pd
operator|.
name|enclosure_index
argument_list|,
name|detail
operator|->
name|args
operator|.
name|pd_lba_ld
operator|.
name|pd
operator|.
name|slot_number
argument_list|,
operator|(
name|long
name|long
operator|)
name|detail
operator|->
name|args
operator|.
name|pd_lba
operator|.
name|lba
argument_list|,
name|detail
operator|->
name|args
operator|.
name|pd_lba_ld
operator|.
name|ld
operator|.
name|ld_index
argument_list|,
name|detail
operator|->
name|args
operator|.
name|pd_lba_ld
operator|.
name|ld
operator|.
name|target_id
argument_list|,
name|detail
operator|->
name|description
argument_list|)
expr_stmt|;
break|break;
case|case
name|MR_EVT_ARGS_PD_PROG
case|:
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"%d - PD %02d(e%d/s%d) "
literal|"progress %d%% seconds %ds: %s\n"
argument_list|,
name|detail
operator|->
name|seq
argument_list|,
name|detail
operator|->
name|args
operator|.
name|pd_prog
operator|.
name|pd
operator|.
name|device_id
argument_list|,
name|detail
operator|->
name|args
operator|.
name|pd_prog
operator|.
name|pd
operator|.
name|enclosure_index
argument_list|,
name|detail
operator|->
name|args
operator|.
name|pd_prog
operator|.
name|pd
operator|.
name|slot_number
argument_list|,
name|detail
operator|->
name|args
operator|.
name|pd_prog
operator|.
name|prog
operator|.
name|progress
operator|/
literal|655
argument_list|,
name|detail
operator|->
name|args
operator|.
name|pd_prog
operator|.
name|prog
operator|.
name|elapsed_seconds
argument_list|,
name|detail
operator|->
name|description
argument_list|)
expr_stmt|;
break|break;
case|case
name|MR_EVT_ARGS_PD_STATE
case|:
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"%d - PD %02d(e%d/s%d) "
literal|"state prior %d new %d: %s\n"
argument_list|,
name|detail
operator|->
name|seq
argument_list|,
name|detail
operator|->
name|args
operator|.
name|pd_prog
operator|.
name|pd
operator|.
name|device_id
argument_list|,
name|detail
operator|->
name|args
operator|.
name|pd_prog
operator|.
name|pd
operator|.
name|enclosure_index
argument_list|,
name|detail
operator|->
name|args
operator|.
name|pd_prog
operator|.
name|pd
operator|.
name|slot_number
argument_list|,
name|detail
operator|->
name|args
operator|.
name|pd_state
operator|.
name|prev_state
argument_list|,
name|detail
operator|->
name|args
operator|.
name|pd_state
operator|.
name|new_state
argument_list|,
name|detail
operator|->
name|description
argument_list|)
expr_stmt|;
break|break;
case|case
name|MR_EVT_ARGS_PCI
case|:
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"%d - PCI 0x04%x 0x04%x "
literal|"0x04%x 0x04%x: %s\n"
argument_list|,
name|detail
operator|->
name|seq
argument_list|,
name|detail
operator|->
name|args
operator|.
name|pci
operator|.
name|venderId
argument_list|,
name|detail
operator|->
name|args
operator|.
name|pci
operator|.
name|deviceId
argument_list|,
name|detail
operator|->
name|args
operator|.
name|pci
operator|.
name|subVenderId
argument_list|,
name|detail
operator|->
name|args
operator|.
name|pci
operator|.
name|subDeviceId
argument_list|,
name|detail
operator|->
name|description
argument_list|)
expr_stmt|;
break|break;
case|case
name|MR_EVT_ARGS_RATE
case|:
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"%d - Rebuild rate %d: %s\n"
argument_list|,
name|detail
operator|->
name|seq
argument_list|,
name|detail
operator|->
name|args
operator|.
name|rate
argument_list|,
name|detail
operator|->
name|description
argument_list|)
expr_stmt|;
break|break;
case|case
name|MR_EVT_ARGS_TIME
case|:
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"%d - Adapter ticks %d "
literal|"elapsed %ds: %s\n"
argument_list|,
name|detail
operator|->
name|seq
argument_list|,
name|detail
operator|->
name|args
operator|.
name|time
operator|.
name|rtc
argument_list|,
name|detail
operator|->
name|args
operator|.
name|time
operator|.
name|elapsedSeconds
argument_list|,
name|detail
operator|->
name|description
argument_list|)
expr_stmt|;
break|break;
case|case
name|MR_EVT_ARGS_ECC
case|:
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"%d - Adapter ECC %x,%x: %s: %s\n"
argument_list|,
name|detail
operator|->
name|seq
argument_list|,
name|detail
operator|->
name|args
operator|.
name|ecc
operator|.
name|ecar
argument_list|,
name|detail
operator|->
name|args
operator|.
name|ecc
operator|.
name|elog
argument_list|,
name|detail
operator|->
name|args
operator|.
name|ecc
operator|.
name|str
argument_list|,
name|detail
operator|->
name|description
argument_list|)
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"%d - Type %d: %s\n"
argument_list|,
name|detail
operator|->
name|seq
argument_list|,
name|detail
operator|->
name|arg_type
argument_list|,
name|detail
operator|->
name|description
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_aen_register
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|seq
parameter_list|,
name|int
name|locale
parameter_list|)
block|{
name|struct
name|mfi_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|mfi_dcmd_frame
modifier|*
name|dcmd
decl_stmt|;
name|union
name|mfi_evt
name|current_aen
decl_stmt|,
name|prior_aen
decl_stmt|;
name|struct
name|mfi_evt_detail
modifier|*
name|ed
decl_stmt|;
name|current_aen
operator|.
name|word
operator|=
name|locale
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_aen_cm
operator|!=
name|NULL
condition|)
block|{
name|prior_aen
operator|.
name|word
operator|=
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|sc
operator|->
name|mfi_aen_cm
operator|->
name|cm_frame
operator|->
name|dcmd
operator|.
name|mbox
operator|)
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|prior_aen
operator|.
name|members
operator|.
name|class
operator|<=
name|current_aen
operator|.
name|members
operator|.
name|class
operator|&&
operator|!
operator|(
operator|(
name|prior_aen
operator|.
name|members
operator|.
name|locale
operator|&
name|current_aen
operator|.
name|members
operator|.
name|locale
operator|)
operator|^
name|current_aen
operator|.
name|members
operator|.
name|locale
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|prior_aen
operator|.
name|members
operator|.
name|locale
operator||=
name|current_aen
operator|.
name|members
operator|.
name|locale
expr_stmt|;
if|if
condition|(
name|prior_aen
operator|.
name|members
operator|.
name|class
operator|<
name|current_aen
operator|.
name|members
operator|.
name|class
condition|)
name|current_aen
operator|.
name|members
operator|.
name|class
operator|=
name|prior_aen
operator|.
name|members
operator|.
name|class
expr_stmt|;
name|mfi_abort
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mfi_aen_cm
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|=
name|mfi_dequeue_free
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|ed
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mfi_evt_detail
argument_list|)
argument_list|,
name|M_MFIBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|ed
operator|==
name|NULL
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|dcmd
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|dcmd
expr_stmt|;
name|bzero
argument_list|(
name|dcmd
operator|->
name|mbox
argument_list|,
name|MFI_MBOX_SIZE
argument_list|)
expr_stmt|;
name|dcmd
operator|->
name|header
operator|.
name|cmd
operator|=
name|MFI_CMD_DCMD
expr_stmt|;
name|dcmd
operator|->
name|header
operator|.
name|timeout
operator|=
literal|0
expr_stmt|;
name|dcmd
operator|->
name|header
operator|.
name|data_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mfi_evt_detail
argument_list|)
expr_stmt|;
name|dcmd
operator|->
name|opcode
operator|=
name|MFI_DCMD_CTRL_EVENT_WAIT
expr_stmt|;
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|dcmd
operator|->
name|mbox
operator|)
index|[
literal|0
index|]
operator|=
name|seq
expr_stmt|;
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|dcmd
operator|->
name|mbox
operator|)
index|[
literal|1
index|]
operator|=
name|locale
expr_stmt|;
name|cm
operator|->
name|cm_sg
operator|=
operator|&
name|dcmd
operator|->
name|sgl
expr_stmt|;
name|cm
operator|->
name|cm_total_frame_size
operator|=
name|MFI_DCMD_FRAME_SIZE
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator|=
name|MFI_CMD_DATAIN
expr_stmt|;
name|cm
operator|->
name|cm_data
operator|=
name|ed
expr_stmt|;
name|cm
operator|->
name|cm_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mfi_evt_detail
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_complete
operator|=
name|mfi_aen_complete
expr_stmt|;
name|sc
operator|->
name|mfi_aen_cm
operator|=
name|cm
expr_stmt|;
name|mfi_enqueue_ready
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|mfi_startio
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mfi_aen_complete
parameter_list|(
name|struct
name|mfi_command
modifier|*
name|cm
parameter_list|)
block|{
name|struct
name|mfi_frame_header
modifier|*
name|hdr
decl_stmt|;
name|struct
name|mfi_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mfi_evt_detail
modifier|*
name|detail
decl_stmt|;
name|struct
name|mfi_aen
modifier|*
name|mfi_aen_entry
decl_stmt|;
name|int
name|seq
init|=
literal|0
decl_stmt|,
name|aborted
init|=
literal|0
decl_stmt|;
name|sc
operator|=
name|cm
operator|->
name|cm_sc
expr_stmt|;
name|hdr
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|header
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_aen_cm
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|sc
operator|->
name|mfi_aen_cm
operator|->
name|cm_aen_abort
operator|||
name|hdr
operator|->
name|cmd_status
operator|==
literal|0xff
condition|)
block|{
name|sc
operator|->
name|mfi_aen_cm
operator|->
name|cm_aen_abort
operator|=
literal|0
expr_stmt|;
name|aborted
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|mfi_aen_triggered
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_poll_waiting
condition|)
name|selwakeup
argument_list|(
operator|&
name|sc
operator|->
name|mfi_select
argument_list|)
expr_stmt|;
name|detail
operator|=
name|cm
operator|->
name|cm_data
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|mfi_decode_evt
argument_list|(
name|sc
argument_list|,
name|detail
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|seq
operator|=
name|detail
operator|->
name|seq
operator|+
literal|1
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|mfi_aen_entry
argument_list|,
argument|&sc->mfi_aen_pids
argument_list|,
argument|aen_link
argument_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|mfi_aen_pids
argument_list|,
name|mfi_aen_entry
argument_list|,
name|aen_link
argument_list|)
expr_stmt|;
name|psignal
argument_list|(
name|mfi_aen_entry
operator|->
name|p
argument_list|,
name|SIGIO
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mfi_aen_entry
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|cm
operator|->
name|cm_data
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mfi_aen_cm
operator|=
name|NULL
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|mfi_aen_cm
argument_list|)
expr_stmt|;
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
comment|/* set it up again so the driver can catch more events */
if|if
condition|(
operator|!
name|aborted
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|mfi_aen_setup
argument_list|(
name|sc
argument_list|,
name|seq
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|NOTYET
end_ifdef

begin_function
specifier|static
name|int
name|mfi_get_entry
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|seq
parameter_list|)
block|{
name|struct
name|mfi_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|mfi_dcmd_frame
modifier|*
name|dcmd
decl_stmt|;
name|struct
name|mfi_log_detail
modifier|*
name|ed
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|=
name|mfi_dequeue_free
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|ed
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mfi_log_detail
argument_list|)
argument_list|,
name|M_MFIBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|ed
operator|==
name|NULL
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|dcmd
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|dcmd
expr_stmt|;
name|bzero
argument_list|(
name|dcmd
operator|->
name|mbox
argument_list|,
name|MFI_MBOX_SIZE
argument_list|)
expr_stmt|;
name|dcmd
operator|->
name|header
operator|.
name|cmd
operator|=
name|MFI_CMD_DCMD
expr_stmt|;
name|dcmd
operator|->
name|header
operator|.
name|timeout
operator|=
literal|0
expr_stmt|;
name|dcmd
operator|->
name|header
operator|.
name|data_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mfi_log_detail
argument_list|)
expr_stmt|;
name|dcmd
operator|->
name|opcode
operator|=
name|MFI_DCMD_CTRL_EVENT_GET
expr_stmt|;
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|dcmd
operator|->
name|mbox
operator|)
index|[
literal|0
index|]
operator|=
name|seq
expr_stmt|;
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|dcmd
operator|->
name|mbox
operator|)
index|[
literal|1
index|]
operator|=
name|MFI_EVT_LOCALE_ALL
expr_stmt|;
name|cm
operator|->
name|cm_sg
operator|=
operator|&
name|dcmd
operator|->
name|sgl
expr_stmt|;
name|cm
operator|->
name|cm_total_frame_size
operator|=
name|MFI_DCMD_FRAME_SIZE
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator|=
name|MFI_CMD_DATAIN
operator||
name|MFI_CMD_POLLED
expr_stmt|;
name|cm
operator|->
name|cm_data
operator|=
name|ed
expr_stmt|;
name|cm
operator|->
name|cm_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mfi_evt_detail
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|mfi_mapcmd
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Controller info buffer map failed"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ed
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|mfi_polled_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Failed to get controller entry\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mfi_max_io
operator|=
operator|(
name|sc
operator|->
name|mfi_total_sgl
operator|-
literal|1
operator|)
operator|*
name|PAGE_SIZE
operator|/
name|MFI_SECTOR_LEN
expr_stmt|;
name|free
argument_list|(
name|ed
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|)
expr_stmt|;
name|mfi_decode_log
argument_list|(
name|sc
argument_list|,
name|ed
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cm
operator|->
name|cm_data
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|mfi_ldprobe_capacity
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|struct
name|mfi_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|mfi_pass_frame
modifier|*
name|pass
decl_stmt|;
name|struct
name|scsi_read_capacity_data_long
modifier|*
name|cap
decl_stmt|;
name|cap
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|cap
argument_list|)
argument_list|,
name|M_MFIBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|cap
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|cm
operator|=
name|mfi_dequeue_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|cap
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|pass
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|pass
expr_stmt|;
name|pass
operator|->
name|header
operator|.
name|cmd
operator|=
name|MFI_CMD_LD_SCSI_IO
expr_stmt|;
name|pass
operator|->
name|header
operator|.
name|target_id
operator|=
name|id
expr_stmt|;
name|pass
operator|->
name|header
operator|.
name|lun_id
operator|=
literal|0
expr_stmt|;
name|pass
operator|->
name|header
operator|.
name|cdb_len
operator|=
literal|6
expr_stmt|;
name|pass
operator|->
name|header
operator|.
name|timeout
operator|=
literal|0
expr_stmt|;
name|pass
operator|->
name|header
operator|.
name|data_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|cap
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|pass
operator|->
name|cdb
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|pass
operator|->
name|cdb
index|[
literal|0
index|]
operator|=
literal|0x9e
expr_stmt|;
comment|/* READ CAPACITY 16 */
name|pass
operator|->
name|cdb
index|[
literal|13
index|]
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|cap
argument_list|)
expr_stmt|;
name|pass
operator|->
name|header
operator|.
name|sense_len
operator|=
name|MFI_SENSE_LEN
expr_stmt|;
name|pass
operator|->
name|sense_addr_lo
operator|=
name|cm
operator|->
name|cm_sense_busaddr
expr_stmt|;
name|pass
operator|->
name|sense_addr_hi
operator|=
literal|0
expr_stmt|;
name|cm
operator|->
name|cm_complete
operator|=
name|mfi_ldprobe_capacity_complete
expr_stmt|;
name|cm
operator|->
name|cm_private
operator|=
name|cap
expr_stmt|;
name|cm
operator|->
name|cm_sg
operator|=
operator|&
name|pass
operator|->
name|sgl
expr_stmt|;
name|cm
operator|->
name|cm_total_frame_size
operator|=
name|MFI_PASS_FRAME_SIZE
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator||=
name|MFI_CMD_DATAIN
expr_stmt|;
name|cm
operator|->
name|cm_data
operator|=
name|cap
expr_stmt|;
name|cm
operator|->
name|cm_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|cap
argument_list|)
expr_stmt|;
name|mfi_enqueue_ready
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|mfi_startio
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mfi_ldprobe_capacity_complete
parameter_list|(
name|struct
name|mfi_command
modifier|*
name|cm
parameter_list|)
block|{
name|struct
name|mfi_frame_header
modifier|*
name|hdr
decl_stmt|;
name|struct
name|mfi_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|scsi_read_capacity_data_long
modifier|*
name|cap
decl_stmt|;
name|uint64_t
name|sectors
decl_stmt|;
name|uint32_t
name|secsize
decl_stmt|;
name|int
name|target
decl_stmt|;
name|sc
operator|=
name|cm
operator|->
name|cm_sc
expr_stmt|;
name|cap
operator|=
name|cm
operator|->
name|cm_private
expr_stmt|;
name|hdr
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|header
expr_stmt|;
if|if
condition|(
operator|(
name|hdr
operator|->
name|cmd_status
operator|!=
name|MFI_STAT_OK
operator|)
operator|||
operator|(
name|hdr
operator|->
name|scsi_status
operator|!=
literal|0x00
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Failed to read capacity for "
literal|"logical disk\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"cmd_status= %d scsi_status= %d\n"
argument_list|,
name|hdr
operator|->
name|cmd_status
argument_list|,
name|hdr
operator|->
name|scsi_status
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cap
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|sc
operator|->
name|mfi_probe_count
operator|<=
literal|0
condition|)
name|wakeup
argument_list|(
name|mfi_startup
argument_list|)
expr_stmt|;
return|return;
block|}
name|target
operator|=
name|hdr
operator|->
name|target_id
expr_stmt|;
name|sectors
operator|=
name|scsi_8btou64
argument_list|(
name|cap
operator|->
name|addr
argument_list|)
expr_stmt|;
name|secsize
operator|=
name|scsi_4btoul
argument_list|(
name|cap
operator|->
name|length
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cap
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|mfi_add_ld
argument_list|(
name|sc
argument_list|,
name|target
argument_list|,
name|sectors
argument_list|,
name|secsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|sc
operator|->
name|mfi_probe_count
operator|<=
literal|0
condition|)
name|wakeup
argument_list|(
name|mfi_startup
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_add_ld
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|id
parameter_list|,
name|uint64_t
name|sectors
parameter_list|,
name|uint32_t
name|secsize
parameter_list|)
block|{
name|struct
name|mfi_ld
modifier|*
name|ld
decl_stmt|;
name|device_t
name|child
decl_stmt|;
if|if
condition|(
operator|(
name|secsize
operator|==
literal|0
operator|)
operator|||
operator|(
name|sectors
operator|==
literal|0
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Invalid capacity parameters for "
literal|"logical disk %d\n"
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|ld
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mfi_ld
argument_list|)
argument_list|,
name|M_MFIBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|ld
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Cannot allocate ld\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|child
operator|=
name|device_add_child
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"mfid"
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Failed to add logical disk\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ld
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|ld
operator|->
name|ld_id
operator|=
name|id
expr_stmt|;
name|ld
operator|->
name|ld_disk
operator|=
name|child
expr_stmt|;
name|ld
operator|->
name|ld_secsize
operator|=
name|secsize
expr_stmt|;
name|ld
operator|->
name|ld_sectors
operator|=
name|sectors
expr_stmt|;
name|device_set_ivars
argument_list|(
name|child
argument_list|,
name|ld
argument_list|)
expr_stmt|;
name|device_set_desc
argument_list|(
name|child
argument_list|,
literal|"MFI Logical Disk"
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|bus_generic_attach
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mfi_command
modifier|*
name|mfi_bio_command
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mfi_io_frame
modifier|*
name|io
decl_stmt|;
name|struct
name|mfi_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|bio
modifier|*
name|bio
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|blkcount
decl_stmt|;
if|if
condition|(
operator|(
name|cm
operator|=
name|mfi_dequeue_free
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|(
name|bio
operator|=
name|mfi_dequeue_bio
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|io
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|io
expr_stmt|;
switch|switch
condition|(
name|bio
operator|->
name|bio_cmd
operator|&
literal|0x03
condition|)
block|{
case|case
name|BIO_READ
case|:
name|io
operator|->
name|header
operator|.
name|cmd
operator|=
name|MFI_CMD_LD_READ
expr_stmt|;
name|flags
operator|=
name|MFI_CMD_DATAIN
expr_stmt|;
break|break;
case|case
name|BIO_WRITE
case|:
name|io
operator|->
name|header
operator|.
name|cmd
operator|=
name|MFI_CMD_LD_WRITE
expr_stmt|;
name|flags
operator|=
name|MFI_CMD_DATAOUT
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"Invalid bio command"
argument_list|)
expr_stmt|;
block|}
comment|/* Cheat with the sector length to avoid a non-constant division */
name|blkcount
operator|=
operator|(
name|bio
operator|->
name|bio_bcount
operator|+
name|MFI_SECTOR_LEN
operator|-
literal|1
operator|)
operator|/
name|MFI_SECTOR_LEN
expr_stmt|;
name|io
operator|->
name|header
operator|.
name|target_id
operator|=
operator|(
name|uintptr_t
operator|)
name|bio
operator|->
name|bio_driver1
expr_stmt|;
name|io
operator|->
name|header
operator|.
name|timeout
operator|=
literal|0
expr_stmt|;
name|io
operator|->
name|header
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|io
operator|->
name|header
operator|.
name|sense_len
operator|=
name|MFI_SENSE_LEN
expr_stmt|;
name|io
operator|->
name|header
operator|.
name|data_len
operator|=
name|blkcount
expr_stmt|;
name|io
operator|->
name|sense_addr_lo
operator|=
name|cm
operator|->
name|cm_sense_busaddr
expr_stmt|;
name|io
operator|->
name|sense_addr_hi
operator|=
literal|0
expr_stmt|;
name|io
operator|->
name|lba_hi
operator|=
operator|(
name|bio
operator|->
name|bio_pblkno
operator|&
literal|0xffffffff00000000
operator|)
operator|>>
literal|32
expr_stmt|;
name|io
operator|->
name|lba_lo
operator|=
name|bio
operator|->
name|bio_pblkno
operator|&
literal|0xffffffff
expr_stmt|;
name|cm
operator|->
name|cm_complete
operator|=
name|mfi_bio_complete
expr_stmt|;
name|cm
operator|->
name|cm_private
operator|=
name|bio
expr_stmt|;
name|cm
operator|->
name|cm_data
operator|=
name|bio
operator|->
name|bio_data
expr_stmt|;
name|cm
operator|->
name|cm_len
operator|=
name|bio
operator|->
name|bio_bcount
expr_stmt|;
name|cm
operator|->
name|cm_sg
operator|=
operator|&
name|io
operator|->
name|sgl
expr_stmt|;
name|cm
operator|->
name|cm_total_frame_size
operator|=
name|MFI_IO_FRAME_SIZE
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator|=
name|flags
expr_stmt|;
return|return
operator|(
name|cm
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mfi_bio_complete
parameter_list|(
name|struct
name|mfi_command
modifier|*
name|cm
parameter_list|)
block|{
name|struct
name|bio
modifier|*
name|bio
decl_stmt|;
name|struct
name|mfi_frame_header
modifier|*
name|hdr
decl_stmt|;
name|struct
name|mfi_softc
modifier|*
name|sc
decl_stmt|;
name|bio
operator|=
name|cm
operator|->
name|cm_private
expr_stmt|;
name|hdr
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|header
expr_stmt|;
name|sc
operator|=
name|cm
operator|->
name|cm_sc
expr_stmt|;
if|if
condition|(
operator|(
name|hdr
operator|->
name|cmd_status
operator|!=
literal|0
operator|)
operator|||
operator|(
name|hdr
operator|->
name|scsi_status
operator|!=
literal|0
operator|)
condition|)
block|{
name|bio
operator|->
name|bio_flags
operator||=
name|BIO_ERROR
expr_stmt|;
name|bio
operator|->
name|bio_error
operator|=
name|EIO
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"I/O error, status= %d "
literal|"scsi_status= %d\n"
argument_list|,
name|hdr
operator|->
name|cmd_status
argument_list|,
name|hdr
operator|->
name|scsi_status
argument_list|)
expr_stmt|;
name|mfi_print_sense
argument_list|(
name|cm
operator|->
name|cm_sc
argument_list|,
name|cm
operator|->
name|cm_sense
argument_list|)
expr_stmt|;
block|}
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|mfi_disk_complete
argument_list|(
name|bio
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mfi_startio
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mfi_command
modifier|*
name|cm
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Don't bother if we're short on resources */
if|if
condition|(
name|sc
operator|->
name|mfi_flags
operator|&
name|MFI_FLAGS_QFRZN
condition|)
break|break;
comment|/* Try a command that has already been prepared */
name|cm
operator|=
name|mfi_dequeue_ready
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Nope, so look for work on the bioq */
if|if
condition|(
name|cm
operator|==
name|NULL
condition|)
name|cm
operator|=
name|mfi_bio_command
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* No work available, so exit */
if|if
condition|(
name|cm
operator|==
name|NULL
condition|)
break|break;
comment|/* Send the command to the controller */
if|if
condition|(
name|mfi_mapcmd
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mfi_requeue_ready
argument_list|(
name|cm
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_mapcmd
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mfi_command
modifier|*
name|cm
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|polled
decl_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_data
operator|!=
name|NULL
condition|)
block|{
name|polled
operator|=
operator|(
name|cm
operator|->
name|cm_flags
operator|&
name|MFI_CMD_POLLED
operator|)
condition|?
name|BUS_DMA_NOWAIT
else|:
literal|0
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|,
name|cm
operator|->
name|cm_data
argument_list|,
name|cm
operator|->
name|cm_len
argument_list|,
name|mfi_data_cb
argument_list|,
name|cm
argument_list|,
name|polled
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINPROGRESS
condition|)
block|{
name|sc
operator|->
name|mfi_flags
operator||=
name|MFI_FLAGS_QFRZN
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
else|else
block|{
name|mfi_enqueue_busy
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|error
operator|=
name|mfi_send_frame
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mfi_data_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|mfi_frame_header
modifier|*
name|hdr
decl_stmt|;
name|struct
name|mfi_command
modifier|*
name|cm
decl_stmt|;
name|union
name|mfi_sgl
modifier|*
name|sgl
decl_stmt|;
name|struct
name|mfi_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|dir
decl_stmt|;
if|if
condition|(
name|error
condition|)
return|return;
name|cm
operator|=
operator|(
expr|struct
name|mfi_command
operator|*
operator|)
name|arg
expr_stmt|;
name|sc
operator|=
name|cm
operator|->
name|cm_sc
expr_stmt|;
name|hdr
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|header
expr_stmt|;
name|sgl
operator|=
name|cm
operator|->
name|cm_sg
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|mfi_flags
operator|&
name|MFI_FLAGS_SG64
operator|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsegs
condition|;
name|i
operator|++
control|)
block|{
name|sgl
operator|->
name|sg32
index|[
name|i
index|]
operator|.
name|addr
operator|=
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
expr_stmt|;
name|sgl
operator|->
name|sg32
index|[
name|i
index|]
operator|.
name|len
operator|=
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsegs
condition|;
name|i
operator|++
control|)
block|{
name|sgl
operator|->
name|sg64
index|[
name|i
index|]
operator|.
name|addr
operator|=
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
expr_stmt|;
name|sgl
operator|->
name|sg64
index|[
name|i
index|]
operator|.
name|len
operator|=
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
expr_stmt|;
block|}
name|hdr
operator|->
name|flags
operator||=
name|MFI_FRAME_SGL64
expr_stmt|;
block|}
name|hdr
operator|->
name|sg_count
operator|=
name|nsegs
expr_stmt|;
name|dir
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|MFI_CMD_DATAIN
condition|)
block|{
name|dir
operator||=
name|BUS_DMASYNC_PREREAD
expr_stmt|;
name|hdr
operator|->
name|flags
operator||=
name|MFI_FRAME_DIR_READ
expr_stmt|;
block|}
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|MFI_CMD_DATAOUT
condition|)
block|{
name|dir
operator||=
name|BUS_DMASYNC_PREWRITE
expr_stmt|;
name|hdr
operator|->
name|flags
operator||=
name|MFI_FRAME_DIR_WRITE
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator||=
name|MFI_CMD_MAPPED
expr_stmt|;
comment|/* 	 * Instead of calculating the total number of frames in the 	 * compound frame, it's already assumed that there will be at 	 * least 1 frame, so don't compensate for the modulo of the 	 * following division. 	 */
name|cm
operator|->
name|cm_total_frame_size
operator|+=
operator|(
name|sc
operator|->
name|mfi_sgsize
operator|*
name|nsegs
operator|)
expr_stmt|;
name|cm
operator|->
name|cm_extra_frames
operator|=
operator|(
name|cm
operator|->
name|cm_total_frame_size
operator|-
literal|1
operator|)
operator|/
name|MFI_FRAME_SIZE
expr_stmt|;
comment|/* The caller will take care of delivering polled commands */
if|if
condition|(
operator|(
name|cm
operator|->
name|cm_flags
operator|&
name|MFI_CMD_POLLED
operator|)
operator|==
literal|0
condition|)
block|{
name|mfi_enqueue_busy
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|mfi_send_frame
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_send_frame
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mfi_command
modifier|*
name|cm
parameter_list|)
block|{
comment|/* 	 * The bus address of the command is aligned on a 64 byte boundary, 	 * leaving the least 6 bits as zero.  For whatever reason, the 	 * hardware wants the address shifted right by three, leaving just 	 * 3 zero bits.  These three bits are then used to indicate how many 	 * 64 byte frames beyond the first one are used in the command.  The 	 * extra frames are typically filled with S/G elements.  The extra 	 * frames must also be contiguous.  Thus, a compound frame can be at 	 * most 512 bytes long, allowing for up to 59 32-bit S/G elements or 	 * 39 64-bit S/G elements for block I/O commands.  This means that 	 * I/O transfers of 256k and higher simply are not possible, which 	 * is quite odd for such a modern adapter. 	 */
name|MFI_WRITE4
argument_list|(
name|sc
argument_list|,
name|MFI_IQP
argument_list|,
operator|(
name|cm
operator|->
name|cm_frame_busaddr
operator|>>
literal|3
operator|)
operator||
name|cm
operator|->
name|cm_extra_frames
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mfi_complete
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mfi_command
modifier|*
name|cm
parameter_list|)
block|{
name|int
name|dir
decl_stmt|;
if|if
condition|(
operator|(
name|cm
operator|->
name|cm_flags
operator|&
name|MFI_CMD_MAPPED
operator|)
operator|!=
literal|0
condition|)
block|{
name|dir
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|MFI_CMD_DATAIN
condition|)
name|dir
operator||=
name|BUS_DMASYNC_POSTREAD
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|MFI_CMD_DATAOUT
condition|)
name|dir
operator||=
name|BUS_DMASYNC_POSTWRITE
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator|&=
operator|~
name|MFI_CMD_MAPPED
expr_stmt|;
block|}
if|if
condition|(
name|cm
operator|->
name|cm_complete
operator|!=
name|NULL
condition|)
name|cm
operator|->
name|cm_complete
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mfi_flags
operator|&=
operator|~
name|MFI_FLAGS_QFRZN
expr_stmt|;
name|mfi_startio
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_abort
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mfi_command
modifier|*
name|cm_abort
parameter_list|)
block|{
name|struct
name|mfi_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|mfi_abort_frame
modifier|*
name|abort
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|=
name|mfi_dequeue_free
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|abort
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|abort
expr_stmt|;
name|abort
operator|->
name|header
operator|.
name|cmd
operator|=
name|MFI_CMD_ABORT
expr_stmt|;
name|abort
operator|->
name|header
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|abort
operator|->
name|abort_context
operator|=
name|cm_abort
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|context
expr_stmt|;
name|abort
operator|->
name|abort_mfi_addr_lo
operator|=
name|cm_abort
operator|->
name|cm_frame_busaddr
expr_stmt|;
name|abort
operator|->
name|abort_mfi_addr_hi
operator|=
literal|0
expr_stmt|;
name|cm
operator|->
name|cm_data
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|mfi_aen_cm
operator|->
name|cm_aen_abort
operator|=
literal|1
expr_stmt|;
name|mfi_mapcmd
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
name|mfi_polled_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|mfi_aen_cm
operator|!=
name|NULL
condition|)
block|{
name|tsleep
argument_list|(
operator|&
name|sc
operator|->
name|mfi_aen_cm
argument_list|,
literal|0
argument_list|,
literal|"mfiabort"
argument_list|,
literal|5
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mfi_dump_blocks
parameter_list|(
name|struct
name|mfi_softc
modifier|*
name|sc
parameter_list|,
name|int
name|id
parameter_list|,
name|uint64_t
name|lba
parameter_list|,
name|void
modifier|*
name|virt
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|mfi_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|mfi_io_frame
modifier|*
name|io
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|cm
operator|=
name|mfi_dequeue_free
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|io
operator|=
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|io
expr_stmt|;
name|io
operator|->
name|header
operator|.
name|cmd
operator|=
name|MFI_CMD_LD_WRITE
expr_stmt|;
name|io
operator|->
name|header
operator|.
name|target_id
operator|=
name|id
expr_stmt|;
name|io
operator|->
name|header
operator|.
name|timeout
operator|=
literal|0
expr_stmt|;
name|io
operator|->
name|header
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|io
operator|->
name|header
operator|.
name|sense_len
operator|=
name|MFI_SENSE_LEN
expr_stmt|;
name|io
operator|->
name|header
operator|.
name|data_len
operator|=
operator|(
name|len
operator|+
name|MFI_SECTOR_LEN
operator|-
literal|1
operator|)
operator|/
name|MFI_SECTOR_LEN
expr_stmt|;
name|io
operator|->
name|sense_addr_lo
operator|=
name|cm
operator|->
name|cm_sense_busaddr
expr_stmt|;
name|io
operator|->
name|sense_addr_hi
operator|=
literal|0
expr_stmt|;
name|io
operator|->
name|lba_hi
operator|=
operator|(
name|lba
operator|&
literal|0xffffffff00000000
operator|)
operator|>>
literal|32
expr_stmt|;
name|io
operator|->
name|lba_lo
operator|=
name|lba
operator|&
literal|0xffffffff
expr_stmt|;
name|cm
operator|->
name|cm_data
operator|=
name|virt
expr_stmt|;
name|cm
operator|->
name|cm_len
operator|=
name|len
expr_stmt|;
name|cm
operator|->
name|cm_sg
operator|=
operator|&
name|io
operator|->
name|sgl
expr_stmt|;
name|cm
operator|->
name|cm_total_frame_size
operator|=
name|MFI_IO_FRAME_SIZE
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator|=
name|MFI_CMD_POLLED
operator||
name|MFI_CMD_DATAOUT
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|mfi_mapcmd
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|mfi_polled_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|)
expr_stmt|;
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|d_thread_t
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|mfi_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|sc
operator|->
name|mfi_flags
operator||=
name|MFI_FLAGS_OPEN
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|d_thread_t
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|mfi_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mfi_aen
modifier|*
name|mfi_aen_entry
decl_stmt|;
name|sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|sc
operator|->
name|mfi_flags
operator|&=
operator|~
name|MFI_FLAGS_OPEN
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|mfi_aen_entry
argument_list|,
argument|&sc->mfi_aen_pids
argument_list|,
argument|aen_link
argument_list|)
block|{
if|if
condition|(
name|mfi_aen_entry
operator|->
name|p
operator|==
name|curproc
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|mfi_aen_pids
argument_list|,
name|mfi_aen_entry
argument_list|,
name|aen_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"REMOVED pid %d\n"
argument_list|,
name|mfi_aen_entry
operator|->
name|p
operator|->
name|p_pid
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mfi_aen_entry
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|int
name|flag
parameter_list|,
name|d_thread_t
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|mfi_softc
modifier|*
name|sc
decl_stmt|;
name|union
name|mfi_statrequest
modifier|*
name|ms
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MFIIO_STATS
case|:
name|ms
operator|=
operator|(
expr|union
name|mfi_statrequest
operator|*
operator|)
name|arg
expr_stmt|;
switch|switch
condition|(
name|ms
operator|->
name|ms_item
condition|)
block|{
case|case
name|MFIQ_FREE
case|:
case|case
name|MFIQ_BIO
case|:
case|case
name|MFIQ_READY
case|:
case|case
name|MFIQ_BUSY
case|:
name|bcopy
argument_list|(
operator|&
name|sc
operator|->
name|mfi_qstat
index|[
name|ms
operator|->
name|ms_item
index|]
argument_list|,
operator|&
name|ms
operator|->
name|ms_qstat
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mfi_qstat
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ENOIOCTL
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|0xc1144d01
case|:
comment|/* Firmware Linux ioctl shim */
block|{
name|devclass_t
name|devclass
decl_stmt|;
name|struct
name|mfi_linux_ioc_packet
name|l_ioc
decl_stmt|;
name|int
name|adapter
decl_stmt|;
name|devclass
operator|=
name|devclass_find
argument_list|(
literal|"mfi"
argument_list|)
expr_stmt|;
if|if
condition|(
name|devclass
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|error
operator|=
name|copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|l_ioc
argument_list|,
sizeof|sizeof
argument_list|(
name|l_ioc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|adapter
operator|=
name|l_ioc
operator|.
name|lioc_adapter_no
expr_stmt|;
name|sc
operator|=
name|devclass_get_softc
argument_list|(
name|devclass
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
return|return
operator|(
name|mfi_linux_ioctl_int
argument_list|(
name|sc
operator|->
name|mfi_cdev
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|,
name|flag
argument_list|,
name|td
argument_list|)
operator|)
return|;
break|break;
block|}
case|case
literal|0x400c4d03
case|:
comment|/* AEN Linux ioctl shim */
block|{
name|devclass_t
name|devclass
decl_stmt|;
name|struct
name|mfi_linux_ioc_aen
name|l_aen
decl_stmt|;
name|int
name|adapter
decl_stmt|;
name|devclass
operator|=
name|devclass_find
argument_list|(
literal|"mfi"
argument_list|)
expr_stmt|;
if|if
condition|(
name|devclass
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|error
operator|=
name|copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|l_aen
argument_list|,
sizeof|sizeof
argument_list|(
name|l_aen
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|adapter
operator|=
name|l_aen
operator|.
name|laen_adapter_no
expr_stmt|;
name|sc
operator|=
name|devclass_get_softc
argument_list|(
name|devclass
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
return|return
operator|(
name|mfi_linux_ioctl_int
argument_list|(
name|sc
operator|->
name|mfi_cdev
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|,
name|flag
argument_list|,
name|td
argument_list|)
operator|)
return|;
break|break;
block|}
default|default:
name|error
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_linux_ioctl_int
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|int
name|flag
parameter_list|,
name|d_thread_t
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|mfi_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mfi_linux_ioc_packet
name|l_ioc
decl_stmt|;
name|struct
name|mfi_linux_ioc_aen
name|l_aen
decl_stmt|;
name|struct
name|mfi_command
modifier|*
name|cm
init|=
name|NULL
decl_stmt|;
name|struct
name|mfi_aen
modifier|*
name|mfi_aen_entry
decl_stmt|;
name|uint32_t
modifier|*
name|sense_ptr
decl_stmt|;
name|uint32_t
name|context
decl_stmt|;
name|uint8_t
modifier|*
name|data
init|=
name|NULL
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
literal|0xc1144d01
case|:
comment|/* Firmware Linux ioctl shim */
name|error
operator|=
name|copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|l_ioc
argument_list|,
sizeof|sizeof
argument_list|(
name|l_ioc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|l_ioc
operator|.
name|lioc_sge_count
operator|>
name|MAX_LINUX_IOCTL_SGE
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|=
name|mfi_dequeue_free
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
comment|/* 		 * save off original context since copying from user 		 * will clobber some data 		 */
name|context
operator|=
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|context
expr_stmt|;
name|bcopy
argument_list|(
name|l_ioc
operator|.
name|lioc_frame
operator|.
name|raw
argument_list|,
name|cm
operator|->
name|cm_frame
argument_list|,
name|l_ioc
operator|.
name|lioc_sgl_off
argument_list|)
expr_stmt|;
comment|/* Linux can do 2 frames ? */
name|cm
operator|->
name|cm_total_frame_size
operator|=
name|l_ioc
operator|.
name|lioc_sgl_off
expr_stmt|;
name|cm
operator|->
name|cm_sg
operator|=
operator|(
expr|union
name|mfi_sgl
operator|*
operator|)
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|bytes
index|[
name|l_ioc
operator|.
name|lioc_sgl_off
index|]
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator|=
name|MFI_CMD_DATAIN
operator||
name|MFI_CMD_DATAOUT
operator||
name|MFI_CMD_POLLED
expr_stmt|;
name|cm
operator|->
name|cm_len
operator|=
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|data_len
expr_stmt|;
name|cm
operator|->
name|cm_data
operator|=
name|data
operator|=
name|malloc
argument_list|(
name|cm
operator|->
name|cm_len
argument_list|,
name|M_MFIBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
comment|/* restore header context */
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|context
operator|=
name|context
expr_stmt|;
name|temp
operator|=
name|data
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l_ioc
operator|.
name|lioc_sge_count
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|copyin
argument_list|(
name|l_ioc
operator|.
name|lioc_sgl
index|[
name|i
index|]
operator|.
name|iov_base
argument_list|,
name|temp
argument_list|,
name|l_ioc
operator|.
name|lioc_sgl
index|[
name|i
index|]
operator|.
name|iov_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Copy in failed"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|temp
operator|=
operator|&
name|temp
index|[
name|l_ioc
operator|.
name|lioc_sgl
index|[
name|i
index|]
operator|.
name|iov_len
index|]
expr_stmt|;
block|}
if|if
condition|(
name|l_ioc
operator|.
name|lioc_sense_len
condition|)
block|{
name|sense_ptr
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|bytes
index|[
name|l_ioc
operator|.
name|lioc_sense_off
index|]
expr_stmt|;
operator|*
name|sense_ptr
operator|=
name|cm
operator|->
name|cm_sense_busaddr
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|mfi_mapcmd
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Controller info buffer map failed"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|mfi_polled_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Controller polled failed"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|mfi_buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|)
expr_stmt|;
name|temp
operator|=
name|data
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l_ioc
operator|.
name|lioc_sge_count
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|copyout
argument_list|(
name|temp
argument_list|,
name|l_ioc
operator|.
name|lioc_sgl
index|[
name|i
index|]
operator|.
name|iov_base
argument_list|,
name|l_ioc
operator|.
name|lioc_sgl
index|[
name|i
index|]
operator|.
name|iov_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Copy out failed"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|temp
operator|=
operator|&
name|temp
index|[
name|l_ioc
operator|.
name|lioc_sgl
index|[
name|i
index|]
operator|.
name|iov_len
index|]
expr_stmt|;
block|}
if|if
condition|(
name|l_ioc
operator|.
name|lioc_sense_len
condition|)
block|{
comment|/* copy out sense */
name|sense_ptr
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|l_ioc
operator|.
name|lioc_frame
operator|.
name|raw
index|[
name|l_ioc
operator|.
name|lioc_sense_off
index|]
expr_stmt|;
name|temp
operator|=
literal|0
expr_stmt|;
name|temp
operator|+=
name|cm
operator|->
name|cm_sense_busaddr
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
name|temp
argument_list|,
name|sense_ptr
argument_list|,
name|l_ioc
operator|.
name|lioc_sense_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Copy out failed"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|cm
operator|->
name|cm_frame
operator|->
name|header
operator|.
name|cmd_status
argument_list|,
operator|&
operator|(
operator|(
expr|struct
name|mfi_linux_ioc_packet
operator|*
operator|)
name|arg
operator|)
operator|->
name|lioc_frame
operator|.
name|hdr
operator|.
name|cmd_status
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"Copy out failed"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|out
label|:
if|if
condition|(
name|data
condition|)
name|free
argument_list|(
name|data
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
name|mfi_release_command
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mfi_io_lock
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
case|case
literal|0x400c4d03
case|:
comment|/* AEN Linux ioctl shim */
name|error
operator|=
name|copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|l_aen
argument_list|,
sizeof|sizeof
argument_list|(
name|l_aen
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|printf
argument_list|(
literal|"AEN IMPLEMENTED for pid %d\n"
argument_list|,
name|curproc
operator|->
name|p_pid
argument_list|)
expr_stmt|;
name|mfi_aen_entry
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mfi_aen
argument_list|)
argument_list|,
name|M_MFIBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|mfi_aen_entry
operator|!=
name|NULL
condition|)
block|{
name|mfi_aen_entry
operator|->
name|p
operator|=
name|curproc
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|mfi_aen_pids
argument_list|,
name|mfi_aen_entry
argument_list|,
name|aen_link
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|mfi_aen_register
argument_list|(
name|sc
argument_list|,
name|l_aen
operator|.
name|laen_seq_num
argument_list|,
name|l_aen
operator|.
name|laen_class_locale
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|mfi_aen_pids
argument_list|,
name|mfi_aen_entry
argument_list|,
name|aen_link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mfi_aen_entry
argument_list|,
name|M_MFIBUF
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|mfi_dev
argument_list|,
literal|"IOCTL 0x%lx not handled\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_poll
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|poll_events
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|mfi_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|revents
init|=
literal|0
decl_stmt|;
name|sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|printf
argument_list|(
literal|"MFI POLL\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|poll_events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|mfi_aen_triggered
operator|!=
literal|0
condition|)
name|revents
operator||=
name|poll_events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mfi_aen_triggered
operator|==
literal|0
operator|&&
name|sc
operator|->
name|mfi_aen_cm
operator|==
name|NULL
condition|)
block|{
name|revents
operator||=
name|POLLERR
expr_stmt|;
block|}
block|}
if|if
condition|(
name|revents
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|poll_events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
condition|)
block|{
name|sc
operator|->
name|mfi_poll_waiting
operator|=
literal|1
expr_stmt|;
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|sc
operator|->
name|mfi_select
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mfi_poll_waiting
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|revents
return|;
block|}
end_function

end_unit

