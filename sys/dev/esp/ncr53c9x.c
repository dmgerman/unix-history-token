begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2004 Scott Long  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_comment
comment|/*	$NetBSD: ncr53c9x.c,v 1.114 2005/02/27 00:27:02 perry Exp $	*/
end_comment

begin_comment
comment|/*-  * Copyright (c) 1998, 2002 The NetBSD Foundation, Inc.  * All rights reserved.  *  * This code is derived from software contributed to The NetBSD Foundation  * by Charles M. Hannum.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *        This product includes software developed by the NetBSD  *        Foundation, Inc. and its contributors.  * 4. Neither the name of The NetBSD Foundation nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 1994 Peter Galbavy  * Copyright (c) 1995 Paul Kranenburg  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Peter Galbavy  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Based on aic6360 by Jarle Greipsland  *  * Acknowledgements: Many of the algorithms used in this driver are  * inspired by the work of Julian Elischer (julian@FreeBSD.org) and  * Charles Hannum (mycroft@duality.gnu.ai.mit.edu).  Thanks a million!  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_include
include|#
directive|include
file|<dev/esp/ncr53c9xreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/esp/ncr53c9xvar.h>
end_include

begin_decl_stmt
name|int
name|ncr53c9x_debug
init|=
name|NCR_SHOWMISC
comment|/*|NCR_SHOWPHASE|NCR_SHOWTRAC|NCR_SHOWCMDS*/
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|int
name|ncr53c9x_notag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|ncr53c9x_select
parameter_list|(
name|struct
name|ncr53c9x_softc
modifier|*
parameter_list|,
name|struct
name|ncr53c9x_ecb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ncr53c9x_reselect
parameter_list|(
name|struct
name|ncr53c9x_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncr53c9x_scsi_reset
parameter_list|(
name|struct
name|ncr53c9x_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncr53c9x_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncr53c9x_sched
parameter_list|(
name|struct
name|ncr53c9x_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncr53c9x_done
parameter_list|(
name|struct
name|ncr53c9x_softc
modifier|*
parameter_list|,
name|struct
name|ncr53c9x_ecb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncr53c9x_msgin
parameter_list|(
name|struct
name|ncr53c9x_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncr53c9x_msgout
parameter_list|(
name|struct
name|ncr53c9x_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncr53c9x_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncr53c9x_watch
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncr53c9x_abort
parameter_list|(
name|struct
name|ncr53c9x_softc
modifier|*
parameter_list|,
name|struct
name|ncr53c9x_ecb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncr53c9x_dequeue
parameter_list|(
name|struct
name|ncr53c9x_softc
modifier|*
parameter_list|,
name|struct
name|ncr53c9x_ecb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncr53c9x_sense
parameter_list|(
name|struct
name|ncr53c9x_softc
modifier|*
parameter_list|,
name|struct
name|ncr53c9x_ecb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncr53c9x_free_ecb
parameter_list|(
name|struct
name|ncr53c9x_softc
modifier|*
parameter_list|,
name|struct
name|ncr53c9x_ecb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncr53c9x_wrfifo
parameter_list|(
name|struct
name|ncr53c9x_softc
modifier|*
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ncr53c9x_rdfifo
parameter_list|(
name|struct
name|ncr53c9x_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ncr53c9x_ecb
modifier|*
name|ncr53c9x_get_ecb
parameter_list|(
name|struct
name|ncr53c9x_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ncr53c9x_linfo
modifier|*
name|ncr53c9x_lunsearch
parameter_list|(
name|struct
name|ncr53c9x_tinfo
modifier|*
parameter_list|,
name|int64_t
name|lun
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ncr53c9x_readregs
parameter_list|(
name|struct
name|ncr53c9x_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|int
name|ncr53c9x_stp2cpb
parameter_list|(
name|struct
name|ncr53c9x_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ncr53c9x_setsync
parameter_list|(
name|struct
name|ncr53c9x_softc
modifier|*
parameter_list|,
name|struct
name|ncr53c9x_tinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|NCR_RDFIFO_START
value|0
end_define

begin_define
define|#
directive|define
name|NCR_RDFIFO_CONTINUE
value|1
end_define

begin_define
define|#
directive|define
name|NCR_SET_COUNT
parameter_list|(
name|sc
parameter_list|,
name|size
parameter_list|)
value|do { \ 		NCR_WRITE_REG((sc), NCR_TCL, (size)); 			\ 		NCR_WRITE_REG((sc), NCR_TCM, (size)>> 8);		\ 		if ((sc->sc_cfg2& NCRCFG2_FE) || 			\ 		    (sc->sc_rev == NCR_VARIANT_FAS366)) {		\ 			NCR_WRITE_REG((sc), NCR_TCH, (size)>> 16);	\ 		}							\ 		if (sc->sc_rev == NCR_VARIANT_FAS366) {			\ 			NCR_WRITE_REG(sc, NCR_RCH, 0);			\ 		}							\ } while (0)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|mstohz
end_ifndef

begin_define
define|#
directive|define
name|mstohz
parameter_list|(
name|ms
parameter_list|)
define|\
value|(((ms)< 0x20000)  ? \ 	    ((ms +0u) / 1000u) * hz : \ 	    ((ms +0u) * hz) /1000u)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Names for the NCR53c9x variants, corresponding to the variant tags  * in ncr53c9xvar.h.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ncr53c9x_variant_names
index|[]
init|=
block|{
literal|"ESP100"
block|,
literal|"ESP100A"
block|,
literal|"ESP200"
block|,
literal|"NCR53C94"
block|,
literal|"NCR53C96"
block|,
literal|"ESP406"
block|,
literal|"FAS408"
block|,
literal|"FAS216"
block|,
literal|"AM53C974"
block|,
literal|"FAS366/HME"
block|,
literal|"NCR53C90 (86C01)"
block|,
literal|"FAS100A"
block|,
literal|"FAS236"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Search linked list for LUN info by LUN id.  */
end_comment

begin_function
specifier|static
name|struct
name|ncr53c9x_linfo
modifier|*
name|ncr53c9x_lunsearch
parameter_list|(
name|struct
name|ncr53c9x_tinfo
modifier|*
name|ti
parameter_list|,
name|int64_t
name|lun
parameter_list|)
block|{
name|struct
name|ncr53c9x_linfo
modifier|*
name|li
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|li
argument_list|,
argument|&ti->luns
argument_list|,
argument|link
argument_list|)
if|if
condition|(
name|li
operator|->
name|lun
operator|==
name|lun
condition|)
return|return
operator|(
name|li
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attach this instance, and then all the sub-devices.  */
end_comment

begin_function
name|int
name|ncr53c9x_attach
parameter_list|(
name|struct
name|ncr53c9x_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|struct
name|ncr53c9x_ecb
modifier|*
name|ecb
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
literal|"ncr"
argument_list|,
literal|"ncr53c9x lock"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* 	 * Note, the front-end has set us up to print the chip variation. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_rev
operator|>=
name|NCR_VARIANT_MAX
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unknown variant %d, devices not "
literal|"attached\n"
argument_list|,
name|sc
operator|->
name|sc_rev
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s, %dMHz, SCSI ID %d\n"
argument_list|,
name|ncr53c9x_variant_names
index|[
name|sc
operator|->
name|sc_rev
index|]
argument_list|,
name|sc
operator|->
name|sc_freq
argument_list|,
name|sc
operator|->
name|sc_id
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ntarg
operator|=
operator|(
name|sc
operator|->
name|sc_rev
operator|==
name|NCR_VARIANT_FAS366
operator|)
condition|?
literal|16
else|:
literal|8
expr_stmt|;
comment|/* 	 * Allocate SCSI message buffers. 	 * Front-ends can override allocation to avoid alignment 	 * handling in the DMA engines. Note that that ncr53c9x_msgout() 	 * can request a 1 byte DMA transfer. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_omess
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|sc_omess_self
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_omess
operator|=
name|malloc
argument_list|(
name|NCR_MAX_MSG_LEN
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_omess
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot allocate MSGOUT buffer\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
block|}
else|else
name|sc
operator|->
name|sc_omess_self
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_imess
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|sc_imess_self
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_imess
operator|=
name|malloc
argument_list|(
name|NCR_MAX_MSG_LEN
operator|+
literal|1
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_imess
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot allocate MSGIN buffer\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail_omess
goto|;
block|}
block|}
else|else
name|sc
operator|->
name|sc_imess_self
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_tinfo
operator|=
name|malloc
argument_list|(
name|sc
operator|->
name|sc_ntarg
operator|*
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_tinfo
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_tinfo
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot allocate target info buffer\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail_imess
goto|;
block|}
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_watchdog
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Treat NCR53C90 with the 86C01 DMA chip exactly as ESP100 	 * from now on. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_rev
operator|==
name|NCR_VARIANT_NCR53C90_86C01
condition|)
name|sc
operator|->
name|sc_rev
operator|=
name|NCR_VARIANT_ESP100
expr_stmt|;
name|sc
operator|->
name|sc_ccf
operator|=
name|FREQTOCCF
argument_list|(
name|sc
operator|->
name|sc_freq
argument_list|)
expr_stmt|;
comment|/* The value *must not* be == 1. Make it 2 */
if|if
condition|(
name|sc
operator|->
name|sc_ccf
operator|==
literal|1
condition|)
name|sc
operator|->
name|sc_ccf
operator|=
literal|2
expr_stmt|;
comment|/* 	 * The recommended timeout is 250ms. This register is loaded 	 * with a value calculated as follows, from the docs: 	 * 	 *		(timout period) x (CLK frequency) 	 *	reg = ------------------------------------- 	 *		 8192 x (Clock Conversion Factor) 	 * 	 * Since CCF has a linear relation to CLK, this generally computes 	 * to the constant of 153. 	 */
name|sc
operator|->
name|sc_timeout
operator|=
operator|(
operator|(
literal|250
operator|*
literal|1000
operator|)
operator|*
name|sc
operator|->
name|sc_freq
operator|)
operator|/
operator|(
literal|8192
operator|*
name|sc
operator|->
name|sc_ccf
operator|)
expr_stmt|;
comment|/* CCF register only has 3 bits; 0 is actually 8 */
name|sc
operator|->
name|sc_ccf
operator|&=
literal|7
expr_stmt|;
comment|/* 	 * Register with CAM 	 */
name|devq
operator|=
name|cam_simq_alloc
argument_list|(
name|sc
operator|->
name|sc_ntarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|devq
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot allocate device queue\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail_tinfo
goto|;
block|}
name|sim
operator|=
name|cam_sim_alloc
argument_list|(
name|ncr53c9x_action
argument_list|,
name|ncr53c9x_poll
argument_list|,
literal|"esp"
argument_list|,
name|sc
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
operator|&
name|Giant
argument_list|,
literal|1
argument_list|,
name|NCR_TAG_DEPTH
argument_list|,
name|devq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sim
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot allocate SIM entry\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail_devq
goto|;
block|}
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|sim
argument_list|,
literal|0
argument_list|)
operator|!=
name|CAM_SUCCESS
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot register bus\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|fail_sim
goto|;
block|}
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|sim
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot create path\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|fail_bus
goto|;
block|}
name|sc
operator|->
name|sc_sim
operator|=
name|sim
expr_stmt|;
name|sc
operator|->
name|sc_path
operator|=
name|path
expr_stmt|;
comment|/* Reset state& bus */
if|#
directive|if
literal|0
block|sc->sc_cfflags = sc->sc_dev.dv_cfdata->cf_flags;
endif|#
directive|endif
name|sc
operator|->
name|sc_state
operator|=
literal|0
expr_stmt|;
name|ncr53c9x_init
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|free_list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|ecb_array
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ncr53c9x_ecb
argument_list|)
operator|*
name|NCR_TAG_DEPTH
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot allocate ECB array\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail_path
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCR_TAG_DEPTH
condition|;
name|i
operator|++
control|)
block|{
name|ecb
operator|=
operator|&
name|sc
operator|->
name|ecb_array
index|[
name|i
index|]
expr_stmt|;
name|ecb
operator|->
name|sc
operator|=
name|sc
expr_stmt|;
name|ecb
operator|->
name|tag_id
operator|=
name|i
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|free_list
argument_list|,
name|ecb
argument_list|,
name|free_links
argument_list|)
expr_stmt|;
block|}
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_watchdog
argument_list|,
literal|60
operator|*
name|hz
argument_list|,
name|ncr53c9x_watch
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail_path
label|:
name|xpt_free_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|fail_bus
label|:
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|sim
argument_list|)
argument_list|)
expr_stmt|;
name|fail_sim
label|:
name|cam_sim_free
argument_list|(
name|sim
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|fail_devq
label|:
name|cam_simq_free
argument_list|(
name|devq
argument_list|)
expr_stmt|;
name|fail_tinfo
label|:
name|free
argument_list|(
name|sc
operator|->
name|sc_tinfo
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|fail_imess
label|:
if|if
condition|(
name|sc
operator|->
name|sc_imess_self
condition|)
name|free
argument_list|(
name|sc
operator|->
name|sc_imess
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|fail_omess
label|:
if|if
condition|(
name|sc
operator|->
name|sc_omess_self
condition|)
name|free
argument_list|(
name|sc
operator|->
name|sc_omess
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ncr53c9x_detach
parameter_list|(
name|struct
name|ncr53c9x_softc
modifier|*
name|sc
parameter_list|)
block|{
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|sc_watchdog
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|ncr53c9x_init
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|sc
operator|->
name|sc_path
argument_list|)
expr_stmt|;
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|sc
operator|->
name|sc_sim
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|sc
operator|->
name|sc_sim
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|ecb_array
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|sc_tinfo
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_imess_self
condition|)
name|free
argument_list|(
name|sc
operator|->
name|sc_imess
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_omess_self
condition|)
name|free
argument_list|(
name|sc
operator|->
name|sc_omess
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is the generic ncr53c9x reset function. It does not reset the SCSI bus,  * only this controller, but kills any on-going commands, and also stops  * and resets the DMA.  *  * After reset, registers are loaded with the defaults from the attach  * routine above.  */
end_comment

begin_function
name|void
name|ncr53c9x_reset
parameter_list|(
name|struct
name|ncr53c9x_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* reset DMA first */
name|NCRDMA_RESET
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* reset SCSI chip */
name|NCRCMD
argument_list|(
name|sc
argument_list|,
name|NCRCMD_RSTCHIP
argument_list|)
expr_stmt|;
name|NCRCMD
argument_list|(
name|sc
argument_list|,
name|NCRCMD_NOP
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|500
argument_list|)
expr_stmt|;
comment|/* do these backwards, and fall through */
switch|switch
condition|(
name|sc
operator|->
name|sc_rev
condition|)
block|{
case|case
name|NCR_VARIANT_ESP406
case|:
case|case
name|NCR_VARIANT_FAS408
case|:
name|NCR_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|NCR_CFG5
argument_list|,
name|sc
operator|->
name|sc_cfg5
operator||
name|NCRCFG5_SINT
argument_list|)
expr_stmt|;
name|NCR_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|NCR_CFG4
argument_list|,
name|sc
operator|->
name|sc_cfg4
argument_list|)
expr_stmt|;
case|case
name|NCR_VARIANT_AM53C974
case|:
case|case
name|NCR_VARIANT_FAS100A
case|:
case|case
name|NCR_VARIANT_FAS216
case|:
case|case
name|NCR_VARIANT_FAS236
case|:
case|case
name|NCR_VARIANT_NCR53C94
case|:
case|case
name|NCR_VARIANT_NCR53C96
case|:
case|case
name|NCR_VARIANT_ESP200
case|:
name|sc
operator|->
name|sc_features
operator||=
name|NCR_F_HASCFG3
expr_stmt|;
name|NCR_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|NCR_CFG3
argument_list|,
name|sc
operator|->
name|sc_cfg3
argument_list|)
expr_stmt|;
case|case
name|NCR_VARIANT_ESP100A
case|:
name|sc
operator|->
name|sc_features
operator||=
name|NCR_F_SELATN3
expr_stmt|;
name|NCR_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|NCR_CFG2
argument_list|,
name|sc
operator|->
name|sc_cfg2
argument_list|)
expr_stmt|;
case|case
name|NCR_VARIANT_ESP100
case|:
name|NCR_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|NCR_CFG1
argument_list|,
name|sc
operator|->
name|sc_cfg1
argument_list|)
expr_stmt|;
name|NCR_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|NCR_CCF
argument_list|,
name|sc
operator|->
name|sc_ccf
argument_list|)
expr_stmt|;
name|NCR_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|NCR_SYNCOFF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|NCR_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|NCR_TIMEOUT
argument_list|,
name|sc
operator|->
name|sc_timeout
argument_list|)
expr_stmt|;
break|break;
case|case
name|NCR_VARIANT_FAS366
case|:
name|sc
operator|->
name|sc_features
operator||=
name|NCR_F_HASCFG3
operator||
name|NCR_F_FASTSCSI
operator||
name|NCR_F_SELATN3
expr_stmt|;
name|sc
operator|->
name|sc_cfg3
operator|=
name|NCRFASCFG3_FASTCLK
operator||
name|NCRFASCFG3_OBAUTO
expr_stmt|;
name|sc
operator|->
name|sc_cfg3_fscsi
operator|=
name|NCRFASCFG3_FASTSCSI
expr_stmt|;
name|NCR_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|NCR_CFG3
argument_list|,
name|sc
operator|->
name|sc_cfg3
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_cfg2
operator|=
literal|0
expr_stmt|;
comment|/* NCRCFG2_HMEFE| NCRCFG2_HME32 */
name|NCR_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|NCR_CFG2
argument_list|,
name|sc
operator|->
name|sc_cfg2
argument_list|)
expr_stmt|;
name|NCR_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|NCR_CFG1
argument_list|,
name|sc
operator|->
name|sc_cfg1
argument_list|)
expr_stmt|;
name|NCR_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|NCR_CCF
argument_list|,
name|sc
operator|->
name|sc_ccf
argument_list|)
expr_stmt|;
name|NCR_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|NCR_SYNCOFF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|NCR_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|NCR_TIMEOUT
argument_list|,
name|sc
operator|->
name|sc_timeout
argument_list|)
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unknown revision code, "
literal|"assuming ESP100\n"
argument_list|)
expr_stmt|;
name|NCR_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|NCR_CFG1
argument_list|,
name|sc
operator|->
name|sc_cfg1
argument_list|)
expr_stmt|;
name|NCR_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|NCR_CCF
argument_list|,
name|sc
operator|->
name|sc_ccf
argument_list|)
expr_stmt|;
name|NCR_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|NCR_SYNCOFF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|NCR_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|NCR_TIMEOUT
argument_list|,
name|sc
operator|->
name|sc_timeout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_rev
operator|==
name|NCR_VARIANT_AM53C974
condition|)
name|NCR_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|NCR_AMDCFG4
argument_list|,
name|sc
operator|->
name|sc_cfg4
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|device_printf(sc->sc_dev, "ncr53c9x_reset: revision %d\n", 	       sc->sc_rev); 	device_printf(sc->sc_dev, "ncr53c9x_reset: cfg1 0x%x, cfg2 0x%x, " 	    "cfg3 0x%x, ccf 0x%x, timeout 0x%x\n", 	    sc->sc_cfg1, sc->sc_cfg2, sc->sc_cfg3, sc->sc_ccf, sc->sc_timeout);
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Reset the SCSI bus, but not the chip  */
end_comment

begin_function
specifier|static
name|void
name|ncr53c9x_scsi_reset
parameter_list|(
name|struct
name|ncr53c9x_softc
modifier|*
name|sc
parameter_list|)
block|{
call|(
modifier|*
name|sc
operator|->
name|sc_glue
operator|->
name|gl_dma_stop
call|)
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|NCR_MISC
argument_list|(
operator|(
literal|"%s: resetting SCSI bus\n"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|NCRCMD
argument_list|(
name|sc
argument_list|,
name|NCRCMD_RSTSCSI
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|250000
argument_list|)
expr_stmt|;
comment|/* Give the bus a fighting chance to settle */
block|}
end_function

begin_comment
comment|/*  * Initialize ncr53c9x state machine  */
end_comment

begin_function
name|void
name|ncr53c9x_init
parameter_list|(
name|struct
name|ncr53c9x_softc
modifier|*
name|sc
parameter_list|,
name|int
name|doreset
parameter_list|)
block|{
name|struct
name|ncr53c9x_ecb
modifier|*
name|ecb
decl_stmt|;
name|struct
name|ncr53c9x_linfo
modifier|*
name|li
decl_stmt|;
name|int
name|i
decl_stmt|,
name|r
decl_stmt|;
name|NCR_MISC
argument_list|(
operator|(
literal|"[NCR_INIT(%d) %d] "
operator|,
name|doreset
operator|,
name|sc
operator|->
name|sc_state
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
literal|0
condition|)
block|{
comment|/* First time through; initialize. */
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|ready_list
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_nexus
operator|=
name|NULL
expr_stmt|;
name|memset
argument_list|(
name|sc
operator|->
name|sc_tinfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_tinfo
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|sc
operator|->
name|sc_ntarg
condition|;
name|r
operator|++
control|)
block|{
name|LIST_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_tinfo
index|[
name|r
index|]
operator|.
name|luns
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Cancel any active commands. */
name|sc
operator|->
name|sc_state
operator|=
name|NCR_CLEANING
expr_stmt|;
name|sc
operator|->
name|sc_msgify
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ecb
operator|=
name|sc
operator|->
name|sc_nexus
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ecb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_CMD_TIMEOUT
expr_stmt|;
name|ncr53c9x_done
argument_list|(
name|sc
argument_list|,
name|ecb
argument_list|)
expr_stmt|;
block|}
comment|/* Cancel outstanding disconnected commands on each LUN */
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|sc
operator|->
name|sc_ntarg
condition|;
name|r
operator|++
control|)
block|{
name|LIST_FOREACH
argument_list|(
argument|li
argument_list|,
argument|&sc->sc_tinfo[r].luns
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
operator|(
name|ecb
operator|=
name|li
operator|->
name|untagged
operator|)
operator|!=
name|NULL
condition|)
block|{
name|li
operator|->
name|untagged
operator|=
name|NULL
expr_stmt|;
comment|/* 					 * XXXXXXX 					 * 					 * Should we terminate a command 					 * that never reached the disk? 					 */
name|li
operator|->
name|busy
operator|=
literal|0
expr_stmt|;
name|ecb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_CMD_TIMEOUT
expr_stmt|;
name|ncr53c9x_done
argument_list|(
name|sc
argument_list|,
name|ecb
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|ecb
operator|=
name|li
operator|->
name|queued
index|[
name|i
index|]
operator|)
condition|)
block|{
name|li
operator|->
name|queued
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|ecb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_CMD_TIMEOUT
expr_stmt|;
name|ncr53c9x_done
argument_list|(
name|sc
argument_list|,
name|ecb
argument_list|)
expr_stmt|;
block|}
name|li
operator|->
name|used
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * reset the chip to a known state 	 */
name|ncr53c9x_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_msgpriq
operator|=
name|sc
operator|->
name|sc_msgout
operator|=
name|sc
operator|->
name|sc_msgoutq
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_phase
operator|=
name|sc
operator|->
name|sc_prevphase
operator|=
name|INVALID_PHASE
expr_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|sc
operator|->
name|sc_ntarg
condition|;
name|r
operator|++
control|)
block|{
name|struct
name|ncr53c9x_tinfo
modifier|*
name|ti
init|=
operator|&
name|sc
operator|->
name|sc_tinfo
index|[
name|r
index|]
decl_stmt|;
comment|/* XXX - config flags per target: low bits: no reselect; high bits: no synch */
name|ti
operator|->
name|flags
operator|=
operator|(
operator|(
name|sc
operator|->
name|sc_minsync
operator|&&
operator|!
operator|(
name|sc
operator|->
name|sc_cfflags
operator|&
operator|(
literal|1
operator|<<
operator|(
operator|(
name|r
operator|&
literal|7
operator|)
operator|+
literal|8
operator|)
operator|)
operator|)
operator|)
condition|?
literal|0
else|:
name|T_SYNCHOFF
operator|)
operator||
operator|(
operator|(
name|sc
operator|->
name|sc_cfflags
operator|&
operator|(
literal|1
operator|<<
operator|(
name|r
operator|&
literal|7
operator|)
operator|)
operator|)
condition|?
name|T_RSELECTOFF
else|:
literal|0
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ncr53c9x_notag
condition|)
name|ti
operator|->
name|flags
operator|&=
operator|~
name|T_TAG
expr_stmt|;
endif|#
directive|endif
name|ti
operator|->
name|period
operator|=
name|sc
operator|->
name|sc_minsync
expr_stmt|;
name|ti
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|ti
operator|->
name|cfg3
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|doreset
condition|)
block|{
name|sc
operator|->
name|sc_state
operator|=
name|NCR_SBR
expr_stmt|;
name|NCRCMD
argument_list|(
name|sc
argument_list|,
name|NCRCMD_RSTSCSI
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|sc_state
operator|=
name|NCR_IDLE
expr_stmt|;
name|ncr53c9x_sched
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Read the NCR registers, and save their contents for later use.  * NCR_STAT, NCR_STEP& NCR_INTR are mostly zeroed out when reading  * NCR_INTR - so make sure it is the last read.  *  * I think that (from reading the docs) most bits in these registers  * only make sense when he DMA CSR has an interrupt showing. Call only  * if an interrupt is pending.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|ncr53c9x_readregs
parameter_list|(
name|struct
name|ncr53c9x_softc
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|sc_espstat
operator|=
name|NCR_READ_REG
argument_list|(
name|sc
argument_list|,
name|NCR_STAT
argument_list|)
expr_stmt|;
comment|/* Only the stepo bits are of interest */
name|sc
operator|->
name|sc_espstep
operator|=
name|NCR_READ_REG
argument_list|(
name|sc
argument_list|,
name|NCR_STEP
argument_list|)
operator|&
name|NCRSTEP_MASK
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rev
operator|==
name|NCR_VARIANT_FAS366
condition|)
name|sc
operator|->
name|sc_espstat2
operator|=
name|NCR_READ_REG
argument_list|(
name|sc
argument_list|,
name|NCR_STAT2
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_espintr
operator|=
name|NCR_READ_REG
argument_list|(
name|sc
argument_list|,
name|NCR_INTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_glue
operator|->
name|gl_clear_latched_intr
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|sc
operator|->
name|sc_glue
operator|->
name|gl_clear_latched_intr
call|)
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Determine the SCSI bus phase, return either a real SCSI bus phase 	 * or some pseudo phase we use to detect certain exceptions. 	 */
name|sc
operator|->
name|sc_phase
operator|=
operator|(
name|sc
operator|->
name|sc_espintr
operator|&
name|NCRINTR_DIS
operator|)
condition|?
comment|/* Disconnected */
name|BUSFREE_PHASE
else|:
name|sc
operator|->
name|sc_espstat
operator|&
name|NCRSTAT_PHASE
expr_stmt|;
name|NCR_INTS
argument_list|(
operator|(
literal|"regs[intr=%02x,stat=%02x,step=%02x,stat2=%02x] "
operator|,
name|sc
operator|->
name|sc_espintr
operator|,
name|sc
operator|->
name|sc_espstat
operator|,
name|sc
operator|->
name|sc_espstep
operator|,
name|sc
operator|->
name|sc_espstat2
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Convert Synchronous Transfer Period to chip register Clock Per Byte value.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|ncr53c9x_stp2cpb
parameter_list|(
name|struct
name|ncr53c9x_softc
modifier|*
name|sc
parameter_list|,
name|int
name|period
parameter_list|)
block|{
name|int
name|v
decl_stmt|;
name|v
operator|=
operator|(
name|sc
operator|->
name|sc_freq
operator|*
name|period
operator|)
operator|/
literal|250
expr_stmt|;
if|if
condition|(
name|ncr53c9x_cpb2stp
argument_list|(
name|sc
argument_list|,
name|v
argument_list|)
operator|<
name|period
condition|)
comment|/* Correct round-down error */
name|v
operator|++
expr_stmt|;
return|return
operator|(
name|v
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|ncr53c9x_setsync
parameter_list|(
name|struct
name|ncr53c9x_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ncr53c9x_tinfo
modifier|*
name|ti
parameter_list|)
block|{
name|u_char
name|syncoff
decl_stmt|,
name|synctp
decl_stmt|;
name|u_char
name|cfg3
init|=
name|sc
operator|->
name|sc_cfg3
operator||
name|ti
operator|->
name|cfg3
decl_stmt|;
if|if
condition|(
name|ti
operator|->
name|flags
operator|&
name|T_SYNCMODE
condition|)
block|{
name|syncoff
operator|=
name|ti
operator|->
name|offset
expr_stmt|;
name|synctp
operator|=
name|ncr53c9x_stp2cpb
argument_list|(
name|sc
argument_list|,
name|ti
operator|->
name|period
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_features
operator|&
name|NCR_F_FASTSCSI
condition|)
block|{
comment|/* 			 * If the period is 200ns or less (ti->period<= 50), 			 * put the chip in Fast SCSI mode. 			 */
if|if
condition|(
name|ti
operator|->
name|period
operator|<=
literal|50
condition|)
comment|/* 				 * There are (at least) 4 variations of the 				 * configuration 3 register.  The drive attach 				 * routine sets the appropriate bit to put the 				 * chip into Fast SCSI mode so that it doesn't 				 * have to be figured out here each time. 				 */
name|cfg3
operator||=
name|sc
operator|->
name|sc_cfg3_fscsi
expr_stmt|;
block|}
comment|/* 		 * Am53c974 requires different SYNCTP values when the 		 * FSCSI bit is off. 		 */
if|if
condition|(
name|sc
operator|->
name|sc_rev
operator|==
name|NCR_VARIANT_AM53C974
operator|&&
operator|(
name|cfg3
operator|&
name|NCRAMDCFG3_FSCSI
operator|)
operator|==
literal|0
condition|)
name|synctp
operator|--
expr_stmt|;
block|}
else|else
block|{
name|syncoff
operator|=
literal|0
expr_stmt|;
name|synctp
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_features
operator|&
name|NCR_F_HASCFG3
condition|)
name|NCR_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|NCR_CFG3
argument_list|,
name|cfg3
argument_list|)
expr_stmt|;
name|NCR_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|NCR_SYNCOFF
argument_list|,
name|syncoff
argument_list|)
expr_stmt|;
name|NCR_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|NCR_SYNCTP
argument_list|,
name|synctp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send a command to a target, set the driver state to NCR_SELECTING  * and let the caller take care of the rest.  *  * Keeping this as a function allows me to say that this may be done  * by DMA instead of programmed I/O soon.  */
end_comment

begin_function
specifier|static
name|void
name|ncr53c9x_select
parameter_list|(
name|struct
name|ncr53c9x_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ncr53c9x_ecb
modifier|*
name|ecb
parameter_list|)
block|{
name|int
name|target
init|=
name|ecb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
decl_stmt|;
name|int
name|lun
init|=
name|ecb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
decl_stmt|;
name|struct
name|ncr53c9x_tinfo
modifier|*
name|ti
decl_stmt|;
name|int
name|tiflags
decl_stmt|;
name|u_char
modifier|*
name|cmd
decl_stmt|;
name|int
name|clen
decl_stmt|;
name|int
name|selatn3
decl_stmt|,
name|selatns
decl_stmt|;
name|size_t
name|dmasize
decl_stmt|;
name|NCR_TRACE
argument_list|(
operator|(
literal|"[ncr53c9x_select(t%d,l%d,cmd:%x,tag:%x,%x)] "
operator|,
name|target
operator|,
name|lun
operator|,
name|ecb
operator|->
name|cmd
operator|.
name|cmd
operator|.
name|opcode
operator|,
name|ecb
operator|->
name|tag
index|[
literal|0
index|]
operator|,
name|ecb
operator|->
name|tag
index|[
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
name|ti
operator|=
operator|&
name|sc
operator|->
name|sc_tinfo
index|[
name|target
index|]
expr_stmt|;
name|tiflags
operator|=
name|ti
operator|->
name|flags
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
name|NCR_SELECTING
expr_stmt|;
comment|/* 	 * Schedule the timeout now, the first time we will go away 	 * expecting to come back due to an interrupt, because it is 	 * always possible that the interrupt may never happen. 	 */
name|ecb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|ncr53c9x_timeout
argument_list|,
name|ecb
argument_list|,
name|mstohz
argument_list|(
name|ecb
operator|->
name|timeout
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * The docs say the target register is never reset, and I 	 * can't think of a better place to set it 	 */
if|if
condition|(
name|sc
operator|->
name|sc_rev
operator|==
name|NCR_VARIANT_FAS366
condition|)
block|{
name|NCRCMD
argument_list|(
name|sc
argument_list|,
name|NCRCMD_FLUSH
argument_list|)
expr_stmt|;
name|NCR_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|NCR_SELID
argument_list|,
name|target
operator||
name|NCR_BUSID_HME
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NCR_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|NCR_SELID
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
name|ncr53c9x_setsync
argument_list|(
name|sc
argument_list|,
name|ti
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ecb
operator|->
name|flags
operator|&
name|ECB_SENSE
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * For REQUEST SENSE, we should not send an IDENTIFY or 		 * otherwise mangle the target.  There should be no MESSAGE IN 		 * phase. 		 */
if|if
condition|(
name|sc
operator|->
name|sc_features
operator|&
name|NCR_F_DMASELECT
condition|)
block|{
comment|/* setup DMA transfer for command */
name|dmasize
operator|=
name|clen
operator|=
name|ecb
operator|->
name|clen
expr_stmt|;
name|sc
operator|->
name|sc_cmdlen
operator|=
name|clen
expr_stmt|;
name|sc
operator|->
name|sc_cmdp
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|ecb
operator|->
name|cmd
operator|.
name|cmd
expr_stmt|;
comment|/* Program the SCSI counter */
name|NCR_SET_COUNT
argument_list|(
name|sc
argument_list|,
name|dmasize
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rev
operator|!=
name|NCR_VARIANT_FAS366
condition|)
name|NCRCMD
argument_list|(
name|sc
argument_list|,
name|NCRCMD_NOP
operator||
name|NCRCMD_DMA
argument_list|)
expr_stmt|;
comment|/* And get the targets attention */
name|NCRCMD
argument_list|(
name|sc
argument_list|,
name|NCRCMD_SELNATN
operator||
name|NCRCMD_DMA
argument_list|)
expr_stmt|;
name|NCRDMA_SETUP
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_cmdp
argument_list|,
operator|&
name|sc
operator|->
name|sc_cmdlen
argument_list|,
literal|0
argument_list|,
operator|&
name|dmasize
argument_list|)
expr_stmt|;
name|NCRDMA_GO
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ncr53c9x_wrfifo
argument_list|(
name|sc
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|ecb
operator|->
name|cmd
operator|.
name|cmd
argument_list|,
name|ecb
operator|->
name|clen
argument_list|)
expr_stmt|;
name|NCRCMD
argument_list|(
name|sc
argument_list|,
name|NCRCMD_SELNATN
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|selatn3
operator|=
name|selatns
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ecb
operator|->
name|tag
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_features
operator|&
name|NCR_F_SELATN3
condition|)
comment|/* use SELATN3 to send tag messages */
name|selatn3
operator|=
literal|1
expr_stmt|;
else|else
comment|/* We don't have SELATN3; use SELATNS to send tags */
name|selatns
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ti
operator|->
name|flags
operator|&
name|T_NEGOTIATE
condition|)
block|{
comment|/* We have to use SELATNS to send sync/wide messages */
name|selatn3
operator|=
literal|0
expr_stmt|;
name|selatns
operator|=
literal|1
expr_stmt|;
block|}
name|cmd
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|ecb
operator|->
name|cmd
operator|.
name|cmd
expr_stmt|;
if|if
condition|(
name|selatn3
condition|)
block|{
comment|/* We'll use tags with SELATN3 */
name|clen
operator|=
name|ecb
operator|->
name|clen
operator|+
literal|3
expr_stmt|;
name|cmd
operator|-=
literal|3
expr_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|MSG_IDENTIFY
argument_list|(
name|lun
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* msg[0] */
name|cmd
index|[
literal|1
index|]
operator|=
name|ecb
operator|->
name|tag
index|[
literal|0
index|]
expr_stmt|;
comment|/* msg[1] */
name|cmd
index|[
literal|2
index|]
operator|=
name|ecb
operator|->
name|tag
index|[
literal|1
index|]
expr_stmt|;
comment|/* msg[2] */
block|}
else|else
block|{
comment|/* We don't have tags, or will send messages with SELATNS */
name|clen
operator|=
name|ecb
operator|->
name|clen
operator|+
literal|1
expr_stmt|;
name|cmd
operator|-=
literal|1
expr_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|MSG_IDENTIFY
argument_list|(
name|lun
argument_list|,
operator|(
name|tiflags
operator|&
name|T_RSELECTOFF
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_features
operator|&
name|NCR_F_DMASELECT
operator|)
operator|&&
operator|!
name|selatns
condition|)
block|{
comment|/* setup DMA transfer for command */
name|dmasize
operator|=
name|clen
expr_stmt|;
name|sc
operator|->
name|sc_cmdlen
operator|=
name|clen
expr_stmt|;
name|sc
operator|->
name|sc_cmdp
operator|=
name|cmd
expr_stmt|;
comment|/* Program the SCSI counter */
name|NCR_SET_COUNT
argument_list|(
name|sc
argument_list|,
name|dmasize
argument_list|)
expr_stmt|;
comment|/* load the count in */
comment|/* if (sc->sc_rev != NCR_VARIANT_FAS366) */
name|NCRCMD
argument_list|(
name|sc
argument_list|,
name|NCRCMD_NOP
operator||
name|NCRCMD_DMA
argument_list|)
expr_stmt|;
comment|/* And get the targets attention */
if|if
condition|(
name|selatn3
condition|)
block|{
name|sc
operator|->
name|sc_msgout
operator|=
name|SEND_TAG
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|NCR_ATN
expr_stmt|;
name|NCRCMD
argument_list|(
name|sc
argument_list|,
name|NCRCMD_SELATN3
operator||
name|NCRCMD_DMA
argument_list|)
expr_stmt|;
block|}
else|else
name|NCRCMD
argument_list|(
name|sc
argument_list|,
name|NCRCMD_SELATN
operator||
name|NCRCMD_DMA
argument_list|)
expr_stmt|;
name|NCRDMA_SETUP
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_cmdp
argument_list|,
operator|&
name|sc
operator|->
name|sc_cmdlen
argument_list|,
literal|0
argument_list|,
operator|&
name|dmasize
argument_list|)
expr_stmt|;
name|NCRDMA_GO
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Who am I?  This is where we tell the target that we are 	 * happy for it to disconnect etc. 	 */
comment|/* Now get the command into the FIFO */
name|ncr53c9x_wrfifo
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|,
name|clen
argument_list|)
expr_stmt|;
comment|/* And get the targets attention */
if|if
condition|(
name|selatns
condition|)
block|{
name|NCR_MSGS
argument_list|(
operator|(
literal|"SELATNS \n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Arbitrate, select and stop after IDENTIFY message */
name|NCRCMD
argument_list|(
name|sc
argument_list|,
name|NCRCMD_SELATNS
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|selatn3
condition|)
block|{
name|sc
operator|->
name|sc_msgout
operator|=
name|SEND_TAG
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|NCR_ATN
expr_stmt|;
name|NCRCMD
argument_list|(
name|sc
argument_list|,
name|NCRCMD_SELATN3
argument_list|)
expr_stmt|;
block|}
else|else
name|NCRCMD
argument_list|(
name|sc
argument_list|,
name|NCRCMD_SELATN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ncr53c9x_free_ecb
parameter_list|(
name|struct
name|ncr53c9x_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ncr53c9x_ecb
modifier|*
name|ecb
parameter_list|)
block|{
name|ecb
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|free_list
argument_list|,
name|ecb
argument_list|,
name|free_links
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|struct
name|ncr53c9x_ecb
modifier|*
name|ncr53c9x_get_ecb
parameter_list|(
name|struct
name|ncr53c9x_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ncr53c9x_ecb
modifier|*
name|ecb
decl_stmt|;
name|ecb
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|free_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecb
condition|)
block|{
if|if
condition|(
name|ecb
operator|->
name|flags
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"ecb flags not cleared\n"
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|free_list
argument_list|,
name|ecb
argument_list|,
name|free_links
argument_list|)
expr_stmt|;
name|ecb
operator|->
name|flags
operator|=
name|ECB_ALLOC
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|ecb
operator|->
name|ccb
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ncr53c9x_ecb
argument_list|)
operator|-
name|offsetof
argument_list|(
expr|struct
name|ncr53c9x_ecb
argument_list|,
name|ccb
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ecb
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * DRIVER FUNCTIONS CALLABLE FROM HIGHER LEVEL DRIVERS:  */
end_comment

begin_comment
comment|/*  * Start a SCSI-command  * This function is called by the higher level SCSI-driver to queue/run  * SCSI-commands.  */
end_comment

begin_function
name|void
name|ncr53c9x_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|ncr53c9x_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ncr53c9x_ecb
modifier|*
name|ecb
decl_stmt|;
name|NCR_TRACE
argument_list|(
operator|(
literal|"[ncr53c9x_action %d]"
operator|,
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|=
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_RESET_BUS
case|:
name|ncr53c9x_scsi_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
case|case
name|XPT_CALC_GEOMETRY
case|:
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|cam_calc_geometry
argument_list|(
operator|&
name|ccb
operator|->
name|ccg
argument_list|,
name|sc
operator|->
name|sc_extended_geom
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
case|case
name|XPT_PATH_INQ
case|:
block|{
name|struct
name|ccb_pathinq
modifier|*
name|cpi
init|=
operator|&
name|ccb
operator|->
name|cpi
decl_stmt|;
name|cpi
operator|->
name|version_num
operator|=
literal|1
expr_stmt|;
name|cpi
operator|->
name|hba_inquiry
operator|=
name|PI_SDTR_ABLE
operator||
name|PI_TAG_ABLE
expr_stmt|;
name|cpi
operator|->
name|hba_inquiry
operator||=
operator|(
name|sc
operator|->
name|sc_rev
operator|==
name|NCR_VARIANT_FAS366
operator|)
condition|?
name|PI_WIDE_16
else|:
literal|0
expr_stmt|;
name|cpi
operator|->
name|target_sprt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_misc
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_eng_cnt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|max_target
operator|=
name|sc
operator|->
name|sc_ntarg
operator|-
literal|1
expr_stmt|;
name|cpi
operator|->
name|max_lun
operator|=
literal|8
expr_stmt|;
name|cpi
operator|->
name|initiator_id
operator|=
name|sc
operator|->
name|sc_id
expr_stmt|;
name|cpi
operator|->
name|bus_id
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|base_transfer_speed
operator|=
literal|3300
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|sim_vid
argument_list|,
literal|"FreeBSD"
argument_list|,
name|SIM_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|hba_vid
argument_list|,
literal|"Sun"
argument_list|,
name|HBA_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|dev_name
argument_list|,
name|cam_sim_name
argument_list|(
name|sim
argument_list|)
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|unit_number
operator|=
name|cam_sim_unit
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|transport
operator|=
name|XPORT_SPI
expr_stmt|;
name|cpi
operator|->
name|transport_version
operator|=
literal|2
expr_stmt|;
name|cpi
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cpi
operator|->
name|protocol_version
operator|=
name|SCSI_REV_2
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|XPT_GET_TRAN_SETTINGS
case|:
block|{
name|struct
name|ccb_trans_settings
modifier|*
name|cts
init|=
operator|&
name|ccb
operator|->
name|cts
decl_stmt|;
name|struct
name|ncr53c9x_tinfo
modifier|*
name|ti
init|=
operator|&
name|sc
operator|->
name|sc_tinfo
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
decl_stmt|;
name|struct
name|ccb_trans_settings_scsi
modifier|*
name|scsi
init|=
operator|&
name|cts
operator|->
name|proto_specific
operator|.
name|scsi
decl_stmt|;
name|struct
name|ccb_trans_settings_spi
modifier|*
name|spi
init|=
operator|&
name|cts
operator|->
name|xport_specific
operator|.
name|spi
decl_stmt|;
name|cts
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cts
operator|->
name|protocol_version
operator|=
name|SCSI_REV_2
expr_stmt|;
name|cts
operator|->
name|transport
operator|=
name|XPORT_SPI
expr_stmt|;
name|cts
operator|->
name|transport_version
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|type
operator|==
name|CTS_TYPE_CURRENT_SETTINGS
condition|)
block|{
name|spi
operator|->
name|sync_period
operator|=
name|ti
operator|->
name|period
expr_stmt|;
name|spi
operator|->
name|sync_offset
operator|=
name|ti
operator|->
name|offset
expr_stmt|;
name|spi
operator|->
name|bus_width
operator|=
name|ti
operator|->
name|width
expr_stmt|;
if|if
condition|(
operator|(
name|ti
operator|->
name|flags
operator|&
name|T_TAG
operator|)
operator|!=
literal|0
condition|)
block|{
name|spi
operator|->
name|flags
operator||=
name|CTS_SPI_FLAGS_DISC_ENB
expr_stmt|;
name|scsi
operator|->
name|flags
operator||=
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
block|}
else|else
block|{
name|spi
operator|->
name|flags
operator|&=
operator|~
name|CTS_SPI_FLAGS_DISC_ENB
expr_stmt|;
name|scsi
operator|->
name|flags
operator|&=
operator|~
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
block|}
block|}
else|else
block|{
name|spi
operator|->
name|sync_period
operator|=
name|sc
operator|->
name|sc_maxsync
expr_stmt|;
name|spi
operator|->
name|sync_offset
operator|=
name|sc
operator|->
name|sc_maxoffset
expr_stmt|;
name|spi
operator|->
name|bus_width
operator|=
name|sc
operator|->
name|sc_maxwidth
expr_stmt|;
name|spi
operator|->
name|flags
operator||=
name|CTS_SPI_FLAGS_DISC_ENB
expr_stmt|;
name|scsi
operator|->
name|flags
operator||=
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
block|}
name|spi
operator|->
name|valid
operator|=
name|CTS_SPI_VALID_BUS_WIDTH
operator||
name|CTS_SPI_VALID_SYNC_RATE
operator||
name|CTS_SPI_VALID_SYNC_OFFSET
operator||
name|CTS_SPI_VALID_DISC
expr_stmt|;
name|scsi
operator|->
name|valid
operator|=
name|CTS_SCSI_VALID_TQ
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|XPT_ABORT
case|:
name|printf
argument_list|(
literal|"XPT_ABORT called\n"
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_FUNC_NOTAVAIL
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
case|case
name|XPT_TERM_IO
case|:
name|printf
argument_list|(
literal|"XPT_TERM_IO called\n"
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_FUNC_NOTAVAIL
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
case|case
name|XPT_RESET_DEV
case|:
name|printf
argument_list|(
literal|"XPT_RESET_DEV called\n"
argument_list|)
expr_stmt|;
case|case
name|XPT_SCSI_IO
case|:
block|{
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|<
literal|0
operator|||
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|>=
name|sc
operator|->
name|sc_ntarg
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_PATH_INVALID
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Get an ECB to use. */
name|ecb
operator|=
name|ncr53c9x_get_ecb
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 		 * This should never happen as we track resources 		 * in the mid-layer. 		 */
if|if
condition|(
name|ecb
operator|==
name|NULL
condition|)
block|{
name|xpt_freeze_simq
argument_list|(
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQUEUE_REQ
expr_stmt|;
name|printf
argument_list|(
literal|"unable to allocate ecb\n"
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Initialize ecb */
name|ecb
operator|->
name|ccb
operator|=
name|ccb
expr_stmt|;
name|ecb
operator|->
name|timeout
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_RESET_DEV
condition|)
block|{
name|ecb
operator|->
name|flags
operator||=
name|ECB_RESET
expr_stmt|;
name|ecb
operator|->
name|clen
operator|=
literal|0
expr_stmt|;
name|ecb
operator|->
name|dleft
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|csio
operator|=
operator|&
name|ccb
operator|->
name|csio
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_POINTER
operator|)
operator|!=
literal|0
condition|)
name|bcopy
argument_list|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_ptr
argument_list|,
operator|&
name|ecb
operator|->
name|cmd
operator|.
name|cmd
argument_list|,
name|csio
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
else|else
name|bcopy
argument_list|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
operator|&
name|ecb
operator|->
name|cmd
operator|.
name|cmd
argument_list|,
name|csio
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
name|ecb
operator|->
name|clen
operator|=
name|csio
operator|->
name|cdb_len
expr_stmt|;
name|ecb
operator|->
name|daddr
operator|=
name|csio
operator|->
name|data_ptr
expr_stmt|;
name|ecb
operator|->
name|dleft
operator|=
name|csio
operator|->
name|dxfer_len
expr_stmt|;
block|}
name|ecb
operator|->
name|stat
operator|=
literal|0
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|ready_list
argument_list|,
name|ecb
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|ecb
operator|->
name|flags
operator||=
name|ECB_READY
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
name|NCR_IDLE
condition|)
name|ncr53c9x_sched
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_SET_TRAN_SETTINGS
case|:
block|{
name|struct
name|ccb_trans_settings
modifier|*
name|cts
init|=
operator|&
name|ccb
operator|->
name|cts
decl_stmt|;
name|int
name|target
init|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
decl_stmt|;
name|struct
name|ncr53c9x_tinfo
modifier|*
name|ti
init|=
operator|&
name|sc
operator|->
name|sc_tinfo
index|[
name|target
index|]
decl_stmt|;
name|struct
name|ccb_trans_settings_scsi
modifier|*
name|scsi
init|=
operator|&
name|cts
operator|->
name|proto_specific
operator|.
name|scsi
decl_stmt|;
name|struct
name|ccb_trans_settings_spi
modifier|*
name|spi
init|=
operator|&
name|cts
operator|->
name|xport_specific
operator|.
name|spi
decl_stmt|;
if|if
condition|(
operator|(
name|scsi
operator|->
name|valid
operator|&
name|CTS_SCSI_VALID_TQ
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_cfflags
operator|&
operator|(
literal|1
operator|<<
operator|(
operator|(
name|target
operator|&
literal|7
operator|)
operator|+
literal|16
operator|)
operator|)
operator|)
operator|==
literal|0
operator|&&
operator|(
name|scsi
operator|->
name|flags
operator|&
name|CTS_SCSI_FLAGS_TAG_ENB
operator|)
condition|)
block|{
name|NCR_MISC
argument_list|(
operator|(
literal|"%s: target %d: tagged queuing\n"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
name|target
operator|)
argument_list|)
expr_stmt|;
name|ti
operator|->
name|flags
operator||=
name|T_TAG
expr_stmt|;
block|}
else|else
name|ti
operator|->
name|flags
operator|&=
operator|~
name|T_TAG
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_BUS_WIDTH
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|spi
operator|->
name|bus_width
operator|!=
literal|0
condition|)
block|{
name|NCR_MISC
argument_list|(
operator|(
literal|"%s: target %d: wide negotiation\n"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
name|target
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rev
operator|==
name|NCR_VARIANT_FAS366
condition|)
block|{
name|ti
operator|->
name|flags
operator||=
name|T_WIDE
expr_stmt|;
name|ti
operator|->
name|width
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|ti
operator|->
name|flags
operator|&=
operator|~
name|T_WIDE
expr_stmt|;
name|ti
operator|->
name|width
operator|=
literal|0
expr_stmt|;
block|}
name|ti
operator|->
name|flags
operator||=
name|T_NEGOTIATE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_SYNC_RATE
operator|)
operator|!=
literal|0
condition|)
block|{
name|NCR_MISC
argument_list|(
operator|(
literal|"%s: target %d: sync period negotiation\n"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
name|target
operator|)
argument_list|)
expr_stmt|;
name|ti
operator|->
name|flags
operator||=
name|T_NEGOTIATE
expr_stmt|;
name|ti
operator|->
name|period
operator|=
name|spi
operator|->
name|sync_period
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_SYNC_OFFSET
operator|)
operator|!=
literal|0
condition|)
block|{
name|NCR_MISC
argument_list|(
operator|(
literal|"%s: target %d: sync offset negotiation\n"
operator|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|,
name|target
operator|)
argument_list|)
expr_stmt|;
name|ti
operator|->
name|flags
operator||=
name|T_NEGOTIATE
expr_stmt|;
name|ti
operator|->
name|offset
operator|=
name|spi
operator|->
name|sync_offset
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Unhandled function code %d\n"
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_PROVIDE_FAIL
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Used when interrupt driven I/O is not allowed, e.g. during boot.  */
end_comment

begin_function
specifier|static
name|void
name|ncr53c9x_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
block|{
name|struct
name|ncr53c9x_softc
modifier|*
name|sc
decl_stmt|;
name|NCR_TRACE
argument_list|(
operator|(
literal|"[ncr53c9x_poll] "
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|=
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
expr_stmt|;
if|if
condition|(
name|NCRDMA_ISINTR
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|ncr53c9x_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * LOW LEVEL SCSI UTILITIES  */
end_comment

begin_comment
comment|/*  * Schedule a scsi operation.  This has now been pulled out of the interrupt  * handler so that we may call it from ncr53c9x_scsipi_request and  * ncr53c9x_done.  This may save us an unnecessary interrupt just to get  * things going.  Should only be called when state == NCR_IDLE and at bio pl.  */
end_comment

begin_function
specifier|static
name|void
name|ncr53c9x_sched
parameter_list|(
name|struct
name|ncr53c9x_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ncr53c9x_ecb
modifier|*
name|ecb
decl_stmt|;
name|struct
name|ncr53c9x_tinfo
modifier|*
name|ti
decl_stmt|;
name|struct
name|ncr53c9x_linfo
modifier|*
name|li
decl_stmt|;
name|int
name|lun
decl_stmt|;
name|int
name|tag
decl_stmt|;
name|NCR_TRACE
argument_list|(
operator|(
literal|"[ncr53c9x_sched] "
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|!=
name|NCR_IDLE
condition|)
name|panic
argument_list|(
literal|"ncr53c9x_sched: not IDLE (state=%d)"
argument_list|,
name|sc
operator|->
name|sc_state
argument_list|)
expr_stmt|;
comment|/* 	 * Find first ecb in ready queue that is for a target/lunit 	 * combinations that is not busy. 	 */
for|for
control|(
name|ecb
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|ready_list
argument_list|)
init|;
name|ecb
operator|!=
name|NULL
condition|;
name|ecb
operator|=
name|TAILQ_NEXT
argument_list|(
name|ecb
argument_list|,
name|chain
argument_list|)
control|)
block|{
name|ti
operator|=
operator|&
name|sc
operator|->
name|sc_tinfo
index|[
name|ecb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
expr_stmt|;
name|lun
operator|=
name|ecb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
comment|/* Select type of tag for this command */
if|if
condition|(
operator|(
name|ti
operator|->
name|flags
operator|&
operator|(
name|T_RSELECTOFF
operator|)
operator|)
operator|!=
literal|0
condition|)
name|tag
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ti
operator|->
name|flags
operator|&
operator|(
name|T_TAG
operator|)
operator|)
operator|==
literal|0
condition|)
name|tag
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ecb
operator|->
name|flags
operator|&
name|ECB_SENSE
operator|)
operator|!=
literal|0
condition|)
name|tag
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ecb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_TAG_ACTION_VALID
operator|)
operator|==
literal|0
condition|)
name|tag
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|ecb
operator|->
name|ccb
operator|->
name|csio
operator|.
name|tag_action
operator|==
name|CAM_TAG_ACTION_NONE
condition|)
name|tag
operator|=
literal|0
expr_stmt|;
else|else
name|tag
operator|=
name|ecb
operator|->
name|ccb
operator|->
name|csio
operator|.
name|tag_action
expr_stmt|;
name|li
operator|=
name|TINFO_LUN
argument_list|(
name|ti
argument_list|,
name|lun
argument_list|)
expr_stmt|;
if|if
condition|(
name|li
operator|==
name|NULL
condition|)
block|{
comment|/* Initialize LUN info and add to list. */
if|if
condition|(
operator|(
name|li
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|li
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
continue|continue;
block|}
name|li
operator|->
name|lun
operator|=
name|lun
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|ti
operator|->
name|luns
argument_list|,
name|li
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun
operator|<
name|NCR_NLUN
condition|)
name|ti
operator|->
name|lun
index|[
name|lun
index|]
operator|=
name|li
expr_stmt|;
block|}
name|li
operator|->
name|last_used
operator|=
name|time_second
expr_stmt|;
if|if
condition|(
name|tag
operator|==
literal|0
condition|)
block|{
comment|/* Try to issue this as an un-tagged command */
if|if
condition|(
name|li
operator|->
name|untagged
operator|==
name|NULL
condition|)
name|li
operator|->
name|untagged
operator|=
name|ecb
expr_stmt|;
block|}
if|if
condition|(
name|li
operator|->
name|untagged
operator|!=
name|NULL
condition|)
block|{
name|tag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|li
operator|->
name|busy
operator|!=
literal|1
operator|)
operator|&&
name|li
operator|->
name|used
operator|==
literal|0
condition|)
block|{
comment|/* We need to issue this untagged command now */
name|ecb
operator|=
name|li
operator|->
name|untagged
expr_stmt|;
block|}
else|else
block|{
comment|/* Not ready yet */
continue|continue;
block|}
block|}
name|ecb
operator|->
name|tag
index|[
literal|0
index|]
operator|=
name|tag
expr_stmt|;
if|if
condition|(
name|tag
operator|!=
literal|0
condition|)
block|{
name|li
operator|->
name|queued
index|[
name|ecb
operator|->
name|tag_id
index|]
operator|=
name|ecb
expr_stmt|;
name|ecb
operator|->
name|tag
index|[
literal|1
index|]
operator|=
name|ecb
operator|->
name|tag_id
expr_stmt|;
name|li
operator|->
name|used
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|li
operator|->
name|untagged
operator|!=
name|NULL
operator|&&
operator|(
name|li
operator|->
name|busy
operator|!=
literal|1
operator|)
condition|)
block|{
name|li
operator|->
name|busy
operator|=
literal|1
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|ready_list
argument_list|,
name|ecb
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|ecb
operator|->
name|flags
operator|&=
operator|~
name|ECB_READY
expr_stmt|;
name|sc
operator|->
name|sc_nexus
operator|=
name|ecb
expr_stmt|;
name|ncr53c9x_select
argument_list|(
name|sc
argument_list|,
name|ecb
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|li
operator|->
name|untagged
operator|==
name|NULL
operator|&&
name|tag
operator|!=
literal|0
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|ready_list
argument_list|,
name|ecb
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|ecb
operator|->
name|flags
operator|&=
operator|~
name|ECB_READY
expr_stmt|;
name|sc
operator|->
name|sc_nexus
operator|=
name|ecb
expr_stmt|;
name|ncr53c9x_select
argument_list|(
name|sc
argument_list|,
name|ecb
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
name|NCR_TRACE
argument_list|(
operator|(
literal|"%d:%d busy\n"
operator|,
name|ecb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|,
name|ecb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ncr53c9x_sense
parameter_list|(
name|struct
name|ncr53c9x_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ncr53c9x_ecb
modifier|*
name|ecb
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
init|=
name|ecb
operator|->
name|ccb
decl_stmt|;
name|struct
name|ncr53c9x_tinfo
modifier|*
name|ti
decl_stmt|;
name|struct
name|scsi_request_sense
modifier|*
name|ss
init|=
operator|(
name|void
operator|*
operator|)
operator|&
name|ecb
operator|->
name|cmd
operator|.
name|cmd
decl_stmt|;
name|struct
name|ncr53c9x_linfo
modifier|*
name|li
decl_stmt|;
name|int
name|lun
decl_stmt|;
name|NCR_TRACE
argument_list|(
operator|(
literal|"requesting sense "
operator|)
argument_list|)
expr_stmt|;
name|lun
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
name|ti
operator|=
operator|&
name|sc
operator|->
name|sc_tinfo
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
expr_stmt|;
comment|/* Next, setup a request sense command block */
name|memset
argument_list|(
name|ss
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ss
argument_list|)
argument_list|)
expr_stmt|;
name|ss
operator|->
name|opcode
operator|=
name|REQUEST_SENSE
expr_stmt|;
name|ss
operator|->
name|byte2
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
operator|<<
name|SCSI_CMD_LUN_SHIFT
expr_stmt|;
name|ss
operator|->
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
expr_stmt|;
name|ecb
operator|->
name|clen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ss
argument_list|)
expr_stmt|;
name|ecb
operator|->
name|daddr
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|ecb
operator|->
name|ccb
operator|->
name|csio
operator|.
name|sense_data
expr_stmt|;
name|ecb
operator|->
name|dleft
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
expr_stmt|;
name|ecb
operator|->
name|flags
operator||=
name|ECB_SENSE
expr_stmt|;
name|ecb
operator|->
name|timeout
operator|=
name|NCR_SENSE_TIMEOUT
expr_stmt|;
name|ti
operator|->
name|senses
operator|++
expr_stmt|;
name|li
operator|=
name|TINFO_LUN
argument_list|(
name|ti
argument_list|,
name|lun
argument_list|)
expr_stmt|;
if|if
condition|(
name|li
operator|->
name|busy
condition|)
name|li
operator|->
name|busy
operator|=
literal|0
expr_stmt|;
name|ncr53c9x_dequeue
argument_list|(
name|sc
argument_list|,
name|ecb
argument_list|)
expr_stmt|;
name|li
operator|->
name|untagged
operator|=
name|ecb
expr_stmt|;
comment|/* must be executed first to fix C/A */
name|li
operator|->
name|busy
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|ecb
operator|==
name|sc
operator|->
name|sc_nexus
condition|)
block|{
name|ncr53c9x_select
argument_list|(
name|sc
argument_list|,
name|ecb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|ready_list
argument_list|,
name|ecb
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|ecb
operator|->
name|flags
operator||=
name|ECB_READY
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
name|NCR_IDLE
condition|)
name|ncr53c9x_sched
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * POST PROCESSING OF SCSI_CMD (usually current)  */
end_comment

begin_function
specifier|static
name|void
name|ncr53c9x_done
parameter_list|(
name|struct
name|ncr53c9x_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ncr53c9x_ecb
modifier|*
name|ecb
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
init|=
name|ecb
operator|->
name|ccb
decl_stmt|;
name|struct
name|ncr53c9x_tinfo
modifier|*
name|ti
decl_stmt|;
name|struct
name|ncr53c9x_linfo
modifier|*
name|li
decl_stmt|;
name|int
name|lun
decl_stmt|;
name|NCR_TRACE
argument_list|(
operator|(
literal|"[ncr53c9x_done(status:%x)] "
operator|,
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|)
argument_list|)
expr_stmt|;
name|ti
operator|=
operator|&
name|sc
operator|->
name|sc_tinfo
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
expr_stmt|;
name|lun
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
name|li
operator|=
name|TINFO_LUN
argument_list|(
name|ti
argument_list|,
name|lun
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|ncr53c9x_timeout
argument_list|,
name|ecb
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
argument_list|)
expr_stmt|;
comment|/* 	 * Now, if we've come here with no error code, i.e. we've kept the 	 * initial XS_NOERROR, and the status code signals that we should 	 * check sense, we'll need to set up a request sense cmd block and 	 * push the command back into the ready queue *before* any other 	 * commands for this target/lunit, else we lose the sense info. 	 * We don't support chk sense conditions for the request sense cmd. 	 */
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|==
name|CAM_REQ_CMP
condition|)
block|{
if|if
condition|(
operator|(
name|ecb
operator|->
name|flags
operator|&
name|ECB_ABORT
operator|)
operator|!=
literal|0
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_CMD_TIMEOUT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ecb
operator|->
name|flags
operator|&
name|ECB_SENSE
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ecb
operator|->
name|stat
operator|!=
name|SCSI_STATUS_CHECK_COND
operator|)
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_AUTOSNS_VALID
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ecb
operator|->
name|stat
operator|==
name|SCSI_STATUS_CHECK_COND
condition|)
block|{
if|if
condition|(
operator|(
name|ecb
operator|->
name|flags
operator|&
name|ECB_SENSE
operator|)
operator|!=
literal|0
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_AUTOSENSE_FAIL
expr_stmt|;
else|else
block|{
comment|/* First, save the return values */
name|ccb
operator|->
name|csio
operator|.
name|resid
operator|=
name|ecb
operator|->
name|dleft
expr_stmt|;
name|ncr53c9x_sense
argument_list|(
name|sc
argument_list|,
name|ecb
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|ccb
operator|->
name|csio
operator|.
name|resid
operator|=
name|ecb
operator|->
name|dleft
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|if (xs->status == SCSI_QUEUE_FULL || xs->status == XS_BUSY) 			xs->error = XS_BUSY;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|NCR53C9X_DEBUG
if|if
condition|(
name|ncr53c9x_debug
operator|&
name|NCR_SHOWTRAC
condition|)
block|{
if|if
condition|(
name|ccb
operator|->
name|csio
operator|.
name|resid
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"resid=%d "
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|resid
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (xs->error == XS_SENSE) 			printf("sense=0x%02x\n", 			    xs->sense.scsi_sense.error_code); 		else 			printf("error=%d\n", xs->error);
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* 	 * Remove the ECB from whatever queue it's on. 	 */
name|ncr53c9x_dequeue
argument_list|(
name|sc
argument_list|,
name|ecb
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecb
operator|==
name|sc
operator|->
name|sc_nexus
condition|)
block|{
name|sc
operator|->
name|sc_nexus
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|!=
name|NCR_CLEANING
condition|)
block|{
name|sc
operator|->
name|sc_state
operator|=
name|NCR_IDLE
expr_stmt|;
name|ncr53c9x_sched
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|==
name|CAM_SEL_TIMEOUT
condition|)
block|{
comment|/* Selection timeout -- discard this LUN if empty */
if|if
condition|(
name|li
operator|->
name|untagged
operator|==
name|NULL
operator|&&
name|li
operator|->
name|used
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|lun
operator|<
name|NCR_NLUN
condition|)
name|ti
operator|->
name|lun
index|[
name|lun
index|]
operator|=
name|NULL
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|li
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|li
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
block|}
name|ncr53c9x_free_ecb
argument_list|(
name|sc
argument_list|,
name|ecb
argument_list|)
expr_stmt|;
name|ti
operator|->
name|cmds
operator|++
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ncr53c9x_dequeue
parameter_list|(
name|struct
name|ncr53c9x_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ncr53c9x_ecb
modifier|*
name|ecb
parameter_list|)
block|{
name|struct
name|ncr53c9x_tinfo
modifier|*
name|ti
decl_stmt|;
name|struct
name|ncr53c9x_linfo
modifier|*
name|li
decl_stmt|;
name|int64_t
name|lun
decl_stmt|;
name|ti
operator|=
operator|&
name|sc
operator|->
name|sc_tinfo
index|[
name|ecb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
expr_stmt|;
name|lun
operator|=
name|ecb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
name|li
operator|=
name|TINFO_LUN
argument_list|(
name|ti
argument_list|,
name|lun
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|li
operator|==
name|NULL
operator|||
name|li
operator|->
name|lun
operator|!=
name|lun
condition|)
name|panic
argument_list|(
literal|"ncr53c9x_dequeue: lun %qx for ecb %p does not exist"
argument_list|,
operator|(
name|long
name|long
operator|)
name|lun
argument_list|,
name|ecb
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|li
operator|->
name|untagged
operator|==
name|ecb
condition|)
block|{
name|li
operator|->
name|busy
operator|=
literal|0
expr_stmt|;
name|li
operator|->
name|untagged
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ecb
operator|->
name|tag
index|[
literal|0
index|]
operator|&&
name|li
operator|->
name|queued
index|[
name|ecb
operator|->
name|tag
index|[
literal|1
index|]
index|]
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|li
operator|->
name|queued
index|[
name|ecb
operator|->
name|tag
index|[
literal|1
index|]
index|]
operator|!=
name|NULL
operator|&&
operator|(
name|li
operator|->
name|queued
index|[
name|ecb
operator|->
name|tag
index|[
literal|1
index|]
index|]
operator|!=
name|ecb
operator|)
condition|)
name|panic
argument_list|(
literal|"ncr53c9x_dequeue: slot %d for lun %qx has %p "
literal|"instead of ecb %p\n"
argument_list|,
name|ecb
operator|->
name|tag
index|[
literal|1
index|]
argument_list|,
operator|(
name|long
name|long
operator|)
name|lun
argument_list|,
name|li
operator|->
name|queued
index|[
name|ecb
operator|->
name|tag
index|[
literal|1
index|]
index|]
argument_list|,
name|ecb
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|li
operator|->
name|queued
index|[
name|ecb
operator|->
name|tag
index|[
literal|1
index|]
index|]
operator|=
name|NULL
expr_stmt|;
name|li
operator|->
name|used
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ecb
operator|->
name|flags
operator|&
name|ECB_READY
operator|)
operator|!=
literal|0
condition|)
block|{
name|ecb
operator|->
name|flags
operator|&=
operator|~
name|ECB_READY
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|ready_list
argument_list|,
name|ecb
argument_list|,
name|chain
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * INTERRUPT/PROTOCOL ENGINE  */
end_comment

begin_comment
comment|/*  * Schedule an outgoing message by prioritizing it, and asserting  * attention on the bus. We can only do this when we are the initiator  * else there will be an illegal command interrupt.  */
end_comment

begin_define
define|#
directive|define
name|ncr53c9x_sched_msgout
parameter_list|(
name|m
parameter_list|)
define|\
value|do {							\ 		NCR_MSGS(("ncr53c9x_sched_msgout %x %d", m, __LINE__));	\ 		NCRCMD(sc, NCRCMD_SETATN);			\ 		sc->sc_flags |= NCR_ATN;			\ 		sc->sc_msgpriq |= (m);				\ 	} while (0)
end_define

begin_function
specifier|static
name|void
name|ncr53c9x_flushfifo
parameter_list|(
name|struct
name|ncr53c9x_softc
modifier|*
name|sc
parameter_list|)
block|{
name|NCR_TRACE
argument_list|(
operator|(
literal|"[flushfifo] "
operator|)
argument_list|)
expr_stmt|;
name|NCRCMD
argument_list|(
name|sc
argument_list|,
name|NCRCMD_FLUSH
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_phase
operator|==
name|COMMAND_PHASE
operator|||
name|sc
operator|->
name|sc_phase
operator|==
name|MESSAGE_OUT_PHASE
condition|)
name|DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ncr53c9x_rdfifo
parameter_list|(
name|struct
name|ncr53c9x_softc
modifier|*
name|sc
parameter_list|,
name|int
name|how
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|;
switch|switch
condition|(
name|how
condition|)
block|{
case|case
name|NCR_RDFIFO_START
case|:
name|buf
operator|=
name|sc
operator|->
name|sc_imess
expr_stmt|;
name|sc
operator|->
name|sc_imlen
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|NCR_RDFIFO_CONTINUE
case|:
name|buf
operator|=
name|sc
operator|->
name|sc_imess
operator|+
name|sc
operator|->
name|sc_imlen
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"ncr53c9x_rdfifo: bad flag"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	 * XXX buffer (sc_imess) size for message 	 */
name|n
operator|=
name|NCR_READ_REG
argument_list|(
name|sc
argument_list|,
name|NCR_FFLAG
argument_list|)
operator|&
name|NCRFIFO_FF
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rev
operator|==
name|NCR_VARIANT_FAS366
condition|)
block|{
name|n
operator|*=
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|buf
index|[
name|i
index|]
operator|=
name|NCR_READ_REG
argument_list|(
name|sc
argument_list|,
name|NCR_FIFO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_espstat2
operator|&
name|NCRFAS_STAT2_ISHUTTLE
condition|)
block|{
name|NCR_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|NCR_FIFO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|buf
index|[
name|i
operator|++
index|]
operator|=
name|NCR_READ_REG
argument_list|(
name|sc
argument_list|,
name|NCR_FIFO
argument_list|)
expr_stmt|;
name|NCR_READ_REG
argument_list|(
name|sc
argument_list|,
name|NCR_FIFO
argument_list|)
expr_stmt|;
name|ncr53c9x_flushfifo
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|buf
index|[
name|i
index|]
operator|=
name|NCR_READ_REG
argument_list|(
name|sc
argument_list|,
name|NCR_FIFO
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_imlen
operator|+=
name|i
expr_stmt|;
if|#
directive|if
literal|0
ifdef|#
directive|ifdef
name|NCR53C9X_DEBUG
block|{ 		int j;  		NCR_TRACE(("\n[rdfifo %s (%d):", 		    (how == NCR_RDFIFO_START) ? "start" : "cont", 		    (int)sc->sc_imlen)); 		if (ncr53c9x_debug& NCR_SHOWTRAC) { 			for (j = 0; j< sc->sc_imlen; j++) 				printf(" %02x", sc->sc_imess[j]); 			printf("]\n"); 		} 	}
endif|#
directive|endif
endif|#
directive|endif
return|return
name|sc
operator|->
name|sc_imlen
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ncr53c9x_wrfifo
parameter_list|(
name|struct
name|ncr53c9x_softc
modifier|*
name|sc
parameter_list|,
name|u_char
modifier|*
name|p
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|NCR53C9X_DEBUG
name|NCR_MSGS
argument_list|(
operator|(
literal|"[wrfifo(%d):"
operator|,
name|len
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ncr53c9x_debug
operator|&
name|NCR_SHOWMSGS
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" %02x"
argument_list|,
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"]\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|NCR_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|NCR_FIFO
argument_list|,
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rev
operator|==
name|NCR_VARIANT_FAS366
condition|)
name|NCR_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|NCR_FIFO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ncr53c9x_reselect
parameter_list|(
name|struct
name|ncr53c9x_softc
modifier|*
name|sc
parameter_list|,
name|int
name|message
parameter_list|,
name|int
name|tagtype
parameter_list|,
name|int
name|tagid
parameter_list|)
block|{
name|u_char
name|selid
decl_stmt|,
name|target
decl_stmt|,
name|lun
decl_stmt|;
name|struct
name|ncr53c9x_ecb
modifier|*
name|ecb
init|=
name|NULL
decl_stmt|;
name|struct
name|ncr53c9x_tinfo
modifier|*
name|ti
decl_stmt|;
name|struct
name|ncr53c9x_linfo
modifier|*
name|li
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rev
operator|==
name|NCR_VARIANT_FAS366
condition|)
block|{
name|target
operator|=
name|sc
operator|->
name|sc_selid
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * The SCSI chip made a snapshot of the data bus 		 * while the reselection was being negotiated. 		 * This enables us to determine which target did 		 * the reselect. 		 */
name|selid
operator|=
name|sc
operator|->
name|sc_selid
operator|&
operator|~
operator|(
literal|1
operator|<<
name|sc
operator|->
name|sc_id
operator|)
expr_stmt|;
if|if
condition|(
name|selid
operator|&
operator|(
name|selid
operator|-
literal|1
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"reselect with invalid "
literal|"selid %02x; sending DEVICE RESET\n"
argument_list|,
name|selid
argument_list|)
expr_stmt|;
goto|goto
name|reset
goto|;
block|}
name|target
operator|=
name|ffs
argument_list|(
name|selid
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
name|lun
operator|=
name|message
operator|&
literal|0x07
expr_stmt|;
comment|/* 	 * Search wait queue for disconnected cmd 	 * The list should be short, so I haven't bothered with 	 * any more sophisticated structures than a simple 	 * singly linked list. 	 */
name|ti
operator|=
operator|&
name|sc
operator|->
name|sc_tinfo
index|[
name|target
index|]
expr_stmt|;
name|li
operator|=
name|TINFO_LUN
argument_list|(
name|ti
argument_list|,
name|lun
argument_list|)
expr_stmt|;
comment|/* 	 * We can get as far as the LUN with the IDENTIFY 	 * message.  Check to see if we're running an 	 * un-tagged command.  Otherwise ack the IDENTIFY 	 * and wait for a tag message. 	 */
if|if
condition|(
name|li
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|li
operator|->
name|untagged
operator|!=
name|NULL
operator|&&
name|li
operator|->
name|busy
condition|)
name|ecb
operator|=
name|li
operator|->
name|untagged
expr_stmt|;
elseif|else
if|if
condition|(
name|tagtype
operator|!=
name|MSG_SIMPLE_Q_TAG
condition|)
block|{
comment|/* Wait for tag to come by */
name|sc
operator|->
name|sc_state
operator|=
name|NCR_IDENTIFIED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|tagtype
condition|)
name|ecb
operator|=
name|li
operator|->
name|queued
index|[
name|tagid
index|]
expr_stmt|;
block|}
if|if
condition|(
name|ecb
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"reselect from target %d lun %d "
literal|"tag %x:%x with no nexus; sending ABORT\n"
argument_list|,
name|target
argument_list|,
name|lun
argument_list|,
name|tagtype
argument_list|,
name|tagid
argument_list|)
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
comment|/* Make this nexus active again. */
name|sc
operator|->
name|sc_state
operator|=
name|NCR_CONNECTED
expr_stmt|;
name|sc
operator|->
name|sc_nexus
operator|=
name|ecb
expr_stmt|;
name|ncr53c9x_setsync
argument_list|(
name|sc
argument_list|,
name|ti
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecb
operator|->
name|flags
operator|&
name|ECB_RESET
condition|)
name|ncr53c9x_sched_msgout
argument_list|(
name|SEND_DEV_RESET
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ecb
operator|->
name|flags
operator|&
name|ECB_ABORT
condition|)
name|ncr53c9x_sched_msgout
argument_list|(
name|SEND_ABORT
argument_list|)
expr_stmt|;
comment|/* Do an implicit RESTORE POINTERS. */
name|sc
operator|->
name|sc_dp
operator|=
name|ecb
operator|->
name|daddr
expr_stmt|;
name|sc
operator|->
name|sc_dleft
operator|=
name|ecb
operator|->
name|dleft
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|reset
label|:
name|ncr53c9x_sched_msgout
argument_list|(
name|SEND_DEV_RESET
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
name|abort
label|:
name|ncr53c9x_sched_msgout
argument_list|(
name|SEND_ABORT
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* From NetBSD.  These should go into CAM at some point */
end_comment

begin_define
define|#
directive|define
name|MSG_ISEXTENDED
parameter_list|(
name|m
parameter_list|)
value|((m) == MSG_EXTENDED)
end_define

begin_define
define|#
directive|define
name|MSG_IS1BYTE
parameter_list|(
name|m
parameter_list|)
define|\
value|((!MSG_ISEXTENDED(m)&& (m)< 0x20) || MSG_ISIDENTIFY(m))
end_define

begin_define
define|#
directive|define
name|MSG_IS2BYTE
parameter_list|(
name|m
parameter_list|)
value|(((m)& 0xf0) == 0x20)
end_define

begin_function
specifier|static
specifier|inline
name|int
name|__verify_msg_format
parameter_list|(
name|u_char
modifier|*
name|p
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|len
operator|==
literal|1
operator|&&
name|MSG_IS1BYTE
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|len
operator|==
literal|2
operator|&&
name|MSG_IS2BYTE
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|len
operator|>=
literal|3
operator|&&
name|MSG_ISEXTENDED
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
operator|&&
name|len
operator|==
name|p
index|[
literal|1
index|]
operator|+
literal|2
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Get an incoming message as initiator.  *  * The SCSI bus must already be in MESSAGE_IN_PHASE and there is a  * byte in the FIFO  */
end_comment

begin_function
specifier|static
name|void
name|ncr53c9x_msgin
parameter_list|(
name|struct
name|ncr53c9x_softc
modifier|*
name|sc
parameter_list|)
block|{
name|NCR_TRACE
argument_list|(
operator|(
literal|"[ncr53c9x_msgin(curmsglen:%ld)] "
operator|,
operator|(
name|long
operator|)
name|sc
operator|->
name|sc_imlen
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_imlen
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"msgin: no msg byte available\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Prepare for a new message.  A message should (according 	 * to the SCSI standard) be transmitted in one single 	 * MESSAGE_IN_PHASE. If we have been in some other phase, 	 * then this is a new message. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_prevphase
operator|!=
name|MESSAGE_IN_PHASE
operator|&&
name|sc
operator|->
name|sc_state
operator|!=
name|NCR_RESELECTED
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"phase change, dropping message, "
literal|"prev %d, state %d\n"
argument_list|,
name|sc
operator|->
name|sc_prevphase
argument_list|,
name|sc
operator|->
name|sc_state
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|NCR_DROP_MSGI
expr_stmt|;
name|sc
operator|->
name|sc_imlen
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * If we're going to reject the message, don't bother storing 	 * the incoming bytes.  But still, we need to ACK them. 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|NCR_DROP_MSGI
operator|)
operator|!=
literal|0
condition|)
block|{
name|NCRCMD
argument_list|(
name|sc
argument_list|,
name|NCRCMD_MSGOK
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"<dropping msg byte %x>"
argument_list|,
name|sc
operator|->
name|sc_imess
index|[
name|sc
operator|->
name|sc_imlen
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_imlen
operator|>=
name|NCR_MAX_MSG_LEN
condition|)
block|{
name|ncr53c9x_sched_msgout
argument_list|(
name|SEND_REJECT
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|NCR_DROP_MSGI
expr_stmt|;
block|}
else|else
block|{
name|u_char
modifier|*
name|pb
decl_stmt|;
name|int
name|plen
decl_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|sc_state
condition|)
block|{
comment|/* 		 * if received message is the first of reselection 		 * then first byte is selid, and then message 		 */
case|case
name|NCR_RESELECTED
case|:
name|pb
operator|=
name|sc
operator|->
name|sc_imess
operator|+
literal|1
expr_stmt|;
name|plen
operator|=
name|sc
operator|->
name|sc_imlen
operator|-
literal|1
expr_stmt|;
break|break;
default|default:
name|pb
operator|=
name|sc
operator|->
name|sc_imess
expr_stmt|;
name|plen
operator|=
name|sc
operator|->
name|sc_imlen
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|__verify_msg_format
argument_list|(
name|pb
argument_list|,
name|plen
argument_list|)
condition|)
goto|goto
name|gotit
goto|;
block|}
comment|/* Ack what we have so far */
name|NCRCMD
argument_list|(
name|sc
argument_list|,
name|NCRCMD_MSGOK
argument_list|)
expr_stmt|;
return|return;
name|gotit
label|:
name|NCR_MSGS
argument_list|(
operator|(
literal|"gotmsg(%x) state %d"
operator|,
name|sc
operator|->
name|sc_imess
index|[
literal|0
index|]
operator|,
name|sc
operator|->
name|sc_state
operator|)
argument_list|)
expr_stmt|;
comment|/* We got a complete message, flush the imess, */
comment|/* XXX nobody uses imlen below */
name|sc
operator|->
name|sc_imlen
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Now we should have a complete message (1 byte, 2 byte 	 * and moderately long extended messages).  We only handle 	 * extended messages which total length is shorter than 	 * NCR_MAX_MSG_LEN.  Longer messages will be amputated. 	 */
switch|switch
condition|(
name|sc
operator|->
name|sc_state
condition|)
block|{
name|struct
name|ncr53c9x_ecb
modifier|*
name|ecb
decl_stmt|;
name|struct
name|ncr53c9x_tinfo
modifier|*
name|ti
decl_stmt|;
name|struct
name|ncr53c9x_linfo
modifier|*
name|li
decl_stmt|;
name|int
name|lun
decl_stmt|;
case|case
name|NCR_CONNECTED
case|:
name|ecb
operator|=
name|sc
operator|->
name|sc_nexus
expr_stmt|;
name|ti
operator|=
operator|&
name|sc
operator|->
name|sc_tinfo
index|[
name|ecb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|sc_imess
index|[
literal|0
index|]
condition|)
block|{
case|case
name|MSG_CMDCOMPLETE
case|:
name|NCR_MSGS
argument_list|(
operator|(
literal|"cmdcomplete "
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dleft
operator|<
literal|0
condition|)
block|{
name|xpt_print_path
argument_list|(
name|ecb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"got %ld extra bytes\n"
argument_list|,
operator|-
operator|(
name|long
operator|)
name|sc
operator|->
name|sc_dleft
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_dleft
operator|=
literal|0
expr_stmt|;
block|}
name|ecb
operator|->
name|dleft
operator|=
operator|(
name|ecb
operator|->
name|flags
operator|&
name|ECB_TENTATIVE_DONE
operator|)
condition|?
literal|0
else|:
name|sc
operator|->
name|sc_dleft
expr_stmt|;
if|if
condition|(
operator|(
name|ecb
operator|->
name|flags
operator|&
name|ECB_SENSE
operator|)
operator|==
literal|0
condition|)
name|ecb
operator|->
name|ccb
operator|->
name|csio
operator|.
name|resid
operator|=
name|ecb
operator|->
name|dleft
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
name|NCR_CMDCOMPLETE
expr_stmt|;
break|break;
case|case
name|MSG_MESSAGE_REJECT
case|:
name|NCR_MSGS
argument_list|(
operator|(
literal|"msg reject (msgout=%x) "
operator|,
name|sc
operator|->
name|sc_msgout
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|sc_msgout
condition|)
block|{
case|case
name|SEND_TAG
case|:
comment|/* 				 * Target does not like tagged queuing. 				 *  - Flush the command queue 				 *  - Disable tagged queuing for the target 				 *  - Dequeue ecb from the queued array. 				 */
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"tagged queuing "
literal|"rejected: target %d\n"
argument_list|,
name|ecb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|)
expr_stmt|;
name|NCR_MSGS
argument_list|(
operator|(
literal|"(rejected sent tag)"
operator|)
argument_list|)
expr_stmt|;
name|NCRCMD
argument_list|(
name|sc
argument_list|,
name|NCRCMD_FLUSH
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ti
operator|->
name|flags
operator|&=
operator|~
name|T_TAG
expr_stmt|;
name|lun
operator|=
name|ecb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
name|li
operator|=
name|TINFO_LUN
argument_list|(
name|ti
argument_list|,
name|lun
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecb
operator|->
name|tag
index|[
literal|0
index|]
operator|&&
name|li
operator|->
name|queued
index|[
name|ecb
operator|->
name|tag
index|[
literal|1
index|]
index|]
operator|!=
name|NULL
condition|)
block|{
name|li
operator|->
name|queued
index|[
name|ecb
operator|->
name|tag
index|[
literal|1
index|]
index|]
operator|=
name|NULL
expr_stmt|;
name|li
operator|->
name|used
operator|--
expr_stmt|;
block|}
name|ecb
operator|->
name|tag
index|[
literal|0
index|]
operator|=
name|ecb
operator|->
name|tag
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|li
operator|->
name|untagged
operator|=
name|ecb
expr_stmt|;
name|li
operator|->
name|busy
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|SEND_SDTR
case|:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"sync transfer "
literal|"rejected: target %d\n"
argument_list|,
name|ecb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|NCR_SYNCHNEGO
expr_stmt|;
name|ti
operator|->
name|flags
operator|&=
operator|~
operator|(
name|T_NEGOTIATE
operator||
name|T_SYNCMODE
operator|)
expr_stmt|;
name|ncr53c9x_setsync
argument_list|(
name|sc
argument_list|,
name|ti
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEND_WDTR
case|:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"wide transfer "
literal|"rejected: target %d\n"
argument_list|,
name|ecb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|)
expr_stmt|;
name|ti
operator|->
name|flags
operator|&=
operator|~
operator|(
name|T_WIDE
operator||
name|T_WDTRSENT
operator|)
expr_stmt|;
name|ti
operator|->
name|width
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SEND_INIT_DET_ERR
case|:
goto|goto
name|abort
goto|;
block|}
break|break;
case|case
name|MSG_NOOP
case|:
name|NCR_MSGS
argument_list|(
operator|(
literal|"noop "
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MSG_HEAD_OF_Q_TAG
case|:
case|case
name|MSG_SIMPLE_Q_TAG
case|:
case|case
name|MSG_ORDERED_Q_TAG
case|:
name|NCR_MSGS
argument_list|(
operator|(
literal|"TAG %x:%x"
operator|,
name|sc
operator|->
name|sc_imess
index|[
literal|0
index|]
operator|,
name|sc
operator|->
name|sc_imess
index|[
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MSG_DISCONNECT
case|:
name|NCR_MSGS
argument_list|(
operator|(
literal|"disconnect "
operator|)
argument_list|)
expr_stmt|;
name|ti
operator|->
name|dconns
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
name|NCR_DISCONNECT
expr_stmt|;
comment|/* 			 * Mark the fact that all bytes have moved. The 			 * target may not bother to do a SAVE POINTERS 			 * at this stage. This flag will set the residual 			 * count to zero on MSG COMPLETE. 			 */
if|if
condition|(
name|sc
operator|->
name|sc_dleft
operator|==
literal|0
condition|)
name|ecb
operator|->
name|flags
operator||=
name|ECB_TENTATIVE_DONE
expr_stmt|;
break|break;
case|case
name|MSG_SAVEDATAPOINTER
case|:
name|NCR_MSGS
argument_list|(
operator|(
literal|"save datapointer "
operator|)
argument_list|)
expr_stmt|;
name|ecb
operator|->
name|daddr
operator|=
name|sc
operator|->
name|sc_dp
expr_stmt|;
name|ecb
operator|->
name|dleft
operator|=
name|sc
operator|->
name|sc_dleft
expr_stmt|;
break|break;
case|case
name|MSG_RESTOREPOINTERS
case|:
name|NCR_MSGS
argument_list|(
operator|(
literal|"restore datapointer "
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_dp
operator|=
name|ecb
operator|->
name|daddr
expr_stmt|;
name|sc
operator|->
name|sc_dleft
operator|=
name|ecb
operator|->
name|dleft
expr_stmt|;
break|break;
case|case
name|MSG_EXTENDED
case|:
name|NCR_MSGS
argument_list|(
operator|(
literal|"extended(%x) "
operator|,
name|sc
operator|->
name|sc_imess
index|[
literal|2
index|]
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|sc_imess
index|[
literal|2
index|]
condition|)
block|{
case|case
name|MSG_EXT_SDTR
case|:
name|NCR_MSGS
argument_list|(
operator|(
literal|"SDTR period %d, offset %d "
operator|,
name|sc
operator|->
name|sc_imess
index|[
literal|3
index|]
operator|,
name|sc
operator|->
name|sc_imess
index|[
literal|4
index|]
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_imess
index|[
literal|1
index|]
operator|!=
literal|3
condition|)
goto|goto
name|reject
goto|;
name|ti
operator|->
name|period
operator|=
name|sc
operator|->
name|sc_imess
index|[
literal|3
index|]
expr_stmt|;
name|ti
operator|->
name|offset
operator|=
name|sc
operator|->
name|sc_imess
index|[
literal|4
index|]
expr_stmt|;
name|ti
operator|->
name|flags
operator|&=
operator|~
name|T_NEGOTIATE
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_minsync
operator|==
literal|0
operator|||
name|ti
operator|->
name|offset
operator|==
literal|0
operator|||
name|ti
operator|->
name|period
operator|>
literal|124
condition|)
block|{
if|#
directive|if
literal|0
ifdef|#
directive|ifdef
name|NCR53C9X_DEBUG
block|xpt_print_path(ecb->ccb->ccb_h.path); 					printf("async mode\n");
endif|#
directive|endif
endif|#
directive|endif
name|ti
operator|->
name|flags
operator|&=
operator|~
name|T_SYNCMODE
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|NCR_SYNCHNEGO
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 						 * target initiated negotiation 						 */
name|ti
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|ncr53c9x_sched_msgout
argument_list|(
name|SEND_SDTR
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|p
decl_stmt|;
name|p
operator|=
name|ncr53c9x_stp2cpb
argument_list|(
name|sc
argument_list|,
name|ti
operator|->
name|period
argument_list|)
expr_stmt|;
name|ti
operator|->
name|period
operator|=
name|ncr53c9x_cpb2stp
argument_list|(
name|sc
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|NCR_SYNCHNEGO
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 						 * target initiated negotiation 						 */
if|if
condition|(
name|ti
operator|->
name|period
operator|<
name|sc
operator|->
name|sc_minsync
condition|)
name|ti
operator|->
name|period
operator|=
name|sc
operator|->
name|sc_minsync
expr_stmt|;
if|if
condition|(
name|ti
operator|->
name|offset
operator|>
literal|15
condition|)
name|ti
operator|->
name|offset
operator|=
literal|15
expr_stmt|;
name|ti
operator|->
name|flags
operator|&=
operator|~
name|T_SYNCMODE
expr_stmt|;
name|ncr53c9x_sched_msgout
argument_list|(
name|SEND_SDTR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* we are sync */
name|ti
operator|->
name|flags
operator||=
name|T_SYNCMODE
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|NCR_SYNCHNEGO
expr_stmt|;
name|ncr53c9x_setsync
argument_list|(
name|sc
argument_list|,
name|ti
argument_list|)
expr_stmt|;
break|break;
case|case
name|MSG_EXT_WDTR
case|:
ifdef|#
directive|ifdef
name|NCR53C9X_DEBUG
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"wide mode %d\n"
argument_list|,
name|sc
operator|->
name|sc_imess
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|sc_imess
index|[
literal|3
index|]
operator|==
literal|1
condition|)
block|{
name|ti
operator|->
name|cfg3
operator||=
name|NCRFASCFG3_EWIDE
expr_stmt|;
name|ncr53c9x_setsync
argument_list|(
name|sc
argument_list|,
name|ti
argument_list|)
expr_stmt|;
block|}
else|else
name|ti
operator|->
name|width
operator|=
literal|0
expr_stmt|;
comment|/* 				 * Device started width negotiation. 				 */
if|if
condition|(
operator|!
operator|(
name|ti
operator|->
name|flags
operator|&
name|T_WDTRSENT
operator|)
condition|)
name|ncr53c9x_sched_msgout
argument_list|(
name|SEND_WDTR
argument_list|)
expr_stmt|;
name|ti
operator|->
name|flags
operator|&=
operator|~
operator|(
name|T_WIDE
operator||
name|T_WDTRSENT
operator|)
expr_stmt|;
break|break;
default|default:
name|xpt_print_path
argument_list|(
name|ecb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"unrecognized MESSAGE EXTENDED;"
literal|" sending REJECT\n"
argument_list|)
expr_stmt|;
goto|goto
name|reject
goto|;
block|}
break|break;
default|default:
name|NCR_MSGS
argument_list|(
operator|(
literal|"ident "
operator|)
argument_list|)
expr_stmt|;
name|xpt_print_path
argument_list|(
name|ecb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"unrecognized MESSAGE; sending REJECT\n"
argument_list|)
expr_stmt|;
name|reject
label|:
name|ncr53c9x_sched_msgout
argument_list|(
name|SEND_REJECT
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|NCR_IDENTIFIED
case|:
comment|/* 		 * IDENTIFY message was received and queue tag is expected now 		 */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_imess
index|[
literal|0
index|]
operator|!=
name|MSG_SIMPLE_Q_TAG
operator|)
operator|||
operator|(
name|sc
operator|->
name|sc_msgify
operator|==
literal|0
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"TAG reselect without "
literal|"IDENTIFY; MSG %x; sending DEVICE RESET\n"
argument_list|,
name|sc
operator|->
name|sc_imess
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
goto|goto
name|reset
goto|;
block|}
operator|(
name|void
operator|)
name|ncr53c9x_reselect
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_msgify
argument_list|,
name|sc
operator|->
name|sc_imess
index|[
literal|0
index|]
argument_list|,
name|sc
operator|->
name|sc_imess
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|NCR_RESELECTED
case|:
if|if
condition|(
name|MSG_ISIDENTIFY
argument_list|(
name|sc
operator|->
name|sc_imess
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|sc
operator|->
name|sc_msgify
operator|=
name|sc
operator|->
name|sc_imess
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"reselect without IDENTIFY;"
literal|" MSG %x; sending DEVICE RESET\n"
argument_list|,
name|sc
operator|->
name|sc_imess
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
goto|goto
name|reset
goto|;
block|}
operator|(
name|void
operator|)
name|ncr53c9x_reselect
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_msgify
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unexpected MESSAGE IN; "
literal|"sending DEVICE RESET\n"
argument_list|)
expr_stmt|;
name|reset
label|:
name|ncr53c9x_sched_msgout
argument_list|(
name|SEND_DEV_RESET
argument_list|)
expr_stmt|;
break|break;
name|abort
label|:
name|ncr53c9x_sched_msgout
argument_list|(
name|SEND_ABORT
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* if we have more messages to send set ATN */
if|if
condition|(
name|sc
operator|->
name|sc_msgpriq
condition|)
name|NCRCMD
argument_list|(
name|sc
argument_list|,
name|NCRCMD_SETATN
argument_list|)
expr_stmt|;
comment|/* Ack last message byte */
name|NCRCMD
argument_list|(
name|sc
argument_list|,
name|NCRCMD_MSGOK
argument_list|)
expr_stmt|;
comment|/* Done, reset message pointer. */
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|NCR_DROP_MSGI
expr_stmt|;
name|sc
operator|->
name|sc_imlen
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send the highest priority, scheduled message  */
end_comment

begin_function
specifier|static
name|void
name|ncr53c9x_msgout
parameter_list|(
name|struct
name|ncr53c9x_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ncr53c9x_tinfo
modifier|*
name|ti
decl_stmt|;
name|struct
name|ncr53c9x_ecb
modifier|*
name|ecb
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|NCR_TRACE
argument_list|(
operator|(
literal|"[ncr53c9x_msgout(priq:%x, prevphase:%x)]"
operator|,
name|sc
operator|->
name|sc_msgpriq
operator|,
name|sc
operator|->
name|sc_prevphase
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * XXX - the NCR_ATN flag is not in sync with the actual ATN 	 *	 condition on the SCSI bus. The 53c9x chip 	 *	 automatically turns off ATN before sending the 	 *	 message byte.  (See also the comment below in the 	 *	 default case when picking out a message to send.) 	 */
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|NCR_ATN
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_prevphase
operator|!=
name|MESSAGE_OUT_PHASE
condition|)
block|{
name|new
label|:
name|NCRCMD
argument_list|(
name|sc
argument_list|,
name|NCRCMD_FLUSH
argument_list|)
expr_stmt|;
comment|/*			DELAY(1); */
name|sc
operator|->
name|sc_msgoutq
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_omlen
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|sc_prevphase
operator|==
name|MESSAGE_OUT_PHASE
condition|)
block|{
name|ncr53c9x_sched_msgout
argument_list|(
name|sc
operator|->
name|sc_msgoutq
argument_list|)
expr_stmt|;
goto|goto
name|new
goto|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"at line %d: unexpected "
literal|"MESSAGE OUT phase\n"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|sc_omlen
operator|==
literal|0
condition|)
block|{
comment|/* Pick up highest priority message */
name|sc
operator|->
name|sc_msgout
operator|=
name|sc
operator|->
name|sc_msgpriq
operator|&
operator|-
name|sc
operator|->
name|sc_msgpriq
expr_stmt|;
name|sc
operator|->
name|sc_msgoutq
operator||=
name|sc
operator|->
name|sc_msgout
expr_stmt|;
name|sc
operator|->
name|sc_msgpriq
operator|&=
operator|~
name|sc
operator|->
name|sc_msgout
expr_stmt|;
name|sc
operator|->
name|sc_omlen
operator|=
literal|1
expr_stmt|;
comment|/* "Default" message len */
switch|switch
condition|(
name|sc
operator|->
name|sc_msgout
condition|)
block|{
case|case
name|SEND_SDTR
case|:
name|ecb
operator|=
name|sc
operator|->
name|sc_nexus
expr_stmt|;
name|ti
operator|=
operator|&
name|sc
operator|->
name|sc_tinfo
index|[
name|ecb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
expr_stmt|;
name|sc
operator|->
name|sc_omess
index|[
literal|0
index|]
operator|=
name|MSG_EXTENDED
expr_stmt|;
name|sc
operator|->
name|sc_omess
index|[
literal|1
index|]
operator|=
name|MSG_EXT_SDTR_LEN
expr_stmt|;
name|sc
operator|->
name|sc_omess
index|[
literal|2
index|]
operator|=
name|MSG_EXT_SDTR
expr_stmt|;
name|sc
operator|->
name|sc_omess
index|[
literal|3
index|]
operator|=
name|ti
operator|->
name|period
expr_stmt|;
name|sc
operator|->
name|sc_omess
index|[
literal|4
index|]
operator|=
name|ti
operator|->
name|offset
expr_stmt|;
name|sc
operator|->
name|sc_omlen
operator|=
literal|5
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|NCR_SYNCHNEGO
operator|)
operator|==
literal|0
condition|)
block|{
name|ti
operator|->
name|flags
operator||=
name|T_SYNCMODE
expr_stmt|;
name|ncr53c9x_setsync
argument_list|(
name|sc
argument_list|,
name|ti
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SEND_WDTR
case|:
name|ecb
operator|=
name|sc
operator|->
name|sc_nexus
expr_stmt|;
name|ti
operator|=
operator|&
name|sc
operator|->
name|sc_tinfo
index|[
name|ecb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
expr_stmt|;
name|sc
operator|->
name|sc_omess
index|[
literal|0
index|]
operator|=
name|MSG_EXTENDED
expr_stmt|;
name|sc
operator|->
name|sc_omess
index|[
literal|1
index|]
operator|=
name|MSG_EXT_WDTR_LEN
expr_stmt|;
name|sc
operator|->
name|sc_omess
index|[
literal|2
index|]
operator|=
name|MSG_EXT_WDTR
expr_stmt|;
name|sc
operator|->
name|sc_omess
index|[
literal|3
index|]
operator|=
name|ti
operator|->
name|width
expr_stmt|;
name|sc
operator|->
name|sc_omlen
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|SEND_IDENTIFY
case|:
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|!=
name|NCR_CONNECTED
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"at line %d: no "
literal|"nexus\n"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
name|ecb
operator|=
name|sc
operator|->
name|sc_nexus
expr_stmt|;
name|sc
operator|->
name|sc_omess
index|[
literal|0
index|]
operator|=
name|MSG_IDENTIFY
argument_list|(
name|ecb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEND_TAG
case|:
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|!=
name|NCR_CONNECTED
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"at line %d: no "
literal|"nexus\n"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
name|ecb
operator|=
name|sc
operator|->
name|sc_nexus
expr_stmt|;
name|sc
operator|->
name|sc_omess
index|[
literal|0
index|]
operator|=
name|ecb
operator|->
name|tag
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|sc_omess
index|[
literal|1
index|]
operator|=
name|ecb
operator|->
name|tag
index|[
literal|1
index|]
expr_stmt|;
name|sc
operator|->
name|sc_omlen
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|SEND_DEV_RESET
case|:
name|sc
operator|->
name|sc_flags
operator||=
name|NCR_ABORTING
expr_stmt|;
name|sc
operator|->
name|sc_omess
index|[
literal|0
index|]
operator|=
name|MSG_BUS_DEV_RESET
expr_stmt|;
name|ecb
operator|=
name|sc
operator|->
name|sc_nexus
expr_stmt|;
name|ti
operator|=
operator|&
name|sc
operator|->
name|sc_tinfo
index|[
name|ecb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
expr_stmt|;
name|ti
operator|->
name|flags
operator|&=
operator|~
name|T_SYNCMODE
expr_stmt|;
if|if
condition|(
operator|(
name|ti
operator|->
name|flags
operator|&
name|T_SYNCHOFF
operator|)
operator|==
literal|0
condition|)
comment|/* We can re-start sync negotiation */
name|ti
operator|->
name|flags
operator||=
name|T_NEGOTIATE
expr_stmt|;
break|break;
case|case
name|SEND_PARITY_ERROR
case|:
name|sc
operator|->
name|sc_omess
index|[
literal|0
index|]
operator|=
name|MSG_PARITY_ERROR
expr_stmt|;
break|break;
case|case
name|SEND_ABORT
case|:
name|sc
operator|->
name|sc_flags
operator||=
name|NCR_ABORTING
expr_stmt|;
name|sc
operator|->
name|sc_omess
index|[
literal|0
index|]
operator|=
name|MSG_ABORT
expr_stmt|;
break|break;
case|case
name|SEND_INIT_DET_ERR
case|:
name|sc
operator|->
name|sc_omess
index|[
literal|0
index|]
operator|=
name|MSG_INITIATOR_DET_ERR
expr_stmt|;
break|break;
case|case
name|SEND_REJECT
case|:
name|sc
operator|->
name|sc_omess
index|[
literal|0
index|]
operator|=
name|MSG_MESSAGE_REJECT
expr_stmt|;
break|break;
default|default:
comment|/* 			 * We normally do not get here, since the chip 			 * automatically turns off ATN before the last 			 * byte of a message is sent to the target. 			 * However, if the target rejects our (multi-byte) 			 * message early by switching to MSG IN phase 			 * ATN remains on, so the target may return to 			 * MSG OUT phase. If there are no scheduled messages 			 * left we send a NO-OP. 			 * 			 * XXX - Note that this leaves no useful purpose for 			 * the NCR_ATN flag. 			 */
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|NCR_ATN
expr_stmt|;
name|sc
operator|->
name|sc_omess
index|[
literal|0
index|]
operator|=
name|MSG_NOOP
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|sc_omp
operator|=
name|sc
operator|->
name|sc_omess
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ncr53c9x_debug
operator|&
name|NCR_SHOWMSGS
condition|)
block|{
name|int
name|i
decl_stmt|;
name|NCR_MSGS
argument_list|(
operator|(
literal|"<msgout:"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_omlen
condition|;
name|i
operator|++
control|)
name|NCR_MSGS
argument_list|(
operator|(
literal|" %02x"
operator|,
name|sc
operator|->
name|sc_omess
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
name|NCR_MSGS
argument_list|(
operator|(
literal|"> "
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|sc_rev
operator|==
name|NCR_VARIANT_FAS366
condition|)
block|{
comment|/* 		 * XXX fifo size 		 */
name|ncr53c9x_flushfifo
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ncr53c9x_wrfifo
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_omp
argument_list|,
name|sc
operator|->
name|sc_omlen
argument_list|)
expr_stmt|;
name|NCRCMD
argument_list|(
name|sc
argument_list|,
name|NCRCMD_TRANS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* (re)send the message */
name|size
operator|=
name|min
argument_list|(
name|sc
operator|->
name|sc_omlen
argument_list|,
name|sc
operator|->
name|sc_maxxfer
argument_list|)
expr_stmt|;
name|NCRDMA_SETUP
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_omp
argument_list|,
operator|&
name|sc
operator|->
name|sc_omlen
argument_list|,
literal|0
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
comment|/* Program the SCSI counter */
name|NCR_SET_COUNT
argument_list|(
name|sc
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* Load the count in and start the message-out transfer */
name|NCRCMD
argument_list|(
name|sc
argument_list|,
name|NCRCMD_NOP
operator||
name|NCRCMD_DMA
argument_list|)
expr_stmt|;
name|NCRCMD
argument_list|(
name|sc
argument_list|,
name|NCRCMD_TRANS
operator||
name|NCRCMD_DMA
argument_list|)
expr_stmt|;
name|NCRDMA_GO
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This is the most critical part of the driver, and has to know  * how to deal with *all* error conditions and phases from the SCSI  * bus. If there are no errors and the DMA was active, then call the  * DMA pseudo-interrupt handler. If this returns 1, then that was it  * and we can return from here without further processing.  *  * Most of this needs verifying.  */
end_comment

begin_function
name|void
name|ncr53c9x_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ncr53c9x_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ncr53c9x_ecb
modifier|*
name|ecb
decl_stmt|;
name|struct
name|ncr53c9x_tinfo
modifier|*
name|ti
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|int
name|nfifo
decl_stmt|;
name|NCR_INTS
argument_list|(
operator|(
literal|"[ncr53c9x_intr: state %d]"
operator|,
name|sc
operator|->
name|sc_state
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NCRDMA_ISINTR
argument_list|(
name|sc
argument_list|)
condition|)
return|return;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|again
label|:
comment|/* and what do the registers say... */
name|ncr53c9x_readregs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * At the moment, only a SCSI Bus Reset or Illegal 	 * Command are classed as errors. A disconnect is a 	 * valid condition, and we let the code check is the 	 * "NCR_BUSFREE_OK" flag was set before declaring it 	 * and error. 	 * 	 * Also, the status register tells us about "Gross 	 * Errors" and "Parity errors". Only the Gross Error 	 * is really bad, and the parity errors are dealt 	 * with later 	 * 	 * TODO 	 *	If there are too many parity error, go to slow 	 *	cable mode ? 	 */
comment|/* SCSI Reset */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_espintr
operator|&
name|NCRINTR_SBR
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|NCR_READ_REG
argument_list|(
name|sc
argument_list|,
name|NCR_FFLAG
argument_list|)
operator|&
name|NCRFIFO_FF
operator|)
operator|!=
literal|0
condition|)
block|{
name|NCRCMD
argument_list|(
name|sc
argument_list|,
name|NCRCMD_FLUSH
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|!=
name|NCR_SBR
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"SCSI bus reset\n"
argument_list|)
expr_stmt|;
name|ncr53c9x_init
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Restart everything */
goto|goto
name|out
goto|;
block|}
if|#
directive|if
literal|0
comment|/*XXX*/
block|printf("<expected bus reset: " 		    "[intr %x, stat %x, step %d]>\n", 		    sc->sc_espintr, sc->sc_espstat, sc->sc_espstep);
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|sc_nexus
operator|!=
name|NULL
condition|)
name|panic
argument_list|(
literal|"%s: nexus in reset state"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|sched
goto|;
block|}
name|ecb
operator|=
name|sc
operator|->
name|sc_nexus
expr_stmt|;
define|#
directive|define
name|NCRINTR_ERR
value|(NCRINTR_SBR|NCRINTR_ILL)
if|if
condition|(
name|sc
operator|->
name|sc_espintr
operator|&
name|NCRINTR_ERR
operator|||
name|sc
operator|->
name|sc_espstat
operator|&
name|NCRSTAT_GE
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_espstat
operator|&
name|NCRSTAT_GE
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Gross Error; no target ? */
if|if
condition|(
name|NCR_READ_REG
argument_list|(
name|sc
argument_list|,
name|NCR_FFLAG
argument_list|)
operator|&
name|NCRFIFO_FF
condition|)
block|{
name|NCRCMD
argument_list|(
name|sc
argument_list|,
name|NCRCMD_FLUSH
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
name|NCR_CONNECTED
operator|||
name|sc
operator|->
name|sc_state
operator|==
name|NCR_SELECTING
condition|)
block|{
name|ecb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SEL_TIMEOUT
expr_stmt|;
name|ncr53c9x_done
argument_list|(
name|sc
argument_list|,
name|ecb
argument_list|)
expr_stmt|;
block|}
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_espintr
operator|&
name|NCRINTR_ILL
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|NCR_EXPECT_ILLCMD
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * Eat away "Illegal command" interrupt 				 * on a ESP100 caused by a re-selection 				 * while we were trying to select 				 * another target. 				 */
ifdef|#
directive|ifdef
name|DEBUG
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"ESP100 work-around "
literal|"activated\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|NCR_EXPECT_ILLCMD
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* illegal command, out of sync ? */
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"illegal command: 0x%x "
literal|"(state %d, phase %x, prevphase %x)\n"
argument_list|,
name|sc
operator|->
name|sc_lastcmd
argument_list|,
name|sc
operator|->
name|sc_state
argument_list|,
name|sc
operator|->
name|sc_phase
argument_list|,
name|sc
operator|->
name|sc_prevphase
argument_list|)
expr_stmt|;
if|if
condition|(
name|NCR_READ_REG
argument_list|(
name|sc
argument_list|,
name|NCR_FFLAG
argument_list|)
operator|&
name|NCRFIFO_FF
condition|)
block|{
name|NCRCMD
argument_list|(
name|sc
argument_list|,
name|NCRCMD_FLUSH
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|ncr53c9x_init
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Restart everything */
goto|goto
name|out
goto|;
block|}
block|}
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|NCR_EXPECT_ILLCMD
expr_stmt|;
comment|/* 	 * Call if DMA is active. 	 * 	 * If DMA_INTR returns true, then maybe go 'round the loop 	 * again in case there is no more DMA queued, but a phase 	 * change is expected. 	 */
if|if
condition|(
name|NCRDMA_ISACTIVE
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|int
name|r
init|=
name|NCRDMA_INTR
argument_list|(
name|sc
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
operator|-
literal|1
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"DMA error; resetting\n"
argument_list|)
expr_stmt|;
name|ncr53c9x_init
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* If DMA active here, then go back to work... */
if|if
condition|(
name|NCRDMA_ISACTIVE
argument_list|(
name|sc
argument_list|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_espstat
operator|&
name|NCRSTAT_TC
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * DMA not completed.  If we can not find a 			 * acceptable explanation, print a diagnostic. 			 */
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
name|NCR_SELECTING
condition|)
comment|/* 				 * This can happen if we are reselected 				 * while using DMA to select a target. 				 */
comment|/*void*/
empty_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_prevphase
operator|==
name|MESSAGE_OUT_PHASE
condition|)
block|{
comment|/* 				 * Our (multi-byte) message (eg SDTR) was 				 * interrupted by the target to send 				 * a MSG REJECT. 				 * Print diagnostic if current phase 				 * is not MESSAGE IN. 				 */
if|if
condition|(
name|sc
operator|->
name|sc_phase
operator|!=
name|MESSAGE_IN_PHASE
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"!TC on MSGOUT"
literal|" [intr %x, stat %x, step %d]"
literal|" prevphase %x, resid %lx\n"
argument_list|,
name|sc
operator|->
name|sc_espintr
argument_list|,
name|sc
operator|->
name|sc_espstat
argument_list|,
name|sc
operator|->
name|sc_espstep
argument_list|,
name|sc
operator|->
name|sc_prevphase
argument_list|,
operator|(
name|u_long
operator|)
name|sc
operator|->
name|sc_omlen
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_dleft
operator|==
literal|0
condition|)
block|{
comment|/* 				 * The DMA operation was started for 				 * a DATA transfer. Print a diagnostic 				 * if the DMA counter and TC bit 				 * appear to be out of sync. 				 * 				 * XXX This is fatal and usually means that 				 *     the DMA engine is hopelessly out of 				 *     sync with reality.  A disk is likely 				 *     getting spammed at this point. 				 */
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"!TC on DATA XFER"
literal|" [intr %x, stat %x, step %d]"
literal|" prevphase %x, resid %x\n"
argument_list|,
name|sc
operator|->
name|sc_espintr
argument_list|,
name|sc
operator|->
name|sc_espstat
argument_list|,
name|sc
operator|->
name|sc_espstep
argument_list|,
name|sc
operator|->
name|sc_prevphase
argument_list|,
name|ecb
condition|?
name|ecb
operator|->
name|dleft
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"esp: unrecoverable DMA error"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Check for less serious errors. 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_espstat
operator|&
name|NCRSTAT_PE
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"SCSI bus parity error\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_prevphase
operator|==
name|MESSAGE_IN_PHASE
condition|)
name|ncr53c9x_sched_msgout
argument_list|(
name|SEND_PARITY_ERROR
argument_list|)
expr_stmt|;
else|else
name|ncr53c9x_sched_msgout
argument_list|(
name|SEND_INIT_DET_ERR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_espintr
operator|&
name|NCRINTR_DIS
operator|)
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_msgify
operator|=
literal|0
expr_stmt|;
name|NCR_INTS
argument_list|(
operator|(
literal|"<DISC [intr %x, stat %x, step %d]>"
operator|,
name|sc
operator|->
name|sc_espintr
operator|,
name|sc
operator|->
name|sc_espstat
operator|,
name|sc
operator|->
name|sc_espstep
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NCR_READ_REG
argument_list|(
name|sc
argument_list|,
name|NCR_FFLAG
argument_list|)
operator|&
name|NCRFIFO_FF
condition|)
block|{
name|NCRCMD
argument_list|(
name|sc
argument_list|,
name|NCRCMD_FLUSH
argument_list|)
expr_stmt|;
comment|/*			DELAY(1); */
block|}
comment|/* 		 * This command must (apparently) be issued within 		 * 250mS of a disconnect. So here you are... 		 */
name|NCRCMD
argument_list|(
name|sc
argument_list|,
name|NCRCMD_ENSEL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|sc_state
condition|)
block|{
case|case
name|NCR_RESELECTED
case|:
goto|goto
name|sched
goto|;
case|case
name|NCR_SELECTING
case|:
block|{
name|struct
name|ncr53c9x_linfo
modifier|*
name|li
decl_stmt|;
name|ecb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SEL_TIMEOUT
expr_stmt|;
comment|/* Selection timeout -- discard all LUNs if empty */
name|ti
operator|=
operator|&
name|sc
operator|->
name|sc_tinfo
index|[
name|ecb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
expr_stmt|;
name|li
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|ti
operator|->
name|luns
argument_list|)
expr_stmt|;
while|while
condition|(
name|li
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|li
operator|->
name|untagged
operator|==
name|NULL
operator|&&
name|li
operator|->
name|used
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|li
operator|->
name|lun
operator|<
name|NCR_NLUN
condition|)
name|ti
operator|->
name|lun
index|[
name|li
operator|->
name|lun
index|]
operator|=
name|NULL
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|li
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|li
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
comment|/* 					 * Restart the search at the beginning 					 */
name|li
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|ti
operator|->
name|luns
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|li
operator|=
name|LIST_NEXT
argument_list|(
name|li
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
goto|goto
name|finish
goto|;
block|}
case|case
name|NCR_CONNECTED
case|:
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|NCR_SYNCHNEGO
operator|)
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|NCR53C9X_DEBUG
if|if
condition|(
name|ecb
operator|!=
name|NULL
condition|)
name|xpt_print_path
argument_list|(
name|ecb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sync nego not completed!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ti
operator|=
operator|&
name|sc
operator|->
name|sc_tinfo
index|[
name|ecb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|NCR_SYNCHNEGO
expr_stmt|;
name|ti
operator|->
name|flags
operator|&=
operator|~
operator|(
name|T_NEGOTIATE
operator||
name|T_SYNCMODE
operator|)
expr_stmt|;
block|}
comment|/* it may be OK to disconnect */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|NCR_ABORTING
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Section 5.1.1 of the SCSI 2 spec 				 * suggests issuing a REQUEST SENSE 				 * following an unexpected disconnect. 				 * Some devices go into a contingent 				 * allegiance condition when 				 * disconnecting, and this is necessary 				 * to clean up their state. 				 */
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unexpected "
literal|"disconnect [state %d, intr %x, stat %x, "
literal|"phase(c %x, p %x)]; "
argument_list|,
name|sc
operator|->
name|sc_state
argument_list|,
name|sc
operator|->
name|sc_espintr
argument_list|,
name|sc
operator|->
name|sc_espstat
argument_list|,
name|sc
operator|->
name|sc_phase
argument_list|,
name|sc
operator|->
name|sc_prevphase
argument_list|)
expr_stmt|;
comment|/* 				 * XXX This will cause a chip reset and will 				 *     prevent us from finding out the real 				 *     problem with the device.  However, it's 				 *     neccessary until a way can be found to 				 *     safely cancel the DMA that is in 				 *     progress. 				 */
if|if
condition|(
literal|1
operator|||
operator|(
name|ecb
operator|->
name|flags
operator|&
name|ECB_SENSE
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"resetting\n"
argument_list|)
expr_stmt|;
goto|goto
name|reset
goto|;
block|}
name|printf
argument_list|(
literal|"sending REQUEST SENSE\n"
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|ncr53c9x_timeout
argument_list|,
name|ecb
argument_list|,
name|ecb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
argument_list|)
expr_stmt|;
name|ncr53c9x_sense
argument_list|(
name|sc
argument_list|,
name|ecb
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ecb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_CMD_TIMEOUT
expr_stmt|;
goto|goto
name|finish
goto|;
case|case
name|NCR_DISCONNECT
case|:
name|sc
operator|->
name|sc_nexus
operator|=
name|NULL
expr_stmt|;
goto|goto
name|sched
goto|;
case|case
name|NCR_CMDCOMPLETE
case|:
name|ecb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
block|}
switch|switch
condition|(
name|sc
operator|->
name|sc_state
condition|)
block|{
case|case
name|NCR_SBR
case|:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"waiting for Bus Reset to happen\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
case|case
name|NCR_RESELECTED
case|:
comment|/* 		 * we must be continuing a message ? 		 */
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unhandled reselect continuation, "
literal|"state %d, intr %02x\n"
argument_list|,
name|sc
operator|->
name|sc_state
argument_list|,
name|sc
operator|->
name|sc_espintr
argument_list|)
expr_stmt|;
name|ncr53c9x_init
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
break|break;
case|case
name|NCR_IDENTIFIED
case|:
name|ecb
operator|=
name|sc
operator|->
name|sc_nexus
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_phase
operator|!=
name|MESSAGE_IN_PHASE
condition|)
block|{
name|int
name|i
init|=
operator|(
name|NCR_READ_REG
argument_list|(
name|sc
argument_list|,
name|NCR_FFLAG
argument_list|)
operator|&
name|NCRFIFO_FF
operator|)
decl_stmt|;
comment|/* 			 * Things are seriously screwed up. 			 * Pull the brakes, i.e. reset 			 */
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"target didn't send tag: %d "
literal|"bytes in fifo\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Drain and display fifo */
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"[%d] "
argument_list|,
name|NCR_READ_REG
argument_list|(
name|sc
argument_list|,
name|NCR_FIFO
argument_list|)
argument_list|)
expr_stmt|;
name|ncr53c9x_init
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
else|else
goto|goto
name|msgin
goto|;
case|case
name|NCR_IDLE
case|:
case|case
name|NCR_SELECTING
case|:
name|ecb
operator|=
name|sc
operator|->
name|sc_nexus
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_espintr
operator|&
name|NCRINTR_RESEL
condition|)
block|{
name|sc
operator|->
name|sc_msgpriq
operator|=
name|sc
operator|->
name|sc_msgout
operator|=
name|sc
operator|->
name|sc_msgoutq
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|=
literal|0
expr_stmt|;
comment|/* 			 * If we're trying to select a 			 * target ourselves, push our command 			 * back into the ready list. 			 */
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
name|NCR_SELECTING
condition|)
block|{
name|NCR_INTS
argument_list|(
operator|(
literal|"backoff selector "
operator|)
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|ncr53c9x_timeout
argument_list|,
name|ecb
argument_list|,
name|ecb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
argument_list|)
expr_stmt|;
name|ncr53c9x_dequeue
argument_list|(
name|sc
argument_list|,
name|ecb
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|ready_list
argument_list|,
name|ecb
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|ecb
operator|->
name|flags
operator||=
name|ECB_READY
expr_stmt|;
name|ecb
operator|=
name|sc
operator|->
name|sc_nexus
operator|=
name|NULL
expr_stmt|;
block|}
name|sc
operator|->
name|sc_state
operator|=
name|NCR_RESELECTED
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_phase
operator|!=
name|MESSAGE_IN_PHASE
condition|)
block|{
comment|/* 				 * Things are seriously screwed up. 				 * Pull the brakes, i.e. reset 				 */
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"target didn't "
literal|"identify\n"
argument_list|)
expr_stmt|;
name|ncr53c9x_init
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 			 * The C90 only inhibits FIFO writes until reselection 			 * is complete instead of waiting until the interrupt 			 * status register has been read.  So, if the reselect 			 * happens while we were entering command bytes (for 			 * another target) some of those bytes can appear in 			 * the FIFO here, after the interrupt is taken. 			 * 			 * To remedy this situation, pull the Selection ID 			 * and Identify message from the FIFO directly, and 			 * ignore any extraneous fifo contents. Also, set 			 * a flag that allows one Illegal Command Interrupt 			 * to occur which the chip also generates as a result 			 * of writing to the FIFO during a reselect. 			 */
if|if
condition|(
name|sc
operator|->
name|sc_rev
operator|==
name|NCR_VARIANT_ESP100
condition|)
block|{
name|nfifo
operator|=
name|NCR_READ_REG
argument_list|(
name|sc
argument_list|,
name|NCR_FFLAG
argument_list|)
operator|&
name|NCRFIFO_FF
expr_stmt|;
name|sc
operator|->
name|sc_imess
index|[
literal|0
index|]
operator|=
name|NCR_READ_REG
argument_list|(
name|sc
argument_list|,
name|NCR_FIFO
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_imess
index|[
literal|1
index|]
operator|=
name|NCR_READ_REG
argument_list|(
name|sc
argument_list|,
name|NCR_FIFO
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_imlen
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|nfifo
operator|!=
literal|2
condition|)
block|{
comment|/* Flush the rest */
name|NCRCMD
argument_list|(
name|sc
argument_list|,
name|NCRCMD_FLUSH
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_flags
operator||=
name|NCR_EXPECT_ILLCMD
expr_stmt|;
if|if
condition|(
name|nfifo
operator|>
literal|2
condition|)
name|nfifo
operator|=
literal|2
expr_stmt|;
comment|/* We fixed it.. */
block|}
else|else
name|nfifo
operator|=
name|ncr53c9x_rdfifo
argument_list|(
name|sc
argument_list|,
name|NCR_RDFIFO_START
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfifo
operator|!=
literal|2
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"RESELECT: %d bytes "
literal|"in FIFO! [intr %x, stat %x, step %d, "
literal|"prevphase %x]\n"
argument_list|,
name|nfifo
argument_list|,
name|sc
operator|->
name|sc_espintr
argument_list|,
name|sc
operator|->
name|sc_espstat
argument_list|,
name|sc
operator|->
name|sc_espstep
argument_list|,
name|sc
operator|->
name|sc_prevphase
argument_list|)
expr_stmt|;
name|ncr53c9x_init
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|sc
operator|->
name|sc_selid
operator|=
name|sc
operator|->
name|sc_imess
index|[
literal|0
index|]
expr_stmt|;
name|NCR_INTS
argument_list|(
operator|(
literal|"selid=%02x "
operator|,
name|sc
operator|->
name|sc_selid
operator|)
argument_list|)
expr_stmt|;
comment|/* Handle identify message */
name|ncr53c9x_msgin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|!=
name|NCR_CONNECTED
operator|&&
name|sc
operator|->
name|sc_state
operator|!=
name|NCR_IDENTIFIED
condition|)
block|{
comment|/* IDENTIFY fail?! */
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"identify failed, "
literal|"state %d, intr %02x\n"
argument_list|,
name|sc
operator|->
name|sc_state
argument_list|,
name|sc
operator|->
name|sc_espintr
argument_list|)
expr_stmt|;
name|ncr53c9x_init
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
goto|goto
name|shortcut
goto|;
comment|/* ie. next phase expected soon */
block|}
define|#
directive|define
name|NCRINTR_DONE
value|(NCRINTR_FC|NCRINTR_BS)
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_espintr
operator|&
name|NCRINTR_DONE
operator|)
operator|==
name|NCRINTR_DONE
condition|)
block|{
comment|/* 			 * Arbitration won; examine the `step' register 			 * to determine how far the selection could progress. 			 */
if|if
condition|(
name|ecb
operator|==
name|NULL
condition|)
block|{
comment|/* 				 * When doing path inquiry during boot 				 * FAS100A trigger a stray interrupt which 				 * we just ignore instead of panicing. 				 */
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
name|NCR_IDLE
operator|&&
name|sc
operator|->
name|sc_espstep
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
name|panic
argument_list|(
literal|"ncr53c9x: no nexus"
argument_list|)
expr_stmt|;
block|}
name|ti
operator|=
operator|&
name|sc
operator|->
name|sc_tinfo
index|[
name|ecb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|sc_espstep
condition|)
block|{
case|case
literal|0
case|:
comment|/* 				 * The target did not respond with a 				 * message out phase - probably an old 				 * device that doesn't recognize ATN. 				 * Clear ATN and just continue, the 				 * target should be in the command 				 * phase. 				 * XXXX check for command phase? 				 */
name|NCRCMD
argument_list|(
name|sc
argument_list|,
name|NCRCMD_RSTATN
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
if|if
condition|(
operator|(
name|ti
operator|->
name|flags
operator|&
name|T_NEGOTIATE
operator|)
operator|==
literal|0
operator|&&
name|ecb
operator|->
name|tag
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"step 1& "
literal|"!NEG\n"
argument_list|)
expr_stmt|;
goto|goto
name|reset
goto|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_phase
operator|!=
name|MESSAGE_OUT_PHASE
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"!MSGOUT\n"
argument_list|)
expr_stmt|;
goto|goto
name|reset
goto|;
block|}
if|if
condition|(
name|ti
operator|->
name|flags
operator|&
name|T_WIDE
condition|)
block|{
name|ti
operator|->
name|flags
operator||=
name|T_WDTRSENT
expr_stmt|;
name|ncr53c9x_sched_msgout
argument_list|(
name|SEND_WDTR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ti
operator|->
name|flags
operator|&
name|T_NEGOTIATE
condition|)
block|{
comment|/* Start negotiating */
name|sc
operator|->
name|sc_flags
operator||=
name|NCR_SYNCHNEGO
expr_stmt|;
if|if
condition|(
name|ecb
operator|->
name|tag
index|[
literal|0
index|]
condition|)
name|ncr53c9x_sched_msgout
argument_list|(
name|SEND_TAG
operator||
name|SEND_SDTR
argument_list|)
expr_stmt|;
else|else
name|ncr53c9x_sched_msgout
argument_list|(
name|SEND_SDTR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Could not do ATN3 so send TAG */
name|ncr53c9x_sched_msgout
argument_list|(
name|SEND_TAG
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_prevphase
operator|=
name|MESSAGE_OUT_PHASE
expr_stmt|;
comment|/* XXXX */
break|break;
case|case
literal|3
case|:
comment|/* 				 * Grr, this is supposed to mean 				 * "target left command phase  prematurely". 				 * It seems to happen regularly when 				 * sync mode is on. 				 * Look at FIFO to see if command went out. 				 * (Timing problems?) 				 */
if|if
condition|(
name|sc
operator|->
name|sc_features
operator|&
name|NCR_F_DMASELECT
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_cmdlen
operator|==
literal|0
condition|)
comment|/* Hope for the best.. */
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|NCR_READ_REG
argument_list|(
name|sc
argument_list|,
name|NCR_FFLAG
argument_list|)
operator|&
name|NCRFIFO_FF
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Hope for the best.. */
break|break;
block|}
name|printf
argument_list|(
literal|"(%s:%d:%d): selection failed;"
literal|" %d left in FIFO "
literal|"[intr %x, stat %x, step %d]\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|ecb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|ecb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
name|NCR_READ_REG
argument_list|(
name|sc
argument_list|,
name|NCR_FFLAG
argument_list|)
operator|&
name|NCRFIFO_FF
argument_list|,
name|sc
operator|->
name|sc_espintr
argument_list|,
name|sc
operator|->
name|sc_espstat
argument_list|,
name|sc
operator|->
name|sc_espstep
argument_list|)
expr_stmt|;
name|NCRCMD
argument_list|(
name|sc
argument_list|,
name|NCRCMD_FLUSH
argument_list|)
expr_stmt|;
name|ncr53c9x_sched_msgout
argument_list|(
name|SEND_ABORT
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
case|case
literal|2
case|:
comment|/* Select stuck at Command Phase */
name|NCRCMD
argument_list|(
name|sc
argument_list|,
name|NCRCMD_FLUSH
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
if|if
condition|(
name|sc
operator|->
name|sc_features
operator|&
name|NCR_F_DMASELECT
operator|&&
name|sc
operator|->
name|sc_cmdlen
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"(%s:%d:%d): select; "
literal|"%lu left in DMA buffer "
literal|"[intr %x, stat %x, step %d]\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|ecb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|ecb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
operator|(
name|u_long
operator|)
name|sc
operator|->
name|sc_cmdlen
argument_list|,
name|sc
operator|->
name|sc_espintr
argument_list|,
name|sc
operator|->
name|sc_espstat
argument_list|,
name|sc
operator|->
name|sc_espstep
argument_list|)
expr_stmt|;
comment|/* So far, everything went fine */
break|break;
block|}
name|sc
operator|->
name|sc_prevphase
operator|=
name|INVALID_PHASE
expr_stmt|;
comment|/* ?? */
comment|/* Do an implicit RESTORE POINTERS. */
name|sc
operator|->
name|sc_dp
operator|=
name|ecb
operator|->
name|daddr
expr_stmt|;
name|sc
operator|->
name|sc_dleft
operator|=
name|ecb
operator|->
name|dleft
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
name|NCR_CONNECTED
expr_stmt|;
break|break;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unexpected status after "
literal|"select: [intr %x, stat %x, step %x]\n"
argument_list|,
name|sc
operator|->
name|sc_espintr
argument_list|,
name|sc
operator|->
name|sc_espstat
argument_list|,
name|sc
operator|->
name|sc_espstep
argument_list|)
expr_stmt|;
name|NCRCMD
argument_list|(
name|sc
argument_list|,
name|NCRCMD_FLUSH
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|reset
goto|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
name|NCR_IDLE
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"stray interrupt\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
break|break;
case|case
name|NCR_CONNECTED
case|:
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|NCR_ICCS
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* "Initiate Command Complete Steps" in progress */
name|u_char
name|msg
decl_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|NCR_ICCS
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_espintr
operator|&
name|NCRINTR_DONE
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"ICCS: "
literal|": [intr %x, stat %x, step %x]\n"
argument_list|,
name|sc
operator|->
name|sc_espintr
argument_list|,
name|sc
operator|->
name|sc_espstat
argument_list|,
name|sc
operator|->
name|sc_espstep
argument_list|)
expr_stmt|;
block|}
name|ncr53c9x_rdfifo
argument_list|(
name|sc
argument_list|,
name|NCR_RDFIFO_START
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_imlen
operator|<
literal|2
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"can't get status, "
literal|"only %d bytes\n"
argument_list|,
operator|(
name|int
operator|)
name|sc
operator|->
name|sc_imlen
argument_list|)
expr_stmt|;
name|ecb
operator|->
name|stat
operator|=
name|sc
operator|->
name|sc_imess
index|[
name|sc
operator|->
name|sc_imlen
operator|-
literal|2
index|]
expr_stmt|;
name|msg
operator|=
name|sc
operator|->
name|sc_imess
index|[
name|sc
operator|->
name|sc_imlen
operator|-
literal|1
index|]
expr_stmt|;
name|NCR_PHASE
argument_list|(
operator|(
literal|"<stat:(%x,%x)>"
operator|,
name|ecb
operator|->
name|stat
operator|,
name|msg
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|MSG_CMDCOMPLETE
condition|)
block|{
name|ecb
operator|->
name|dleft
operator|=
operator|(
name|ecb
operator|->
name|flags
operator|&
name|ECB_TENTATIVE_DONE
operator|)
condition|?
literal|0
else|:
name|sc
operator|->
name|sc_dleft
expr_stmt|;
if|if
condition|(
operator|(
name|ecb
operator|->
name|flags
operator|&
name|ECB_SENSE
operator|)
operator|==
literal|0
condition|)
name|ecb
operator|->
name|ccb
operator|->
name|csio
operator|.
name|resid
operator|=
name|ecb
operator|->
name|dleft
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
name|NCR_CMDCOMPLETE
expr_stmt|;
block|}
else|else
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"STATUS_PHASE: "
literal|"msg %d\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_imlen
operator|=
literal|0
expr_stmt|;
name|NCRCMD
argument_list|(
name|sc
argument_list|,
name|NCRCMD_MSGOK
argument_list|)
expr_stmt|;
goto|goto
name|shortcut
goto|;
comment|/* ie. wait for disconnect */
block|}
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"invalid state: %d [intr %x, "
literal|"phase(c %x, p %x)]\n"
argument_list|,
name|sc
operator|->
name|sc_state
argument_list|,
name|sc
operator|->
name|sc_espintr
argument_list|,
name|sc
operator|->
name|sc_phase
argument_list|,
name|sc
operator|->
name|sc_prevphase
argument_list|)
expr_stmt|;
goto|goto
name|reset
goto|;
block|}
comment|/* 	 * Driver is now in state NCR_CONNECTED, i.e. we 	 * have a current command working the SCSI bus. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|!=
name|NCR_CONNECTED
operator|||
name|ecb
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"ncr53c9x: no nexus"
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|sc
operator|->
name|sc_phase
condition|)
block|{
case|case
name|MESSAGE_OUT_PHASE
case|:
name|NCR_PHASE
argument_list|(
operator|(
literal|"MESSAGE_OUT_PHASE "
operator|)
argument_list|)
expr_stmt|;
name|ncr53c9x_msgout
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_prevphase
operator|=
name|MESSAGE_OUT_PHASE
expr_stmt|;
break|break;
case|case
name|MESSAGE_IN_PHASE
case|:
name|msgin
label|:
name|NCR_PHASE
argument_list|(
operator|(
literal|"MESSAGE_IN_PHASE "
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_espintr
operator|&
name|NCRINTR_BS
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_rev
operator|!=
name|NCR_VARIANT_FAS366
operator|)
operator|||
operator|!
operator|(
name|sc
operator|->
name|sc_espstat2
operator|&
name|NCRFAS_STAT2_EMPTY
operator|)
condition|)
block|{
name|NCRCMD
argument_list|(
name|sc
argument_list|,
name|NCRCMD_FLUSH
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_flags
operator||=
name|NCR_WAITI
expr_stmt|;
name|NCRCMD
argument_list|(
name|sc
argument_list|,
name|NCRCMD_TRANS
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_espintr
operator|&
name|NCRINTR_FC
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|NCR_WAITI
operator|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"MSGIN: unexpected "
literal|"FC bit: [intr %x, stat %x, step %x]\n"
argument_list|,
name|sc
operator|->
name|sc_espintr
argument_list|,
name|sc
operator|->
name|sc_espstat
argument_list|,
name|sc
operator|->
name|sc_espstep
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|NCR_WAITI
expr_stmt|;
name|ncr53c9x_rdfifo
argument_list|(
name|sc
argument_list|,
operator|(
name|sc
operator|->
name|sc_prevphase
operator|==
name|sc
operator|->
name|sc_phase
operator|)
condition|?
name|NCR_RDFIFO_CONTINUE
else|:
name|NCR_RDFIFO_START
argument_list|)
expr_stmt|;
name|ncr53c9x_msgin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"MSGIN: weird bits: "
literal|"[intr %x, stat %x, step %x]\n"
argument_list|,
name|sc
operator|->
name|sc_espintr
argument_list|,
name|sc
operator|->
name|sc_espstat
argument_list|,
name|sc
operator|->
name|sc_espstep
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_prevphase
operator|=
name|MESSAGE_IN_PHASE
expr_stmt|;
goto|goto
name|shortcut
goto|;
comment|/* i.e. expect data to be ready */
case|case
name|COMMAND_PHASE
case|:
comment|/* 		 * Send the command block. Normally we don't see this 		 * phase because the SEL_ATN command takes care of 		 * all this. However, we end up here if either the 		 * target or we wanted to exchange some more messages 		 * first (e.g. to start negotiations). 		 */
name|NCR_PHASE
argument_list|(
operator|(
literal|"COMMAND_PHASE 0x%02x (%d) "
operator|,
name|ecb
operator|->
name|cmd
operator|.
name|cmd
operator|.
name|opcode
operator|,
name|ecb
operator|->
name|clen
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NCR_READ_REG
argument_list|(
name|sc
argument_list|,
name|NCR_FFLAG
argument_list|)
operator|&
name|NCRFIFO_FF
condition|)
block|{
name|NCRCMD
argument_list|(
name|sc
argument_list|,
name|NCRCMD_FLUSH
argument_list|)
expr_stmt|;
comment|/*			DELAY(1);*/
block|}
if|if
condition|(
name|sc
operator|->
name|sc_features
operator|&
name|NCR_F_DMASELECT
condition|)
block|{
comment|/* setup DMA transfer for command */
name|size
operator|=
name|ecb
operator|->
name|clen
expr_stmt|;
name|sc
operator|->
name|sc_cmdlen
operator|=
name|size
expr_stmt|;
name|sc
operator|->
name|sc_cmdp
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|ecb
operator|->
name|cmd
operator|.
name|cmd
expr_stmt|;
name|NCRDMA_SETUP
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_cmdp
argument_list|,
operator|&
name|sc
operator|->
name|sc_cmdlen
argument_list|,
literal|0
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
comment|/* Program the SCSI counter */
name|NCR_SET_COUNT
argument_list|(
name|sc
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* load the count in */
name|NCRCMD
argument_list|(
name|sc
argument_list|,
name|NCRCMD_NOP
operator||
name|NCRCMD_DMA
argument_list|)
expr_stmt|;
comment|/* start the command transfer */
name|NCRCMD
argument_list|(
name|sc
argument_list|,
name|NCRCMD_TRANS
operator||
name|NCRCMD_DMA
argument_list|)
expr_stmt|;
name|NCRDMA_GO
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ncr53c9x_wrfifo
argument_list|(
name|sc
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|ecb
operator|->
name|cmd
operator|.
name|cmd
argument_list|,
name|ecb
operator|->
name|clen
argument_list|)
expr_stmt|;
name|NCRCMD
argument_list|(
name|sc
argument_list|,
name|NCRCMD_TRANS
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_prevphase
operator|=
name|COMMAND_PHASE
expr_stmt|;
break|break;
case|case
name|DATA_OUT_PHASE
case|:
name|NCR_PHASE
argument_list|(
operator|(
literal|"DATA_OUT_PHASE [%ld] "
operator|,
operator|(
name|long
operator|)
name|sc
operator|->
name|sc_dleft
operator|)
argument_list|)
expr_stmt|;
name|NCRCMD
argument_list|(
name|sc
argument_list|,
name|NCRCMD_FLUSH
argument_list|)
expr_stmt|;
name|size
operator|=
name|min
argument_list|(
name|sc
operator|->
name|sc_dleft
argument_list|,
name|sc
operator|->
name|sc_maxxfer
argument_list|)
expr_stmt|;
name|NCRDMA_SETUP
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_dp
argument_list|,
operator|&
name|sc
operator|->
name|sc_dleft
argument_list|,
literal|0
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_prevphase
operator|=
name|DATA_OUT_PHASE
expr_stmt|;
goto|goto
name|setup_xfer
goto|;
case|case
name|DATA_IN_PHASE
case|:
name|NCR_PHASE
argument_list|(
operator|(
literal|"DATA_IN_PHASE "
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rev
operator|==
name|NCR_VARIANT_ESP100
condition|)
name|NCRCMD
argument_list|(
name|sc
argument_list|,
name|NCRCMD_FLUSH
argument_list|)
expr_stmt|;
name|size
operator|=
name|min
argument_list|(
name|sc
operator|->
name|sc_dleft
argument_list|,
name|sc
operator|->
name|sc_maxxfer
argument_list|)
expr_stmt|;
name|NCRDMA_SETUP
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_dp
argument_list|,
operator|&
name|sc
operator|->
name|sc_dleft
argument_list|,
literal|1
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_prevphase
operator|=
name|DATA_IN_PHASE
expr_stmt|;
name|setup_xfer
label|:
comment|/* Target returned to data phase: wipe "done" memory */
name|ecb
operator|->
name|flags
operator|&=
operator|~
name|ECB_TENTATIVE_DONE
expr_stmt|;
comment|/* Program the SCSI counter */
name|NCR_SET_COUNT
argument_list|(
name|sc
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* load the count in */
name|NCRCMD
argument_list|(
name|sc
argument_list|,
name|NCRCMD_NOP
operator||
name|NCRCMD_DMA
argument_list|)
expr_stmt|;
comment|/* 		 * Note that if `size' is 0, we've already transceived 		 * all the bytes we want but we're still in DATA PHASE. 		 * Apparently, the device needs padding. Also, a 		 * transfer size of 0 means "maximum" to the chip 		 * DMA logic. 		 */
name|NCRCMD
argument_list|(
name|sc
argument_list|,
operator|(
name|size
operator|==
literal|0
condition|?
name|NCRCMD_TRPAD
else|:
name|NCRCMD_TRANS
operator|)
operator||
name|NCRCMD_DMA
argument_list|)
expr_stmt|;
name|NCRDMA_GO
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
case|case
name|STATUS_PHASE
case|:
name|NCR_PHASE
argument_list|(
operator|(
literal|"STATUS_PHASE "
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|NCR_ICCS
expr_stmt|;
name|NCRCMD
argument_list|(
name|sc
argument_list|,
name|NCRCMD_ICCS
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_prevphase
operator|=
name|STATUS_PHASE
expr_stmt|;
goto|goto
name|shortcut
goto|;
comment|/* i.e. expect status results soon */
case|case
name|INVALID_PHASE
case|:
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unexpected bus phase; resetting\n"
argument_list|)
expr_stmt|;
goto|goto
name|reset
goto|;
block|}
name|out
label|:
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
return|return;
name|reset
label|:
name|ncr53c9x_init
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
name|finish
label|:
name|ncr53c9x_done
argument_list|(
name|sc
argument_list|,
name|ecb
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
name|sched
label|:
name|sc
operator|->
name|sc_state
operator|=
name|NCR_IDLE
expr_stmt|;
name|ncr53c9x_sched
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
name|shortcut
label|:
comment|/* 	 * The idea is that many of the SCSI operations take very little 	 * time, and going away and getting interrupted is too high an 	 * overhead to pay. For example, selecting, sending a message 	 * and command and then doing some work can be done in one "pass". 	 * 	 * The delay is a heuristic. It is 2 when at 20MHz, 2 at 25MHz and 1 	 * at 40MHz. This needs testing. 	 */
block|{
name|struct
name|timeval
name|wait
decl_stmt|,
name|cur
decl_stmt|;
name|microtime
argument_list|(
operator|&
name|wait
argument_list|)
expr_stmt|;
name|wait
operator|.
name|tv_usec
operator|+=
literal|50
operator|/
name|sc
operator|->
name|sc_freq
expr_stmt|;
if|if
condition|(
name|wait
operator|.
name|tv_usec
operator|>
literal|1000000
condition|)
block|{
name|wait
operator|.
name|tv_sec
operator|++
expr_stmt|;
name|wait
operator|.
name|tv_usec
operator|-=
literal|1000000
expr_stmt|;
block|}
do|do
block|{
if|if
condition|(
name|NCRDMA_ISINTR
argument_list|(
name|sc
argument_list|)
condition|)
goto|goto
name|again
goto|;
name|microtime
argument_list|(
operator|&
name|cur
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|cur
operator|.
name|tv_sec
operator|<=
name|wait
operator|.
name|tv_sec
operator|&&
name|cur
operator|.
name|tv_usec
operator|<=
name|wait
operator|.
name|tv_usec
condition|)
do|;
block|}
goto|goto
name|out
goto|;
block|}
end_function

begin_function
specifier|static
name|void
name|ncr53c9x_abort
parameter_list|(
name|sc
parameter_list|,
name|ecb
parameter_list|)
name|struct
name|ncr53c9x_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ncr53c9x_ecb
modifier|*
name|ecb
decl_stmt|;
block|{
comment|/* 2 secs for the abort */
name|ecb
operator|->
name|timeout
operator|=
name|NCR_ABORT_TIMEOUT
expr_stmt|;
name|ecb
operator|->
name|flags
operator||=
name|ECB_ABORT
expr_stmt|;
if|if
condition|(
name|ecb
operator|==
name|sc
operator|->
name|sc_nexus
condition|)
block|{
comment|/* 		 * If we're still selecting, the message will be scheduled 		 * after selection is complete. 		 */
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
name|NCR_CONNECTED
condition|)
name|ncr53c9x_sched_msgout
argument_list|(
name|SEND_ABORT
argument_list|)
expr_stmt|;
comment|/* 		 * Reschedule timeout. 		 */
name|ecb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|ncr53c9x_timeout
argument_list|,
name|ecb
argument_list|,
name|mstohz
argument_list|(
name|ecb
operator|->
name|timeout
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Just leave the command where it is. 		 * XXX - what choice do we have but to reset the SCSI 		 *	 eventually? 		 */
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
name|NCR_IDLE
condition|)
name|ncr53c9x_sched
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ncr53c9x_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ncr53c9x_ecb
modifier|*
name|ecb
init|=
name|arg
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
init|=
name|ecb
operator|->
name|ccb
decl_stmt|;
name|struct
name|ncr53c9x_softc
modifier|*
name|sc
init|=
name|ecb
operator|->
name|sc
decl_stmt|;
name|struct
name|ncr53c9x_tinfo
modifier|*
name|ti
init|=
operator|&
name|sc
operator|->
name|sc_tinfo
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
decl_stmt|;
name|xpt_print_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"timed out [ecb %p (flags 0x%x, dleft %x, "
literal|"stat %x)],<state %d, nexus %p, phase(l %x, c %x, p %x), "
literal|"resid %lx, msg(q %x,o %x) %s>"
argument_list|,
name|ecb
argument_list|,
name|ecb
operator|->
name|flags
argument_list|,
name|ecb
operator|->
name|dleft
argument_list|,
name|ecb
operator|->
name|stat
argument_list|,
name|sc
operator|->
name|sc_state
argument_list|,
name|sc
operator|->
name|sc_nexus
argument_list|,
name|NCR_READ_REG
argument_list|(
name|sc
argument_list|,
name|NCR_STAT
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_phase
argument_list|,
name|sc
operator|->
name|sc_prevphase
argument_list|,
operator|(
name|long
operator|)
name|sc
operator|->
name|sc_dleft
argument_list|,
name|sc
operator|->
name|sc_msgpriq
argument_list|,
name|sc
operator|->
name|sc_msgout
argument_list|,
name|NCRDMA_ISACTIVE
argument_list|(
name|sc
argument_list|)
condition|?
literal|"DMA active"
else|:
literal|""
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|NCR53C9X_DEBUG
argument_list|)
operator|&&
name|NCR53C9X_DEBUG
operator|>
literal|1
name|printf
argument_list|(
literal|"TRACE: %s."
argument_list|,
name|ecb
operator|->
name|trace
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecb
operator|->
name|flags
operator|&
name|ECB_ABORT
condition|)
block|{
comment|/* abort timed out */
name|printf
argument_list|(
literal|" AGAIN\n"
argument_list|)
expr_stmt|;
name|ncr53c9x_init
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* abort the operation that has timed out */
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_CMD_TIMEOUT
expr_stmt|;
name|ncr53c9x_abort
argument_list|(
name|sc
argument_list|,
name|ecb
argument_list|)
expr_stmt|;
comment|/* Disable sync mode if stuck in a data phase */
if|if
condition|(
name|ecb
operator|==
name|sc
operator|->
name|sc_nexus
operator|&&
operator|(
name|ti
operator|->
name|flags
operator|&
name|T_SYNCMODE
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|sc
operator|->
name|sc_phase
operator|&
operator|(
name|MSGI
operator||
name|CDI
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* XXX ASYNC CALLBACK! */
name|xpt_print_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sync negotiation disabled\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_cfflags
operator||=
operator|(
literal|1
operator|<<
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|&
literal|7
operator|)
operator|+
literal|8
operator|)
operator|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ncr53c9x_watch
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ncr53c9x_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|ncr53c9x_softc
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|ncr53c9x_tinfo
modifier|*
name|ti
decl_stmt|;
name|struct
name|ncr53c9x_linfo
modifier|*
name|li
decl_stmt|;
name|int
name|t
decl_stmt|;
comment|/* Delete any structures that have not been used in 10min. */
name|time_t
name|old
init|=
name|time_second
operator|-
operator|(
literal|10
operator|*
literal|60
operator|)
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|sc
operator|->
name|sc_ntarg
condition|;
name|t
operator|++
control|)
block|{
name|ti
operator|=
operator|&
name|sc
operator|->
name|sc_tinfo
index|[
name|t
index|]
expr_stmt|;
name|li
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|ti
operator|->
name|luns
argument_list|)
expr_stmt|;
while|while
condition|(
name|li
condition|)
block|{
if|if
condition|(
name|li
operator|->
name|last_used
operator|<
name|old
operator|&&
name|li
operator|->
name|untagged
operator|==
name|NULL
operator|&&
name|li
operator|->
name|used
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|li
operator|->
name|lun
operator|<
name|NCR_NLUN
condition|)
name|ti
operator|->
name|lun
index|[
name|li
operator|->
name|lun
index|]
operator|=
name|NULL
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|li
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|li
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
comment|/* Restart the search at the beginning */
name|li
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|ti
operator|->
name|luns
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|li
operator|=
name|LIST_NEXT
argument_list|(
name|li
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_watchdog
argument_list|,
literal|60
operator|*
name|hz
argument_list|,
name|ncr53c9x_watch
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

