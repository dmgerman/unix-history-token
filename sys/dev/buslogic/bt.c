begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Generic driver for the BusLogic MultiMaster SCSI host adapters  * Product specific probe and attach routines can be found in:  * i386/isa/bt_isa.c	BT-54X, BT-445 cards  * i386/eisa/bt_eisa.c	BT-74x, BT-75x cards  * pci/bt_pci.c		BT-946, BT-948, BT-956, BT-958 cards  *  * Copyright (c) 1998, 1999 Justin T. Gibbs.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification, immediately at the beginning of the file.  * 2. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *      $Id: bt.c,v 1.20 1999/05/06 20:16:20 ken Exp $  */
end_comment

begin_comment
comment|/*   * Special thanks to Leonard N. Zubkoff for writing such a complete and   * well documented Mylex/BusLogic MultiMaster driver for Linux.  Support   * in this driver for the wide range of MultiMaster controllers and   * firmware revisions, with their otherwise undocumented quirks, would not   * have been possible without his efforts.   */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_comment
comment|/*  * XXX It appears that BusLogic PCI adapters go out to lunch if you   *     attempt to perform memory mapped I/O.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_include
include|#
directive|include
file|"pci.h"
end_include

begin_if
if|#
directive|if
name|NPCI
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<machine/bus_memio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/bus_pio.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<dev/buslogic/btreg.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|MAX
end_ifndef

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)> (b) ? (a) : (b))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MailBox Management functions */
end_comment

begin_function_decl
specifier|static
name|__inline
name|void
name|btnextinbox
parameter_list|(
name|struct
name|bt_softc
modifier|*
name|bt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|btnextoutbox
parameter_list|(
name|struct
name|bt_softc
modifier|*
name|bt
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|__inline
name|void
name|btnextinbox
parameter_list|(
name|struct
name|bt_softc
modifier|*
name|bt
parameter_list|)
block|{
if|if
condition|(
name|bt
operator|->
name|cur_inbox
operator|==
name|bt
operator|->
name|last_inbox
condition|)
name|bt
operator|->
name|cur_inbox
operator|=
name|bt
operator|->
name|in_boxes
expr_stmt|;
else|else
name|bt
operator|->
name|cur_inbox
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|btnextoutbox
parameter_list|(
name|struct
name|bt_softc
modifier|*
name|bt
parameter_list|)
block|{
if|if
condition|(
name|bt
operator|->
name|cur_outbox
operator|==
name|bt
operator|->
name|last_outbox
condition|)
name|bt
operator|->
name|cur_outbox
operator|=
name|bt
operator|->
name|out_boxes
expr_stmt|;
else|else
name|bt
operator|->
name|cur_outbox
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* CCB Mangement functions */
end_comment

begin_function_decl
specifier|static
name|__inline
name|u_int32_t
name|btccbvtop
parameter_list|(
name|struct
name|bt_softc
modifier|*
name|bt
parameter_list|,
name|struct
name|bt_ccb
modifier|*
name|bccb
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|bt_ccb
operator|*
name|btccbptov
argument_list|(
argument|struct bt_softc *bt
argument_list|,
argument|u_int32_t ccb_addr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|__inline
name|u_int32_t
name|btsensepaddr
parameter_list|(
name|struct
name|bt_softc
modifier|*
name|bt
parameter_list|,
name|struct
name|bt_ccb
modifier|*
name|bccb
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|scsi_sense_data
operator|*
name|btsensevaddr
argument_list|(
expr|struct
name|bt_softc
operator|*
name|bt
argument_list|,
expr|struct
name|bt_ccb
operator|*
name|bccb
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|__inline
name|u_int32_t
name|btccbvtop
parameter_list|(
name|struct
name|bt_softc
modifier|*
name|bt
parameter_list|,
name|struct
name|bt_ccb
modifier|*
name|bccb
parameter_list|)
block|{
return|return
operator|(
name|bt
operator|->
name|bt_ccb_physbase
operator|+
call|(
name|u_int32_t
call|)
argument_list|(
operator|(
name|caddr_t
operator|)
name|bccb
operator|-
operator|(
name|caddr_t
operator|)
name|bt
operator|->
name|bt_ccb_array
argument_list|)
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|bt_ccb
operator|*
name|btccbptov
argument_list|(
argument|struct bt_softc *bt
argument_list|,
argument|u_int32_t ccb_addr
argument_list|)
block|{
return|return
operator|(
name|bt
operator|->
name|bt_ccb_array
operator|+
operator|(
operator|(
expr|struct
name|bt_ccb
operator|*
operator|)
name|ccb_addr
operator|-
operator|(
expr|struct
name|bt_ccb
operator|*
operator|)
name|bt
operator|->
name|bt_ccb_physbase
operator|)
operator|)
return|;
block|}
end_expr_stmt

begin_function
specifier|static
name|__inline
name|u_int32_t
name|btsensepaddr
parameter_list|(
name|struct
name|bt_softc
modifier|*
name|bt
parameter_list|,
name|struct
name|bt_ccb
modifier|*
name|bccb
parameter_list|)
block|{
name|u_int
name|index
decl_stmt|;
name|index
operator|=
call|(
name|u_int
call|)
argument_list|(
name|bccb
operator|-
name|bt
operator|->
name|bt_ccb_array
argument_list|)
expr_stmt|;
return|return
operator|(
name|bt
operator|->
name|sense_buffers_physbase
operator|+
operator|(
name|index
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|scsi_sense_data
operator|*
name|btsensevaddr
argument_list|(
argument|struct bt_softc *bt
argument_list|,
argument|struct bt_ccb *bccb
argument_list|)
block|{
name|u_int
name|index
block|;
name|index
operator|=
call|(
name|u_int
call|)
argument_list|(
name|bccb
operator|-
name|bt
operator|->
name|bt_ccb_array
argument_list|)
block|;
return|return
operator|(
name|bt
operator|->
name|sense_buffers
operator|+
name|index
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|bt_ccb
operator|*
name|btgetccb
argument_list|(
expr|struct
name|bt_softc
operator|*
name|bt
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|__inline
name|void
name|btfreeccb
parameter_list|(
name|struct
name|bt_softc
modifier|*
name|bt
parameter_list|,
name|struct
name|bt_ccb
modifier|*
name|bccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|btallocccbs
parameter_list|(
name|struct
name|bt_softc
modifier|*
name|bt
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|bus_dmamap_callback_t
name|btexecuteccb
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|btdone
parameter_list|(
name|struct
name|bt_softc
modifier|*
name|bt
parameter_list|,
name|struct
name|bt_ccb
modifier|*
name|bccb
parameter_list|,
name|bt_mbi_comp_code_t
name|comp_code
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Host adapter command functions */
end_comment

begin_function_decl
specifier|static
name|int
name|btreset
parameter_list|(
name|struct
name|bt_softc
modifier|*
name|bt
parameter_list|,
name|int
name|hard_reset
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Initialization functions */
end_comment

begin_function_decl
specifier|static
name|int
name|btinitmboxes
parameter_list|(
name|struct
name|bt_softc
modifier|*
name|bt
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|bus_dmamap_callback_t
name|btmapmboxes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bus_dmamap_callback_t
name|btmapccbs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bus_dmamap_callback_t
name|btmapsgs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Transfer Negotiation Functions */
end_comment

begin_function_decl
specifier|static
name|void
name|btfetchtransinfo
parameter_list|(
name|struct
name|bt_softc
modifier|*
name|bt
parameter_list|,
name|struct
name|ccb_trans_settings
modifier|*
name|cts
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* CAM SIM entry points */
end_comment

begin_define
define|#
directive|define
name|ccb_bccb_ptr
value|spriv_ptr0
end_define

begin_define
define|#
directive|define
name|ccb_bt_ptr
value|spriv_ptr1
end_define

begin_function_decl
specifier|static
name|void
name|btaction
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|btpoll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Our timeout handler */
end_comment

begin_decl_stmt
name|timeout_t
name|bttimeout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|bt_unit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * XXX  * Do our own re-probe protection until a configuration  * manager can do it for us.  This ensures that we don't  * reprobe a card already found by the EISA or PCI probes.  */
end_comment

begin_decl_stmt
name|struct
name|bt_isa_port
name|bt_isa_ports
index|[]
init|=
block|{
block|{
literal|0x130
block|,
literal|0
block|,
literal|4
block|}
block|,
block|{
literal|0x134
block|,
literal|0
block|,
literal|5
block|}
block|,
block|{
literal|0x230
block|,
literal|0
block|,
literal|2
block|}
block|,
block|{
literal|0x234
block|,
literal|0
block|,
literal|3
block|}
block|,
block|{
literal|0x330
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0x334
block|,
literal|0
block|,
literal|1
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * I/O ports listed in the order enumerated by the  * card for certain op codes.  */
end_comment

begin_decl_stmt
name|u_int16_t
name|bt_board_ports
index|[]
init|=
block|{
literal|0x330
block|,
literal|0x334
block|,
literal|0x230
block|,
literal|0x234
block|,
literal|0x130
block|,
literal|0x134
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Exported functions */
end_comment

begin_function
name|void
name|bt_init_softc
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|resource
modifier|*
name|port
parameter_list|,
name|struct
name|resource
modifier|*
name|irq
parameter_list|,
name|struct
name|resource
modifier|*
name|drq
parameter_list|)
block|{
name|struct
name|bt_softc
modifier|*
name|bt
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|bt
operator|->
name|free_bt_ccbs
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|bt
operator|->
name|pending_ccbs
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|bt
operator|->
name|sg_maps
argument_list|)
expr_stmt|;
name|bt
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|bt
operator|->
name|unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bt
operator|->
name|port
operator|=
name|port
expr_stmt|;
name|bt
operator|->
name|irq
operator|=
name|irq
expr_stmt|;
name|bt
operator|->
name|drq
operator|=
name|drq
expr_stmt|;
name|bt
operator|->
name|tag
operator|=
name|rman_get_bustag
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|bt
operator|->
name|bsh
operator|=
name|rman_get_bushandle
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bt_free_softc
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bt_softc
modifier|*
name|bt
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|bt
operator|->
name|init_level
condition|)
block|{
default|default:
case|case
literal|11
case|:
name|bus_dmamap_unload
argument_list|(
name|bt
operator|->
name|sense_dmat
argument_list|,
name|bt
operator|->
name|sense_dmamap
argument_list|)
expr_stmt|;
case|case
literal|10
case|:
name|bus_dmamem_free
argument_list|(
name|bt
operator|->
name|sense_dmat
argument_list|,
name|bt
operator|->
name|sense_buffers
argument_list|,
name|bt
operator|->
name|sense_dmamap
argument_list|)
expr_stmt|;
case|case
literal|9
case|:
name|bus_dma_tag_destroy
argument_list|(
name|bt
operator|->
name|sense_dmat
argument_list|)
expr_stmt|;
case|case
literal|8
case|:
block|{
name|struct
name|sg_map_node
modifier|*
name|sg_map
decl_stmt|;
while|while
condition|(
operator|(
name|sg_map
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|bt
operator|->
name|sg_maps
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|bt
operator|->
name|sg_maps
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|bt
operator|->
name|sg_dmat
argument_list|,
name|sg_map
operator|->
name|sg_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|bt
operator|->
name|sg_dmat
argument_list|,
name|sg_map
operator|->
name|sg_vaddr
argument_list|,
name|sg_map
operator|->
name|sg_dmamap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sg_map
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|bus_dma_tag_destroy
argument_list|(
name|bt
operator|->
name|sg_dmat
argument_list|)
expr_stmt|;
block|}
case|case
literal|7
case|:
name|bus_dmamap_unload
argument_list|(
name|bt
operator|->
name|ccb_dmat
argument_list|,
name|bt
operator|->
name|ccb_dmamap
argument_list|)
expr_stmt|;
case|case
literal|6
case|:
name|bus_dmamem_free
argument_list|(
name|bt
operator|->
name|ccb_dmat
argument_list|,
name|bt
operator|->
name|bt_ccb_array
argument_list|,
name|bt
operator|->
name|ccb_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|bt
operator|->
name|ccb_dmat
argument_list|,
name|bt
operator|->
name|ccb_dmamap
argument_list|)
expr_stmt|;
case|case
literal|5
case|:
name|bus_dma_tag_destroy
argument_list|(
name|bt
operator|->
name|ccb_dmat
argument_list|)
expr_stmt|;
case|case
literal|4
case|:
name|bus_dmamap_unload
argument_list|(
name|bt
operator|->
name|mailbox_dmat
argument_list|,
name|bt
operator|->
name|mailbox_dmamap
argument_list|)
expr_stmt|;
case|case
literal|3
case|:
name|bus_dmamem_free
argument_list|(
name|bt
operator|->
name|mailbox_dmat
argument_list|,
name|bt
operator|->
name|in_boxes
argument_list|,
name|bt
operator|->
name|mailbox_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|bt
operator|->
name|mailbox_dmat
argument_list|,
name|bt
operator|->
name|mailbox_dmamap
argument_list|)
expr_stmt|;
case|case
literal|2
case|:
name|bus_dma_tag_destroy
argument_list|(
name|bt
operator|->
name|buffer_dmat
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
name|bus_dma_tag_destroy
argument_list|(
name|bt
operator|->
name|mailbox_dmat
argument_list|)
expr_stmt|;
case|case
literal|0
case|:
break|break;
block|}
block|}
end_function

begin_function
name|int
name|bt_port_probe
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|bt_probe_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|bt_softc
modifier|*
name|bt
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|config_data_t
name|config_data
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* See if there is really a card present */
if|if
condition|(
name|bt_probe
argument_list|(
name|dev
argument_list|)
operator|||
name|bt_fetch_adapter_info
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * Determine our IRQ, and DMA settings and 	 * export them to the configuration system. 	 */
name|error
operator|=
name|bt_cmd
argument_list|(
name|bt
argument_list|,
name|BOP_INQUIRE_CONFIG
argument_list|,
name|NULL
argument_list|,
comment|/*parmlen*/
literal|0
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|config_data
argument_list|,
sizeof|sizeof
argument_list|(
name|config_data
argument_list|)
argument_list|,
name|DEFAULT_CMD_TIMEOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"bt_port_probe: Could not determine IRQ or DMA "
literal|"settings for adapter.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|bt
operator|->
name|model
index|[
literal|0
index|]
operator|==
literal|'5'
condition|)
block|{
comment|/* DMA settings only make sense for ISA cards */
switch|switch
condition|(
name|config_data
operator|.
name|dma_chan
condition|)
block|{
case|case
name|DMA_CHAN_5
case|:
name|info
operator|->
name|drq
operator|=
literal|5
expr_stmt|;
break|break;
case|case
name|DMA_CHAN_6
case|:
name|info
operator|->
name|drq
operator|=
literal|6
expr_stmt|;
break|break;
case|case
name|DMA_CHAN_7
case|:
name|info
operator|->
name|drq
operator|=
literal|7
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"bt_port_probe: Invalid DMA setting "
literal|"detected for adapter.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* VL/EISA/PCI DMA */
name|info
operator|->
name|drq
operator|=
operator|-
literal|1
expr_stmt|;
block|}
switch|switch
condition|(
name|config_data
operator|.
name|irq
condition|)
block|{
case|case
name|IRQ_9
case|:
case|case
name|IRQ_10
case|:
case|case
name|IRQ_11
case|:
case|case
name|IRQ_12
case|:
case|case
name|IRQ_14
case|:
case|case
name|IRQ_15
case|:
name|info
operator|->
name|irq
operator|=
name|ffs
argument_list|(
name|config_data
operator|.
name|irq
argument_list|)
operator|+
literal|8
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"bt_port_probe: Invalid IRQ setting %x"
literal|"detected for adapter.\n"
argument_list|,
name|config_data
operator|.
name|irq
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Probe the adapter and verify that the card is a BusLogic.  */
end_comment

begin_function
name|int
name|bt_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bt_softc
modifier|*
name|bt
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|esetup_info_data_t
name|esetup_info
decl_stmt|;
name|u_int
name|status
decl_stmt|;
name|u_int
name|intstat
decl_stmt|;
name|u_int
name|geometry
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_int8_t
name|param
decl_stmt|;
comment|/* 	 * See if the three I/O ports look reasonable. 	 * Touch the minimal number of registers in the 	 * failure case. 	 */
name|status
operator|=
name|bt_inb
argument_list|(
name|bt
argument_list|,
name|STATUS_REG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|==
literal|0
operator|)
operator|||
operator|(
name|status
operator|&
operator|(
name|DIAG_ACTIVE
operator||
name|CMD_REG_BUSY
operator||
name|STATUS_REG_RSVD
operator||
name|CMD_INVALID
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed Status Reg Test - %x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|intstat
operator|=
name|bt_inb
argument_list|(
name|bt
argument_list|,
name|INTSTAT_REG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|intstat
operator|&
name|INTSTAT_REG_RSVD
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed Intstat Reg Test\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|geometry
operator|=
name|bt_inb
argument_list|(
name|bt
argument_list|,
name|GEOMETRY_REG
argument_list|)
expr_stmt|;
if|if
condition|(
name|geometry
operator|==
literal|0xFF
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed Geometry Reg Test\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * Looking good so far.  Final test is to reset the 	 * adapter and attempt to fetch the extended setup 	 * information.  This should filter out all 1542 cards. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|btreset
argument_list|(
name|bt
argument_list|,
comment|/*hard_reset*/
name|TRUE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed Reset\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|param
operator|=
sizeof|sizeof
argument_list|(
name|esetup_info
argument_list|)
expr_stmt|;
name|error
operator|=
name|bt_cmd
argument_list|(
name|bt
argument_list|,
name|BOP_INQUIRE_ESETUP_INFO
argument_list|,
operator|&
name|param
argument_list|,
comment|/*parmlen*/
literal|1
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|esetup_info
argument_list|,
sizeof|sizeof
argument_list|(
name|esetup_info
argument_list|)
argument_list|,
name|DEFAULT_CMD_TIMEOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Pull the boards setup information and record it in our softc.  */
end_comment

begin_function
name|int
name|bt_fetch_adapter_info
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bt_softc
modifier|*
name|bt
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|board_id_data_t
name|board_id
decl_stmt|;
name|esetup_info_data_t
name|esetup_info
decl_stmt|;
name|config_data_t
name|config_data
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_int8_t
name|length_param
decl_stmt|;
comment|/* First record the firmware version */
name|error
operator|=
name|bt_cmd
argument_list|(
name|bt
argument_list|,
name|BOP_INQUIRE_BOARD_ID
argument_list|,
name|NULL
argument_list|,
comment|/*parmlen*/
literal|0
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|board_id
argument_list|,
sizeof|sizeof
argument_list|(
name|board_id
argument_list|)
argument_list|,
name|DEFAULT_CMD_TIMEOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"bt_fetch_adapter_info - Failed Get Board Info\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|bt
operator|->
name|firmware_ver
index|[
literal|0
index|]
operator|=
name|board_id
operator|.
name|firmware_rev_major
expr_stmt|;
name|bt
operator|->
name|firmware_ver
index|[
literal|1
index|]
operator|=
literal|'.'
expr_stmt|;
name|bt
operator|->
name|firmware_ver
index|[
literal|2
index|]
operator|=
name|board_id
operator|.
name|firmware_rev_minor
expr_stmt|;
name|bt
operator|->
name|firmware_ver
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	 * Depending on the firmware major and minor version, 	 * we may be able to fetch additional minor version info. 	 */
if|if
condition|(
name|bt
operator|->
name|firmware_ver
index|[
literal|0
index|]
operator|>
literal|'0'
condition|)
block|{
name|error
operator|=
name|bt_cmd
argument_list|(
name|bt
argument_list|,
name|BOP_INQUIRE_FW_VER_3DIG
argument_list|,
name|NULL
argument_list|,
comment|/*parmlen*/
literal|0
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|bt
operator|->
name|firmware_ver
index|[
literal|3
index|]
argument_list|,
literal|1
argument_list|,
name|DEFAULT_CMD_TIMEOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"bt_fetch_adapter_info - Failed Get "
literal|"Firmware 3rd Digit\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|bt
operator|->
name|firmware_ver
index|[
literal|3
index|]
operator|==
literal|' '
condition|)
name|bt
operator|->
name|firmware_ver
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
name|bt
operator|->
name|firmware_ver
index|[
literal|4
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|bt
operator|->
name|firmware_ver
argument_list|,
literal|"3.3"
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|error
operator|=
name|bt_cmd
argument_list|(
name|bt
argument_list|,
name|BOP_INQUIRE_FW_VER_4DIG
argument_list|,
name|NULL
argument_list|,
comment|/*parmlen*/
literal|0
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|bt
operator|->
name|firmware_ver
index|[
literal|4
index|]
argument_list|,
literal|1
argument_list|,
name|DEFAULT_CMD_TIMEOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"bt_fetch_adapter_info - Failed Get "
literal|"Firmware 4th Digit\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|bt
operator|->
name|firmware_ver
index|[
literal|4
index|]
operator|==
literal|' '
condition|)
name|bt
operator|->
name|firmware_ver
index|[
literal|4
index|]
operator|=
literal|'\0'
expr_stmt|;
name|bt
operator|->
name|firmware_ver
index|[
literal|5
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* 	 * Some boards do not handle the "recently documented" 	 * Inquire Board Model Number command correctly or do not give 	 * exact information.  Use the Firmware and Extended Setup 	 * information in these cases to come up with the right answer. 	 * The major firmware revision number indicates: 	 * 	 * 	5.xx	BusLogic "W" Series Host Adapters: 	 *		BT-948/958/958D 	 *	4.xx	BusLogic "C" Series Host Adapters: 	 *		BT-946C/956C/956CD/747C/757C/757CD/445C/545C/540CF 	 *	3.xx	BusLogic "S" Series Host Adapters: 	 *		BT-747S/747D/757S/757D/445S/545S/542D 	 *		BT-542B/742A (revision H) 	 *	2.xx	BusLogic "A" Series Host Adapters: 	 *		BT-542B/742A (revision G and below) 	 *	0.xx	AMI FastDisk VLB/EISA BusLogic Clone Host Adapter 	 */
name|length_param
operator|=
sizeof|sizeof
argument_list|(
name|esetup_info
argument_list|)
expr_stmt|;
name|error
operator|=
name|bt_cmd
argument_list|(
name|bt
argument_list|,
name|BOP_INQUIRE_ESETUP_INFO
argument_list|,
operator|&
name|length_param
argument_list|,
comment|/*parmlen*/
literal|1
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|esetup_info
argument_list|,
sizeof|sizeof
argument_list|(
name|esetup_info
argument_list|)
argument_list|,
name|DEFAULT_CMD_TIMEOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
name|bt
operator|->
name|bios_addr
operator|=
name|esetup_info
operator|.
name|bios_addr
operator|<<
literal|12
expr_stmt|;
if|if
condition|(
name|esetup_info
operator|.
name|bus_type
operator|==
literal|'A'
operator|&&
name|bt
operator|->
name|firmware_ver
index|[
literal|0
index|]
operator|==
literal|'2'
condition|)
block|{
name|snprintf
argument_list|(
name|bt
operator|->
name|model
argument_list|,
sizeof|sizeof
argument_list|(
name|bt
operator|->
name|model
argument_list|)
argument_list|,
literal|"542B"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|esetup_info
operator|.
name|bus_type
operator|==
literal|'E'
operator|&&
operator|(
name|strncmp
argument_list|(
name|bt
operator|->
name|firmware_ver
argument_list|,
literal|"2.1"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|bt
operator|->
name|firmware_ver
argument_list|,
literal|"2.20"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|snprintf
argument_list|(
name|bt
operator|->
name|model
argument_list|,
sizeof|sizeof
argument_list|(
name|bt
operator|->
name|model
argument_list|)
argument_list|,
literal|"742A"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|esetup_info
operator|.
name|bus_type
operator|==
literal|'E'
operator|&&
name|bt
operator|->
name|firmware_ver
index|[
literal|0
index|]
operator|==
literal|'0'
condition|)
block|{
comment|/* AMI FastDisk EISA Series 441 0.x */
name|snprintf
argument_list|(
name|bt
operator|->
name|model
argument_list|,
sizeof|sizeof
argument_list|(
name|bt
operator|->
name|model
argument_list|)
argument_list|,
literal|"747A"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ha_model_data_t
name|model_data
decl_stmt|;
name|int
name|i
decl_stmt|;
name|length_param
operator|=
sizeof|sizeof
argument_list|(
name|model_data
argument_list|)
expr_stmt|;
name|error
operator|=
name|bt_cmd
argument_list|(
name|bt
argument_list|,
name|BOP_INQUIRE_MODEL
argument_list|,
operator|&
name|length_param
argument_list|,
literal|1
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|model_data
argument_list|,
sizeof|sizeof
argument_list|(
name|model_data
argument_list|)
argument_list|,
name|DEFAULT_CMD_TIMEOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"bt_fetch_adapter_info - Failed Inquire "
literal|"Model Number\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|model_data
operator|.
name|ascii_model
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|bt
operator|->
name|model
index|[
name|i
index|]
operator|=
name|model_data
operator|.
name|ascii_model
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|bt
operator|->
name|model
index|[
name|i
index|]
operator|==
literal|' '
condition|)
break|break;
block|}
name|bt
operator|->
name|model
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|bt
operator|->
name|level_trigger_ints
operator|=
name|esetup_info
operator|.
name|level_trigger_ints
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/* SG element limits */
name|bt
operator|->
name|max_sg
operator|=
name|esetup_info
operator|.
name|max_sg
expr_stmt|;
comment|/* Set feature flags */
name|bt
operator|->
name|wide_bus
operator|=
name|esetup_info
operator|.
name|wide_bus
expr_stmt|;
name|bt
operator|->
name|diff_bus
operator|=
name|esetup_info
operator|.
name|diff_bus
expr_stmt|;
name|bt
operator|->
name|ultra_scsi
operator|=
name|esetup_info
operator|.
name|ultra_scsi
expr_stmt|;
if|if
condition|(
operator|(
name|bt
operator|->
name|firmware_ver
index|[
literal|0
index|]
operator|==
literal|'5'
operator|)
operator|||
operator|(
name|bt
operator|->
name|firmware_ver
index|[
literal|0
index|]
operator|==
literal|'4'
operator|&&
name|bt
operator|->
name|wide_bus
operator|)
condition|)
name|bt
operator|->
name|extended_lun
operator|=
name|TRUE
expr_stmt|;
name|bt
operator|->
name|strict_rr
operator|=
operator|(
name|strcmp
argument_list|(
name|bt
operator|->
name|firmware_ver
argument_list|,
literal|"3.31"
argument_list|)
operator|>=
literal|0
operator|)
expr_stmt|;
name|bt
operator|->
name|extended_trans
operator|=
operator|(
operator|(
name|bt_inb
argument_list|(
name|bt
argument_list|,
name|GEOMETRY_REG
argument_list|)
operator|&
name|EXTENDED_TRANSLATION
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
comment|/* 	 * Determine max CCB count and whether tagged queuing is 	 * available based on controller type. Tagged queuing 	 * only works on 'W' series adapters, 'C' series adapters 	 * with firmware of rev 4.42 and higher, and 'S' series 	 * adapters with firmware of rev 3.35 and higher.  The 	 * maximum CCB counts are as follows: 	 * 	 *	192	BT-948/958/958D 	 *	100	BT-946C/956C/956CD/747C/757C/757CD/445C 	 * 	50	BT-545C/540CF 	 * 	30	BT-747S/747D/757S/757D/445S/545S/542D/542B/742A 	 */
if|if
condition|(
name|bt
operator|->
name|firmware_ver
index|[
literal|0
index|]
operator|==
literal|'5'
condition|)
block|{
name|bt
operator|->
name|max_ccbs
operator|=
literal|192
expr_stmt|;
name|bt
operator|->
name|tag_capable
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bt
operator|->
name|firmware_ver
index|[
literal|0
index|]
operator|==
literal|'4'
condition|)
block|{
if|if
condition|(
name|bt
operator|->
name|model
index|[
literal|0
index|]
operator|==
literal|'5'
condition|)
name|bt
operator|->
name|max_ccbs
operator|=
literal|50
expr_stmt|;
else|else
name|bt
operator|->
name|max_ccbs
operator|=
literal|100
expr_stmt|;
name|bt
operator|->
name|tag_capable
operator|=
operator|(
name|strcmp
argument_list|(
name|bt
operator|->
name|firmware_ver
argument_list|,
literal|"4.22"
argument_list|)
operator|>=
literal|0
operator|)
expr_stmt|;
block|}
else|else
block|{
name|bt
operator|->
name|max_ccbs
operator|=
literal|30
expr_stmt|;
if|if
condition|(
name|bt
operator|->
name|firmware_ver
index|[
literal|0
index|]
operator|==
literal|'3'
operator|&&
operator|(
name|strcmp
argument_list|(
name|bt
operator|->
name|firmware_ver
argument_list|,
literal|"3.35"
argument_list|)
operator|>=
literal|0
operator|)
condition|)
name|bt
operator|->
name|tag_capable
operator|=
name|TRUE
expr_stmt|;
else|else
name|bt
operator|->
name|tag_capable
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|bt
operator|->
name|tag_capable
operator|!=
name|FALSE
condition|)
name|bt
operator|->
name|tags_permitted
operator|=
name|ALL_TARGETS
expr_stmt|;
comment|/* Determine Sync/Wide/Disc settings */
if|if
condition|(
name|bt
operator|->
name|firmware_ver
index|[
literal|0
index|]
operator|>=
literal|'4'
condition|)
block|{
name|auto_scsi_data_t
name|auto_scsi_data
decl_stmt|;
name|fetch_lram_params_t
name|fetch_lram_params
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 		 * These settings are stored in the 		 * AutoSCSI data in LRAM of 'W' and 'C' 		 * adapters. 		 */
name|fetch_lram_params
operator|.
name|offset
operator|=
name|AUTO_SCSI_BYTE_OFFSET
expr_stmt|;
name|fetch_lram_params
operator|.
name|response_len
operator|=
sizeof|sizeof
argument_list|(
name|auto_scsi_data
argument_list|)
expr_stmt|;
name|error
operator|=
name|bt_cmd
argument_list|(
name|bt
argument_list|,
name|BOP_FETCH_LRAM
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|fetch_lram_params
argument_list|,
sizeof|sizeof
argument_list|(
name|fetch_lram_params
argument_list|)
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|auto_scsi_data
argument_list|,
sizeof|sizeof
argument_list|(
name|auto_scsi_data
argument_list|)
argument_list|,
name|DEFAULT_CMD_TIMEOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"bt_fetch_adapter_info - Failed "
literal|"Get Auto SCSI Info\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|bt
operator|->
name|disc_permitted
operator|=
name|auto_scsi_data
operator|.
name|low_disc_permitted
operator||
operator|(
name|auto_scsi_data
operator|.
name|high_disc_permitted
operator|<<
literal|8
operator|)
expr_stmt|;
name|bt
operator|->
name|sync_permitted
operator|=
name|auto_scsi_data
operator|.
name|low_sync_permitted
operator||
operator|(
name|auto_scsi_data
operator|.
name|high_sync_permitted
operator|<<
literal|8
operator|)
expr_stmt|;
name|bt
operator|->
name|fast_permitted
operator|=
name|auto_scsi_data
operator|.
name|low_fast_permitted
operator||
operator|(
name|auto_scsi_data
operator|.
name|high_fast_permitted
operator|<<
literal|8
operator|)
expr_stmt|;
name|bt
operator|->
name|ultra_permitted
operator|=
name|auto_scsi_data
operator|.
name|low_ultra_permitted
operator||
operator|(
name|auto_scsi_data
operator|.
name|high_ultra_permitted
operator|<<
literal|8
operator|)
expr_stmt|;
name|bt
operator|->
name|wide_permitted
operator|=
name|auto_scsi_data
operator|.
name|low_wide_permitted
operator||
operator|(
name|auto_scsi_data
operator|.
name|high_wide_permitted
operator|<<
literal|8
operator|)
expr_stmt|;
if|if
condition|(
name|bt
operator|->
name|ultra_scsi
operator|==
name|FALSE
condition|)
name|bt
operator|->
name|ultra_permitted
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bt
operator|->
name|wide_bus
operator|==
name|FALSE
condition|)
name|bt
operator|->
name|wide_permitted
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * 'S' and 'A' series have this information in the setup 		 * information structure. 		 */
name|setup_data_t
name|setup_info
decl_stmt|;
name|length_param
operator|=
sizeof|sizeof
argument_list|(
name|setup_info
argument_list|)
expr_stmt|;
name|error
operator|=
name|bt_cmd
argument_list|(
name|bt
argument_list|,
name|BOP_INQUIRE_SETUP_INFO
argument_list|,
operator|&
name|length_param
argument_list|,
comment|/*paramlen*/
literal|1
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|setup_info
argument_list|,
sizeof|sizeof
argument_list|(
name|setup_info
argument_list|)
argument_list|,
name|DEFAULT_CMD_TIMEOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"bt_fetch_adapter_info - Failed "
literal|"Get Setup Info\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|setup_info
operator|.
name|initiate_sync
operator|!=
literal|0
condition|)
block|{
name|bt
operator|->
name|sync_permitted
operator|=
name|ALL_TARGETS
expr_stmt|;
if|if
condition|(
name|bt
operator|->
name|model
index|[
literal|0
index|]
operator|==
literal|'7'
condition|)
block|{
if|if
condition|(
name|esetup_info
operator|.
name|sync_neg10MB
operator|!=
literal|0
condition|)
name|bt
operator|->
name|fast_permitted
operator|=
name|ALL_TARGETS
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|bt
operator|->
name|model
argument_list|,
literal|"757"
argument_list|)
operator|==
literal|0
condition|)
name|bt
operator|->
name|wide_permitted
operator|=
name|ALL_TARGETS
expr_stmt|;
block|}
block|}
name|bt
operator|->
name|disc_permitted
operator|=
name|ALL_TARGETS
expr_stmt|;
block|}
comment|/* We need as many mailboxes as we can have ccbs */
name|bt
operator|->
name|num_boxes
operator|=
name|bt
operator|->
name|max_ccbs
expr_stmt|;
comment|/* Determine our SCSI ID */
name|error
operator|=
name|bt_cmd
argument_list|(
name|bt
argument_list|,
name|BOP_INQUIRE_CONFIG
argument_list|,
name|NULL
argument_list|,
comment|/*parmlen*/
literal|0
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|config_data
argument_list|,
sizeof|sizeof
argument_list|(
name|config_data
argument_list|)
argument_list|,
name|DEFAULT_CMD_TIMEOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"bt_fetch_adapter_info - Failed Get Config\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|bt
operator|->
name|scsi_id
operator|=
name|config_data
operator|.
name|scsi_id
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Start the board, ready for normal operation  */
end_comment

begin_function
name|int
name|bt_init
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bt_softc
modifier|*
name|bt
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
comment|/* Announce the Adapter */
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"BT-%s FW Rev. %s "
argument_list|,
name|bt
operator|->
name|model
argument_list|,
name|bt
operator|->
name|firmware_ver
argument_list|)
expr_stmt|;
if|if
condition|(
name|bt
operator|->
name|ultra_scsi
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"Ultra "
argument_list|)
expr_stmt|;
if|if
condition|(
name|bt
operator|->
name|wide_bus
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"Wide "
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Narrow "
argument_list|)
expr_stmt|;
if|if
condition|(
name|bt
operator|->
name|diff_bus
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"Diff "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SCSI Host Adapter, SCSI ID %d, %d CCBs\n"
argument_list|,
name|bt
operator|->
name|scsi_id
argument_list|,
name|bt
operator|->
name|max_ccbs
argument_list|)
expr_stmt|;
comment|/* 	 * Create our DMA tags.  These tags define the kinds of device 	 * accessable memory allocations and memory mappings we will  	 * need to perform during normal operation. 	 * 	 * Unless we need to further restrict the allocation, we rely 	 * on the restrictions of the parent dmat, hence the common 	 * use of MAXADDR and MAXSIZE. 	 */
comment|/* DMA tag for mapping buffers into device visible space. */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|bt
operator|->
name|parent_dmat
argument_list|,
comment|/*alignment*/
literal|0
argument_list|,
comment|/*boundary*/
literal|0
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
comment|/*maxsize*/
name|MAXBSIZE
argument_list|,
comment|/*nsegments*/
name|BT_NSEG
argument_list|,
comment|/*maxsegsz*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/*flags*/
name|BUS_DMA_ALLOCNOW
argument_list|,
operator|&
name|bt
operator|->
name|buffer_dmat
argument_list|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|error_exit
goto|;
block|}
name|bt
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* DMA tag for our mailboxes */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|bt
operator|->
name|parent_dmat
argument_list|,
comment|/*alignment*/
literal|0
argument_list|,
comment|/*boundary*/
literal|0
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
name|bt
operator|->
name|num_boxes
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|bt_mbox_in_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|bt_mbox_out_t
argument_list|)
operator|)
argument_list|,
comment|/*nsegments*/
literal|1
argument_list|,
comment|/*maxsegsz*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
operator|&
name|bt
operator|->
name|mailbox_dmat
argument_list|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|error_exit
goto|;
block|}
name|bt
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* Allocation for our mailboxes */
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|bt
operator|->
name|mailbox_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|bt
operator|->
name|out_boxes
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|bt
operator|->
name|mailbox_dmamap
argument_list|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|error_exit
goto|;
block|}
name|bt
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* And permanently map them */
name|bus_dmamap_load
argument_list|(
name|bt
operator|->
name|mailbox_dmat
argument_list|,
name|bt
operator|->
name|mailbox_dmamap
argument_list|,
name|bt
operator|->
name|out_boxes
argument_list|,
name|bt
operator|->
name|num_boxes
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|bt_mbox_in_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|bt_mbox_out_t
argument_list|)
operator|)
argument_list|,
name|btmapmboxes
argument_list|,
name|bt
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
name|bt
operator|->
name|init_level
operator|++
expr_stmt|;
name|bt
operator|->
name|in_boxes
operator|=
operator|(
name|bt_mbox_in_t
operator|*
operator|)
operator|&
name|bt
operator|->
name|out_boxes
index|[
name|bt
operator|->
name|num_boxes
index|]
expr_stmt|;
name|btinitmboxes
argument_list|(
name|bt
argument_list|)
expr_stmt|;
comment|/* DMA tag for our ccb structures */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|bt
operator|->
name|parent_dmat
argument_list|,
comment|/*alignment*/
literal|0
argument_list|,
comment|/*boundary*/
literal|0
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
name|bt
operator|->
name|max_ccbs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|bt_ccb
argument_list|)
argument_list|,
comment|/*nsegments*/
literal|1
argument_list|,
comment|/*maxsegsz*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
operator|&
name|bt
operator|->
name|ccb_dmat
argument_list|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|error_exit
goto|;
block|}
name|bt
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* Allocation for our ccbs */
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|bt
operator|->
name|ccb_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|bt
operator|->
name|bt_ccb_array
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|bt
operator|->
name|ccb_dmamap
argument_list|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|error_exit
goto|;
block|}
name|bt
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* And permanently map them */
name|bus_dmamap_load
argument_list|(
name|bt
operator|->
name|ccb_dmat
argument_list|,
name|bt
operator|->
name|ccb_dmamap
argument_list|,
name|bt
operator|->
name|bt_ccb_array
argument_list|,
name|bt
operator|->
name|max_ccbs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|bt_ccb
argument_list|)
argument_list|,
name|btmapccbs
argument_list|,
name|bt
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
name|bt
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* DMA tag for our S/G structures.  We allocate in page sized chunks */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|bt
operator|->
name|parent_dmat
argument_list|,
comment|/*alignment*/
literal|0
argument_list|,
comment|/*boundary*/
literal|0
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
name|PAGE_SIZE
argument_list|,
comment|/*nsegments*/
literal|1
argument_list|,
comment|/*maxsegsz*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
operator|&
name|bt
operator|->
name|sg_dmat
argument_list|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|error_exit
goto|;
block|}
name|bt
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* Perform initial CCB allocation */
name|bzero
argument_list|(
name|bt
operator|->
name|bt_ccb_array
argument_list|,
name|bt
operator|->
name|max_ccbs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|bt_ccb
argument_list|)
argument_list|)
expr_stmt|;
name|btallocccbs
argument_list|(
name|bt
argument_list|)
expr_stmt|;
if|if
condition|(
name|bt
operator|->
name|num_ccbs
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"bt_init - Unable to allocate initial ccbs\n"
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
comment|/* 	 * Note that we are going and return (to probe) 	 */
return|return
literal|0
return|;
name|error_exit
label|:
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bt_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bt_softc
modifier|*
name|bt
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|tagged_dev_openings
decl_stmt|;
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * We reserve 1 ccb for error recovery, so don't 	 * tell the XPT about it. 	 */
if|if
condition|(
name|bt
operator|->
name|tag_capable
operator|!=
literal|0
condition|)
name|tagged_dev_openings
operator|=
name|bt
operator|->
name|max_ccbs
operator|-
literal|1
expr_stmt|;
else|else
name|tagged_dev_openings
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Create the device queue for our SIM. 	 */
name|devq
operator|=
name|cam_simq_alloc
argument_list|(
name|bt
operator|->
name|max_ccbs
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|devq
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* 	 * Construct our SIM entry 	 */
name|bt
operator|->
name|sim
operator|=
name|cam_sim_alloc
argument_list|(
name|btaction
argument_list|,
name|btpoll
argument_list|,
literal|"bt"
argument_list|,
name|bt
argument_list|,
name|bt
operator|->
name|unit
argument_list|,
literal|2
argument_list|,
name|tagged_dev_openings
argument_list|,
name|devq
argument_list|)
expr_stmt|;
if|if
condition|(
name|bt
operator|->
name|sim
operator|==
name|NULL
condition|)
block|{
name|cam_simq_free
argument_list|(
name|devq
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|bt
operator|->
name|sim
argument_list|,
literal|0
argument_list|)
operator|!=
name|CAM_SUCCESS
condition|)
block|{
name|cam_sim_free
argument_list|(
name|bt
operator|->
name|sim
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|bt
operator|->
name|path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|bt
operator|->
name|sim
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|bt
operator|->
name|sim
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|bt
operator|->
name|sim
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * Setup interrupt. 	 */
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|bt
operator|->
name|irq
argument_list|,
name|INTR_TYPE_CAM
argument_list|,
name|bt_intr
argument_list|,
name|bt
argument_list|,
operator|&
name|bt
operator|->
name|ih
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"bus_setup_intr() failed: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bt_check_probed_iop
parameter_list|(
name|u_int
name|ioport
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BT_NUM_ISAPORTS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bt_isa_ports
index|[
name|i
index|]
operator|.
name|addr
operator|==
name|ioport
condition|)
block|{
if|if
condition|(
name|bt_isa_ports
index|[
name|i
index|]
operator|.
name|probed
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|bt_mark_probed_bio
parameter_list|(
name|isa_compat_io_t
name|port
parameter_list|)
block|{
if|if
condition|(
name|port
operator|<
name|BIO_DISABLED
condition|)
name|bt_mark_probed_iop
argument_list|(
name|bt_board_ports
index|[
name|port
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bt_mark_probed_iop
parameter_list|(
name|u_int
name|ioport
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BT_NUM_ISAPORTS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ioport
operator|==
name|bt_isa_ports
index|[
name|i
index|]
operator|.
name|addr
condition|)
block|{
name|bt_isa_ports
index|[
name|i
index|]
operator|.
name|probed
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
name|void
name|bt_find_probe_range
parameter_list|(
name|int
name|ioport
parameter_list|,
name|int
modifier|*
name|port_index
parameter_list|,
name|int
modifier|*
name|max_port_index
parameter_list|)
block|{
if|if
condition|(
name|ioport
operator|>
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BT_NUM_ISAPORTS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ioport
operator|<=
name|bt_isa_ports
index|[
name|i
index|]
operator|.
name|addr
condition|)
break|break;
if|if
condition|(
operator|(
name|i
operator|>=
name|BT_NUM_ISAPORTS
operator|)
operator|||
operator|(
name|ioport
operator|!=
name|bt_isa_ports
index|[
name|i
index|]
operator|.
name|addr
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|" bt_isa_probe: Invalid baseport of 0x%x specified. bt_isa_probe: Nearest valid baseport is 0x%x. bt_isa_probe: Failing probe.\n"
argument_list|,
name|ioport
argument_list|,
operator|(
name|i
operator|<
name|BT_NUM_ISAPORTS
operator|)
condition|?
name|bt_isa_ports
index|[
name|i
index|]
operator|.
name|addr
else|:
name|bt_isa_ports
index|[
name|BT_NUM_ISAPORTS
operator|-
literal|1
index|]
operator|.
name|addr
argument_list|)
expr_stmt|;
operator|*
name|port_index
operator|=
operator|*
name|max_port_index
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
operator|*
name|port_index
operator|=
operator|*
name|max_port_index
operator|=
name|bt_isa_ports
index|[
name|i
index|]
operator|.
name|bio
expr_stmt|;
block|}
else|else
block|{
operator|*
name|port_index
operator|=
literal|0
expr_stmt|;
operator|*
name|max_port_index
operator|=
name|BT_NUM_ISAPORTS
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|bt_iop_from_bio
parameter_list|(
name|isa_compat_io_t
name|bio_index
parameter_list|)
block|{
if|if
condition|(
name|bio_index
operator|>=
literal|0
operator|&&
name|bio_index
operator|<
name|BT_NUM_ISAPORTS
condition|)
return|return
operator|(
name|bt_board_ports
index|[
name|bio_index
index|]
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|btallocccbs
parameter_list|(
name|struct
name|bt_softc
modifier|*
name|bt
parameter_list|)
block|{
name|struct
name|bt_ccb
modifier|*
name|next_ccb
decl_stmt|;
name|struct
name|sg_map_node
modifier|*
name|sg_map
decl_stmt|;
name|bus_addr_t
name|physaddr
decl_stmt|;
name|bt_sg_t
modifier|*
name|segs
decl_stmt|;
name|int
name|newcount
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|bt
operator|->
name|num_ccbs
operator|>=
name|bt
operator|->
name|max_ccbs
condition|)
comment|/* Can't allocate any more */
return|return;
name|next_ccb
operator|=
operator|&
name|bt
operator|->
name|bt_ccb_array
index|[
name|bt
operator|->
name|num_ccbs
index|]
expr_stmt|;
name|sg_map
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sg_map
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sg_map
operator|==
name|NULL
condition|)
goto|goto
name|error_exit
goto|;
comment|/* Allocate S/G space for the next batch of CCBS */
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|bt
operator|->
name|sg_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sg_map
operator|->
name|sg_vaddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sg_map
operator|->
name|sg_dmamap
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|sg_map
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|bt
operator|->
name|sg_maps
argument_list|,
name|sg_map
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|bus_dmamap_load
argument_list|(
name|bt
operator|->
name|sg_dmat
argument_list|,
name|sg_map
operator|->
name|sg_dmamap
argument_list|,
name|sg_map
operator|->
name|sg_vaddr
argument_list|,
name|PAGE_SIZE
argument_list|,
name|btmapsgs
argument_list|,
name|bt
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
name|segs
operator|=
name|sg_map
operator|->
name|sg_vaddr
expr_stmt|;
name|physaddr
operator|=
name|sg_map
operator|->
name|sg_physaddr
expr_stmt|;
name|newcount
operator|=
operator|(
name|PAGE_SIZE
operator|/
operator|(
name|BT_NSEG
operator|*
sizeof|sizeof
argument_list|(
name|bt_sg_t
argument_list|)
operator|)
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|bt
operator|->
name|num_ccbs
operator|<
name|bt
operator|->
name|max_ccbs
operator|&&
name|i
operator|<
name|newcount
condition|;
name|i
operator|++
control|)
block|{
name|int
name|error
decl_stmt|;
name|next_ccb
operator|->
name|sg_list
operator|=
name|segs
expr_stmt|;
name|next_ccb
operator|->
name|sg_list_phys
operator|=
name|physaddr
expr_stmt|;
name|next_ccb
operator|->
name|flags
operator|=
name|BCCB_FREE
expr_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|bt
operator|->
name|buffer_dmat
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
operator|&
name|next_ccb
operator|->
name|dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|bt
operator|->
name|free_bt_ccbs
argument_list|,
name|next_ccb
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|segs
operator|+=
name|BT_NSEG
expr_stmt|;
name|physaddr
operator|+=
operator|(
name|BT_NSEG
operator|*
sizeof|sizeof
argument_list|(
name|bt_sg_t
argument_list|)
operator|)
expr_stmt|;
name|next_ccb
operator|++
expr_stmt|;
name|bt
operator|->
name|num_ccbs
operator|++
expr_stmt|;
block|}
comment|/* Reserve a CCB for error recovery */
if|if
condition|(
name|bt
operator|->
name|recovery_bccb
operator|==
name|NULL
condition|)
block|{
name|bt
operator|->
name|recovery_bccb
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|bt
operator|->
name|free_bt_ccbs
argument_list|)
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|bt
operator|->
name|free_bt_ccbs
argument_list|,
name|links
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SLIST_FIRST
argument_list|(
operator|&
name|bt
operator|->
name|free_bt_ccbs
argument_list|)
operator|!=
name|NULL
condition|)
return|return;
name|error_exit
label|:
name|device_printf
argument_list|(
name|bt
operator|->
name|dev
argument_list|,
literal|"Can't malloc BCCBs\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|btfreeccb
parameter_list|(
name|struct
name|bt_softc
modifier|*
name|bt
parameter_list|,
name|struct
name|bt_ccb
modifier|*
name|bccb
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|bccb
operator|->
name|flags
operator|&
name|BCCB_ACTIVE
operator|)
operator|!=
literal|0
condition|)
name|LIST_REMOVE
argument_list|(
operator|&
name|bccb
operator|->
name|ccb
operator|->
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|le
argument_list|)
expr_stmt|;
if|if
condition|(
name|bt
operator|->
name|resource_shortage
operator|!=
literal|0
operator|&&
operator|(
name|bccb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_RELEASE_SIMQ
operator|)
operator|==
literal|0
condition|)
block|{
name|bccb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
name|bt
operator|->
name|resource_shortage
operator|=
name|FALSE
expr_stmt|;
block|}
name|bccb
operator|->
name|flags
operator|=
name|BCCB_FREE
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|bt
operator|->
name|free_bt_ccbs
argument_list|,
name|bccb
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|bt
operator|->
name|active_ccbs
operator|--
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|bt_ccb
operator|*
name|btgetccb
argument_list|(
argument|struct bt_softc *bt
argument_list|)
block|{ 	struct
name|bt_ccb
operator|*
name|bccb
block|;
name|int
name|s
block|;
name|s
operator|=
name|splcam
argument_list|()
block|;
if|if
condition|(
operator|(
name|bccb
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|bt
operator|->
name|free_bt_ccbs
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|bt
operator|->
name|free_bt_ccbs
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|bt
operator|->
name|active_ccbs
operator|++
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|btallocccbs
argument_list|(
name|bt
argument_list|)
expr_stmt|;
name|bccb
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|bt
operator|->
name|free_bt_ccbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|bccb
operator|!=
name|NULL
condition|)
block|{
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|bt
operator|->
name|free_bt_ccbs
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|bt
operator|->
name|active_ccbs
operator|++
expr_stmt|;
block|}
block|}
end_else

begin_expr_stmt
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|bccb
operator|)
return|;
end_return

begin_function
unit|}  static
name|void
name|btaction
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|bt_softc
modifier|*
name|bt
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"btaction\n"
operator|)
argument_list|)
expr_stmt|;
name|bt
operator|=
operator|(
expr|struct
name|bt_softc
operator|*
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
comment|/* Common cases first */
case|case
name|XPT_SCSI_IO
case|:
comment|/* Execute the requested I/O operation */
case|case
name|XPT_RESET_DEV
case|:
comment|/* Bus Device Reset the specified SCSI device */
block|{
name|struct
name|bt_ccb
modifier|*
name|bccb
decl_stmt|;
name|struct
name|bt_hccb
modifier|*
name|hccb
decl_stmt|;
comment|/* 		 * get a bccb to use. 		 */
if|if
condition|(
operator|(
name|bccb
operator|=
name|btgetccb
argument_list|(
name|bt
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|bt
operator|->
name|resource_shortage
operator|=
name|TRUE
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|xpt_freeze_simq
argument_list|(
name|bt
operator|->
name|sim
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQUEUE_REQ
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|hccb
operator|=
operator|&
name|bccb
operator|->
name|hccb
expr_stmt|;
comment|/* 		 * So we can find the BCCB when an abort is requested 		 */
name|bccb
operator|->
name|ccb
operator|=
name|ccb
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_bccb_ptr
operator|=
name|bccb
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_bt_ptr
operator|=
name|bt
expr_stmt|;
comment|/* 		 * Put all the arguments for the xfer in the bccb 		 */
name|hccb
operator|->
name|target_id
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|hccb
operator|->
name|target_lun
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
name|hccb
operator|->
name|btstat
operator|=
literal|0
expr_stmt|;
name|hccb
operator|->
name|sdstat
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_SCSI_IO
condition|)
block|{
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccbh
decl_stmt|;
name|csio
operator|=
operator|&
name|ccb
operator|->
name|csio
expr_stmt|;
name|ccbh
operator|=
operator|&
name|csio
operator|->
name|ccb_h
expr_stmt|;
name|hccb
operator|->
name|opcode
operator|=
name|INITIATOR_CCB_WRESID
expr_stmt|;
name|hccb
operator|->
name|datain
operator|=
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_IN
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|hccb
operator|->
name|dataout
operator|=
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_OUT
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|hccb
operator|->
name|cmd_len
operator|=
name|csio
operator|->
name|cdb_len
expr_stmt|;
if|if
condition|(
name|hccb
operator|->
name|cmd_len
operator|>
sizeof|sizeof
argument_list|(
name|hccb
operator|->
name|scsi_cdb
argument_list|)
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|btfreeccb
argument_list|(
name|bt
argument_list|,
name|bccb
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|hccb
operator|->
name|sense_len
operator|=
name|csio
operator|->
name|sense_len
expr_stmt|;
if|if
condition|(
operator|(
name|ccbh
operator|->
name|flags
operator|&
name|CAM_TAG_ACTION_VALID
operator|)
operator|!=
literal|0
operator|&&
name|ccb
operator|->
name|csio
operator|.
name|tag_action
operator|!=
name|CAM_TAG_ACTION_NONE
condition|)
block|{
name|hccb
operator|->
name|tag_enable
operator|=
name|TRUE
expr_stmt|;
name|hccb
operator|->
name|tag_type
operator|=
operator|(
name|ccb
operator|->
name|csio
operator|.
name|tag_action
operator|&
literal|0x3
operator|)
expr_stmt|;
block|}
else|else
block|{
name|hccb
operator|->
name|tag_enable
operator|=
name|FALSE
expr_stmt|;
name|hccb
operator|->
name|tag_type
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ccbh
operator|->
name|flags
operator|&
name|CAM_CDB_POINTER
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ccbh
operator|->
name|flags
operator|&
name|CAM_CDB_PHYS
operator|)
operator|==
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_ptr
argument_list|,
name|hccb
operator|->
name|scsi_cdb
argument_list|,
name|hccb
operator|->
name|cmd_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* I guess I could map it in... */
name|ccbh
operator|->
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|btfreeccb
argument_list|(
name|bt
argument_list|,
name|bccb
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|bcopy
argument_list|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
name|hccb
operator|->
name|scsi_cdb
argument_list|,
name|hccb
operator|->
name|cmd_len
argument_list|)
expr_stmt|;
block|}
comment|/* If need be, bounce our sense buffer */
if|if
condition|(
name|bt
operator|->
name|sense_buffers
operator|!=
name|NULL
condition|)
block|{
name|hccb
operator|->
name|sense_addr
operator|=
name|btsensepaddr
argument_list|(
name|bt
argument_list|,
name|bccb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hccb
operator|->
name|sense_addr
operator|=
name|vtophys
argument_list|(
operator|&
name|csio
operator|->
name|sense_data
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * If we have any data to send with this command, 			 * map it into bus space. 			 */
comment|/* Only use S/G if there is a transfer */
if|if
condition|(
operator|(
name|ccbh
operator|->
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
condition|)
block|{
if|if
condition|(
operator|(
name|ccbh
operator|->
name|flags
operator|&
name|CAM_SCATTER_VALID
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 					 * We've been given a pointer 					 * to a single buffer. 					 */
if|if
condition|(
operator|(
name|ccbh
operator|->
name|flags
operator|&
name|CAM_DATA_PHYS
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|s
decl_stmt|;
name|int
name|error
decl_stmt|;
name|s
operator|=
name|splsoftvm
argument_list|()
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|bt
operator|->
name|buffer_dmat
argument_list|,
name|bccb
operator|->
name|dmamap
argument_list|,
name|csio
operator|->
name|data_ptr
argument_list|,
name|csio
operator|->
name|dxfer_len
argument_list|,
name|btexecuteccb
argument_list|,
name|bccb
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINPROGRESS
condition|)
block|{
comment|/* 							 * So as to maintain 							 * ordering, freeze the 							 * controller queue 							 * until our mapping is 							 * returned. 							 */
name|xpt_freeze_simq
argument_list|(
name|bt
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|bus_dma_segment
name|seg
decl_stmt|;
comment|/* Pointer to physical buffer */
name|seg
operator|.
name|ds_addr
operator|=
operator|(
name|bus_addr_t
operator|)
name|csio
operator|->
name|data_ptr
expr_stmt|;
name|seg
operator|.
name|ds_len
operator|=
name|csio
operator|->
name|dxfer_len
expr_stmt|;
name|btexecuteccb
argument_list|(
name|bccb
argument_list|,
operator|&
name|seg
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|struct
name|bus_dma_segment
modifier|*
name|segs
decl_stmt|;
if|if
condition|(
operator|(
name|ccbh
operator|->
name|flags
operator|&
name|CAM_DATA_PHYS
operator|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"btaction - Physical "
literal|"segment pointers "
literal|"unsupported"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccbh
operator|->
name|flags
operator|&
name|CAM_SG_LIST_PHYS
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"btaction - Virtual "
literal|"segment addresses "
literal|"unsupported"
argument_list|)
expr_stmt|;
comment|/* Just use the segments provided */
name|segs
operator|=
operator|(
expr|struct
name|bus_dma_segment
operator|*
operator|)
name|csio
operator|->
name|data_ptr
expr_stmt|;
name|btexecuteccb
argument_list|(
name|bccb
argument_list|,
name|segs
argument_list|,
name|csio
operator|->
name|sglist_cnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|btexecuteccb
argument_list|(
name|bccb
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|hccb
operator|->
name|opcode
operator|=
name|INITIATOR_BUS_DEV_RESET
expr_stmt|;
comment|/* No data transfer */
name|hccb
operator|->
name|datain
operator|=
name|TRUE
expr_stmt|;
name|hccb
operator|->
name|dataout
operator|=
name|TRUE
expr_stmt|;
name|hccb
operator|->
name|cmd_len
operator|=
literal|0
expr_stmt|;
name|hccb
operator|->
name|sense_len
operator|=
literal|0
expr_stmt|;
name|hccb
operator|->
name|tag_enable
operator|=
name|FALSE
expr_stmt|;
name|hccb
operator|->
name|tag_type
operator|=
literal|0
expr_stmt|;
name|btexecuteccb
argument_list|(
name|bccb
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|XPT_EN_LUN
case|:
comment|/* Enable LUN as a target */
case|case
name|XPT_TARGET_IO
case|:
comment|/* Execute target I/O request */
case|case
name|XPT_ACCEPT_TARGET_IO
case|:
comment|/* Accept Host Target Mode CDB */
case|case
name|XPT_CONT_TARGET_IO
case|:
comment|/* Continue Host Target I/O Connection*/
case|case
name|XPT_ABORT
case|:
comment|/* Abort the specified CCB */
comment|/* XXX Implement */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_SET_TRAN_SETTINGS
case|:
block|{
comment|/* XXX Implement */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_PROVIDE_FAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_GET_TRAN_SETTINGS
case|:
comment|/* Get default/user set transfer settings for the target */
block|{
name|struct
name|ccb_trans_settings
modifier|*
name|cts
decl_stmt|;
name|u_int
name|target_mask
decl_stmt|;
name|cts
operator|=
operator|&
name|ccb
operator|->
name|cts
expr_stmt|;
name|target_mask
operator|=
literal|0x01
operator|<<
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
if|if
condition|(
operator|(
name|cts
operator|->
name|flags
operator|&
name|CCB_TRANS_USER_SETTINGS
operator|)
operator|!=
literal|0
condition|)
block|{
name|cts
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|bt
operator|->
name|disc_permitted
operator|&
name|target_mask
operator|)
operator|!=
literal|0
condition|)
name|cts
operator|->
name|flags
operator||=
name|CCB_TRANS_DISC_ENB
expr_stmt|;
if|if
condition|(
operator|(
name|bt
operator|->
name|tags_permitted
operator|&
name|target_mask
operator|)
operator|!=
literal|0
condition|)
name|cts
operator|->
name|flags
operator||=
name|CCB_TRANS_TAG_ENB
expr_stmt|;
if|if
condition|(
operator|(
name|bt
operator|->
name|wide_permitted
operator|&
name|target_mask
operator|)
operator|!=
literal|0
condition|)
name|cts
operator|->
name|bus_width
operator|=
name|MSG_EXT_WDTR_BUS_16_BIT
expr_stmt|;
else|else
name|cts
operator|->
name|bus_width
operator|=
name|MSG_EXT_WDTR_BUS_8_BIT
expr_stmt|;
if|if
condition|(
operator|(
name|bt
operator|->
name|ultra_permitted
operator|&
name|target_mask
operator|)
operator|!=
literal|0
condition|)
name|cts
operator|->
name|sync_period
operator|=
literal|12
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|bt
operator|->
name|fast_permitted
operator|&
name|target_mask
operator|)
operator|!=
literal|0
condition|)
name|cts
operator|->
name|sync_period
operator|=
literal|25
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|bt
operator|->
name|sync_permitted
operator|&
name|target_mask
operator|)
operator|!=
literal|0
condition|)
name|cts
operator|->
name|sync_period
operator|=
literal|50
expr_stmt|;
else|else
name|cts
operator|->
name|sync_period
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|sync_period
operator|!=
literal|0
condition|)
name|cts
operator|->
name|sync_offset
operator|=
literal|15
expr_stmt|;
name|cts
operator|->
name|valid
operator|=
name|CCB_TRANS_SYNC_RATE_VALID
operator||
name|CCB_TRANS_SYNC_OFFSET_VALID
operator||
name|CCB_TRANS_BUS_WIDTH_VALID
operator||
name|CCB_TRANS_DISC_VALID
operator||
name|CCB_TRANS_TQ_VALID
expr_stmt|;
block|}
else|else
block|{
name|btfetchtransinfo
argument_list|(
name|bt
argument_list|,
name|cts
argument_list|)
expr_stmt|;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_CALC_GEOMETRY
case|:
block|{
name|struct
name|ccb_calc_geometry
modifier|*
name|ccg
decl_stmt|;
name|u_int32_t
name|size_mb
decl_stmt|;
name|u_int32_t
name|secs_per_cylinder
decl_stmt|;
name|ccg
operator|=
operator|&
name|ccb
operator|->
name|ccg
expr_stmt|;
name|size_mb
operator|=
name|ccg
operator|->
name|volume_size
operator|/
operator|(
operator|(
literal|1024L
operator|*
literal|1024L
operator|)
operator|/
name|ccg
operator|->
name|block_size
operator|)
expr_stmt|;
if|if
condition|(
name|size_mb
operator|>=
literal|1024
operator|&&
operator|(
name|bt
operator|->
name|extended_trans
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|size_mb
operator|>=
literal|2048
condition|)
block|{
name|ccg
operator|->
name|heads
operator|=
literal|255
expr_stmt|;
name|ccg
operator|->
name|secs_per_track
operator|=
literal|63
expr_stmt|;
block|}
else|else
block|{
name|ccg
operator|->
name|heads
operator|=
literal|128
expr_stmt|;
name|ccg
operator|->
name|secs_per_track
operator|=
literal|32
expr_stmt|;
block|}
block|}
else|else
block|{
name|ccg
operator|->
name|heads
operator|=
literal|64
expr_stmt|;
name|ccg
operator|->
name|secs_per_track
operator|=
literal|32
expr_stmt|;
block|}
name|secs_per_cylinder
operator|=
name|ccg
operator|->
name|heads
operator|*
name|ccg
operator|->
name|secs_per_track
expr_stmt|;
name|ccg
operator|->
name|cylinders
operator|=
name|ccg
operator|->
name|volume_size
operator|/
name|secs_per_cylinder
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_RESET_BUS
case|:
comment|/* Reset the specified SCSI bus */
block|{
name|btreset
argument_list|(
name|bt
argument_list|,
comment|/*hardreset*/
name|TRUE
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_TERM_IO
case|:
comment|/* Terminate the I/O process */
comment|/* XXX Implement */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_PATH_INQ
case|:
comment|/* Path routing inquiry */
block|{
name|struct
name|ccb_pathinq
modifier|*
name|cpi
init|=
operator|&
name|ccb
operator|->
name|cpi
decl_stmt|;
name|cpi
operator|->
name|version_num
operator|=
literal|1
expr_stmt|;
comment|/* XXX??? */
name|cpi
operator|->
name|hba_inquiry
operator|=
name|PI_SDTR_ABLE
expr_stmt|;
if|if
condition|(
name|bt
operator|->
name|tag_capable
operator|!=
literal|0
condition|)
name|cpi
operator|->
name|hba_inquiry
operator||=
name|PI_TAG_ABLE
expr_stmt|;
if|if
condition|(
name|bt
operator|->
name|wide_bus
operator|!=
literal|0
condition|)
name|cpi
operator|->
name|hba_inquiry
operator||=
name|PI_WIDE_16
expr_stmt|;
name|cpi
operator|->
name|target_sprt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_misc
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_eng_cnt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|max_target
operator|=
name|bt
operator|->
name|wide_bus
condition|?
literal|15
else|:
literal|7
expr_stmt|;
name|cpi
operator|->
name|max_lun
operator|=
literal|7
expr_stmt|;
name|cpi
operator|->
name|initiator_id
operator|=
name|bt
operator|->
name|scsi_id
expr_stmt|;
name|cpi
operator|->
name|bus_id
operator|=
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|base_transfer_speed
operator|=
literal|3300
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|sim_vid
argument_list|,
literal|"FreeBSD"
argument_list|,
name|SIM_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|hba_vid
argument_list|,
literal|"BusLogic"
argument_list|,
name|HBA_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|dev_name
argument_list|,
name|cam_sim_name
argument_list|(
name|sim
argument_list|)
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|unit_number
operator|=
name|cam_sim_unit
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|btexecuteccb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|dm_segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|bt_ccb
modifier|*
name|bccb
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|bt_softc
modifier|*
name|bt
decl_stmt|;
name|int
name|s
decl_stmt|;
name|bccb
operator|=
operator|(
expr|struct
name|bt_ccb
operator|*
operator|)
name|arg
expr_stmt|;
name|ccb
operator|=
name|bccb
operator|->
name|ccb
expr_stmt|;
name|bt
operator|=
operator|(
expr|struct
name|bt_softc
operator|*
operator|)
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_bt_ptr
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|error
operator|!=
name|EFBIG
condition|)
name|device_printf
argument_list|(
name|bt
operator|->
name|dev
argument_list|,
literal|"Unexepected error 0x%x returned from "
literal|"bus_dmamap_load\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|==
name|CAM_REQ_INPROG
condition|)
block|{
name|xpt_freeze_devq
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_TOO_BIG
operator||
name|CAM_DEV_QFRZN
expr_stmt|;
block|}
name|btfreeccb
argument_list|(
name|bt
argument_list|,
name|bccb
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|nseg
operator|!=
literal|0
condition|)
block|{
name|bt_sg_t
modifier|*
name|sg
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|end_seg
decl_stmt|;
name|bus_dmasync_op_t
name|op
decl_stmt|;
name|end_seg
operator|=
name|dm_segs
operator|+
name|nseg
expr_stmt|;
comment|/* Copy the segments into our SG list */
name|sg
operator|=
name|bccb
operator|->
name|sg_list
expr_stmt|;
while|while
condition|(
name|dm_segs
operator|<
name|end_seg
condition|)
block|{
name|sg
operator|->
name|len
operator|=
name|dm_segs
operator|->
name|ds_len
expr_stmt|;
name|sg
operator|->
name|addr
operator|=
name|dm_segs
operator|->
name|ds_addr
expr_stmt|;
name|sg
operator|++
expr_stmt|;
name|dm_segs
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|nseg
operator|>
literal|1
condition|)
block|{
name|bccb
operator|->
name|hccb
operator|.
name|opcode
operator|=
name|INITIATOR_SG_CCB_WRESID
expr_stmt|;
name|bccb
operator|->
name|hccb
operator|.
name|data_len
operator|=
sizeof|sizeof
argument_list|(
name|bt_sg_t
argument_list|)
operator|*
name|nseg
expr_stmt|;
name|bccb
operator|->
name|hccb
operator|.
name|data_addr
operator|=
name|bccb
operator|->
name|sg_list_phys
expr_stmt|;
block|}
else|else
block|{
name|bccb
operator|->
name|hccb
operator|.
name|data_len
operator|=
name|bccb
operator|->
name|sg_list
operator|->
name|len
expr_stmt|;
name|bccb
operator|->
name|hccb
operator|.
name|data_addr
operator|=
name|bccb
operator|->
name|sg_list
operator|->
name|addr
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
name|op
operator|=
name|BUS_DMASYNC_PREREAD
expr_stmt|;
else|else
name|op
operator|=
name|BUS_DMASYNC_PREWRITE
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|bt
operator|->
name|buffer_dmat
argument_list|,
name|bccb
operator|->
name|dmamap
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bccb
operator|->
name|hccb
operator|.
name|opcode
operator|=
name|INITIATOR_CCB
expr_stmt|;
name|bccb
operator|->
name|hccb
operator|.
name|data_len
operator|=
literal|0
expr_stmt|;
name|bccb
operator|->
name|hccb
operator|.
name|data_addr
operator|=
literal|0
expr_stmt|;
block|}
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
comment|/* 	 * Last time we need to check if this CCB needs to 	 * be aborted. 	 */
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|!=
name|CAM_REQ_INPROG
condition|)
block|{
if|if
condition|(
name|nseg
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|bt
operator|->
name|buffer_dmat
argument_list|,
name|bccb
operator|->
name|dmamap
argument_list|)
expr_stmt|;
name|btfreeccb
argument_list|(
name|bt
argument_list|,
name|bccb
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|bccb
operator|->
name|flags
operator|=
name|BCCB_ACTIVE
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SIM_QUEUED
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|bt
operator|->
name|pending_ccbs
argument_list|,
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|le
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|bttimeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|bccb
argument_list|,
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
comment|/* Tell the adapter about this command */
name|bt
operator|->
name|cur_outbox
operator|->
name|ccb_addr
operator|=
name|btccbvtop
argument_list|(
name|bt
argument_list|,
name|bccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|bt
operator|->
name|cur_outbox
operator|->
name|action_code
operator|!=
name|BMBO_FREE
condition|)
block|{
comment|/* 		 * We should never encounter a busy mailbox. 		 * If we do, warn the user, and treat it as 		 * a resource shortage.  If the controller is 		 * hung, one of the pending transactions will 		 * timeout causing us to start recovery operations. 		 */
name|device_printf
argument_list|(
name|bt
operator|->
name|dev
argument_list|,
literal|"Encountered busy mailbox with %d out of %d "
literal|"commands active!!!\n"
argument_list|,
name|bt
operator|->
name|active_ccbs
argument_list|,
name|bt
operator|->
name|max_ccbs
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|bttimeout
argument_list|,
name|bccb
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|nseg
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|bt
operator|->
name|buffer_dmat
argument_list|,
name|bccb
operator|->
name|dmamap
argument_list|)
expr_stmt|;
name|btfreeccb
argument_list|(
name|bt
argument_list|,
name|bccb
argument_list|)
expr_stmt|;
name|bt
operator|->
name|resource_shortage
operator|=
name|TRUE
expr_stmt|;
name|xpt_freeze_simq
argument_list|(
name|bt
operator|->
name|sim
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQUEUE_REQ
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|bt
operator|->
name|cur_outbox
operator|->
name|action_code
operator|=
name|BMBO_START
expr_stmt|;
name|bt_outb
argument_list|(
name|bt
argument_list|,
name|COMMAND_REG
argument_list|,
name|BOP_START_MBOX
argument_list|)
expr_stmt|;
name|btnextoutbox
argument_list|(
name|bt
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bt_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|bt_softc
modifier|*
name|bt
decl_stmt|;
name|u_int
name|intstat
decl_stmt|;
name|bt
operator|=
operator|(
expr|struct
name|bt_softc
operator|*
operator|)
name|arg
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|intstat
operator|=
name|bt_inb
argument_list|(
name|bt
argument_list|,
name|INTSTAT_REG
argument_list|)
operator|)
operator|&
name|INTR_PENDING
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|intstat
operator|&
name|CMD_COMPLETE
operator|)
operator|!=
literal|0
condition|)
block|{
name|bt
operator|->
name|latched_status
operator|=
name|bt_inb
argument_list|(
name|bt
argument_list|,
name|STATUS_REG
argument_list|)
expr_stmt|;
name|bt
operator|->
name|command_cmp
operator|=
name|TRUE
expr_stmt|;
block|}
name|bt_outb
argument_list|(
name|bt
argument_list|,
name|CONTROL_REG
argument_list|,
name|RESET_INTR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|intstat
operator|&
name|IMB_LOADED
operator|)
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
name|bt
operator|->
name|cur_inbox
operator|->
name|comp_code
operator|!=
name|BMBI_FREE
condition|)
block|{
name|btdone
argument_list|(
name|bt
argument_list|,
name|btccbptov
argument_list|(
name|bt
argument_list|,
name|bt
operator|->
name|cur_inbox
operator|->
name|ccb_addr
argument_list|)
argument_list|,
name|bt
operator|->
name|cur_inbox
operator|->
name|comp_code
argument_list|)
expr_stmt|;
name|bt
operator|->
name|cur_inbox
operator|->
name|comp_code
operator|=
name|BMBI_FREE
expr_stmt|;
name|btnextinbox
argument_list|(
name|bt
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|intstat
operator|&
name|SCSI_BUS_RESET
operator|)
operator|!=
literal|0
condition|)
block|{
name|btreset
argument_list|(
name|bt
argument_list|,
comment|/*hardreset*/
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|btdone
parameter_list|(
name|struct
name|bt_softc
modifier|*
name|bt
parameter_list|,
name|struct
name|bt_ccb
modifier|*
name|bccb
parameter_list|,
name|bt_mbi_comp_code_t
name|comp_code
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|ccb
operator|=
name|bccb
operator|->
name|ccb
expr_stmt|;
name|csio
operator|=
operator|&
name|bccb
operator|->
name|ccb
operator|->
name|csio
expr_stmt|;
if|if
condition|(
operator|(
name|bccb
operator|->
name|flags
operator|&
name|BCCB_ACTIVE
operator|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|bt
operator|->
name|dev
argument_list|,
literal|"btdone - Attempt to free non-active BCCB %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|bccb
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
condition|)
block|{
name|bus_dmasync_op_t
name|op
decl_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
name|op
operator|=
name|BUS_DMASYNC_POSTREAD
expr_stmt|;
else|else
name|op
operator|=
name|BUS_DMASYNC_POSTWRITE
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|bt
operator|->
name|buffer_dmat
argument_list|,
name|bccb
operator|->
name|dmamap
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|bt
operator|->
name|buffer_dmat
argument_list|,
name|bccb
operator|->
name|dmamap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bccb
operator|==
name|bt
operator|->
name|recovery_bccb
condition|)
block|{
comment|/* 		 * The recovery BCCB does not have a CCB associated 		 * with it, so short circuit the normal error handling. 		 * We now traverse our list of pending CCBs and process 		 * any that were terminated by the recovery CCBs action. 		 * We also reinstate timeouts for all remaining, pending, 		 * CCBs. 		 */
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
name|cam_status
name|error
decl_stmt|;
comment|/* Notify all clients that a BDR occured */
name|error
operator|=
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|bt
operator|->
name|sim
argument_list|)
argument_list|,
name|bccb
operator|->
name|hccb
operator|.
name|target_id
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|CAM_REQ_CMP
condition|)
name|xpt_async
argument_list|(
name|AC_SENT_BDR
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ccb_h
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|bt
operator|->
name|pending_ccbs
argument_list|)
expr_stmt|;
while|while
condition|(
name|ccb_h
operator|!=
name|NULL
condition|)
block|{
name|struct
name|bt_ccb
modifier|*
name|pending_bccb
decl_stmt|;
name|pending_bccb
operator|=
operator|(
expr|struct
name|bt_ccb
operator|*
operator|)
name|ccb_h
operator|->
name|ccb_bccb_ptr
expr_stmt|;
if|if
condition|(
name|pending_bccb
operator|->
name|hccb
operator|.
name|target_id
operator|==
name|bccb
operator|->
name|hccb
operator|.
name|target_id
condition|)
block|{
name|pending_bccb
operator|->
name|hccb
operator|.
name|btstat
operator|=
name|BTSTAT_HA_BDR
expr_stmt|;
name|ccb_h
operator|=
name|LIST_NEXT
argument_list|(
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|le
argument_list|)
expr_stmt|;
name|btdone
argument_list|(
name|bt
argument_list|,
name|pending_bccb
argument_list|,
name|BMBI_ERROR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ccb_h
operator|->
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|bttimeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|pending_bccb
argument_list|,
operator|(
name|ccb_h
operator|->
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|ccb_h
operator|=
name|LIST_NEXT
argument_list|(
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|le
argument_list|)
expr_stmt|;
block|}
block|}
name|device_printf
argument_list|(
name|bt
operator|->
name|dev
argument_list|,
literal|"No longer in timeout\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|untimeout
argument_list|(
name|bttimeout
argument_list|,
name|bccb
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|comp_code
condition|)
block|{
case|case
name|BMBI_FREE
case|:
name|device_printf
argument_list|(
name|bt
operator|->
name|dev
argument_list|,
literal|"btdone - CCB completed with free status!\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BMBI_NOT_FOUND
case|:
name|device_printf
argument_list|(
name|bt
operator|->
name|dev
argument_list|,
literal|"btdone - CCB Abort failed to find CCB\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BMBI_ABORT
case|:
case|case
name|BMBI_ERROR
case|:
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"bt: ccb %p - error %x occured.  "
literal|"btstat = %x, sdstat = %x\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|bccb
argument_list|,
name|comp_code
argument_list|,
name|bccb
operator|->
name|hccb
operator|.
name|btstat
argument_list|,
name|bccb
operator|->
name|hccb
operator|.
name|sdstat
argument_list|)
expr_stmt|;
block|}
comment|/* An error occured */
switch|switch
condition|(
name|bccb
operator|->
name|hccb
operator|.
name|btstat
condition|)
block|{
case|case
name|BTSTAT_DATARUN_ERROR
case|:
if|if
condition|(
name|bccb
operator|->
name|hccb
operator|.
name|data_len
operator|==
literal|0
condition|)
block|{
comment|/* 				 * At least firmware 4.22, does this 				 * for a QUEUE FULL condition. 				 */
name|bccb
operator|->
name|hccb
operator|.
name|sdstat
operator|=
name|SCSI_STATUS_QUEUE_FULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bccb
operator|->
name|hccb
operator|.
name|data_len
operator|<
literal|0
condition|)
block|{
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_DATA_RUN_ERR
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
name|BTSTAT_NOERROR
case|:
case|case
name|BTSTAT_LINKED_CMD_COMPLETE
case|:
case|case
name|BTSTAT_LINKED_CMD_FLAG_COMPLETE
case|:
case|case
name|BTSTAT_DATAUNDERUN_ERROR
case|:
name|csio
operator|->
name|scsi_status
operator|=
name|bccb
operator|->
name|hccb
operator|.
name|sdstat
expr_stmt|;
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SCSI_STATUS_ERROR
expr_stmt|;
switch|switch
condition|(
name|csio
operator|->
name|scsi_status
condition|)
block|{
case|case
name|SCSI_STATUS_CHECK_COND
case|:
case|case
name|SCSI_STATUS_CMD_TERMINATED
case|:
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_AUTOSNS_VALID
expr_stmt|;
comment|/* Bounce sense back if necessary */
if|if
condition|(
name|bt
operator|->
name|sense_buffers
operator|!=
name|NULL
condition|)
block|{
name|csio
operator|->
name|sense_data
operator|=
operator|*
name|btsensevaddr
argument_list|(
name|bt
argument_list|,
name|bccb
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
case|case
name|SCSI_STATUS_OK
case|:
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
block|}
name|csio
operator|->
name|resid
operator|=
name|bccb
operator|->
name|hccb
operator|.
name|data_len
expr_stmt|;
break|break;
case|case
name|BTSTAT_SELTIMEOUT
case|:
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SEL_TIMEOUT
expr_stmt|;
break|break;
case|case
name|BTSTAT_UNEXPECTED_BUSFREE
case|:
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_UNEXP_BUSFREE
expr_stmt|;
break|break;
case|case
name|BTSTAT_INVALID_PHASE
case|:
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SEQUENCE_FAIL
expr_stmt|;
break|break;
case|case
name|BTSTAT_INVALID_ACTION_CODE
case|:
name|panic
argument_list|(
literal|"%s: Inavlid Action code"
argument_list|,
name|bt_name
argument_list|(
name|bt
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BTSTAT_INVALID_OPCODE
case|:
name|panic
argument_list|(
literal|"%s: Inavlid CCB Opcode code"
argument_list|,
name|bt_name
argument_list|(
name|bt
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BTSTAT_LINKED_CCB_LUN_MISMATCH
case|:
comment|/* We don't even support linked commands... */
name|panic
argument_list|(
literal|"%s: Linked CCB Lun Mismatch"
argument_list|,
name|bt_name
argument_list|(
name|bt
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BTSTAT_INVALID_CCB_OR_SG_PARAM
case|:
name|panic
argument_list|(
literal|"%s: Invalid CCB or SG list"
argument_list|,
name|bt_name
argument_list|(
name|bt
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BTSTAT_AUTOSENSE_FAILED
case|:
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_AUTOSENSE_FAIL
expr_stmt|;
break|break;
case|case
name|BTSTAT_TAGGED_MSG_REJECTED
case|:
block|{
name|struct
name|ccb_trans_settings
name|neg
decl_stmt|;
name|xpt_print_path
argument_list|(
name|csio
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"refuses tagged commands.  Performing "
literal|"non-tagged I/O\n"
argument_list|)
expr_stmt|;
name|neg
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|neg
operator|.
name|valid
operator|=
name|CCB_TRANS_TQ_VALID
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|neg
operator|.
name|ccb_h
argument_list|,
name|csio
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|xpt_async
argument_list|(
name|AC_TRANSFER_NEG
argument_list|,
name|csio
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
operator|&
name|neg
argument_list|)
expr_stmt|;
name|bt
operator|->
name|tags_permitted
operator|&=
operator|~
operator|(
literal|0x01
operator|<<
name|csio
operator|->
name|ccb_h
operator|.
name|target_id
operator|)
expr_stmt|;
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_MSG_REJECT_REC
expr_stmt|;
break|break;
block|}
case|case
name|BTSTAT_UNSUPPORTED_MSG_RECEIVED
case|:
comment|/* 			 * XXX You would think that this is 			 *     a recoverable error... Hmmm. 			 */
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP_ERR
expr_stmt|;
break|break;
case|case
name|BTSTAT_HA_SOFTWARE_ERROR
case|:
case|case
name|BTSTAT_HA_WATCHDOG_ERROR
case|:
case|case
name|BTSTAT_HARDWARE_FAILURE
case|:
comment|/* Hardware reset ??? Can we recover ??? */
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_NO_HBA
expr_stmt|;
break|break;
case|case
name|BTSTAT_TARGET_IGNORED_ATN
case|:
case|case
name|BTSTAT_OTHER_SCSI_BUS_RESET
case|:
case|case
name|BTSTAT_HA_SCSI_BUS_RESET
case|:
if|if
condition|(
operator|(
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_CMD_TIMEOUT
condition|)
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SCSI_BUS_RESET
expr_stmt|;
break|break;
case|case
name|BTSTAT_HA_BDR
case|:
if|if
condition|(
operator|(
name|bccb
operator|->
name|flags
operator|&
name|BCCB_DEVICE_RESET
operator|)
operator|==
literal|0
condition|)
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_BDR_SENT
expr_stmt|;
else|else
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_CMD_TIMEOUT
expr_stmt|;
break|break;
case|case
name|BTSTAT_INVALID_RECONNECT
case|:
case|case
name|BTSTAT_ABORT_QUEUE_GENERATED
case|:
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_TERMIO
expr_stmt|;
break|break;
case|case
name|BTSTAT_SCSI_PERROR_DETECTED
case|:
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_UNCOR_PARITY
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_freeze_devq
argument_list|(
name|csio
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_DEV_QFRZN
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|bccb
operator|->
name|flags
operator|&
name|BCCB_RELEASE_SIMQ
operator|)
operator|!=
literal|0
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
name|btfreeccb
argument_list|(
name|bt
argument_list|,
name|bccb
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|BMBI_OK
case|:
comment|/* All completed without incident */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP
expr_stmt|;
if|if
condition|(
operator|(
name|bccb
operator|->
name|flags
operator|&
name|BCCB_RELEASE_SIMQ
operator|)
operator|!=
literal|0
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
name|btfreeccb
argument_list|(
name|bt
argument_list|,
name|bccb
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|btreset
parameter_list|(
name|struct
name|bt_softc
modifier|*
name|bt
parameter_list|,
name|int
name|hard_reset
parameter_list|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
name|u_int
name|status
decl_stmt|;
name|u_int
name|timeout
decl_stmt|;
name|u_int8_t
name|reset_type
decl_stmt|;
if|if
condition|(
name|hard_reset
operator|!=
literal|0
condition|)
name|reset_type
operator|=
name|HARD_RESET
expr_stmt|;
else|else
name|reset_type
operator|=
name|SOFT_RESET
expr_stmt|;
name|bt_outb
argument_list|(
name|bt
argument_list|,
name|CONTROL_REG
argument_list|,
name|reset_type
argument_list|)
expr_stmt|;
comment|/* Wait 5sec. for Diagnostic start */
name|timeout
operator|=
literal|5
operator|*
literal|10000
expr_stmt|;
while|while
condition|(
operator|--
name|timeout
condition|)
block|{
name|status
operator|=
name|bt_inb
argument_list|(
name|bt
argument_list|,
name|STATUS_REG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|DIAG_ACTIVE
operator|)
operator|!=
literal|0
condition|)
break|break;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"%s: btreset - Diagnostic Active failed to "
literal|"assert. status = 0x%x\n"
argument_list|,
name|bt_name
argument_list|(
name|bt
argument_list|)
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
comment|/* Wait 10sec. for Diagnostic end */
name|timeout
operator|=
literal|10
operator|*
literal|10000
expr_stmt|;
while|while
condition|(
operator|--
name|timeout
condition|)
block|{
name|status
operator|=
name|bt_inb
argument_list|(
name|bt
argument_list|,
name|STATUS_REG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|DIAG_ACTIVE
operator|)
operator|==
literal|0
condition|)
break|break;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"%s: btreset - Diagnostic Active failed to drop. "
literal|"status = 0x%x\n"
argument_list|,
name|bt_name
argument_list|(
name|bt
argument_list|)
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
comment|/* Wait for the host adapter to become ready or report a failure */
name|timeout
operator|=
literal|10000
expr_stmt|;
while|while
condition|(
operator|--
name|timeout
condition|)
block|{
name|status
operator|=
name|bt_inb
argument_list|(
name|bt
argument_list|,
name|STATUS_REG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
operator|(
name|DIAG_FAIL
operator||
name|HA_READY
operator||
name|DATAIN_REG_READY
operator|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: btreset - Host adapter failed to come ready. "
literal|"status = 0x%x\n"
argument_list|,
name|bt_name
argument_list|(
name|bt
argument_list|)
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
comment|/* If the diagnostics failed, tell the user */
if|if
condition|(
operator|(
name|status
operator|&
name|DIAG_FAIL
operator|)
operator|!=
literal|0
operator|||
operator|(
name|status
operator|&
name|HA_READY
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: btreset - Adapter failed diagnostics\n"
argument_list|,
name|bt_name
argument_list|(
name|bt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|DATAIN_REG_READY
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: btreset - Host Adapter Error code = 0x%x\n"
argument_list|,
name|bt_name
argument_list|(
name|bt
argument_list|)
argument_list|,
name|bt_inb
argument_list|(
name|bt
argument_list|,
name|DATAIN_REG
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* If we've allocated mailboxes, initialize them */
if|if
condition|(
name|bt
operator|->
name|init_level
operator|>
literal|4
condition|)
name|btinitmboxes
argument_list|(
name|bt
argument_list|)
expr_stmt|;
comment|/* If we've attached to the XPT, tell it about the event */
if|if
condition|(
name|bt
operator|->
name|path
operator|!=
name|NULL
condition|)
name|xpt_async
argument_list|(
name|AC_BUS_RESET
argument_list|,
name|bt
operator|->
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Perform completion processing for all outstanding CCBs. 	 */
while|while
condition|(
operator|(
name|ccb_h
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|bt
operator|->
name|pending_ccbs
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|struct
name|bt_ccb
modifier|*
name|pending_bccb
decl_stmt|;
name|pending_bccb
operator|=
operator|(
expr|struct
name|bt_ccb
operator|*
operator|)
name|ccb_h
operator|->
name|ccb_bccb_ptr
expr_stmt|;
name|pending_bccb
operator|->
name|hccb
operator|.
name|btstat
operator|=
name|BTSTAT_HA_SCSI_BUS_RESET
expr_stmt|;
name|btdone
argument_list|(
name|bt
argument_list|,
name|pending_bccb
argument_list|,
name|BMBI_ERROR
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send a command to the adapter.  */
end_comment

begin_function
name|int
name|bt_cmd
parameter_list|(
name|struct
name|bt_softc
modifier|*
name|bt
parameter_list|,
name|bt_op_t
name|opcode
parameter_list|,
name|u_int8_t
modifier|*
name|params
parameter_list|,
name|u_int
name|param_len
parameter_list|,
name|u_int8_t
modifier|*
name|reply_data
parameter_list|,
name|u_int
name|reply_len
parameter_list|,
name|u_int
name|cmd_timeout
parameter_list|)
block|{
name|u_int
name|timeout
decl_stmt|;
name|u_int
name|status
decl_stmt|;
name|u_int
name|saved_status
decl_stmt|;
name|u_int
name|intstat
decl_stmt|;
name|u_int
name|reply_buf_size
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|cmd_complete
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* No data returned to start */
name|reply_buf_size
operator|=
name|reply_len
expr_stmt|;
name|reply_len
operator|=
literal|0
expr_stmt|;
name|intstat
operator|=
literal|0
expr_stmt|;
name|cmd_complete
operator|=
literal|0
expr_stmt|;
name|saved_status
operator|=
literal|0
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|bt
operator|->
name|command_cmp
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Wait up to 10 sec. for the adapter to become 	 * ready to accept commands. 	 */
name|timeout
operator|=
literal|100000
expr_stmt|;
while|while
condition|(
operator|--
name|timeout
condition|)
block|{
name|status
operator|=
name|bt_inb
argument_list|(
name|bt
argument_list|,
name|STATUS_REG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|HA_READY
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|status
operator|&
name|CMD_REG_BUSY
operator|)
operator|==
literal|0
condition|)
break|break;
comment|/* 		 * Throw away any pending data which may be 		 * left over from earlier commands that we 		 * timedout on. 		 */
if|if
condition|(
operator|(
name|status
operator|&
name|DATAIN_REG_READY
operator|)
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|bt_inb
argument_list|(
name|bt
argument_list|,
name|DATAIN_REG
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: bt_cmd: Timeout waiting for adapter ready, "
literal|"status = 0x%x\n"
argument_list|,
name|bt_name
argument_list|(
name|bt
argument_list|)
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
comment|/* 	 * Send the opcode followed by any necessary parameter bytes. 	 */
name|bt_outb
argument_list|(
name|bt
argument_list|,
name|COMMAND_REG
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
comment|/* 	 * Wait for up to 1sec for each byte of the the 	 * parameter list sent to be sent. 	 */
name|timeout
operator|=
literal|10000
expr_stmt|;
while|while
condition|(
name|param_len
operator|&&
operator|--
name|timeout
condition|)
block|{
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|status
operator|=
name|bt_inb
argument_list|(
name|bt
argument_list|,
name|STATUS_REG
argument_list|)
expr_stmt|;
name|intstat
operator|=
name|bt_inb
argument_list|(
name|bt
argument_list|,
name|INTSTAT_REG
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|intstat
operator|&
operator|(
name|INTR_PENDING
operator||
name|CMD_COMPLETE
operator|)
operator|)
operator|==
operator|(
name|INTR_PENDING
operator||
name|CMD_COMPLETE
operator|)
condition|)
block|{
name|saved_status
operator|=
name|status
expr_stmt|;
name|cmd_complete
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bt
operator|->
name|command_cmp
operator|!=
literal|0
condition|)
block|{
name|saved_status
operator|=
name|bt
operator|->
name|latched_status
expr_stmt|;
name|cmd_complete
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|status
operator|&
name|DATAIN_REG_READY
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|status
operator|&
name|CMD_REG_BUSY
operator|)
operator|==
literal|0
condition|)
block|{
name|bt_outb
argument_list|(
name|bt
argument_list|,
name|COMMAND_REG
argument_list|,
operator|*
name|params
operator|++
argument_list|)
expr_stmt|;
name|param_len
operator|--
expr_stmt|;
name|timeout
operator|=
literal|10000
expr_stmt|;
block|}
block|}
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: bt_cmd: Timeout sending parameters, "
literal|"status = 0x%x\n"
argument_list|,
name|bt_name
argument_list|(
name|bt
argument_list|)
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|cmd_complete
operator|=
literal|1
expr_stmt|;
name|saved_status
operator|=
name|status
expr_stmt|;
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
block|}
comment|/* 	 * Wait for the command to complete. 	 */
while|while
condition|(
name|cmd_complete
operator|==
literal|0
operator|&&
operator|--
name|cmd_timeout
condition|)
block|{
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|status
operator|=
name|bt_inb
argument_list|(
name|bt
argument_list|,
name|STATUS_REG
argument_list|)
expr_stmt|;
name|intstat
operator|=
name|bt_inb
argument_list|(
name|bt
argument_list|,
name|INTSTAT_REG
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|bt
operator|->
name|command_cmp
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * Our interrupt handler saw CMD_COMPLETE 			 * status before we did. 			 */
name|cmd_complete
operator|=
literal|1
expr_stmt|;
name|saved_status
operator|=
name|bt
operator|->
name|latched_status
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|intstat
operator|&
operator|(
name|INTR_PENDING
operator||
name|CMD_COMPLETE
operator|)
operator|)
operator|==
operator|(
name|INTR_PENDING
operator||
name|CMD_COMPLETE
operator|)
condition|)
block|{
comment|/* 			 * Our poll (in case interrupts are blocked) 			 * saw the CMD_COMPLETE interrupt. 			 */
name|cmd_complete
operator|=
literal|1
expr_stmt|;
name|saved_status
operator|=
name|status
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opcode
operator|==
name|BOP_MODIFY_IO_ADDR
operator|&&
operator|(
name|status
operator|&
name|CMD_REG_BUSY
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * The BOP_MODIFY_IO_ADDR does not issue a CMD_COMPLETE, 			 * but it should update the status register.  So, we 			 * consider this command complete when the CMD_REG_BUSY 			 * status clears. 			 */
name|saved_status
operator|=
name|status
expr_stmt|;
name|cmd_complete
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|status
operator|&
name|DATAIN_REG_READY
operator|)
operator|!=
literal|0
condition|)
block|{
name|u_int8_t
name|data
decl_stmt|;
name|data
operator|=
name|bt_inb
argument_list|(
name|bt
argument_list|,
name|DATAIN_REG
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply_len
operator|<
name|reply_buf_size
condition|)
block|{
operator|*
name|reply_data
operator|++
operator|=
name|data
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s: bt_cmd - Discarded reply data byte "
literal|"for opcode 0x%x\n"
argument_list|,
name|bt_name
argument_list|(
name|bt
argument_list|)
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Reset timeout to ensure at least a second 			 * between response bytes. 			 */
name|cmd_timeout
operator|=
name|MAX
argument_list|(
name|cmd_timeout
argument_list|,
literal|10000
argument_list|)
expr_stmt|;
name|reply_len
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|opcode
operator|==
name|BOP_FETCH_LRAM
operator|)
operator|&&
operator|(
name|status
operator|&
name|HA_READY
operator|)
operator|!=
literal|0
condition|)
block|{
name|saved_status
operator|=
name|status
expr_stmt|;
name|cmd_complete
operator|=
literal|1
expr_stmt|;
block|}
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cmd_timeout
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: bt_cmd: Timeout waiting for command (%x) "
literal|"to complete.\n%s: status = 0x%x, intstat = 0x%x, "
literal|"rlen %d\n"
argument_list|,
name|bt_name
argument_list|(
name|bt
argument_list|)
argument_list|,
name|opcode
argument_list|,
name|bt_name
argument_list|(
name|bt
argument_list|)
argument_list|,
name|status
argument_list|,
name|intstat
argument_list|,
name|reply_len
argument_list|)
expr_stmt|;
name|error
operator|=
operator|(
name|ETIMEDOUT
operator|)
expr_stmt|;
block|}
comment|/* 	 * Clear any pending interrupts.  Block interrupts so our 	 * interrupt handler is not re-entered. 	 */
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|bt_intr
argument_list|(
name|bt
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * If the command was rejected by the controller, tell the caller. 	 */
if|if
condition|(
operator|(
name|saved_status
operator|&
name|CMD_INVALID
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Some early adapters may not recover properly from 		 * an invalid command.  If it appears that the controller 		 * has wedged (i.e. status was not cleared by our interrupt 		 * reset above), perform a soft reset.       		 */
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"%s: Invalid Command 0x%x\n"
argument_list|,
name|bt_name
argument_list|(
name|bt
argument_list|)
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|status
operator|=
name|bt_inb
argument_list|(
name|bt
argument_list|,
name|STATUS_REG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
operator|(
name|CMD_INVALID
operator||
name|STATUS_REG_RSVD
operator||
name|DATAIN_REG_READY
operator||
name|CMD_REG_BUSY
operator||
name|DIAG_FAIL
operator||
name|DIAG_ACTIVE
operator|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|status
operator|&
operator|(
name|HA_READY
operator||
name|INIT_REQUIRED
operator|)
operator|)
operator|!=
operator|(
name|HA_READY
operator||
name|INIT_REQUIRED
operator|)
condition|)
block|{
name|btreset
argument_list|(
name|bt
argument_list|,
comment|/*hard_reset*/
name|FALSE
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|param_len
operator|>
literal|0
condition|)
block|{
comment|/* The controller did not accept the full argument list */
return|return
operator|(
name|E2BIG
operator|)
return|;
block|}
if|if
condition|(
name|reply_len
operator|!=
name|reply_buf_size
condition|)
block|{
comment|/* Too much or too little data received */
return|return
operator|(
name|EMSGSIZE
operator|)
return|;
block|}
comment|/* We were successful */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|btinitmboxes
parameter_list|(
name|struct
name|bt_softc
modifier|*
name|bt
parameter_list|)
block|{
name|init_32b_mbox_params_t
name|init_mbox
decl_stmt|;
name|int
name|error
decl_stmt|;
name|bzero
argument_list|(
name|bt
operator|->
name|in_boxes
argument_list|,
sizeof|sizeof
argument_list|(
name|bt_mbox_in_t
argument_list|)
operator|*
name|bt
operator|->
name|num_boxes
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|bt
operator|->
name|out_boxes
argument_list|,
sizeof|sizeof
argument_list|(
name|bt_mbox_out_t
argument_list|)
operator|*
name|bt
operator|->
name|num_boxes
argument_list|)
expr_stmt|;
name|bt
operator|->
name|cur_inbox
operator|=
name|bt
operator|->
name|in_boxes
expr_stmt|;
name|bt
operator|->
name|last_inbox
operator|=
name|bt
operator|->
name|in_boxes
operator|+
name|bt
operator|->
name|num_boxes
operator|-
literal|1
expr_stmt|;
name|bt
operator|->
name|cur_outbox
operator|=
name|bt
operator|->
name|out_boxes
expr_stmt|;
name|bt
operator|->
name|last_outbox
operator|=
name|bt
operator|->
name|out_boxes
operator|+
name|bt
operator|->
name|num_boxes
operator|-
literal|1
expr_stmt|;
comment|/* Tell the adapter about them */
name|init_mbox
operator|.
name|num_boxes
operator|=
name|bt
operator|->
name|num_boxes
expr_stmt|;
name|init_mbox
operator|.
name|base_addr
index|[
literal|0
index|]
operator|=
name|bt
operator|->
name|mailbox_physbase
operator|&
literal|0xFF
expr_stmt|;
name|init_mbox
operator|.
name|base_addr
index|[
literal|1
index|]
operator|=
operator|(
name|bt
operator|->
name|mailbox_physbase
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|init_mbox
operator|.
name|base_addr
index|[
literal|2
index|]
operator|=
operator|(
name|bt
operator|->
name|mailbox_physbase
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|init_mbox
operator|.
name|base_addr
index|[
literal|3
index|]
operator|=
operator|(
name|bt
operator|->
name|mailbox_physbase
operator|>>
literal|24
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|error
operator|=
name|bt_cmd
argument_list|(
name|bt
argument_list|,
name|BOP_INITIALIZE_32BMBOX
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|init_mbox
argument_list|,
comment|/*parmlen*/
sizeof|sizeof
argument_list|(
name|init_mbox
argument_list|)
argument_list|,
comment|/*reply_buf*/
name|NULL
argument_list|,
comment|/*reply_len*/
literal|0
argument_list|,
name|DEFAULT_CMD_TIMEOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"btinitmboxes: Initialization command failed\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bt
operator|->
name|strict_rr
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * If the controller supports 		 * strict round robin mode, 		 * enable it 		 */
name|u_int8_t
name|param
decl_stmt|;
name|param
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|bt_cmd
argument_list|(
name|bt
argument_list|,
name|BOP_ENABLE_STRICT_RR
argument_list|,
operator|&
name|param
argument_list|,
literal|1
argument_list|,
comment|/*reply_buf*/
name|NULL
argument_list|,
comment|/*reply_len*/
literal|0
argument_list|,
name|DEFAULT_CMD_TIMEOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"btinitmboxes: Unable to enable strict RR\n"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Using Strict Round Robin Mailbox Mode\n"
argument_list|,
name|bt_name
argument_list|(
name|bt
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Update the XPT's idea of the negotiated transfer  * parameters for a particular target.  */
end_comment

begin_function
specifier|static
name|void
name|btfetchtransinfo
parameter_list|(
name|struct
name|bt_softc
modifier|*
name|bt
parameter_list|,
name|struct
name|ccb_trans_settings
modifier|*
name|cts
parameter_list|)
block|{
name|setup_data_t
name|setup_info
decl_stmt|;
name|u_int
name|target
decl_stmt|;
name|u_int
name|targ_offset
decl_stmt|;
name|u_int
name|targ_mask
decl_stmt|;
name|u_int
name|sync_period
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_int8_t
name|param
decl_stmt|;
name|targ_syncinfo_t
name|sync_info
decl_stmt|;
name|target
operator|=
name|cts
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|targ_offset
operator|=
operator|(
name|target
operator|&
literal|0x7
operator|)
expr_stmt|;
name|targ_mask
operator|=
operator|(
literal|0x01
operator|<<
name|targ_offset
operator|)
expr_stmt|;
comment|/* 	 * Inquire Setup Information.  This command retreives the 	 * Wide negotiation status for recent adapters as well as 	 * the sync info for older models. 	 */
name|param
operator|=
sizeof|sizeof
argument_list|(
name|setup_info
argument_list|)
expr_stmt|;
name|error
operator|=
name|bt_cmd
argument_list|(
name|bt
argument_list|,
name|BOP_INQUIRE_SETUP_INFO
argument_list|,
operator|&
name|param
argument_list|,
comment|/*paramlen*/
literal|1
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|setup_info
argument_list|,
sizeof|sizeof
argument_list|(
name|setup_info
argument_list|)
argument_list|,
name|DEFAULT_CMD_TIMEOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: btfetchtransinfo - Inquire Setup Info Failed %x\n"
argument_list|,
name|bt_name
argument_list|(
name|bt
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|cts
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|sync_info
operator|=
operator|(
name|target
operator|<
literal|8
operator|)
condition|?
name|setup_info
operator|.
name|low_syncinfo
index|[
name|targ_offset
index|]
else|:
name|setup_info
operator|.
name|high_syncinfo
index|[
name|targ_offset
index|]
expr_stmt|;
if|if
condition|(
name|sync_info
operator|.
name|sync
operator|==
literal|0
condition|)
name|cts
operator|->
name|sync_offset
operator|=
literal|0
expr_stmt|;
else|else
name|cts
operator|->
name|sync_offset
operator|=
name|sync_info
operator|.
name|offset
expr_stmt|;
name|cts
operator|->
name|bus_width
operator|=
name|MSG_EXT_WDTR_BUS_8_BIT
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|bt
operator|->
name|firmware_ver
argument_list|,
literal|"5.06L"
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|u_int
name|wide_active
decl_stmt|;
name|wide_active
operator|=
operator|(
name|target
operator|<
literal|8
operator|)
condition|?
operator|(
name|setup_info
operator|.
name|low_wide_active
operator|&
name|targ_mask
operator|)
else|:
operator|(
name|setup_info
operator|.
name|high_wide_active
operator|&
name|targ_mask
operator|)
expr_stmt|;
if|if
condition|(
name|wide_active
condition|)
name|cts
operator|->
name|bus_width
operator|=
name|MSG_EXT_WDTR_BUS_16_BIT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|bt
operator|->
name|wide_permitted
operator|&
name|targ_mask
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|ccb_getdev
name|cgd
decl_stmt|;
comment|/* 		 * Prior to rev 5.06L, wide status isn't provided, 		 * so we "guess" that wide transfers are in effect 		 * if the user settings allow for wide and the inquiry 		 * data for the device indicates that it can handle 		 * wide transfers. 		 */
name|xpt_setup_ccb
argument_list|(
operator|&
name|cgd
operator|.
name|ccb_h
argument_list|,
name|cts
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|cgd
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_GDEV_TYPE
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|cgd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cgd
operator|.
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_CMP
operator|&&
operator|(
name|cgd
operator|.
name|inq_data
operator|.
name|flags
operator|&
name|SID_WBus16
operator|)
operator|!=
literal|0
condition|)
name|cts
operator|->
name|bus_width
operator|=
name|MSG_EXT_WDTR_BUS_16_BIT
expr_stmt|;
block|}
if|if
condition|(
name|bt
operator|->
name|firmware_ver
index|[
literal|0
index|]
operator|>=
literal|'3'
condition|)
block|{
comment|/* 		 * For adapters that can do fast or ultra speeds, 		 * use the more exact Target Sync Information command. 		 */
name|target_sync_info_data_t
name|sync_info
decl_stmt|;
name|param
operator|=
sizeof|sizeof
argument_list|(
name|sync_info
argument_list|)
expr_stmt|;
name|error
operator|=
name|bt_cmd
argument_list|(
name|bt
argument_list|,
name|BOP_TARG_SYNC_INFO
argument_list|,
operator|&
name|param
argument_list|,
comment|/*paramlen*/
literal|1
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|sync_info
argument_list|,
sizeof|sizeof
argument_list|(
name|sync_info
argument_list|)
argument_list|,
name|DEFAULT_CMD_TIMEOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: btfetchtransinfo - Inquire Sync "
literal|"Info Failed 0x%x\n"
argument_list|,
name|bt_name
argument_list|(
name|bt
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|cts
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|sync_period
operator|=
name|sync_info
operator|.
name|sync_rate
index|[
name|target
index|]
operator|*
literal|100
expr_stmt|;
block|}
else|else
block|{
name|sync_period
operator|=
literal|2000
operator|+
operator|(
literal|500
operator|*
name|sync_info
operator|.
name|period
operator|)
expr_stmt|;
block|}
comment|/* Convert ns value to standard SCSI sync rate */
if|if
condition|(
name|cts
operator|->
name|sync_offset
operator|!=
literal|0
condition|)
name|cts
operator|->
name|sync_period
operator|=
name|scsi_calc_syncparam
argument_list|(
name|sync_period
argument_list|)
expr_stmt|;
else|else
name|cts
operator|->
name|sync_period
operator|=
literal|0
expr_stmt|;
name|cts
operator|->
name|valid
operator|=
name|CCB_TRANS_SYNC_RATE_VALID
operator||
name|CCB_TRANS_SYNC_OFFSET_VALID
operator||
name|CCB_TRANS_BUS_WIDTH_VALID
expr_stmt|;
name|xpt_async
argument_list|(
name|AC_TRANSFER_NEG
argument_list|,
name|cts
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|cts
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|btmapmboxes
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|bt_softc
modifier|*
name|bt
decl_stmt|;
name|bt
operator|=
operator|(
expr|struct
name|bt_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|bt
operator|->
name|mailbox_physbase
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|btmapccbs
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|bt_softc
modifier|*
name|bt
decl_stmt|;
name|bt
operator|=
operator|(
expr|struct
name|bt_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|bt
operator|->
name|bt_ccb_physbase
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|btmapsgs
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|bt_softc
modifier|*
name|bt
decl_stmt|;
name|bt
operator|=
operator|(
expr|struct
name|bt_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|SLIST_FIRST
argument_list|(
operator|&
name|bt
operator|->
name|sg_maps
argument_list|)
operator|->
name|sg_physaddr
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|btpoll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
block|{
name|bt_intr
argument_list|(
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bttimeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|bt_ccb
modifier|*
name|bccb
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|bt_softc
modifier|*
name|bt
decl_stmt|;
name|int
name|s
decl_stmt|;
name|bccb
operator|=
operator|(
expr|struct
name|bt_ccb
operator|*
operator|)
name|arg
expr_stmt|;
name|ccb
operator|=
name|bccb
operator|->
name|ccb
expr_stmt|;
name|bt
operator|=
operator|(
expr|struct
name|bt_softc
operator|*
operator|)
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_bt_ptr
expr_stmt|;
name|xpt_print_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"CCB %p - timed out\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|bccb
argument_list|)
expr_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|bccb
operator|->
name|flags
operator|&
name|BCCB_ACTIVE
operator|)
operator|==
literal|0
condition|)
block|{
name|xpt_print_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"CCB %p - timed out CCB already completed\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|bccb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * In order to simplify the recovery process, we ask the XPT 	 * layer to halt the queue of new transactions and we traverse 	 * the list of pending CCBs and remove their timeouts. This 	 * means that the driver attempts to clear only one error 	 * condition at a time.  In general, timeouts that occur 	 * close together are related anyway, so there is no benefit 	 * in attempting to handle errors in parrallel.  Timeouts will 	 * be reinstated when the recovery process ends. 	 */
if|if
condition|(
operator|(
name|bccb
operator|->
name|flags
operator|&
name|BCCB_DEVICE_RESET
operator|)
operator|==
literal|0
condition|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
if|if
condition|(
operator|(
name|bccb
operator|->
name|flags
operator|&
name|BCCB_RELEASE_SIMQ
operator|)
operator|==
literal|0
condition|)
block|{
name|xpt_freeze_simq
argument_list|(
name|bt
operator|->
name|sim
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
name|bccb
operator|->
name|flags
operator||=
name|BCCB_RELEASE_SIMQ
expr_stmt|;
block|}
name|ccb_h
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|bt
operator|->
name|pending_ccbs
argument_list|)
expr_stmt|;
while|while
condition|(
name|ccb_h
operator|!=
name|NULL
condition|)
block|{
name|struct
name|bt_ccb
modifier|*
name|pending_bccb
decl_stmt|;
name|pending_bccb
operator|=
operator|(
expr|struct
name|bt_ccb
operator|*
operator|)
name|ccb_h
operator|->
name|ccb_bccb_ptr
expr_stmt|;
name|untimeout
argument_list|(
name|bttimeout
argument_list|,
name|pending_bccb
argument_list|,
name|ccb_h
operator|->
name|timeout_ch
argument_list|)
expr_stmt|;
name|ccb_h
operator|=
name|LIST_NEXT
argument_list|(
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|le
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|bccb
operator|->
name|flags
operator|&
name|BCCB_DEVICE_RESET
operator|)
operator|!=
literal|0
operator|||
name|bt
operator|->
name|cur_outbox
operator|->
name|action_code
operator|!=
name|BMBO_FREE
operator|||
operator|(
operator|(
name|bccb
operator|->
name|hccb
operator|.
name|tag_enable
operator|==
name|TRUE
operator|)
operator|&&
operator|(
name|bt
operator|->
name|firmware_ver
index|[
literal|0
index|]
operator|<
literal|'5'
operator|)
operator|)
condition|)
block|{
comment|/* 		 * Try a full host adapter/SCSI bus reset. 		 * We do this only if we have already attempted 		 * to clear the condition with a BDR, or we cannot 		 * attempt a BDR for lack of mailbox resources 		 * or because of faulty firmware.  It turns out 		 * that firmware versions prior to 5.xx treat BDRs 		 * as untagged commands that cannot be sent until 		 * all outstanding tagged commands have been processed. 		 * This makes it somewhat difficult to use a BDR to 		 * clear up a problem with an uncompleted tagged command. 		 */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_CMD_TIMEOUT
expr_stmt|;
name|btreset
argument_list|(
name|bt
argument_list|,
comment|/*hardreset*/
name|TRUE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: No longer in timeout\n"
argument_list|,
name|bt_name
argument_list|(
name|bt
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*     		 * Send a Bus Device Reset message: 		 * The target that is holding up the bus may not 		 * be the same as the one that triggered this timeout 		 * (different commands have different timeout lengths), 		 * but we have no way of determining this from our 		 * timeout handler.  Our strategy here is to queue a 		 * BDR message to the target of the timed out command. 		 * If this fails, we'll get another timeout 2 seconds 		 * later which will attempt a bus reset. 		 */
name|bccb
operator|->
name|flags
operator||=
name|BCCB_DEVICE_RESET
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|bttimeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|bccb
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
name|bt
operator|->
name|recovery_bccb
operator|->
name|hccb
operator|.
name|opcode
operator|=
name|INITIATOR_BUS_DEV_RESET
expr_stmt|;
comment|/* No Data Transfer */
name|bt
operator|->
name|recovery_bccb
operator|->
name|hccb
operator|.
name|datain
operator|=
name|TRUE
expr_stmt|;
name|bt
operator|->
name|recovery_bccb
operator|->
name|hccb
operator|.
name|dataout
operator|=
name|TRUE
expr_stmt|;
name|bt
operator|->
name|recovery_bccb
operator|->
name|hccb
operator|.
name|btstat
operator|=
literal|0
expr_stmt|;
name|bt
operator|->
name|recovery_bccb
operator|->
name|hccb
operator|.
name|sdstat
operator|=
literal|0
expr_stmt|;
name|bt
operator|->
name|recovery_bccb
operator|->
name|hccb
operator|.
name|target_id
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
comment|/* Tell the adapter about this command */
name|bt
operator|->
name|cur_outbox
operator|->
name|ccb_addr
operator|=
name|btccbvtop
argument_list|(
name|bt
argument_list|,
name|bt
operator|->
name|recovery_bccb
argument_list|)
expr_stmt|;
name|bt
operator|->
name|cur_outbox
operator|->
name|action_code
operator|=
name|BMBO_START
expr_stmt|;
name|bt_outb
argument_list|(
name|bt
argument_list|,
name|COMMAND_REG
argument_list|,
name|BOP_START_MBOX
argument_list|)
expr_stmt|;
name|btnextoutbox
argument_list|(
name|bt
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

