begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1999 Kazutaka YOKOTA<yokota@zodiac.mech.utsunomiya-u.ac.jp>  * Copyright (c) 1992-1998 SÃ¸ren Schmidt  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification, immediately at the beginning of the file.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_syscons.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|SC_NO_HISTORY
end_ifndef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/consio.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__sparc64__
argument_list|)
operator|||
name|defined
argument_list|(
name|__powerpc__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<machine/sc_machdep.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<machine/pc/display.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/syscons/syscons.h>
end_include

begin_comment
comment|/*  * XXX Placeholder.  * This calculations should be dynamically scaled by number of separate sc  * devices.  A base value of 'extra_history_size' should be defined for  * each syscons unit, and added and subtracted from the dynamic  * 'extra_history_size' as units are added and removed.  This way, each time  * a new syscons unit goes online, extra_history_size is automatically bumped.  */
end_comment

begin_define
define|#
directive|define
name|MAXSC
value|1
end_define

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SC_MAX_HISTORY_SIZE
argument_list|)
end_if

begin_define
define|#
directive|define
name|SC_MAX_HISTORY_SIZE
value|(1000 * MAXCONS * MAXSC)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SC_HISTORY_SIZE
argument_list|)
end_if

begin_define
define|#
directive|define
name|SC_HISTORY_SIZE
value|(ROW * 4)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|SC_HISTORY_SIZE
operator|*
name|MAXCONS
operator|*
name|MAXSC
operator|)
operator|>
name|SC_MAX_HISTORY_SIZE
end_if

begin_undef
undef|#
directive|undef
name|SC_MAX_HISTORY_SIZE
end_undef

begin_define
define|#
directive|define
name|SC_MAX_HISTORY_SIZE
value|(SC_HISTORY_SIZE * MAXCONS * MAXSC)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* local variables */
end_comment

begin_decl_stmt
specifier|static
name|int
name|extra_history_size
init|=
name|SC_MAX_HISTORY_SIZE
operator|-
name|SC_HISTORY_SIZE
operator|*
name|MAXCONS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* local functions */
end_comment

begin_function_decl
specifier|static
name|void
name|copy_history
parameter_list|(
name|sc_vtb_t
modifier|*
name|from
parameter_list|,
name|sc_vtb_t
modifier|*
name|to
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|history_to_screen
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* allocate a history buffer */
end_comment

begin_function
name|int
name|sc_alloc_history_buffer
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|lines
parameter_list|,
name|int
name|prev_ysize
parameter_list|,
name|int
name|wait
parameter_list|)
block|{
comment|/* 	 * syscons unconditionally allocates buffers up to  	 * SC_HISTORY_SIZE lines or scp->ysize lines, whichever  	 * is larger. A value greater than that is allowed,  	 * subject to extra_history_size. 	 */
name|sc_vtb_t
modifier|*
name|history
decl_stmt|;
name|sc_vtb_t
modifier|*
name|prev_history
decl_stmt|;
name|int
name|cur_lines
decl_stmt|;
comment|/* current buffer size */
name|int
name|min_lines
decl_stmt|;
comment|/* guaranteed buffer size */
name|int
name|delta
decl_stmt|;
comment|/* lines to put back */
if|if
condition|(
name|lines
operator|<=
literal|0
condition|)
name|lines
operator|=
name|SC_HISTORY_SIZE
expr_stmt|;
comment|/* use the default value */
comment|/* make it at least as large as the screen size */
name|lines
operator|=
name|imax
argument_list|(
name|lines
argument_list|,
name|scp
operator|->
name|ysize
argument_list|)
expr_stmt|;
comment|/* remove the history buffer while we update it */
name|history
operator|=
name|prev_history
operator|=
name|scp
operator|->
name|history
expr_stmt|;
name|scp
operator|->
name|history
operator|=
name|NULL
expr_stmt|;
comment|/* calculate the amount of lines to put back to extra_history_size */
name|delta
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|prev_history
condition|)
block|{
name|cur_lines
operator|=
name|sc_vtb_rows
argument_list|(
name|history
argument_list|)
expr_stmt|;
name|min_lines
operator|=
name|imax
argument_list|(
name|SC_HISTORY_SIZE
argument_list|,
name|prev_ysize
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_lines
operator|>
name|min_lines
condition|)
name|delta
operator|=
name|cur_lines
operator|-
name|min_lines
expr_stmt|;
block|}
comment|/* lines up to min_lines are always allowed. */
name|min_lines
operator|=
name|imax
argument_list|(
name|SC_HISTORY_SIZE
argument_list|,
name|scp
operator|->
name|ysize
argument_list|)
expr_stmt|;
if|if
condition|(
name|lines
operator|>
name|min_lines
condition|)
block|{
if|if
condition|(
name|lines
operator|-
name|min_lines
operator|>
name|extra_history_size
operator|+
name|delta
condition|)
block|{
comment|/* too many lines are requested */
name|scp
operator|->
name|history
operator|=
name|prev_history
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
block|}
comment|/* allocate a new buffer */
name|history
operator|=
operator|(
name|sc_vtb_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|history
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
operator|(
name|wait
operator|)
condition|?
name|M_WAITOK
else|:
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|history
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|lines
operator|>
name|min_lines
condition|)
name|extra_history_size
operator|-=
name|lines
operator|-
name|min_lines
expr_stmt|;
comment|/* XXX error check? */
name|sc_vtb_init
argument_list|(
name|history
argument_list|,
name|VTB_RINGBUFFER
argument_list|,
name|scp
operator|->
name|xsize
argument_list|,
name|lines
argument_list|,
name|NULL
argument_list|,
name|wait
argument_list|)
expr_stmt|;
comment|/* FIXME: XXX no good? */
name|sc_vtb_clear
argument_list|(
name|history
argument_list|,
name|scp
operator|->
name|sc
operator|->
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|SC_NORM_ATTR
operator|<<
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev_history
operator|!=
name|NULL
condition|)
name|copy_history
argument_list|(
name|prev_history
argument_list|,
name|history
argument_list|)
expr_stmt|;
name|scp
operator|->
name|history_pos
operator|=
name|sc_vtb_tail
argument_list|(
name|history
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|scp
operator|->
name|history_pos
operator|=
literal|0
expr_stmt|;
block|}
comment|/* destroy the previous buffer */
if|if
condition|(
name|prev_history
operator|!=
name|NULL
condition|)
block|{
name|extra_history_size
operator|+=
name|delta
expr_stmt|;
name|sc_vtb_destroy
argument_list|(
name|prev_history
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|prev_history
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|scp
operator|->
name|history
operator|=
name|history
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|copy_history
parameter_list|(
name|sc_vtb_t
modifier|*
name|from
parameter_list|,
name|sc_vtb_t
modifier|*
name|to
parameter_list|)
block|{
name|int
name|lines
decl_stmt|;
name|int
name|cols
decl_stmt|;
name|int
name|cols1
decl_stmt|;
name|int
name|cols2
decl_stmt|;
name|int
name|pos
decl_stmt|;
name|int
name|i
decl_stmt|;
name|lines
operator|=
name|sc_vtb_rows
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|cols1
operator|=
name|sc_vtb_cols
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|cols2
operator|=
name|sc_vtb_cols
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|cols
operator|=
name|imin
argument_list|(
name|cols1
argument_list|,
name|cols2
argument_list|)
expr_stmt|;
name|pos
operator|=
name|sc_vtb_tail
argument_list|(
name|from
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lines
condition|;
operator|++
name|i
control|)
block|{
name|sc_vtb_append
argument_list|(
name|from
argument_list|,
name|pos
argument_list|,
name|to
argument_list|,
name|cols
argument_list|)
expr_stmt|;
if|if
condition|(
name|cols
operator|<
name|cols2
condition|)
name|sc_vtb_seek
argument_list|(
name|to
argument_list|,
name|sc_vtb_pos
argument_list|(
name|to
argument_list|,
name|sc_vtb_tail
argument_list|(
name|to
argument_list|)
argument_list|,
name|cols2
operator|-
name|cols
argument_list|)
argument_list|)
expr_stmt|;
name|pos
operator|=
name|sc_vtb_pos
argument_list|(
name|from
argument_list|,
name|pos
argument_list|,
name|cols1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sc_free_history_buffer
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|prev_ysize
parameter_list|)
block|{
name|sc_vtb_t
modifier|*
name|history
decl_stmt|;
name|int
name|cur_lines
decl_stmt|;
comment|/* current buffer size */
name|int
name|min_lines
decl_stmt|;
comment|/* guaranteed buffer size */
name|history
operator|=
name|scp
operator|->
name|history
expr_stmt|;
name|scp
operator|->
name|history
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|history
operator|==
name|NULL
condition|)
return|return;
name|cur_lines
operator|=
name|sc_vtb_rows
argument_list|(
name|history
argument_list|)
expr_stmt|;
name|min_lines
operator|=
name|imax
argument_list|(
name|SC_HISTORY_SIZE
argument_list|,
name|prev_ysize
argument_list|)
expr_stmt|;
name|extra_history_size
operator|+=
operator|(
name|cur_lines
operator|>
name|min_lines
operator|)
condition|?
name|cur_lines
operator|-
name|min_lines
else|:
literal|0
expr_stmt|;
name|sc_vtb_destroy
argument_list|(
name|history
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|history
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* copy entire screen into the top of the history buffer */
end_comment

begin_function
name|void
name|sc_hist_save
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|sc_vtb_append
argument_list|(
operator|&
name|scp
operator|->
name|vtb
argument_list|,
literal|0
argument_list|,
name|scp
operator|->
name|history
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
argument_list|)
expr_stmt|;
name|scp
operator|->
name|history_pos
operator|=
name|sc_vtb_tail
argument_list|(
name|scp
operator|->
name|history
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* restore the screen by copying from the history buffer */
end_comment

begin_function
name|int
name|sc_hist_restore
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|scp
operator|->
name|history_pos
operator|!=
name|sc_vtb_tail
argument_list|(
name|scp
operator|->
name|history
argument_list|)
condition|)
block|{
name|scp
operator|->
name|history_pos
operator|=
name|sc_vtb_tail
argument_list|(
name|scp
operator|->
name|history
argument_list|)
expr_stmt|;
name|history_to_screen
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
literal|1
expr_stmt|;
block|}
name|sc_vtb_seek
argument_list|(
name|scp
operator|->
name|history
argument_list|,
name|sc_vtb_pos
argument_list|(
name|scp
operator|->
name|history
argument_list|,
name|sc_vtb_tail
argument_list|(
name|scp
operator|->
name|history
argument_list|)
argument_list|,
operator|-
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* copy screen-full of saved lines */
end_comment

begin_function
specifier|static
name|void
name|history_to_screen
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|int
name|pos
decl_stmt|;
name|int
name|i
decl_stmt|;
name|pos
operator|=
name|scp
operator|->
name|history_pos
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|scp
operator|->
name|ysize
condition|;
operator|++
name|i
control|)
block|{
name|pos
operator|=
name|sc_vtb_pos
argument_list|(
name|scp
operator|->
name|history
argument_list|,
name|pos
argument_list|,
operator|-
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
name|sc_vtb_copy
argument_list|(
name|scp
operator|->
name|history
argument_list|,
name|pos
argument_list|,
operator|&
name|scp
operator|->
name|vtb
argument_list|,
name|scp
operator|->
name|xsize
operator|*
operator|(
name|scp
operator|->
name|ysize
operator|-
name|i
operator|)
argument_list|,
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
block|}
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* go to the tail of the history buffer */
end_comment

begin_function
name|void
name|sc_hist_home
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|scp
operator|->
name|history_pos
operator|=
name|sc_vtb_tail
argument_list|(
name|scp
operator|->
name|history
argument_list|)
expr_stmt|;
name|history_to_screen
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* go to the top of the history buffer */
end_comment

begin_function
name|void
name|sc_hist_end
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|scp
operator|->
name|history_pos
operator|=
name|sc_vtb_pos
argument_list|(
name|scp
operator|->
name|history
argument_list|,
name|sc_vtb_tail
argument_list|(
name|scp
operator|->
name|history
argument_list|)
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
argument_list|)
expr_stmt|;
name|history_to_screen
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* move one line up */
end_comment

begin_function
name|int
name|sc_hist_up_line
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
if|if
condition|(
name|sc_vtb_pos
argument_list|(
name|scp
operator|->
name|history
argument_list|,
name|scp
operator|->
name|history_pos
argument_list|,
operator|-
operator|(
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
operator|)
argument_list|)
operator|==
name|sc_vtb_tail
argument_list|(
name|scp
operator|->
name|history
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|scp
operator|->
name|history_pos
operator|=
name|sc_vtb_pos
argument_list|(
name|scp
operator|->
name|history
argument_list|,
name|scp
operator|->
name|history_pos
argument_list|,
operator|-
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
name|history_to_screen
argument_list|(
name|scp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* move one line down */
end_comment

begin_function
name|int
name|sc_hist_down_line
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
if|if
condition|(
name|scp
operator|->
name|history_pos
operator|==
name|sc_vtb_tail
argument_list|(
name|scp
operator|->
name|history
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|scp
operator|->
name|history_pos
operator|=
name|sc_vtb_pos
argument_list|(
name|scp
operator|->
name|history
argument_list|,
name|scp
operator|->
name|history_pos
argument_list|,
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
name|history_to_screen
argument_list|(
name|scp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|sc_hist_ioctl
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|scr_stat
modifier|*
name|scp
decl_stmt|;
name|int
name|error
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|CONS_HISTORY
case|:
comment|/* set history size */
name|scp
operator|=
name|SC_STAT
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|<=
literal|0
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|BUFFER_SAVED
condition|)
return|return
name|EBUSY
return|;
name|DPRINTF
argument_list|(
literal|5
argument_list|,
operator|(
literal|"lines:%d, ysize:%d, pool:%d\n"
operator|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|,
name|scp
operator|->
name|ysize
operator|,
name|extra_history_size
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|sc_alloc_history_buffer
argument_list|(
name|scp
argument_list|,
name|imax
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|,
name|scp
operator|->
name|ysize
argument_list|)
argument_list|,
name|scp
operator|->
name|ysize
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|5
argument_list|,
operator|(
literal|"error:%d, rows:%d, pool:%d\n"
operator|,
name|error
operator|,
name|sc_vtb_rows
argument_list|(
name|scp
operator|->
name|history
argument_list|)
operator|,
name|extra_history_size
operator|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
case|case
name|CONS_CLRHIST
case|:
name|scp
operator|=
name|SC_STAT
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|sc_vtb_clear
argument_list|(
name|scp
operator|->
name|history
argument_list|,
name|scp
operator|->
name|sc
operator|->
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|SC_NORM_ATTR
operator|<<
literal|8
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|ENOIOCTL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SC_NO_HISTORY */
end_comment

end_unit

