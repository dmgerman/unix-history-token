begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1999 Kazutaka YOKOTA<yokota@zodiac.mech.utsunomiya-u.ac.jp>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer as  *    the first lines of this file unmodified.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"opt_syscons.h"
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<machine/console.h>
end_include

begin_include
include|#
directive|include
file|<machine/mouse.h>
end_include

begin_include
include|#
directive|include
file|<dev/syscons/syscons.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SC_TWOBUTTON_MOUSE
end_ifdef

begin_define
define|#
directive|define
name|SC_MOUSE_PASTEBUTTON
value|MOUSE_BUTTON3DOWN
end_define

begin_comment
comment|/* right button */
end_comment

begin_define
define|#
directive|define
name|SC_MOUSE_EXTENDBUTTON
value|MOUSE_BUTTON2DOWN
end_define

begin_comment
comment|/* not really used */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SC_MOUSE_PASTEBUTTON
value|MOUSE_BUTTON2DOWN
end_define

begin_comment
comment|/* middle button */
end_comment

begin_define
define|#
directive|define
name|SC_MOUSE_EXTENDBUTTON
value|MOUSE_BUTTON3DOWN
end_define

begin_comment
comment|/* right button */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SC_TWOBUTTON_MOUSE */
end_comment

begin_define
define|#
directive|define
name|SC_WAKEUP_DELTA
value|20
end_define

begin_comment
comment|/* for backward compatibility */
end_comment

begin_define
define|#
directive|define
name|OLD_CONS_MOUSECTL
value|_IOWR('c', 10, old_mouse_info_t)
end_define

begin_typedef
typedef|typedef
struct|struct
name|old_mouse_data
block|{
name|int
name|x
decl_stmt|;
name|int
name|y
decl_stmt|;
name|int
name|buttons
decl_stmt|;
block|}
name|old_mouse_data_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|old_mouse_info
block|{
name|int
name|operation
decl_stmt|;
union|union
block|{
name|struct
name|old_mouse_data
name|data
decl_stmt|;
name|struct
name|mouse_mode
name|mode
decl_stmt|;
block|}
name|u
union|;
block|}
name|old_mouse_info_t
typedef|;
end_typedef

begin_ifndef
ifndef|#
directive|ifndef
name|SC_NO_SYSMOUSE
end_ifndef

begin_comment
comment|/* local variables */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cut_buffer_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
modifier|*
name|cut_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* local functions */
end_comment

begin_function_decl
specifier|static
name|void
name|set_mouse_pos
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|SC_NO_CUTPASTE
end_ifndef

begin_function_decl
specifier|static
name|int
name|skip_spc_right
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|skip_spc_left
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mouse_cut
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mouse_cut_start
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mouse_cut_end
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mouse_cut_word
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mouse_cut_line
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mouse_cut_extend
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mouse_paste
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SC_NO_CUTPASTE */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SC_NO_CUTPASTE
end_ifndef

begin_comment
comment|/* allocate a cut buffer */
end_comment

begin_function
name|void
name|sc_alloc_cut_buffer
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|wait
parameter_list|)
block|{
name|u_char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|cut_buffer
operator|==
name|NULL
operator|)
operator|||
operator|(
name|cut_buffer_size
operator|<
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
operator|+
literal|1
operator|)
condition|)
block|{
name|p
operator|=
name|cut_buffer
expr_stmt|;
name|cut_buffer
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|p
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|cut_buffer_size
operator|=
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
operator|+
literal|1
expr_stmt|;
name|p
operator|=
operator|(
name|u_char
operator|*
operator|)
name|malloc
argument_list|(
name|cut_buffer_size
argument_list|,
name|M_DEVBUF
argument_list|,
operator|(
name|wait
operator|)
condition|?
name|M_WAITOK
else|:
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|p
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cut_buffer
operator|=
name|p
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SC_NO_CUTPASTE */
end_comment

begin_comment
comment|/* move mouse */
end_comment

begin_function
name|void
name|sc_mouse_move
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|scp
operator|->
name|mouse_xpos
operator|=
name|scp
operator|->
name|mouse_oldxpos
operator|=
name|x
expr_stmt|;
name|scp
operator|->
name|mouse_ypos
operator|=
name|scp
operator|->
name|mouse_oldypos
operator|=
name|y
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|font_size
operator|<=
literal|0
condition|)
name|scp
operator|->
name|mouse_pos
operator|=
name|scp
operator|->
name|mouse_oldpos
operator|=
literal|0
expr_stmt|;
else|else
name|scp
operator|->
name|mouse_pos
operator|=
name|scp
operator|->
name|mouse_oldpos
operator|=
operator|(
name|y
operator|/
name|scp
operator|->
name|font_size
operator|-
name|scp
operator|->
name|yoff
operator|)
operator|*
name|scp
operator|->
name|xsize
operator|+
name|x
operator|/
literal|8
operator|-
name|scp
operator|->
name|xoff
expr_stmt|;
name|scp
operator|->
name|status
operator||=
name|MOUSE_MOVED
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* adjust mouse position */
end_comment

begin_function
specifier|static
name|void
name|set_mouse_pos
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
if|if
condition|(
name|scp
operator|->
name|mouse_xpos
operator|<
name|scp
operator|->
name|xoff
operator|*
literal|8
condition|)
name|scp
operator|->
name|mouse_xpos
operator|=
name|scp
operator|->
name|xoff
operator|*
literal|8
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|mouse_ypos
operator|<
name|scp
operator|->
name|yoff
operator|*
name|scp
operator|->
name|font_size
condition|)
name|scp
operator|->
name|mouse_ypos
operator|=
name|scp
operator|->
name|yoff
operator|*
name|scp
operator|->
name|font_size
expr_stmt|;
if|if
condition|(
name|ISGRAPHSC
argument_list|(
name|scp
argument_list|)
condition|)
block|{
if|if
condition|(
name|scp
operator|->
name|mouse_xpos
operator|>
name|scp
operator|->
name|xpixel
operator|-
literal|1
condition|)
name|scp
operator|->
name|mouse_xpos
operator|=
name|scp
operator|->
name|xpixel
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|mouse_ypos
operator|>
name|scp
operator|->
name|ypixel
operator|-
literal|1
condition|)
name|scp
operator|->
name|mouse_ypos
operator|=
name|scp
operator|->
name|ypixel
operator|-
literal|1
expr_stmt|;
return|return;
block|}
else|else
block|{
if|if
condition|(
name|scp
operator|->
name|mouse_xpos
operator|>
operator|(
name|scp
operator|->
name|xsize
operator|+
name|scp
operator|->
name|xoff
operator|)
operator|*
literal|8
operator|-
literal|1
condition|)
name|scp
operator|->
name|mouse_xpos
operator|=
operator|(
name|scp
operator|->
name|xsize
operator|+
name|scp
operator|->
name|xoff
operator|)
operator|*
literal|8
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|mouse_ypos
operator|>
operator|(
name|scp
operator|->
name|ysize
operator|+
name|scp
operator|->
name|yoff
operator|)
operator|*
name|scp
operator|->
name|font_size
operator|-
literal|1
condition|)
name|scp
operator|->
name|mouse_ypos
operator|=
operator|(
name|scp
operator|->
name|ysize
operator|+
name|scp
operator|->
name|yoff
operator|)
operator|*
name|scp
operator|->
name|font_size
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|scp
operator|->
name|mouse_xpos
operator|!=
name|scp
operator|->
name|mouse_oldxpos
operator|||
name|scp
operator|->
name|mouse_ypos
operator|!=
name|scp
operator|->
name|mouse_oldypos
condition|)
block|{
name|scp
operator|->
name|status
operator||=
name|MOUSE_MOVED
expr_stmt|;
name|scp
operator|->
name|mouse_pos
operator|=
operator|(
name|scp
operator|->
name|mouse_ypos
operator|/
name|scp
operator|->
name|font_size
operator|-
name|scp
operator|->
name|yoff
operator|)
operator|*
name|scp
operator|->
name|xsize
operator|+
name|scp
operator|->
name|mouse_xpos
operator|/
literal|8
operator|-
name|scp
operator|->
name|xoff
expr_stmt|;
ifndef|#
directive|ifndef
name|SC_NO_CUTPASTE
if|if
condition|(
operator|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_VISIBLE
operator|)
operator|&&
operator|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_CUTTING
operator|)
condition|)
name|mouse_cut
argument_list|(
name|scp
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|SC_NO_CUTPASTE
end_ifndef

begin_function
name|void
name|sc_draw_mouse_image
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
if|if
condition|(
name|ISGRAPHSC
argument_list|(
name|scp
argument_list|)
condition|)
return|return;
operator|++
name|scp
operator|->
name|sc
operator|->
name|videoio_in_progress
expr_stmt|;
call|(
modifier|*
name|scp
operator|->
name|rndr
operator|->
name|draw_mouse
call|)
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|mouse_xpos
argument_list|,
name|scp
operator|->
name|mouse_ypos
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|scp
operator|->
name|mouse_oldpos
operator|=
name|scp
operator|->
name|mouse_pos
expr_stmt|;
name|scp
operator|->
name|mouse_oldxpos
operator|=
name|scp
operator|->
name|mouse_xpos
expr_stmt|;
name|scp
operator|->
name|mouse_oldypos
operator|=
name|scp
operator|->
name|mouse_ypos
expr_stmt|;
name|scp
operator|->
name|status
operator||=
name|MOUSE_VISIBLE
expr_stmt|;
operator|--
name|scp
operator|->
name|sc
operator|->
name|videoio_in_progress
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sc_remove_mouse_image
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|int
name|size
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ISGRAPHSC
argument_list|(
name|scp
argument_list|)
condition|)
return|return;
operator|++
name|scp
operator|->
name|sc
operator|->
name|videoio_in_progress
expr_stmt|;
call|(
modifier|*
name|scp
operator|->
name|rndr
operator|->
name|draw_mouse
call|)
argument_list|(
name|scp
argument_list|,
operator|(
name|scp
operator|->
name|mouse_oldpos
operator|%
name|scp
operator|->
name|xsize
operator|+
name|scp
operator|->
name|xoff
operator|)
operator|*
literal|8
argument_list|,
operator|(
name|scp
operator|->
name|mouse_oldpos
operator|/
name|scp
operator|->
name|xsize
operator|+
name|scp
operator|->
name|yoff
operator|)
operator|*
name|scp
operator|->
name|font_size
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|size
operator|=
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
expr_stmt|;
name|i
operator|=
name|scp
operator|->
name|mouse_oldpos
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|i
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|PC98
if|if
condition|(
name|i
operator|+
name|scp
operator|->
name|xsize
operator|+
literal|1
operator|<
name|size
condition|)
block|{
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|i
operator|+
name|scp
operator|->
name|xsize
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|+
name|scp
operator|->
name|xsize
operator|<
name|size
condition|)
block|{
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|i
operator|+
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|size
condition|)
block|{
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* PC98 */
name|scp
operator|->
name|status
operator|&=
operator|~
name|MOUSE_VISIBLE
expr_stmt|;
operator|--
name|scp
operator|->
name|sc
operator|->
name|videoio_in_progress
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sc_inside_cutmark
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|pos
parameter_list|)
block|{
name|int
name|start
decl_stmt|;
name|int
name|end
decl_stmt|;
if|if
condition|(
name|scp
operator|->
name|mouse_cut_end
operator|<
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|scp
operator|->
name|mouse_cut_start
operator|<=
name|scp
operator|->
name|mouse_cut_end
condition|)
block|{
name|start
operator|=
name|scp
operator|->
name|mouse_cut_start
expr_stmt|;
name|end
operator|=
name|scp
operator|->
name|mouse_cut_end
expr_stmt|;
block|}
else|else
block|{
name|start
operator|=
name|scp
operator|->
name|mouse_cut_end
expr_stmt|;
name|end
operator|=
name|scp
operator|->
name|mouse_cut_start
operator|-
literal|1
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|start
operator|<=
name|pos
operator|)
operator|&&
operator|(
name|pos
operator|<=
name|end
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sc_remove_cutmarking
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|mouse_cut_end
operator|>=
literal|0
condition|)
block|{
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|mouse_cut_start
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|mouse_cut_end
argument_list|)
expr_stmt|;
block|}
name|scp
operator|->
name|mouse_cut_start
operator|=
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
expr_stmt|;
name|scp
operator|->
name|mouse_cut_end
operator|=
operator|-
literal|1
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|scp
operator|->
name|status
operator|&=
operator|~
name|MOUSE_CUTTING
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sc_remove_all_cutmarkings
parameter_list|(
name|sc_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|scr_stat
modifier|*
name|scp
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* delete cut markings in all vtys */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|vtys
condition|;
operator|++
name|i
control|)
block|{
name|scp
operator|=
name|SC_STAT
argument_list|(
name|sc
operator|->
name|dev
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|==
name|NULL
condition|)
continue|continue;
name|sc_remove_cutmarking
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sc_remove_all_mouse
parameter_list|(
name|sc_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|scr_stat
modifier|*
name|scp
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|vtys
condition|;
operator|++
name|i
control|)
block|{
name|scp
operator|=
name|SC_STAT
argument_list|(
name|sc
operator|->
name|dev
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_VISIBLE
condition|)
block|{
name|scp
operator|->
name|status
operator|&=
operator|~
name|MOUSE_VISIBLE
expr_stmt|;
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_define
define|#
directive|define
name|IS_SPACE_CHAR
parameter_list|(
name|c
parameter_list|)
value|(((c)& 0xff) == ' ')
end_define

begin_comment
comment|/* skip spaces to right */
end_comment

begin_function
specifier|static
name|int
name|skip_spc_right
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|p
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|p
operator|%
name|scp
operator|->
name|xsize
init|;
name|i
operator|<
name|scp
operator|->
name|xsize
condition|;
operator|++
name|i
control|)
block|{
name|c
operator|=
name|sc_vtb_getc
argument_list|(
operator|&
name|scp
operator|->
name|vtb
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IS_SPACE_CHAR
argument_list|(
name|c
argument_list|)
condition|)
break|break;
operator|++
name|p
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* skip spaces to left */
end_comment

begin_function
specifier|static
name|int
name|skip_spc_left
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|p
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|p
operator|--
operator|%
name|scp
operator|->
name|xsize
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|c
operator|=
name|sc_vtb_getc
argument_list|(
operator|&
name|scp
operator|->
name|vtb
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IS_SPACE_CHAR
argument_list|(
name|c
argument_list|)
condition|)
break|break;
operator|--
name|p
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* copy marked region to the cut buffer */
end_comment

begin_function
specifier|static
name|void
name|mouse_cut
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|int
name|start
decl_stmt|;
name|int
name|end
decl_stmt|;
name|int
name|from
decl_stmt|;
name|int
name|to
decl_stmt|;
name|int
name|blank
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|p
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
name|start
operator|=
name|scp
operator|->
name|mouse_cut_start
expr_stmt|;
name|end
operator|=
name|scp
operator|->
name|mouse_cut_end
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|mouse_pos
operator|>=
name|start
condition|)
block|{
name|from
operator|=
name|start
expr_stmt|;
name|to
operator|=
name|end
operator|=
name|scp
operator|->
name|mouse_pos
expr_stmt|;
block|}
else|else
block|{
name|from
operator|=
name|end
operator|=
name|scp
operator|->
name|mouse_pos
expr_stmt|;
name|to
operator|=
name|start
operator|-
literal|1
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|from
operator|,
name|i
operator|=
name|blank
operator|=
literal|0
init|;
name|p
operator|<=
name|to
condition|;
operator|++
name|p
control|)
block|{
name|cut_buffer
index|[
name|i
index|]
operator|=
name|sc_vtb_getc
argument_list|(
operator|&
name|scp
operator|->
name|vtb
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* remember the position of the last non-space char */
if|if
condition|(
operator|!
name|IS_SPACE_CHAR
argument_list|(
name|cut_buffer
index|[
name|i
operator|++
index|]
argument_list|)
condition|)
name|blank
operator|=
name|i
expr_stmt|;
comment|/* the first space after the last non-space */
comment|/* trim trailing blank when crossing lines */
if|if
condition|(
operator|(
name|p
operator|%
name|scp
operator|->
name|xsize
operator|)
operator|==
operator|(
name|scp
operator|->
name|xsize
operator|-
literal|1
operator|)
condition|)
block|{
name|cut_buffer
index|[
name|blank
index|]
operator|=
literal|'\r'
expr_stmt|;
name|i
operator|=
name|blank
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|cut_buffer
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* scan towards the end of the last line */
operator|--
name|p
expr_stmt|;
for|for
control|(
name|i
operator|=
name|p
operator|%
name|scp
operator|->
name|xsize
init|;
name|i
operator|<
name|scp
operator|->
name|xsize
condition|;
operator|++
name|i
control|)
block|{
name|c
operator|=
name|sc_vtb_getc
argument_list|(
operator|&
name|scp
operator|->
name|vtb
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IS_SPACE_CHAR
argument_list|(
name|c
argument_list|)
condition|)
break|break;
operator|++
name|p
expr_stmt|;
block|}
comment|/* if there is nothing but blank chars, trim them, but mark towards eol */
if|if
condition|(
name|i
operator|>=
name|scp
operator|->
name|xsize
condition|)
block|{
if|if
condition|(
name|end
operator|>=
name|start
condition|)
name|to
operator|=
name|end
operator|=
name|p
operator|-
literal|1
expr_stmt|;
else|else
name|to
operator|=
name|start
operator|=
name|p
expr_stmt|;
name|cut_buffer
index|[
name|blank
operator|++
index|]
operator|=
literal|'\r'
expr_stmt|;
name|cut_buffer
index|[
name|blank
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* remove the current marking */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|mouse_cut_start
operator|<=
name|scp
operator|->
name|mouse_cut_end
condition|)
block|{
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|mouse_cut_start
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|mouse_cut_end
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scp
operator|->
name|mouse_cut_end
operator|>=
literal|0
condition|)
block|{
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|mouse_cut_end
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|mouse_cut_start
argument_list|)
expr_stmt|;
block|}
comment|/* mark the new region */
name|scp
operator|->
name|mouse_cut_start
operator|=
name|start
expr_stmt|;
name|scp
operator|->
name|mouse_cut_end
operator|=
name|end
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* a mouse button is pressed, start cut operation */
end_comment

begin_function
specifier|static
name|void
name|mouse_cut_start
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_VISIBLE
condition|)
block|{
name|i
operator|=
name|scp
operator|->
name|mouse_cut_start
expr_stmt|;
name|j
operator|=
name|scp
operator|->
name|mouse_cut_end
expr_stmt|;
name|sc_remove_all_cutmarkings
argument_list|(
name|scp
operator|->
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|mouse_pos
operator|==
name|i
operator|&&
name|i
operator|==
name|j
condition|)
block|{
name|cut_buffer
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|skip_spc_right
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|mouse_pos
argument_list|)
operator|>=
name|scp
operator|->
name|xsize
condition|)
block|{
comment|/* if the pointer is on trailing blank chars, mark towards eol */
name|i
operator|=
name|skip_spc_left
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|mouse_pos
argument_list|)
operator|+
literal|1
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|scp
operator|->
name|mouse_cut_start
operator|=
operator|(
name|scp
operator|->
name|mouse_pos
operator|/
name|scp
operator|->
name|xsize
operator|)
operator|*
name|scp
operator|->
name|xsize
operator|+
name|i
expr_stmt|;
name|scp
operator|->
name|mouse_cut_end
operator|=
operator|(
name|scp
operator|->
name|mouse_pos
operator|/
name|scp
operator|->
name|xsize
operator|+
literal|1
operator|)
operator|*
name|scp
operator|->
name|xsize
operator|-
literal|1
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|cut_buffer
index|[
literal|0
index|]
operator|=
literal|'\r'
expr_stmt|;
name|cut_buffer
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|scp
operator|->
name|status
operator||=
name|MOUSE_CUTTING
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|scp
operator|->
name|mouse_cut_start
operator|=
name|scp
operator|->
name|mouse_pos
expr_stmt|;
name|scp
operator|->
name|mouse_cut_end
operator|=
name|scp
operator|->
name|mouse_cut_start
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|cut_buffer
index|[
literal|0
index|]
operator|=
name|sc_vtb_getc
argument_list|(
operator|&
name|scp
operator|->
name|vtb
argument_list|,
name|scp
operator|->
name|mouse_cut_start
argument_list|)
expr_stmt|;
name|cut_buffer
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|scp
operator|->
name|status
operator||=
name|MOUSE_CUTTING
expr_stmt|;
block|}
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
comment|/* this is probably overkill XXX */
block|}
block|}
end_function

begin_comment
comment|/* end of cut operation */
end_comment

begin_function
specifier|static
name|void
name|mouse_cut_end
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_VISIBLE
condition|)
name|scp
operator|->
name|status
operator|&=
operator|~
name|MOUSE_CUTTING
expr_stmt|;
block|}
end_function

begin_comment
comment|/* copy a word under the mouse pointer */
end_comment

begin_function
specifier|static
name|void
name|mouse_cut_word
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|int
name|start
decl_stmt|;
name|int
name|end
decl_stmt|;
name|int
name|sol
decl_stmt|;
name|int
name|eol
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
comment|/*      * Because we don't have locale information in the kernel,      * we only distinguish space char and non-space chars.  Punctuation      * chars, symbols and other regular chars are all treated alike.      */
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_VISIBLE
condition|)
block|{
comment|/* remove the current cut mark */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|mouse_cut_start
operator|<=
name|scp
operator|->
name|mouse_cut_end
condition|)
block|{
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|mouse_cut_start
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|mouse_cut_end
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scp
operator|->
name|mouse_cut_end
operator|>=
literal|0
condition|)
block|{
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|mouse_cut_end
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|mouse_cut_start
argument_list|)
expr_stmt|;
block|}
name|scp
operator|->
name|mouse_cut_start
operator|=
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
expr_stmt|;
name|scp
operator|->
name|mouse_cut_end
operator|=
operator|-
literal|1
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|sol
operator|=
operator|(
name|scp
operator|->
name|mouse_pos
operator|/
name|scp
operator|->
name|xsize
operator|)
operator|*
name|scp
operator|->
name|xsize
expr_stmt|;
name|eol
operator|=
name|sol
operator|+
name|scp
operator|->
name|xsize
expr_stmt|;
name|c
operator|=
name|sc_vtb_getc
argument_list|(
operator|&
name|scp
operator|->
name|vtb
argument_list|,
name|scp
operator|->
name|mouse_pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_SPACE_CHAR
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* blank space */
for|for
control|(
name|j
operator|=
name|scp
operator|->
name|mouse_pos
init|;
name|j
operator|>=
name|sol
condition|;
operator|--
name|j
control|)
block|{
name|c
operator|=
name|sc_vtb_getc
argument_list|(
operator|&
name|scp
operator|->
name|vtb
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IS_SPACE_CHAR
argument_list|(
name|c
argument_list|)
condition|)
break|break;
block|}
name|start
operator|=
operator|++
name|j
expr_stmt|;
for|for
control|(
name|j
operator|=
name|scp
operator|->
name|mouse_pos
init|;
name|j
operator|<
name|eol
condition|;
operator|++
name|j
control|)
block|{
name|c
operator|=
name|sc_vtb_getc
argument_list|(
operator|&
name|scp
operator|->
name|vtb
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IS_SPACE_CHAR
argument_list|(
name|c
argument_list|)
condition|)
break|break;
block|}
name|end
operator|=
name|j
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* non-space word */
for|for
control|(
name|j
operator|=
name|scp
operator|->
name|mouse_pos
init|;
name|j
operator|>=
name|sol
condition|;
operator|--
name|j
control|)
block|{
name|c
operator|=
name|sc_vtb_getc
argument_list|(
operator|&
name|scp
operator|->
name|vtb
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_SPACE_CHAR
argument_list|(
name|c
argument_list|)
condition|)
break|break;
block|}
name|start
operator|=
operator|++
name|j
expr_stmt|;
for|for
control|(
name|j
operator|=
name|scp
operator|->
name|mouse_pos
init|;
name|j
operator|<
name|eol
condition|;
operator|++
name|j
control|)
block|{
name|c
operator|=
name|sc_vtb_getc
argument_list|(
operator|&
name|scp
operator|->
name|vtb
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_SPACE_CHAR
argument_list|(
name|c
argument_list|)
condition|)
break|break;
block|}
name|end
operator|=
name|j
operator|-
literal|1
expr_stmt|;
block|}
comment|/* copy the found word */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
name|start
init|;
name|j
operator|<=
name|end
condition|;
operator|++
name|j
control|)
name|cut_buffer
index|[
name|i
operator|++
index|]
operator|=
name|sc_vtb_getc
argument_list|(
operator|&
name|scp
operator|->
name|vtb
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|cut_buffer
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|scp
operator|->
name|status
operator||=
name|MOUSE_CUTTING
expr_stmt|;
comment|/* mark the region */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|scp
operator|->
name|mouse_cut_start
operator|=
name|start
expr_stmt|;
name|scp
operator|->
name|mouse_cut_end
operator|=
name|end
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* copy a line under the mouse pointer */
end_comment

begin_function
specifier|static
name|void
name|mouse_cut_line
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_VISIBLE
condition|)
block|{
comment|/* remove the current cut mark */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|mouse_cut_start
operator|<=
name|scp
operator|->
name|mouse_cut_end
condition|)
block|{
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|mouse_cut_start
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|mouse_cut_end
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scp
operator|->
name|mouse_cut_end
operator|>=
literal|0
condition|)
block|{
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|mouse_cut_end
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|mouse_cut_start
argument_list|)
expr_stmt|;
block|}
comment|/* mark the entire line */
name|scp
operator|->
name|mouse_cut_start
operator|=
operator|(
name|scp
operator|->
name|mouse_pos
operator|/
name|scp
operator|->
name|xsize
operator|)
operator|*
name|scp
operator|->
name|xsize
expr_stmt|;
name|scp
operator|->
name|mouse_cut_end
operator|=
name|scp
operator|->
name|mouse_cut_start
operator|+
name|scp
operator|->
name|xsize
operator|-
literal|1
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|mouse_cut_start
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|mouse_cut_end
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* copy the line into the cut buffer */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
name|scp
operator|->
name|mouse_cut_start
init|;
name|j
operator|<=
name|scp
operator|->
name|mouse_cut_end
condition|;
operator|++
name|j
control|)
name|cut_buffer
index|[
name|i
operator|++
index|]
operator|=
name|sc_vtb_getc
argument_list|(
operator|&
name|scp
operator|->
name|vtb
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|cut_buffer
index|[
name|i
operator|++
index|]
operator|=
literal|'\r'
expr_stmt|;
name|cut_buffer
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|scp
operator|->
name|status
operator||=
name|MOUSE_CUTTING
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* extend the marked region to the mouse pointer position */
end_comment

begin_function
specifier|static
name|void
name|mouse_cut_extend
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|int
name|start
decl_stmt|;
name|int
name|end
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_VISIBLE
operator|)
operator|&&
operator|!
operator|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_CUTTING
operator|)
operator|&&
operator|(
name|scp
operator|->
name|mouse_cut_end
operator|>=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|scp
operator|->
name|mouse_cut_start
operator|<=
name|scp
operator|->
name|mouse_cut_end
condition|)
block|{
name|start
operator|=
name|scp
operator|->
name|mouse_cut_start
expr_stmt|;
name|end
operator|=
name|scp
operator|->
name|mouse_cut_end
expr_stmt|;
block|}
else|else
block|{
name|start
operator|=
name|scp
operator|->
name|mouse_cut_end
expr_stmt|;
name|end
operator|=
name|scp
operator|->
name|mouse_cut_start
operator|-
literal|1
expr_stmt|;
block|}
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|mouse_pos
operator|>
name|end
condition|)
block|{
name|scp
operator|->
name|mouse_cut_start
operator|=
name|start
expr_stmt|;
name|scp
operator|->
name|mouse_cut_end
operator|=
name|end
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scp
operator|->
name|mouse_pos
operator|<
name|start
condition|)
block|{
name|scp
operator|->
name|mouse_cut_start
operator|=
name|end
operator|+
literal|1
expr_stmt|;
name|scp
operator|->
name|mouse_cut_end
operator|=
name|start
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|scp
operator|->
name|mouse_pos
operator|-
name|start
operator|>
name|end
operator|+
literal|1
operator|-
name|scp
operator|->
name|mouse_pos
condition|)
block|{
name|scp
operator|->
name|mouse_cut_start
operator|=
name|start
expr_stmt|;
name|scp
operator|->
name|mouse_cut_end
operator|=
name|end
expr_stmt|;
block|}
else|else
block|{
name|scp
operator|->
name|mouse_cut_start
operator|=
name|end
operator|+
literal|1
expr_stmt|;
name|scp
operator|->
name|mouse_cut_end
operator|=
name|start
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|mouse_cut
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|scp
operator|->
name|status
operator||=
name|MOUSE_CUTTING
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* paste cut buffer contents into the current vty */
end_comment

begin_function
specifier|static
name|void
name|mouse_paste
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_VISIBLE
condition|)
name|sc_paste
argument_list|(
name|scp
argument_list|,
name|cut_buffer
argument_list|,
name|strlen
argument_list|(
name|cut_buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SC_NO_CUTPASTE */
end_comment

begin_function
name|int
name|sc_mouse_ioctl
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|mouse_info_t
modifier|*
name|mouse
decl_stmt|;
name|mouse_info_t
name|buf
decl_stmt|;
name|scr_stat
modifier|*
name|cur_scp
decl_stmt|;
name|scr_stat
modifier|*
name|scp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|f
decl_stmt|;
name|scp
operator|=
name|SC_STAT
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|CONS_MOUSECTL
case|:
comment|/* control mouse arrow */
case|case
name|OLD_CONS_MOUSECTL
case|:
name|mouse
operator|=
operator|(
name|mouse_info_t
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|OLD_CONS_MOUSECTL
condition|)
block|{
specifier|static
name|u_char
name|swapb
index|[]
init|=
block|{
literal|0
block|,
literal|4
block|,
literal|2
block|,
literal|6
block|,
literal|1
block|,
literal|5
block|,
literal|3
block|,
literal|7
block|}
decl_stmt|;
name|old_mouse_info_t
modifier|*
name|old_mouse
init|=
operator|(
name|old_mouse_info_t
operator|*
operator|)
name|data
decl_stmt|;
name|mouse
operator|=
operator|&
name|buf
expr_stmt|;
name|mouse
operator|->
name|operation
operator|=
name|old_mouse
operator|->
name|operation
expr_stmt|;
switch|switch
condition|(
name|mouse
operator|->
name|operation
condition|)
block|{
case|case
name|MOUSE_MODE
case|:
name|mouse
operator|->
name|u
operator|.
name|mode
operator|=
name|old_mouse
operator|->
name|u
operator|.
name|mode
expr_stmt|;
break|break;
case|case
name|MOUSE_SHOW
case|:
case|case
name|MOUSE_HIDE
case|:
break|break;
case|case
name|MOUSE_MOVEABS
case|:
case|case
name|MOUSE_MOVEREL
case|:
case|case
name|MOUSE_ACTION
case|:
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|x
operator|=
name|old_mouse
operator|->
name|u
operator|.
name|data
operator|.
name|x
expr_stmt|;
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|y
operator|=
name|old_mouse
operator|->
name|u
operator|.
name|data
operator|.
name|y
expr_stmt|;
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|z
operator|=
literal|0
expr_stmt|;
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|buttons
operator|=
name|swapb
index|[
name|old_mouse
operator|->
name|u
operator|.
name|data
operator|.
name|buttons
operator|&
literal|0x7
index|]
expr_stmt|;
break|break;
case|case
name|MOUSE_GETINFO
case|:
name|old_mouse
operator|->
name|u
operator|.
name|data
operator|.
name|x
operator|=
name|scp
operator|->
name|mouse_xpos
expr_stmt|;
name|old_mouse
operator|->
name|u
operator|.
name|data
operator|.
name|y
operator|=
name|scp
operator|->
name|mouse_ypos
expr_stmt|;
name|old_mouse
operator|->
name|u
operator|.
name|data
operator|.
name|buttons
operator|=
name|swapb
index|[
name|scp
operator|->
name|mouse_buttons
operator|&
literal|0x7
index|]
expr_stmt|;
return|return
literal|0
return|;
default|default:
return|return
name|EINVAL
return|;
block|}
block|}
name|cur_scp
operator|=
name|scp
operator|->
name|sc
operator|->
name|cur_scp
expr_stmt|;
switch|switch
condition|(
name|mouse
operator|->
name|operation
condition|)
block|{
case|case
name|MOUSE_MODE
case|:
if|if
condition|(
name|ISSIGVALID
argument_list|(
name|mouse
operator|->
name|u
operator|.
name|mode
operator|.
name|signal
argument_list|)
condition|)
block|{
name|scp
operator|->
name|mouse_signal
operator|=
name|mouse
operator|->
name|u
operator|.
name|mode
operator|.
name|signal
expr_stmt|;
name|scp
operator|->
name|mouse_proc
operator|=
name|p
expr_stmt|;
name|scp
operator|->
name|mouse_pid
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
block|}
else|else
block|{
name|scp
operator|->
name|mouse_signal
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|mouse_proc
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|mouse_pid
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
case|case
name|MOUSE_SHOW
case|:
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|scp
operator|->
name|sc
operator|->
name|flags
operator|&
name|SC_MOUSE_ENABLED
operator|)
condition|)
block|{
name|scp
operator|->
name|sc
operator|->
name|flags
operator||=
name|SC_MOUSE_ENABLED
expr_stmt|;
name|cur_scp
operator|->
name|status
operator|&=
operator|~
name|MOUSE_HIDDEN
expr_stmt|;
if|if
condition|(
operator|!
name|ISGRAPHSC
argument_list|(
name|cur_scp
argument_list|)
condition|)
name|mark_all
argument_list|(
name|cur_scp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
break|break;
case|case
name|MOUSE_HIDE
case|:
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|sc
operator|->
name|flags
operator|&
name|SC_MOUSE_ENABLED
condition|)
block|{
name|scp
operator|->
name|sc
operator|->
name|flags
operator|&=
operator|~
name|SC_MOUSE_ENABLED
expr_stmt|;
name|sc_remove_all_mouse
argument_list|(
name|scp
operator|->
name|sc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
break|break;
case|case
name|MOUSE_MOVEABS
case|:
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|scp
operator|->
name|mouse_xpos
operator|=
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|x
expr_stmt|;
name|scp
operator|->
name|mouse_ypos
operator|=
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|y
expr_stmt|;
name|set_mouse_pos
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOUSE_MOVEREL
case|:
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|scp
operator|->
name|mouse_xpos
operator|+=
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|x
expr_stmt|;
name|scp
operator|->
name|mouse_ypos
operator|+=
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|y
expr_stmt|;
name|set_mouse_pos
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOUSE_GETINFO
case|:
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|x
operator|=
name|scp
operator|->
name|mouse_xpos
expr_stmt|;
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|y
operator|=
name|scp
operator|->
name|mouse_ypos
expr_stmt|;
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|z
operator|=
literal|0
expr_stmt|;
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|buttons
operator|=
name|scp
operator|->
name|mouse_buttons
expr_stmt|;
return|return
literal|0
return|;
case|case
name|MOUSE_ACTION
case|:
case|case
name|MOUSE_MOTION_EVENT
case|:
comment|/* send out mouse event on /dev/sysmouse */
if|#
directive|if
literal|0
comment|/* this should maybe only be settable from /dev/consolectl SOS */
block|if (SC_VTY(tp->t_dev) != SC_CONSOLECTL) 		return ENOTTY;
endif|#
directive|endif
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|x
operator|!=
literal|0
operator|||
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|y
operator|!=
literal|0
condition|)
block|{
name|cur_scp
operator|->
name|mouse_xpos
operator|+=
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|x
expr_stmt|;
name|cur_scp
operator|->
name|mouse_ypos
operator|+=
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|y
expr_stmt|;
name|set_mouse_pos
argument_list|(
name|cur_scp
argument_list|)
expr_stmt|;
block|}
name|f
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mouse
operator|->
name|operation
operator|==
name|MOUSE_ACTION
condition|)
block|{
name|f
operator|=
name|cur_scp
operator|->
name|mouse_buttons
operator|^
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|buttons
expr_stmt|;
name|cur_scp
operator|->
name|mouse_buttons
operator|=
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|buttons
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysmouse_event
argument_list|(
name|mouse
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/*  	     * If any buttons are down or the mouse has moved a lot,  	     * stop the screen saver. 	     */
if|if
condition|(
operator|(
operator|(
name|mouse
operator|->
name|operation
operator|==
name|MOUSE_ACTION
operator|)
operator|&&
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|buttons
operator|)
operator|||
operator|(
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|x
operator|*
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|x
operator|+
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|y
operator|*
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|y
operator|>=
name|SC_WAKEUP_DELTA
operator|*
name|SC_WAKEUP_DELTA
operator|)
condition|)
block|{
name|sc_touch_scrn_saver
argument_list|()
expr_stmt|;
block|}
name|cur_scp
operator|->
name|status
operator|&=
operator|~
name|MOUSE_HIDDEN
expr_stmt|;
if|if
condition|(
name|cur_scp
operator|->
name|mouse_signal
condition|)
block|{
comment|/* has controlling process died? */
if|if
condition|(
name|cur_scp
operator|->
name|mouse_proc
operator|&&
operator|(
name|cur_scp
operator|->
name|mouse_proc
operator|!=
name|pfind
argument_list|(
name|cur_scp
operator|->
name|mouse_pid
argument_list|)
operator|)
condition|)
block|{
name|cur_scp
operator|->
name|mouse_signal
operator|=
literal|0
expr_stmt|;
name|cur_scp
operator|->
name|mouse_proc
operator|=
name|NULL
expr_stmt|;
name|cur_scp
operator|->
name|mouse_pid
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|psignal
argument_list|(
name|cur_scp
operator|->
name|mouse_proc
argument_list|,
name|cur_scp
operator|->
name|mouse_signal
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ISGRAPHSC
argument_list|(
name|cur_scp
argument_list|)
operator|||
operator|(
name|cut_buffer
operator|==
name|NULL
operator|)
condition|)
break|break;
ifndef|#
directive|ifndef
name|SC_NO_CUTPASTE
if|if
condition|(
operator|(
name|mouse
operator|->
name|operation
operator|==
name|MOUSE_ACTION
operator|)
operator|&&
name|f
condition|)
block|{
comment|/* process button presses */
if|if
condition|(
name|cur_scp
operator|->
name|mouse_buttons
operator|&
name|MOUSE_BUTTON1DOWN
condition|)
name|mouse_cut_start
argument_list|(
name|cur_scp
argument_list|)
expr_stmt|;
else|else
name|mouse_cut_end
argument_list|(
name|cur_scp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_scp
operator|->
name|mouse_buttons
operator|&
name|MOUSE_BUTTON2DOWN
operator|||
name|cur_scp
operator|->
name|mouse_buttons
operator|&
name|MOUSE_BUTTON3DOWN
condition|)
name|mouse_paste
argument_list|(
name|cur_scp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SC_NO_CUTPASTE */
break|break;
case|case
name|MOUSE_BUTTON_EVENT
case|:
if|if
condition|(
operator|(
name|mouse
operator|->
name|u
operator|.
name|event
operator|.
name|id
operator|&
name|MOUSE_BUTTONS
operator|)
operator|==
literal|0
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|mouse
operator|->
name|u
operator|.
name|event
operator|.
name|value
operator|<
literal|0
condition|)
return|return
name|EINVAL
return|;
if|#
directive|if
literal|0
comment|/* this should maybe only be settable from /dev/consolectl SOS */
block|if (SC_VTY(tp->t_dev) != SC_CONSOLECTL) 		return ENOTTY;
endif|#
directive|endif
if|if
condition|(
name|mouse
operator|->
name|u
operator|.
name|event
operator|.
name|value
operator|>
literal|0
condition|)
name|cur_scp
operator|->
name|mouse_buttons
operator||=
name|mouse
operator|->
name|u
operator|.
name|event
operator|.
name|id
expr_stmt|;
else|else
name|cur_scp
operator|->
name|mouse_buttons
operator|&=
operator|~
name|mouse
operator|->
name|u
operator|.
name|event
operator|.
name|id
expr_stmt|;
if|if
condition|(
name|sysmouse_event
argument_list|(
name|mouse
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* if a button is held down, stop the screen saver */
if|if
condition|(
name|mouse
operator|->
name|u
operator|.
name|event
operator|.
name|value
operator|>
literal|0
condition|)
name|sc_touch_scrn_saver
argument_list|()
expr_stmt|;
name|cur_scp
operator|->
name|status
operator|&=
operator|~
name|MOUSE_HIDDEN
expr_stmt|;
if|if
condition|(
name|cur_scp
operator|->
name|mouse_signal
condition|)
block|{
if|if
condition|(
name|cur_scp
operator|->
name|mouse_proc
operator|&&
operator|(
name|cur_scp
operator|->
name|mouse_proc
operator|!=
name|pfind
argument_list|(
name|cur_scp
operator|->
name|mouse_pid
argument_list|)
operator|)
condition|)
block|{
name|cur_scp
operator|->
name|mouse_signal
operator|=
literal|0
expr_stmt|;
name|cur_scp
operator|->
name|mouse_proc
operator|=
name|NULL
expr_stmt|;
name|cur_scp
operator|->
name|mouse_pid
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|psignal
argument_list|(
name|cur_scp
operator|->
name|mouse_proc
argument_list|,
name|cur_scp
operator|->
name|mouse_signal
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ISGRAPHSC
argument_list|(
name|cur_scp
argument_list|)
operator|||
operator|(
name|cut_buffer
operator|==
name|NULL
operator|)
condition|)
break|break;
ifndef|#
directive|ifndef
name|SC_NO_CUTPASTE
switch|switch
condition|(
name|mouse
operator|->
name|u
operator|.
name|event
operator|.
name|id
condition|)
block|{
case|case
name|MOUSE_BUTTON1DOWN
case|:
switch|switch
condition|(
name|mouse
operator|->
name|u
operator|.
name|event
operator|.
name|value
operator|%
literal|4
condition|)
block|{
case|case
literal|0
case|:
comment|/* up */
name|mouse_cut_end
argument_list|(
name|cur_scp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* single click: start cut operation */
name|mouse_cut_start
argument_list|(
name|cur_scp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* double click: cut a word */
name|mouse_cut_word
argument_list|(
name|cur_scp
argument_list|)
expr_stmt|;
name|mouse_cut_end
argument_list|(
name|cur_scp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* triple click: cut a line */
name|mouse_cut_line
argument_list|(
name|cur_scp
argument_list|)
expr_stmt|;
name|mouse_cut_end
argument_list|(
name|cur_scp
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|SC_MOUSE_PASTEBUTTON
case|:
switch|switch
condition|(
name|mouse
operator|->
name|u
operator|.
name|event
operator|.
name|value
condition|)
block|{
case|case
literal|0
case|:
comment|/* up */
break|break;
default|default:
name|mouse_paste
argument_list|(
name|cur_scp
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|SC_MOUSE_EXTENDBUTTON
case|:
switch|switch
condition|(
name|mouse
operator|->
name|u
operator|.
name|event
operator|.
name|value
condition|)
block|{
case|case
literal|0
case|:
comment|/* up */
if|if
condition|(
operator|!
operator|(
name|cur_scp
operator|->
name|mouse_buttons
operator|&
name|MOUSE_BUTTON1DOWN
operator|)
condition|)
name|mouse_cut_end
argument_list|(
name|cur_scp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|mouse_cut_extend
argument_list|(
name|cur_scp
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
endif|#
directive|endif
comment|/* SC_NO_CUTPASTE */
break|break;
case|case
name|MOUSE_MOUSECHAR
case|:
if|if
condition|(
name|mouse
operator|->
name|u
operator|.
name|mouse_char
operator|<
literal|0
condition|)
block|{
name|mouse
operator|->
name|u
operator|.
name|mouse_char
operator|=
name|scp
operator|->
name|sc
operator|->
name|mouse_char
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mouse
operator|->
name|u
operator|.
name|mouse_char
operator|>=
name|UCHAR_MAX
operator|-
literal|4
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|sc_remove_all_mouse
argument_list|(
name|scp
operator|->
name|sc
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SC_NO_FONT_LOADING
if|if
condition|(
name|ISTEXTSC
argument_list|(
name|cur_scp
argument_list|)
operator|&&
operator|(
name|cur_scp
operator|->
name|font
operator|!=
name|NULL
operator|)
condition|)
name|sc_load_font
argument_list|(
name|cur_scp
argument_list|,
literal|0
argument_list|,
name|cur_scp
operator|->
name|font_size
argument_list|,
name|cur_scp
operator|->
name|font
argument_list|,
name|cur_scp
operator|->
name|sc
operator|->
name|mouse_char
argument_list|,
literal|4
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|scp
operator|->
name|sc
operator|->
name|mouse_char
operator|=
name|mouse
operator|->
name|u
operator|.
name|mouse_char
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
return|return
name|EINVAL
return|;
block|}
return|return
literal|0
return|;
block|}
return|return
name|ENOIOCTL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SC_NO_SYSMOUSE */
end_comment

end_unit

