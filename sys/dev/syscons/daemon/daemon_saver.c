begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1997 Sandro Sigala, Brescia, Italy.  * Copyright (c) 1997 Chris Shenton  * Copyright (c) 1995 SÃ¸ren Schmidt  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer  *    in this position and unchanged.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/jail.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/consio.h>
end_include

begin_include
include|#
directive|include
file|<sys/fbio.h>
end_include

begin_include
include|#
directive|include
file|<machine/pc/display.h>
end_include

begin_include
include|#
directive|include
file|<dev/fb/fbreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/fb/splashreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/syscons/syscons.h>
end_include

begin_define
define|#
directive|define
name|DAEMON_MAX_WIDTH
value|32
end_define

begin_define
define|#
directive|define
name|DAEMON_MAX_HEIGHT
value|19
end_define

begin_decl_stmt
specifier|static
name|u_char
modifier|*
name|message
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|messagelen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|blanked
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|attr_mask
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ATTR
parameter_list|(
name|attr
parameter_list|)
value|(((attr)& attr_mask)<< 8)
end_define

begin_comment
comment|/* Who is the author of this ASCII pic? */
end_comment

begin_decl_stmt
specifier|static
name|u_char
modifier|*
name|daemon_pic
index|[]
init|=
block|{
literal|"             ,        ,"
block|,
literal|"            /(        )`"
block|,
literal|"            \\ \\___   / |"
block|,
literal|"            /- _  `-/  '"
block|,
literal|"           (/\\/ \\ \\   /\\"
block|,
literal|"           / /   | `    \\"
block|,
literal|"           O O   ) /    |"
block|,
literal|"           `-^--'`<     '"
block|,
literal|"          (_.)  _  )   /"
block|,
literal|"           `.___/`    /"
block|,
literal|"             `-----' /"
block|,
literal|"<----.     __ / __   \\"
block|,
literal|"<----|====O)))==) \\) /===="
block|,
literal|"<----'    `--' `.__,' \\"
block|,
literal|"             |        |"
block|,
literal|"              \\       /       /\\"
block|,
literal|"         ______( (_  / \\______/"
block|,
literal|"       ,'  ,-----'   |"
block|,
literal|"       `--{__________)"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
modifier|*
name|daemon_attr
index|[]
init|=
block|{
literal|"             R        R"
block|,
literal|"            RR        RR"
block|,
literal|"            R RRRR   R R"
block|,
literal|"            RR W  RRR  R"
block|,
literal|"           RWWW W R   RR"
block|,
literal|"           W W   W R    R"
block|,
literal|"           B B   W R    R"
block|,
literal|"           WWWWWWRR     R"
block|,
literal|"          RRRR  R  R   R"
block|,
literal|"           RRRRRRR    R"
block|,
literal|"             RRRRRRR R"
block|,
literal|"YYYYYY     RR R RR   R"
block|,
literal|"YYYYYYYYYYRRRRYYR RR RYYYY"
block|,
literal|"YYYYYY    RRRR RRRRRR R"
block|,
literal|"             R        R"
block|,
literal|"              R       R       RR"
block|,
literal|"         CCCCCCR RR  R RRRRRRRR"
block|,
literal|"       CC  CCCCCCC   C"
block|,
literal|"       CCCCCCCCCCCCCCC"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Reverse a graphics character, or return unaltered if no mirror;  * should do alphanumerics too, but I'm too lazy.<cshenton@it.hq.nasa.gov>  */
end_comment

begin_function
specifier|static
name|u_char
name|xflip_symbol
parameter_list|(
name|u_char
name|symbol
parameter_list|)
block|{
specifier|static
specifier|const
name|u_char
name|lchars
index|[]
init|=
literal|"`'(){}[]\\/<>"
decl_stmt|;
specifier|static
specifier|const
name|u_char
name|rchars
index|[]
init|=
literal|"'`)(}{][/\\><"
decl_stmt|;
name|int
name|pos
decl_stmt|;
for|for
control|(
name|pos
operator|=
literal|0
init|;
name|lchars
index|[
name|pos
index|]
operator|!=
literal|'\0'
condition|;
name|pos
operator|++
control|)
if|if
condition|(
name|lchars
index|[
name|pos
index|]
operator|==
name|symbol
condition|)
return|return
name|rchars
index|[
name|pos
index|]
return|;
return|return
name|symbol
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|clear_daemon
parameter_list|(
name|sc_softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|xpos
parameter_list|,
name|int
name|ypos
parameter_list|,
name|int
name|dxdir
parameter_list|,
name|int
name|xoff
parameter_list|,
name|int
name|yoff
parameter_list|,
name|int
name|xlen
parameter_list|,
name|int
name|ylen
parameter_list|)
block|{
name|int
name|y
decl_stmt|;
if|if
condition|(
name|xlen
operator|<=
literal|0
condition|)
return|return;
for|for
control|(
name|y
operator|=
name|yoff
init|;
name|y
operator|<
name|ylen
condition|;
name|y
operator|++
control|)
block|{
name|sc_vtb_erase
argument_list|(
operator|&
name|sc
operator|->
name|cur_scp
operator|->
name|scr
argument_list|,
operator|(
name|ypos
operator|+
name|y
operator|)
operator|*
name|sc
operator|->
name|cur_scp
operator|->
name|xsize
operator|+
name|xpos
operator|+
name|xoff
argument_list|,
name|xlen
operator|-
name|xoff
argument_list|,
name|sc
operator|->
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|ATTR
argument_list|(
name|FG_LIGHTGREY
operator||
name|BG_BLACK
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|draw_daemon
parameter_list|(
name|sc_softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|xpos
parameter_list|,
name|int
name|ypos
parameter_list|,
name|int
name|dxdir
parameter_list|,
name|int
name|xoff
parameter_list|,
name|int
name|yoff
parameter_list|,
name|int
name|xlen
parameter_list|,
name|int
name|ylen
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|px
decl_stmt|;
name|int
name|attr
decl_stmt|;
for|for
control|(
name|y
operator|=
name|yoff
init|;
name|y
operator|<
name|ylen
condition|;
name|y
operator|++
control|)
block|{
if|if
condition|(
name|dxdir
operator|<
literal|0
condition|)
name|px
operator|=
name|xoff
expr_stmt|;
else|else
name|px
operator|=
name|DAEMON_MAX_WIDTH
operator|-
name|xlen
expr_stmt|;
if|if
condition|(
name|px
operator|>=
name|strlen
argument_list|(
name|daemon_pic
index|[
name|y
index|]
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|x
operator|=
name|xoff
init|;
operator|(
name|x
operator|<
name|xlen
operator|)
operator|&&
operator|(
name|daemon_pic
index|[
name|y
index|]
index|[
name|px
index|]
operator|!=
literal|'\0'
operator|)
condition|;
name|x
operator|++
operator|,
name|px
operator|++
control|)
block|{
switch|switch
condition|(
name|daemon_attr
index|[
name|y
index|]
index|[
name|px
index|]
condition|)
block|{
case|case
literal|'R'
case|:
name|attr
operator|=
name|FG_LIGHTRED
operator||
name|BG_BLACK
expr_stmt|;
break|break;
case|case
literal|'Y'
case|:
name|attr
operator|=
name|FG_YELLOW
operator||
name|BG_BLACK
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|attr
operator|=
name|FG_LIGHTBLUE
operator||
name|BG_BLACK
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
name|attr
operator|=
name|FG_LIGHTGREY
operator||
name|BG_BLACK
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|attr
operator|=
name|FG_CYAN
operator||
name|BG_BLACK
expr_stmt|;
break|break;
default|default:
name|attr
operator|=
name|FG_WHITE
operator||
name|BG_BLACK
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dxdir
operator|<
literal|0
condition|)
block|{
comment|/* Moving left */
name|sc_vtb_putc
argument_list|(
operator|&
name|sc
operator|->
name|cur_scp
operator|->
name|scr
argument_list|,
operator|(
name|ypos
operator|+
name|y
operator|)
operator|*
name|sc
operator|->
name|cur_scp
operator|->
name|xsize
operator|+
name|xpos
operator|+
name|x
argument_list|,
name|sc
operator|->
name|scr_map
index|[
name|daemon_pic
index|[
name|y
index|]
index|[
name|px
index|]
index|]
argument_list|,
name|ATTR
argument_list|(
name|attr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Moving right */
name|sc_vtb_putc
argument_list|(
operator|&
name|sc
operator|->
name|cur_scp
operator|->
name|scr
argument_list|,
operator|(
name|ypos
operator|+
name|y
operator|)
operator|*
name|sc
operator|->
name|cur_scp
operator|->
name|xsize
operator|+
name|xpos
operator|+
name|DAEMON_MAX_WIDTH
operator|-
name|px
operator|-
literal|1
argument_list|,
name|sc
operator|->
name|scr_map
index|[
name|xflip_symbol
argument_list|(
name|daemon_pic
index|[
name|y
index|]
index|[
name|px
index|]
argument_list|)
index|]
argument_list|,
name|ATTR
argument_list|(
name|attr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|clear_string
parameter_list|(
name|sc_softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|xpos
parameter_list|,
name|int
name|ypos
parameter_list|,
name|int
name|xoff
parameter_list|,
name|char
modifier|*
name|s
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
return|return;
name|sc_vtb_erase
argument_list|(
operator|&
name|sc
operator|->
name|cur_scp
operator|->
name|scr
argument_list|,
name|ypos
operator|*
name|sc
operator|->
name|cur_scp
operator|->
name|xsize
operator|+
name|xpos
operator|+
name|xoff
argument_list|,
name|len
operator|-
name|xoff
argument_list|,
name|sc
operator|->
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|ATTR
argument_list|(
name|FG_LIGHTGREY
operator||
name|BG_BLACK
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|draw_string
parameter_list|(
name|sc_softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|xpos
parameter_list|,
name|int
name|ypos
parameter_list|,
name|int
name|xoff
parameter_list|,
name|u_char
modifier|*
name|s
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
name|xoff
init|;
name|x
operator|<
name|len
condition|;
name|x
operator|++
control|)
name|sc_vtb_putc
argument_list|(
operator|&
name|sc
operator|->
name|cur_scp
operator|->
name|scr
argument_list|,
name|ypos
operator|*
name|sc
operator|->
name|cur_scp
operator|->
name|xsize
operator|+
name|xpos
operator|+
name|x
argument_list|,
name|sc
operator|->
name|scr_map
index|[
name|s
index|[
name|x
index|]
index|]
argument_list|,
name|ATTR
argument_list|(
name|FG_LIGHTGREEN
operator||
name|BG_BLACK
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|daemon_saver
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
name|blank
parameter_list|)
block|{
specifier|static
name|int
name|txpos
init|=
literal|10
decl_stmt|,
name|typos
init|=
literal|10
decl_stmt|;
specifier|static
name|int
name|txdir
init|=
operator|-
literal|1
decl_stmt|,
name|tydir
init|=
operator|-
literal|1
decl_stmt|;
specifier|static
name|int
name|dxpos
init|=
literal|0
decl_stmt|,
name|dypos
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|dxdir
init|=
literal|1
decl_stmt|,
name|dydir
init|=
literal|1
decl_stmt|;
specifier|static
name|int
name|moved_daemon
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|xoff
decl_stmt|,
name|yoff
decl_stmt|,
name|toff
decl_stmt|;
specifier|static
name|int
name|xlen
decl_stmt|,
name|ylen
decl_stmt|,
name|tlen
decl_stmt|;
name|sc_softc_t
modifier|*
name|sc
decl_stmt|;
name|scr_stat
modifier|*
name|scp
decl_stmt|;
name|int
name|min
decl_stmt|,
name|max
decl_stmt|;
name|sc
operator|=
name|sc_find_softc
argument_list|(
name|adp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
name|EAGAIN
return|;
name|scp
operator|=
name|sc
operator|->
name|cur_scp
expr_stmt|;
if|if
condition|(
name|blank
condition|)
block|{
if|if
condition|(
name|adp
operator|->
name|va_info
operator|.
name|vi_flags
operator|&
name|V_INFO_GRAPHICS
condition|)
return|return
name|EAGAIN
return|;
if|if
condition|(
name|blanked
operator|==
literal|0
condition|)
block|{
comment|/* clear the screen and set the border color */
name|sc_vtb_clear
argument_list|(
operator|&
name|scp
operator|->
name|scr
argument_list|,
name|sc
operator|->
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|ATTR
argument_list|(
name|FG_LIGHTGREY
operator||
name|BG_BLACK
argument_list|)
argument_list|)
expr_stmt|;
name|vidd_set_hw_cursor
argument_list|(
name|adp
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sc_set_border
argument_list|(
name|scp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xlen
operator|=
name|ylen
operator|=
name|tlen
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|blanked
operator|++
operator|<
literal|2
condition|)
return|return
literal|0
return|;
name|blanked
operator|=
literal|1
expr_stmt|;
name|clear_daemon
argument_list|(
name|sc
argument_list|,
name|dxpos
argument_list|,
name|dypos
argument_list|,
name|dxdir
argument_list|,
name|xoff
argument_list|,
name|yoff
argument_list|,
name|xlen
argument_list|,
name|ylen
argument_list|)
expr_stmt|;
name|clear_string
argument_list|(
name|sc
argument_list|,
name|txpos
argument_list|,
name|typos
argument_list|,
name|toff
argument_list|,
name|message
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|moved_daemon
condition|)
block|{
comment|/* 			 * The daemon picture may be off the screen, if 			 * screen size is chagened while the screen 			 * saver is inactive. Make sure the origin of 			 * the picture is between min and max. 			 */
if|if
condition|(
name|scp
operator|->
name|xsize
operator|<=
name|DAEMON_MAX_WIDTH
condition|)
block|{
comment|/* 				 * If the screen width is too narrow, we 				 * allow part of the picture go off 				 * the screen so that the daemon won't 				 * flip too often. 				 */
name|min
operator|=
name|scp
operator|->
name|xsize
operator|-
name|DAEMON_MAX_WIDTH
operator|-
literal|10
expr_stmt|;
name|max
operator|=
literal|10
expr_stmt|;
block|}
else|else
block|{
name|min
operator|=
literal|0
expr_stmt|;
name|max
operator|=
name|scp
operator|->
name|xsize
operator|-
name|DAEMON_MAX_WIDTH
expr_stmt|;
block|}
if|if
condition|(
name|dxpos
operator|<=
name|min
condition|)
block|{
name|dxpos
operator|=
name|min
expr_stmt|;
name|dxdir
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dxpos
operator|>=
name|max
condition|)
block|{
name|dxpos
operator|=
name|max
expr_stmt|;
name|dxdir
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|scp
operator|->
name|ysize
operator|<=
name|DAEMON_MAX_HEIGHT
condition|)
block|{
name|min
operator|=
name|scp
operator|->
name|ysize
operator|-
name|DAEMON_MAX_HEIGHT
operator|-
literal|10
expr_stmt|;
name|max
operator|=
literal|10
expr_stmt|;
block|}
else|else
block|{
name|min
operator|=
literal|0
expr_stmt|;
name|max
operator|=
name|scp
operator|->
name|ysize
operator|-
name|DAEMON_MAX_HEIGHT
expr_stmt|;
block|}
if|if
condition|(
name|dypos
operator|<=
name|min
condition|)
block|{
name|dypos
operator|=
name|min
expr_stmt|;
name|dydir
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dypos
operator|>=
name|max
condition|)
block|{
name|dypos
operator|=
name|max
expr_stmt|;
name|dydir
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|moved_daemon
operator|=
operator|-
literal|1
expr_stmt|;
name|dxpos
operator|+=
name|dxdir
expr_stmt|;
name|dypos
operator|+=
name|dydir
expr_stmt|;
comment|/* clip the picture */
name|xoff
operator|=
literal|0
expr_stmt|;
name|xlen
operator|=
name|DAEMON_MAX_WIDTH
expr_stmt|;
if|if
condition|(
name|dxpos
operator|+
name|xlen
operator|<=
literal|0
condition|)
name|xlen
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|dxpos
operator|<
literal|0
condition|)
name|xoff
operator|=
operator|-
name|dxpos
expr_stmt|;
if|if
condition|(
name|dxpos
operator|>=
name|scp
operator|->
name|xsize
condition|)
name|xlen
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|dxpos
operator|+
name|xlen
operator|>
name|scp
operator|->
name|xsize
condition|)
name|xlen
operator|=
name|scp
operator|->
name|xsize
operator|-
name|dxpos
expr_stmt|;
name|yoff
operator|=
literal|0
expr_stmt|;
name|ylen
operator|=
name|DAEMON_MAX_HEIGHT
expr_stmt|;
if|if
condition|(
name|dypos
operator|+
name|ylen
operator|<=
literal|0
condition|)
name|ylen
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|dypos
operator|<
literal|0
condition|)
name|yoff
operator|=
operator|-
name|dypos
expr_stmt|;
if|if
condition|(
name|dypos
operator|>=
name|scp
operator|->
name|ysize
condition|)
name|ylen
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|dypos
operator|+
name|ylen
operator|>
name|scp
operator|->
name|ysize
condition|)
name|ylen
operator|=
name|scp
operator|->
name|ysize
operator|-
name|dypos
expr_stmt|;
block|}
if|if
condition|(
name|scp
operator|->
name|xsize
operator|<=
name|messagelen
condition|)
block|{
name|min
operator|=
name|scp
operator|->
name|xsize
operator|-
name|messagelen
operator|-
literal|10
expr_stmt|;
name|max
operator|=
literal|10
expr_stmt|;
block|}
else|else
block|{
name|min
operator|=
literal|0
expr_stmt|;
name|max
operator|=
name|scp
operator|->
name|xsize
operator|-
name|messagelen
expr_stmt|;
block|}
if|if
condition|(
name|txpos
operator|<=
name|min
condition|)
block|{
name|txpos
operator|=
name|min
expr_stmt|;
name|txdir
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|txpos
operator|>=
name|max
condition|)
block|{
name|txpos
operator|=
name|max
expr_stmt|;
name|txdir
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|typos
operator|<=
literal|0
condition|)
block|{
name|typos
operator|=
literal|0
expr_stmt|;
name|tydir
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|typos
operator|>=
name|scp
operator|->
name|ysize
operator|-
literal|1
condition|)
block|{
name|typos
operator|=
name|scp
operator|->
name|ysize
operator|-
literal|1
expr_stmt|;
name|tydir
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|txpos
operator|+=
name|txdir
expr_stmt|;
name|typos
operator|+=
name|tydir
expr_stmt|;
name|toff
operator|=
literal|0
expr_stmt|;
name|tlen
operator|=
name|messagelen
expr_stmt|;
if|if
condition|(
name|txpos
operator|+
name|tlen
operator|<=
literal|0
condition|)
name|tlen
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|txpos
operator|<
literal|0
condition|)
name|toff
operator|=
operator|-
name|txpos
expr_stmt|;
if|if
condition|(
name|txpos
operator|>=
name|scp
operator|->
name|xsize
condition|)
name|tlen
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|txpos
operator|+
name|tlen
operator|>
name|scp
operator|->
name|xsize
condition|)
name|tlen
operator|=
name|scp
operator|->
name|xsize
operator|-
name|txpos
expr_stmt|;
name|draw_daemon
argument_list|(
name|sc
argument_list|,
name|dxpos
argument_list|,
name|dypos
argument_list|,
name|dxdir
argument_list|,
name|xoff
argument_list|,
name|yoff
argument_list|,
name|xlen
argument_list|,
name|ylen
argument_list|)
expr_stmt|;
name|draw_string
argument_list|(
name|sc
argument_list|,
name|txpos
argument_list|,
name|typos
argument_list|,
name|toff
argument_list|,
name|message
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
block|}
else|else
name|blanked
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|daemon_init
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|)
block|{
name|size_t
name|hostlen
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|prison0
operator|.
name|pr_mtx
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|hostlen
operator|=
name|strlen
argument_list|(
name|prison0
operator|.
name|pr_hostname
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|prison0
operator|.
name|pr_mtx
argument_list|)
expr_stmt|;
name|messagelen
operator|=
name|hostlen
operator|+
literal|3
operator|+
name|strlen
argument_list|(
name|ostype
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|osrelease
argument_list|)
expr_stmt|;
name|message
operator|=
name|malloc
argument_list|(
name|messagelen
operator|+
literal|1
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|prison0
operator|.
name|pr_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostlen
operator|<
name|strlen
argument_list|(
name|prison0
operator|.
name|pr_hostname
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|message
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"%s - %s %s"
argument_list|,
name|prison0
operator|.
name|pr_hostname
argument_list|,
name|ostype
argument_list|,
name|osrelease
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|prison0
operator|.
name|pr_mtx
argument_list|)
expr_stmt|;
name|blanked
operator|=
literal|0
expr_stmt|;
name|attr_mask
operator|=
operator|~
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|daemon_term
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|)
block|{
name|free
argument_list|(
name|message
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|scrn_saver_t
name|daemon_module
init|=
block|{
literal|"daemon_saver"
block|,
name|daemon_init
block|,
name|daemon_term
block|,
name|daemon_saver
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SAVER_MODULE
argument_list|(
name|daemon_saver
argument_list|,
name|daemon_module
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

