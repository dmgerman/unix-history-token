begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992-1998 SÃ¸ren Schmidt  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification, immediately at the beginning of the file.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  *	$Id: syscons.c,v 1.280 1998/09/26 03:34:08 yokota Exp $  */
end_comment

begin_include
include|#
directive|include
file|"sc.h"
end_include

begin_include
include|#
directive|include
file|"apm.h"
end_include

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|"opt_devfs.h"
end_include

begin_include
include|#
directive|include
file|"opt_vesa.h"
end_include

begin_include
include|#
directive|include
file|"opt_vm86.h"
end_include

begin_include
include|#
directive|include
file|"opt_syscons.h"
end_include

begin_if
if|#
directive|if
name|NSC
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEVFS
end_ifdef

begin_include
include|#
directive|include
file|<sys/devfsext.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/bootinfo.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/cons.h>
end_include

begin_include
include|#
directive|include
file|<machine/console.h>
end_include

begin_include
include|#
directive|include
file|<machine/mouse.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/psl.h>
end_include

begin_include
include|#
directive|include
file|<machine/frame.h>
end_include

begin_include
include|#
directive|include
file|<machine/pc/display.h>
end_include

begin_include
include|#
directive|include
file|<machine/pc/vesa.h>
end_include

begin_include
include|#
directive|include
file|<machine/apm_bios.h>
end_include

begin_include
include|#
directive|include
file|<machine/random.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/timerreg.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/kbdtables.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/kbdio.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/videoio.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/syscons.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAXCONS
argument_list|)
end_if

begin_define
define|#
directive|define
name|MAXCONS
value|16
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SC_MAX_HISTORY_SIZE
argument_list|)
end_if

begin_define
define|#
directive|define
name|SC_MAX_HISTORY_SIZE
value|(1000 * MAXCONS)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SC_HISTORY_SIZE
argument_list|)
end_if

begin_define
define|#
directive|define
name|SC_HISTORY_SIZE
value|(ROW * 4)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|SC_HISTORY_SIZE
operator|*
name|MAXCONS
operator|)
operator|>
name|SC_MAX_HISTORY_SIZE
end_if

begin_undef
undef|#
directive|undef
name|SC_MAX_HISTORY_SIZE
end_undef

begin_define
define|#
directive|define
name|SC_MAX_HISTORY_SIZE
value|(SC_HISTORY_SIZE * MAXCONS)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SC_MOUSE_CHAR
argument_list|)
end_if

begin_define
define|#
directive|define
name|SC_MOUSE_CHAR
value|(0xd0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|COLD
value|0
end_define

begin_define
define|#
directive|define
name|WARM
value|1
end_define

begin_define
define|#
directive|define
name|DEFAULT_BLANKTIME
value|(5*60)
end_define

begin_comment
comment|/* 5 minutes */
end_comment

begin_define
define|#
directive|define
name|MAX_BLANKTIME
value|(7*24*60*60)
end_define

begin_comment
comment|/* 7 days!? */
end_comment

begin_comment
comment|/* for backward compatibility */
end_comment

begin_define
define|#
directive|define
name|OLD_CONS_MOUSECTL
value|_IOWR('c', 10, old_mouse_info_t)
end_define

begin_typedef
typedef|typedef
struct|struct
name|old_mouse_data
block|{
name|int
name|x
decl_stmt|;
name|int
name|y
decl_stmt|;
name|int
name|buttons
decl_stmt|;
block|}
name|old_mouse_data_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|old_mouse_info
block|{
name|int
name|operation
decl_stmt|;
union|union
block|{
name|struct
name|old_mouse_data
name|data
decl_stmt|;
name|struct
name|mouse_mode
name|mode
decl_stmt|;
block|}
name|u
union|;
block|}
name|old_mouse_info_t
typedef|;
end_typedef

begin_comment
comment|/* XXX use sc_bcopy where video memory is concerned */
end_comment

begin_function_decl
specifier|extern
name|void
name|generic_bcopy
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|generic_bzero
parameter_list|(
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|default_attr
name|user_default
init|=
block|{
operator|(
name|FG_LIGHTGREY
operator||
name|BG_BLACK
operator|)
operator|<<
literal|8
block|,
operator|(
name|FG_BLACK
operator||
name|BG_LIGHTGREY
operator|)
operator|<<
literal|8
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|default_attr
name|kernel_default
init|=
block|{
operator|(
name|FG_WHITE
operator||
name|BG_BLACK
operator|)
operator|<<
literal|8
block|,
operator|(
name|FG_BLACK
operator||
name|BG_LIGHTGREY
operator|)
operator|<<
literal|8
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|scr_stat
name|main_console
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|scr_stat
modifier|*
name|console
index|[
name|MAXCONS
index|]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEVFS
end_ifdef

begin_decl_stmt
specifier|static
name|void
modifier|*
name|sc_devfs_token
index|[
name|MAXCONS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|sc_mouse_devfs_token
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|sc_console_devfs_token
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|scr_stat
modifier|*
name|cur_console
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|scr_stat
modifier|*
name|new_scp
decl_stmt|,
modifier|*
name|old_scp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|term_stat
name|kernel_console
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|default_attr
modifier|*
name|current_default
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|flags
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sc_port
init|=
name|IO_KBD
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|KBDC
name|sc_kbdc
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|init_done
init|=
name|COLD
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_short
name|sc_buffer
index|[
name|ROW
operator|*
name|COL
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|shutdown_in_progress
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|font_loading_in_progress
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|switch_in_progress
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|write_in_progress
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|blink_in_progress
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|blinkrate
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|crtc_addr
init|=
name|MONO_BASE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|crtc_type
init|=
name|KD_MONO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|crtc_vga
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|adp_flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|shfts
init|=
literal|0
decl_stmt|,
name|ctls
init|=
literal|0
decl_stmt|,
name|alts
init|=
literal|0
decl_stmt|,
name|agrs
init|=
literal|0
decl_stmt|,
name|metas
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|accents
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|nlkcnt
init|=
literal|0
decl_stmt|,
name|clkcnt
init|=
literal|0
decl_stmt|,
name|slkcnt
init|=
literal|0
decl_stmt|,
name|alkcnt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|u_int
name|n_fkey_tab
init|=
sizeof|sizeof
argument_list|(
name|fkey_tab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|fkey_tab
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|delayed_next_scr
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|scrn_blank_time
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* screen saver timeout value */
end_comment

begin_decl_stmt
name|int
name|scrn_blanked
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* screen saver active flag */
end_comment

begin_decl_stmt
specifier|static
name|long
name|scrn_time_stamp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|saver_mode
init|=
name|CONS_LKM_SAVER
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* LKM/user saver */
end_comment

begin_decl_stmt
specifier|static
name|int
name|run_scrn_saver
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* should run the saver? */
end_comment

begin_decl_stmt
specifier|static
name|int
name|scrn_idle
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* about to run the saver */
end_comment

begin_decl_stmt
name|u_char
name|scr_map
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|scr_rmap
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|initial_video_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* initial video mode # */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bios_video_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* video mode # set by BIOS */
end_comment

begin_decl_stmt
name|int
name|fonts_loaded
init|=
literal|0
ifdef|#
directive|ifdef
name|STD8X16FONT
operator||
name|FONT_16
endif|#
directive|endif
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|font_8
index|[
literal|256
operator|*
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|font_14
index|[
literal|256
operator|*
literal|14
index|]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|STD8X16FONT
end_ifdef

begin_decl_stmt
specifier|extern
endif|#
directive|endif
name|u_char
name|font_16
index|[
literal|256
operator|*
literal|16
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|palette
index|[
literal|256
operator|*
literal|3
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
modifier|*
name|cut_buffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cut_buffer_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mouse_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sysmouse protocol level */
end_comment

begin_decl_stmt
specifier|static
name|mousestatus_t
name|mouse_status
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_short
name|mouse_and_mask
index|[
literal|16
index|]
init|=
block|{
literal|0xc000
block|,
literal|0xe000
block|,
literal|0xf000
block|,
literal|0xf800
block|,
literal|0xfc00
block|,
literal|0xfe00
block|,
literal|0xff00
block|,
literal|0xff80
block|,
literal|0xfe00
block|,
literal|0x1e00
block|,
literal|0x1f00
block|,
literal|0x0f00
block|,
literal|0x0f00
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_short
name|mouse_or_mask
index|[
literal|16
index|]
init|=
block|{
literal|0x0000
block|,
literal|0x4000
block|,
literal|0x6000
block|,
literal|0x7000
block|,
literal|0x7800
block|,
literal|0x7c00
block|,
literal|0x7e00
block|,
literal|0x6800
block|,
literal|0x0c00
block|,
literal|0x0c00
block|,
literal|0x0600
block|,
literal|0x0600
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sc_history_size
init|=
name|SC_HISTORY_SIZE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|extra_history_size
init|=
name|SC_MAX_HISTORY_SIZE
operator|-
name|SC_HISTORY_SIZE
operator|*
name|MAXCONS
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|none_saver
parameter_list|(
name|int
name|blank
parameter_list|)
block|{ }
end_function

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|current_saver
function_decl|)
parameter_list|(
name|int
name|blank
parameter_list|)
init|=
name|none_saver
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|default_saver
function_decl|)
parameter_list|(
name|int
name|blank
parameter_list|)
init|=
name|none_saver
function_decl|;
end_function_decl

begin_decl_stmt
name|d_ioctl_t
modifier|*
name|sc_user_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sticky_splash
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* OS specific stuff */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|not_yet_done
end_ifdef

begin_define
define|#
directive|define
name|VIRTUAL_TTY
parameter_list|(
name|x
parameter_list|)
value|(sccons[x] = ttymalloc(sccons[x]))
end_define

begin_decl_stmt
name|struct
name|CONSOLE_TTY
argument_list|(
name|sccons
index|[
name|MAXCONS
index|]
operator|=
name|ttymalloc
argument_list|(
name|sccons
index|[
name|MAXCONS
index|]
argument_list|)
argument_list|)
decl|struct
name|MOUSE_TTY
argument_list|(
name|sccons
index|[
name|MAXCONS
operator|+
literal|1
index|]
operator|=
name|ttymalloc
argument_list|(
name|sccons
index|[
name|MAXCONS
operator|+
literal|1
index|]
argument_list|)
argument_list|)
decl|struct
name|tty
modifier|*
name|sccons
index|[
name|MAXCONS
operator|+
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|VIRTUAL_TTY
parameter_list|(
name|x
parameter_list|)
value|&sccons[x]
end_define

begin_define
define|#
directive|define
name|CONSOLE_TTY
value|&sccons[MAXCONS]
end_define

begin_define
define|#
directive|define
name|MOUSE_TTY
value|&sccons[MAXCONS+1]
end_define

begin_decl_stmt
specifier|static
name|struct
name|tty
name|sccons
index|[
name|MAXCONS
operator|+
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SC_MOUSE
value|128
end_define

begin_define
define|#
directive|define
name|SC_CONSOLE
value|255
end_define

begin_decl_stmt
name|u_short
modifier|*
name|Crtat
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|nsccons
init|=
name|MAXCONS
operator|+
literal|2
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|WRAPHIST
parameter_list|(
name|scp
parameter_list|,
name|pointer
parameter_list|,
name|offset
parameter_list|)
define|\
value|((scp)->history + ((((pointer) - (scp)->history) + (scp)->history_size \     + (offset)) % (scp)->history_size))
end_define

begin_define
define|#
directive|define
name|ISSIGVALID
parameter_list|(
name|sig
parameter_list|)
value|((sig)> 0&& (sig)< NSIG)
end_define

begin_comment
comment|/* prototypes */
end_comment

begin_function_decl
specifier|static
name|int
name|scattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|scparam
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|termios
modifier|*
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|scprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|scvidprobe
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sckbdprobe
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|scstart
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|scmousestart
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|scinit
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|scshutdown
parameter_list|(
name|int
name|howto
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|scgetc
parameter_list|(
name|u_int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|SCGETC_CN
value|1
end_define

begin_define
define|#
directive|define
name|SCGETC_NONBLOCK
value|2
end_define

begin_function_decl
specifier|static
name|void
name|sccnupdate
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|scr_stat
modifier|*
name|alloc_scp
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_scp
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sc_bcopy
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|u_short
modifier|*
name|p
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|,
name|int
name|mark
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_scr_num
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|timeout_t
name|scrn_timer
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|scrn_update
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|show_cursor
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|scrn_saver
parameter_list|(
name|void
function_decl|(
modifier|*
name|saver
function_decl|)
parameter_list|(
name|int
parameter_list|)
parameter_list|,
name|int
name|blank
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stop_scrn_saver
parameter_list|(
name|void
function_decl|(
modifier|*
name|saver
function_decl|)
parameter_list|(
name|int
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wait_scrn_saver_stop
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|switch_scr
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|u_int
name|next_scr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|exchange_scr
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|scan_esc
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|u_char
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ansi_put
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|draw_cursor_image
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remove_cursor_image
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|move_crsr
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_char
modifier|*
name|get_fstr
parameter_list|(
name|u_int
name|c
parameter_list|,
name|u_int
modifier|*
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|history_to_screen
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|history_up_line
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|history_down_line
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mask2attr
parameter_list|(
name|struct
name|term_stat
modifier|*
name|term
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_keyboard
parameter_list|(
name|int
name|command
parameter_list|,
name|int
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|update_leds
parameter_list|(
name|int
name|which
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_destructive_cursor
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_mouse_pos
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|skip_spc_right
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|u_short
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|skip_spc_left
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|u_short
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mouse_cut
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mouse_cut_start
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mouse_cut_end
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mouse_cut_word
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mouse_cut_line
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mouse_cut_extend
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mouse_paste
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|draw_mouse_image
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remove_mouse_image
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|draw_cutmarking
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remove_cutmarking
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_bell
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|pitch
parameter_list|,
name|int
name|duration
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|timeout_t
name|blink_screen
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SC_SPLASH_SCREEN
end_ifdef

begin_function_decl
specifier|static
name|void
name|scsplash_init
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|scsplash_term
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|scsplash_saver
parameter_list|(
name|int
name|show
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|scsplash_stick
parameter_list|(
name|stick
parameter_list|)
value|(sticky_splash = (stick))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|scsplash_stick
parameter_list|(
name|stick
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|isa_driver
name|scdriver
init|=
block|{
name|scprobe
block|,
name|scattach
block|,
literal|"sc"
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|scopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|scclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|scread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|scwrite
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|scioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_mmap_t
name|scmmap
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|12
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|sc_cdevsw
init|=
block|{
name|scopen
block|,
name|scclose
block|,
name|scread
block|,
name|scwrite
block|,
name|scioctl
block|,
name|nullstop
block|,
name|noreset
block|,
name|scdevtotty
block|,
name|ttpoll
block|,
name|scmmap
block|,
name|nostrategy
block|,
literal|"sc"
block|,
name|NULL
block|,
operator|-
literal|1
block|,
name|nodump
block|,
name|nopsize
block|,
name|D_TTY
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|draw_cursor_image
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|u_short
name|cursor_image
decl_stmt|;
name|u_short
modifier|*
name|ptr
decl_stmt|;
name|u_short
name|prev_image
decl_stmt|;
if|if
condition|(
name|ISPIXELSC
argument_list|(
name|scp
argument_list|)
condition|)
block|{
name|sc_bcopy
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|ptr
operator|=
operator|(
name|u_short
operator|*
operator|)
operator|(
name|get_adapter
argument_list|(
name|scp
argument_list|)
operator|->
name|va_window
operator|)
operator|+
operator|(
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
operator|)
expr_stmt|;
comment|/* do we have a destructive cursor ? */
if|if
condition|(
name|flags
operator|&
name|CHAR_CURSOR
condition|)
block|{
name|prev_image
operator|=
name|scp
operator|->
name|cursor_saveunder
expr_stmt|;
name|cursor_image
operator|=
operator|*
name|ptr
operator|&
literal|0x00ff
expr_stmt|;
if|if
condition|(
name|cursor_image
operator|==
name|DEAD_CHAR
condition|)
name|cursor_image
operator|=
name|prev_image
operator|&
literal|0x00ff
expr_stmt|;
name|cursor_image
operator||=
operator|*
operator|(
name|scp
operator|->
name|cursor_pos
operator|)
operator|&
literal|0xff00
expr_stmt|;
name|scp
operator|->
name|cursor_saveunder
operator|=
name|cursor_image
expr_stmt|;
comment|/* update the cursor bitmap if the char under the cursor has changed */
if|if
condition|(
name|prev_image
operator|!=
name|cursor_image
condition|)
name|set_destructive_cursor
argument_list|(
name|scp
argument_list|)
expr_stmt|;
comment|/* modify cursor_image */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|BLINK_CURSOR
operator|)
operator|||
operator|(
operator|(
name|flags
operator|&
name|BLINK_CURSOR
operator|)
operator|&&
operator|(
name|blinkrate
operator|&
literal|4
operator|)
operator|)
condition|)
block|{
comment|/*  	     * When the mouse pointer is at the same position as the cursor, 	     * the cursor bitmap needs to be updated even if the char under  	     * the cursor hasn't changed, because the mouse pionter may  	     * have moved by a few dots within the cursor cel. 	     */
if|if
condition|(
operator|(
name|prev_image
operator|==
name|cursor_image
operator|)
operator|&&
operator|(
name|cursor_image
operator|!=
operator|*
operator|(
name|scp
operator|->
name|cursor_pos
operator|)
operator|)
condition|)
name|set_destructive_cursor
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|cursor_image
operator|&=
literal|0xff00
expr_stmt|;
name|cursor_image
operator||=
name|DEAD_CHAR
expr_stmt|;
block|}
block|}
else|else
block|{
name|cursor_image
operator|=
operator|(
operator|*
operator|(
name|ptr
operator|)
operator|&
literal|0x00ff
operator|)
operator||
operator|*
operator|(
name|scp
operator|->
name|cursor_pos
operator|)
operator|&
literal|0xff00
expr_stmt|;
name|scp
operator|->
name|cursor_saveunder
operator|=
name|cursor_image
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|BLINK_CURSOR
operator|)
operator|||
operator|(
operator|(
name|flags
operator|&
name|BLINK_CURSOR
operator|)
operator|&&
operator|(
name|blinkrate
operator|&
literal|4
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|cursor_image
operator|&
literal|0x7000
operator|)
operator|==
literal|0x7000
condition|)
block|{
name|cursor_image
operator|&=
literal|0x8fff
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cursor_image
operator|&
literal|0x0700
operator|)
condition|)
name|cursor_image
operator||=
literal|0x0700
expr_stmt|;
block|}
else|else
block|{
name|cursor_image
operator||=
literal|0x7000
expr_stmt|;
if|if
condition|(
operator|(
name|cursor_image
operator|&
literal|0x0700
operator|)
operator|==
literal|0x0700
condition|)
name|cursor_image
operator|&=
literal|0xf0ff
expr_stmt|;
block|}
block|}
block|}
operator|*
name|ptr
operator|=
name|cursor_image
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|remove_cursor_image
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
if|if
condition|(
name|ISPIXELSC
argument_list|(
name|scp
argument_list|)
condition|)
name|sc_bcopy
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|cursor_oldpos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|cursor_oldpos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
operator|*
operator|(
operator|(
name|u_short
operator|*
operator|)
operator|(
name|get_adapter
argument_list|(
name|scp
argument_list|)
operator|->
name|va_window
operator|)
operator|+
operator|(
name|scp
operator|->
name|cursor_oldpos
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|)
operator|=
name|scp
operator|->
name|cursor_saveunder
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|move_crsr
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
if|if
condition|(
name|x
operator|<
literal|0
condition|)
name|x
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|y
operator|<
literal|0
condition|)
name|y
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|x
operator|>=
name|scp
operator|->
name|xsize
condition|)
name|x
operator|=
name|scp
operator|->
name|xsize
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|y
operator|>=
name|scp
operator|->
name|ysize
condition|)
name|y
operator|=
name|scp
operator|->
name|ysize
operator|-
literal|1
expr_stmt|;
name|scp
operator|->
name|xpos
operator|=
name|x
expr_stmt|;
name|scp
operator|->
name|ypos
operator|=
name|y
expr_stmt|;
name|scp
operator|->
name|cursor_pos
operator|=
name|scp
operator|->
name|scr_buf
operator|+
name|scp
operator|->
name|ypos
operator|*
name|scp
operator|->
name|xsize
operator|+
name|scp
operator|->
name|xpos
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|scprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
if|if
condition|(
operator|!
name|scvidprobe
argument_list|(
name|dev
operator|->
name|id_unit
argument_list|,
name|dev
operator|->
name|id_flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"sc%d: no video adapter is found.\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|VESA
argument_list|)
operator|&&
name|defined
argument_list|(
name|VM86
argument_list|)
if|if
condition|(
name|vesa_load
argument_list|()
condition|)
return|return
name|FALSE
return|;
endif|#
directive|endif
call|(
modifier|*
name|biosvidsw
operator|.
name|diag
call|)
argument_list|(
name|bootverbose
argument_list|)
expr_stmt|;
name|sc_port
operator|=
name|dev
operator|->
name|id_iobase
expr_stmt|;
if|if
condition|(
name|sckbdprobe
argument_list|(
name|dev
operator|->
name|id_unit
argument_list|,
name|dev
operator|->
name|id_flags
argument_list|)
condition|)
return|return
operator|(
name|IO_KBDSIZE
operator|)
return|;
else|else
return|return
operator|(
operator|(
name|dev
operator|->
name|id_flags
operator|&
name|DETECT_KBD
operator|)
condition|?
literal|0
else|:
name|IO_KBDSIZE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* probe video adapters, return TRUE if found */
end_comment

begin_function
specifier|static
name|int
name|scvidprobe
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|video_adapter_t
modifier|*
name|adp
decl_stmt|;
comment|/* do this test only once */
if|if
condition|(
name|init_done
operator|!=
name|COLD
condition|)
return|return
operator|(
name|crtc_type
operator|!=
operator|-
literal|1
operator|)
return|;
if|if
condition|(
call|(
modifier|*
name|biosvidsw
operator|.
name|init
call|)
argument_list|()
operator|<=
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|(
name|adp
operator|=
call|(
modifier|*
name|biosvidsw
operator|.
name|adapter
call|)
argument_list|(
name|V_ADP_PRIMARY
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|crtc_type
operator|=
name|adp
operator|->
name|va_type
expr_stmt|;
name|crtc_vga
operator|=
operator|(
name|crtc_type
operator|==
name|KD_VGA
operator|)
expr_stmt|;
name|crtc_addr
operator|=
name|adp
operator|->
name|va_crtc_addr
expr_stmt|;
name|Crtat
operator|=
operator|(
name|u_short
operator|*
operator|)
name|adp
operator|->
name|va_window
expr_stmt|;
name|adp_flags
operator|=
name|adp
operator|->
name|va_flags
expr_stmt|;
name|initial_video_mode
operator|=
name|adp
operator|->
name|va_initial_mode
expr_stmt|;
name|bios_video_mode
operator|=
name|adp
operator|->
name|va_initial_bios_mode
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* probe the keyboard, return TRUE if found */
end_comment

begin_function
specifier|static
name|int
name|sckbdprobe
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|codeset
decl_stmt|;
name|int
name|c
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|m
decl_stmt|;
name|int
name|res
decl_stmt|,
name|id
decl_stmt|;
name|sc_kbdc
operator|=
name|kbdc_open
argument_list|(
name|sc_port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|kbdc_lock
argument_list|(
name|sc_kbdc
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
comment|/* driver error? */
name|printf
argument_list|(
literal|"sc%d: unable to lock the controller.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|flags
operator|&
name|DETECT_KBD
operator|)
condition|?
name|FALSE
else|:
name|TRUE
operator|)
return|;
block|}
comment|/* flush any noise in the buffer */
name|empty_both_buffers
argument_list|(
name|sc_kbdc
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* save the current keyboard controller command byte */
name|m
operator|=
name|kbdc_get_device_mask
argument_list|(
name|sc_kbdc
argument_list|)
operator|&
operator|~
name|KBD_KBD_CONTROL_BITS
expr_stmt|;
name|c
operator|=
name|get_controller_command_byte
argument_list|(
name|sc_kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* CONTROLLER ERROR */
name|printf
argument_list|(
literal|"sc%d: unable to get the current command byte value.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"sc%d: the current keyboard controller command byte %04x\n"
argument_list|,
name|unit
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* override the keyboard lock switch */
block|c |= KBD_OVERRIDE_KBD_LOCK;
endif|#
directive|endif
comment|/*       * The keyboard may have been screwed up by the boot block.      * We may just be able to recover from error by testing the controller      * and the keyboard port. The controller command byte needs to be saved      * before this recovery operation, as some controllers seem to set       * the command byte to particular values.      */
name|test_controller
argument_list|(
name|sc_kbdc
argument_list|)
expr_stmt|;
name|test_kbd_port
argument_list|(
name|sc_kbdc
argument_list|)
expr_stmt|;
comment|/* enable the keyboard port, but disable the keyboard intr. */
if|if
condition|(
operator|!
name|set_controller_command_byte
argument_list|(
name|sc_kbdc
argument_list|,
name|KBD_KBD_CONTROL_BITS
argument_list|,
name|KBD_ENABLE_KBD_PORT
operator||
name|KBD_DISABLE_KBD_INT
argument_list|)
condition|)
block|{
comment|/* CONTROLLER ERROR  	 * there is very little we can do... 	 */
name|printf
argument_list|(
literal|"sc%d: unable to set the command byte.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/*        * Check if we have an XT keyboard before we attempt to reset it.        * The procedure assumes that the keyboard and the controller have        * been set up properly by BIOS and have not been messed up        * during the boot process.       */
name|codeset
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|XT_KEYBD
condition|)
comment|/* the user says there is a XT keyboard */
name|codeset
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DETECT_XT_KEYBOARD
elseif|else
if|if
condition|(
operator|(
name|c
operator|&
name|KBD_TRANSLATION
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* SET_SCANCODE_SET is not always supported; ignore error */
if|if
condition|(
name|send_kbd_command_and_data
argument_list|(
name|sc_kbdc
argument_list|,
name|KBDC_SET_SCANCODE_SET
argument_list|,
literal|0
argument_list|)
operator|==
name|KBD_ACK
condition|)
name|codeset
operator|=
name|read_kbd_data
argument_list|(
name|sc_kbdc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"sc%d: keyboard scancode set %d\n"
argument_list|,
name|unit
argument_list|,
name|codeset
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DETECT_XT_KEYBOARD */
if|if
condition|(
name|flags
operator|&
name|KBD_NORESET
condition|)
block|{
name|write_kbd_command
argument_list|(
name|sc_kbdc
argument_list|,
name|KBDC_ECHO
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_kbd_data
argument_list|(
name|sc_kbdc
argument_list|)
operator|!=
name|KBD_ECHO
condition|)
block|{
name|empty_both_buffers
argument_list|(
name|sc_kbdc
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|test_controller
argument_list|(
name|sc_kbdc
argument_list|)
expr_stmt|;
name|test_kbd_port
argument_list|(
name|sc_kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"sc%d: failed to get response from the keyboard.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
else|else
block|{
comment|/* reset keyboard hardware */
if|if
condition|(
operator|!
name|reset_kbd
argument_list|(
name|sc_kbdc
argument_list|)
condition|)
block|{
comment|/* KEYBOARD ERROR              * Keyboard reset may fail either because the keyboard doen't              * exist, or because the keyboard doesn't pass the self-test,              * or the keyboard controller on the motherboard and the keyboard              * somehow fail to shake hands. It is just possible, particularly              * in the last case, that the keyoard controller may be left               * in a hung state. test_controller() and test_kbd_port() appear              * to bring the keyboard controller back (I don't know why and              * how, though.)              */
name|empty_both_buffers
argument_list|(
name|sc_kbdc
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|test_controller
argument_list|(
name|sc_kbdc
argument_list|)
expr_stmt|;
name|test_kbd_port
argument_list|(
name|sc_kbdc
argument_list|)
expr_stmt|;
comment|/* We could disable the keyboard port and interrupt... but,               * the keyboard may still exist (see above).               */
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"sc%d: failed to reset the keyboard.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
comment|/*      * Allow us to set the XT_KEYBD flag in UserConfig so that keyboards      * such as those on the IBM ThinkPad laptop computers can be used      * with the standard console driver.      */
if|if
condition|(
name|codeset
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|send_kbd_command_and_data
argument_list|(
name|sc_kbdc
argument_list|,
name|KBDC_SET_SCANCODE_SET
argument_list|,
name|codeset
argument_list|)
operator|==
name|KBD_ACK
condition|)
block|{
comment|/* XT kbd doesn't need scan code translation */
name|c
operator|&=
operator|~
name|KBD_TRANSLATION
expr_stmt|;
block|}
else|else
block|{
comment|/* KEYBOARD ERROR  	     * The XT kbd isn't usable unless the proper scan code set 	     * is selected.  	     */
name|printf
argument_list|(
literal|"sc%d: unable to set the XT keyboard mode.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
comment|/* enable the keyboard port and intr. */
if|if
condition|(
operator|!
name|set_controller_command_byte
argument_list|(
name|sc_kbdc
argument_list|,
name|KBD_KBD_CONTROL_BITS
operator||
name|KBD_TRANSLATION
operator||
name|KBD_OVERRIDE_KBD_LOCK
argument_list|,
operator|(
name|c
operator|&
operator|(
name|KBD_TRANSLATION
operator||
name|KBD_OVERRIDE_KBD_LOCK
operator|)
operator|)
operator||
name|KBD_ENABLE_KBD_PORT
operator||
name|KBD_ENABLE_KBD_INT
argument_list|)
condition|)
block|{
comment|/* CONTROLLER ERROR  	 * This is serious; we are left with the disabled keyboard intr.  	 */
name|printf
argument_list|(
literal|"sc%d: unable to enable the keyboard port and intr.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Get the ID of the keyboard, if any */
name|empty_kbd_buffer
argument_list|(
name|sc_kbdc
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|res
operator|=
name|send_kbd_command
argument_list|(
name|sc_kbdc
argument_list|,
name|KBDC_SEND_DEV_ID
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|KBD_ACK
condition|)
block|{
comment|/* 10ms delay */
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|id
operator|=
operator|(
name|read_kbd_data
argument_list|(
name|sc_kbdc
argument_list|)
operator|<<
literal|8
operator|)
operator||
name|read_kbd_data
argument_list|(
name|sc_kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"sc%d: keyboard device ID: %04x\n"
argument_list|,
name|unit
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
name|kbdc_set_device_mask
argument_list|(
name|sc_kbdc
argument_list|,
name|m
operator||
name|KBD_KBD_CONTROL_BITS
argument_list|)
operator|,
name|kbdc_lock
argument_list|(
name|sc_kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
name|fail
label|:
if|if
condition|(
name|c
operator|!=
operator|-
literal|1
condition|)
comment|/* try to restore the command byte as before, if possible */
name|set_controller_command_byte
argument_list|(
name|sc_kbdc
argument_list|,
literal|0xff
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|kbdc_set_device_mask
argument_list|(
name|sc_kbdc
argument_list|,
operator|(
name|flags
operator|&
name|DETECT_KBD
operator|)
condition|?
name|m
else|:
name|m
operator||
name|KBD_KBD_CONTROL_BITS
argument_list|)
expr_stmt|;
name|kbdc_lock
argument_list|(
name|sc_kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_if
if|#
directive|if
name|NAPM
operator|>
literal|0
end_if

begin_function
specifier|static
name|int
name|scresume
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|shfts
operator|=
name|ctls
operator|=
name|alts
operator|=
name|agrs
operator|=
name|metas
operator|=
name|accents
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|scattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|scr_stat
modifier|*
name|scp
decl_stmt|;
name|video_info_t
name|info
decl_stmt|;
name|dev_t
name|cdev
init|=
name|makedev
argument_list|(
name|CDEV_MAJOR
argument_list|,
literal|0
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|DEVFS
name|int
name|vc
decl_stmt|;
endif|#
directive|endif
name|scinit
argument_list|()
expr_stmt|;
name|flags
operator|=
name|dev
operator|->
name|id_flags
expr_stmt|;
if|if
condition|(
operator|!
name|ISFONTAVAIL
argument_list|(
name|adp_flags
argument_list|)
condition|)
name|flags
operator|&=
operator|~
name|CHAR_CURSOR
expr_stmt|;
name|scp
operator|=
name|console
index|[
literal|0
index|]
expr_stmt|;
comment|/* copy temporary buffer to final buffer */
name|scp
operator|->
name|scr_buf
operator|=
name|NULL
expr_stmt|;
name|sc_alloc_scr_buffer
argument_list|(
name|scp
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|sc_buffer
argument_list|,
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
comment|/* cut buffer is available only when the mouse pointer is used */
if|if
condition|(
name|ISMOUSEAVAIL
argument_list|(
name|adp_flags
argument_list|)
condition|)
name|sc_alloc_cut_buffer
argument_list|(
name|scp
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* initialize history buffer& pointers */
name|sc_alloc_history_buffer
argument_list|(
name|scp
argument_list|,
name|sc_history_size
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|VESA
argument_list|)
operator|&&
name|defined
argument_list|(
name|VM86
argument_list|)
if|if
condition|(
operator|(
name|flags
operator|&
name|VESA800X600
operator|)
operator|&&
operator|(
call|(
modifier|*
name|biosvidsw
operator|.
name|get_info
call|)
argument_list|(
name|scp
operator|->
name|adp
argument_list|,
name|M_VESA_800x600
argument_list|,
operator|&
name|info
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SC_SPLASH_SCREEN
name|scsplash_term
argument_list|(
name|scp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc_set_graphics_mode
argument_list|(
name|scp
argument_list|,
name|NULL
argument_list|,
name|M_VESA_800x600
argument_list|)
expr_stmt|;
name|sc_set_pixel_mode
argument_list|(
name|scp
argument_list|,
name|NULL
argument_list|,
name|COL
argument_list|,
name|ROW
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|initial_video_mode
operator|=
name|M_VESA_800x600
expr_stmt|;
ifdef|#
directive|ifdef
name|SC_SPLASH_SCREEN
name|scsplash_init
argument_list|(
name|scp
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* VESA&& VM86 */
comment|/* initialize cursor stuff */
if|if
condition|(
operator|!
name|ISGRAPHSC
argument_list|(
name|scp
argument_list|)
condition|)
name|draw_cursor_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
comment|/* get screen update going */
name|scrn_timer
argument_list|(
operator|(
name|void
operator|*
operator|)
name|TRUE
argument_list|)
expr_stmt|;
name|update_leds
argument_list|(
name|scp
operator|->
name|status
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sc%d: "
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|crtc_type
condition|)
block|{
case|case
name|KD_VGA
case|:
name|printf
argument_list|(
literal|"VGA %s"
argument_list|,
operator|(
name|adp_flags
operator|&
name|V_ADP_COLOR
operator|)
condition|?
literal|"color"
else|:
literal|"mono"
argument_list|)
expr_stmt|;
break|break;
case|case
name|KD_EGA
case|:
name|printf
argument_list|(
literal|"EGA %s"
argument_list|,
operator|(
name|adp_flags
operator|&
name|V_ADP_COLOR
operator|)
condition|?
literal|"color"
else|:
literal|"mono"
argument_list|)
expr_stmt|;
break|break;
case|case
name|KD_CGA
case|:
name|printf
argument_list|(
literal|"CGA"
argument_list|)
expr_stmt|;
break|break;
case|case
name|KD_MONO
case|:
case|case
name|KD_HERCULES
case|:
default|default:
name|printf
argument_list|(
literal|"MDA/Hercules"
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"<%d virtual consoles, flags=0x%x>\n"
argument_list|,
name|MAXCONS
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|#
directive|if
name|NAPM
operator|>
literal|0
name|scp
operator|->
name|r_hook
operator|.
name|ah_fun
operator|=
name|scresume
expr_stmt|;
name|scp
operator|->
name|r_hook
operator|.
name|ah_arg
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|r_hook
operator|.
name|ah_name
operator|=
literal|"system keyboard"
expr_stmt|;
name|scp
operator|->
name|r_hook
operator|.
name|ah_order
operator|=
name|APM_MID_ORDER
expr_stmt|;
name|apm_hook_establish
argument_list|(
name|APM_HOOK_RESUME
argument_list|,
operator|&
name|scp
operator|->
name|r_hook
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|at_shutdown
argument_list|(
name|scshutdown
argument_list|,
name|NULL
argument_list|,
name|SHUTDOWN_PRE_SYNC
argument_list|)
expr_stmt|;
name|cdevsw_add
argument_list|(
operator|&
name|cdev
argument_list|,
operator|&
name|sc_cdevsw
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVFS
for|for
control|(
name|vc
operator|=
literal|0
init|;
name|vc
operator|<
name|MAXCONS
condition|;
name|vc
operator|++
control|)
name|sc_devfs_token
index|[
name|vc
index|]
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|sc_cdevsw
argument_list|,
name|vc
argument_list|,
name|DV_CHR
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"ttyv%r"
argument_list|,
name|vc
argument_list|)
expr_stmt|;
name|sc_mouse_devfs_token
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|sc_cdevsw
argument_list|,
name|SC_MOUSE
argument_list|,
name|DV_CHR
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"sysmouse"
argument_list|)
expr_stmt|;
name|sc_console_devfs_token
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|sc_cdevsw
argument_list|,
name|SC_CONSOLE
argument_list|,
name|DV_CHR
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"consolectl"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
name|struct
name|tty
modifier|*
name|scdevtotty
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
name|int
name|unit
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|init_done
operator|==
name|COLD
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|unit
operator|==
name|SC_CONSOLE
condition|)
return|return
name|CONSOLE_TTY
return|;
if|if
condition|(
name|unit
operator|==
name|SC_MOUSE
condition|)
return|return
name|MOUSE_TTY
return|;
if|if
condition|(
name|unit
operator|>=
name|MAXCONS
operator|||
name|unit
operator|<
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
name|VIRTUAL_TTY
argument_list|(
name|unit
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|scopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
name|scdevtotty
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tp
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|tp
operator|->
name|t_oproc
operator|=
operator|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|==
name|SC_MOUSE
operator|)
condition|?
name|scmousestart
else|:
name|scstart
expr_stmt|;
name|tp
operator|->
name|t_param
operator|=
name|scparam
expr_stmt|;
name|tp
operator|->
name|t_dev
operator|=
name|dev
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
condition|)
block|{
name|ttychars
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* Use the current setting of the<-- key as default VERASE. */
comment|/* If the Delete key is preferable, an stty is necessary     */
name|tp
operator|->
name|t_cc
index|[
name|VERASE
index|]
operator|=
name|key_map
operator|.
name|key
index|[
literal|0x0e
index|]
operator|.
name|map
index|[
literal|0
index|]
expr_stmt|;
name|tp
operator|->
name|t_iflag
operator|=
name|TTYDEF_IFLAG
expr_stmt|;
name|tp
operator|->
name|t_oflag
operator|=
name|TTYDEF_OFLAG
expr_stmt|;
name|tp
operator|->
name|t_cflag
operator|=
name|TTYDEF_CFLAG
expr_stmt|;
name|tp
operator|->
name|t_lflag
operator|=
name|TTYDEF_LFLAG
expr_stmt|;
name|tp
operator|->
name|t_ispeed
operator|=
name|tp
operator|->
name|t_ospeed
operator|=
name|TTYDEF_SPEED
expr_stmt|;
name|scparam
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|)
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
operator|)
operator|(
name|tp
operator|,
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|==
name|SC_MOUSE
condition|)
name|mouse_level
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
block|}
elseif|else
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_XCLUDE
operator|&&
name|p
operator|->
name|p_ucred
operator|->
name|cr_uid
operator|!=
literal|0
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|<
name|MAXCONS
operator|&&
operator|!
name|console
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
condition|)
block|{
name|console
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
operator|=
name|alloc_scp
argument_list|()
expr_stmt|;
if|if
condition|(
name|ISGRAPHSC
argument_list|(
name|console
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
argument_list|)
condition|)
name|sc_set_pixel_mode
argument_list|(
name|console
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
argument_list|,
name|NULL
argument_list|,
name|COL
argument_list|,
name|ROW
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|<
name|MAXCONS
operator|&&
operator|!
name|tp
operator|->
name|t_winsize
operator|.
name|ws_col
operator|&&
operator|!
name|tp
operator|->
name|t_winsize
operator|.
name|ws_row
condition|)
block|{
name|tp
operator|->
name|t_winsize
operator|.
name|ws_col
operator|=
name|console
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
operator|->
name|xsize
expr_stmt|;
name|tp
operator|->
name|t_winsize
operator|.
name|ws_row
operator|=
name|console
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
operator|->
name|ysize
expr_stmt|;
block|}
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_open
operator|)
operator|(
name|dev
operator|,
name|tp
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|scclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
name|scdevtotty
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|scr_stat
modifier|*
name|scp
decl_stmt|;
if|if
condition|(
operator|!
name|tp
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|<
name|MAXCONS
condition|)
block|{
name|scp
operator|=
name|sc_get_scr_stat
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|SWITCH_WAIT_ACQ
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|scp
operator|->
name|smode
argument_list|)
expr_stmt|;
if|#
directive|if
name|not_yet_done
if|if
condition|(
name|scp
operator|==
operator|&
name|main_console
condition|)
block|{
name|scp
operator|->
name|pid
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|proc
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|smode
operator|.
name|mode
operator|=
name|VT_AUTO
expr_stmt|;
block|}
else|else
block|{
name|free
argument_list|(
name|scp
operator|->
name|scr_buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|history
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|scp
operator|->
name|history
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|history_size
operator|/
name|scp
operator|->
name|xsize
operator|>
name|imax
argument_list|(
name|sc_history_size
argument_list|,
name|scp
operator|->
name|ysize
argument_list|)
condition|)
name|extra_history_size
operator|+=
name|scp
operator|->
name|history_size
operator|/
name|scp
operator|->
name|xsize
operator|-
name|imax
argument_list|(
name|sc_history_size
argument_list|,
name|scp
operator|->
name|ysize
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|scp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|console
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
operator|=
name|NULL
expr_stmt|;
block|}
else|#
directive|else
name|scp
operator|->
name|pid
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|proc
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|smode
operator|.
name|mode
operator|=
name|VT_AUTO
expr_stmt|;
endif|#
directive|endif
block|}
name|spltty
argument_list|()
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_close
operator|)
operator|(
name|tp
operator|,
name|flag
operator|)
expr_stmt|;
name|ttyclose
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|spl0
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|scread
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
name|scdevtotty
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tp
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_read
operator|)
operator|(
name|tp
operator|,
name|uio
operator|,
name|flag
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|scwrite
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
name|scdevtotty
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tp
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_write
operator|)
operator|(
name|tp
operator|,
name|uio
operator|,
name|flag
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|scintr
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
specifier|static
name|struct
name|tty
modifier|*
name|cur_tty
decl_stmt|;
name|int
name|c
decl_stmt|,
name|len
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|;
comment|/*       * Loop while there is still input to get from the keyboard.      * I don't think this is nessesary, and it doesn't fix      * the Xaccel-2.1 keyboard hang, but it can't hurt.		XXX      */
while|while
condition|(
operator|(
name|c
operator|=
name|scgetc
argument_list|(
name|SCGETC_NONBLOCK
argument_list|)
operator|)
operator|!=
name|NOKEY
condition|)
block|{
name|cur_tty
operator|=
name|VIRTUAL_TTY
argument_list|(
name|get_scr_num
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cur_tty
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
condition|)
if|if
condition|(
operator|!
operator|(
operator|(
name|cur_tty
operator|=
name|CONSOLE_TTY
operator|)
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
condition|)
continue|continue;
switch|switch
condition|(
name|c
operator|&
literal|0xff00
condition|)
block|{
case|case
literal|0x0000
case|:
comment|/* normal key */
operator|(
operator|*
name|linesw
index|[
name|cur_tty
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|c
operator|&
literal|0xFF
operator|,
name|cur_tty
operator|)
expr_stmt|;
break|break;
case|case
name|FKEY
case|:
comment|/* function key, return string */
if|if
condition|(
name|cp
operator|=
name|get_fstr
argument_list|(
operator|(
name|u_int
operator|)
name|c
argument_list|,
operator|(
name|u_int
operator|*
operator|)
operator|&
name|len
argument_list|)
condition|)
block|{
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
operator|(
operator|*
name|linesw
index|[
name|cur_tty
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
operator|*
name|cp
operator|++
operator|&
literal|0xFF
operator|,
name|cur_tty
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|MKEY
case|:
comment|/* meta is active, prepend ESC */
operator|(
operator|*
name|linesw
index|[
name|cur_tty
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
literal|0x1b
operator|,
name|cur_tty
operator|)
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|cur_tty
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|c
operator|&
literal|0xFF
operator|,
name|cur_tty
operator|)
expr_stmt|;
break|break;
case|case
name|BKEY
case|:
comment|/* backtab fixed sequence (esc [ Z) */
operator|(
operator|*
name|linesw
index|[
name|cur_tty
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
literal|0x1b
operator|,
name|cur_tty
operator|)
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|cur_tty
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
literal|'['
operator|,
name|cur_tty
operator|)
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|cur_tty
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
literal|'Z'
operator|,
name|cur_tty
operator|)
expr_stmt|;
break|break;
block|}
block|}
if|#
directive|if
literal|0
block|if (cur_console->status& MOUSE_ENABLED) { 	cur_console->status&= ~MOUSE_VISIBLE; 	remove_mouse_image(cur_console);     }
else|#
directive|else
if|if
condition|(
name|cur_console
operator|->
name|status
operator|&
name|MOUSE_VISIBLE
condition|)
block|{
name|remove_mouse_image
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
name|cur_console
operator|->
name|status
operator|&=
operator|~
name|MOUSE_VISIBLE
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|scparam
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|termios
modifier|*
name|t
parameter_list|)
block|{
name|tp
operator|->
name|t_ispeed
operator|=
name|t
operator|->
name|c_ispeed
expr_stmt|;
name|tp
operator|->
name|t_ospeed
operator|=
name|t
operator|->
name|c_ospeed
expr_stmt|;
name|tp
operator|->
name|t_cflag
operator|=
name|t
operator|->
name|c_cflag
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|scioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|u_int
name|delta_ehs
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|scr_stat
modifier|*
name|scp
decl_stmt|;
name|video_adapter_t
modifier|*
name|adp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|tp
operator|=
name|scdevtotty
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tp
condition|)
return|return
name|ENXIO
return|;
name|scp
operator|=
name|sc_get_scr_stat
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
expr_stmt|;
comment|/* If there is a user_ioctl function call that first */
if|if
condition|(
name|sc_user_ioctl
condition|)
block|{
name|error
operator|=
call|(
modifier|*
name|sc_user_ioctl
call|)
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOIOCTL
condition|)
return|return
name|error
return|;
block|}
name|error
operator|=
name|sc_vid_ioctl
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOIOCTL
condition|)
return|return
name|error
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
comment|/* process console hardware related ioctl's */
case|case
name|GIO_ATTR
case|:
comment|/* get current attributes */
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
expr_stmt|;
return|return
literal|0
return|;
case|case
name|GIO_COLOR
case|:
comment|/* is this a color console ? */
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
operator|(
name|adp_flags
operator|&
name|V_ADP_COLOR
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
return|return
literal|0
return|;
case|case
name|CONS_BLANKTIME
case|:
comment|/* set screen saver timeout (0 = no saver) */
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|<
literal|0
operator|||
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|>
name|MAX_BLANKTIME
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|scrn_blank_time
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
name|run_scrn_saver
operator|=
operator|(
name|scrn_blank_time
operator|!=
literal|0
operator|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|CONS_CURSORTYPE
case|:
comment|/* set cursor type blink/noblink */
if|if
condition|(
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|)
operator|&
literal|0x01
condition|)
name|flags
operator||=
name|BLINK_CURSOR
expr_stmt|;
else|else
name|flags
operator|&=
operator|~
name|BLINK_CURSOR
expr_stmt|;
if|if
condition|(
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|)
operator|&
literal|0x02
condition|)
block|{
if|if
condition|(
operator|!
name|ISFONTAVAIL
argument_list|(
name|get_adapter
argument_list|(
name|scp
argument_list|)
operator|->
name|va_flags
argument_list|)
condition|)
return|return
name|ENXIO
return|;
name|flags
operator||=
name|CHAR_CURSOR
expr_stmt|;
block|}
else|else
name|flags
operator|&=
operator|~
name|CHAR_CURSOR
expr_stmt|;
comment|/*  	 * The cursor shape is global property; all virtual consoles 	 * are affected. Update the cursor in the current console... 	 */
if|if
condition|(
operator|!
name|ISGRAPHSC
argument_list|(
name|cur_console
argument_list|)
condition|)
block|{
name|remove_cursor_image
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|CHAR_CURSOR
condition|)
name|set_destructive_cursor
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
name|draw_cursor_image
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
case|case
name|CONS_BELLTYPE
case|:
comment|/* set bell type sound/visual */
if|if
condition|(
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|)
operator|&
literal|0x01
condition|)
name|flags
operator||=
name|VISUAL_BELL
expr_stmt|;
else|else
name|flags
operator|&=
operator|~
name|VISUAL_BELL
expr_stmt|;
if|if
condition|(
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|)
operator|&
literal|0x02
condition|)
name|flags
operator||=
name|QUIET_BELL
expr_stmt|;
else|else
name|flags
operator|&=
operator|~
name|QUIET_BELL
expr_stmt|;
return|return
literal|0
return|;
case|case
name|CONS_HISTORY
case|:
comment|/* set history size */
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|>
literal|0
condition|)
block|{
name|int
name|lines
decl_stmt|;
comment|/* buffer size to allocate */
name|int
name|lines0
decl_stmt|;
comment|/* current buffer size */
name|lines
operator|=
name|imax
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|,
name|scp
operator|->
name|ysize
argument_list|)
expr_stmt|;
name|lines0
operator|=
operator|(
name|scp
operator|->
name|history
operator|!=
name|NULL
operator|)
condition|?
name|scp
operator|->
name|history_size
operator|/
name|scp
operator|->
name|xsize
else|:
name|scp
operator|->
name|ysize
expr_stmt|;
if|if
condition|(
name|lines0
operator|>
name|imax
argument_list|(
name|sc_history_size
argument_list|,
name|scp
operator|->
name|ysize
argument_list|)
condition|)
name|delta_ehs
operator|=
name|lines0
operator|-
name|imax
argument_list|(
name|sc_history_size
argument_list|,
name|scp
operator|->
name|ysize
argument_list|)
expr_stmt|;
else|else
name|delta_ehs
operator|=
literal|0
expr_stmt|;
comment|/* 	     * syscons unconditionally allocates buffers upto SC_HISTORY_SIZE 	     * lines or scp->ysize lines, whichever is larger. A value  	     * greater than that is allowed, subject to extra_history_size. 	     */
if|if
condition|(
name|lines
operator|>
name|imax
argument_list|(
name|sc_history_size
argument_list|,
name|scp
operator|->
name|ysize
argument_list|)
condition|)
if|if
condition|(
name|lines
operator|-
name|imax
argument_list|(
name|sc_history_size
argument_list|,
name|scp
operator|->
name|ysize
argument_list|)
operator|>
name|extra_history_size
operator|+
name|delta_ehs
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|cur_console
operator|->
name|status
operator|&
name|BUFFER_SAVED
condition|)
return|return
name|EBUSY
return|;
name|sc_alloc_history_buffer
argument_list|(
name|scp
argument_list|,
name|lines
argument_list|,
name|delta_ehs
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
name|EINVAL
return|;
case|case
name|CONS_MOUSECTL
case|:
comment|/* control mouse arrow */
case|case
name|OLD_CONS_MOUSECTL
case|:
block|{
comment|/* MOUSE_BUTTON?DOWN -> MOUSE_MSC_BUTTON?UP */
specifier|static
name|int
name|butmap
index|[
literal|8
index|]
init|=
block|{
name|MOUSE_MSC_BUTTON1UP
operator||
name|MOUSE_MSC_BUTTON2UP
operator||
name|MOUSE_MSC_BUTTON3UP
block|,
name|MOUSE_MSC_BUTTON2UP
operator||
name|MOUSE_MSC_BUTTON3UP
block|,
name|MOUSE_MSC_BUTTON1UP
operator||
name|MOUSE_MSC_BUTTON3UP
block|,
name|MOUSE_MSC_BUTTON3UP
block|,
name|MOUSE_MSC_BUTTON1UP
operator||
name|MOUSE_MSC_BUTTON2UP
block|,
name|MOUSE_MSC_BUTTON2UP
block|,
name|MOUSE_MSC_BUTTON1UP
block|,
literal|0
block|, 	}
decl_stmt|;
name|mouse_info_t
modifier|*
name|mouse
init|=
operator|(
name|mouse_info_t
operator|*
operator|)
name|data
decl_stmt|;
name|mouse_info_t
name|buf
decl_stmt|;
comment|/* FIXME: */
if|if
condition|(
operator|!
name|ISMOUSEAVAIL
argument_list|(
name|get_adapter
argument_list|(
name|scp
argument_list|)
operator|->
name|va_flags
argument_list|)
condition|)
return|return
name|ENODEV
return|;
if|if
condition|(
name|cmd
operator|==
name|OLD_CONS_MOUSECTL
condition|)
block|{
specifier|static
name|u_char
name|swapb
index|[]
init|=
block|{
literal|0
block|,
literal|4
block|,
literal|2
block|,
literal|6
block|,
literal|1
block|,
literal|5
block|,
literal|3
block|,
literal|7
block|}
decl_stmt|;
name|old_mouse_info_t
modifier|*
name|old_mouse
init|=
operator|(
name|old_mouse_info_t
operator|*
operator|)
name|data
decl_stmt|;
name|mouse
operator|=
operator|&
name|buf
expr_stmt|;
name|mouse
operator|->
name|operation
operator|=
name|old_mouse
operator|->
name|operation
expr_stmt|;
switch|switch
condition|(
name|mouse
operator|->
name|operation
condition|)
block|{
case|case
name|MOUSE_MODE
case|:
name|mouse
operator|->
name|u
operator|.
name|mode
operator|=
name|old_mouse
operator|->
name|u
operator|.
name|mode
expr_stmt|;
break|break;
case|case
name|MOUSE_SHOW
case|:
case|case
name|MOUSE_HIDE
case|:
break|break;
case|case
name|MOUSE_MOVEABS
case|:
case|case
name|MOUSE_MOVEREL
case|:
case|case
name|MOUSE_ACTION
case|:
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|x
operator|=
name|old_mouse
operator|->
name|u
operator|.
name|data
operator|.
name|x
expr_stmt|;
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|y
operator|=
name|old_mouse
operator|->
name|u
operator|.
name|data
operator|.
name|y
expr_stmt|;
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|z
operator|=
literal|0
expr_stmt|;
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|buttons
operator|=
name|swapb
index|[
name|old_mouse
operator|->
name|u
operator|.
name|data
operator|.
name|buttons
operator|&
literal|0x7
index|]
expr_stmt|;
break|break;
case|case
name|MOUSE_GETINFO
case|:
name|old_mouse
operator|->
name|u
operator|.
name|data
operator|.
name|x
operator|=
name|scp
operator|->
name|mouse_xpos
expr_stmt|;
name|old_mouse
operator|->
name|u
operator|.
name|data
operator|.
name|y
operator|=
name|scp
operator|->
name|mouse_ypos
expr_stmt|;
name|old_mouse
operator|->
name|u
operator|.
name|data
operator|.
name|buttons
operator|=
name|swapb
index|[
name|scp
operator|->
name|mouse_buttons
operator|&
literal|0x7
index|]
expr_stmt|;
break|break;
default|default:
return|return
name|EINVAL
return|;
block|}
block|}
switch|switch
condition|(
name|mouse
operator|->
name|operation
condition|)
block|{
case|case
name|MOUSE_MODE
case|:
if|if
condition|(
name|ISSIGVALID
argument_list|(
name|mouse
operator|->
name|u
operator|.
name|mode
operator|.
name|signal
argument_list|)
condition|)
block|{
name|scp
operator|->
name|mouse_signal
operator|=
name|mouse
operator|->
name|u
operator|.
name|mode
operator|.
name|signal
expr_stmt|;
name|scp
operator|->
name|mouse_proc
operator|=
name|p
expr_stmt|;
name|scp
operator|->
name|mouse_pid
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
block|}
else|else
block|{
name|scp
operator|->
name|mouse_signal
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|mouse_proc
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|mouse_pid
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
case|case
name|MOUSE_SHOW
case|:
if|if
condition|(
name|ISTEXTSC
argument_list|(
name|scp
argument_list|)
operator|&&
operator|!
operator|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_ENABLED
operator|)
condition|)
block|{
name|scp
operator|->
name|status
operator||=
operator|(
name|MOUSE_ENABLED
operator||
name|MOUSE_VISIBLE
operator|)
expr_stmt|;
name|scp
operator|->
name|mouse_oldpos
operator|=
name|scp
operator|->
name|mouse_pos
expr_stmt|;
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
name|EINVAL
return|;
break|break;
case|case
name|MOUSE_HIDE
case|:
if|if
condition|(
name|ISTEXTSC
argument_list|(
name|scp
argument_list|)
operator|&&
operator|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_ENABLED
operator|)
condition|)
block|{
name|scp
operator|->
name|status
operator|&=
operator|~
operator|(
name|MOUSE_ENABLED
operator||
name|MOUSE_VISIBLE
operator|)
expr_stmt|;
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
name|EINVAL
return|;
break|break;
case|case
name|MOUSE_MOVEABS
case|:
name|scp
operator|->
name|mouse_xpos
operator|=
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|x
expr_stmt|;
name|scp
operator|->
name|mouse_ypos
operator|=
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|y
expr_stmt|;
name|set_mouse_pos
argument_list|(
name|scp
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOUSE_MOVEREL
case|:
name|scp
operator|->
name|mouse_xpos
operator|+=
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|x
expr_stmt|;
name|scp
operator|->
name|mouse_ypos
operator|+=
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|y
expr_stmt|;
name|set_mouse_pos
argument_list|(
name|scp
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOUSE_GETINFO
case|:
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|x
operator|=
name|scp
operator|->
name|mouse_xpos
expr_stmt|;
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|y
operator|=
name|scp
operator|->
name|mouse_ypos
expr_stmt|;
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|z
operator|=
literal|0
expr_stmt|;
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|buttons
operator|=
name|scp
operator|->
name|mouse_buttons
expr_stmt|;
return|return
literal|0
return|;
case|case
name|MOUSE_ACTION
case|:
case|case
name|MOUSE_MOTION_EVENT
case|:
comment|/* this should maybe only be settable from /dev/consolectl SOS */
comment|/* send out mouse event on /dev/sysmouse */
name|mouse_status
operator|.
name|dx
operator|+=
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|x
expr_stmt|;
name|mouse_status
operator|.
name|dy
operator|+=
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|y
expr_stmt|;
name|mouse_status
operator|.
name|dz
operator|+=
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|z
expr_stmt|;
if|if
condition|(
name|mouse
operator|->
name|operation
operator|==
name|MOUSE_ACTION
condition|)
name|mouse_status
operator|.
name|button
operator|=
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|buttons
expr_stmt|;
name|mouse_status
operator|.
name|flags
operator||=
operator|(
operator|(
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|x
operator|||
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|y
operator|||
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|z
operator|)
condition|?
name|MOUSE_POSCHANGED
else|:
literal|0
operator|)
operator||
operator|(
name|mouse_status
operator|.
name|obutton
operator|^
name|mouse_status
operator|.
name|button
operator|)
expr_stmt|;
if|if
condition|(
name|mouse_status
operator|.
name|flags
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ISTEXTSC
argument_list|(
name|cur_console
argument_list|)
operator|&&
operator|(
name|cur_console
operator|->
name|status
operator|&
name|MOUSE_ENABLED
operator|)
condition|)
name|cur_console
operator|->
name|status
operator||=
name|MOUSE_VISIBLE
expr_stmt|;
if|if
condition|(
operator|(
name|MOUSE_TTY
operator|)
operator|->
name|t_state
operator|&
name|TS_ISOPEN
condition|)
block|{
name|u_char
name|buf
index|[
name|MOUSE_SYS_PACKETSIZE
index|]
decl_stmt|;
name|int
name|j
decl_stmt|;
comment|/* the first five bytes are compatible with MouseSystems' */
name|buf
index|[
literal|0
index|]
operator|=
name|MOUSE_MSC_SYNC
operator||
name|butmap
index|[
name|mouse_status
operator|.
name|button
operator|&
name|MOUSE_STDBUTTONS
index|]
expr_stmt|;
name|j
operator|=
name|imax
argument_list|(
name|imin
argument_list|(
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|x
argument_list|,
literal|255
argument_list|)
argument_list|,
operator|-
literal|256
argument_list|)
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|j
operator|>>
literal|1
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|j
operator|-
name|buf
index|[
literal|1
index|]
expr_stmt|;
name|j
operator|=
operator|-
name|imax
argument_list|(
name|imin
argument_list|(
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|y
argument_list|,
literal|255
argument_list|)
argument_list|,
operator|-
literal|256
argument_list|)
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|j
operator|>>
literal|1
expr_stmt|;
name|buf
index|[
literal|4
index|]
operator|=
name|j
operator|-
name|buf
index|[
literal|2
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MOUSE_MSC_PACKETSIZE
condition|;
name|j
operator|++
control|)
operator|(
operator|*
name|linesw
index|[
operator|(
name|MOUSE_TTY
operator|)
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|buf
index|[
name|j
index|]
operator|,
name|MOUSE_TTY
operator|)
expr_stmt|;
if|if
condition|(
name|mouse_level
operator|>=
literal|1
condition|)
block|{
comment|/* extended part */
name|j
operator|=
name|imax
argument_list|(
name|imin
argument_list|(
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|z
argument_list|,
literal|127
argument_list|)
argument_list|,
operator|-
literal|128
argument_list|)
expr_stmt|;
name|buf
index|[
literal|5
index|]
operator|=
operator|(
name|j
operator|>>
literal|1
operator|)
operator|&
literal|0x7f
expr_stmt|;
name|buf
index|[
literal|6
index|]
operator|=
operator|(
name|j
operator|-
operator|(
name|j
operator|>>
literal|1
operator|)
operator|)
operator|&
literal|0x7f
expr_stmt|;
comment|/* buttons 4-10 */
name|buf
index|[
literal|7
index|]
operator|=
operator|(
operator|~
name|mouse_status
operator|.
name|button
operator|>>
literal|3
operator|)
operator|&
literal|0x7f
expr_stmt|;
for|for
control|(
name|j
operator|=
name|MOUSE_MSC_PACKETSIZE
init|;
name|j
operator|<
name|MOUSE_SYS_PACKETSIZE
condition|;
name|j
operator|++
control|)
operator|(
operator|*
name|linesw
index|[
operator|(
name|MOUSE_TTY
operator|)
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|buf
index|[
name|j
index|]
operator|,
name|MOUSE_TTY
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cur_console
operator|->
name|mouse_signal
condition|)
block|{
name|cur_console
operator|->
name|mouse_buttons
operator|=
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|buttons
expr_stmt|;
comment|/* has controlling process died? */
if|if
condition|(
name|cur_console
operator|->
name|mouse_proc
operator|&&
operator|(
name|cur_console
operator|->
name|mouse_proc
operator|!=
name|pfind
argument_list|(
name|cur_console
operator|->
name|mouse_pid
argument_list|)
operator|)
condition|)
block|{
name|cur_console
operator|->
name|mouse_signal
operator|=
literal|0
expr_stmt|;
name|cur_console
operator|->
name|mouse_proc
operator|=
name|NULL
expr_stmt|;
name|cur_console
operator|->
name|mouse_pid
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|psignal
argument_list|(
name|cur_console
operator|->
name|mouse_proc
argument_list|,
name|cur_console
operator|->
name|mouse_signal
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mouse
operator|->
name|operation
operator|==
name|MOUSE_ACTION
operator|&&
name|cut_buffer
operator|!=
name|NULL
condition|)
block|{
comment|/* process button presses */
if|if
condition|(
operator|(
name|cur_console
operator|->
name|mouse_buttons
operator|^
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|buttons
operator|)
operator|&&
name|ISTEXTSC
argument_list|(
name|cur_console
argument_list|)
condition|)
block|{
name|cur_console
operator|->
name|mouse_buttons
operator|=
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|buttons
expr_stmt|;
if|if
condition|(
name|cur_console
operator|->
name|mouse_buttons
operator|&
name|MOUSE_BUTTON1DOWN
condition|)
name|mouse_cut_start
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
else|else
name|mouse_cut_end
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_console
operator|->
name|mouse_buttons
operator|&
name|MOUSE_BUTTON2DOWN
operator|||
name|cur_console
operator|->
name|mouse_buttons
operator|&
name|MOUSE_BUTTON3DOWN
condition|)
name|mouse_paste
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|x
operator|!=
literal|0
operator|||
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|y
operator|!=
literal|0
condition|)
block|{
name|cur_console
operator|->
name|mouse_xpos
operator|+=
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|x
expr_stmt|;
name|cur_console
operator|->
name|mouse_ypos
operator|+=
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|y
expr_stmt|;
name|set_mouse_pos
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MOUSE_BUTTON_EVENT
case|:
if|if
condition|(
operator|(
name|mouse
operator|->
name|u
operator|.
name|event
operator|.
name|id
operator|&
name|MOUSE_BUTTONS
operator|)
operator|==
literal|0
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|mouse
operator|->
name|u
operator|.
name|event
operator|.
name|value
operator|<
literal|0
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|mouse
operator|->
name|u
operator|.
name|event
operator|.
name|value
operator|>
literal|0
condition|)
block|{
name|cur_console
operator|->
name|mouse_buttons
operator||=
name|mouse
operator|->
name|u
operator|.
name|event
operator|.
name|id
expr_stmt|;
name|mouse_status
operator|.
name|button
operator||=
name|mouse
operator|->
name|u
operator|.
name|event
operator|.
name|id
expr_stmt|;
block|}
else|else
block|{
name|cur_console
operator|->
name|mouse_buttons
operator|&=
operator|~
name|mouse
operator|->
name|u
operator|.
name|event
operator|.
name|id
expr_stmt|;
name|mouse_status
operator|.
name|button
operator|&=
operator|~
name|mouse
operator|->
name|u
operator|.
name|event
operator|.
name|id
expr_stmt|;
block|}
name|mouse_status
operator|.
name|flags
operator||=
name|mouse_status
operator|.
name|obutton
operator|^
name|mouse_status
operator|.
name|button
expr_stmt|;
if|if
condition|(
name|mouse_status
operator|.
name|flags
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ISTEXTSC
argument_list|(
name|cur_console
argument_list|)
operator|&&
operator|(
name|cur_console
operator|->
name|status
operator|&
name|MOUSE_ENABLED
operator|)
condition|)
name|cur_console
operator|->
name|status
operator||=
name|MOUSE_VISIBLE
expr_stmt|;
if|if
condition|(
operator|(
name|MOUSE_TTY
operator|)
operator|->
name|t_state
operator|&
name|TS_ISOPEN
condition|)
block|{
name|u_char
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|MOUSE_MSC_SYNC
operator||
name|butmap
index|[
name|mouse_status
operator|.
name|button
operator|&
name|MOUSE_STDBUTTONS
index|]
expr_stmt|;
name|buf
index|[
literal|7
index|]
operator|=
operator|(
operator|~
name|mouse_status
operator|.
name|button
operator|>>
literal|3
operator|)
operator|&
literal|0x7f
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|buf
index|[
literal|2
index|]
operator|=
name|buf
index|[
literal|3
index|]
operator|=
name|buf
index|[
literal|4
index|]
operator|=
name|buf
index|[
literal|5
index|]
operator|=
name|buf
index|[
literal|6
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
operator|(
name|mouse_level
operator|>=
literal|1
operator|)
condition|?
name|MOUSE_SYS_PACKETSIZE
else|:
name|MOUSE_MSC_PACKETSIZE
operator|)
condition|;
name|i
operator|++
control|)
operator|(
operator|*
name|linesw
index|[
operator|(
name|MOUSE_TTY
operator|)
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|buf
index|[
name|i
index|]
operator|,
name|MOUSE_TTY
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|cur_console
operator|->
name|mouse_signal
condition|)
block|{
if|if
condition|(
name|cur_console
operator|->
name|mouse_proc
operator|&&
operator|(
name|cur_console
operator|->
name|mouse_proc
operator|!=
name|pfind
argument_list|(
name|cur_console
operator|->
name|mouse_pid
argument_list|)
operator|)
condition|)
block|{
name|cur_console
operator|->
name|mouse_signal
operator|=
literal|0
expr_stmt|;
name|cur_console
operator|->
name|mouse_proc
operator|=
name|NULL
expr_stmt|;
name|cur_console
operator|->
name|mouse_pid
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|psignal
argument_list|(
name|cur_console
operator|->
name|mouse_proc
argument_list|,
name|cur_console
operator|->
name|mouse_signal
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ISTEXTSC
argument_list|(
name|cur_console
argument_list|)
operator|||
operator|(
name|cut_buffer
operator|==
name|NULL
operator|)
condition|)
break|break;
switch|switch
condition|(
name|mouse
operator|->
name|u
operator|.
name|event
operator|.
name|id
condition|)
block|{
case|case
name|MOUSE_BUTTON1DOWN
case|:
switch|switch
condition|(
name|mouse
operator|->
name|u
operator|.
name|event
operator|.
name|value
operator|%
literal|4
condition|)
block|{
case|case
literal|0
case|:
comment|/* up */
name|mouse_cut_end
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|mouse_cut_start
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|mouse_cut_word
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|mouse_cut_line
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|MOUSE_BUTTON2DOWN
case|:
switch|switch
condition|(
name|mouse
operator|->
name|u
operator|.
name|event
operator|.
name|value
condition|)
block|{
case|case
literal|0
case|:
comment|/* up */
break|break;
default|default:
name|mouse_paste
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|MOUSE_BUTTON3DOWN
case|:
switch|switch
condition|(
name|mouse
operator|->
name|u
operator|.
name|event
operator|.
name|value
condition|)
block|{
case|case
literal|0
case|:
comment|/* up */
if|if
condition|(
operator|!
operator|(
name|cur_console
operator|->
name|mouse_buttons
operator|&
name|MOUSE_BUTTON1DOWN
operator|)
condition|)
name|mouse_cut_end
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
break|break;
default|default:
name|mouse_cut_extend
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
break|break;
default|default:
return|return
name|EINVAL
return|;
block|}
comment|/* make screensaver happy */
name|scsplash_stick
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|run_scrn_saver
operator|=
name|FALSE
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* MOUSE_XXX: /dev/sysmouse ioctls */
case|case
name|MOUSE_GETHWINFO
case|:
comment|/* get device information */
block|{
name|mousehw_t
modifier|*
name|hw
init|=
operator|(
name|mousehw_t
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|tp
operator|!=
name|MOUSE_TTY
condition|)
return|return
name|ENOTTY
return|;
name|hw
operator|->
name|buttons
operator|=
literal|10
expr_stmt|;
comment|/* XXX unknown */
name|hw
operator|->
name|iftype
operator|=
name|MOUSE_IF_SYSMOUSE
expr_stmt|;
name|hw
operator|->
name|type
operator|=
name|MOUSE_MOUSE
expr_stmt|;
name|hw
operator|->
name|model
operator|=
name|MOUSE_MODEL_GENERIC
expr_stmt|;
name|hw
operator|->
name|hwid
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
case|case
name|MOUSE_GETMODE
case|:
comment|/* get protocol/mode */
block|{
name|mousemode_t
modifier|*
name|mode
init|=
operator|(
name|mousemode_t
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|tp
operator|!=
name|MOUSE_TTY
condition|)
return|return
name|ENOTTY
return|;
name|mode
operator|->
name|level
operator|=
name|mouse_level
expr_stmt|;
switch|switch
condition|(
name|mode
operator|->
name|level
condition|)
block|{
case|case
literal|0
case|:
comment|/* at this level, sysmouse emulates MouseSystems protocol */
name|mode
operator|->
name|protocol
operator|=
name|MOUSE_PROTO_MSC
expr_stmt|;
name|mode
operator|->
name|rate
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* unknown */
name|mode
operator|->
name|resolution
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* unknown */
name|mode
operator|->
name|accelfactor
operator|=
literal|0
expr_stmt|;
comment|/* disabled */
name|mode
operator|->
name|packetsize
operator|=
name|MOUSE_MSC_PACKETSIZE
expr_stmt|;
name|mode
operator|->
name|syncmask
index|[
literal|0
index|]
operator|=
name|MOUSE_MSC_SYNCMASK
expr_stmt|;
name|mode
operator|->
name|syncmask
index|[
literal|1
index|]
operator|=
name|MOUSE_MSC_SYNC
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* at this level, sysmouse uses its own protocol */
name|mode
operator|->
name|protocol
operator|=
name|MOUSE_PROTO_SYSMOUSE
expr_stmt|;
name|mode
operator|->
name|rate
operator|=
operator|-
literal|1
expr_stmt|;
name|mode
operator|->
name|resolution
operator|=
operator|-
literal|1
expr_stmt|;
name|mode
operator|->
name|accelfactor
operator|=
literal|0
expr_stmt|;
name|mode
operator|->
name|packetsize
operator|=
name|MOUSE_SYS_PACKETSIZE
expr_stmt|;
name|mode
operator|->
name|syncmask
index|[
literal|0
index|]
operator|=
name|MOUSE_SYS_SYNCMASK
expr_stmt|;
name|mode
operator|->
name|syncmask
index|[
literal|1
index|]
operator|=
name|MOUSE_SYS_SYNC
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
case|case
name|MOUSE_SETMODE
case|:
comment|/* set protocol/mode */
block|{
name|mousemode_t
modifier|*
name|mode
init|=
operator|(
name|mousemode_t
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|tp
operator|!=
name|MOUSE_TTY
condition|)
return|return
name|ENOTTY
return|;
if|if
condition|(
operator|(
name|mode
operator|->
name|level
operator|<
literal|0
operator|)
operator|||
operator|(
name|mode
operator|->
name|level
operator|>
literal|1
operator|)
condition|)
return|return
name|EINVAL
return|;
name|mouse_level
operator|=
name|mode
operator|->
name|level
expr_stmt|;
return|return
literal|0
return|;
block|}
case|case
name|MOUSE_GETLEVEL
case|:
comment|/* get operation level */
if|if
condition|(
name|tp
operator|!=
name|MOUSE_TTY
condition|)
return|return
name|ENOTTY
return|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|mouse_level
expr_stmt|;
return|return
literal|0
return|;
case|case
name|MOUSE_SETLEVEL
case|:
comment|/* set operation level */
if|if
condition|(
name|tp
operator|!=
name|MOUSE_TTY
condition|)
return|return
name|ENOTTY
return|;
if|if
condition|(
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|<
literal|0
operator|)
operator|||
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|>
literal|1
operator|)
condition|)
return|return
name|EINVAL
return|;
name|mouse_level
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
return|return
literal|0
return|;
case|case
name|MOUSE_GETSTATUS
case|:
comment|/* get accumulated mouse events */
if|if
condition|(
name|tp
operator|!=
name|MOUSE_TTY
condition|)
return|return
name|ENOTTY
return|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
operator|*
operator|(
name|mousestatus_t
operator|*
operator|)
name|data
operator|=
name|mouse_status
expr_stmt|;
name|mouse_status
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|mouse_status
operator|.
name|obutton
operator|=
name|mouse_status
operator|.
name|button
expr_stmt|;
name|mouse_status
operator|.
name|dx
operator|=
literal|0
expr_stmt|;
name|mouse_status
operator|.
name|dy
operator|=
literal|0
expr_stmt|;
name|mouse_status
operator|.
name|dz
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
if|#
directive|if
name|notyet
case|case
name|MOUSE_GETVARS
case|:
comment|/* get internal mouse variables */
case|case
name|MOUSE_SETVARS
case|:
comment|/* set internal mouse variables */
if|if
condition|(
name|tp
operator|!=
name|MOUSE_TTY
condition|)
return|return
name|ENOTTY
return|;
return|return
name|ENODEV
return|;
endif|#
directive|endif
case|case
name|MOUSE_READSTATE
case|:
comment|/* read status from the device */
case|case
name|MOUSE_READDATA
case|:
comment|/* read data from the device */
if|if
condition|(
name|tp
operator|!=
name|MOUSE_TTY
condition|)
return|return
name|ENOTTY
return|;
return|return
name|ENODEV
return|;
case|case
name|CONS_GETINFO
case|:
comment|/* get current (virtual) console info */
block|{
name|vid_info_t
modifier|*
name|ptr
init|=
operator|(
name|vid_info_t
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|ptr
operator|->
name|size
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|vid_info
argument_list|)
condition|)
block|{
name|ptr
operator|->
name|m_num
operator|=
name|get_scr_num
argument_list|()
expr_stmt|;
name|ptr
operator|->
name|mv_col
operator|=
name|scp
operator|->
name|xpos
expr_stmt|;
name|ptr
operator|->
name|mv_row
operator|=
name|scp
operator|->
name|ypos
expr_stmt|;
name|ptr
operator|->
name|mv_csz
operator|=
name|scp
operator|->
name|xsize
expr_stmt|;
name|ptr
operator|->
name|mv_rsz
operator|=
name|scp
operator|->
name|ysize
expr_stmt|;
name|ptr
operator|->
name|mv_norm
operator|.
name|fore
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|std_color
operator|&
literal|0x0f00
operator|)
operator|>>
literal|8
expr_stmt|;
name|ptr
operator|->
name|mv_norm
operator|.
name|back
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|std_color
operator|&
literal|0xf000
operator|)
operator|>>
literal|12
expr_stmt|;
name|ptr
operator|->
name|mv_rev
operator|.
name|fore
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|rev_color
operator|&
literal|0x0f00
operator|)
operator|>>
literal|8
expr_stmt|;
name|ptr
operator|->
name|mv_rev
operator|.
name|back
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|rev_color
operator|&
literal|0xf000
operator|)
operator|>>
literal|12
expr_stmt|;
name|ptr
operator|->
name|mv_grfc
operator|.
name|fore
operator|=
literal|0
expr_stmt|;
comment|/* not supported */
name|ptr
operator|->
name|mv_grfc
operator|.
name|back
operator|=
literal|0
expr_stmt|;
comment|/* not supported */
name|ptr
operator|->
name|mv_ovscan
operator|=
name|scp
operator|->
name|border
expr_stmt|;
name|ptr
operator|->
name|mk_keylock
operator|=
name|scp
operator|->
name|status
operator|&
name|LOCK_KEY_MASK
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|EINVAL
return|;
block|}
case|case
name|CONS_GETVERS
case|:
comment|/* get version number */
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
literal|0x200
expr_stmt|;
comment|/* version 2.0 */
return|return
literal|0
return|;
case|case
name|CONS_IDLE
case|:
comment|/* see if the screen has been idle */
comment|/* 	 * When the screen is in the GRAPHICS_MODE or UNKNOWN_MODE, 	 * the user process may have been writing something on the 	 * screen and syscons is not aware of it. Declare the screen 	 * is NOT idle if it is in one of these modes. But there is 	 * an exception to it; if a screen saver is running in the  	 * graphics mode in the current screen, we should say that the 	 * screen has been idle. 	 */
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|scrn_idle
operator|&&
operator|(
operator|!
name|ISGRAPHSC
argument_list|(
name|cur_console
argument_list|)
operator|||
operator|(
name|cur_console
operator|->
name|status
operator|&
name|SAVER_RUNNING
operator|)
operator|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|CONS_SAVERMODE
case|:
comment|/* set saver mode */
switch|switch
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
block|{
case|case
name|CONS_USR_SAVER
case|:
comment|/* if a LKM screen saver is running, stop it first. */
name|scsplash_stick
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|saver_mode
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|wait_scrn_saver_stop
argument_list|()
operator|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|scp
operator|->
name|status
operator||=
name|SAVER_RUNNING
expr_stmt|;
name|scsplash_stick
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONS_LKM_SAVER
case|:
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|saver_mode
operator|==
name|CONS_USR_SAVER
operator|)
operator|&&
operator|(
name|scp
operator|->
name|status
operator|&
name|SAVER_RUNNING
operator|)
condition|)
name|scp
operator|->
name|status
operator|&=
operator|~
name|SAVER_RUNNING
expr_stmt|;
name|saver_mode
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|EINVAL
return|;
block|}
return|return
literal|0
return|;
case|case
name|CONS_SAVERSTART
case|:
comment|/* immediately start/stop the screen saver */
comment|/* 	 * Note that this ioctl does not guarantee the screen saver  	 * actually starts or stops. It merely attempts to do so... 	 */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|run_scrn_saver
operator|=
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|run_scrn_saver
condition|)
name|scrn_time_stamp
operator|-=
name|scrn_blank_time
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|VT_SETMODE
case|:
comment|/* set screen switcher mode */
block|{
name|struct
name|vt_mode
modifier|*
name|mode
decl_stmt|;
name|mode
operator|=
operator|(
expr|struct
name|vt_mode
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|ISSIGVALID
argument_list|(
name|mode
operator|->
name|relsig
argument_list|)
operator|&&
name|ISSIGVALID
argument_list|(
name|mode
operator|->
name|acqsig
argument_list|)
operator|&&
name|ISSIGVALID
argument_list|(
name|mode
operator|->
name|frsig
argument_list|)
condition|)
block|{
name|bcopy
argument_list|(
name|data
argument_list|,
operator|&
name|scp
operator|->
name|smode
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vt_mode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|smode
operator|.
name|mode
operator|==
name|VT_PROCESS
condition|)
block|{
name|scp
operator|->
name|proc
operator|=
name|p
expr_stmt|;
name|scp
operator|->
name|pid
operator|=
name|scp
operator|->
name|proc
operator|->
name|p_pid
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
else|else
return|return
name|EINVAL
return|;
block|}
case|case
name|VT_GETMODE
case|:
comment|/* get screen switcher mode */
name|bcopy
argument_list|(
operator|&
name|scp
operator|->
name|smode
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vt_mode
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|VT_RELDISP
case|:
comment|/* screen switcher ioctl */
switch|switch
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
block|{
case|case
name|VT_FALSE
case|:
comment|/* user refuses to release screen, abort */
if|if
condition|(
name|scp
operator|==
name|old_scp
operator|&&
operator|(
name|scp
operator|->
name|status
operator|&
name|SWITCH_WAIT_REL
operator|)
condition|)
block|{
name|old_scp
operator|->
name|status
operator|&=
operator|~
name|SWITCH_WAIT_REL
expr_stmt|;
name|switch_in_progress
operator|=
name|FALSE
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|EINVAL
return|;
case|case
name|VT_TRUE
case|:
comment|/* user has released screen, go on */
if|if
condition|(
name|scp
operator|==
name|old_scp
operator|&&
operator|(
name|scp
operator|->
name|status
operator|&
name|SWITCH_WAIT_REL
operator|)
condition|)
block|{
name|scp
operator|->
name|status
operator|&=
operator|~
name|SWITCH_WAIT_REL
expr_stmt|;
name|exchange_scr
argument_list|()
expr_stmt|;
if|if
condition|(
name|new_scp
operator|->
name|smode
operator|.
name|mode
operator|==
name|VT_PROCESS
condition|)
block|{
name|new_scp
operator|->
name|status
operator||=
name|SWITCH_WAIT_ACQ
expr_stmt|;
name|psignal
argument_list|(
name|new_scp
operator|->
name|proc
argument_list|,
name|new_scp
operator|->
name|smode
operator|.
name|acqsig
argument_list|)
expr_stmt|;
block|}
else|else
name|switch_in_progress
operator|=
name|FALSE
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|EINVAL
return|;
case|case
name|VT_ACKACQ
case|:
comment|/* acquire acknowledged, switch completed */
if|if
condition|(
name|scp
operator|==
name|new_scp
operator|&&
operator|(
name|scp
operator|->
name|status
operator|&
name|SWITCH_WAIT_ACQ
operator|)
condition|)
block|{
name|scp
operator|->
name|status
operator|&=
operator|~
name|SWITCH_WAIT_ACQ
expr_stmt|;
name|switch_in_progress
operator|=
name|FALSE
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|EINVAL
return|;
default|default:
return|return
name|EINVAL
return|;
block|}
comment|/* NOT REACHED */
case|case
name|VT_OPENQRY
case|:
comment|/* return free virtual console */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXCONS
condition|;
name|i
operator|++
control|)
block|{
name|tp
operator|=
name|VIRTUAL_TTY
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
condition|)
block|{
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|i
operator|+
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
name|EINVAL
return|;
case|case
name|VT_ACTIVATE
case|:
comment|/* switch to screen *data */
return|return
name|switch_scr
argument_list|(
name|scp
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|-
literal|1
argument_list|)
return|;
case|case
name|VT_WAITACTIVE
case|:
comment|/* wait for switch to occur */
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|>
name|MAXCONS
operator|||
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|<
literal|0
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|==
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|-
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|scp
operator|==
name|cur_console
condition|)
return|return
literal|0
return|;
block|}
else|else
name|scp
operator|=
name|console
index|[
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|-
literal|1
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|scp
operator|->
name|smode
argument_list|,
name|PZERO
operator||
name|PCATCH
argument_list|,
literal|"waitvt"
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|ERESTART
condition|)
empty_stmt|;
return|return
name|error
return|;
case|case
name|VT_GETACTIVE
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|get_scr_num
argument_list|()
operator|+
literal|1
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KDENABIO
case|:
comment|/* allow io operations */
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
if|if
condition|(
name|securelevel
operator|>
literal|0
condition|)
return|return
name|EPERM
return|;
name|p
operator|->
name|p_md
operator|.
name|md_regs
operator|->
name|tf_eflags
operator||=
name|PSL_IOPL
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KDDISABIO
case|:
comment|/* disallow io operations (default) */
name|p
operator|->
name|p_md
operator|.
name|md_regs
operator|->
name|tf_eflags
operator|&=
operator|~
name|PSL_IOPL
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KDSKBSTATE
case|:
comment|/* set keyboard state (locks) */
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
operator|~
name|LOCK_KEY_MASK
condition|)
return|return
name|EINVAL
return|;
name|scp
operator|->
name|status
operator|&=
operator|~
name|LOCK_KEY_MASK
expr_stmt|;
name|scp
operator|->
name|status
operator||=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|scp
operator|==
name|cur_console
condition|)
name|update_leds
argument_list|(
name|scp
operator|->
name|status
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KDGKBSTATE
case|:
comment|/* get keyboard state (locks) */
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|scp
operator|->
name|status
operator|&
name|LOCK_KEY_MASK
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KDSETRAD
case|:
comment|/* set keyboard repeat& delay rates */
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
operator|~
literal|0x7f
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|sc_kbdc
operator|!=
name|NULL
condition|)
name|set_keyboard
argument_list|(
name|KBDC_SET_TYPEMATIC
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KDSKBMODE
case|:
comment|/* set keyboard mode */
switch|switch
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
block|{
case|case
name|K_RAW
case|:
comment|/* switch to RAW scancode mode */
name|scp
operator|->
name|status
operator|&=
operator|~
name|KBD_CODE_MODE
expr_stmt|;
name|scp
operator|->
name|status
operator||=
name|KBD_RAW_MODE
expr_stmt|;
return|return
literal|0
return|;
case|case
name|K_CODE
case|:
comment|/* switch to CODE mode */
name|scp
operator|->
name|status
operator|&=
operator|~
name|KBD_RAW_MODE
expr_stmt|;
name|scp
operator|->
name|status
operator||=
name|KBD_CODE_MODE
expr_stmt|;
return|return
literal|0
return|;
case|case
name|K_XLATE
case|:
comment|/* switch to XLT ascii mode */
if|if
condition|(
name|scp
operator|==
name|cur_console
operator|&&
name|scp
operator|->
name|status
operator|&
name|KBD_RAW_MODE
condition|)
name|shfts
operator|=
name|ctls
operator|=
name|alts
operator|=
name|agrs
operator|=
name|metas
operator|=
name|accents
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|status
operator|&=
operator|~
operator|(
name|KBD_RAW_MODE
operator||
name|KBD_CODE_MODE
operator|)
expr_stmt|;
return|return
literal|0
return|;
default|default:
return|return
name|EINVAL
return|;
block|}
comment|/* NOT REACHED */
case|case
name|KDGKBMODE
case|:
comment|/* get keyboard mode */
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
operator|(
name|scp
operator|->
name|status
operator|&
name|KBD_RAW_MODE
operator|)
condition|?
name|K_RAW
else|:
operator|(
operator|(
name|scp
operator|->
name|status
operator|&
name|KBD_CODE_MODE
operator|)
condition|?
name|K_CODE
else|:
name|K_XLATE
operator|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KDMKTONE
case|:
comment|/* sound the bell */
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
name|do_bell
argument_list|(
name|scp
argument_list|,
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|)
operator|&
literal|0xffff
argument_list|,
operator|(
operator|(
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|)
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
operator|*
name|hz
operator|/
literal|1000
argument_list|)
expr_stmt|;
else|else
name|do_bell
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|bell_pitch
argument_list|,
name|scp
operator|->
name|bell_duration
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KIOCSOUND
case|:
comment|/* make tone (*data) hz */
if|if
condition|(
name|scp
operator|==
name|cur_console
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
block|{
name|int
name|pitch
init|=
name|timer_freq
operator|/
operator|*
operator|(
name|int
operator|*
operator|)
name|data
decl_stmt|;
comment|/* set command for counter 2, 2 byte write */
if|if
condition|(
name|acquire_timer2
argument_list|(
name|TIMER_16BIT
operator||
name|TIMER_SQWAVE
argument_list|)
condition|)
return|return
name|EBUSY
return|;
comment|/* set pitch */
name|outb
argument_list|(
name|TIMER_CNTR2
argument_list|,
name|pitch
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TIMER_CNTR2
argument_list|,
operator|(
name|pitch
operator|>>
literal|8
operator|)
argument_list|)
expr_stmt|;
comment|/* enable counter 2 output to speaker */
name|outb
argument_list|(
name|IO_PPI
argument_list|,
name|inb
argument_list|(
name|IO_PPI
argument_list|)
operator||
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* disable counter 2 output to speaker */
name|outb
argument_list|(
name|IO_PPI
argument_list|,
name|inb
argument_list|(
name|IO_PPI
argument_list|)
operator|&
literal|0xFC
argument_list|)
expr_stmt|;
name|release_timer2
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
case|case
name|KDGKBTYPE
case|:
comment|/* get keyboard type */
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
literal|0
expr_stmt|;
comment|/* type not known (yet) */
return|return
literal|0
return|;
case|case
name|KDSETLED
case|:
comment|/* set keyboard LED status */
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
operator|~
name|LED_MASK
condition|)
return|return
name|EINVAL
return|;
name|scp
operator|->
name|status
operator|&=
operator|~
name|LED_MASK
expr_stmt|;
name|scp
operator|->
name|status
operator||=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|scp
operator|==
name|cur_console
condition|)
name|update_leds
argument_list|(
name|scp
operator|->
name|status
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KDGETLED
case|:
comment|/* get keyboard LED status */
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|scp
operator|->
name|status
operator|&
name|LED_MASK
expr_stmt|;
return|return
literal|0
return|;
case|case
name|GETFKEY
case|:
comment|/* get functionkey string */
if|if
condition|(
operator|*
operator|(
name|u_short
operator|*
operator|)
name|data
operator|<
name|n_fkey_tab
condition|)
block|{
name|fkeyarg_t
modifier|*
name|ptr
init|=
operator|(
name|fkeyarg_t
operator|*
operator|)
name|data
decl_stmt|;
name|bcopy
argument_list|(
operator|&
name|fkey_tab
index|[
name|ptr
operator|->
name|keynum
index|]
operator|.
name|str
argument_list|,
name|ptr
operator|->
name|keydef
argument_list|,
name|fkey_tab
index|[
name|ptr
operator|->
name|keynum
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|flen
operator|=
name|fkey_tab
index|[
name|ptr
operator|->
name|keynum
index|]
operator|.
name|len
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
name|EINVAL
return|;
case|case
name|SETFKEY
case|:
comment|/* set functionkey string */
if|if
condition|(
operator|*
operator|(
name|u_short
operator|*
operator|)
name|data
operator|<
name|n_fkey_tab
condition|)
block|{
name|fkeyarg_t
modifier|*
name|ptr
init|=
operator|(
name|fkeyarg_t
operator|*
operator|)
name|data
decl_stmt|;
name|bcopy
argument_list|(
name|ptr
operator|->
name|keydef
argument_list|,
operator|&
name|fkey_tab
index|[
name|ptr
operator|->
name|keynum
index|]
operator|.
name|str
argument_list|,
name|min
argument_list|(
name|ptr
operator|->
name|flen
argument_list|,
name|MAXFK
argument_list|)
argument_list|)
expr_stmt|;
name|fkey_tab
index|[
name|ptr
operator|->
name|keynum
index|]
operator|.
name|len
operator|=
name|min
argument_list|(
name|ptr
operator|->
name|flen
argument_list|,
name|MAXFK
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
name|EINVAL
return|;
case|case
name|GIO_SCRNMAP
case|:
comment|/* get output translation table */
name|bcopy
argument_list|(
operator|&
name|scr_map
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|scr_map
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|PIO_SCRNMAP
case|:
comment|/* set output translation table */
name|bcopy
argument_list|(
name|data
argument_list|,
operator|&
name|scr_map
argument_list|,
sizeof|sizeof
argument_list|(
name|scr_map
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|scr_map
argument_list|)
condition|;
name|i
operator|++
control|)
name|scr_rmap
index|[
name|scr_map
index|[
name|i
index|]
index|]
operator|=
name|i
expr_stmt|;
return|return
literal|0
return|;
case|case
name|GIO_KEYMAP
case|:
comment|/* get keyboard translation table */
name|bcopy
argument_list|(
operator|&
name|key_map
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|key_map
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|PIO_KEYMAP
case|:
comment|/* set keyboard translation table */
name|accents
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|accent_map
argument_list|,
sizeof|sizeof
argument_list|(
name|accent_map
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|data
argument_list|,
operator|&
name|key_map
argument_list|,
sizeof|sizeof
argument_list|(
name|key_map
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|GIO_DEADKEYMAP
case|:
comment|/* get accent key translation table */
name|bcopy
argument_list|(
operator|&
name|accent_map
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|accent_map
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|PIO_DEADKEYMAP
case|:
comment|/* set accent key translation table */
name|accents
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
name|data
argument_list|,
operator|&
name|accent_map
argument_list|,
sizeof|sizeof
argument_list|(
name|accent_map
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|PIO_FONT8x8
case|:
comment|/* set 8x8 dot font */
if|if
condition|(
operator|!
name|ISFONTAVAIL
argument_list|(
name|get_adapter
argument_list|(
name|scp
argument_list|)
operator|->
name|va_flags
argument_list|)
condition|)
return|return
name|ENXIO
return|;
name|bcopy
argument_list|(
name|data
argument_list|,
name|font_8
argument_list|,
literal|8
operator|*
literal|256
argument_list|)
expr_stmt|;
name|fonts_loaded
operator||=
name|FONT_8
expr_stmt|;
comment|/* 	 * FONT KLUDGE 	 * Always use the font page #0. XXX 	 * Don't load if the current font size is not 8x8. 	 */
if|if
condition|(
name|ISTEXTSC
argument_list|(
name|cur_console
argument_list|)
operator|&&
operator|(
name|cur_console
operator|->
name|font_size
operator|<
literal|14
operator|)
condition|)
name|copy_font
argument_list|(
name|cur_console
argument_list|,
name|LOAD
argument_list|,
literal|8
argument_list|,
name|font_8
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|GIO_FONT8x8
case|:
comment|/* get 8x8 dot font */
if|if
condition|(
operator|!
name|ISFONTAVAIL
argument_list|(
name|get_adapter
argument_list|(
name|scp
argument_list|)
operator|->
name|va_flags
argument_list|)
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
name|fonts_loaded
operator|&
name|FONT_8
condition|)
block|{
name|bcopy
argument_list|(
name|font_8
argument_list|,
name|data
argument_list|,
literal|8
operator|*
literal|256
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
name|ENXIO
return|;
case|case
name|PIO_FONT8x14
case|:
comment|/* set 8x14 dot font */
if|if
condition|(
operator|!
name|ISFONTAVAIL
argument_list|(
name|get_adapter
argument_list|(
name|scp
argument_list|)
operator|->
name|va_flags
argument_list|)
condition|)
return|return
name|ENXIO
return|;
name|bcopy
argument_list|(
name|data
argument_list|,
name|font_14
argument_list|,
literal|14
operator|*
literal|256
argument_list|)
expr_stmt|;
name|fonts_loaded
operator||=
name|FONT_14
expr_stmt|;
comment|/* 	 * FONT KLUDGE 	 * Always use the font page #0. XXX 	 * Don't load if the current font size is not 8x14. 	 */
if|if
condition|(
name|ISTEXTSC
argument_list|(
name|cur_console
argument_list|)
operator|&&
operator|(
name|cur_console
operator|->
name|font_size
operator|>=
literal|14
operator|)
operator|&&
operator|(
name|cur_console
operator|->
name|font_size
operator|<
literal|16
operator|)
condition|)
name|copy_font
argument_list|(
name|cur_console
argument_list|,
name|LOAD
argument_list|,
literal|14
argument_list|,
name|font_14
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|GIO_FONT8x14
case|:
comment|/* get 8x14 dot font */
if|if
condition|(
operator|!
name|ISFONTAVAIL
argument_list|(
name|get_adapter
argument_list|(
name|scp
argument_list|)
operator|->
name|va_flags
argument_list|)
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
name|fonts_loaded
operator|&
name|FONT_14
condition|)
block|{
name|bcopy
argument_list|(
name|font_14
argument_list|,
name|data
argument_list|,
literal|14
operator|*
literal|256
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
name|ENXIO
return|;
case|case
name|PIO_FONT8x16
case|:
comment|/* set 8x16 dot font */
if|if
condition|(
operator|!
name|ISFONTAVAIL
argument_list|(
name|get_adapter
argument_list|(
name|scp
argument_list|)
operator|->
name|va_flags
argument_list|)
condition|)
return|return
name|ENXIO
return|;
name|bcopy
argument_list|(
name|data
argument_list|,
name|font_16
argument_list|,
literal|16
operator|*
literal|256
argument_list|)
expr_stmt|;
name|fonts_loaded
operator||=
name|FONT_16
expr_stmt|;
comment|/* 	 * FONT KLUDGE 	 * Always use the font page #0. XXX 	 * Don't load if the current font size is not 8x16. 	 */
if|if
condition|(
name|ISTEXTSC
argument_list|(
name|cur_console
argument_list|)
operator|&&
operator|(
name|cur_console
operator|->
name|font_size
operator|>=
literal|16
operator|)
condition|)
name|copy_font
argument_list|(
name|cur_console
argument_list|,
name|LOAD
argument_list|,
literal|16
argument_list|,
name|font_16
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|GIO_FONT8x16
case|:
comment|/* get 8x16 dot font */
if|if
condition|(
operator|!
name|ISFONTAVAIL
argument_list|(
name|get_adapter
argument_list|(
name|scp
argument_list|)
operator|->
name|va_flags
argument_list|)
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
name|fonts_loaded
operator|&
name|FONT_16
condition|)
block|{
name|bcopy
argument_list|(
name|font_16
argument_list|,
name|data
argument_list|,
literal|16
operator|*
literal|256
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
name|ENXIO
return|;
default|default:
break|break;
block|}
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_ioctl
operator|)
operator|(
name|tp
operator|,
name|cmd
operator|,
name|data
operator|,
name|flag
operator|,
name|p
operator|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOIOCTL
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|ttioctl
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOIOCTL
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|scstart
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|clist
modifier|*
name|rbp
decl_stmt|;
name|int
name|s
decl_stmt|,
name|len
decl_stmt|;
name|u_char
name|buf
index|[
name|PCBURST
index|]
decl_stmt|;
name|scr_stat
modifier|*
name|scp
init|=
name|sc_get_scr_stat
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|SLKED
operator|||
name|blink_in_progress
condition|)
return|return;
comment|/* XXX who repeats the call when the above flags are cleared? */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_TIMEOUT
operator||
name|TS_BUSY
operator||
name|TS_TTSTOP
operator|)
operator|)
condition|)
block|{
name|tp
operator|->
name|t_state
operator||=
name|TS_BUSY
expr_stmt|;
name|rbp
operator|=
operator|&
name|tp
operator|->
name|t_outq
expr_stmt|;
while|while
condition|(
name|rbp
operator|->
name|c_cc
condition|)
block|{
name|len
operator|=
name|q_to_b
argument_list|(
name|rbp
argument_list|,
name|buf
argument_list|,
name|PCBURST
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ansi_put
argument_list|(
name|scp
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
block|}
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
name|ttwwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|scmousestart
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|clist
modifier|*
name|rbp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|u_char
name|buf
index|[
name|PCBURST
index|]
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_TIMEOUT
operator||
name|TS_BUSY
operator||
name|TS_TTSTOP
operator|)
operator|)
condition|)
block|{
name|tp
operator|->
name|t_state
operator||=
name|TS_BUSY
expr_stmt|;
name|rbp
operator|=
operator|&
name|tp
operator|->
name|t_outq
expr_stmt|;
while|while
condition|(
name|rbp
operator|->
name|c_cc
condition|)
block|{
name|q_to_b
argument_list|(
name|rbp
argument_list|,
name|buf
argument_list|,
name|PCBURST
argument_list|)
expr_stmt|;
block|}
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
name|ttwwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sccnprobe
parameter_list|(
name|struct
name|consdev
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|isa_device
modifier|*
name|dvp
decl_stmt|;
comment|/*      * Take control if we are the highest priority enabled display device.      */
name|dvp
operator|=
name|find_display
argument_list|()
expr_stmt|;
if|if
condition|(
name|dvp
operator|==
name|NULL
operator|||
name|dvp
operator|->
name|id_driver
operator|!=
operator|&
name|scdriver
condition|)
block|{
name|cp
operator|->
name|cn_pri
operator|=
name|CN_DEAD
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|scvidprobe
argument_list|(
name|dvp
operator|->
name|id_unit
argument_list|,
name|dvp
operator|->
name|id_flags
argument_list|)
condition|)
block|{
name|cp
operator|->
name|cn_pri
operator|=
name|CN_DEAD
expr_stmt|;
return|return;
block|}
comment|/* initialize required fields */
name|cp
operator|->
name|cn_dev
operator|=
name|makedev
argument_list|(
name|CDEV_MAJOR
argument_list|,
name|SC_CONSOLE
argument_list|)
expr_stmt|;
name|cp
operator|->
name|cn_pri
operator|=
name|CN_INTERNAL
expr_stmt|;
name|sc_kbdc
operator|=
name|kbdc_open
argument_list|(
name|sc_port
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sccninit
parameter_list|(
name|struct
name|consdev
modifier|*
name|cp
parameter_list|)
block|{
name|scinit
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sccnputc
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|c
parameter_list|)
block|{
name|u_char
name|buf
index|[
literal|1
index|]
decl_stmt|;
name|int
name|s
decl_stmt|;
name|scr_stat
modifier|*
name|scp
init|=
name|console
index|[
literal|0
index|]
decl_stmt|;
name|term_stat
name|save
init|=
name|scp
operator|->
name|term
decl_stmt|;
name|scp
operator|->
name|term
operator|=
name|kernel_console
expr_stmt|;
name|current_default
operator|=
operator|&
name|kernel_default
expr_stmt|;
if|if
condition|(
name|scp
operator|==
name|cur_console
operator|&&
operator|!
name|ISGRAPHSC
argument_list|(
name|scp
argument_list|)
condition|)
name|remove_cursor_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|ansi_put
argument_list|(
name|scp
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|kernel_console
operator|=
name|scp
operator|->
name|term
expr_stmt|;
name|current_default
operator|=
operator|&
name|user_default
expr_stmt|;
name|scp
operator|->
name|term
operator|=
name|save
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* block scintr and scrn_timer */
name|sccnupdate
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sccngetc
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
name|int
name|s
init|=
name|spltty
argument_list|()
decl_stmt|;
comment|/* block scintr and scrn_timer while we poll */
name|int
name|c
decl_stmt|;
comment|/*       * Stop the screen saver and update the screen if necessary.      * What if we have been running in the screen saver code... XXX      */
name|scsplash_stick
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|run_scrn_saver
operator|=
name|FALSE
expr_stmt|;
name|sccnupdate
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
name|c
operator|=
name|scgetc
argument_list|(
name|SCGETC_CN
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sccncheckc
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
name|int
name|s
init|=
name|spltty
argument_list|()
decl_stmt|;
comment|/* block scintr and scrn_timer while we poll */
name|int
name|c
decl_stmt|;
name|scsplash_stick
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|run_scrn_saver
operator|=
name|FALSE
expr_stmt|;
name|sccnupdate
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
name|c
operator|=
name|scgetc
argument_list|(
name|SCGETC_CN
operator||
name|SCGETC_NONBLOCK
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|==
name|NOKEY
condition|?
operator|-
literal|1
else|:
name|c
operator|)
return|;
comment|/* c == -1 can't happen */
block|}
end_function

begin_function
specifier|static
name|void
name|sccnupdate
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
comment|/* this is a cut-down version of scrn_timer()... */
if|if
condition|(
name|font_loading_in_progress
condition|)
return|return;
if|if
condition|(
name|panicstr
operator|||
name|shutdown_in_progress
condition|)
block|{
name|scsplash_stick
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|run_scrn_saver
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scp
operator|!=
name|cur_console
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
name|run_scrn_saver
condition|)
name|scrn_idle
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|saver_mode
operator|!=
name|CONS_LKM_SAVER
operator|)
operator|||
operator|!
name|scrn_idle
condition|)
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|SAVER_RUNNING
condition|)
name|stop_scrn_saver
argument_list|(
name|current_saver
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|!=
name|cur_console
operator|||
name|blink_in_progress
operator|||
name|switch_in_progress
condition|)
return|return;
if|if
condition|(
operator|!
name|ISGRAPHSC
argument_list|(
name|scp
argument_list|)
operator|&&
operator|!
operator|(
name|scp
operator|->
name|status
operator|&
name|SAVER_RUNNING
operator|)
condition|)
name|scrn_update
argument_list|(
name|scp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|scr_stat
modifier|*
name|sc_get_scr_stat
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
name|int
name|unit
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|unit
operator|==
name|SC_CONSOLE
condition|)
return|return
name|console
index|[
literal|0
index|]
return|;
if|if
condition|(
name|unit
operator|>=
name|MAXCONS
operator|||
name|unit
operator|<
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
name|console
index|[
name|unit
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_scr_num
parameter_list|()
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|i
operator|<
name|MAXCONS
operator|)
operator|&&
operator|(
name|cur_console
operator|!=
name|console
index|[
name|i
index|]
operator|)
condition|)
name|i
operator|++
expr_stmt|;
return|return
name|i
operator|<
name|MAXCONS
condition|?
name|i
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|scrn_timer
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|scr_stat
modifier|*
name|scp
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* don't do anything when we are touching font */
if|if
condition|(
name|font_loading_in_progress
condition|)
block|{
if|if
condition|(
name|arg
condition|)
name|timeout
argument_list|(
name|scrn_timer
argument_list|,
operator|(
name|void
operator|*
operator|)
name|TRUE
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
return|return;
block|}
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/*       * With release 2.1 of the Xaccel server, the keyboard is left      * hanging pretty often. Apparently an interrupt from the      * keyboard is lost, and I don't know why (yet).      * This ugly hack calls scintr if input is ready for the keyboard      * and conveniently hides the problem.			XXX      */
comment|/* Try removing anything stuck in the keyboard controller; whether      * it's a keyboard scan code or mouse data. `scintr()' doesn't      * read the mouse data directly, but `kbdio' routines will, as a      * side effect.      */
if|if
condition|(
name|kbdc_lock
argument_list|(
name|sc_kbdc
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
comment|/* 	 * We have seen the lock flag is not set. Let's reset the flag early; 	 * otherwise `update_led()' failes which may want the lock  	 * during `scintr()'. 	 */
name|kbdc_lock
argument_list|(
name|sc_kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|kbdc_data_ready
argument_list|(
name|sc_kbdc
argument_list|)
condition|)
name|scintr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|scp
operator|=
name|cur_console
expr_stmt|;
comment|/* should we stop the screen saver? */
name|getmicrouptime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
if|if
condition|(
name|panicstr
operator|||
name|shutdown_in_progress
condition|)
block|{
name|scsplash_stick
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|run_scrn_saver
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|run_scrn_saver
condition|)
block|{
name|scrn_idle
operator|=
operator|(
name|tv
operator|.
name|tv_sec
operator|>
name|scrn_time_stamp
operator|+
name|scrn_blank_time
operator|)
expr_stmt|;
block|}
else|else
block|{
name|scrn_time_stamp
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
name|scrn_idle
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|scrn_blank_time
operator|>
literal|0
condition|)
name|run_scrn_saver
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|saver_mode
operator|!=
name|CONS_LKM_SAVER
operator|)
operator|||
operator|!
name|scrn_idle
condition|)
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|SAVER_RUNNING
condition|)
name|stop_scrn_saver
argument_list|(
name|current_saver
argument_list|)
expr_stmt|;
comment|/* should we just return ? */
if|if
condition|(
name|blink_in_progress
operator|||
name|switch_in_progress
condition|)
block|{
if|if
condition|(
name|arg
condition|)
name|timeout
argument_list|(
name|scrn_timer
argument_list|,
operator|(
name|void
operator|*
operator|)
name|TRUE
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Update the screen */
if|if
condition|(
operator|!
name|ISGRAPHSC
argument_list|(
name|scp
argument_list|)
operator|&&
operator|!
operator|(
name|scp
operator|->
name|status
operator|&
name|SAVER_RUNNING
operator|)
condition|)
name|scrn_update
argument_list|(
name|scp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* should we activate the screen saver? */
if|if
condition|(
operator|(
name|saver_mode
operator|==
name|CONS_LKM_SAVER
operator|)
operator|&&
name|scrn_idle
condition|)
if|if
condition|(
operator|!
name|ISGRAPHSC
argument_list|(
name|scp
argument_list|)
operator|||
operator|(
name|scp
operator|->
name|status
operator|&
name|SAVER_RUNNING
operator|)
condition|)
name|scrn_saver
argument_list|(
name|current_saver
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
condition|)
name|timeout
argument_list|(
name|scrn_timer
argument_list|,
operator|(
name|void
operator|*
operator|)
name|TRUE
argument_list|,
name|hz
operator|/
literal|25
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|scrn_update
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|show_cursor
parameter_list|)
block|{
comment|/* update screen image */
if|if
condition|(
name|scp
operator|->
name|start
operator|<=
name|scp
operator|->
name|end
condition|)
name|sc_bcopy
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|start
argument_list|,
name|scp
operator|->
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* we are not to show the cursor and the mouse pointer... */
if|if
condition|(
operator|!
name|show_cursor
condition|)
block|{
name|scp
operator|->
name|end
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|start
operator|=
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
operator|-
literal|1
expr_stmt|;
return|return;
block|}
comment|/* update "pseudo" mouse pointer image */
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_VISIBLE
condition|)
block|{
comment|/* did mouse move since last time ? */
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_MOVED
condition|)
block|{
comment|/* do we need to remove old mouse pointer image ? */
if|if
condition|(
name|scp
operator|->
name|mouse_cut_start
operator|!=
name|NULL
operator|||
operator|(
name|scp
operator|->
name|mouse_pos
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|<=
name|scp
operator|->
name|start
operator|||
operator|(
name|scp
operator|->
name|mouse_pos
operator|+
name|scp
operator|->
name|xsize
operator|+
literal|1
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|>=
name|scp
operator|->
name|end
condition|)
block|{
name|remove_mouse_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
name|scp
operator|->
name|status
operator|&=
operator|~
name|MOUSE_MOVED
expr_stmt|;
name|draw_mouse_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* mouse didn't move, has it been overwritten ? */
if|if
condition|(
operator|(
name|scp
operator|->
name|mouse_pos
operator|+
name|scp
operator|->
name|xsize
operator|+
literal|1
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|>=
name|scp
operator|->
name|start
operator|&&
operator|(
name|scp
operator|->
name|mouse_pos
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|<=
name|scp
operator|->
name|end
condition|)
block|{
name|draw_mouse_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* update cursor image */
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|CURSOR_ENABLED
condition|)
block|{
comment|/* did cursor move since last time ? */
if|if
condition|(
name|scp
operator|->
name|cursor_pos
operator|!=
name|scp
operator|->
name|cursor_oldpos
condition|)
block|{
comment|/* do we need to remove old cursor image ? */
if|if
condition|(
operator|(
name|scp
operator|->
name|cursor_oldpos
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|<
name|scp
operator|->
name|start
operator|||
operator|(
operator|(
name|scp
operator|->
name|cursor_oldpos
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|>
name|scp
operator|->
name|end
operator|)
condition|)
block|{
name|remove_cursor_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
name|scp
operator|->
name|cursor_oldpos
operator|=
name|scp
operator|->
name|cursor_pos
expr_stmt|;
name|draw_cursor_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* cursor didn't move, has it been overwritten ? */
if|if
condition|(
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
operator|>=
name|scp
operator|->
name|start
operator|&&
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
operator|<=
name|scp
operator|->
name|end
condition|)
block|{
name|draw_cursor_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* if its a blinking cursor, we may have to update it */
if|if
condition|(
name|flags
operator|&
name|BLINK_CURSOR
condition|)
name|draw_cursor_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
block|}
name|blinkrate
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|scp
operator|->
name|mouse_cut_start
operator|!=
name|NULL
condition|)
name|draw_cutmarking
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|scp
operator|->
name|end
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|start
operator|=
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|int
name|add_scrn_saver
parameter_list|(
name|void
function_decl|(
modifier|*
name|this_saver
function_decl|)
parameter_list|(
name|int
parameter_list|)
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SC_SPLASH_SCREEN
if|if
condition|(
name|current_saver
operator|==
name|scsplash
condition|)
block|{
name|scsplash_stick
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|stop_scrn_saver
argument_list|(
name|scsplash
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|current_saver
operator|!=
name|default_saver
condition|)
return|return
name|EBUSY
return|;
name|run_scrn_saver
operator|=
name|FALSE
expr_stmt|;
name|saver_mode
operator|=
name|CONS_LKM_SAVER
expr_stmt|;
name|current_saver
operator|=
name|this_saver
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|remove_scrn_saver
parameter_list|(
name|void
function_decl|(
modifier|*
name|this_saver
function_decl|)
parameter_list|(
name|int
parameter_list|)
parameter_list|)
block|{
if|if
condition|(
name|current_saver
operator|!=
name|this_saver
condition|)
return|return
name|EINVAL
return|;
comment|/*      * In order to prevent `current_saver' from being called by      * the timeout routine `scrn_timer()' while we manipulate       * the saver list, we shall set `current_saver' to `none_saver'       * before stopping the current saver, rather than blocking by `splXX()'.      */
name|current_saver
operator|=
name|none_saver
expr_stmt|;
if|if
condition|(
name|scrn_blanked
operator|>
literal|0
condition|)
name|stop_scrn_saver
argument_list|(
name|this_saver
argument_list|)
expr_stmt|;
if|if
condition|(
name|scrn_blanked
operator|>
literal|0
condition|)
return|return
name|EBUSY
return|;
comment|/* XXX */
name|current_saver
operator|=
name|default_saver
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|scrn_saver
parameter_list|(
name|void
function_decl|(
modifier|*
name|saver
function_decl|)
parameter_list|(
name|int
parameter_list|)
parameter_list|,
name|int
name|blank
parameter_list|)
block|{
specifier|static
name|int
name|busy
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|busy
condition|)
return|return;
name|busy
operator|=
name|TRUE
expr_stmt|;
call|(
modifier|*
name|saver
call|)
argument_list|(
name|blank
argument_list|)
expr_stmt|;
name|busy
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|stop_scrn_saver
parameter_list|(
name|void
function_decl|(
modifier|*
name|saver
function_decl|)
parameter_list|(
name|int
parameter_list|)
parameter_list|)
block|{
name|scrn_saver
argument_list|(
name|saver
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|run_scrn_saver
operator|=
name|FALSE
expr_stmt|;
comment|/* the screen saver may have chosen not to stop after all... */
if|if
condition|(
name|scrn_blanked
operator|>
literal|0
condition|)
return|return;
name|mark_all
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
if|if
condition|(
name|delayed_next_scr
condition|)
name|switch_scr
argument_list|(
name|cur_console
argument_list|,
name|delayed_next_scr
operator|-
literal|1
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|scrn_blanked
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|wait_scrn_saver_stop
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|scrn_blanked
operator|>
literal|0
condition|)
block|{
name|run_scrn_saver
operator|=
name|FALSE
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|scrn_blanked
argument_list|,
name|PZERO
operator||
name|PCATCH
argument_list|,
literal|"scrsav"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|run_scrn_saver
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ERESTART
condition|)
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
name|void
name|sc_clear_screen
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|move_crsr
argument_list|(
name|scp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|scp
operator|->
name|cursor_oldpos
operator|=
name|scp
operator|->
name|cursor_pos
expr_stmt|;
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
argument_list|)
expr_stmt|;
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|remove_cutmarking
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|switch_scr
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|u_int
name|next_scr
parameter_list|)
block|{
comment|/* delay switch if actively updating screen */
if|if
condition|(
name|scrn_blanked
operator|>
literal|0
operator|||
name|write_in_progress
operator|||
name|blink_in_progress
condition|)
block|{
name|scsplash_stick
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|run_scrn_saver
operator|=
name|FALSE
expr_stmt|;
name|delayed_next_scr
operator|=
name|next_scr
operator|+
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|switch_in_progress
operator|&&
operator|(
name|cur_console
operator|->
name|proc
operator|!=
name|pfind
argument_list|(
name|cur_console
operator|->
name|pid
argument_list|)
operator|)
condition|)
name|switch_in_progress
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|next_scr
operator|>=
name|MAXCONS
operator|||
name|switch_in_progress
operator|||
operator|(
name|cur_console
operator|->
name|smode
operator|.
name|mode
operator|==
name|VT_AUTO
operator|&&
name|ISGRAPHSC
argument_list|(
name|cur_console
argument_list|)
operator|)
condition|)
block|{
name|do_bell
argument_list|(
name|scp
argument_list|,
name|BELL_PITCH
argument_list|,
name|BELL_DURATION
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/* is the wanted virtual console open ? */
if|if
condition|(
name|next_scr
condition|)
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
name|VIRTUAL_TTY
argument_list|(
name|next_scr
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
condition|)
block|{
name|do_bell
argument_list|(
name|scp
argument_list|,
name|BELL_PITCH
argument_list|,
name|BELL_DURATION
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
block|}
name|switch_in_progress
operator|=
name|TRUE
expr_stmt|;
name|old_scp
operator|=
name|cur_console
expr_stmt|;
name|new_scp
operator|=
name|console
index|[
name|next_scr
index|]
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|new_scp
operator|->
name|smode
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_scp
operator|==
name|old_scp
condition|)
block|{
name|switch_in_progress
operator|=
name|FALSE
expr_stmt|;
name|delayed_next_scr
operator|=
name|FALSE
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* has controlling process died? */
if|if
condition|(
name|old_scp
operator|->
name|proc
operator|&&
operator|(
name|old_scp
operator|->
name|proc
operator|!=
name|pfind
argument_list|(
name|old_scp
operator|->
name|pid
argument_list|)
operator|)
condition|)
name|old_scp
operator|->
name|smode
operator|.
name|mode
operator|=
name|VT_AUTO
expr_stmt|;
if|if
condition|(
name|new_scp
operator|->
name|proc
operator|&&
operator|(
name|new_scp
operator|->
name|proc
operator|!=
name|pfind
argument_list|(
name|new_scp
operator|->
name|pid
argument_list|)
operator|)
condition|)
name|new_scp
operator|->
name|smode
operator|.
name|mode
operator|=
name|VT_AUTO
expr_stmt|;
comment|/* check the modes and switch appropriately */
if|if
condition|(
name|old_scp
operator|->
name|smode
operator|.
name|mode
operator|==
name|VT_PROCESS
condition|)
block|{
name|old_scp
operator|->
name|status
operator||=
name|SWITCH_WAIT_REL
expr_stmt|;
name|psignal
argument_list|(
name|old_scp
operator|->
name|proc
argument_list|,
name|old_scp
operator|->
name|smode
operator|.
name|relsig
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|exchange_scr
argument_list|()
expr_stmt|;
if|if
condition|(
name|new_scp
operator|->
name|smode
operator|.
name|mode
operator|==
name|VT_PROCESS
condition|)
block|{
name|new_scp
operator|->
name|status
operator||=
name|SWITCH_WAIT_ACQ
expr_stmt|;
name|psignal
argument_list|(
name|new_scp
operator|->
name|proc
argument_list|,
name|new_scp
operator|->
name|smode
operator|.
name|acqsig
argument_list|)
expr_stmt|;
block|}
else|else
name|switch_in_progress
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|exchange_scr
parameter_list|(
name|void
parameter_list|)
block|{
name|move_crsr
argument_list|(
name|old_scp
argument_list|,
name|old_scp
operator|->
name|xpos
argument_list|,
name|old_scp
operator|->
name|ypos
argument_list|)
expr_stmt|;
name|cur_console
operator|=
name|new_scp
expr_stmt|;
if|if
condition|(
name|old_scp
operator|->
name|mode
operator|!=
name|new_scp
operator|->
name|mode
operator|||
name|ISUNKNOWNSC
argument_list|(
name|old_scp
argument_list|)
condition|)
name|set_mode
argument_list|(
name|new_scp
argument_list|)
expr_stmt|;
name|move_crsr
argument_list|(
name|new_scp
argument_list|,
name|new_scp
operator|->
name|xpos
argument_list|,
name|new_scp
operator|->
name|ypos
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISTEXTSC
argument_list|(
name|new_scp
argument_list|)
operator|&&
operator|(
name|flags
operator|&
name|CHAR_CURSOR
operator|)
condition|)
name|set_destructive_cursor
argument_list|(
name|new_scp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISGRAPHSC
argument_list|(
name|old_scp
argument_list|)
condition|)
name|load_palette
argument_list|(
name|new_scp
argument_list|,
name|palette
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_scp
operator|->
name|status
operator|&
name|KBD_RAW_MODE
operator|||
name|new_scp
operator|->
name|status
operator|&
name|KBD_RAW_MODE
operator|||
name|old_scp
operator|->
name|status
operator|&
name|KBD_CODE_MODE
operator|||
name|new_scp
operator|->
name|status
operator|&
name|KBD_CODE_MODE
condition|)
name|shfts
operator|=
name|ctls
operator|=
name|alts
operator|=
name|agrs
operator|=
name|metas
operator|=
name|accents
operator|=
literal|0
expr_stmt|;
name|set_border
argument_list|(
name|new_scp
argument_list|,
name|new_scp
operator|->
name|border
argument_list|)
expr_stmt|;
name|update_leds
argument_list|(
name|new_scp
operator|->
name|status
argument_list|)
expr_stmt|;
name|delayed_next_scr
operator|=
name|FALSE
expr_stmt|;
name|mark_all
argument_list|(
name|new_scp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|scan_esc
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|u_char
name|c
parameter_list|)
block|{
specifier|static
name|u_char
name|ansi_col
index|[
literal|16
index|]
init|=
block|{
literal|0
block|,
literal|4
block|,
literal|2
block|,
literal|6
block|,
literal|1
block|,
literal|5
block|,
literal|3
block|,
literal|7
block|,
literal|8
block|,
literal|12
block|,
literal|10
block|,
literal|14
block|,
literal|9
block|,
literal|13
block|,
literal|11
block|,
literal|15
block|}
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|u_short
modifier|*
name|src
decl_stmt|,
modifier|*
name|dst
decl_stmt|,
name|count
decl_stmt|;
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|esc
operator|==
literal|1
condition|)
block|{
comment|/* seen ESC */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'7'
case|:
comment|/* Save cursor position */
name|scp
operator|->
name|saved_xpos
operator|=
name|scp
operator|->
name|xpos
expr_stmt|;
name|scp
operator|->
name|saved_ypos
operator|=
name|scp
operator|->
name|ypos
expr_stmt|;
break|break;
case|case
literal|'8'
case|:
comment|/* Restore saved cursor position */
if|if
condition|(
name|scp
operator|->
name|saved_xpos
operator|>=
literal|0
operator|&&
name|scp
operator|->
name|saved_ypos
operator|>=
literal|0
condition|)
name|move_crsr
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|saved_xpos
argument_list|,
name|scp
operator|->
name|saved_ypos
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'['
case|:
comment|/* Start ESC [ sequence */
name|scp
operator|->
name|term
operator|.
name|esc
operator|=
literal|2
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|last_param
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|scp
operator|->
name|term
operator|.
name|num_param
init|;
name|i
operator|<
name|MAX_ESC_PAR
condition|;
name|i
operator|++
control|)
name|scp
operator|->
name|term
operator|.
name|param
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|num_param
operator|=
literal|0
expr_stmt|;
return|return;
case|case
literal|'M'
case|:
comment|/* Move cursor up 1 line, scroll if at top */
if|if
condition|(
name|scp
operator|->
name|ypos
operator|>
literal|0
condition|)
name|move_crsr
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|xpos
argument_list|,
name|scp
operator|->
name|ypos
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|bcopy
argument_list|(
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|scr_buf
operator|+
name|scp
operator|->
name|xsize
argument_list|,
operator|(
name|scp
operator|->
name|ysize
operator|-
literal|1
operator|)
operator|*
name|scp
operator|->
name|xsize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
break|break;
if|#
directive|if
name|notyet
case|case
literal|'Q'
case|:
name|scp
operator|->
name|term
operator|.
name|esc
operator|=
literal|4
expr_stmt|;
return|return;
endif|#
directive|endif
case|case
literal|'c'
case|:
comment|/* Clear screen& home */
name|sc_clear_screen
argument_list|(
name|scp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'('
case|:
comment|/* iso-2022: designate 94 character set to G0 */
name|scp
operator|->
name|term
operator|.
name|esc
operator|=
literal|5
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|esc
operator|==
literal|2
condition|)
block|{
comment|/* seen ESC [ */
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|<
name|MAX_ESC_PAR
condition|)
block|{
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|last_param
operator|!=
name|scp
operator|->
name|term
operator|.
name|num_param
condition|)
block|{
name|scp
operator|->
name|term
operator|.
name|last_param
operator|=
name|scp
operator|->
name|term
operator|.
name|num_param
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|param
index|[
name|scp
operator|->
name|term
operator|.
name|num_param
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|scp
operator|->
name|term
operator|.
name|param
index|[
name|scp
operator|->
name|term
operator|.
name|num_param
index|]
operator|*=
literal|10
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|param
index|[
name|scp
operator|->
name|term
operator|.
name|num_param
index|]
operator|+=
name|c
operator|-
literal|'0'
expr_stmt|;
return|return;
block|}
block|}
name|scp
operator|->
name|term
operator|.
name|num_param
operator|=
name|scp
operator|->
name|term
operator|.
name|last_param
operator|+
literal|1
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|';'
case|:
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|<
name|MAX_ESC_PAR
condition|)
return|return;
break|break;
case|case
literal|'='
case|:
name|scp
operator|->
name|term
operator|.
name|esc
operator|=
literal|3
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|last_param
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|scp
operator|->
name|term
operator|.
name|num_param
init|;
name|i
operator|<
name|MAX_ESC_PAR
condition|;
name|i
operator|++
control|)
name|scp
operator|->
name|term
operator|.
name|param
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|num_param
operator|=
literal|0
expr_stmt|;
return|return;
case|case
literal|'A'
case|:
comment|/* up n rows */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|move_crsr
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|xpos
argument_list|,
name|scp
operator|->
name|ypos
operator|-
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
comment|/* down n rows */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|move_crsr
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|xpos
argument_list|,
name|scp
operator|->
name|ypos
operator|+
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* right n columns */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|move_crsr
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|xpos
operator|+
name|n
argument_list|,
name|scp
operator|->
name|ypos
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* left n columns */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|move_crsr
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|xpos
operator|-
name|n
argument_list|,
name|scp
operator|->
name|ypos
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
comment|/* cursor to start of line n lines down */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|move_crsr
argument_list|(
name|scp
argument_list|,
literal|0
argument_list|,
name|scp
operator|->
name|ypos
operator|+
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
comment|/* cursor to start of line n lines up */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|move_crsr
argument_list|(
name|scp
argument_list|,
literal|0
argument_list|,
name|scp
operator|->
name|ypos
operator|-
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* Cursor move */
case|case
literal|'H'
case|:
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|0
condition|)
name|move_crsr
argument_list|(
name|scp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|2
condition|)
name|move_crsr
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|1
index|]
operator|-
literal|1
argument_list|,
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'J'
case|:
comment|/* Clear all or part of display */
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|0
condition|)
name|n
operator|=
literal|0
expr_stmt|;
else|else
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|0
case|:
comment|/* clear form cursor to end of display */
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|cursor_pos
argument_list|,
name|scp
operator|->
name|scr_buf
operator|+
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
operator|-
name|scp
operator|->
name|cursor_pos
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
operator|-
literal|1
argument_list|)
expr_stmt|;
name|remove_cutmarking
argument_list|(
name|scp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* clear from beginning of display to cursor */
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|remove_cutmarking
argument_list|(
name|scp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* clear entire display */
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
argument_list|)
expr_stmt|;
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|remove_cutmarking
argument_list|(
name|scp
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'K'
case|:
comment|/* Clear all or part of line */
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|0
condition|)
name|n
operator|=
literal|0
expr_stmt|;
else|else
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|0
case|:
comment|/* clear form cursor to end of line */
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|cursor_pos
argument_list|,
name|scp
operator|->
name|xsize
operator|-
name|scp
operator|->
name|xpos
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
operator|+
name|scp
operator|->
name|xsize
operator|-
literal|1
operator|-
name|scp
operator|->
name|xpos
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* clear from beginning of line to cursor */
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|xpos
argument_list|,
name|scp
operator|->
name|xpos
operator|+
literal|1
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|ypos
operator|*
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* clear entire line */
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|xpos
argument_list|,
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|ypos
operator|*
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
operator|(
name|scp
operator|->
name|ypos
operator|+
literal|1
operator|)
operator|*
name|scp
operator|->
name|xsize
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'L'
case|:
comment|/* Insert n lines */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|scp
operator|->
name|ysize
operator|-
name|scp
operator|->
name|ypos
condition|)
name|n
operator|=
name|scp
operator|->
name|ysize
operator|-
name|scp
operator|->
name|ypos
expr_stmt|;
name|src
operator|=
name|scp
operator|->
name|scr_buf
operator|+
name|scp
operator|->
name|ypos
operator|*
name|scp
operator|->
name|xsize
expr_stmt|;
name|dst
operator|=
name|src
operator|+
name|n
operator|*
name|scp
operator|->
name|xsize
expr_stmt|;
name|count
operator|=
name|scp
operator|->
name|ysize
operator|-
operator|(
name|scp
operator|->
name|ypos
operator|+
name|n
operator|)
expr_stmt|;
name|bcopy
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|count
operator|*
name|scp
operator|->
name|xsize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|src
argument_list|,
name|n
operator|*
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|ypos
operator|*
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
comment|/* Delete n lines */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|scp
operator|->
name|ysize
operator|-
name|scp
operator|->
name|ypos
condition|)
name|n
operator|=
name|scp
operator|->
name|ysize
operator|-
name|scp
operator|->
name|ypos
expr_stmt|;
name|dst
operator|=
name|scp
operator|->
name|scr_buf
operator|+
name|scp
operator|->
name|ypos
operator|*
name|scp
operator|->
name|xsize
expr_stmt|;
name|src
operator|=
name|dst
operator|+
name|n
operator|*
name|scp
operator|->
name|xsize
expr_stmt|;
name|count
operator|=
name|scp
operator|->
name|ysize
operator|-
operator|(
name|scp
operator|->
name|ypos
operator|+
name|n
operator|)
expr_stmt|;
name|bcopy
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|count
operator|*
name|scp
operator|->
name|xsize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|=
name|dst
operator|+
name|count
operator|*
name|scp
operator|->
name|xsize
expr_stmt|;
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|src
argument_list|,
name|n
operator|*
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|ypos
operator|*
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
comment|/* Delete n chars */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|scp
operator|->
name|xsize
operator|-
name|scp
operator|->
name|xpos
condition|)
name|n
operator|=
name|scp
operator|->
name|xsize
operator|-
name|scp
operator|->
name|xpos
expr_stmt|;
name|dst
operator|=
name|scp
operator|->
name|cursor_pos
expr_stmt|;
name|src
operator|=
name|dst
operator|+
name|n
expr_stmt|;
name|count
operator|=
name|scp
operator|->
name|xsize
operator|-
operator|(
name|scp
operator|->
name|xpos
operator|+
name|n
operator|)
expr_stmt|;
name|bcopy
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|=
name|dst
operator|+
name|count
expr_stmt|;
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|src
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
operator|+
name|n
operator|+
name|count
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'@'
case|:
comment|/* Insert n chars */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|scp
operator|->
name|xsize
operator|-
name|scp
operator|->
name|xpos
condition|)
name|n
operator|=
name|scp
operator|->
name|xsize
operator|-
name|scp
operator|->
name|xpos
expr_stmt|;
name|src
operator|=
name|scp
operator|->
name|cursor_pos
expr_stmt|;
name|dst
operator|=
name|src
operator|+
name|n
expr_stmt|;
name|count
operator|=
name|scp
operator|->
name|xsize
operator|-
operator|(
name|scp
operator|->
name|xpos
operator|+
name|n
operator|)
expr_stmt|;
name|bcopy
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|src
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
operator|+
name|n
operator|+
name|count
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* scroll up n lines */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|scp
operator|->
name|ysize
condition|)
name|n
operator|=
name|scp
operator|->
name|ysize
expr_stmt|;
name|bcopy
argument_list|(
name|scp
operator|->
name|scr_buf
operator|+
operator|(
name|scp
operator|->
name|xsize
operator|*
name|n
operator|)
argument_list|,
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|xsize
operator|*
operator|(
name|scp
operator|->
name|ysize
operator|-
name|n
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|scr_buf
operator|+
name|scp
operator|->
name|xsize
operator|*
operator|(
name|scp
operator|->
name|ysize
operator|-
name|n
operator|)
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|n
argument_list|)
expr_stmt|;
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
comment|/* scroll down n lines */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|scp
operator|->
name|ysize
condition|)
name|n
operator|=
name|scp
operator|->
name|ysize
expr_stmt|;
name|bcopy
argument_list|(
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|scr_buf
operator|+
operator|(
name|scp
operator|->
name|xsize
operator|*
name|n
operator|)
argument_list|,
name|scp
operator|->
name|xsize
operator|*
operator|(
name|scp
operator|->
name|ysize
operator|-
name|n
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|n
argument_list|)
expr_stmt|;
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
comment|/* erase n characters in line */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|scp
operator|->
name|xsize
operator|-
name|scp
operator|->
name|xpos
condition|)
name|n
operator|=
name|scp
operator|->
name|xsize
operator|-
name|scp
operator|->
name|xpos
expr_stmt|;
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|cursor_pos
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
operator|+
name|n
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
comment|/* move n tabs backwards */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|scp
operator|->
name|xpos
operator|&
literal|0xf8
operator|)
operator|==
name|scp
operator|->
name|xpos
condition|)
name|i
operator|-=
literal|8
operator|*
name|n
expr_stmt|;
else|else
name|i
operator|-=
literal|8
operator|*
operator|(
name|n
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|i
operator|=
literal|0
expr_stmt|;
name|move_crsr
argument_list|(
name|scp
argument_list|,
name|i
argument_list|,
name|scp
operator|->
name|ypos
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'`'
case|:
comment|/* move cursor to column n */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|move_crsr
argument_list|(
name|scp
argument_list|,
name|n
operator|-
literal|1
argument_list|,
name|scp
operator|->
name|ypos
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
comment|/* move cursor n columns to the right */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|move_crsr
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|xpos
operator|+
name|n
argument_list|,
name|scp
operator|->
name|ypos
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* move cursor to row n */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|move_crsr
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|xpos
argument_list|,
name|n
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* move cursor n rows down */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|move_crsr
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|xpos
argument_list|,
name|scp
operator|->
name|ypos
operator|+
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* change attribute */
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|0
condition|)
block|{
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator|=
name|NORMAL_ATTR
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|scp
operator|->
name|term
operator|.
name|cur_color
operator|=
name|scp
operator|->
name|term
operator|.
name|std_color
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|scp
operator|->
name|term
operator|.
name|num_param
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
name|i
index|]
condition|)
block|{
case|case
literal|0
case|:
comment|/* back to normal */
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator|=
name|NORMAL_ATTR
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|scp
operator|->
name|term
operator|.
name|cur_color
operator|=
name|scp
operator|->
name|term
operator|.
name|std_color
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* bold */
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator||=
name|BOLD_ATTR
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* underline */
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator||=
name|UNDERLINE_ATTR
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* blink */
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator||=
name|BLINK_ATTR
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|/* reverse video */
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator||=
name|REVERSE_ATTR
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
break|break;
case|case
literal|30
case|:
case|case
literal|31
case|:
comment|/* set fg color */
case|case
literal|32
case|:
case|case
literal|33
case|:
case|case
literal|34
case|:
case|case
literal|35
case|:
case|case
literal|36
case|:
case|case
literal|37
case|:
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator||=
name|FOREGROUND_CHANGED
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_color
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator|&
literal|0xF000
operator|)
operator||
operator|(
name|ansi_col
index|[
operator|(
name|n
operator|-
literal|30
operator|)
operator|&
literal|7
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
break|break;
case|case
literal|40
case|:
case|case
literal|41
case|:
comment|/* set bg color */
case|case
literal|42
case|:
case|case
literal|43
case|:
case|case
literal|44
case|:
case|case
literal|45
case|:
case|case
literal|46
case|:
case|case
literal|47
case|:
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator||=
name|BACKGROUND_CHANGED
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_color
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator|&
literal|0x0F00
operator|)
operator||
operator|(
name|ansi_col
index|[
operator|(
name|n
operator|-
literal|40
operator|)
operator|&
literal|7
index|]
operator|<<
literal|12
operator|)
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
literal|'s'
case|:
comment|/* Save cursor position */
name|scp
operator|->
name|saved_xpos
operator|=
name|scp
operator|->
name|xpos
expr_stmt|;
name|scp
operator|->
name|saved_ypos
operator|=
name|scp
operator|->
name|ypos
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
comment|/* Restore saved cursor position */
if|if
condition|(
name|scp
operator|->
name|saved_xpos
operator|>=
literal|0
operator|&&
name|scp
operator|->
name|saved_ypos
operator|>=
literal|0
condition|)
name|move_crsr
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|saved_xpos
argument_list|,
name|scp
operator|->
name|saved_ypos
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|0
condition|)
name|n
operator|=
literal|0
expr_stmt|;
else|else
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|0
case|:
comment|/* reset attributes */
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator|=
name|NORMAL_ATTR
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|scp
operator|->
name|term
operator|.
name|cur_color
operator|=
name|scp
operator|->
name|term
operator|.
name|std_color
operator|=
name|current_default
operator|->
name|std_color
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|rev_color
operator|=
name|current_default
operator|->
name|rev_color
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* set ansi background */
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator|&=
operator|~
name|BACKGROUND_CHANGED
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_color
operator|=
name|scp
operator|->
name|term
operator|.
name|std_color
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|std_color
operator|&
literal|0x0F00
operator|)
operator||
operator|(
name|ansi_col
index|[
operator|(
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|1
index|]
operator|)
operator|&
literal|0x0F
index|]
operator|<<
literal|12
operator|)
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* set ansi foreground */
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator|&=
operator|~
name|FOREGROUND_CHANGED
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_color
operator|=
name|scp
operator|->
name|term
operator|.
name|std_color
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|std_color
operator|&
literal|0xF000
operator|)
operator||
operator|(
name|ansi_col
index|[
operator|(
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|1
index|]
operator|)
operator|&
literal|0x0F
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* set ansi attribute directly */
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator|&=
operator|~
operator|(
name|FOREGROUND_CHANGED
operator||
name|BACKGROUND_CHANGED
operator|)
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_color
operator|=
name|scp
operator|->
name|term
operator|.
name|std_color
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|1
index|]
operator|&
literal|0xFF
operator|)
operator|<<
literal|8
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* set ansi reverse video background */
name|scp
operator|->
name|term
operator|.
name|rev_color
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|rev_color
operator|&
literal|0x0F00
operator|)
operator||
operator|(
name|ansi_col
index|[
operator|(
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|1
index|]
operator|)
operator|&
literal|0x0F
index|]
operator|<<
literal|12
operator|)
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
comment|/* set ansi reverse video foreground */
name|scp
operator|->
name|term
operator|.
name|rev_color
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|rev_color
operator|&
literal|0xF000
operator|)
operator||
operator|(
name|ansi_col
index|[
operator|(
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|1
index|]
operator|)
operator|&
literal|0x0F
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|/* set ansi reverse video directly */
name|scp
operator|->
name|term
operator|.
name|rev_color
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|1
index|]
operator|&
literal|0xFF
operator|)
operator|<<
literal|8
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'z'
case|:
comment|/* switch to (virtual) console n */
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|1
condition|)
name|switch_scr
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|esc
operator|==
literal|3
condition|)
block|{
comment|/* seen ESC [0-9]+ = */
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|<
name|MAX_ESC_PAR
condition|)
block|{
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|last_param
operator|!=
name|scp
operator|->
name|term
operator|.
name|num_param
condition|)
block|{
name|scp
operator|->
name|term
operator|.
name|last_param
operator|=
name|scp
operator|->
name|term
operator|.
name|num_param
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|param
index|[
name|scp
operator|->
name|term
operator|.
name|num_param
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|scp
operator|->
name|term
operator|.
name|param
index|[
name|scp
operator|->
name|term
operator|.
name|num_param
index|]
operator|*=
literal|10
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|param
index|[
name|scp
operator|->
name|term
operator|.
name|num_param
index|]
operator|+=
name|c
operator|-
literal|'0'
expr_stmt|;
return|return;
block|}
block|}
name|scp
operator|->
name|term
operator|.
name|num_param
operator|=
name|scp
operator|->
name|term
operator|.
name|last_param
operator|+
literal|1
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|';'
case|:
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|<
name|MAX_ESC_PAR
condition|)
return|return;
break|break;
case|case
literal|'A'
case|:
comment|/* set display border color */
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|1
condition|)
block|{
name|scp
operator|->
name|border
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|scp
operator|==
name|cur_console
condition|)
name|set_border
argument_list|(
name|cur_console
argument_list|,
name|scp
operator|->
name|border
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'B'
case|:
comment|/* set bell pitch and duration */
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|2
condition|)
block|{
name|scp
operator|->
name|bell_pitch
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
name|scp
operator|->
name|bell_duration
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|1
index|]
expr_stmt|;
block|}
break|break;
case|case
literal|'C'
case|:
comment|/* set cursor type& shape */
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
operator|&
literal|0x01
condition|)
name|flags
operator||=
name|BLINK_CURSOR
expr_stmt|;
else|else
name|flags
operator|&=
operator|~
name|BLINK_CURSOR
expr_stmt|;
if|if
condition|(
operator|(
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
operator|&
literal|0x02
operator|)
operator|&&
name|ISFONTAVAIL
argument_list|(
name|get_adapter
argument_list|(
name|scp
argument_list|)
operator|->
name|va_flags
argument_list|)
condition|)
name|flags
operator||=
name|CHAR_CURSOR
expr_stmt|;
else|else
name|flags
operator|&=
operator|~
name|CHAR_CURSOR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|2
condition|)
block|{
name|scp
operator|->
name|cursor_start
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
operator|&
literal|0x1F
expr_stmt|;
name|scp
operator|->
name|cursor_end
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|1
index|]
operator|&
literal|0x1F
expr_stmt|;
block|}
comment|/*  	     * The cursor shape is global property; all virtual consoles 	     * are affected. Update the cursor in the current console... 	     */
if|if
condition|(
operator|!
name|ISGRAPHSC
argument_list|(
name|cur_console
argument_list|)
condition|)
block|{
name|remove_cursor_image
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|CHAR_CURSOR
condition|)
name|set_destructive_cursor
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
name|draw_cursor_image
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'F'
case|:
comment|/* set ansi foreground */
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|1
condition|)
block|{
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator|&=
operator|~
name|FOREGROUND_CHANGED
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_color
operator|=
name|scp
operator|->
name|term
operator|.
name|std_color
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|std_color
operator|&
literal|0xF000
operator|)
operator||
operator|(
operator|(
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
operator|&
literal|0x0F
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'G'
case|:
comment|/* set ansi background */
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|1
condition|)
block|{
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator|&=
operator|~
name|BACKGROUND_CHANGED
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_color
operator|=
name|scp
operator|->
name|term
operator|.
name|std_color
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|std_color
operator|&
literal|0x0F00
operator|)
operator||
operator|(
operator|(
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
operator|&
literal|0x0F
operator|)
operator|<<
literal|12
operator|)
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'H'
case|:
comment|/* set ansi reverse video foreground */
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|1
condition|)
block|{
name|scp
operator|->
name|term
operator|.
name|rev_color
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|rev_color
operator|&
literal|0xF000
operator|)
operator||
operator|(
operator|(
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
operator|&
literal|0x0F
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'I'
case|:
comment|/* set ansi reverse video background */
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|1
condition|)
block|{
name|scp
operator|->
name|term
operator|.
name|rev_color
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|rev_color
operator|&
literal|0x0F00
operator|)
operator||
operator|(
operator|(
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
operator|&
literal|0x0F
operator|)
operator|<<
literal|12
operator|)
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
if|#
directive|if
name|notyet
elseif|else
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|esc
operator|==
literal|4
condition|)
block|{
comment|/* seen ESC Q */
comment|/* to be filled */
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|esc
operator|==
literal|5
condition|)
block|{
comment|/* seen ESC ( */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'B'
case|:
comment|/* iso-2022: desginate ASCII into G0 */
break|break;
comment|/* other items to be filled */
default|default:
break|break;
block|}
block|}
name|scp
operator|->
name|term
operator|.
name|esc
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ansi_put
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|u_char
modifier|*
name|ptr
init|=
name|buf
decl_stmt|;
comment|/* make screensaver happy */
if|if
condition|(
operator|!
name|sticky_splash
operator|&&
name|scp
operator|==
name|cur_console
condition|)
name|run_scrn_saver
operator|=
name|FALSE
expr_stmt|;
name|write_in_progress
operator|++
expr_stmt|;
name|outloop
label|:
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|esc
condition|)
block|{
name|scan_esc
argument_list|(
name|scp
argument_list|,
operator|*
name|ptr
operator|++
argument_list|)
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PRINTABLE
argument_list|(
operator|*
name|ptr
argument_list|)
condition|)
block|{
comment|/* Print only printables */
name|int
name|cnt
init|=
name|len
operator|<=
operator|(
name|scp
operator|->
name|xsize
operator|-
name|scp
operator|->
name|xpos
operator|)
condition|?
name|len
else|:
operator|(
name|scp
operator|->
name|xsize
operator|-
name|scp
operator|->
name|xpos
operator|)
decl_stmt|;
name|u_short
name|cur_attr
init|=
name|scp
operator|->
name|term
operator|.
name|cur_attr
decl_stmt|;
name|u_short
modifier|*
name|cursor_pos
init|=
name|scp
operator|->
name|cursor_pos
decl_stmt|;
do|do
block|{
comment|/* 	     * gcc-2.6.3 generates poor (un)sign extension code.  Casting the 	     * pointers in the following to volatile should have no effect, 	     * but in fact speeds up this inner loop from 26 to 18 cycles 	     * (+ cache misses) on i486's. 	     */
define|#
directive|define
name|UCVP
parameter_list|(
name|ucp
parameter_list|)
value|((u_char volatile *)(ucp))
operator|*
name|cursor_pos
operator|++
operator|=
name|UCVP
argument_list|(
name|scr_map
argument_list|)
index|[
operator|*
name|UCVP
argument_list|(
name|ptr
argument_list|)
index|]
operator||
name|cur_attr
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
name|cnt
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|cnt
operator|&&
name|PRINTABLE
argument_list|(
operator|*
name|ptr
argument_list|)
condition|)
do|;
name|len
operator|-=
operator|(
name|cursor_pos
operator|-
name|scp
operator|->
name|cursor_pos
operator|)
expr_stmt|;
name|scp
operator|->
name|xpos
operator|+=
operator|(
name|cursor_pos
operator|-
name|scp
operator|->
name|cursor_pos
operator|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|scp
operator|->
name|cursor_pos
operator|=
name|cursor_pos
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|xpos
operator|>=
name|scp
operator|->
name|xsize
condition|)
block|{
name|scp
operator|->
name|xpos
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|ypos
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
operator|*
name|ptr
condition|)
block|{
case|case
literal|0x07
case|:
name|do_bell
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|bell_pitch
argument_list|,
name|scp
operator|->
name|bell_duration
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x08
case|:
comment|/* non-destructive backspace */
if|if
condition|(
name|scp
operator|->
name|cursor_pos
operator|>
name|scp
operator|->
name|scr_buf
condition|)
block|{
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|scp
operator|->
name|cursor_pos
operator|--
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|xpos
operator|>
literal|0
condition|)
name|scp
operator|->
name|xpos
operator|--
expr_stmt|;
else|else
block|{
name|scp
operator|->
name|xpos
operator|+=
name|scp
operator|->
name|xsize
operator|-
literal|1
expr_stmt|;
name|scp
operator|->
name|ypos
operator|--
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|0x09
case|:
comment|/* non-destructive tab */
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|scp
operator|->
name|cursor_pos
operator|+=
operator|(
literal|8
operator|-
name|scp
operator|->
name|xpos
operator|%
literal|8u
operator|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scp
operator|->
name|xpos
operator|+=
operator|(
literal|8
operator|-
name|scp
operator|->
name|xpos
operator|%
literal|8u
operator|)
operator|)
operator|>=
name|scp
operator|->
name|xsize
condition|)
block|{
name|scp
operator|->
name|xpos
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|ypos
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|0x0a
case|:
comment|/* newline, same pos */
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|scp
operator|->
name|cursor_pos
operator|+=
name|scp
operator|->
name|xsize
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|scp
operator|->
name|ypos
operator|++
expr_stmt|;
break|break;
case|case
literal|0x0c
case|:
comment|/* form feed, clears screen */
name|sc_clear_screen
argument_list|(
name|scp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x0d
case|:
comment|/* return, return to pos 0 */
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|scp
operator|->
name|cursor_pos
operator|-=
name|scp
operator|->
name|xpos
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|scp
operator|->
name|xpos
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|0x1b
case|:
comment|/* start escape sequence */
name|scp
operator|->
name|term
operator|.
name|esc
operator|=
literal|1
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|num_param
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|ptr
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
comment|/* do we have to scroll ?? */
if|if
condition|(
name|scp
operator|->
name|cursor_pos
operator|>=
name|scp
operator|->
name|scr_buf
operator|+
name|scp
operator|->
name|ysize
operator|*
name|scp
operator|->
name|xsize
condition|)
block|{
name|remove_cutmarking
argument_list|(
name|scp
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|history
operator|!=
name|NULL
condition|)
block|{
name|bcopy
argument_list|(
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|history_head
argument_list|,
name|scp
operator|->
name|xsize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|scp
operator|->
name|history_head
operator|+=
name|scp
operator|->
name|xsize
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|history_head
operator|+
name|scp
operator|->
name|xsize
operator|>
name|scp
operator|->
name|history
operator|+
name|scp
operator|->
name|history_size
condition|)
name|scp
operator|->
name|history_head
operator|=
name|scp
operator|->
name|history
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|scp
operator|->
name|scr_buf
operator|+
name|scp
operator|->
name|xsize
argument_list|,
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|xsize
operator|*
operator|(
name|scp
operator|->
name|ysize
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|scr_buf
operator|+
name|scp
operator|->
name|xsize
operator|*
operator|(
name|scp
operator|->
name|ysize
operator|-
literal|1
operator|)
argument_list|,
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
name|scp
operator|->
name|cursor_pos
operator|-=
name|scp
operator|->
name|xsize
expr_stmt|;
name|scp
operator|->
name|ypos
operator|--
expr_stmt|;
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
condition|)
goto|goto
name|outloop
goto|;
name|write_in_progress
operator|--
expr_stmt|;
if|if
condition|(
name|delayed_next_scr
condition|)
name|switch_scr
argument_list|(
name|scp
argument_list|,
name|delayed_next_scr
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|scinit
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|col
decl_stmt|;
name|int
name|row
decl_stmt|;
name|u_int
name|i
decl_stmt|;
if|if
condition|(
name|init_done
operator|!=
name|COLD
condition|)
return|return;
name|init_done
operator|=
name|WARM
expr_stmt|;
comment|/* extract the hardware cursor location and move it out of the way */
call|(
modifier|*
name|biosvidsw
operator|.
name|read_hw_cursor
call|)
argument_list|(
name|V_ADP_PRIMARY
argument_list|,
operator|&
name|col
argument_list|,
operator|&
name|row
argument_list|)
expr_stmt|;
call|(
modifier|*
name|biosvidsw
operator|.
name|set_hw_cursor
call|)
argument_list|(
name|V_ADP_PRIMARY
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* set up the first console */
name|current_default
operator|=
operator|&
name|user_default
expr_stmt|;
name|console
index|[
literal|0
index|]
operator|=
operator|&
name|main_console
expr_stmt|;
name|init_scp
argument_list|(
name|console
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|cur_console
operator|=
name|console
index|[
literal|0
index|]
expr_stmt|;
comment|/* copy screen to temporary buffer */
if|if
condition|(
name|ISTEXTSC
argument_list|(
name|console
index|[
literal|0
index|]
argument_list|)
condition|)
name|generic_bcopy
argument_list|(
operator|(
name|ushort
operator|*
operator|)
operator|(
name|get_adapter
argument_list|(
name|console
index|[
literal|0
index|]
argument_list|)
operator|->
name|va_window
operator|)
argument_list|,
name|sc_buffer
argument_list|,
name|console
index|[
literal|0
index|]
operator|->
name|xsize
operator|*
name|console
index|[
literal|0
index|]
operator|->
name|ysize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|console
index|[
literal|0
index|]
operator|->
name|scr_buf
operator|=
name|console
index|[
literal|0
index|]
operator|->
name|mouse_pos
operator|=
name|console
index|[
literal|0
index|]
operator|->
name|mouse_oldpos
operator|=
name|sc_buffer
expr_stmt|;
if|if
condition|(
name|col
operator|>=
name|console
index|[
literal|0
index|]
operator|->
name|xsize
condition|)
name|col
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|row
operator|>=
name|console
index|[
literal|0
index|]
operator|->
name|ysize
condition|)
name|row
operator|=
name|console
index|[
literal|0
index|]
operator|->
name|ysize
operator|-
literal|1
expr_stmt|;
name|console
index|[
literal|0
index|]
operator|->
name|xpos
operator|=
name|col
expr_stmt|;
name|console
index|[
literal|0
index|]
operator|->
name|ypos
operator|=
name|row
expr_stmt|;
name|console
index|[
literal|0
index|]
operator|->
name|cursor_pos
operator|=
name|console
index|[
literal|0
index|]
operator|->
name|cursor_oldpos
operator|=
name|sc_buffer
operator|+
name|row
operator|*
name|console
index|[
literal|0
index|]
operator|->
name|xsize
operator|+
name|col
expr_stmt|;
name|console
index|[
literal|0
index|]
operator|->
name|cursor_saveunder
operator|=
operator|*
name|console
index|[
literal|0
index|]
operator|->
name|cursor_pos
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|MAXCONS
condition|;
name|i
operator|++
control|)
name|console
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|kernel_console
operator|.
name|esc
operator|=
literal|0
expr_stmt|;
name|kernel_console
operator|.
name|attr_mask
operator|=
name|NORMAL_ATTR
expr_stmt|;
name|kernel_console
operator|.
name|cur_attr
operator|=
name|kernel_console
operator|.
name|cur_color
operator|=
name|kernel_console
operator|.
name|std_color
operator|=
name|kernel_default
operator|.
name|std_color
expr_stmt|;
name|kernel_console
operator|.
name|rev_color
operator|=
name|kernel_default
operator|.
name|rev_color
expr_stmt|;
comment|/* initialize mapscrn arrays to a one to one map */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|scr_map
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|scr_map
index|[
name|i
index|]
operator|=
name|scr_rmap
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
comment|/* Save font and palette */
if|if
condition|(
name|ISFONTAVAIL
argument_list|(
name|get_adapter
argument_list|(
name|cur_console
argument_list|)
operator|->
name|va_flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|fonts_loaded
operator|&
name|FONT_16
condition|)
block|{
name|copy_font
argument_list|(
name|cur_console
argument_list|,
name|LOAD
argument_list|,
literal|16
argument_list|,
name|font_16
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|copy_font
argument_list|(
name|cur_console
argument_list|,
name|SAVE
argument_list|,
literal|16
argument_list|,
name|font_16
argument_list|)
expr_stmt|;
name|fonts_loaded
operator|=
name|FONT_16
expr_stmt|;
name|set_destructive_cursor
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * FONT KLUDGE 	 * Always use the font page #0. XXX 	 */
call|(
modifier|*
name|biosvidsw
operator|.
name|show_font
call|)
argument_list|(
name|cur_console
operator|->
name|adp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|save_palette
argument_list|(
name|cur_console
argument_list|,
name|palette
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SC_SPLASH_SCREEN
comment|/* put up the splash. */
name|scsplash_init
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|scshutdown
parameter_list|(
name|int
name|howto
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|scsplash_stick
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|run_scrn_saver
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|cold
operator|&&
name|cur_console
operator|->
name|smode
operator|.
name|mode
operator|==
name|VT_AUTO
operator|&&
name|console
index|[
literal|0
index|]
operator|->
name|smode
operator|.
name|mode
operator|==
name|VT_AUTO
condition|)
name|switch_scr
argument_list|(
name|cur_console
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|shutdown_in_progress
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sc_clean_up
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|wait_scrn_saver_stop
argument_list|()
operator|)
condition|)
return|return
name|error
return|;
name|scp
operator|->
name|status
operator|&=
operator|~
name|MOUSE_VISIBLE
expr_stmt|;
name|remove_cutmarking
argument_list|(
name|scp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|sc_alloc_scr_buffer
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|wait
parameter_list|,
name|int
name|clear
parameter_list|)
block|{
if|if
condition|(
name|scp
operator|->
name|scr_buf
condition|)
name|free
argument_list|(
name|scp
operator|->
name|scr_buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|scp
operator|->
name|scr_buf
operator|=
operator|(
name|u_short
operator|*
operator|)
name|malloc
argument_list|(
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
operator|(
name|wait
operator|)
condition|?
name|M_WAITOK
else|:
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|clear
condition|)
block|{
comment|/* clear the screen and move the text cursor to the top-left position */
name|sc_clear_screen
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* retain the current cursor position, but adjust pointers */
name|move_crsr
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|xpos
argument_list|,
name|scp
operator|->
name|ypos
argument_list|)
expr_stmt|;
name|scp
operator|->
name|cursor_oldpos
operator|=
name|scp
operator|->
name|cursor_pos
expr_stmt|;
block|}
comment|/* move the mouse cursor at the center of the screen */
name|sc_move_mouse
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|xpixel
operator|/
literal|2
argument_list|,
name|scp
operator|->
name|ypixel
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sc_alloc_cut_buffer
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|wait
parameter_list|)
block|{
if|if
condition|(
operator|(
name|cut_buffer
operator|==
name|NULL
operator|)
operator|||
operator|(
name|cut_buffer_size
operator|<
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
operator|+
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|cut_buffer
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|cut_buffer
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|cut_buffer_size
operator|=
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
operator|+
literal|1
expr_stmt|;
name|cut_buffer
operator|=
operator|(
name|u_char
operator|*
operator|)
name|malloc
argument_list|(
name|cut_buffer_size
argument_list|,
name|M_DEVBUF
argument_list|,
operator|(
name|wait
operator|)
condition|?
name|M_WAITOK
else|:
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|cut_buffer
operator|!=
name|NULL
condition|)
name|cut_buffer
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sc_alloc_history_buffer
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|lines
parameter_list|,
name|int
name|extra
parameter_list|,
name|int
name|wait
parameter_list|)
block|{
name|u_short
modifier|*
name|usp
decl_stmt|;
if|if
condition|(
name|lines
operator|<
name|scp
operator|->
name|ysize
condition|)
name|lines
operator|=
name|scp
operator|->
name|ysize
expr_stmt|;
name|usp
operator|=
name|scp
operator|->
name|history
expr_stmt|;
name|scp
operator|->
name|history
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|usp
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|usp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra
operator|>
literal|0
condition|)
name|extra_history_size
operator|+=
name|extra
expr_stmt|;
block|}
name|scp
operator|->
name|history_size
operator|=
name|lines
operator|*
name|scp
operator|->
name|xsize
expr_stmt|;
if|if
condition|(
name|lines
operator|>
name|imax
argument_list|(
name|sc_history_size
argument_list|,
name|scp
operator|->
name|ysize
argument_list|)
condition|)
name|extra_history_size
operator|-=
name|lines
operator|-
name|imax
argument_list|(
name|sc_history_size
argument_list|,
name|scp
operator|->
name|ysize
argument_list|)
expr_stmt|;
name|usp
operator|=
operator|(
name|u_short
operator|*
operator|)
name|malloc
argument_list|(
name|scp
operator|->
name|history_size
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
operator|(
name|wait
operator|)
condition|?
name|M_WAITOK
else|:
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|usp
operator|!=
name|NULL
condition|)
name|bzero
argument_list|(
name|usp
argument_list|,
name|scp
operator|->
name|history_size
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|scp
operator|->
name|history_head
operator|=
name|scp
operator|->
name|history_pos
operator|=
name|usp
expr_stmt|;
name|scp
operator|->
name|history
operator|=
name|usp
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|scr_stat
modifier|*
name|alloc_scp
parameter_list|()
block|{
name|scr_stat
modifier|*
name|scp
decl_stmt|;
name|scp
operator|=
operator|(
name|scr_stat
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|scr_stat
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|init_scp
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|sc_alloc_scr_buffer
argument_list|(
name|scp
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISMOUSEAVAIL
argument_list|(
name|get_adapter
argument_list|(
name|scp
argument_list|)
operator|->
name|va_flags
argument_list|)
condition|)
name|sc_alloc_cut_buffer
argument_list|(
name|scp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|sc_alloc_history_buffer
argument_list|(
name|scp
argument_list|,
name|sc_history_size
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* SOS     if (get_adapter(scp)->va_flags& V_ADP_MODECHANGE) 	set_mode(scp); */
name|sc_clear_screen
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|scp
operator|->
name|cursor_saveunder
operator|=
operator|*
name|scp
operator|->
name|cursor_pos
expr_stmt|;
return|return
name|scp
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_scp
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|video_info_t
name|info
decl_stmt|;
name|scp
operator|->
name|adp
operator|=
name|V_ADP_PRIMARY
expr_stmt|;
call|(
modifier|*
name|biosvidsw
operator|.
name|get_info
call|)
argument_list|(
name|scp
operator|->
name|adp
argument_list|,
name|initial_video_mode
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
name|scp
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|mode
operator|=
name|scp
operator|->
name|initial_mode
operator|=
name|initial_video_mode
expr_stmt|;
name|scp
operator|->
name|scr_buf
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|vi_flags
operator|&
name|V_INFO_GRAPHICS
condition|)
block|{
name|scp
operator|->
name|status
operator||=
name|GRAPHICS_MODE
expr_stmt|;
name|scp
operator|->
name|xpixel
operator|=
name|info
operator|.
name|vi_width
expr_stmt|;
name|scp
operator|->
name|ypixel
operator|=
name|info
operator|.
name|vi_height
expr_stmt|;
name|scp
operator|->
name|xsize
operator|=
name|info
operator|.
name|vi_width
operator|/
literal|8
expr_stmt|;
name|scp
operator|->
name|ysize
operator|=
name|info
operator|.
name|vi_height
operator|/
name|info
operator|.
name|vi_cheight
expr_stmt|;
name|scp
operator|->
name|font_size
operator|=
name|FONT_NONE
expr_stmt|;
block|}
else|else
block|{
name|scp
operator|->
name|xsize
operator|=
name|info
operator|.
name|vi_width
expr_stmt|;
name|scp
operator|->
name|ysize
operator|=
name|info
operator|.
name|vi_height
expr_stmt|;
name|scp
operator|->
name|xpixel
operator|=
name|scp
operator|->
name|xsize
operator|*
literal|8
expr_stmt|;
name|scp
operator|->
name|ypixel
operator|=
name|scp
operator|->
name|ysize
operator|*
name|info
operator|.
name|vi_cheight
expr_stmt|;
name|scp
operator|->
name|font_size
operator|=
name|info
operator|.
name|vi_cheight
expr_stmt|;
block|}
name|scp
operator|->
name|xoff
operator|=
name|scp
operator|->
name|yoff
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|xpos
operator|=
name|scp
operator|->
name|ypos
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|saved_xpos
operator|=
name|scp
operator|->
name|saved_ypos
operator|=
operator|-
literal|1
expr_stmt|;
name|scp
operator|->
name|start
operator|=
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
expr_stmt|;
name|scp
operator|->
name|end
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|esc
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator|=
name|NORMAL_ATTR
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|scp
operator|->
name|term
operator|.
name|cur_color
operator|=
name|scp
operator|->
name|term
operator|.
name|std_color
operator|=
name|current_default
operator|->
name|std_color
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|rev_color
operator|=
name|current_default
operator|->
name|rev_color
expr_stmt|;
name|scp
operator|->
name|border
operator|=
name|BG_BLACK
expr_stmt|;
name|scp
operator|->
name|cursor_start
operator|=
operator|*
operator|(
name|u_int8_t
operator|*
operator|)
name|pa_to_va
argument_list|(
literal|0x461
argument_list|)
expr_stmt|;
name|scp
operator|->
name|cursor_end
operator|=
operator|*
operator|(
name|u_int8_t
operator|*
operator|)
name|pa_to_va
argument_list|(
literal|0x460
argument_list|)
expr_stmt|;
name|scp
operator|->
name|mouse_xpos
operator|=
name|scp
operator|->
name|xsize
operator|*
literal|8
operator|/
literal|2
expr_stmt|;
name|scp
operator|->
name|mouse_ypos
operator|=
name|scp
operator|->
name|ysize
operator|*
name|scp
operator|->
name|font_size
operator|/
literal|2
expr_stmt|;
name|scp
operator|->
name|mouse_cut_start
operator|=
name|scp
operator|->
name|mouse_cut_end
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|mouse_signal
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|mouse_pid
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|mouse_proc
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|bell_pitch
operator|=
name|BELL_PITCH
expr_stmt|;
name|scp
operator|->
name|bell_duration
operator|=
name|BELL_DURATION
expr_stmt|;
name|scp
operator|->
name|status
operator||=
operator|(
operator|*
operator|(
name|u_int8_t
operator|*
operator|)
name|pa_to_va
argument_list|(
literal|0x417
argument_list|)
operator|&
literal|0x20
operator|)
condition|?
name|NLKED
else|:
literal|0
expr_stmt|;
name|scp
operator|->
name|status
operator||=
name|CURSOR_ENABLED
expr_stmt|;
name|scp
operator|->
name|pid
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|proc
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|smode
operator|.
name|mode
operator|=
name|VT_AUTO
expr_stmt|;
name|scp
operator|->
name|history_head
operator|=
name|scp
operator|->
name|history_pos
operator|=
name|scp
operator|->
name|history
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|history_size
operator|=
name|imax
argument_list|(
name|sc_history_size
argument_list|,
name|scp
operator|->
name|ysize
argument_list|)
operator|*
name|scp
operator|->
name|xsize
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_char
modifier|*
name|get_fstr
parameter_list|(
name|u_int
name|c
parameter_list|,
name|u_int
modifier|*
name|len
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|&
name|FKEY
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|i
operator|=
operator|(
name|c
operator|&
literal|0xFF
operator|)
operator|-
name|F_FN
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|n_fkey_tab
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
operator|*
name|len
operator|=
name|fkey_tab
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
return|return
operator|(
name|fkey_tab
index|[
name|i
index|]
operator|.
name|str
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|history_to_screen
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|scp
operator|->
name|ysize
condition|;
name|i
operator|++
control|)
name|bcopy
argument_list|(
name|scp
operator|->
name|history
operator|+
operator|(
operator|(
operator|(
name|scp
operator|->
name|history_pos
operator|-
name|scp
operator|->
name|history
operator|)
operator|+
name|scp
operator|->
name|history_size
operator|-
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
name|scp
operator|->
name|xsize
operator|)
operator|)
operator|%
name|scp
operator|->
name|history_size
operator|)
argument_list|,
name|scp
operator|->
name|scr_buf
operator|+
operator|(
name|scp
operator|->
name|xsize
operator|*
operator|(
name|scp
operator|->
name|ysize
operator|-
literal|1
operator|-
name|i
operator|)
operator|)
argument_list|,
name|scp
operator|->
name|xsize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|history_up_line
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
if|if
condition|(
name|WRAPHIST
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|history_pos
argument_list|,
operator|-
operator|(
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
operator|)
argument_list|)
operator|!=
name|scp
operator|->
name|history_head
condition|)
block|{
name|scp
operator|->
name|history_pos
operator|=
name|WRAPHIST
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|history_pos
argument_list|,
operator|-
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
name|history_to_screen
argument_list|(
name|scp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|history_down_line
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
if|if
condition|(
name|scp
operator|->
name|history_pos
operator|!=
name|scp
operator|->
name|history_head
condition|)
block|{
name|scp
operator|->
name|history_pos
operator|=
name|WRAPHIST
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|history_pos
argument_list|,
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
name|history_to_screen
argument_list|(
name|scp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * scgetc(flags) - get character from keyboard.  * If flags& SCGETC_CN, then avoid harmful side effects.  * If flags& SCGETC_NONBLOCK, then wait until a key is pressed, else  * return NOKEY if there is nothing there.  */
end_comment

begin_function
specifier|static
name|u_int
name|scgetc
parameter_list|(
name|u_int
name|flags
parameter_list|)
block|{
name|struct
name|key_t
modifier|*
name|key
decl_stmt|;
name|u_char
name|scancode
decl_stmt|,
name|keycode
decl_stmt|;
name|u_int
name|state
decl_stmt|,
name|action
decl_stmt|;
name|int
name|c
decl_stmt|;
specifier|static
name|u_char
name|esc_flag
init|=
literal|0
decl_stmt|,
name|compose
init|=
literal|0
decl_stmt|;
specifier|static
name|u_int
name|chr
init|=
literal|0
decl_stmt|;
name|next_code
label|:
comment|/* first see if there is something in the keyboard port */
if|if
condition|(
name|flags
operator|&
name|SCGETC_NONBLOCK
condition|)
block|{
name|c
operator|=
name|read_kbd_data_no_wait
argument_list|(
name|sc_kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|NOKEY
operator|)
return|;
block|}
else|else
block|{
do|do
block|{
name|c
operator|=
name|read_kbd_data
argument_list|(
name|sc_kbdc
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|==
operator|-
literal|1
condition|)
do|;
block|}
name|scancode
operator|=
operator|(
name|u_char
operator|)
name|c
expr_stmt|;
comment|/* make screensaver happy */
if|if
condition|(
operator|!
operator|(
name|scancode
operator|&
literal|0x80
operator|)
condition|)
block|{
name|scsplash_stick
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|run_scrn_saver
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCGETC_CN
operator|)
condition|)
block|{
comment|/* do the /dev/random device a favour */
name|add_keyboard_randomness
argument_list|(
name|scancode
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_console
operator|->
name|status
operator|&
name|KBD_RAW_MODE
condition|)
return|return
name|scancode
return|;
block|}
name|keycode
operator|=
name|scancode
operator|&
literal|0x7F
expr_stmt|;
switch|switch
condition|(
name|esc_flag
condition|)
block|{
case|case
literal|0x00
case|:
comment|/* normal scancode */
switch|switch
condition|(
name|scancode
condition|)
block|{
case|case
literal|0xB8
case|:
comment|/* left alt (compose key) */
if|if
condition|(
name|compose
condition|)
block|{
name|compose
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|chr
operator|>
literal|255
condition|)
block|{
name|do_bell
argument_list|(
name|cur_console
argument_list|,
name|BELL_PITCH
argument_list|,
name|BELL_DURATION
argument_list|)
expr_stmt|;
name|chr
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|0x38
case|:
if|if
condition|(
operator|!
name|compose
condition|)
block|{
name|compose
operator|=
literal|1
expr_stmt|;
name|chr
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|0xE0
case|:
case|case
literal|0xE1
case|:
name|esc_flag
operator|=
name|scancode
expr_stmt|;
goto|goto
name|next_code
goto|;
block|}
break|break;
case|case
literal|0xE0
case|:
comment|/* 0xE0 prefix */
name|esc_flag
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|keycode
condition|)
block|{
case|case
literal|0x1C
case|:
comment|/* right enter key */
name|keycode
operator|=
literal|0x59
expr_stmt|;
break|break;
case|case
literal|0x1D
case|:
comment|/* right ctrl key */
name|keycode
operator|=
literal|0x5A
expr_stmt|;
break|break;
case|case
literal|0x35
case|:
comment|/* keypad divide key */
name|keycode
operator|=
literal|0x5B
expr_stmt|;
break|break;
case|case
literal|0x37
case|:
comment|/* print scrn key */
name|keycode
operator|=
literal|0x5C
expr_stmt|;
break|break;
case|case
literal|0x38
case|:
comment|/* right alt key (alt gr) */
name|keycode
operator|=
literal|0x5D
expr_stmt|;
break|break;
case|case
literal|0x47
case|:
comment|/* grey home key */
name|keycode
operator|=
literal|0x5E
expr_stmt|;
break|break;
case|case
literal|0x48
case|:
comment|/* grey up arrow key */
name|keycode
operator|=
literal|0x5F
expr_stmt|;
break|break;
case|case
literal|0x49
case|:
comment|/* grey page up key */
name|keycode
operator|=
literal|0x60
expr_stmt|;
break|break;
case|case
literal|0x4B
case|:
comment|/* grey left arrow key */
name|keycode
operator|=
literal|0x61
expr_stmt|;
break|break;
case|case
literal|0x4D
case|:
comment|/* grey right arrow key */
name|keycode
operator|=
literal|0x62
expr_stmt|;
break|break;
case|case
literal|0x4F
case|:
comment|/* grey end key */
name|keycode
operator|=
literal|0x63
expr_stmt|;
break|break;
case|case
literal|0x50
case|:
comment|/* grey down arrow key */
name|keycode
operator|=
literal|0x64
expr_stmt|;
break|break;
case|case
literal|0x51
case|:
comment|/* grey page down key */
name|keycode
operator|=
literal|0x65
expr_stmt|;
break|break;
case|case
literal|0x52
case|:
comment|/* grey insert key */
name|keycode
operator|=
literal|0x66
expr_stmt|;
break|break;
case|case
literal|0x53
case|:
comment|/* grey delete key */
name|keycode
operator|=
literal|0x67
expr_stmt|;
break|break;
comment|/* the following 3 are only used on the MS "Natural" keyboard */
case|case
literal|0x5b
case|:
comment|/* left Window key */
name|keycode
operator|=
literal|0x69
expr_stmt|;
break|break;
case|case
literal|0x5c
case|:
comment|/* right Window key */
name|keycode
operator|=
literal|0x6a
expr_stmt|;
break|break;
case|case
literal|0x5d
case|:
comment|/* menu key */
name|keycode
operator|=
literal|0x6b
expr_stmt|;
break|break;
default|default:
comment|/* ignore everything else */
goto|goto
name|next_code
goto|;
block|}
break|break;
case|case
literal|0xE1
case|:
comment|/* 0xE1 prefix */
name|esc_flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|keycode
operator|==
literal|0x1D
condition|)
name|esc_flag
operator|=
literal|0x1D
expr_stmt|;
goto|goto
name|next_code
goto|;
comment|/* NOT REACHED */
case|case
literal|0x1D
case|:
comment|/* pause / break */
name|esc_flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|keycode
operator|!=
literal|0x45
condition|)
goto|goto
name|next_code
goto|;
name|keycode
operator|=
literal|0x68
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCGETC_CN
operator|)
operator|&&
operator|(
name|cur_console
operator|->
name|status
operator|&
name|KBD_CODE_MODE
operator|)
condition|)
return|return
operator|(
name|keycode
operator||
operator|(
name|scancode
operator|&
literal|0x80
operator|)
operator|)
return|;
comment|/* if scroll-lock pressed allow history browsing */
if|if
condition|(
name|cur_console
operator|->
name|history
operator|&&
name|cur_console
operator|->
name|status
operator|&
name|SLKED
condition|)
block|{
name|int
name|i
decl_stmt|;
name|cur_console
operator|->
name|status
operator|&=
operator|~
name|CURSOR_ENABLED
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cur_console
operator|->
name|status
operator|&
name|BUFFER_SAVED
operator|)
condition|)
block|{
name|cur_console
operator|->
name|status
operator||=
name|BUFFER_SAVED
expr_stmt|;
name|cur_console
operator|->
name|history_save
operator|=
name|cur_console
operator|->
name|history_head
expr_stmt|;
comment|/* copy screen into top of history buffer */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cur_console
operator|->
name|ysize
condition|;
name|i
operator|++
control|)
block|{
name|bcopy
argument_list|(
name|cur_console
operator|->
name|scr_buf
operator|+
operator|(
name|cur_console
operator|->
name|xsize
operator|*
name|i
operator|)
argument_list|,
name|cur_console
operator|->
name|history_head
argument_list|,
name|cur_console
operator|->
name|xsize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|cur_console
operator|->
name|history_head
operator|+=
name|cur_console
operator|->
name|xsize
expr_stmt|;
if|if
condition|(
name|cur_console
operator|->
name|history_head
operator|+
name|cur_console
operator|->
name|xsize
operator|>
name|cur_console
operator|->
name|history
operator|+
name|cur_console
operator|->
name|history_size
condition|)
name|cur_console
operator|->
name|history_head
operator|=
name|cur_console
operator|->
name|history
expr_stmt|;
block|}
name|cur_console
operator|->
name|history_pos
operator|=
name|cur_console
operator|->
name|history_head
expr_stmt|;
name|history_to_screen
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|scancode
condition|)
block|{
case|case
literal|0x47
case|:
comment|/* home key */
name|cur_console
operator|->
name|history_pos
operator|=
name|cur_console
operator|->
name|history_head
expr_stmt|;
name|history_to_screen
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
goto|goto
name|next_code
goto|;
case|case
literal|0x4F
case|:
comment|/* end key */
name|cur_console
operator|->
name|history_pos
operator|=
name|WRAPHIST
argument_list|(
name|cur_console
argument_list|,
name|cur_console
operator|->
name|history_head
argument_list|,
name|cur_console
operator|->
name|xsize
operator|*
name|cur_console
operator|->
name|ysize
argument_list|)
expr_stmt|;
name|history_to_screen
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
goto|goto
name|next_code
goto|;
case|case
literal|0x48
case|:
comment|/* up arrow key */
if|if
condition|(
name|history_up_line
argument_list|(
name|cur_console
argument_list|)
condition|)
name|do_bell
argument_list|(
name|cur_console
argument_list|,
name|BELL_PITCH
argument_list|,
name|BELL_DURATION
argument_list|)
expr_stmt|;
goto|goto
name|next_code
goto|;
case|case
literal|0x50
case|:
comment|/* down arrow key */
if|if
condition|(
name|history_down_line
argument_list|(
name|cur_console
argument_list|)
condition|)
name|do_bell
argument_list|(
name|cur_console
argument_list|,
name|BELL_PITCH
argument_list|,
name|BELL_DURATION
argument_list|)
expr_stmt|;
goto|goto
name|next_code
goto|;
case|case
literal|0x49
case|:
comment|/* page up key */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cur_console
operator|->
name|ysize
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|history_up_line
argument_list|(
name|cur_console
argument_list|)
condition|)
block|{
name|do_bell
argument_list|(
name|cur_console
argument_list|,
name|BELL_PITCH
argument_list|,
name|BELL_DURATION
argument_list|)
expr_stmt|;
break|break;
block|}
goto|goto
name|next_code
goto|;
case|case
literal|0x51
case|:
comment|/* page down key */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cur_console
operator|->
name|ysize
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|history_down_line
argument_list|(
name|cur_console
argument_list|)
condition|)
block|{
name|do_bell
argument_list|(
name|cur_console
argument_list|,
name|BELL_PITCH
argument_list|,
name|BELL_DURATION
argument_list|)
expr_stmt|;
break|break;
block|}
goto|goto
name|next_code
goto|;
block|}
block|}
if|if
condition|(
name|compose
condition|)
block|{
switch|switch
condition|(
name|scancode
condition|)
block|{
comment|/* key pressed process it */
case|case
literal|0x47
case|:
case|case
literal|0x48
case|:
case|case
literal|0x49
case|:
comment|/* keypad 7,8,9 */
name|chr
operator|=
operator|(
name|scancode
operator|-
literal|0x40
operator|)
operator|+
name|chr
operator|*
literal|10
expr_stmt|;
goto|goto
name|next_code
goto|;
case|case
literal|0x4B
case|:
case|case
literal|0x4C
case|:
case|case
literal|0x4D
case|:
comment|/* keypad 4,5,6 */
name|chr
operator|=
operator|(
name|scancode
operator|-
literal|0x47
operator|)
operator|+
name|chr
operator|*
literal|10
expr_stmt|;
goto|goto
name|next_code
goto|;
case|case
literal|0x4F
case|:
case|case
literal|0x50
case|:
case|case
literal|0x51
case|:
comment|/* keypad 1,2,3 */
name|chr
operator|=
operator|(
name|scancode
operator|-
literal|0x4E
operator|)
operator|+
name|chr
operator|*
literal|10
expr_stmt|;
goto|goto
name|next_code
goto|;
case|case
literal|0x52
case|:
comment|/* keypad 0 */
name|chr
operator|*=
literal|10
expr_stmt|;
goto|goto
name|next_code
goto|;
comment|/* key release, no interest here */
case|case
literal|0xC7
case|:
case|case
literal|0xC8
case|:
case|case
literal|0xC9
case|:
comment|/* keypad 7,8,9 */
case|case
literal|0xCB
case|:
case|case
literal|0xCC
case|:
case|case
literal|0xCD
case|:
comment|/* keypad 4,5,6 */
case|case
literal|0xCF
case|:
case|case
literal|0xD0
case|:
case|case
literal|0xD1
case|:
comment|/* keypad 1,2,3 */
case|case
literal|0xD2
case|:
comment|/* keypad 0 */
goto|goto
name|next_code
goto|;
case|case
literal|0x38
case|:
comment|/* left alt key */
break|break;
default|default:
if|if
condition|(
name|chr
condition|)
block|{
name|compose
operator|=
name|chr
operator|=
literal|0
expr_stmt|;
name|do_bell
argument_list|(
name|cur_console
argument_list|,
name|BELL_PITCH
argument_list|,
name|BELL_DURATION
argument_list|)
expr_stmt|;
goto|goto
name|next_code
goto|;
block|}
break|break;
block|}
block|}
name|state
operator|=
operator|(
name|shfts
condition|?
literal|1
else|:
literal|0
operator|)
operator||
operator|(
literal|2
operator|*
operator|(
name|ctls
condition|?
literal|1
else|:
literal|0
operator|)
operator|)
operator||
operator|(
literal|4
operator|*
operator|(
name|alts
condition|?
literal|1
else|:
literal|0
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|agrs
operator|&&
operator|(
name|cur_console
operator|->
name|status
operator|&
name|ALKED
operator|)
operator|)
operator|||
operator|(
name|agrs
operator|&&
operator|!
operator|(
name|cur_console
operator|->
name|status
operator|&
name|ALKED
operator|)
operator|)
condition|)
name|keycode
operator|+=
name|ALTGR_OFFSET
expr_stmt|;
name|key
operator|=
operator|&
name|key_map
operator|.
name|key
index|[
name|keycode
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|key
operator|->
name|flgs
operator|&
name|FLAG_LOCK_C
operator|)
operator|&&
operator|(
name|cur_console
operator|->
name|status
operator|&
name|CLKED
operator|)
operator|)
operator|||
operator|(
operator|(
name|key
operator|->
name|flgs
operator|&
name|FLAG_LOCK_N
operator|)
operator|&&
operator|(
name|cur_console
operator|->
name|status
operator|&
name|NLKED
operator|)
operator|)
condition|)
name|state
operator|^=
literal|1
expr_stmt|;
comment|/* Check for make/break */
name|action
operator|=
name|key
operator|->
name|map
index|[
name|state
index|]
expr_stmt|;
if|if
condition|(
name|scancode
operator|&
literal|0x80
condition|)
block|{
comment|/* key released */
if|if
condition|(
name|key
operator|->
name|spcl
operator|&
operator|(
literal|0x80
operator|>>
name|state
operator|)
condition|)
block|{
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|LSH
case|:
name|shfts
operator|&=
operator|~
literal|1
expr_stmt|;
break|break;
case|case
name|RSH
case|:
name|shfts
operator|&=
operator|~
literal|2
expr_stmt|;
break|break;
case|case
name|LCTR
case|:
name|ctls
operator|&=
operator|~
literal|1
expr_stmt|;
break|break;
case|case
name|RCTR
case|:
name|ctls
operator|&=
operator|~
literal|2
expr_stmt|;
break|break;
case|case
name|LALT
case|:
name|alts
operator|&=
operator|~
literal|1
expr_stmt|;
break|break;
case|case
name|RALT
case|:
name|alts
operator|&=
operator|~
literal|2
expr_stmt|;
break|break;
case|case
name|NLK
case|:
name|nlkcnt
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CLK
case|:
name|clkcnt
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SLK
case|:
name|slkcnt
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ASH
case|:
name|agrs
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ALK
case|:
name|alkcnt
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|META
case|:
name|metas
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|chr
operator|&&
operator|!
name|compose
condition|)
block|{
name|action
operator|=
name|chr
expr_stmt|;
name|chr
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|action
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* key pressed */
if|if
condition|(
name|key
operator|->
name|spcl
operator|&
operator|(
literal|0x80
operator|>>
name|state
operator|)
condition|)
block|{
switch|switch
condition|(
name|action
condition|)
block|{
comment|/* LOCKING KEYS */
case|case
name|NLK
case|:
if|if
condition|(
operator|!
name|nlkcnt
condition|)
block|{
name|nlkcnt
operator|++
expr_stmt|;
if|if
condition|(
name|cur_console
operator|->
name|status
operator|&
name|NLKED
condition|)
name|cur_console
operator|->
name|status
operator|&=
operator|~
name|NLKED
expr_stmt|;
else|else
name|cur_console
operator|->
name|status
operator||=
name|NLKED
expr_stmt|;
name|update_leds
argument_list|(
name|cur_console
operator|->
name|status
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CLK
case|:
if|if
condition|(
operator|!
name|clkcnt
condition|)
block|{
name|clkcnt
operator|++
expr_stmt|;
if|if
condition|(
name|cur_console
operator|->
name|status
operator|&
name|CLKED
condition|)
name|cur_console
operator|->
name|status
operator|&=
operator|~
name|CLKED
expr_stmt|;
else|else
name|cur_console
operator|->
name|status
operator||=
name|CLKED
expr_stmt|;
name|update_leds
argument_list|(
name|cur_console
operator|->
name|status
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SLK
case|:
if|if
condition|(
operator|!
name|slkcnt
condition|)
block|{
name|slkcnt
operator|++
expr_stmt|;
if|if
condition|(
name|cur_console
operator|->
name|status
operator|&
name|SLKED
condition|)
block|{
name|cur_console
operator|->
name|status
operator|&=
operator|~
name|SLKED
expr_stmt|;
if|if
condition|(
name|cur_console
operator|->
name|status
operator|&
name|BUFFER_SAVED
condition|)
block|{
name|int
name|i
decl_stmt|;
name|u_short
modifier|*
name|ptr
init|=
name|cur_console
operator|->
name|history_save
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cur_console
operator|->
name|ysize
condition|;
name|i
operator|++
control|)
block|{
name|bcopy
argument_list|(
name|ptr
argument_list|,
name|cur_console
operator|->
name|scr_buf
operator|+
operator|(
name|cur_console
operator|->
name|xsize
operator|*
name|i
operator|)
argument_list|,
name|cur_console
operator|->
name|xsize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|ptr
operator|+=
name|cur_console
operator|->
name|xsize
expr_stmt|;
if|if
condition|(
name|ptr
operator|+
name|cur_console
operator|->
name|xsize
operator|>
name|cur_console
operator|->
name|history
operator|+
name|cur_console
operator|->
name|history_size
condition|)
name|ptr
operator|=
name|cur_console
operator|->
name|history
expr_stmt|;
block|}
name|cur_console
operator|->
name|status
operator|&=
operator|~
name|BUFFER_SAVED
expr_stmt|;
name|cur_console
operator|->
name|history_head
operator|=
name|cur_console
operator|->
name|history_save
expr_stmt|;
name|cur_console
operator|->
name|status
operator||=
name|CURSOR_ENABLED
expr_stmt|;
name|mark_all
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
block|}
name|scstart
argument_list|(
name|VIRTUAL_TTY
argument_list|(
name|get_scr_num
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|cur_console
operator|->
name|status
operator||=
name|SLKED
expr_stmt|;
name|update_leds
argument_list|(
name|cur_console
operator|->
name|status
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ALK
case|:
if|if
condition|(
operator|!
name|alkcnt
condition|)
block|{
name|alkcnt
operator|++
expr_stmt|;
if|if
condition|(
name|cur_console
operator|->
name|status
operator|&
name|ALKED
condition|)
name|cur_console
operator|->
name|status
operator|&=
operator|~
name|ALKED
expr_stmt|;
else|else
name|cur_console
operator|->
name|status
operator||=
name|ALKED
expr_stmt|;
name|update_leds
argument_list|(
name|cur_console
operator|->
name|status
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* NON-LOCKING KEYS */
case|case
name|NOP
case|:
break|break;
case|case
name|SPSC
case|:
comment|/* force activatation/deactivation of the screen saver */
name|accents
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|scrn_blanked
operator|<=
literal|0
condition|)
block|{
name|run_scrn_saver
operator|=
name|TRUE
expr_stmt|;
name|scrn_time_stamp
operator|-=
name|scrn_blank_time
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SC_SPLASH_SCREEN
if|if
condition|(
name|cold
condition|)
block|{
comment|/* 		     * While devices are being probed, the screen saver need 		     * to be invoked explictly. XXX 		     */
if|if
condition|(
name|scrn_blanked
operator|>
literal|0
condition|)
block|{
name|scsplash_stick
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|stop_scrn_saver
argument_list|(
name|current_saver
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|ISGRAPHSC
argument_list|(
name|cur_console
argument_list|)
condition|)
block|{
name|scsplash_stick
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|scrn_saver
argument_list|(
name|current_saver
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
break|break;
case|case
name|RBT
case|:
ifndef|#
directive|ifndef
name|SC_DISABLE_REBOOT
name|accents
operator|=
literal|0
expr_stmt|;
name|shutdown_nice
argument_list|()
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|SUSP
case|:
if|#
directive|if
name|NAPM
operator|>
literal|0
name|accents
operator|=
literal|0
expr_stmt|;
name|apm_suspend
argument_list|(
name|PMST_SUSPEND
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|STBY
case|:
if|#
directive|if
name|NAPM
operator|>
literal|0
name|accents
operator|=
literal|0
expr_stmt|;
name|apm_suspend
argument_list|(
name|PMST_STANDBY
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|DBG
case|:
ifdef|#
directive|ifdef
name|DDB
comment|/* try to switch to console 0 */
name|accents
operator|=
literal|0
expr_stmt|;
comment|/* 		 * TRY to make sure the screen saver is stopped,  		 * and the screen is updated before switching to  		 * the vty0. 		 */
name|scrn_timer
argument_list|(
operator|(
name|void
operator|*
operator|)
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_console
operator|->
name|smode
operator|.
name|mode
operator|==
name|VT_AUTO
operator|&&
name|console
index|[
literal|0
index|]
operator|->
name|smode
operator|.
name|mode
operator|==
name|VT_AUTO
condition|)
name|switch_scr
argument_list|(
name|cur_console
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Debugger
argument_list|(
literal|"manual escape to debugger"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"No debugger in kernel\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|LSH
case|:
name|shfts
operator||=
literal|1
expr_stmt|;
break|break;
case|case
name|RSH
case|:
name|shfts
operator||=
literal|2
expr_stmt|;
break|break;
case|case
name|LCTR
case|:
name|ctls
operator||=
literal|1
expr_stmt|;
break|break;
case|case
name|RCTR
case|:
name|ctls
operator||=
literal|2
expr_stmt|;
break|break;
case|case
name|LALT
case|:
name|alts
operator||=
literal|1
expr_stmt|;
break|break;
case|case
name|RALT
case|:
name|alts
operator||=
literal|2
expr_stmt|;
break|break;
case|case
name|ASH
case|:
name|agrs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|META
case|:
name|metas
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|NEXT
case|:
block|{
name|int
name|next
decl_stmt|,
name|this
init|=
name|get_scr_num
argument_list|()
decl_stmt|;
name|accents
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|next
operator|=
name|this
operator|+
literal|1
init|;
name|next
operator|!=
name|this
condition|;
name|next
operator|=
operator|(
name|next
operator|+
literal|1
operator|)
operator|%
name|MAXCONS
control|)
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
name|VIRTUAL_TTY
argument_list|(
name|next
argument_list|)
decl_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
condition|)
block|{
name|switch_scr
argument_list|(
name|cur_console
argument_list|,
name|next
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
break|break;
case|case
name|BTAB
case|:
name|accents
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|BKEY
operator|)
return|;
default|default:
if|if
condition|(
name|action
operator|>=
name|F_ACC
operator|&&
name|action
operator|<=
name|L_ACC
condition|)
block|{
comment|/* turn it into an index */
name|action
operator|-=
name|F_ACC
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|action
operator|>
name|accent_map
operator|.
name|n_accs
operator|)
operator|||
operator|(
name|accent_map
operator|.
name|acc
index|[
name|action
operator|-
literal|1
index|]
operator|.
name|accchar
operator|==
literal|0
operator|)
condition|)
block|{
comment|/*  			 * The index is out of range or pointing to an  			 * empty entry. 			 */
name|accents
operator|=
literal|0
expr_stmt|;
name|do_bell
argument_list|(
name|cur_console
argument_list|,
name|BELL_PITCH
argument_list|,
name|BELL_DURATION
argument_list|)
expr_stmt|;
block|}
comment|/*  		     * If the same accent key has been hit twice, 		     * produce the accent char itself. 		     */
if|if
condition|(
name|action
operator|==
name|accents
condition|)
block|{
name|action
operator|=
name|accent_map
operator|.
name|acc
index|[
name|accents
operator|-
literal|1
index|]
operator|.
name|accchar
expr_stmt|;
name|accents
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|metas
condition|)
name|action
operator||=
name|MKEY
expr_stmt|;
return|return
operator|(
name|action
operator|)
return|;
block|}
comment|/* remember the index and wait for the next key stroke */
name|accents
operator|=
name|action
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|accents
operator|>
literal|0
condition|)
block|{
name|accents
operator|=
literal|0
expr_stmt|;
name|do_bell
argument_list|(
name|cur_console
argument_list|,
name|BELL_PITCH
argument_list|,
name|BELL_DURATION
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|action
operator|>=
name|F_SCR
operator|&&
name|action
operator|<=
name|L_SCR
condition|)
block|{
name|switch_scr
argument_list|(
name|cur_console
argument_list|,
name|action
operator|-
name|F_SCR
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|action
operator|>=
name|F_FN
operator|&&
name|action
operator|<=
name|L_FN
condition|)
name|action
operator||=
name|FKEY
expr_stmt|;
return|return
operator|(
name|action
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|accents
condition|)
block|{
name|struct
name|acc_t
modifier|*
name|acc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|acc
operator|=
operator|&
name|accent_map
operator|.
name|acc
index|[
name|accents
operator|-
literal|1
index|]
expr_stmt|;
name|accents
operator|=
literal|0
expr_stmt|;
comment|/*  		 * If the accent key is followed by the space key, 		 * produce the accent char itself. 		 */
if|if
condition|(
name|action
operator|==
literal|' '
condition|)
block|{
name|action
operator|=
name|acc
operator|->
name|accchar
expr_stmt|;
if|if
condition|(
name|metas
condition|)
name|action
operator||=
name|MKEY
expr_stmt|;
return|return
operator|(
name|action
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_ACCENTCHARS
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|acc
operator|->
name|map
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|0
condition|)
comment|/* end of the map entry */
break|break;
if|if
condition|(
name|acc
operator|->
name|map
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
name|action
condition|)
block|{
name|action
operator|=
name|acc
operator|->
name|map
index|[
name|i
index|]
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|metas
condition|)
name|action
operator||=
name|MKEY
expr_stmt|;
return|return
operator|(
name|action
operator|)
return|;
block|}
block|}
name|do_bell
argument_list|(
name|cur_console
argument_list|,
name|BELL_PITCH
argument_list|,
name|BELL_DURATION
argument_list|)
expr_stmt|;
goto|goto
name|next_code
goto|;
block|}
if|if
condition|(
name|metas
condition|)
name|action
operator||=
name|MKEY
expr_stmt|;
return|return
operator|(
name|action
operator|)
return|;
block|}
block|}
goto|goto
name|next_code
goto|;
block|}
end_function

begin_function
name|int
name|scmmap
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|nprot
parameter_list|)
block|{
if|if
condition|(
name|offset
operator|>
literal|0x20000
operator|-
name|PAGE_SIZE
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|i386_btop
argument_list|(
operator|(
name|VIDEOMEM
operator|+
name|offset
operator|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate hardware attributes word using logical attributes mask and  * hardware colors  */
end_comment

begin_function
specifier|static
name|int
name|mask2attr
parameter_list|(
name|struct
name|term_stat
modifier|*
name|term
parameter_list|)
block|{
name|int
name|attr
decl_stmt|,
name|mask
init|=
name|term
operator|->
name|attr_mask
decl_stmt|;
if|if
condition|(
name|mask
operator|&
name|REVERSE_ATTR
condition|)
block|{
name|attr
operator|=
operator|(
operator|(
name|mask
operator|&
name|FOREGROUND_CHANGED
operator|)
condition|?
operator|(
operator|(
name|term
operator|->
name|cur_color
operator|&
literal|0xF000
operator|)
operator|>>
literal|4
operator|)
else|:
operator|(
name|term
operator|->
name|rev_color
operator|&
literal|0x0F00
operator|)
operator|)
operator||
operator|(
operator|(
name|mask
operator|&
name|BACKGROUND_CHANGED
operator|)
condition|?
operator|(
operator|(
name|term
operator|->
name|cur_color
operator|&
literal|0x0F00
operator|)
operator|<<
literal|4
operator|)
else|:
operator|(
name|term
operator|->
name|rev_color
operator|&
literal|0xF000
operator|)
operator|)
expr_stmt|;
block|}
else|else
name|attr
operator|=
name|term
operator|->
name|cur_color
expr_stmt|;
comment|/* XXX: underline mapping for Hercules adapter can be better */
if|if
condition|(
name|mask
operator|&
operator|(
name|BOLD_ATTR
operator||
name|UNDERLINE_ATTR
operator|)
condition|)
name|attr
operator|^=
literal|0x0800
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|BLINK_ATTR
condition|)
name|attr
operator|^=
literal|0x8000
expr_stmt|;
return|return
name|attr
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_keyboard
parameter_list|(
name|int
name|command
parameter_list|,
name|int
name|data
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
if|if
condition|(
name|sc_kbdc
operator|==
name|NULL
condition|)
return|return;
comment|/* prevent the timeout routine from polling the keyboard */
if|if
condition|(
operator|!
name|kbdc_lock
argument_list|(
name|sc_kbdc
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return;
comment|/* disable the keyboard and mouse interrupt */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
block|c = get_controller_command_byte(sc_kbdc);     if ((c == -1)  	|| !set_controller_command_byte(sc_kbdc,              kbdc_get_device_mask(sc_kbdc),             KBD_DISABLE_KBD_PORT | KBD_DISABLE_KBD_INT                 | KBD_DISABLE_AUX_PORT | KBD_DISABLE_AUX_INT)) {
comment|/* CONTROLLER ERROR */
block|kbdc_lock(sc_kbdc, FALSE); 	splx(s); 	return;     }
comment|/*       * Now that the keyboard controller is told not to generate       * the keyboard and mouse interrupts, call `splx()' to allow       * the other tty interrupts. The clock interrupt may also occur,       * but the timeout routine (`scrn_timer()') will be blocked       * by the lock flag set via `kbdc_lock()'      */
block|splx(s);
endif|#
directive|endif
if|if
condition|(
name|send_kbd_command_and_data
argument_list|(
name|sc_kbdc
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
operator|!=
name|KBD_ACK
condition|)
name|send_kbd_command
argument_list|(
name|sc_kbdc
argument_list|,
name|KBDC_ENABLE_KBD
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* restore the interrupts */
block|if (!set_controller_command_byte(sc_kbdc,             kbdc_get_device_mask(sc_kbdc), 	    c& (KBD_KBD_CONTROL_BITS | KBD_AUX_CONTROL_BITS))) {
comment|/* CONTROLLER ERROR */
block|}
else|#
directive|else
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|kbdc_lock
argument_list|(
name|sc_kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|update_leds
parameter_list|(
name|int
name|which
parameter_list|)
block|{
specifier|static
name|u_char
name|xlate_leds
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|4
block|,
literal|2
block|,
literal|6
block|,
literal|1
block|,
literal|5
block|,
literal|3
block|,
literal|7
block|}
decl_stmt|;
comment|/* replace CAPS led with ALTGR led for ALTGR keyboards */
if|if
condition|(
name|key_map
operator|.
name|n_keys
operator|>
name|ALTGR_OFFSET
condition|)
block|{
if|if
condition|(
name|which
operator|&
name|ALKED
condition|)
name|which
operator||=
name|CLKED
expr_stmt|;
else|else
name|which
operator|&=
operator|~
name|CLKED
expr_stmt|;
block|}
name|set_keyboard
argument_list|(
name|KBDC_SET_LEDS
argument_list|,
name|xlate_leds
index|[
name|which
operator|&
name|LED_MASK
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|set_mode
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|video_info_t
name|info
decl_stmt|;
name|video_adapter_t
modifier|*
name|adp
decl_stmt|;
comment|/* reject unsupported mode */
if|if
condition|(
call|(
modifier|*
name|biosvidsw
operator|.
name|get_info
call|)
argument_list|(
name|scp
operator|->
name|adp
argument_list|,
name|scp
operator|->
name|mode
argument_list|,
operator|&
name|info
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* if this vty is not currently showing, do nothing */
if|if
condition|(
name|scp
operator|!=
name|cur_console
condition|)
return|return
literal|0
return|;
comment|/* setup video hardware for the given mode */
name|adp
operator|=
name|get_adapter
argument_list|(
name|scp
argument_list|)
expr_stmt|;
call|(
modifier|*
name|biosvidsw
operator|.
name|set_mode
call|)
argument_list|(
name|scp
operator|->
name|adp
argument_list|,
name|scp
operator|->
name|mode
argument_list|)
expr_stmt|;
name|Crtat
operator|=
operator|(
name|u_short
operator|*
operator|)
name|adp
operator|->
name|va_window
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|scp
operator|->
name|status
operator|&
name|GRAPHICS_MODE
operator|)
condition|)
block|{
comment|/* load appropriate font */
if|if
condition|(
operator|!
operator|(
name|scp
operator|->
name|status
operator|&
name|PIXEL_MODE
operator|)
operator|&&
name|ISFONTAVAIL
argument_list|(
name|get_adapter
argument_list|(
name|scp
argument_list|)
operator|->
name|va_flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|scp
operator|->
name|font_size
operator|<
literal|14
condition|)
block|{
if|if
condition|(
name|fonts_loaded
operator|&
name|FONT_8
condition|)
name|copy_font
argument_list|(
name|scp
argument_list|,
name|LOAD
argument_list|,
literal|8
argument_list|,
name|font_8
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scp
operator|->
name|font_size
operator|>=
literal|16
condition|)
block|{
if|if
condition|(
name|fonts_loaded
operator|&
name|FONT_16
condition|)
name|copy_font
argument_list|(
name|scp
argument_list|,
name|LOAD
argument_list|,
literal|16
argument_list|,
name|font_16
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fonts_loaded
operator|&
name|FONT_14
condition|)
name|copy_font
argument_list|(
name|scp
argument_list|,
name|LOAD
argument_list|,
literal|14
argument_list|,
name|font_14
argument_list|)
expr_stmt|;
block|}
comment|/* 	    * FONT KLUDGE: 	    * This is an interim kludge to display correct font. 	    * Always use the font page #0 on the video plane 2. 	    * Somehow we cannot show the font in other font pages on 	    * some video cards... XXX 	    */
call|(
modifier|*
name|biosvidsw
operator|.
name|show_font
call|)
argument_list|(
name|scp
operator|->
name|adp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|PIXEL_MODE
condition|)
name|generic_bzero
argument_list|(
operator|(
name|u_char
operator|*
operator|)
operator|(
name|adp
operator|->
name|va_window
operator|)
argument_list|,
name|scp
operator|->
name|xpixel
operator|*
name|scp
operator|->
name|ypixel
operator|/
literal|8
argument_list|)
expr_stmt|;
name|set_border
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|border
argument_list|)
expr_stmt|;
comment|/* move hardware cursor out of the way */
call|(
modifier|*
name|biosvidsw
operator|.
name|set_hw_cursor
call|)
argument_list|(
name|scp
operator|->
name|adp
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|set_border
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|color
parameter_list|)
block|{
name|u_char
modifier|*
name|p
decl_stmt|;
name|int
name|xoff
decl_stmt|;
name|int
name|yoff
decl_stmt|;
name|int
name|xlen
decl_stmt|;
name|int
name|ylen
decl_stmt|;
name|int
name|i
decl_stmt|;
call|(
modifier|*
name|biosvidsw
operator|.
name|set_border
call|)
argument_list|(
name|scp
operator|->
name|adp
argument_list|,
name|color
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|PIXEL_MODE
condition|)
block|{
name|outw
argument_list|(
name|GDCIDX
argument_list|,
literal|0x0005
argument_list|)
expr_stmt|;
comment|/* read mode 0, write mode 0 */
name|outw
argument_list|(
name|GDCIDX
argument_list|,
literal|0x0003
argument_list|)
expr_stmt|;
comment|/* data rotate/function select */
name|outw
argument_list|(
name|GDCIDX
argument_list|,
literal|0x0f01
argument_list|)
expr_stmt|;
comment|/* set/reset enable */
name|outw
argument_list|(
name|GDCIDX
argument_list|,
literal|0xff08
argument_list|)
expr_stmt|;
comment|/* bit mask */
name|outw
argument_list|(
name|GDCIDX
argument_list|,
operator|(
name|color
operator|<<
literal|8
operator|)
operator||
literal|0x00
argument_list|)
expr_stmt|;
comment|/* set/reset */
name|p
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|get_adapter
argument_list|(
name|scp
argument_list|)
operator|->
name|va_window
operator|)
expr_stmt|;
name|xoff
operator|=
name|scp
operator|->
name|xoff
expr_stmt|;
name|yoff
operator|=
name|scp
operator|->
name|yoff
operator|*
name|scp
operator|->
name|font_size
expr_stmt|;
name|xlen
operator|=
name|scp
operator|->
name|xpixel
operator|/
literal|8
expr_stmt|;
name|ylen
operator|=
name|scp
operator|->
name|ysize
operator|*
name|scp
operator|->
name|font_size
expr_stmt|;
if|if
condition|(
name|yoff
operator|>
literal|0
condition|)
block|{
name|generic_bzero
argument_list|(
name|p
argument_list|,
name|xlen
operator|*
name|yoff
argument_list|)
expr_stmt|;
name|generic_bzero
argument_list|(
name|p
operator|+
name|xlen
operator|*
operator|(
name|yoff
operator|+
name|ylen
operator|)
argument_list|,
name|xlen
operator|*
name|scp
operator|->
name|ypixel
operator|-
name|xlen
operator|*
operator|(
name|yoff
operator|+
name|ylen
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xoff
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ylen
condition|;
operator|++
name|i
control|)
block|{
name|generic_bzero
argument_list|(
name|p
operator|+
name|xlen
operator|*
operator|(
name|yoff
operator|+
name|i
operator|)
argument_list|,
name|xoff
argument_list|)
expr_stmt|;
name|generic_bzero
argument_list|(
name|p
operator|+
name|xlen
operator|*
operator|(
name|yoff
operator|+
name|i
operator|)
operator|+
name|xoff
operator|+
name|scp
operator|->
name|xsize
argument_list|,
name|xlen
operator|-
name|xoff
operator|-
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
block|}
block|}
name|outw
argument_list|(
name|GDCIDX
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
comment|/* set/reset */
name|outw
argument_list|(
name|GDCIDX
argument_list|,
literal|0x0001
argument_list|)
expr_stmt|;
comment|/* set/reset enable */
block|}
block|}
end_function

begin_function
name|void
name|copy_font
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|operation
parameter_list|,
name|int
name|font_size
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|)
block|{
comment|/*      * FONT KLUDGE:      * This is an interim kludge to display correct font.      * Always use the font page #0 on the video plane 2.      * Somehow we cannot show the font in other font pages on      * some video cards... XXX      */
name|font_loading_in_progress
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|operation
operator|==
name|LOAD
condition|)
block|{
call|(
modifier|*
name|biosvidsw
operator|.
name|load_font
call|)
argument_list|(
name|scp
operator|->
name|adp
argument_list|,
literal|0
argument_list|,
name|font_size
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
literal|256
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|CHAR_CURSOR
condition|)
name|set_destructive_cursor
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|operation
operator|==
name|SAVE
condition|)
block|{
call|(
modifier|*
name|biosvidsw
operator|.
name|save_font
call|)
argument_list|(
name|scp
operator|->
name|adp
argument_list|,
literal|0
argument_list|,
name|font_size
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
literal|256
argument_list|)
expr_stmt|;
block|}
name|font_loading_in_progress
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_destructive_cursor
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|u_char
name|cursor
index|[
literal|32
index|]
decl_stmt|;
name|u_char
modifier|*
name|font_buffer
decl_stmt|;
name|int
name|font_size
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|ISFONTAVAIL
argument_list|(
name|get_adapter
argument_list|(
name|scp
argument_list|)
operator|->
name|va_flags
argument_list|)
operator|||
operator|!
name|ISTEXTSC
argument_list|(
name|scp
argument_list|)
condition|)
return|return;
if|if
condition|(
name|scp
operator|->
name|font_size
operator|<
literal|14
condition|)
block|{
name|font_buffer
operator|=
name|font_8
expr_stmt|;
name|font_size
operator|=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scp
operator|->
name|font_size
operator|>=
literal|16
condition|)
block|{
name|font_buffer
operator|=
name|font_16
expr_stmt|;
name|font_size
operator|=
literal|16
expr_stmt|;
block|}
else|else
block|{
name|font_buffer
operator|=
name|font_14
expr_stmt|;
name|font_size
operator|=
literal|14
expr_stmt|;
block|}
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_VISIBLE
condition|)
block|{
if|if
condition|(
operator|(
name|scp
operator|->
name|cursor_saveunder
operator|&
literal|0xff
operator|)
operator|==
name|SC_MOUSE_CHAR
condition|)
name|bcopy
argument_list|(
operator|&
name|scp
operator|->
name|mouse_cursor
index|[
literal|0
index|]
argument_list|,
name|cursor
argument_list|,
name|scp
operator|->
name|font_size
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|scp
operator|->
name|cursor_saveunder
operator|&
literal|0xff
operator|)
operator|==
name|SC_MOUSE_CHAR
operator|+
literal|1
condition|)
name|bcopy
argument_list|(
operator|&
name|scp
operator|->
name|mouse_cursor
index|[
literal|32
index|]
argument_list|,
name|cursor
argument_list|,
name|scp
operator|->
name|font_size
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|scp
operator|->
name|cursor_saveunder
operator|&
literal|0xff
operator|)
operator|==
name|SC_MOUSE_CHAR
operator|+
literal|2
condition|)
name|bcopy
argument_list|(
operator|&
name|scp
operator|->
name|mouse_cursor
index|[
literal|64
index|]
argument_list|,
name|cursor
argument_list|,
name|scp
operator|->
name|font_size
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|scp
operator|->
name|cursor_saveunder
operator|&
literal|0xff
operator|)
operator|==
name|SC_MOUSE_CHAR
operator|+
literal|3
condition|)
name|bcopy
argument_list|(
operator|&
name|scp
operator|->
name|mouse_cursor
index|[
literal|96
index|]
argument_list|,
name|cursor
argument_list|,
name|scp
operator|->
name|font_size
argument_list|)
expr_stmt|;
else|else
name|bcopy
argument_list|(
name|font_buffer
operator|+
operator|(
operator|(
name|scp
operator|->
name|cursor_saveunder
operator|&
literal|0xff
operator|)
operator|*
name|scp
operator|->
name|font_size
operator|)
argument_list|,
name|cursor
argument_list|,
name|scp
operator|->
name|font_size
argument_list|)
expr_stmt|;
block|}
else|else
name|bcopy
argument_list|(
name|font_buffer
operator|+
operator|(
operator|(
name|scp
operator|->
name|cursor_saveunder
operator|&
literal|0xff
operator|)
operator|*
name|scp
operator|->
name|font_size
operator|)
argument_list|,
name|cursor
argument_list|,
name|scp
operator|->
name|font_size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|i
operator|>=
name|scp
operator|->
name|cursor_start
operator|&&
name|i
operator|<=
name|scp
operator|->
name|cursor_end
operator|)
operator|||
operator|(
name|scp
operator|->
name|cursor_start
operator|>=
name|scp
operator|->
name|font_size
operator|&&
name|i
operator|==
name|scp
operator|->
name|font_size
operator|-
literal|1
operator|)
condition|)
name|cursor
index|[
name|i
index|]
operator||=
literal|0xff
expr_stmt|;
if|#
directive|if
literal|1
while|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|crtc_addr
operator|+
literal|6
argument_list|)
operator|&
literal|0x08
operator|)
condition|)
comment|/* wait for vertical retrace */
empty_stmt|;
endif|#
directive|endif
name|font_loading_in_progress
operator|=
name|TRUE
expr_stmt|;
call|(
modifier|*
name|biosvidsw
operator|.
name|load_font
call|)
argument_list|(
name|scp
operator|->
name|adp
argument_list|,
literal|0
argument_list|,
name|font_size
argument_list|,
name|cursor
argument_list|,
name|DEAD_CHAR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|font_loading_in_progress
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sc_move_mouse
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
name|scp
operator|->
name|mouse_xpos
operator|=
name|x
expr_stmt|;
name|scp
operator|->
name|mouse_ypos
operator|=
name|y
expr_stmt|;
name|scp
operator|->
name|mouse_pos
operator|=
name|scp
operator|->
name|mouse_oldpos
operator|=
name|scp
operator|->
name|scr_buf
operator|+
operator|(
name|y
operator|/
name|scp
operator|->
name|font_size
operator|)
operator|*
name|scp
operator|->
name|xsize
operator|+
name|x
operator|/
literal|8
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_mouse_pos
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
specifier|static
name|int
name|last_xpos
init|=
operator|-
literal|1
decl_stmt|,
name|last_ypos
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|scp
operator|->
name|mouse_xpos
operator|<
literal|0
condition|)
name|scp
operator|->
name|mouse_xpos
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|mouse_ypos
operator|<
literal|0
condition|)
name|scp
operator|->
name|mouse_ypos
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|ISTEXTSC
argument_list|(
name|scp
argument_list|)
condition|)
block|{
if|if
condition|(
name|scp
operator|->
name|mouse_xpos
operator|>
name|scp
operator|->
name|xpixel
operator|-
literal|1
condition|)
name|scp
operator|->
name|mouse_xpos
operator|=
name|scp
operator|->
name|xpixel
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|mouse_ypos
operator|>
name|scp
operator|->
name|ypixel
operator|-
literal|1
condition|)
name|scp
operator|->
name|mouse_ypos
operator|=
name|scp
operator|->
name|ypixel
operator|-
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|scp
operator|->
name|mouse_xpos
operator|>
operator|(
name|scp
operator|->
name|xsize
operator|*
literal|8
operator|)
operator|-
literal|1
condition|)
name|scp
operator|->
name|mouse_xpos
operator|=
operator|(
name|scp
operator|->
name|xsize
operator|*
literal|8
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|mouse_ypos
operator|>
operator|(
name|scp
operator|->
name|ysize
operator|*
name|scp
operator|->
name|font_size
operator|)
operator|-
literal|1
condition|)
name|scp
operator|->
name|mouse_ypos
operator|=
operator|(
name|scp
operator|->
name|ysize
operator|*
name|scp
operator|->
name|font_size
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|mouse_xpos
operator|!=
name|last_xpos
operator|||
name|scp
operator|->
name|mouse_ypos
operator|!=
name|last_ypos
condition|)
block|{
name|scp
operator|->
name|status
operator||=
name|MOUSE_MOVED
expr_stmt|;
name|scp
operator|->
name|mouse_pos
operator|=
name|scp
operator|->
name|scr_buf
operator|+
operator|(
operator|(
name|scp
operator|->
name|mouse_ypos
operator|/
name|scp
operator|->
name|font_size
operator|)
operator|*
name|scp
operator|->
name|xsize
operator|+
name|scp
operator|->
name|mouse_xpos
operator|/
literal|8
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_VISIBLE
operator|)
operator|&&
operator|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_CUTTING
operator|)
condition|)
name|mouse_cut
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|isspace
parameter_list|(
name|c
parameter_list|)
value|(((c)& 0xff) == ' ')
end_define

begin_function
specifier|static
name|int
name|skip_spc_right
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|u_short
modifier|*
name|p
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|p
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|%
name|scp
operator|->
name|xsize
init|;
name|i
operator|<
name|scp
operator|->
name|xsize
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
break|break;
operator|++
name|p
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|skip_spc_left
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|u_short
modifier|*
name|p
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|p
operator|--
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|%
name|scp
operator|->
name|xsize
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
break|break;
operator|--
name|p
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mouse_cut
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|u_short
modifier|*
name|end
decl_stmt|;
name|u_short
modifier|*
name|p
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
name|scp
operator|->
name|mouse_cut_end
operator|=
operator|(
name|scp
operator|->
name|mouse_pos
operator|>=
name|scp
operator|->
name|mouse_cut_start
operator|)
condition|?
name|scp
operator|->
name|mouse_pos
operator|+
literal|1
else|:
name|scp
operator|->
name|mouse_pos
expr_stmt|;
name|end
operator|=
operator|(
name|scp
operator|->
name|mouse_cut_start
operator|>
name|scp
operator|->
name|mouse_cut_end
operator|)
condition|?
name|scp
operator|->
name|mouse_cut_start
else|:
name|scp
operator|->
name|mouse_cut_end
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|(
name|scp
operator|->
name|mouse_cut_start
operator|>
name|scp
operator|->
name|mouse_cut_end
operator|)
condition|?
name|scp
operator|->
name|mouse_cut_end
else|:
name|scp
operator|->
name|mouse_cut_start
init|;
name|p
operator|<
name|end
condition|;
operator|++
name|p
control|)
block|{
name|cut_buffer
index|[
name|i
index|]
operator|=
operator|*
name|p
operator|&
literal|0xff
expr_stmt|;
comment|/* remember the position of the last non-space char */
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|cut_buffer
index|[
name|i
operator|++
index|]
argument_list|)
condition|)
name|j
operator|=
name|i
expr_stmt|;
comment|/* trim trailing blank when crossing lines */
if|if
condition|(
operator|(
operator|(
name|p
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|%
name|scp
operator|->
name|xsize
operator|)
operator|==
operator|(
name|scp
operator|->
name|xsize
operator|-
literal|1
operator|)
condition|)
block|{
name|cut_buffer
index|[
name|j
operator|++
index|]
operator|=
literal|'\r'
expr_stmt|;
name|i
operator|=
name|j
expr_stmt|;
block|}
block|}
name|cut_buffer
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* scan towards the end of the last line */
operator|--
name|p
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|p
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|%
name|scp
operator|->
name|xsize
init|;
name|i
operator|<
name|scp
operator|->
name|xsize
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
break|break;
operator|++
name|p
expr_stmt|;
block|}
comment|/* if there is nothing but blank chars, trim them, but mark towards eol */
if|if
condition|(
name|i
operator|>=
name|scp
operator|->
name|xsize
condition|)
block|{
if|if
condition|(
name|scp
operator|->
name|mouse_cut_start
operator|>
name|scp
operator|->
name|mouse_cut_end
condition|)
name|scp
operator|->
name|mouse_cut_start
operator|=
name|p
expr_stmt|;
else|else
name|scp
operator|->
name|mouse_cut_end
operator|=
name|p
expr_stmt|;
name|cut_buffer
index|[
name|j
operator|++
index|]
operator|=
literal|'\r'
expr_stmt|;
name|cut_buffer
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|mouse_cut_start
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|mouse_cut_end
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mouse_cut_start
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_VISIBLE
condition|)
block|{
if|if
condition|(
name|scp
operator|->
name|mouse_pos
operator|==
name|scp
operator|->
name|mouse_cut_start
operator|&&
name|scp
operator|->
name|mouse_cut_start
operator|==
name|scp
operator|->
name|mouse_cut_end
operator|-
literal|1
condition|)
block|{
name|cut_buffer
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|remove_cutmarking
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|skip_spc_right
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|mouse_pos
argument_list|)
operator|>=
name|scp
operator|->
name|xsize
condition|)
block|{
comment|/* if the pointer is on trailing blank chars, mark towards eol */
name|i
operator|=
name|skip_spc_left
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|mouse_pos
argument_list|)
operator|+
literal|1
expr_stmt|;
name|scp
operator|->
name|mouse_cut_start
operator|=
name|scp
operator|->
name|scr_buf
operator|+
operator|(
operator|(
name|scp
operator|->
name|mouse_pos
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|/
name|scp
operator|->
name|xsize
operator|)
operator|*
name|scp
operator|->
name|xsize
operator|+
name|i
expr_stmt|;
name|scp
operator|->
name|mouse_cut_end
operator|=
name|scp
operator|->
name|scr_buf
operator|+
operator|(
operator|(
name|scp
operator|->
name|mouse_pos
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|/
name|scp
operator|->
name|xsize
operator|+
literal|1
operator|)
operator|*
name|scp
operator|->
name|xsize
expr_stmt|;
name|cut_buffer
index|[
literal|0
index|]
operator|=
literal|'\r'
expr_stmt|;
name|cut_buffer
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|scp
operator|->
name|status
operator||=
name|MOUSE_CUTTING
expr_stmt|;
block|}
else|else
block|{
name|scp
operator|->
name|mouse_cut_start
operator|=
name|scp
operator|->
name|mouse_pos
expr_stmt|;
name|scp
operator|->
name|mouse_cut_end
operator|=
name|scp
operator|->
name|mouse_cut_start
operator|+
literal|1
expr_stmt|;
name|cut_buffer
index|[
literal|0
index|]
operator|=
operator|*
name|scp
operator|->
name|mouse_cut_start
operator|&
literal|0xff
expr_stmt|;
name|cut_buffer
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|scp
operator|->
name|status
operator||=
name|MOUSE_CUTTING
expr_stmt|;
block|}
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
comment|/* delete all other screens cut markings */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXCONS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|console
index|[
name|i
index|]
operator|==
name|NULL
operator|||
name|console
index|[
name|i
index|]
operator|==
name|scp
condition|)
continue|continue;
name|remove_cutmarking
argument_list|(
name|console
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mouse_cut_end
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_VISIBLE
condition|)
block|{
name|scp
operator|->
name|status
operator|&=
operator|~
name|MOUSE_CUTTING
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mouse_cut_word
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|u_short
modifier|*
name|p
decl_stmt|;
name|u_short
modifier|*
name|sol
decl_stmt|;
name|u_short
modifier|*
name|eol
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/*      * Because we don't have locale information in the kernel,      * we only distinguish space char and non-space chars.  Punctuation      * chars, symbols and other regular chars are all treated alike.      */
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_VISIBLE
condition|)
block|{
name|sol
operator|=
name|scp
operator|->
name|scr_buf
operator|+
operator|(
operator|(
name|scp
operator|->
name|mouse_pos
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|/
name|scp
operator|->
name|xsize
operator|)
operator|*
name|scp
operator|->
name|xsize
expr_stmt|;
name|eol
operator|=
name|sol
operator|+
name|scp
operator|->
name|xsize
expr_stmt|;
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|scp
operator|->
name|mouse_pos
argument_list|)
condition|)
block|{
for|for
control|(
name|p
operator|=
name|scp
operator|->
name|mouse_pos
init|;
name|p
operator|>=
name|sol
condition|;
operator|--
name|p
control|)
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
break|break;
name|scp
operator|->
name|mouse_cut_start
operator|=
operator|++
name|p
expr_stmt|;
for|for
control|(
name|p
operator|=
name|scp
operator|->
name|mouse_pos
init|;
name|p
operator|<
name|eol
condition|;
operator|++
name|p
control|)
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
break|break;
name|scp
operator|->
name|mouse_cut_end
operator|=
name|p
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|p
operator|=
name|scp
operator|->
name|mouse_pos
init|;
name|p
operator|>=
name|sol
condition|;
operator|--
name|p
control|)
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
break|break;
name|scp
operator|->
name|mouse_cut_start
operator|=
operator|++
name|p
expr_stmt|;
for|for
control|(
name|p
operator|=
name|scp
operator|->
name|mouse_pos
init|;
name|p
operator|<
name|eol
condition|;
operator|++
name|p
control|)
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
break|break;
name|scp
operator|->
name|mouse_cut_end
operator|=
name|p
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|scp
operator|->
name|mouse_cut_start
init|;
name|p
operator|<
name|scp
operator|->
name|mouse_cut_end
condition|;
operator|++
name|p
control|)
name|cut_buffer
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|p
operator|&
literal|0xff
expr_stmt|;
name|cut_buffer
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|scp
operator|->
name|status
operator||=
name|MOUSE_CUTTING
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mouse_cut_line
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|u_short
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_VISIBLE
condition|)
block|{
name|scp
operator|->
name|mouse_cut_start
operator|=
name|scp
operator|->
name|scr_buf
operator|+
operator|(
operator|(
name|scp
operator|->
name|mouse_pos
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|/
name|scp
operator|->
name|xsize
operator|)
operator|*
name|scp
operator|->
name|xsize
expr_stmt|;
name|scp
operator|->
name|mouse_cut_end
operator|=
name|scp
operator|->
name|mouse_cut_start
operator|+
name|scp
operator|->
name|xsize
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|scp
operator|->
name|mouse_cut_start
init|;
name|p
operator|<
name|scp
operator|->
name|mouse_cut_end
condition|;
operator|++
name|p
control|)
name|cut_buffer
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|p
operator|&
literal|0xff
expr_stmt|;
name|cut_buffer
index|[
name|i
operator|++
index|]
operator|=
literal|'\r'
expr_stmt|;
name|cut_buffer
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|scp
operator|->
name|status
operator||=
name|MOUSE_CUTTING
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mouse_cut_extend
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
if|if
condition|(
operator|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_VISIBLE
operator|)
operator|&&
operator|!
operator|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_CUTTING
operator|)
operator|&&
operator|(
name|scp
operator|->
name|mouse_cut_start
operator|!=
name|NULL
operator|)
condition|)
block|{
name|mouse_cut
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|scp
operator|->
name|status
operator||=
name|MOUSE_CUTTING
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mouse_paste
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_VISIBLE
condition|)
block|{
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|u_char
modifier|*
name|ptr
init|=
name|cut_buffer
decl_stmt|;
name|tp
operator|=
name|VIRTUAL_TTY
argument_list|(
name|get_scr_num
argument_list|()
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
condition|)
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|scr_rmap
index|[
operator|*
name|ptr
operator|++
index|]
operator|,
name|tp
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|draw_mouse_image
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|u_short
name|buffer
index|[
literal|32
index|]
decl_stmt|;
name|u_short
name|xoffset
decl_stmt|,
name|yoffset
decl_stmt|;
name|u_short
modifier|*
name|crt_pos
init|=
operator|(
name|u_short
operator|*
operator|)
operator|(
name|get_adapter
argument_list|(
name|scp
argument_list|)
operator|->
name|va_window
operator|)
operator|+
operator|(
name|scp
operator|->
name|mouse_pos
operator|-
name|scp
operator|->
name|scr_buf
operator|)
decl_stmt|;
name|u_char
modifier|*
name|font_buffer
decl_stmt|;
name|int
name|font_size
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|scp
operator|->
name|font_size
operator|<
literal|14
condition|)
block|{
name|font_buffer
operator|=
name|font_8
expr_stmt|;
name|font_size
operator|=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scp
operator|->
name|font_size
operator|>=
literal|16
condition|)
block|{
name|font_buffer
operator|=
name|font_16
expr_stmt|;
name|font_size
operator|=
literal|16
expr_stmt|;
block|}
else|else
block|{
name|font_buffer
operator|=
name|font_14
expr_stmt|;
name|font_size
operator|=
literal|14
expr_stmt|;
block|}
name|xoffset
operator|=
name|scp
operator|->
name|mouse_xpos
operator|%
literal|8
expr_stmt|;
name|yoffset
operator|=
name|scp
operator|->
name|mouse_ypos
operator|%
name|scp
operator|->
name|font_size
expr_stmt|;
comment|/* prepare mousepointer char's bitmaps */
name|bcopy
argument_list|(
name|font_buffer
operator|+
operator|(
operator|(
operator|*
operator|(
name|scp
operator|->
name|mouse_pos
operator|)
operator|&
literal|0xff
operator|)
operator|*
name|font_size
operator|)
argument_list|,
operator|&
name|scp
operator|->
name|mouse_cursor
index|[
literal|0
index|]
argument_list|,
name|font_size
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|font_buffer
operator|+
operator|(
operator|(
operator|*
operator|(
name|scp
operator|->
name|mouse_pos
operator|+
literal|1
operator|)
operator|&
literal|0xff
operator|)
operator|*
name|font_size
operator|)
argument_list|,
operator|&
name|scp
operator|->
name|mouse_cursor
index|[
literal|32
index|]
argument_list|,
name|font_size
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|font_buffer
operator|+
operator|(
operator|(
operator|*
operator|(
name|scp
operator|->
name|mouse_pos
operator|+
name|scp
operator|->
name|xsize
operator|)
operator|&
literal|0xff
operator|)
operator|*
name|font_size
operator|)
argument_list|,
operator|&
name|scp
operator|->
name|mouse_cursor
index|[
literal|64
index|]
argument_list|,
name|font_size
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|font_buffer
operator|+
operator|(
operator|(
operator|*
operator|(
name|scp
operator|->
name|mouse_pos
operator|+
name|scp
operator|->
name|xsize
operator|+
literal|1
operator|)
operator|&
literal|0xff
operator|)
operator|*
name|font_size
operator|)
argument_list|,
operator|&
name|scp
operator|->
name|mouse_cursor
index|[
literal|96
index|]
argument_list|,
name|font_size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|font_size
condition|;
name|i
operator|++
control|)
block|{
name|buffer
index|[
name|i
index|]
operator|=
name|scp
operator|->
name|mouse_cursor
index|[
name|i
index|]
operator|<<
literal|8
operator||
name|scp
operator|->
name|mouse_cursor
index|[
name|i
operator|+
literal|32
index|]
expr_stmt|;
name|buffer
index|[
name|i
operator|+
name|font_size
index|]
operator|=
name|scp
operator|->
name|mouse_cursor
index|[
name|i
operator|+
literal|64
index|]
operator|<<
literal|8
operator||
name|scp
operator|->
name|mouse_cursor
index|[
name|i
operator|+
literal|96
index|]
expr_stmt|;
block|}
comment|/* now and-or in the mousepointer image */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|buffer
index|[
name|i
operator|+
name|yoffset
index|]
operator|=
operator|(
name|buffer
index|[
name|i
operator|+
name|yoffset
index|]
operator|&
operator|~
operator|(
name|mouse_and_mask
index|[
name|i
index|]
operator|>>
name|xoffset
operator|)
operator|)
operator||
operator|(
name|mouse_or_mask
index|[
name|i
index|]
operator|>>
name|xoffset
operator|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|font_size
condition|;
name|i
operator|++
control|)
block|{
name|scp
operator|->
name|mouse_cursor
index|[
name|i
index|]
operator|=
operator|(
name|buffer
index|[
name|i
index|]
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
expr_stmt|;
name|scp
operator|->
name|mouse_cursor
index|[
name|i
operator|+
literal|32
index|]
operator|=
name|buffer
index|[
name|i
index|]
operator|&
literal|0xff
expr_stmt|;
name|scp
operator|->
name|mouse_cursor
index|[
name|i
operator|+
literal|64
index|]
operator|=
operator|(
name|buffer
index|[
name|i
operator|+
name|font_size
index|]
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
expr_stmt|;
name|scp
operator|->
name|mouse_cursor
index|[
name|i
operator|+
literal|96
index|]
operator|=
name|buffer
index|[
name|i
operator|+
name|font_size
index|]
operator|&
literal|0xff
expr_stmt|;
block|}
name|scp
operator|->
name|mouse_oldpos
operator|=
name|scp
operator|->
name|mouse_pos
expr_stmt|;
if|#
directive|if
literal|1
comment|/* wait for vertical retrace to avoid jitter on some videocards */
while|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|crtc_addr
operator|+
literal|6
argument_list|)
operator|&
literal|0x08
operator|)
condition|)
comment|/* idle */
empty_stmt|;
endif|#
directive|endif
name|font_loading_in_progress
operator|=
name|TRUE
expr_stmt|;
call|(
modifier|*
name|biosvidsw
operator|.
name|load_font
call|)
argument_list|(
name|scp
operator|->
name|adp
argument_list|,
literal|0
argument_list|,
literal|32
argument_list|,
name|scp
operator|->
name|mouse_cursor
argument_list|,
name|SC_MOUSE_CHAR
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|font_loading_in_progress
operator|=
name|FALSE
expr_stmt|;
operator|*
operator|(
name|crt_pos
operator|)
operator|=
operator|(
operator|*
operator|(
name|scp
operator|->
name|mouse_pos
operator|)
operator|&
literal|0xff00
operator|)
operator||
name|SC_MOUSE_CHAR
expr_stmt|;
operator|*
operator|(
name|crt_pos
operator|+
name|scp
operator|->
name|xsize
operator|)
operator|=
operator|(
operator|*
operator|(
name|scp
operator|->
name|mouse_pos
operator|+
name|scp
operator|->
name|xsize
operator|)
operator|&
literal|0xff00
operator|)
operator||
operator|(
name|SC_MOUSE_CHAR
operator|+
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|mouse_xpos
operator|<
operator|(
name|scp
operator|->
name|xsize
operator|-
literal|1
operator|)
operator|*
literal|8
condition|)
block|{
operator|*
operator|(
name|crt_pos
operator|+
literal|1
operator|)
operator|=
operator|(
operator|*
operator|(
name|scp
operator|->
name|mouse_pos
operator|+
literal|1
operator|)
operator|&
literal|0xff00
operator|)
operator||
operator|(
name|SC_MOUSE_CHAR
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
operator|(
name|crt_pos
operator|+
name|scp
operator|->
name|xsize
operator|+
literal|1
operator|)
operator|=
operator|(
operator|*
operator|(
name|scp
operator|->
name|mouse_pos
operator|+
name|scp
operator|->
name|xsize
operator|+
literal|1
operator|)
operator|&
literal|0xff00
operator|)
operator||
operator|(
name|SC_MOUSE_CHAR
operator|+
literal|3
operator|)
expr_stmt|;
block|}
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|mouse_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|mouse_pos
operator|+
name|scp
operator|->
name|xsize
operator|+
literal|1
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|remove_mouse_image
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|u_short
modifier|*
name|crt_pos
decl_stmt|;
if|if
condition|(
operator|!
name|ISTEXTSC
argument_list|(
name|scp
argument_list|)
condition|)
return|return;
name|crt_pos
operator|=
operator|(
name|u_short
operator|*
operator|)
operator|(
name|get_adapter
argument_list|(
name|scp
argument_list|)
operator|->
name|va_window
operator|)
operator|+
operator|(
name|scp
operator|->
name|mouse_oldpos
operator|-
name|scp
operator|->
name|scr_buf
operator|)
expr_stmt|;
operator|*
operator|(
name|crt_pos
operator|)
operator|=
operator|*
operator|(
name|scp
operator|->
name|mouse_oldpos
operator|)
expr_stmt|;
operator|*
operator|(
name|crt_pos
operator|+
literal|1
operator|)
operator|=
operator|*
operator|(
name|scp
operator|->
name|mouse_oldpos
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
operator|(
name|crt_pos
operator|+
name|scp
operator|->
name|xsize
operator|)
operator|=
operator|*
operator|(
name|scp
operator|->
name|mouse_oldpos
operator|+
name|scp
operator|->
name|xsize
operator|)
expr_stmt|;
operator|*
operator|(
name|crt_pos
operator|+
name|scp
operator|->
name|xsize
operator|+
literal|1
operator|)
operator|=
operator|*
operator|(
name|scp
operator|->
name|mouse_oldpos
operator|+
name|scp
operator|->
name|xsize
operator|+
literal|1
operator|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|mouse_oldpos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|mouse_oldpos
operator|+
name|scp
operator|->
name|xsize
operator|+
literal|1
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|draw_cutmarking
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|u_short
modifier|*
name|crt_pos
decl_stmt|;
name|u_short
modifier|*
name|ptr
decl_stmt|;
name|u_short
name|och
decl_stmt|,
name|nch
decl_stmt|;
name|crt_pos
operator|=
operator|(
name|u_short
operator|*
operator|)
operator|(
name|get_adapter
argument_list|(
name|scp
argument_list|)
operator|->
name|va_window
operator|)
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|scp
operator|->
name|scr_buf
init|;
name|ptr
operator|<=
operator|(
name|scp
operator|->
name|scr_buf
operator|+
operator|(
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
operator|)
operator|)
condition|;
name|ptr
operator|++
control|)
block|{
name|nch
operator|=
name|och
operator|=
operator|*
operator|(
name|crt_pos
operator|+
operator|(
name|ptr
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|)
expr_stmt|;
comment|/* are we outside the selected area ? */
if|if
condition|(
name|ptr
operator|<
operator|(
name|scp
operator|->
name|mouse_cut_start
operator|>
name|scp
operator|->
name|mouse_cut_end
condition|?
name|scp
operator|->
name|mouse_cut_end
else|:
name|scp
operator|->
name|mouse_cut_start
operator|)
operator|||
name|ptr
operator|>=
operator|(
name|scp
operator|->
name|mouse_cut_start
operator|>
name|scp
operator|->
name|mouse_cut_end
condition|?
name|scp
operator|->
name|mouse_cut_start
else|:
name|scp
operator|->
name|mouse_cut_end
operator|)
condition|)
block|{
if|if
condition|(
name|ptr
operator|!=
name|scp
operator|->
name|cursor_pos
condition|)
name|nch
operator|=
operator|(
name|och
operator|&
literal|0xff
operator|)
operator||
operator|(
operator|*
name|ptr
operator|&
literal|0xff00
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* are we clear of the cursor image ? */
if|if
condition|(
name|ptr
operator|!=
name|scp
operator|->
name|cursor_pos
condition|)
name|nch
operator|=
operator|(
name|och
operator|&
literal|0x88ff
operator|)
operator||
operator|(
operator|*
name|ptr
operator|&
literal|0x7000
operator|)
operator|>>
literal|4
operator||
operator|(
operator|*
name|ptr
operator|&
literal|0x0700
operator|)
operator|<<
literal|4
expr_stmt|;
else|else
block|{
if|if
condition|(
name|flags
operator|&
name|CHAR_CURSOR
condition|)
name|nch
operator|=
operator|(
name|och
operator|&
literal|0x88ff
operator|)
operator||
operator|(
operator|*
name|ptr
operator|&
literal|0x7000
operator|)
operator|>>
literal|4
operator||
operator|(
operator|*
name|ptr
operator|&
literal|0x0700
operator|)
operator|<<
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|BLINK_CURSOR
operator|)
condition|)
name|nch
operator|=
operator|(
name|och
operator|&
literal|0xff
operator|)
operator||
operator|(
operator|*
name|ptr
operator|&
literal|0xff00
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nch
operator|!=
name|och
condition|)
operator|*
operator|(
name|crt_pos
operator|+
operator|(
name|ptr
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|)
operator|=
name|nch
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|remove_cutmarking
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|scp
operator|->
name|mouse_cut_start
operator|=
name|scp
operator|->
name|mouse_cut_end
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|status
operator|&=
operator|~
name|MOUSE_CUTTING
expr_stmt|;
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_bell
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|pitch
parameter_list|,
name|int
name|duration
parameter_list|)
block|{
if|if
condition|(
name|cold
operator|||
name|shutdown_in_progress
condition|)
return|return;
if|if
condition|(
name|scp
operator|!=
name|cur_console
operator|&&
operator|(
name|flags
operator|&
name|QUIET_BELL
operator|)
condition|)
return|return;
if|if
condition|(
name|flags
operator|&
name|VISUAL_BELL
condition|)
block|{
if|if
condition|(
name|blink_in_progress
condition|)
return|return;
name|blink_in_progress
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|scp
operator|!=
name|cur_console
condition|)
name|blink_in_progress
operator|+=
literal|2
expr_stmt|;
name|blink_screen
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|scp
operator|!=
name|cur_console
condition|)
name|pitch
operator|*=
literal|2
expr_stmt|;
name|sysbeep
argument_list|(
name|pitch
argument_list|,
name|duration
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|blink_screen
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|scr_stat
modifier|*
name|scp
init|=
name|arg
decl_stmt|;
if|if
condition|(
operator|!
name|ISTEXTSC
argument_list|(
name|scp
argument_list|)
operator|||
operator|(
name|blink_in_progress
operator|<=
literal|1
operator|)
condition|)
block|{
name|blink_in_progress
operator|=
name|FALSE
expr_stmt|;
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
if|if
condition|(
name|delayed_next_scr
condition|)
name|switch_scr
argument_list|(
name|scp
argument_list|,
name|delayed_next_scr
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|blink_in_progress
operator|&
literal|1
condition|)
name|fillw
argument_list|(
name|kernel_default
operator|.
name|std_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
operator|(
name|u_short
operator|*
operator|)
operator|(
name|get_adapter
argument_list|(
name|scp
argument_list|)
operator|->
name|va_window
operator|)
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
argument_list|)
expr_stmt|;
else|else
name|fillw
argument_list|(
name|kernel_default
operator|.
name|rev_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
operator|(
name|u_short
operator|*
operator|)
operator|(
name|get_adapter
argument_list|(
name|scp
argument_list|)
operator|->
name|va_window
operator|)
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
argument_list|)
expr_stmt|;
name|blink_in_progress
operator|--
expr_stmt|;
name|timeout
argument_list|(
name|blink_screen
argument_list|,
name|scp
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sc_bcopy
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|u_short
modifier|*
name|p
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|,
name|int
name|mark
parameter_list|)
block|{
name|u_char
modifier|*
name|font
decl_stmt|;
name|u_char
specifier|volatile
modifier|*
name|d
decl_stmt|;
name|u_char
modifier|*
name|e
decl_stmt|;
name|u_char
modifier|*
name|f
decl_stmt|;
name|int
name|font_size
decl_stmt|;
name|int
name|line_length
decl_stmt|;
name|int
name|xsize
decl_stmt|;
name|u_short
name|bg
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|u_char
name|c
decl_stmt|;
if|if
condition|(
name|ISTEXTSC
argument_list|(
name|scp
argument_list|)
condition|)
block|{
name|generic_bcopy
argument_list|(
name|p
operator|+
name|from
argument_list|,
operator|(
name|u_short
operator|*
operator|)
operator|(
name|get_adapter
argument_list|(
name|scp
argument_list|)
operator|->
name|va_window
operator|)
operator|+
name|from
argument_list|,
operator|(
name|to
operator|-
name|from
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* if ISPIXELSC(scp) */
block|{
if|if
condition|(
name|mark
condition|)
name|mark
operator|=
literal|255
expr_stmt|;
name|font_size
operator|=
name|scp
operator|->
name|font_size
expr_stmt|;
if|if
condition|(
name|font_size
operator|<
literal|14
condition|)
name|font
operator|=
name|font_8
expr_stmt|;
elseif|else
if|if
condition|(
name|font_size
operator|>=
literal|16
condition|)
name|font
operator|=
name|font_16
expr_stmt|;
else|else
name|font
operator|=
name|font_14
expr_stmt|;
name|line_length
operator|=
name|scp
operator|->
name|xpixel
operator|/
literal|8
expr_stmt|;
name|xsize
operator|=
name|scp
operator|->
name|xsize
expr_stmt|;
name|d
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|get_adapter
argument_list|(
name|scp
argument_list|)
operator|->
name|va_window
operator|)
operator|+
name|scp
operator|->
name|xoff
operator|+
name|scp
operator|->
name|yoff
operator|*
name|font_size
operator|*
name|line_length
operator|+
operator|(
name|from
operator|%
name|xsize
operator|)
operator|+
name|font_size
operator|*
name|line_length
operator|*
operator|(
name|from
operator|/
name|xsize
operator|)
expr_stmt|;
name|outw
argument_list|(
name|GDCIDX
argument_list|,
literal|0x0005
argument_list|)
expr_stmt|;
comment|/* read mode 0, write mode 0 */
name|outw
argument_list|(
name|GDCIDX
argument_list|,
literal|0x0003
argument_list|)
expr_stmt|;
comment|/* data rotate/function select */
name|outw
argument_list|(
name|GDCIDX
argument_list|,
literal|0x0f01
argument_list|)
expr_stmt|;
comment|/* set/reset enable */
name|bg
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|from
init|;
name|i
operator|<=
name|to
condition|;
name|i
operator|++
control|)
block|{
comment|/* set background color in EGA/VGA latch */
if|if
condition|(
name|bg
operator|!=
operator|(
name|p
index|[
name|i
index|]
operator|&
literal|0xf000
operator|)
condition|)
block|{
name|bg
operator|=
operator|(
name|p
index|[
name|i
index|]
operator|&
literal|0xf000
operator|)
expr_stmt|;
name|outw
argument_list|(
name|GDCIDX
argument_list|,
operator|(
name|bg
operator|>>
literal|4
operator|)
operator||
literal|0x00
argument_list|)
expr_stmt|;
comment|/* set/reset */
name|outw
argument_list|(
name|GDCIDX
argument_list|,
literal|0xff08
argument_list|)
expr_stmt|;
comment|/* bit mask */
operator|*
name|d
operator|=
literal|0
expr_stmt|;
name|c
operator|=
operator|*
name|d
expr_stmt|;
comment|/* set the background color in the latch */
block|}
comment|/* foreground color */
name|outw
argument_list|(
name|GDCIDX
argument_list|,
operator|(
name|p
index|[
name|i
index|]
operator|&
literal|0x0f00
operator|)
operator||
literal|0x00
argument_list|)
expr_stmt|;
comment|/* set/reset */
name|e
operator|=
operator|(
name|u_char
operator|*
operator|)
name|d
expr_stmt|;
name|f
operator|=
operator|&
name|font
index|[
operator|(
name|p
index|[
name|i
index|]
operator|&
literal|0x00ff
operator|)
operator|*
name|font_size
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|font_size
condition|;
name|j
operator|++
operator|,
name|f
operator|++
control|)
block|{
name|outw
argument_list|(
name|GDCIDX
argument_list|,
operator|(
operator|(
operator|*
name|f
operator|^
name|mark
operator|)
operator|<<
literal|8
operator|)
operator||
literal|0x08
argument_list|)
expr_stmt|;
comment|/* bit mask */
operator|*
name|e
operator|=
literal|0
expr_stmt|;
name|e
operator|+=
name|line_length
expr_stmt|;
block|}
name|d
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|%
name|xsize
operator|)
operator|==
name|xsize
operator|-
literal|1
condition|)
name|d
operator|+=
name|scp
operator|->
name|xoff
operator|*
literal|2
operator|+
operator|(
name|font_size
operator|-
literal|1
operator|)
operator|*
name|line_length
expr_stmt|;
block|}
name|outw
argument_list|(
name|GDCIDX
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
comment|/* set/reset */
name|outw
argument_list|(
name|GDCIDX
argument_list|,
literal|0x0001
argument_list|)
expr_stmt|;
comment|/* set/reset enable */
name|outw
argument_list|(
name|GDCIDX
argument_list|,
literal|0xff08
argument_list|)
expr_stmt|;
comment|/* bit mask */
if|#
directive|if
literal|0
comment|/* VGA only */
block|outw(GDCIDX, 0x0305);
comment|/* read mode 0, write mode 3 */
block|outw(GDCIDX, 0x0003);
comment|/* data rotate/function select */
block|outw(GDCIDX, 0x0f01);
comment|/* set/reset enable */
block|outw(GDCIDX, 0xff08);
comment|/* bit mask */
block|bg = -1; 	for (i = from ; i<= to ; i++) {
comment|/* set background color in EGA/VGA latch */
block|if (bg != (p[i]& 0xf000)) { 		bg = (p[i]& 0xf000); 		outw(GDCIDX, 0x0005);
comment|/* read mode 0, write mode 0 */
block|outw(GDCIDX, (bg>> 4) | 0x00);
comment|/* set/reset */
block|*d = 0; 		c = *d;
comment|/* set the background color in the latch */
block|outw(GDCIDX, 0x0305);
comment|/* read mode 0, write mode 3 */
block|}
comment|/* foreground color */
block|outw(GDCIDX, (p[i]& 0x0f00) | 0x00);
comment|/* set/reset */
block|e = (u_char *)d; 	    f =&font[(p[i]& 0x00ff)*font_size]; 	    for (j = 0 ; j< font_size; j++, f++) { 	        *e = *f^mark; 		e += line_length; 	    } 	    d++; 	    if ((i % xsize) == xsize - 1) 		d += scp->xoff*2 + (font_size - 1)*line_length; 	} 	outw(GDCIDX, 0x0005);
comment|/* read mode 0, write mode 0 */
block|outw(GDCIDX, 0x0000);
comment|/* set/reset */
block|outw(GDCIDX, 0x0001);
comment|/* set/reset enable */
endif|#
directive|endif
comment|/* 0 */
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SC_SPLASH_SCREEN
end_ifdef

begin_function
specifier|static
name|void
name|scsplash_init
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|video_info_t
name|info
decl_stmt|;
if|if
condition|(
name|scsplash_load
argument_list|(
name|scp
argument_list|)
operator|==
literal|0
operator|&&
name|add_scrn_saver
argument_list|(
name|scsplash_saver
argument_list|)
operator|==
literal|0
condition|)
block|{
name|default_saver
operator|=
name|scsplash_saver
expr_stmt|;
name|scrn_blank_time
operator|=
name|DEFAULT_BLANKTIME
expr_stmt|;
name|run_scrn_saver
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|boothowto
operator|&
operator|(
name|RB_VERBOSE
operator||
name|RB_CONFIG
operator|)
operator|)
condition|)
block|{
name|scsplash_stick
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|scsplash_saver
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|scsplash_term
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|default_saver
operator|=
name|none_saver
expr_stmt|;
name|scsplash_stick
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|remove_scrn_saver
argument_list|(
name|scsplash_saver
argument_list|)
expr_stmt|;
name|scsplash_unload
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|scsplash_saver
parameter_list|(
name|int
name|show
parameter_list|)
block|{
if|if
condition|(
name|show
condition|)
name|scsplash
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|sticky_splash
condition|)
name|scsplash
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SC_SPLASH_SCREEN */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NSC */
end_comment

end_unit

