begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992-1998 SÃ¸ren Schmidt  * All rights reserved.  *  * This code is derived from software contributed to The DragonFly Project  * by Sascha Wildner<saw@online.de>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification, immediately at the beginning of the file.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_compat.h"
end_include

begin_include
include|#
directive|include
file|"opt_syscons.h"
end_include

begin_include
include|#
directive|include
file|"opt_splash.h"
end_include

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/cons.h>
end_include

begin_include
include|#
directive|include
file|<sys/consio.h>
end_include

begin_include
include|#
directive|include
file|<sys/kdb.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/fbio.h>
end_include

begin_include
include|#
directive|include
file|<sys/kbio.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/random.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_include
include|#
directive|include
file|<sys/serial.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/power.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__sparc64__
argument_list|)
operator|||
name|defined
argument_list|(
name|__powerpc__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<machine/sc_machdep.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<machine/pc/display.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<machine/psl.h>
end_include

begin_include
include|#
directive|include
file|<machine/frame.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_include
include|#
directive|include
file|<dev/kbd/kbdreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/fb/fbreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/fb/splashreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/syscons/syscons.h>
end_include

begin_define
define|#
directive|define
name|COLD
value|0
end_define

begin_define
define|#
directive|define
name|WARM
value|1
end_define

begin_define
define|#
directive|define
name|DEFAULT_BLANKTIME
value|(5*60)
end_define

begin_comment
comment|/* 5 minutes */
end_comment

begin_define
define|#
directive|define
name|MAX_BLANKTIME
value|(7*24*60*60)
end_define

begin_comment
comment|/* 7 days!? */
end_comment

begin_define
define|#
directive|define
name|KEYCODE_BS
value|0x0e
end_define

begin_comment
comment|/* "<-- Backspace" key, XXX */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|default_attr
block|{
name|int
name|std_color
decl_stmt|;
comment|/* normal hardware color */
name|int
name|rev_color
decl_stmt|;
comment|/* reverse hardware color */
block|}
name|default_attr
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|default_attr
name|user_default
init|=
block|{
name|SC_NORM_ATTR
block|,
name|SC_NORM_REV_ATTR
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sc_console_unit
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sc_saver_keyb_only
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|scr_stat
modifier|*
name|sc_console
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|consdev
modifier|*
name|sc_consptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|scr_stat
name|main_console
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|tty
modifier|*
name|main_devs
index|[
name|MAXCONS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|init_done
init|=
name|COLD
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|shutdown_in_progress
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|suspend_in_progress
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|sc_malloc
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|saver_mode
init|=
name|CONS_NO_SAVER
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* LKM/user saver */
end_comment

begin_decl_stmt
specifier|static
name|int
name|run_scrn_saver
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* should run the saver? */
end_comment

begin_decl_stmt
specifier|static
name|int
name|enable_bell
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* enable beeper */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SC_DISABLE_REBOOT
end_ifndef

begin_decl_stmt
specifier|static
name|int
name|enable_reboot
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* enable keyboard reboot */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SC_DISABLE_KDBKEY
end_ifndef

begin_decl_stmt
specifier|static
name|int
name|enable_kdbkey
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* enable keyboard debug */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|long
name|scrn_blank_time
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* screen saver timeout value */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEV_SPLASH
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|scrn_blanked
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of blanked screen */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sticky_splash
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|none_saver
parameter_list|(
name|sc_softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|blank
parameter_list|)
block|{ }
end_function

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|current_saver
function_decl|)
parameter_list|(
name|sc_softc_t
modifier|*
parameter_list|,
name|int
parameter_list|)
init|=
name|none_saver
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SC_NO_SUSPEND_VTYSWITCH
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|sc_no_suspend_vtswitch
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|int
name|sc_no_suspend_vtswitch
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|sc_susp_scr
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|syscons
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"syscons"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw_syscons
argument_list|,
name|OID_AUTO
argument_list|,
name|saver
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"saver"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_syscons_saver
argument_list|,
name|OID_AUTO
argument_list|,
name|keybonly
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc_saver_keyb_only
argument_list|,
literal|0
argument_list|,
literal|"screen saver interrupted by input only"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_syscons
argument_list|,
name|OID_AUTO
argument_list|,
name|bell
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|enable_bell
argument_list|,
literal|0
argument_list|,
literal|"enable bell"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|SC_DISABLE_REBOOT
end_ifndef

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_syscons
argument_list|,
name|OID_AUTO
argument_list|,
name|kbd_reboot
argument_list|,
name|CTLFLAG_RW
operator||
name|CTLFLAG_SECURE
argument_list|,
operator|&
name|enable_reboot
argument_list|,
literal|0
argument_list|,
literal|"enable keyboard reboot"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SC_DISABLE_KDBKEY
end_ifndef

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_syscons
argument_list|,
name|OID_AUTO
argument_list|,
name|kbd_debug
argument_list|,
name|CTLFLAG_RW
operator||
name|CTLFLAG_SECURE
argument_list|,
operator|&
name|enable_kdbkey
argument_list|,
literal|0
argument_list|,
literal|"enable keyboard debug"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.syscons.sc_no_suspend_vtswitch"
argument_list|,
operator|&
name|sc_no_suspend_vtswitch
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_syscons
argument_list|,
name|OID_AUTO
argument_list|,
name|sc_no_suspend_vtswitch
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc_no_suspend_vtswitch
argument_list|,
literal|0
argument_list|,
literal|"Disable VT switch before suspend."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SC_NO_FONT_LOADING
argument_list|)
operator|&&
name|defined
argument_list|(
name|SC_DFLT_FONT
argument_list|)
end_if

begin_include
include|#
directive|include
file|"font.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|tsw_ioctl_t
modifier|*
name|sc_user_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bios_values_t
name|bios_value
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|enable_panic_key
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|enable_panic_key
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|enable_panic_key
argument_list|,
literal|0
argument_list|,
literal|"Enable panic via keypress specified in kbdmap(5)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|SC_CONSOLECTL
value|255
end_define

begin_define
define|#
directive|define
name|VTY_WCHAN
parameter_list|(
name|sc
parameter_list|,
name|vty
parameter_list|)
value|(&SC_DEV(sc, vty))
end_define

begin_decl_stmt
specifier|static
name|int
name|debugger
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* prototypes */
end_comment

begin_function_decl
specifier|static
name|int
name|sc_allocate_keyboard
parameter_list|(
name|sc_softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|scvidprobe
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|cons
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sckbdprobe
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|cons
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|scmeminit
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|scdevtounit
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|kbd_callback_func_t
name|sckbdevent
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|scinit
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|scr_stat
modifier|*
name|sc_get_stat
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|scterm
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|scshutdown
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|scsuspend
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|scresume
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|scgetc
parameter_list|(
name|sc_softc_t
modifier|*
name|sc
parameter_list|,
name|u_int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|SCGETC_CN
value|1
end_define

begin_define
define|#
directive|define
name|SCGETC_NONBLOCK
value|2
end_define

begin_function_decl
specifier|static
name|void
name|sccnupdate
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|scr_stat
modifier|*
name|alloc_scp
parameter_list|(
name|sc_softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|vty
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_scp
parameter_list|(
name|sc_softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|vty
parameter_list|,
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|timeout_t
name|scrn_timer
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|and_region
parameter_list|(
name|int
modifier|*
name|s1
parameter_list|,
name|int
modifier|*
name|e1
parameter_list|,
name|int
name|s2
parameter_list|,
name|int
name|e2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|scrn_update
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|show_cursor
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|DEV_SPLASH
end_ifdef

begin_function_decl
specifier|static
name|int
name|scsplash_callback
parameter_list|(
name|int
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|scsplash_saver
parameter_list|(
name|sc_softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|show
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|add_scrn_saver
parameter_list|(
name|void
function_decl|(
modifier|*
name|this_saver
function_decl|)
parameter_list|(
name|sc_softc_t
modifier|*
parameter_list|,
name|int
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|remove_scrn_saver
parameter_list|(
name|void
function_decl|(
modifier|*
name|this_saver
function_decl|)
parameter_list|(
name|sc_softc_t
modifier|*
parameter_list|,
name|int
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_scrn_saver_mode
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|mode
parameter_list|,
name|u_char
modifier|*
name|pal
parameter_list|,
name|int
name|border
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|restore_scrn_saver_mode
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|changemode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stop_scrn_saver
parameter_list|(
name|sc_softc_t
modifier|*
name|sc
parameter_list|,
name|void
function_decl|(
modifier|*
name|saver
function_decl|)
parameter_list|(
name|sc_softc_t
modifier|*
parameter_list|,
name|int
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wait_scrn_saver_stop
parameter_list|(
name|sc_softc_t
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|scsplash_stick
parameter_list|(
name|stick
parameter_list|)
value|(sticky_splash = (stick))
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !DEV_SPLASH */
end_comment

begin_define
define|#
directive|define
name|scsplash_stick
parameter_list|(
name|stick
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEV_SPLASH */
end_comment

begin_function_decl
specifier|static
name|int
name|do_switch_scr
parameter_list|(
name|sc_softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vt_proc_alive
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|signal_vt_rel
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|signal_vt_acq
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|finish_vt_rel
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|release
parameter_list|,
name|int
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|finish_vt_acq
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|exchange_scr
parameter_list|(
name|sc_softc_t
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|update_cursor_image
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|change_cursor_shape
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|base
parameter_list|,
name|int
name|height
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|save_kbd_state
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|update_kbd_state
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|state
parameter_list|,
name|int
name|mask
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|update_kbd_leds
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|which
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|timeout_t
name|blink_screen
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|struct
name|tty
modifier|*
name|sc_alloc_tty
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|cn_probe_t
name|sc_cnprobe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cn_init_t
name|sc_cninit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cn_term_t
name|sc_cnterm
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cn_getc_t
name|sc_cngetc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cn_putc_t
name|sc_cnputc
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|CONSOLE_DRIVER
argument_list|(
name|sc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|tsw_open_t
name|sctty_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tsw_close_t
name|sctty_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tsw_outwakeup_t
name|sctty_outwakeup
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tsw_ioctl_t
name|sctty_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tsw_mmap_t
name|sctty_mmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ttydevsw
name|sc_ttydevsw
init|=
block|{
operator|.
name|tsw_open
operator|=
name|sctty_open
block|,
operator|.
name|tsw_close
operator|=
name|sctty_close
block|,
operator|.
name|tsw_outwakeup
operator|=
name|sctty_outwakeup
block|,
operator|.
name|tsw_ioctl
operator|=
name|sctty_ioctl
block|,
operator|.
name|tsw_mmap
operator|=
name|sctty_mmap
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|consolectl_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|consolectl_devsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_flags
operator|=
name|D_NEEDGIANT
block|,
operator|.
name|d_ioctl
operator|=
name|consolectl_ioctl
block|,
operator|.
name|d_name
operator|=
literal|"consolectl"
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|sc_probe_unit
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
operator|!
name|scvidprobe
argument_list|(
name|unit
argument_list|,
name|flags
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"%s%d: no video adapter found.\n"
argument_list|,
name|SC_DRIVER_NAME
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
comment|/* syscons will be attached even when there is no keyboard */
name|sckbdprobe
argument_list|(
name|unit
argument_list|,
name|flags
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* probe video adapters, return TRUE if found */
end_comment

begin_function
specifier|static
name|int
name|scvidprobe
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|cons
parameter_list|)
block|{
comment|/*      * Access the video adapter driver through the back door!      * Video adapter drivers need to be configured before syscons.      * However, when syscons is being probed as the low-level console,      * they have not been initialized yet.  We force them to initialize      * themselves here. XXX      */
name|vid_configure
argument_list|(
name|cons
condition|?
name|VIO_PROBE_ONLY
else|:
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|vid_find_adapter
argument_list|(
literal|"*"
argument_list|,
name|unit
argument_list|)
operator|>=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* probe the keyboard, return TRUE if found */
end_comment

begin_function
specifier|static
name|int
name|sckbdprobe
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|cons
parameter_list|)
block|{
comment|/* access the keyboard driver through the backdoor! */
name|kbd_configure
argument_list|(
name|cons
condition|?
name|KB_CONF_PROBE_ONLY
else|:
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|kbd_find_keyboard
argument_list|(
literal|"*"
argument_list|,
name|unit
argument_list|)
operator|>=
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|adapter_name
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|)
block|{
specifier|static
struct|struct
block|{
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|name
index|[
literal|2
index|]
decl_stmt|;
block|}
name|names
index|[]
init|=
block|{
block|{
name|KD_MONO
block|,
block|{
literal|"MDA"
block|,
literal|"MDA"
block|}
block|}
block|,
block|{
name|KD_HERCULES
block|,
block|{
literal|"Hercules"
block|,
literal|"Hercules"
block|}
block|}
block|,
block|{
name|KD_CGA
block|,
block|{
literal|"CGA"
block|,
literal|"CGA"
block|}
block|}
block|,
block|{
name|KD_EGA
block|,
block|{
literal|"EGA"
block|,
literal|"EGA (mono)"
block|}
block|}
block|,
block|{
name|KD_VGA
block|,
block|{
literal|"VGA"
block|,
literal|"VGA (mono)"
block|}
block|}
block|,
block|{
name|KD_PC98
block|,
block|{
literal|"PC-98x1"
block|,
literal|"PC-98x1"
block|}
block|}
block|,
block|{
name|KD_TGA
block|,
block|{
literal|"TGA"
block|,
literal|"TGA"
block|}
block|}
block|,
block|{
operator|-
literal|1
block|,
block|{
literal|"Unknown"
block|,
literal|"Unknown"
block|}
block|}
block|,     }
struct|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|names
index|[
name|i
index|]
operator|.
name|type
operator|!=
operator|-
literal|1
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|names
index|[
name|i
index|]
operator|.
name|type
operator|==
name|adp
operator|->
name|va_type
condition|)
break|break;
return|return
name|names
index|[
name|i
index|]
operator|.
name|name
index|[
operator|(
name|adp
operator|->
name|va_flags
operator|&
name|V_ADP_COLOR
operator|)
condition|?
literal|0
else|:
literal|1
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctty_outwakeup
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
name|u_char
name|buf
index|[
name|PCBURST
index|]
decl_stmt|;
name|scr_stat
modifier|*
name|scp
init|=
name|sc_get_stat
argument_list|(
name|tp
argument_list|)
decl_stmt|;
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|SLKED
operator|||
operator|(
name|scp
operator|==
name|scp
operator|->
name|sc
operator|->
name|cur_scp
operator|&&
name|scp
operator|->
name|sc
operator|->
name|blink_in_progress
operator|)
condition|)
return|return;
for|for
control|(
init|;
condition|;
control|)
block|{
name|len
operator|=
name|ttydisc_getc
argument_list|(
name|tp
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
break|break;
name|sc_puts
argument_list|(
name|scp
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|tty
modifier|*
name|sc_alloc_tty
parameter_list|(
name|int
name|index
parameter_list|,
name|int
name|devnum
parameter_list|)
block|{
name|struct
name|sc_ttysoftc
modifier|*
name|stc
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
comment|/* Allocate TTY object and softc to store unit number. */
name|stc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sc_ttysoftc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|stc
operator|->
name|st_index
operator|=
name|index
expr_stmt|;
name|stc
operator|->
name|st_stat
operator|=
name|NULL
expr_stmt|;
name|tp
operator|=
name|tty_alloc_mutex
argument_list|(
operator|&
name|sc_ttydevsw
argument_list|,
name|stc
argument_list|,
operator|&
name|Giant
argument_list|)
expr_stmt|;
comment|/* Create device node. */
name|tty_makedev
argument_list|(
name|tp
argument_list|,
name|NULL
argument_list|,
literal|"v%r"
argument_list|,
name|devnum
argument_list|)
expr_stmt|;
return|return
operator|(
name|tp
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SC_PIXEL_MODE
end_ifdef

begin_function
specifier|static
name|void
name|sc_set_vesa_mode
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|sc_softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|video_info_t
name|info
decl_stmt|;
name|u_char
modifier|*
name|font
decl_stmt|;
name|int
name|depth
decl_stmt|;
name|int
name|fontsize
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|vmode
decl_stmt|;
name|vmode
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|resource_int_value
argument_list|(
literal|"sc"
argument_list|,
name|unit
argument_list|,
literal|"vesa_mode"
argument_list|,
operator|&
name|vmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|vmode
operator|<
name|M_VESA_BASE
operator|||
name|vmode
operator|>
name|M_VESA_MODE_MAX
operator|||
name|vidd_get_info
argument_list|(
name|sc
operator|->
name|adp
argument_list|,
name|vmode
argument_list|,
operator|&
name|info
argument_list|)
operator|!=
literal|0
operator|||
operator|!
name|sc_support_pixel_mode
argument_list|(
operator|&
name|info
argument_list|)
condition|)
name|vmode
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If the mode is unset or unsupported, search for an available 	 * 800x600 graphics mode with the highest color depth. 	 */
if|if
condition|(
name|vmode
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|depth
operator|=
literal|0
operator|,
name|i
operator|=
name|M_VESA_BASE
init|;
name|i
operator|<=
name|M_VESA_MODE_MAX
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|vidd_get_info
argument_list|(
name|sc
operator|->
name|adp
argument_list|,
name|i
argument_list|,
operator|&
name|info
argument_list|)
operator|==
literal|0
operator|&&
name|info
operator|.
name|vi_width
operator|==
literal|800
operator|&&
name|info
operator|.
name|vi_height
operator|==
literal|600
operator|&&
name|sc_support_pixel_mode
argument_list|(
operator|&
name|info
argument_list|)
operator|&&
name|info
operator|.
name|vi_depth
operator|>
name|depth
condition|)
block|{
name|vmode
operator|=
name|i
expr_stmt|;
name|depth
operator|=
name|info
operator|.
name|vi_depth
expr_stmt|;
block|}
if|if
condition|(
name|vmode
operator|==
literal|0
condition|)
return|return;
name|vidd_get_info
argument_list|(
name|sc
operator|->
name|adp
argument_list|,
name|vmode
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SC_NO_FONT_LOADING
argument_list|)
operator|&&
name|defined
argument_list|(
name|SC_DFLT_FONT
argument_list|)
name|fontsize
operator|=
name|info
operator|.
name|vi_cheight
expr_stmt|;
else|#
directive|else
name|fontsize
operator|=
name|scp
operator|->
name|font_size
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fontsize
operator|<
literal|14
condition|)
name|fontsize
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|fontsize
operator|>=
literal|16
condition|)
name|fontsize
operator|=
literal|16
expr_stmt|;
else|else
name|fontsize
operator|=
literal|14
expr_stmt|;
ifndef|#
directive|ifndef
name|SC_NO_FONT_LOADING
switch|switch
condition|(
name|fontsize
condition|)
block|{
case|case
literal|8
case|:
if|if
condition|(
operator|(
name|sc
operator|->
name|fonts_loaded
operator|&
name|FONT_8
operator|)
operator|==
literal|0
condition|)
return|return;
name|font
operator|=
name|sc
operator|->
name|font_8
expr_stmt|;
break|break;
case|case
literal|14
case|:
if|if
condition|(
operator|(
name|sc
operator|->
name|fonts_loaded
operator|&
name|FONT_14
operator|)
operator|==
literal|0
condition|)
return|return;
name|font
operator|=
name|sc
operator|->
name|font_14
expr_stmt|;
break|break;
case|case
literal|16
case|:
if|if
condition|(
operator|(
name|sc
operator|->
name|fonts_loaded
operator|&
name|FONT_16
operator|)
operator|==
literal|0
condition|)
return|return;
name|font
operator|=
name|sc
operator|->
name|font_16
expr_stmt|;
break|break;
block|}
else|#
directive|else
name|font
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEV_SPLASH
if|if
condition|(
operator|(
name|sc
operator|->
name|flags
operator|&
name|SC_SPLASH_SCRN
operator|)
operator|!=
literal|0
condition|)
name|splash_term
argument_list|(
name|sc
operator|->
name|adp
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|SC_NO_HISTORY
if|if
condition|(
name|scp
operator|->
name|history
operator|!=
name|NULL
condition|)
block|{
name|sc_vtb_append
argument_list|(
operator|&
name|scp
operator|->
name|vtb
argument_list|,
literal|0
argument_list|,
name|scp
operator|->
name|history
argument_list|,
name|scp
operator|->
name|ypos
operator|*
name|scp
operator|->
name|xsize
operator|+
name|scp
operator|->
name|xpos
argument_list|)
expr_stmt|;
name|scp
operator|->
name|history_pos
operator|=
name|sc_vtb_tail
argument_list|(
name|scp
operator|->
name|history
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|vidd_set_mode
argument_list|(
name|sc
operator|->
name|adp
argument_list|,
name|vmode
argument_list|)
expr_stmt|;
name|scp
operator|->
name|status
operator||=
operator|(
name|UNKNOWN_MODE
operator||
name|PIXEL_MODE
operator||
name|MOUSE_HIDDEN
operator|)
expr_stmt|;
name|scp
operator|->
name|status
operator|&=
operator|~
operator|(
name|GRAPHICS_MODE
operator||
name|MOUSE_VISIBLE
operator|)
expr_stmt|;
name|scp
operator|->
name|xpixel
operator|=
name|info
operator|.
name|vi_width
expr_stmt|;
name|scp
operator|->
name|ypixel
operator|=
name|info
operator|.
name|vi_height
expr_stmt|;
name|scp
operator|->
name|xsize
operator|=
name|scp
operator|->
name|xpixel
operator|/
literal|8
expr_stmt|;
name|scp
operator|->
name|ysize
operator|=
name|scp
operator|->
name|ypixel
operator|/
name|fontsize
expr_stmt|;
name|scp
operator|->
name|xpos
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|ypos
operator|=
name|scp
operator|->
name|ysize
operator|-
literal|1
expr_stmt|;
name|scp
operator|->
name|xoff
operator|=
name|scp
operator|->
name|yoff
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|font
operator|=
name|font
expr_stmt|;
name|scp
operator|->
name|font_size
operator|=
name|fontsize
expr_stmt|;
name|scp
operator|->
name|font_width
operator|=
literal|8
expr_stmt|;
name|scp
operator|->
name|start
operator|=
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
operator|-
literal|1
expr_stmt|;
name|scp
operator|->
name|end
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|cursor_pos
operator|=
name|scp
operator|->
name|cursor_oldpos
operator|=
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|xsize
expr_stmt|;
name|scp
operator|->
name|mode
operator|=
name|sc
operator|->
name|initial_mode
operator|=
name|vmode
expr_stmt|;
ifndef|#
directive|ifndef
name|__sparc64__
name|sc_vtb_init
argument_list|(
operator|&
name|scp
operator|->
name|scr
argument_list|,
name|VTB_FRAMEBUFFER
argument_list|,
name|scp
operator|->
name|xsize
argument_list|,
name|scp
operator|->
name|ysize
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
operator|->
name|adp
operator|->
name|va_window
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc_alloc_scr_buffer
argument_list|(
name|scp
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|sc_init_emulator
argument_list|(
name|scp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SC_NO_CUTPASTE
name|sc_alloc_cut_buffer
argument_list|(
name|scp
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|SC_NO_HISTORY
name|sc_alloc_history_buffer
argument_list|(
name|scp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc_set_border
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|border
argument_list|)
expr_stmt|;
name|sc_set_cursor_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|scp
operator|->
name|status
operator|&=
operator|~
name|UNKNOWN_MODE
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_SPLASH
if|if
condition|(
operator|(
name|sc
operator|->
name|flags
operator|&
name|SC_SPLASH_SCRN
operator|)
operator|!=
literal|0
condition|)
name|splash_init
argument_list|(
name|sc
operator|->
name|adp
argument_list|,
name|scsplash_callback
argument_list|,
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|sc_attach_unit
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|sc_softc_t
modifier|*
name|sc
decl_stmt|;
name|scr_stat
modifier|*
name|scp
decl_stmt|;
name|struct
name|cdev
modifier|*
name|dev
decl_stmt|;
name|int
name|vc
decl_stmt|;
name|flags
operator|&=
operator|~
name|SC_KERNEL_CONSOLE
expr_stmt|;
if|if
condition|(
name|sc_console_unit
operator|==
name|unit
condition|)
block|{
comment|/* 	 * If this unit is being used as the system console, we need to 	 * adjust some variables and buffers before and after scinit(). 	 */
comment|/* assert(sc_console != NULL) */
name|flags
operator||=
name|SC_KERNEL_CONSOLE
expr_stmt|;
name|scmeminit
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
name|scinit
argument_list|(
name|unit
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|sc
operator|=
name|sc_get_softc
argument_list|(
name|unit
argument_list|,
name|flags
operator|&
name|SC_KERNEL_CONSOLE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|config
operator|=
name|flags
expr_stmt|;
name|scp
operator|=
name|sc_get_stat
argument_list|(
name|sc
operator|->
name|dev
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc_console
operator|==
name|NULL
condition|)
comment|/* sc_console_unit< 0 */
name|sc_console
operator|=
name|scp
expr_stmt|;
ifdef|#
directive|ifdef
name|SC_PIXEL_MODE
if|if
condition|(
operator|(
name|sc
operator|->
name|config
operator|&
name|SC_VESAMODE
operator|)
operator|!=
literal|0
condition|)
name|sc_set_vesa_mode
argument_list|(
name|scp
argument_list|,
name|sc
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SC_PIXEL_MODE */
comment|/* initialize cursor */
if|if
condition|(
operator|!
name|ISGRAPHSC
argument_list|(
name|scp
argument_list|)
condition|)
name|update_cursor_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
comment|/* get screen update going */
name|scrn_timer
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* set up the keyboard */
operator|(
name|void
operator|)
name|kbdd_ioctl
argument_list|(
name|sc
operator|->
name|kbd
argument_list|,
name|KDSKBMODE
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|scp
operator|->
name|kbd_mode
argument_list|)
expr_stmt|;
name|update_kbd_state
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|status
argument_list|,
name|LOCK_MASK
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s%d: %s<%d virtual consoles, flags=0x%x>\n"
argument_list|,
name|SC_DRIVER_NAME
argument_list|,
name|unit
argument_list|,
name|adapter_name
argument_list|(
name|sc
operator|->
name|adp
argument_list|)
argument_list|,
name|sc
operator|->
name|vtys
argument_list|,
name|sc
operator|->
name|config
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"%s%d:"
argument_list|,
name|SC_DRIVER_NAME
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|adapter
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|" fb%d"
argument_list|,
name|sc
operator|->
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|keyboard
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|", kbd%d"
argument_list|,
name|sc
operator|->
name|keyboard
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|tsw
condition|)
name|printf
argument_list|(
literal|", terminal emulator: %s (%s)"
argument_list|,
name|scp
operator|->
name|tsw
operator|->
name|te_name
argument_list|,
name|scp
operator|->
name|tsw
operator|->
name|te_desc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Register suspend/resume/shutdown callbacks for the kernel console. */
if|if
condition|(
name|sc_console_unit
operator|==
name|unit
condition|)
block|{
name|EVENTHANDLER_REGISTER
argument_list|(
name|power_suspend
argument_list|,
name|scsuspend
argument_list|,
name|NULL
argument_list|,
name|EVENTHANDLER_PRI_ANY
argument_list|)
expr_stmt|;
name|EVENTHANDLER_REGISTER
argument_list|(
name|power_resume
argument_list|,
name|scresume
argument_list|,
name|NULL
argument_list|,
name|EVENTHANDLER_PRI_ANY
argument_list|)
expr_stmt|;
name|EVENTHANDLER_REGISTER
argument_list|(
name|shutdown_pre_sync
argument_list|,
name|scshutdown
argument_list|,
name|NULL
argument_list|,
name|SHUTDOWN_PRI_DEFAULT
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|vc
operator|=
literal|0
init|;
name|vc
operator|<
name|sc
operator|->
name|vtys
condition|;
name|vc
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|dev
index|[
name|vc
index|]
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|dev
index|[
name|vc
index|]
operator|=
name|sc_alloc_tty
argument_list|(
name|vc
argument_list|,
name|vc
operator|+
name|unit
operator|*
name|MAXCONS
argument_list|)
expr_stmt|;
if|if
condition|(
name|vc
operator|==
literal|0
operator|&&
name|sc
operator|->
name|dev
operator|==
name|main_devs
condition|)
name|SC_STAT
argument_list|(
name|sc
operator|->
name|dev
index|[
literal|0
index|]
argument_list|)
operator|=
operator|&
name|main_console
expr_stmt|;
block|}
comment|/* 	 * The first vty already has struct tty and scr_stat initialized 	 * in scinit().  The other vtys will have these structs when 	 * first opened. 	 */
block|}
name|dev
operator|=
name|make_dev
argument_list|(
operator|&
name|consolectl_devsw
argument_list|,
literal|0
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"consolectl"
argument_list|)
expr_stmt|;
name|dev
operator|->
name|si_drv1
operator|=
name|sc
operator|->
name|dev
index|[
literal|0
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|scmeminit
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|sc_malloc
condition|)
return|return;
name|sc_malloc
operator|=
name|TRUE
expr_stmt|;
comment|/*      * As soon as malloc() becomes functional, we had better allocate      * various buffers for the kernel console.      */
if|if
condition|(
name|sc_console_unit
operator|<
literal|0
condition|)
comment|/* sc_console == NULL */
return|return;
comment|/* copy the temporary buffer to the final buffer */
name|sc_alloc_scr_buffer
argument_list|(
name|sc_console
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SC_NO_CUTPASTE
name|sc_alloc_cut_buffer
argument_list|(
name|sc_console
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|SC_NO_HISTORY
comment|/* initialize history buffer& pointers */
name|sc_alloc_history_buffer
argument_list|(
name|sc_console
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* XXX */
end_comment

begin_expr_stmt
name|SYSINIT
argument_list|(
name|sc_mem
argument_list|,
name|SI_SUB_KMEM
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|scmeminit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|scdevtounit
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|int
name|vty
init|=
name|SC_VTY
argument_list|(
name|tp
argument_list|)
decl_stmt|;
if|if
condition|(
name|vty
operator|==
name|SC_CONSOLECTL
condition|)
return|return
operator|(
operator|(
name|sc_console
operator|!=
name|NULL
operator|)
condition|?
name|sc_console
operator|->
name|sc
operator|->
name|unit
else|:
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
operator|(
name|vty
operator|<
literal|0
operator|)
operator|||
operator|(
name|vty
operator|>=
name|MAXCONS
operator|*
name|sc_max_unit
argument_list|()
operator|)
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
name|vty
operator|/
name|MAXCONS
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctty_open
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|int
name|unit
init|=
name|scdevtounit
argument_list|(
name|tp
argument_list|)
decl_stmt|;
name|sc_softc_t
modifier|*
name|sc
decl_stmt|;
name|scr_stat
modifier|*
name|scp
decl_stmt|;
ifndef|#
directive|ifndef
name|__sparc64__
name|keyarg_t
name|key
decl_stmt|;
endif|#
directive|endif
name|DPRINTF
argument_list|(
literal|5
argument_list|,
operator|(
literal|"scopen: dev:%s, unit:%d, vty:%d\n"
operator|,
name|devtoname
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
operator|,
name|unit
operator|,
name|SC_VTY
argument_list|(
name|tp
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|=
name|sc_get_softc
argument_list|(
name|unit
argument_list|,
operator|(
name|sc_console_unit
operator|==
name|unit
operator|)
condition|?
name|SC_KERNEL_CONSOLE
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
operator|!
name|tty_opened
argument_list|(
name|tp
argument_list|)
condition|)
block|{
comment|/* Use the current setting of the<-- key as default VERASE. */
comment|/* If the Delete key is preferable, an stty is necessary     */
ifndef|#
directive|ifndef
name|__sparc64__
if|if
condition|(
name|sc
operator|->
name|kbd
operator|!=
name|NULL
condition|)
block|{
name|key
operator|.
name|keynum
operator|=
name|KEYCODE_BS
expr_stmt|;
operator|(
name|void
operator|)
name|kbdd_ioctl
argument_list|(
name|sc
operator|->
name|kbd
argument_list|,
name|GIO_KEYMAPENT
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|key
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_termios
operator|.
name|c_cc
index|[
name|VERASE
index|]
operator|=
name|key
operator|.
name|key
operator|.
name|map
index|[
literal|0
index|]
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|scp
operator|=
name|sc_get_stat
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|==
name|NULL
condition|)
block|{
name|scp
operator|=
name|SC_STAT
argument_list|(
name|tp
argument_list|)
operator|=
name|alloc_scp
argument_list|(
name|sc
argument_list|,
name|SC_VTY
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISGRAPHSC
argument_list|(
name|scp
argument_list|)
condition|)
name|sc_set_pixel_mode
argument_list|(
name|scp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|16
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|tp
operator|->
name|t_winsize
operator|.
name|ws_col
operator|&&
operator|!
name|tp
operator|->
name|t_winsize
operator|.
name|ws_row
condition|)
block|{
name|tp
operator|->
name|t_winsize
operator|.
name|ws_col
operator|=
name|scp
operator|->
name|xsize
expr_stmt|;
name|tp
operator|->
name|t_winsize
operator|.
name|ws_row
operator|=
name|scp
operator|->
name|ysize
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctty_close
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|scr_stat
modifier|*
name|scp
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|SC_VTY
argument_list|(
name|tp
argument_list|)
operator|!=
name|SC_CONSOLECTL
condition|)
block|{
name|scp
operator|=
name|sc_get_stat
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* were we in the middle of the VT switching process? */
name|DPRINTF
argument_list|(
literal|5
argument_list|,
operator|(
literal|"sc%d: scclose(), "
operator|,
name|scp
operator|->
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|scp
operator|==
name|scp
operator|->
name|sc
operator|->
name|cur_scp
operator|)
operator|&&
operator|(
name|scp
operator|->
name|sc
operator|->
name|unit
operator|==
name|sc_console_unit
operator|)
condition|)
name|cnavailable
argument_list|(
name|sc_consptr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|finish_vt_rel
argument_list|(
name|scp
argument_list|,
name|TRUE
argument_list|,
operator|&
name|s
argument_list|)
operator|==
literal|0
condition|)
comment|/* force release */
name|DPRINTF
argument_list|(
literal|5
argument_list|,
operator|(
literal|"reset WAIT_REL, "
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|finish_vt_acq
argument_list|(
name|scp
argument_list|)
operator|==
literal|0
condition|)
comment|/* force acknowledge */
name|DPRINTF
argument_list|(
literal|5
argument_list|,
operator|(
literal|"reset WAIT_ACQ, "
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|not_yet_done
if|if
condition|(
name|scp
operator|==
operator|&
name|main_console
condition|)
block|{
name|scp
operator|->
name|pid
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|proc
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|smode
operator|.
name|mode
operator|=
name|VT_AUTO
expr_stmt|;
block|}
else|else
block|{
name|sc_vtb_destroy
argument_list|(
operator|&
name|scp
operator|->
name|vtb
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__sparc64__
name|sc_vtb_destroy
argument_list|(
operator|&
name|scp
operator|->
name|scr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc_free_history_buffer
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|ysize
argument_list|)
expr_stmt|;
name|SC_STAT
argument_list|(
name|tp
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|scp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|scp
operator|->
name|pid
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|proc
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|smode
operator|.
name|mode
operator|=
name|VT_AUTO
expr_stmt|;
endif|#
directive|endif
name|scp
operator|->
name|kbd_mode
operator|=
name|K_XLATE
expr_stmt|;
if|if
condition|(
name|scp
operator|==
name|scp
operator|->
name|sc
operator|->
name|cur_scp
condition|)
operator|(
name|void
operator|)
name|kbdd_ioctl
argument_list|(
name|scp
operator|->
name|sc
operator|->
name|kbd
argument_list|,
name|KDSKBMODE
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|scp
operator|->
name|kbd_mode
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|5
argument_list|,
operator|(
literal|"done.\n"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* XXX mpsafetty: fix screensaver. What about outwakeup? */
end_comment

begin_endif
unit|static int scread(struct cdev *dev, struct uio *uio, int flag) {     if (!sc_saver_keyb_only) 	sc_touch_scrn_saver();     return ttyread(dev, uio, flag); }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|sckbdevent
parameter_list|(
name|keyboard_t
modifier|*
name|thiskbd
parameter_list|,
name|int
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|sc_softc_t
modifier|*
name|sc
decl_stmt|;
name|struct
name|tty
modifier|*
name|cur_tty
decl_stmt|;
name|int
name|c
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|size_t
name|len
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|cp
decl_stmt|;
name|sc
operator|=
operator|(
name|sc_softc_t
operator|*
operator|)
name|arg
expr_stmt|;
comment|/* assert(thiskbd == sc->kbd) */
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|KBDIO_KEYINPUT
case|:
break|break;
case|case
name|KBDIO_UNLOADING
case|:
name|sc
operator|->
name|kbd
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|keyboard
operator|=
operator|-
literal|1
expr_stmt|;
name|kbd_release
argument_list|(
name|thiskbd
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|sc
operator|->
name|keyboard
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/*       * Loop while there is still input to get from the keyboard.      * I don't think this is nessesary, and it doesn't fix      * the Xaccel-2.1 keyboard hang, but it can't hurt.		XXX      */
while|while
condition|(
operator|(
name|c
operator|=
name|scgetc
argument_list|(
name|sc
argument_list|,
name|SCGETC_NONBLOCK
argument_list|)
operator|)
operator|!=
name|NOKEY
condition|)
block|{
name|cur_tty
operator|=
name|SC_DEV
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|cur_scp
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tty_opened
argument_list|(
name|cur_tty
argument_list|)
condition|)
continue|continue;
if|if
condition|(
call|(
modifier|*
name|sc
operator|->
name|cur_scp
operator|->
name|tsw
operator|->
name|te_input
call|)
argument_list|(
name|sc
operator|->
name|cur_scp
argument_list|,
name|c
argument_list|,
name|cur_tty
argument_list|)
condition|)
continue|continue;
switch|switch
condition|(
name|KEYFLAGS
argument_list|(
name|c
argument_list|)
condition|)
block|{
case|case
literal|0x0000
case|:
comment|/* normal key */
name|ttydisc_rint
argument_list|(
name|cur_tty
argument_list|,
name|KEYCHAR
argument_list|(
name|c
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|FKEY
case|:
comment|/* function key, return string */
name|cp
operator|=
call|(
modifier|*
name|sc
operator|->
name|cur_scp
operator|->
name|tsw
operator|->
name|te_fkeystr
call|)
argument_list|(
name|sc
operator|->
name|cur_scp
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
name|ttydisc_rint_simple
argument_list|(
name|cur_tty
argument_list|,
name|cp
argument_list|,
name|strlen
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|cp
operator|=
name|kbdd_get_fkeystr
argument_list|(
name|thiskbd
argument_list|,
name|KEYCHAR
argument_list|(
name|c
argument_list|)
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
name|ttydisc_rint_simple
argument_list|(
name|cur_tty
argument_list|,
name|cp
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|MKEY
case|:
comment|/* meta is active, prepend ESC */
name|ttydisc_rint
argument_list|(
name|cur_tty
argument_list|,
literal|0x1b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ttydisc_rint
argument_list|(
name|cur_tty
argument_list|,
name|KEYCHAR
argument_list|(
name|c
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|BKEY
case|:
comment|/* backtab fixed sequence (esc [ Z) */
name|ttydisc_rint_simple
argument_list|(
name|cur_tty
argument_list|,
literal|"\x1B[Z"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
break|break;
block|}
name|ttydisc_rint_done
argument_list|(
name|cur_tty
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|cur_scp
operator|->
name|status
operator||=
name|MOUSE_HIDDEN
expr_stmt|;
name|done
label|:
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctty_ioctl
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc_softc_t
modifier|*
name|sc
decl_stmt|;
name|scr_stat
modifier|*
name|scp
decl_stmt|;
name|int
name|s
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_FREEBSD6
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_FREEBSD5
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|COMPAT_FREEBSD4
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_43
argument_list|)
name|int
name|ival
decl_stmt|;
endif|#
directive|endif
comment|/* If there is a user_ioctl function call that first */
if|if
condition|(
name|sc_user_ioctl
condition|)
block|{
name|error
operator|=
call|(
modifier|*
name|sc_user_ioctl
call|)
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOIOCTL
condition|)
return|return
name|error
return|;
block|}
name|error
operator|=
name|sc_vid_ioctl
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOIOCTL
condition|)
return|return
name|error
return|;
ifndef|#
directive|ifndef
name|SC_NO_HISTORY
name|error
operator|=
name|sc_hist_ioctl
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOIOCTL
condition|)
return|return
name|error
return|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|SC_NO_SYSMOUSE
name|error
operator|=
name|sc_mouse_ioctl
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOIOCTL
condition|)
return|return
name|error
return|;
endif|#
directive|endif
name|scp
operator|=
name|sc_get_stat
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* assert(scp != NULL) */
comment|/* scp is sc_console, if SC_VTY(dev) == SC_CONSOLECTL. */
name|sc
operator|=
name|scp
operator|->
name|sc
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|tsw
condition|)
block|{
name|error
operator|=
call|(
modifier|*
name|scp
operator|->
name|tsw
operator|->
name|te_ioctl
call|)
argument_list|(
name|scp
argument_list|,
name|tp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOIOCTL
condition|)
return|return
name|error
return|;
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
comment|/* process console hardware related ioctl's */
case|case
name|GIO_ATTR
case|:
comment|/* get current attributes */
comment|/* this ioctl is not processed here, but in the terminal emulator */
return|return
name|ENOTTY
return|;
case|case
name|GIO_COLOR
case|:
comment|/* is this a color console ? */
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
operator|(
name|sc
operator|->
name|adp
operator|->
name|va_flags
operator|&
name|V_ADP_COLOR
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
return|return
literal|0
return|;
case|case
name|CONS_BLANKTIME
case|:
comment|/* set screen saver timeout (0 = no saver) */
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|<
literal|0
operator|||
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|>
name|MAX_BLANKTIME
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|scrn_blank_time
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
name|run_scrn_saver
operator|=
operator|(
name|scrn_blank_time
operator|!=
literal|0
operator|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|CONS_CURSORTYPE
case|:
comment|/* set cursor type (obsolete) */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&=
name|CONS_CURSOR_ATTRS
expr_stmt|;
name|sc_change_cursor_shape
argument_list|(
name|scp
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|CONS_GETCURSORSHAPE
case|:
comment|/* get cursor shape (new interface) */
if|if
condition|(
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
index|[
literal|0
index|]
operator|&
name|CONS_LOCAL_CURSOR
condition|)
block|{
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
index|[
literal|0
index|]
operator|=
name|scp
operator|->
name|curr_curs_attr
operator|.
name|flags
expr_stmt|;
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
index|[
literal|1
index|]
operator|=
name|scp
operator|->
name|curr_curs_attr
operator|.
name|base
expr_stmt|;
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
index|[
literal|2
index|]
operator|=
name|scp
operator|->
name|curr_curs_attr
operator|.
name|height
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
index|[
literal|0
index|]
operator|=
name|sc
operator|->
name|curs_attr
operator|.
name|flags
expr_stmt|;
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
index|[
literal|1
index|]
operator|=
name|sc
operator|->
name|curs_attr
operator|.
name|base
expr_stmt|;
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
index|[
literal|2
index|]
operator|=
name|sc
operator|->
name|curs_attr
operator|.
name|height
expr_stmt|;
block|}
return|return
literal|0
return|;
case|case
name|CONS_SETCURSORSHAPE
case|:
comment|/* set cursor shape (new interface) */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|sc_change_cursor_shape
argument_list|(
name|scp
argument_list|,
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
index|[
literal|0
index|]
argument_list|,
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
index|[
literal|1
index|]
argument_list|,
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|CONS_BELLTYPE
case|:
comment|/* set bell type sound/visual */
if|if
condition|(
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|)
operator|&
name|CONS_VISUAL_BELL
condition|)
name|sc
operator|->
name|flags
operator||=
name|SC_VISUAL_BELL
expr_stmt|;
else|else
name|sc
operator|->
name|flags
operator|&=
operator|~
name|SC_VISUAL_BELL
expr_stmt|;
if|if
condition|(
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|)
operator|&
name|CONS_QUIET_BELL
condition|)
name|sc
operator|->
name|flags
operator||=
name|SC_QUIET_BELL
expr_stmt|;
else|else
name|sc
operator|->
name|flags
operator|&=
operator|~
name|SC_QUIET_BELL
expr_stmt|;
return|return
literal|0
return|;
case|case
name|CONS_GETINFO
case|:
comment|/* get current (virtual) console info */
block|{
name|vid_info_t
modifier|*
name|ptr
init|=
operator|(
name|vid_info_t
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|ptr
operator|->
name|size
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|vid_info
argument_list|)
condition|)
block|{
name|ptr
operator|->
name|m_num
operator|=
name|sc
operator|->
name|cur_scp
operator|->
name|index
expr_stmt|;
name|ptr
operator|->
name|font_size
operator|=
name|scp
operator|->
name|font_size
expr_stmt|;
name|ptr
operator|->
name|mv_col
operator|=
name|scp
operator|->
name|xpos
expr_stmt|;
name|ptr
operator|->
name|mv_row
operator|=
name|scp
operator|->
name|ypos
expr_stmt|;
name|ptr
operator|->
name|mv_csz
operator|=
name|scp
operator|->
name|xsize
expr_stmt|;
name|ptr
operator|->
name|mv_rsz
operator|=
name|scp
operator|->
name|ysize
expr_stmt|;
name|ptr
operator|->
name|mv_hsz
operator|=
operator|(
name|scp
operator|->
name|history
operator|!=
name|NULL
operator|)
condition|?
name|scp
operator|->
name|history
operator|->
name|vtb_rows
else|:
literal|0
expr_stmt|;
comment|/* 	     * The following fields are filled by the terminal emulator. XXX 	     * 	     * ptr->mv_norm.fore 	     * ptr->mv_norm.back 	     * ptr->mv_rev.fore 	     * ptr->mv_rev.back 	     */
name|ptr
operator|->
name|mv_grfc
operator|.
name|fore
operator|=
literal|0
expr_stmt|;
comment|/* not supported */
name|ptr
operator|->
name|mv_grfc
operator|.
name|back
operator|=
literal|0
expr_stmt|;
comment|/* not supported */
name|ptr
operator|->
name|mv_ovscan
operator|=
name|scp
operator|->
name|border
expr_stmt|;
if|if
condition|(
name|scp
operator|==
name|sc
operator|->
name|cur_scp
condition|)
name|save_kbd_state
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|mk_keylock
operator|=
name|scp
operator|->
name|status
operator|&
name|LOCK_MASK
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|EINVAL
return|;
block|}
case|case
name|CONS_GETVERS
case|:
comment|/* get version number */
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
literal|0x200
expr_stmt|;
comment|/* version 2.0 */
return|return
literal|0
return|;
case|case
name|CONS_IDLE
case|:
comment|/* see if the screen has been idle */
comment|/* 	 * When the screen is in the GRAPHICS_MODE or UNKNOWN_MODE, 	 * the user process may have been writing something on the 	 * screen and syscons is not aware of it. Declare the screen 	 * is NOT idle if it is in one of these modes. But there is 	 * an exception to it; if a screen saver is running in the  	 * graphics mode in the current screen, we should say that the 	 * screen has been idle. 	 */
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
operator|(
name|sc
operator|->
name|flags
operator|&
name|SC_SCRN_IDLE
operator|)
operator|&&
operator|(
operator|!
name|ISGRAPHSC
argument_list|(
name|sc
operator|->
name|cur_scp
argument_list|)
operator|||
operator|(
name|sc
operator|->
name|cur_scp
operator|->
name|status
operator|&
name|SAVER_RUNNING
operator|)
operator|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|CONS_SAVERMODE
case|:
comment|/* set saver mode */
switch|switch
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
block|{
case|case
name|CONS_NO_SAVER
case|:
case|case
name|CONS_USR_SAVER
case|:
comment|/* if a LKM screen saver is running, stop it first. */
name|scsplash_stick
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|saver_mode
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_SPLASH
if|if
condition|(
operator|(
name|error
operator|=
name|wait_scrn_saver_stop
argument_list|(
name|NULL
argument_list|)
operator|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
endif|#
directive|endif
name|run_scrn_saver
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|saver_mode
operator|==
name|CONS_USR_SAVER
condition|)
name|scp
operator|->
name|status
operator||=
name|SAVER_RUNNING
expr_stmt|;
else|else
name|scp
operator|->
name|status
operator|&=
operator|~
name|SAVER_RUNNING
expr_stmt|;
name|scsplash_stick
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONS_LKM_SAVER
case|:
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|saver_mode
operator|==
name|CONS_USR_SAVER
operator|)
operator|&&
operator|(
name|scp
operator|->
name|status
operator|&
name|SAVER_RUNNING
operator|)
condition|)
name|scp
operator|->
name|status
operator|&=
operator|~
name|SAVER_RUNNING
expr_stmt|;
name|saver_mode
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|EINVAL
return|;
block|}
return|return
literal|0
return|;
case|case
name|CONS_SAVERSTART
case|:
comment|/* immediately start/stop the screen saver */
comment|/* 	 * Note that this ioctl does not guarantee the screen saver  	 * actually starts or stops. It merely attempts to do so... 	 */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|run_scrn_saver
operator|=
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|run_scrn_saver
condition|)
name|sc
operator|->
name|scrn_time_stamp
operator|-=
name|scrn_blank_time
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|CONS_SCRSHOT
case|:
comment|/* get a screen shot */
block|{
name|int
name|retval
decl_stmt|,
name|hist_rsz
decl_stmt|;
name|size_t
name|lsize
decl_stmt|,
name|csize
decl_stmt|;
name|vm_offset_t
name|frbp
decl_stmt|,
name|hstp
decl_stmt|;
name|unsigned
name|lnum
decl_stmt|;
name|scrshot_t
modifier|*
name|ptr
init|=
operator|(
name|scrshot_t
operator|*
operator|)
name|data
decl_stmt|;
name|void
modifier|*
name|outp
init|=
name|ptr
operator|->
name|buf
decl_stmt|;
if|if
condition|(
name|ptr
operator|->
name|x
operator|<
literal|0
operator|||
name|ptr
operator|->
name|y
operator|<
literal|0
operator|||
name|ptr
operator|->
name|xsize
operator|<
literal|0
operator|||
name|ptr
operator|->
name|ysize
operator|<
literal|0
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|ISGRAPHSC
argument_list|(
name|scp
argument_list|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|EOPNOTSUPP
return|;
block|}
name|hist_rsz
operator|=
operator|(
name|scp
operator|->
name|history
operator|!=
name|NULL
operator|)
condition|?
name|scp
operator|->
name|history
operator|->
name|vtb_rows
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|u_int
operator|)
name|ptr
operator|->
name|x
operator|+
name|ptr
operator|->
name|xsize
operator|)
operator|>
name|scp
operator|->
name|xsize
operator|||
operator|(
operator|(
name|u_int
operator|)
name|ptr
operator|->
name|y
operator|+
name|ptr
operator|->
name|ysize
operator|)
operator|>
operator|(
name|scp
operator|->
name|ysize
operator|+
name|hist_rsz
operator|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|lsize
operator|=
name|scp
operator|->
name|xsize
operator|*
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
expr_stmt|;
name|csize
operator|=
name|ptr
operator|->
name|xsize
operator|*
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
expr_stmt|;
comment|/* Pointer to the last line of framebuffer */
name|frbp
operator|=
name|scp
operator|->
name|vtb
operator|.
name|vtb_buffer
operator|+
name|scp
operator|->
name|ysize
operator|*
name|lsize
operator|+
name|ptr
operator|->
name|x
operator|*
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
expr_stmt|;
comment|/* Pointer to the last line of target buffer */
name|outp
operator|=
operator|(
name|char
operator|*
operator|)
name|outp
operator|+
name|ptr
operator|->
name|ysize
operator|*
name|csize
expr_stmt|;
comment|/* Pointer to the last line of history buffer */
if|if
condition|(
name|scp
operator|->
name|history
operator|!=
name|NULL
condition|)
name|hstp
operator|=
name|scp
operator|->
name|history
operator|->
name|vtb_buffer
operator|+
name|sc_vtb_tail
argument_list|(
name|scp
operator|->
name|history
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
operator|+
name|ptr
operator|->
name|x
operator|*
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
expr_stmt|;
else|else
name|hstp
operator|=
literal|0
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|lnum
operator|=
literal|0
init|;
name|lnum
operator|<
operator|(
name|ptr
operator|->
name|y
operator|+
name|ptr
operator|->
name|ysize
operator|)
condition|;
name|lnum
operator|++
control|)
block|{
if|if
condition|(
name|lnum
operator|<
name|scp
operator|->
name|ysize
condition|)
block|{
name|frbp
operator|-=
name|lsize
expr_stmt|;
block|}
else|else
block|{
name|hstp
operator|-=
name|lsize
expr_stmt|;
if|if
condition|(
name|hstp
operator|<
name|scp
operator|->
name|history
operator|->
name|vtb_buffer
condition|)
name|hstp
operator|+=
name|scp
operator|->
name|history
operator|->
name|vtb_rows
operator|*
name|lsize
expr_stmt|;
name|frbp
operator|=
name|hstp
expr_stmt|;
block|}
if|if
condition|(
name|lnum
operator|<
name|ptr
operator|->
name|y
condition|)
continue|continue;
name|outp
operator|=
operator|(
name|char
operator|*
operator|)
name|outp
operator|-
name|csize
expr_stmt|;
name|retval
operator|=
name|copyout
argument_list|(
operator|(
name|void
operator|*
operator|)
name|frbp
argument_list|,
name|outp
argument_list|,
name|csize
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
case|case
name|VT_SETMODE
case|:
comment|/* set screen switcher mode */
block|{
name|struct
name|vt_mode
modifier|*
name|mode
decl_stmt|;
name|struct
name|proc
modifier|*
name|p1
decl_stmt|;
name|mode
operator|=
operator|(
expr|struct
name|vt_mode
operator|*
operator|)
name|data
expr_stmt|;
name|DPRINTF
argument_list|(
literal|5
argument_list|,
operator|(
literal|"%s%d: VT_SETMODE "
operator|,
name|SC_DRIVER_NAME
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|smode
operator|.
name|mode
operator|==
name|VT_PROCESS
condition|)
block|{
name|p1
operator|=
name|pfind
argument_list|(
name|scp
operator|->
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|proc
operator|==
name|p1
operator|&&
name|scp
operator|->
name|proc
operator|!=
name|td
operator|->
name|td_proc
condition|)
block|{
if|if
condition|(
name|p1
condition|)
name|PROC_UNLOCK
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|5
argument_list|,
operator|(
literal|"error EPERM\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|EPERM
return|;
block|}
if|if
condition|(
name|p1
condition|)
name|PROC_UNLOCK
argument_list|(
name|p1
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|mode
operator|->
name|mode
operator|==
name|VT_AUTO
condition|)
block|{
name|scp
operator|->
name|smode
operator|.
name|mode
operator|=
name|VT_AUTO
expr_stmt|;
name|scp
operator|->
name|proc
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|pid
operator|=
literal|0
expr_stmt|;
name|DPRINTF
argument_list|(
literal|5
argument_list|,
operator|(
literal|"VT_AUTO, "
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scp
operator|==
name|sc
operator|->
name|cur_scp
operator|)
operator|&&
operator|(
name|sc
operator|->
name|unit
operator|==
name|sc_console_unit
operator|)
condition|)
name|cnavailable
argument_list|(
name|sc_consptr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* were we in the middle of the vty switching process? */
if|if
condition|(
name|finish_vt_rel
argument_list|(
name|scp
argument_list|,
name|TRUE
argument_list|,
operator|&
name|s
argument_list|)
operator|==
literal|0
condition|)
name|DPRINTF
argument_list|(
literal|5
argument_list|,
operator|(
literal|"reset WAIT_REL, "
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|finish_vt_acq
argument_list|(
name|scp
argument_list|)
operator|==
literal|0
condition|)
name|DPRINTF
argument_list|(
literal|5
argument_list|,
operator|(
literal|"reset WAIT_ACQ, "
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|ISSIGVALID
argument_list|(
name|mode
operator|->
name|relsig
argument_list|)
operator|||
operator|!
name|ISSIGVALID
argument_list|(
name|mode
operator|->
name|acqsig
argument_list|)
operator|||
operator|!
name|ISSIGVALID
argument_list|(
name|mode
operator|->
name|frsig
argument_list|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|5
argument_list|,
operator|(
literal|"error EINVAL\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|DPRINTF
argument_list|(
literal|5
argument_list|,
operator|(
literal|"VT_PROCESS %d, "
operator|,
name|td
operator|->
name|td_proc
operator|->
name|p_pid
operator|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|data
argument_list|,
operator|&
name|scp
operator|->
name|smode
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vt_mode
argument_list|)
argument_list|)
expr_stmt|;
name|scp
operator|->
name|proc
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|scp
operator|->
name|pid
operator|=
name|scp
operator|->
name|proc
operator|->
name|p_pid
expr_stmt|;
if|if
condition|(
operator|(
name|scp
operator|==
name|sc
operator|->
name|cur_scp
operator|)
operator|&&
operator|(
name|sc
operator|->
name|unit
operator|==
name|sc_console_unit
operator|)
condition|)
name|cnavailable
argument_list|(
name|sc_consptr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|5
argument_list|,
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
case|case
name|VT_GETMODE
case|:
comment|/* get screen switcher mode */
name|bcopy
argument_list|(
operator|&
name|scp
operator|->
name|smode
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vt_mode
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_FREEBSD6
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_FREEBSD5
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|COMPAT_FREEBSD4
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_43
argument_list|)
case|case
name|_IO
argument_list|(
literal|'v'
argument_list|,
literal|4
argument_list|)
case|:
name|ival
operator|=
name|IOCPARM_IVAL
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|ival
expr_stmt|;
comment|/* FALLTHROUGH */
endif|#
directive|endif
case|case
name|VT_RELDISP
case|:
comment|/* screen switcher ioctl */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* 	 * This must be the current vty which is in the VT_PROCESS 	 * switching mode... 	 */
if|if
condition|(
operator|(
name|scp
operator|!=
name|sc
operator|->
name|cur_scp
operator|)
operator|||
operator|(
name|scp
operator|->
name|smode
operator|.
name|mode
operator|!=
name|VT_PROCESS
operator|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/* ...and this process is controlling it. */
if|if
condition|(
name|scp
operator|->
name|proc
operator|!=
name|td
operator|->
name|td_proc
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|EPERM
return|;
block|}
name|error
operator|=
name|EINVAL
expr_stmt|;
switch|switch
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
block|{
case|case
name|VT_FALSE
case|:
comment|/* user refuses to release screen, abort */
if|if
condition|(
operator|(
name|error
operator|=
name|finish_vt_rel
argument_list|(
name|scp
argument_list|,
name|FALSE
argument_list|,
operator|&
name|s
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|DPRINTF
argument_list|(
literal|5
argument_list|,
operator|(
literal|"%s%d: VT_FALSE\n"
operator|,
name|SC_DRIVER_NAME
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|VT_TRUE
case|:
comment|/* user has released screen, go on */
if|if
condition|(
operator|(
name|error
operator|=
name|finish_vt_rel
argument_list|(
name|scp
argument_list|,
name|TRUE
argument_list|,
operator|&
name|s
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|DPRINTF
argument_list|(
literal|5
argument_list|,
operator|(
literal|"%s%d: VT_TRUE\n"
operator|,
name|SC_DRIVER_NAME
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|VT_ACKACQ
case|:
comment|/* acquire acknowledged, switch completed */
if|if
condition|(
operator|(
name|error
operator|=
name|finish_vt_acq
argument_list|(
name|scp
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|DPRINTF
argument_list|(
literal|5
argument_list|,
operator|(
literal|"%s%d: VT_ACKACQ\n"
operator|,
name|SC_DRIVER_NAME
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
case|case
name|VT_OPENQRY
case|:
comment|/* return free virtual console */
for|for
control|(
name|i
operator|=
name|sc
operator|->
name|first_vty
init|;
name|i
operator|<
name|sc
operator|->
name|first_vty
operator|+
name|sc
operator|->
name|vtys
condition|;
name|i
operator|++
control|)
block|{
name|tp
operator|=
name|SC_DEV
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tty_opened
argument_list|(
name|tp
argument_list|)
condition|)
block|{
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|i
operator|+
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
name|EINVAL
return|;
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_FREEBSD6
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_FREEBSD5
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|COMPAT_FREEBSD4
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_43
argument_list|)
case|case
name|_IO
argument_list|(
literal|'v'
argument_list|,
literal|5
argument_list|)
case|:
name|ival
operator|=
name|IOCPARM_IVAL
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|ival
expr_stmt|;
comment|/* FALLTHROUGH */
endif|#
directive|endif
case|case
name|VT_ACTIVATE
case|:
comment|/* switch to screen *data */
name|i
operator|=
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|==
literal|0
operator|)
condition|?
name|scp
operator|->
name|index
else|:
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|-
literal|1
operator|)
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|error
operator|=
name|sc_clean_up
argument_list|(
name|sc
operator|->
name|cur_scp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|error
operator|=
name|sc_switch_scr
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_FREEBSD6
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_FREEBSD5
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|COMPAT_FREEBSD4
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_43
argument_list|)
case|case
name|_IO
argument_list|(
literal|'v'
argument_list|,
literal|6
argument_list|)
case|:
name|ival
operator|=
name|IOCPARM_IVAL
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|ival
expr_stmt|;
comment|/* FALLTHROUGH */
endif|#
directive|endif
case|case
name|VT_WAITACTIVE
case|:
comment|/* wait for switch to occur */
name|i
operator|=
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|==
literal|0
operator|)
condition|?
name|scp
operator|->
name|index
else|:
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|<
name|sc
operator|->
name|first_vty
operator|)
operator|||
operator|(
name|i
operator|>=
name|sc
operator|->
name|first_vty
operator|+
name|sc
operator|->
name|vtys
operator|)
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|i
operator|==
name|sc
operator|->
name|cur_scp
operator|->
name|index
condition|)
return|return
literal|0
return|;
name|error
operator|=
name|tsleep
argument_list|(
name|VTY_WCHAN
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
argument_list|,
operator|(
name|PZERO
operator|+
literal|1
operator|)
operator||
name|PCATCH
argument_list|,
literal|"waitvt"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|error
return|;
case|case
name|VT_GETACTIVE
case|:
comment|/* get active vty # */
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|sc
operator|->
name|cur_scp
operator|->
name|index
operator|+
literal|1
expr_stmt|;
return|return
literal|0
return|;
case|case
name|VT_GETINDEX
case|:
comment|/* get this vty # */
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|scp
operator|->
name|index
operator|+
literal|1
expr_stmt|;
return|return
literal|0
return|;
case|case
name|VT_LOCKSWITCH
case|:
comment|/* prevent vty switching */
if|if
condition|(
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|)
operator|&
literal|0x01
condition|)
name|sc
operator|->
name|flags
operator||=
name|SC_SCRN_VTYLOCK
expr_stmt|;
else|else
name|sc
operator|->
name|flags
operator|&=
operator|~
name|SC_SCRN_VTYLOCK
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KDENABIO
case|:
comment|/* allow io operations */
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_IO
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|error
operator|=
name|securelevel_gt
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
ifdef|#
directive|ifdef
name|__i386__
name|td
operator|->
name|td_frame
operator|->
name|tf_eflags
operator||=
name|PSL_IOPL
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__amd64__
argument_list|)
name|td
operator|->
name|td_frame
operator|->
name|tf_rflags
operator||=
name|PSL_IOPL
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
case|case
name|KDDISABIO
case|:
comment|/* disallow io operations (default) */
ifdef|#
directive|ifdef
name|__i386__
name|td
operator|->
name|td_frame
operator|->
name|tf_eflags
operator|&=
operator|~
name|PSL_IOPL
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__amd64__
argument_list|)
name|td
operator|->
name|td_frame
operator|->
name|tf_rflags
operator|&=
operator|~
name|PSL_IOPL
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_FREEBSD6
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_FREEBSD5
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|COMPAT_FREEBSD4
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_43
argument_list|)
case|case
name|_IO
argument_list|(
literal|'K'
argument_list|,
literal|20
argument_list|)
case|:
name|ival
operator|=
name|IOCPARM_IVAL
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|ival
expr_stmt|;
comment|/* FALLTHROUGH */
endif|#
directive|endif
case|case
name|KDSKBSTATE
case|:
comment|/* set keyboard state (locks) */
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
operator|~
name|LOCK_MASK
condition|)
return|return
name|EINVAL
return|;
name|scp
operator|->
name|status
operator|&=
operator|~
name|LOCK_MASK
expr_stmt|;
name|scp
operator|->
name|status
operator||=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|scp
operator|==
name|sc
operator|->
name|cur_scp
condition|)
name|update_kbd_state
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|status
argument_list|,
name|LOCK_MASK
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KDGKBSTATE
case|:
comment|/* get keyboard state (locks) */
if|if
condition|(
name|scp
operator|==
name|sc
operator|->
name|cur_scp
condition|)
name|save_kbd_state
argument_list|(
name|scp
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|scp
operator|->
name|status
operator|&
name|LOCK_MASK
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KDGETREPEAT
case|:
comment|/* get keyboard repeat& delay rates */
case|case
name|KDSETREPEAT
case|:
comment|/* set keyboard repeat& delay rates (new) */
name|error
operator|=
name|kbdd_ioctl
argument_list|(
name|sc
operator|->
name|kbd
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOIOCTL
condition|)
name|error
operator|=
name|ENODEV
expr_stmt|;
return|return
name|error
return|;
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_FREEBSD6
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_FREEBSD5
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|COMPAT_FREEBSD4
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_43
argument_list|)
case|case
name|_IO
argument_list|(
literal|'K'
argument_list|,
literal|67
argument_list|)
case|:
name|ival
operator|=
name|IOCPARM_IVAL
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|ival
expr_stmt|;
comment|/* FALLTHROUGH */
endif|#
directive|endif
case|case
name|KDSETRAD
case|:
comment|/* set keyboard repeat& delay rates (old) */
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
operator|~
literal|0x7f
condition|)
return|return
name|EINVAL
return|;
name|error
operator|=
name|kbdd_ioctl
argument_list|(
name|sc
operator|->
name|kbd
argument_list|,
name|KDSETRAD
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOIOCTL
condition|)
name|error
operator|=
name|ENODEV
expr_stmt|;
return|return
name|error
return|;
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_FREEBSD6
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_FREEBSD5
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|COMPAT_FREEBSD4
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_43
argument_list|)
case|case
name|_IO
argument_list|(
literal|'K'
argument_list|,
literal|7
argument_list|)
case|:
name|ival
operator|=
name|IOCPARM_IVAL
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|ival
expr_stmt|;
comment|/* FALLTHROUGH */
endif|#
directive|endif
case|case
name|KDSKBMODE
case|:
comment|/* set keyboard mode */
switch|switch
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
block|{
case|case
name|K_XLATE
case|:
comment|/* switch to XLT ascii mode */
case|case
name|K_RAW
case|:
comment|/* switch to RAW scancode mode */
case|case
name|K_CODE
case|:
comment|/* switch to CODE mode */
name|scp
operator|->
name|kbd_mode
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|scp
operator|==
name|sc
operator|->
name|cur_scp
condition|)
operator|(
name|void
operator|)
name|kbdd_ioctl
argument_list|(
name|sc
operator|->
name|kbd
argument_list|,
name|KDSKBMODE
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
default|default:
return|return
name|EINVAL
return|;
block|}
comment|/* NOT REACHED */
case|case
name|KDGKBMODE
case|:
comment|/* get keyboard mode */
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|scp
operator|->
name|kbd_mode
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KDGKBINFO
case|:
name|error
operator|=
name|kbdd_ioctl
argument_list|(
name|sc
operator|->
name|kbd
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOIOCTL
condition|)
name|error
operator|=
name|ENODEV
expr_stmt|;
return|return
name|error
return|;
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_FREEBSD6
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_FREEBSD5
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|COMPAT_FREEBSD4
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_43
argument_list|)
case|case
name|_IO
argument_list|(
literal|'K'
argument_list|,
literal|8
argument_list|)
case|:
name|ival
operator|=
name|IOCPARM_IVAL
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|ival
expr_stmt|;
comment|/* FALLTHROUGH */
endif|#
directive|endif
case|case
name|KDMKTONE
case|:
comment|/* sound the bell */
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
name|sc_bell
argument_list|(
name|scp
argument_list|,
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|)
operator|&
literal|0xffff
argument_list|,
operator|(
operator|(
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|)
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
operator|*
name|hz
operator|/
literal|1000
argument_list|)
expr_stmt|;
else|else
name|sc_bell
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|bell_pitch
argument_list|,
name|scp
operator|->
name|bell_duration
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_FREEBSD6
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_FREEBSD5
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|COMPAT_FREEBSD4
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_43
argument_list|)
case|case
name|_IO
argument_list|(
literal|'K'
argument_list|,
literal|63
argument_list|)
case|:
name|ival
operator|=
name|IOCPARM_IVAL
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|ival
expr_stmt|;
comment|/* FALLTHROUGH */
endif|#
directive|endif
case|case
name|KIOCSOUND
case|:
comment|/* make tone (*data) hz */
if|if
condition|(
name|scp
operator|==
name|sc
operator|->
name|cur_scp
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
return|return
name|sc_tone
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
return|;
else|else
return|return
name|sc_tone
argument_list|(
literal|0
argument_list|)
return|;
block|}
return|return
literal|0
return|;
case|case
name|KDGKBTYPE
case|:
comment|/* get keyboard type */
name|error
operator|=
name|kbdd_ioctl
argument_list|(
name|sc
operator|->
name|kbd
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOIOCTL
condition|)
block|{
comment|/* always return something? XXX */
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_FREEBSD6
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_FREEBSD5
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|COMPAT_FREEBSD4
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_43
argument_list|)
case|case
name|_IO
argument_list|(
literal|'K'
argument_list|,
literal|66
argument_list|)
case|:
name|ival
operator|=
name|IOCPARM_IVAL
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|ival
expr_stmt|;
comment|/* FALLTHROUGH */
endif|#
directive|endif
case|case
name|KDSETLED
case|:
comment|/* set keyboard LED status */
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
operator|~
name|LED_MASK
condition|)
comment|/* FIXME: LOCK_MASK? */
return|return
name|EINVAL
return|;
name|scp
operator|->
name|status
operator|&=
operator|~
name|LED_MASK
expr_stmt|;
name|scp
operator|->
name|status
operator||=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|scp
operator|==
name|sc
operator|->
name|cur_scp
condition|)
name|update_kbd_leds
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|status
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KDGETLED
case|:
comment|/* get keyboard LED status */
if|if
condition|(
name|scp
operator|==
name|sc
operator|->
name|cur_scp
condition|)
name|save_kbd_state
argument_list|(
name|scp
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|scp
operator|->
name|status
operator|&
name|LED_MASK
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KBADDKBD
case|:
comment|/* add/remove keyboard to/from mux */
case|case
name|KBRELKBD
case|:
name|error
operator|=
name|kbdd_ioctl
argument_list|(
name|sc
operator|->
name|kbd
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOIOCTL
condition|)
name|error
operator|=
name|ENODEV
expr_stmt|;
return|return
name|error
return|;
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_FREEBSD6
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_FREEBSD5
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|COMPAT_FREEBSD4
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_43
argument_list|)
case|case
name|_IO
argument_list|(
literal|'c'
argument_list|,
literal|110
argument_list|)
case|:
name|ival
operator|=
name|IOCPARM_IVAL
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|ival
expr_stmt|;
comment|/* FALLTHROUGH */
endif|#
directive|endif
case|case
name|CONS_SETKBD
case|:
comment|/* set the new keyboard */
block|{
name|keyboard_t
modifier|*
name|newkbd
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|newkbd
operator|=
name|kbd_get_keyboard
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|newkbd
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|kbd
operator|!=
name|newkbd
condition|)
block|{
name|i
operator|=
name|kbd_allocate
argument_list|(
name|newkbd
operator|->
name|kb_name
argument_list|,
name|newkbd
operator|->
name|kb_unit
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|sc
operator|->
name|keyboard
argument_list|,
name|sckbdevent
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* i == newkbd->kb_index */
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|kbd
operator|!=
name|NULL
condition|)
block|{
name|save_kbd_state
argument_list|(
name|sc
operator|->
name|cur_scp
argument_list|)
expr_stmt|;
name|kbd_release
argument_list|(
name|sc
operator|->
name|kbd
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|sc
operator|->
name|keyboard
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|kbd
operator|=
name|kbd_get_keyboard
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* sc->kbd == newkbd */
name|sc
operator|->
name|keyboard
operator|=
name|i
expr_stmt|;
operator|(
name|void
operator|)
name|kbdd_ioctl
argument_list|(
name|sc
operator|->
name|kbd
argument_list|,
name|KDSKBMODE
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sc
operator|->
name|cur_scp
operator|->
name|kbd_mode
argument_list|)
expr_stmt|;
name|update_kbd_state
argument_list|(
name|sc
operator|->
name|cur_scp
argument_list|,
name|sc
operator|->
name|cur_scp
operator|->
name|status
argument_list|,
name|LOCK_MASK
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|EPERM
expr_stmt|;
comment|/* XXX */
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
case|case
name|CONS_RELKBD
case|:
comment|/* release the current keyboard */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|kbd
operator|!=
name|NULL
condition|)
block|{
name|save_kbd_state
argument_list|(
name|sc
operator|->
name|cur_scp
argument_list|)
expr_stmt|;
name|error
operator|=
name|kbd_release
argument_list|(
name|sc
operator|->
name|kbd
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|sc
operator|->
name|keyboard
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|kbd
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|keyboard
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
case|case
name|CONS_GETTERM
case|:
comment|/* get the current terminal emulator info */
block|{
name|sc_term_sw_t
modifier|*
name|sw
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|term_info_t
operator|*
operator|)
name|data
operator|)
operator|->
name|ti_index
operator|==
literal|0
condition|)
block|{
name|sw
operator|=
name|scp
operator|->
name|tsw
expr_stmt|;
block|}
else|else
block|{
name|sw
operator|=
name|sc_term_match_by_number
argument_list|(
operator|(
operator|(
name|term_info_t
operator|*
operator|)
name|data
operator|)
operator|->
name|ti_index
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sw
operator|!=
name|NULL
condition|)
block|{
name|strncpy
argument_list|(
operator|(
operator|(
name|term_info_t
operator|*
operator|)
name|data
operator|)
operator|->
name|ti_name
argument_list|,
name|sw
operator|->
name|te_name
argument_list|,
sizeof|sizeof
argument_list|(
operator|(
operator|(
name|term_info_t
operator|*
operator|)
name|data
operator|)
operator|->
name|ti_name
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
operator|(
operator|(
name|term_info_t
operator|*
operator|)
name|data
operator|)
operator|->
name|ti_desc
argument_list|,
name|sw
operator|->
name|te_desc
argument_list|,
sizeof|sizeof
argument_list|(
operator|(
operator|(
name|term_info_t
operator|*
operator|)
name|data
operator|)
operator|->
name|ti_desc
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|(
name|term_info_t
operator|*
operator|)
name|data
operator|)
operator|->
name|ti_flags
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
operator|(
operator|(
name|term_info_t
operator|*
operator|)
name|data
operator|)
operator|->
name|ti_name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
operator|(
name|term_info_t
operator|*
operator|)
name|data
operator|)
operator|->
name|ti_desc
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
operator|(
name|term_info_t
operator|*
operator|)
name|data
operator|)
operator|->
name|ti_flags
operator|=
literal|0
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
block|}
case|case
name|CONS_SETTERM
case|:
comment|/* set the current terminal emulator */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|error
operator|=
name|sc_init_emulator
argument_list|(
name|scp
argument_list|,
operator|(
operator|(
name|term_info_t
operator|*
operator|)
name|data
operator|)
operator|->
name|ti_name
argument_list|)
expr_stmt|;
comment|/* FIXME: what if scp == sc_console! XXX */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
case|case
name|GIO_SCRNMAP
case|:
comment|/* get output translation table */
name|bcopy
argument_list|(
operator|&
name|sc
operator|->
name|scr_map
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|scr_map
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|PIO_SCRNMAP
case|:
comment|/* set output translation table */
name|bcopy
argument_list|(
name|data
argument_list|,
operator|&
name|sc
operator|->
name|scr_map
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|scr_map
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|scr_map
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|scr_rmap
index|[
name|sc
operator|->
name|scr_map
index|[
name|i
index|]
index|]
operator|=
name|i
expr_stmt|;
block|}
return|return
literal|0
return|;
case|case
name|GIO_KEYMAP
case|:
comment|/* get keyboard translation table */
case|case
name|PIO_KEYMAP
case|:
comment|/* set keyboard translation table */
case|case
name|OGIO_KEYMAP
case|:
comment|/* get keyboard translation table (compat) */
case|case
name|OPIO_KEYMAP
case|:
comment|/* set keyboard translation table (compat) */
case|case
name|GIO_DEADKEYMAP
case|:
comment|/* get accent key translation table */
case|case
name|PIO_DEADKEYMAP
case|:
comment|/* set accent key translation table */
case|case
name|GETFKEY
case|:
comment|/* get function key string */
case|case
name|SETFKEY
case|:
comment|/* set function key string */
name|error
operator|=
name|kbdd_ioctl
argument_list|(
name|sc
operator|->
name|kbd
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOIOCTL
condition|)
name|error
operator|=
name|ENODEV
expr_stmt|;
return|return
name|error
return|;
ifndef|#
directive|ifndef
name|SC_NO_FONT_LOADING
case|case
name|PIO_FONT8x8
case|:
comment|/* set 8x8 dot font */
if|if
condition|(
operator|!
name|ISFONTAVAIL
argument_list|(
name|sc
operator|->
name|adp
operator|->
name|va_flags
argument_list|)
condition|)
return|return
name|ENXIO
return|;
name|bcopy
argument_list|(
name|data
argument_list|,
name|sc
operator|->
name|font_8
argument_list|,
literal|8
operator|*
literal|256
argument_list|)
expr_stmt|;
name|sc
operator|->
name|fonts_loaded
operator||=
name|FONT_8
expr_stmt|;
comment|/* 	 * FONT KLUDGE 	 * Always use the font page #0. XXX 	 * Don't load if the current font size is not 8x8. 	 */
if|if
condition|(
name|ISTEXTSC
argument_list|(
name|sc
operator|->
name|cur_scp
argument_list|)
operator|&&
operator|(
name|sc
operator|->
name|cur_scp
operator|->
name|font_size
operator|<
literal|14
operator|)
condition|)
name|sc_load_font
argument_list|(
name|sc
operator|->
name|cur_scp
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
literal|8
argument_list|,
name|sc
operator|->
name|font_8
argument_list|,
literal|0
argument_list|,
literal|256
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|GIO_FONT8x8
case|:
comment|/* get 8x8 dot font */
if|if
condition|(
operator|!
name|ISFONTAVAIL
argument_list|(
name|sc
operator|->
name|adp
operator|->
name|va_flags
argument_list|)
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
name|sc
operator|->
name|fonts_loaded
operator|&
name|FONT_8
condition|)
block|{
name|bcopy
argument_list|(
name|sc
operator|->
name|font_8
argument_list|,
name|data
argument_list|,
literal|8
operator|*
literal|256
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
name|ENXIO
return|;
case|case
name|PIO_FONT8x14
case|:
comment|/* set 8x14 dot font */
if|if
condition|(
operator|!
name|ISFONTAVAIL
argument_list|(
name|sc
operator|->
name|adp
operator|->
name|va_flags
argument_list|)
condition|)
return|return
name|ENXIO
return|;
name|bcopy
argument_list|(
name|data
argument_list|,
name|sc
operator|->
name|font_14
argument_list|,
literal|14
operator|*
literal|256
argument_list|)
expr_stmt|;
name|sc
operator|->
name|fonts_loaded
operator||=
name|FONT_14
expr_stmt|;
comment|/* 	 * FONT KLUDGE 	 * Always use the font page #0. XXX 	 * Don't load if the current font size is not 8x14. 	 */
if|if
condition|(
name|ISTEXTSC
argument_list|(
name|sc
operator|->
name|cur_scp
argument_list|)
operator|&&
operator|(
name|sc
operator|->
name|cur_scp
operator|->
name|font_size
operator|>=
literal|14
operator|)
operator|&&
operator|(
name|sc
operator|->
name|cur_scp
operator|->
name|font_size
operator|<
literal|16
operator|)
condition|)
name|sc_load_font
argument_list|(
name|sc
operator|->
name|cur_scp
argument_list|,
literal|0
argument_list|,
literal|14
argument_list|,
literal|8
argument_list|,
name|sc
operator|->
name|font_14
argument_list|,
literal|0
argument_list|,
literal|256
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|GIO_FONT8x14
case|:
comment|/* get 8x14 dot font */
if|if
condition|(
operator|!
name|ISFONTAVAIL
argument_list|(
name|sc
operator|->
name|adp
operator|->
name|va_flags
argument_list|)
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
name|sc
operator|->
name|fonts_loaded
operator|&
name|FONT_14
condition|)
block|{
name|bcopy
argument_list|(
name|sc
operator|->
name|font_14
argument_list|,
name|data
argument_list|,
literal|14
operator|*
literal|256
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
name|ENXIO
return|;
case|case
name|PIO_FONT8x16
case|:
comment|/* set 8x16 dot font */
if|if
condition|(
operator|!
name|ISFONTAVAIL
argument_list|(
name|sc
operator|->
name|adp
operator|->
name|va_flags
argument_list|)
condition|)
return|return
name|ENXIO
return|;
name|bcopy
argument_list|(
name|data
argument_list|,
name|sc
operator|->
name|font_16
argument_list|,
literal|16
operator|*
literal|256
argument_list|)
expr_stmt|;
name|sc
operator|->
name|fonts_loaded
operator||=
name|FONT_16
expr_stmt|;
comment|/* 	 * FONT KLUDGE 	 * Always use the font page #0. XXX 	 * Don't load if the current font size is not 8x16. 	 */
if|if
condition|(
name|ISTEXTSC
argument_list|(
name|sc
operator|->
name|cur_scp
argument_list|)
operator|&&
operator|(
name|sc
operator|->
name|cur_scp
operator|->
name|font_size
operator|>=
literal|16
operator|)
condition|)
name|sc_load_font
argument_list|(
name|sc
operator|->
name|cur_scp
argument_list|,
literal|0
argument_list|,
literal|16
argument_list|,
literal|8
argument_list|,
name|sc
operator|->
name|font_16
argument_list|,
literal|0
argument_list|,
literal|256
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|GIO_FONT8x16
case|:
comment|/* get 8x16 dot font */
if|if
condition|(
operator|!
name|ISFONTAVAIL
argument_list|(
name|sc
operator|->
name|adp
operator|->
name|va_flags
argument_list|)
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
name|sc
operator|->
name|fonts_loaded
operator|&
name|FONT_16
condition|)
block|{
name|bcopy
argument_list|(
name|sc
operator|->
name|font_16
argument_list|,
name|data
argument_list|,
literal|16
operator|*
literal|256
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
name|ENXIO
return|;
endif|#
directive|endif
comment|/* SC_NO_FONT_LOADING */
default|default:
break|break;
block|}
return|return
operator|(
name|ENOIOCTL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|consolectl_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|fflag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
name|sctty_ioctl
argument_list|(
name|dev
operator|->
name|si_drv1
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|td
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sc_cnprobe
parameter_list|(
name|struct
name|consdev
modifier|*
name|cp
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|cp
operator|->
name|cn_pri
operator|=
name|sc_get_cons_priority
argument_list|(
operator|&
name|unit
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
comment|/* a video card is always required */
if|if
condition|(
operator|!
name|scvidprobe
argument_list|(
name|unit
argument_list|,
name|flags
argument_list|,
name|TRUE
argument_list|)
condition|)
name|cp
operator|->
name|cn_pri
operator|=
name|CN_DEAD
expr_stmt|;
comment|/* syscons will become console even when there is no keyboard */
name|sckbdprobe
argument_list|(
name|unit
argument_list|,
name|flags
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|cn_pri
operator|==
name|CN_DEAD
condition|)
return|return;
comment|/* initialize required fields */
name|strcpy
argument_list|(
name|cp
operator|->
name|cn_name
argument_list|,
literal|"ttyv0"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sc_cninit
parameter_list|(
name|struct
name|consdev
modifier|*
name|cp
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|sc_get_cons_priority
argument_list|(
operator|&
name|unit
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
name|scinit
argument_list|(
name|unit
argument_list|,
name|flags
operator||
name|SC_KERNEL_CONSOLE
argument_list|)
expr_stmt|;
name|sc_console_unit
operator|=
name|unit
expr_stmt|;
name|sc_console
operator|=
name|sc_get_stat
argument_list|(
name|sc_get_softc
argument_list|(
name|unit
argument_list|,
name|SC_KERNEL_CONSOLE
argument_list|)
operator|->
name|dev
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sc_consptr
operator|=
name|cp
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sc_cnterm
parameter_list|(
name|struct
name|consdev
modifier|*
name|cp
parameter_list|)
block|{
comment|/* we are not the kernel console any more, release everything */
if|if
condition|(
name|sc_console_unit
operator|<
literal|0
condition|)
return|return;
comment|/* shouldn't happen */
if|#
directive|if
literal|0
comment|/* XXX */
block|sc_clear_screen(sc_console);     sccnupdate(sc_console);
endif|#
directive|endif
name|scterm
argument_list|(
name|sc_console_unit
argument_list|,
name|SC_KERNEL_CONSOLE
argument_list|)
expr_stmt|;
name|sc_console_unit
operator|=
operator|-
literal|1
expr_stmt|;
name|sc_console
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sc_cnputc
parameter_list|(
name|struct
name|consdev
modifier|*
name|cd
parameter_list|,
name|int
name|c
parameter_list|)
block|{
name|u_char
name|buf
index|[
literal|1
index|]
decl_stmt|;
name|scr_stat
modifier|*
name|scp
init|=
name|sc_console
decl_stmt|;
ifndef|#
directive|ifndef
name|SC_NO_HISTORY
if|#
directive|if
literal|0
block|struct tty *tp;
endif|#
directive|endif
endif|#
directive|endif
comment|/* !SC_NO_HISTORY */
name|int
name|s
decl_stmt|;
comment|/* assert(sc_console != NULL) */
ifndef|#
directive|ifndef
name|SC_NO_HISTORY
if|if
condition|(
name|scp
operator|==
name|scp
operator|->
name|sc
operator|->
name|cur_scp
operator|&&
name|scp
operator|->
name|status
operator|&
name|SLKED
condition|)
block|{
name|scp
operator|->
name|status
operator|&=
operator|~
name|SLKED
expr_stmt|;
name|update_kbd_state
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|status
argument_list|,
name|SLKED
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|BUFFER_SAVED
condition|)
block|{
if|if
condition|(
operator|!
name|sc_hist_restore
argument_list|(
name|scp
argument_list|)
condition|)
name|sc_remove_cutmarking
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|scp
operator|->
name|status
operator|&=
operator|~
name|BUFFER_SAVED
expr_stmt|;
name|scp
operator|->
name|status
operator||=
name|CURSOR_ENABLED
expr_stmt|;
name|sc_draw_cursor_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* 	 * XXX: Now that TTY's have their own locks, we cannot process 	 * any data after disabling scroll lock. cnputs already holds a 	 * spinlock. 	 */
block|tp = SC_DEV(scp->sc, scp->index); 	tty_lock(tp); 	if (tty_opened(tp)) 	    sctty_outwakeup(tp); 	tty_unlock(tp);
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* !SC_NO_HISTORY */
name|buf
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|sc_puts
argument_list|(
name|scp
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* block sckbdevent and scrn_timer */
name|sccnupdate
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sc_cngetc
parameter_list|(
name|struct
name|consdev
modifier|*
name|cd
parameter_list|)
block|{
specifier|static
name|struct
name|fkeytab
name|fkey
decl_stmt|;
specifier|static
name|int
name|fkeycp
decl_stmt|;
name|scr_stat
modifier|*
name|scp
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|p
decl_stmt|;
name|int
name|cur_mode
decl_stmt|;
name|int
name|s
init|=
name|spltty
argument_list|()
decl_stmt|;
comment|/* block sckbdevent and scrn_timer while we poll */
name|int
name|c
decl_stmt|;
comment|/* assert(sc_console != NULL) */
comment|/*       * Stop the screen saver and update the screen if necessary.      * What if we have been running in the screen saver code... XXX      */
name|sc_touch_scrn_saver
argument_list|()
expr_stmt|;
name|scp
operator|=
name|sc_console
operator|->
name|sc
operator|->
name|cur_scp
expr_stmt|;
comment|/* XXX */
name|sccnupdate
argument_list|(
name|scp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fkeycp
operator|<
name|fkey
operator|.
name|len
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|fkey
operator|.
name|str
index|[
name|fkeycp
operator|++
index|]
return|;
block|}
if|if
condition|(
name|scp
operator|->
name|sc
operator|->
name|kbd
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/*       * Make sure the keyboard is accessible even when the kbd device      * driver is disabled.      */
name|kbdd_enable
argument_list|(
name|scp
operator|->
name|sc
operator|->
name|kbd
argument_list|)
expr_stmt|;
comment|/* we shall always use the keyboard in the XLATE mode here */
name|cur_mode
operator|=
name|scp
operator|->
name|kbd_mode
expr_stmt|;
name|scp
operator|->
name|kbd_mode
operator|=
name|K_XLATE
expr_stmt|;
operator|(
name|void
operator|)
name|kbdd_ioctl
argument_list|(
name|scp
operator|->
name|sc
operator|->
name|kbd
argument_list|,
name|KDSKBMODE
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|scp
operator|->
name|kbd_mode
argument_list|)
expr_stmt|;
name|kbdd_poll
argument_list|(
name|scp
operator|->
name|sc
operator|->
name|kbd
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|c
operator|=
name|scgetc
argument_list|(
name|scp
operator|->
name|sc
argument_list|,
name|SCGETC_CN
operator||
name|SCGETC_NONBLOCK
argument_list|)
expr_stmt|;
name|kbdd_poll
argument_list|(
name|scp
operator|->
name|sc
operator|->
name|kbd
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|scp
operator|->
name|kbd_mode
operator|=
name|cur_mode
expr_stmt|;
operator|(
name|void
operator|)
name|kbdd_ioctl
argument_list|(
name|scp
operator|->
name|sc
operator|->
name|kbd
argument_list|,
name|KDSKBMODE
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|scp
operator|->
name|kbd_mode
argument_list|)
expr_stmt|;
name|kbdd_disable
argument_list|(
name|scp
operator|->
name|sc
operator|->
name|kbd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|KEYFLAGS
argument_list|(
name|c
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* normal char */
return|return
name|KEYCHAR
argument_list|(
name|c
argument_list|)
return|;
case|case
name|FKEY
case|:
comment|/* function key */
name|p
operator|=
call|(
modifier|*
name|scp
operator|->
name|tsw
operator|->
name|te_fkeystr
call|)
argument_list|(
name|scp
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|fkey
operator|.
name|len
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|p
argument_list|,
name|fkey
operator|.
name|str
argument_list|,
name|fkey
operator|.
name|len
argument_list|)
expr_stmt|;
name|fkeycp
operator|=
literal|1
expr_stmt|;
return|return
name|fkey
operator|.
name|str
index|[
literal|0
index|]
return|;
block|}
name|p
operator|=
name|kbdd_get_fkeystr
argument_list|(
name|scp
operator|->
name|sc
operator|->
name|kbd
argument_list|,
name|KEYCHAR
argument_list|(
name|c
argument_list|)
argument_list|,
operator|(
name|size_t
operator|*
operator|)
operator|&
name|fkeycp
argument_list|)
expr_stmt|;
name|fkey
operator|.
name|len
operator|=
name|fkeycp
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|fkey
operator|.
name|len
operator|>
literal|0
operator|)
condition|)
block|{
name|bcopy
argument_list|(
name|p
argument_list|,
name|fkey
operator|.
name|str
argument_list|,
name|fkey
operator|.
name|len
argument_list|)
expr_stmt|;
name|fkeycp
operator|=
literal|1
expr_stmt|;
return|return
name|fkey
operator|.
name|str
index|[
literal|0
index|]
return|;
block|}
return|return
name|c
return|;
comment|/* XXX */
case|case
name|NOKEY
case|:
case|case
name|ERRKEY
case|:
default|default:
return|return
operator|-
literal|1
return|;
block|}
comment|/* NOT REACHED */
block|}
end_function

begin_function
specifier|static
name|void
name|sccnupdate
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
comment|/* this is a cut-down version of scrn_timer()... */
if|if
condition|(
name|suspend_in_progress
operator|||
name|scp
operator|->
name|sc
operator|->
name|font_loading_in_progress
condition|)
return|return;
if|if
condition|(
name|debugger
operator|>
literal|0
operator|||
name|panicstr
operator|||
name|shutdown_in_progress
condition|)
block|{
name|sc_touch_scrn_saver
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scp
operator|!=
name|scp
operator|->
name|sc
operator|->
name|cur_scp
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
name|run_scrn_saver
condition|)
name|scp
operator|->
name|sc
operator|->
name|flags
operator|&=
operator|~
name|SC_SCRN_IDLE
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_SPLASH
if|if
condition|(
operator|(
name|saver_mode
operator|!=
name|CONS_LKM_SAVER
operator|)
operator|||
operator|!
operator|(
name|scp
operator|->
name|sc
operator|->
name|flags
operator|&
name|SC_SCRN_IDLE
operator|)
condition|)
if|if
condition|(
name|scp
operator|->
name|sc
operator|->
name|flags
operator|&
name|SC_SCRN_BLANKED
condition|)
name|stop_scrn_saver
argument_list|(
name|scp
operator|->
name|sc
argument_list|,
name|current_saver
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|scp
operator|!=
name|scp
operator|->
name|sc
operator|->
name|cur_scp
operator|||
name|scp
operator|->
name|sc
operator|->
name|blink_in_progress
operator|||
name|scp
operator|->
name|sc
operator|->
name|switch_in_progress
condition|)
return|return;
comment|/*      * FIXME: unlike scrn_timer(), we call scrn_update() from here even      * when write_in_progress is non-zero.  XXX      */
if|if
condition|(
operator|!
name|ISGRAPHSC
argument_list|(
name|scp
argument_list|)
operator|&&
operator|!
operator|(
name|scp
operator|->
name|sc
operator|->
name|flags
operator|&
name|SC_SCRN_BLANKED
operator|)
condition|)
name|scrn_update
argument_list|(
name|scp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|scrn_timer
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|PC98
specifier|static
name|int
name|kbd_interval
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|struct
name|timeval
name|tv
decl_stmt|;
name|sc_softc_t
modifier|*
name|sc
decl_stmt|;
name|scr_stat
modifier|*
name|scp
decl_stmt|;
name|int
name|again
decl_stmt|;
name|int
name|s
decl_stmt|;
name|again
operator|=
operator|(
name|arg
operator|!=
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|arg
operator|!=
name|NULL
condition|)
name|sc
operator|=
operator|(
name|sc_softc_t
operator|*
operator|)
name|arg
expr_stmt|;
elseif|else
if|if
condition|(
name|sc_console
operator|!=
name|NULL
condition|)
name|sc
operator|=
name|sc_console
operator|->
name|sc
expr_stmt|;
else|else
return|return;
comment|/* don't do anything when we are performing some I/O operations */
if|if
condition|(
name|suspend_in_progress
operator|||
name|sc
operator|->
name|font_loading_in_progress
condition|)
block|{
if|if
condition|(
name|again
condition|)
name|timeout
argument_list|(
name|scrn_timer
argument_list|,
name|sc
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
return|return;
block|}
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|PC98
if|if
condition|(
operator|(
name|sc
operator|->
name|kbd
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|sc
operator|->
name|config
operator|&
name|SC_AUTODETECT_KBD
operator|)
condition|)
block|{
comment|/* try to allocate a keyboard automatically */
if|if
condition|(
operator|++
name|kbd_interval
operator|>=
literal|25
condition|)
block|{
name|sc
operator|->
name|keyboard
operator|=
name|sc_allocate_keyboard
argument_list|(
name|sc
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|keyboard
operator|>=
literal|0
condition|)
block|{
name|sc
operator|->
name|kbd
operator|=
name|kbd_get_keyboard
argument_list|(
name|sc
operator|->
name|keyboard
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|kbdd_ioctl
argument_list|(
name|sc
operator|->
name|kbd
argument_list|,
name|KDSKBMODE
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sc
operator|->
name|cur_scp
operator|->
name|kbd_mode
argument_list|)
expr_stmt|;
name|update_kbd_state
argument_list|(
name|sc
operator|->
name|cur_scp
argument_list|,
name|sc
operator|->
name|cur_scp
operator|->
name|status
argument_list|,
name|LOCK_MASK
argument_list|)
expr_stmt|;
block|}
name|kbd_interval
operator|=
literal|0
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* PC98 */
comment|/* find the vty to update */
name|scp
operator|=
name|sc
operator|->
name|cur_scp
expr_stmt|;
comment|/* should we stop the screen saver? */
name|getmicrouptime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugger
operator|>
literal|0
operator|||
name|panicstr
operator|||
name|shutdown_in_progress
condition|)
name|sc_touch_scrn_saver
argument_list|()
expr_stmt|;
if|if
condition|(
name|run_scrn_saver
condition|)
block|{
if|if
condition|(
name|tv
operator|.
name|tv_sec
operator|>
name|sc
operator|->
name|scrn_time_stamp
operator|+
name|scrn_blank_time
condition|)
name|sc
operator|->
name|flags
operator||=
name|SC_SCRN_IDLE
expr_stmt|;
else|else
name|sc
operator|->
name|flags
operator|&=
operator|~
name|SC_SCRN_IDLE
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|scrn_time_stamp
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
name|sc
operator|->
name|flags
operator|&=
operator|~
name|SC_SCRN_IDLE
expr_stmt|;
if|if
condition|(
name|scrn_blank_time
operator|>
literal|0
condition|)
name|run_scrn_saver
operator|=
name|TRUE
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEV_SPLASH
if|if
condition|(
operator|(
name|saver_mode
operator|!=
name|CONS_LKM_SAVER
operator|)
operator|||
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|SC_SCRN_IDLE
operator|)
condition|)
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|SC_SCRN_BLANKED
condition|)
name|stop_scrn_saver
argument_list|(
name|sc
argument_list|,
name|current_saver
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* should we just return ? */
if|if
condition|(
name|sc
operator|->
name|blink_in_progress
operator|||
name|sc
operator|->
name|switch_in_progress
operator|||
name|sc
operator|->
name|write_in_progress
condition|)
block|{
if|if
condition|(
name|again
condition|)
name|timeout
argument_list|(
name|scrn_timer
argument_list|,
name|sc
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Update the screen */
name|scp
operator|=
name|sc
operator|->
name|cur_scp
expr_stmt|;
comment|/* cur_scp may have changed... */
if|if
condition|(
operator|!
name|ISGRAPHSC
argument_list|(
name|scp
argument_list|)
operator|&&
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|SC_SCRN_BLANKED
operator|)
condition|)
name|scrn_update
argument_list|(
name|scp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_SPLASH
comment|/* should we activate the screen saver? */
if|if
condition|(
operator|(
name|saver_mode
operator|==
name|CONS_LKM_SAVER
operator|)
operator|&&
operator|(
name|sc
operator|->
name|flags
operator|&
name|SC_SCRN_IDLE
operator|)
condition|)
if|if
condition|(
operator|!
name|ISGRAPHSC
argument_list|(
name|scp
argument_list|)
operator|||
operator|(
name|sc
operator|->
name|flags
operator|&
name|SC_SCRN_BLANKED
operator|)
condition|)
call|(
modifier|*
name|current_saver
call|)
argument_list|(
name|sc
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|again
condition|)
name|timeout
argument_list|(
name|scrn_timer
argument_list|,
name|sc
argument_list|,
name|hz
operator|/
literal|25
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|and_region
parameter_list|(
name|int
modifier|*
name|s1
parameter_list|,
name|int
modifier|*
name|e1
parameter_list|,
name|int
name|s2
parameter_list|,
name|int
name|e2
parameter_list|)
block|{
if|if
condition|(
operator|*
name|e1
operator|<
name|s2
operator|||
name|e2
operator|<
operator|*
name|s1
condition|)
return|return
name|FALSE
return|;
operator|*
name|s1
operator|=
name|imax
argument_list|(
operator|*
name|s1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
operator|*
name|e1
operator|=
name|imin
argument_list|(
operator|*
name|e1
argument_list|,
name|e2
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|scrn_update
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|show_cursor
parameter_list|)
block|{
name|int
name|start
decl_stmt|;
name|int
name|end
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|e
decl_stmt|;
comment|/* assert(scp == scp->sc->cur_scp) */
name|SC_VIDEO_LOCK
argument_list|(
name|scp
operator|->
name|sc
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SC_NO_CUTPASTE
comment|/* remove the previous mouse pointer image if necessary */
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_VISIBLE
condition|)
block|{
name|s
operator|=
name|scp
operator|->
name|mouse_pos
expr_stmt|;
name|e
operator|=
name|scp
operator|->
name|mouse_pos
operator|+
name|scp
operator|->
name|xsize
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|scp
operator|->
name|status
operator|&
operator|(
name|MOUSE_MOVED
operator||
name|MOUSE_HIDDEN
operator|)
operator|)
operator|||
name|and_region
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|e
argument_list|,
name|scp
operator|->
name|start
argument_list|,
name|scp
operator|->
name|end
argument_list|)
operator|||
operator|(
operator|(
name|scp
operator|->
name|status
operator|&
name|CURSOR_ENABLED
operator|)
operator|&&
operator|(
name|scp
operator|->
name|cursor_pos
operator|!=
name|scp
operator|->
name|cursor_oldpos
operator|)
operator|&&
operator|(
name|and_region
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|e
argument_list|,
name|scp
operator|->
name|cursor_pos
argument_list|,
name|scp
operator|->
name|cursor_pos
argument_list|)
operator|||
name|and_region
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|e
argument_list|,
name|scp
operator|->
name|cursor_oldpos
argument_list|,
name|scp
operator|->
name|cursor_oldpos
argument_list|)
operator|)
operator|)
condition|)
block|{
name|sc_remove_mouse_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|end
operator|>=
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
condition|)
name|scp
operator|->
name|end
operator|=
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
operator|-
literal|1
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* !SC_NO_CUTPASTE */
if|#
directive|if
literal|1
comment|/* debug: XXX */
if|if
condition|(
name|scp
operator|->
name|end
operator|>=
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
condition|)
block|{
name|printf
argument_list|(
literal|"scrn_update(): scp->end %d> size_of_screen!!\n"
argument_list|,
name|scp
operator|->
name|end
argument_list|)
expr_stmt|;
name|scp
operator|->
name|end
operator|=
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|scp
operator|->
name|start
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"scrn_update(): scp->start %d< 0\n"
argument_list|,
name|scp
operator|->
name|start
argument_list|)
expr_stmt|;
name|scp
operator|->
name|start
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* update screen image */
if|if
condition|(
name|scp
operator|->
name|start
operator|<=
name|scp
operator|->
name|end
condition|)
block|{
if|if
condition|(
name|scp
operator|->
name|mouse_cut_end
operator|>=
literal|0
condition|)
block|{
comment|/* there is a marked region for cut& paste */
if|if
condition|(
name|scp
operator|->
name|mouse_cut_start
operator|<=
name|scp
operator|->
name|mouse_cut_end
condition|)
block|{
name|start
operator|=
name|scp
operator|->
name|mouse_cut_start
expr_stmt|;
name|end
operator|=
name|scp
operator|->
name|mouse_cut_end
expr_stmt|;
block|}
else|else
block|{
name|start
operator|=
name|scp
operator|->
name|mouse_cut_end
expr_stmt|;
name|end
operator|=
name|scp
operator|->
name|mouse_cut_start
operator|-
literal|1
expr_stmt|;
block|}
name|s
operator|=
name|start
expr_stmt|;
name|e
operator|=
name|end
expr_stmt|;
comment|/* does the cut-mark region overlap with the update region? */
if|if
condition|(
name|and_region
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|e
argument_list|,
name|scp
operator|->
name|start
argument_list|,
name|scp
operator|->
name|end
argument_list|)
condition|)
block|{
call|(
modifier|*
name|scp
operator|->
name|rndr
operator|->
name|draw
call|)
argument_list|(
name|scp
argument_list|,
name|s
argument_list|,
name|e
operator|-
name|s
operator|+
literal|1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|s
operator|=
literal|0
expr_stmt|;
name|e
operator|=
name|start
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|and_region
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|e
argument_list|,
name|scp
operator|->
name|start
argument_list|,
name|scp
operator|->
name|end
argument_list|)
condition|)
call|(
modifier|*
name|scp
operator|->
name|rndr
operator|->
name|draw
call|)
argument_list|(
name|scp
argument_list|,
name|s
argument_list|,
name|e
operator|-
name|s
operator|+
literal|1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|s
operator|=
name|end
operator|+
literal|1
expr_stmt|;
name|e
operator|=
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|and_region
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|e
argument_list|,
name|scp
operator|->
name|start
argument_list|,
name|scp
operator|->
name|end
argument_list|)
condition|)
call|(
modifier|*
name|scp
operator|->
name|rndr
operator|->
name|draw
call|)
argument_list|(
name|scp
argument_list|,
name|s
argument_list|,
name|e
operator|-
name|s
operator|+
literal|1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
call|(
modifier|*
name|scp
operator|->
name|rndr
operator|->
name|draw
call|)
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|start
argument_list|,
name|scp
operator|->
name|end
operator|-
name|scp
operator|->
name|start
operator|+
literal|1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
call|(
modifier|*
name|scp
operator|->
name|rndr
operator|->
name|draw
call|)
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|start
argument_list|,
name|scp
operator|->
name|end
operator|-
name|scp
operator|->
name|start
operator|+
literal|1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* we are not to show the cursor and the mouse pointer... */
if|if
condition|(
operator|!
name|show_cursor
condition|)
block|{
name|scp
operator|->
name|end
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|start
operator|=
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
operator|-
literal|1
expr_stmt|;
name|SC_VIDEO_UNLOCK
argument_list|(
name|scp
operator|->
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* update cursor image */
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|CURSOR_ENABLED
condition|)
block|{
name|s
operator|=
name|scp
operator|->
name|start
expr_stmt|;
name|e
operator|=
name|scp
operator|->
name|end
expr_stmt|;
comment|/* did cursor move since last time ? */
if|if
condition|(
name|scp
operator|->
name|cursor_pos
operator|!=
name|scp
operator|->
name|cursor_oldpos
condition|)
block|{
comment|/* do we need to remove old cursor image ? */
if|if
condition|(
operator|!
name|and_region
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|e
argument_list|,
name|scp
operator|->
name|cursor_oldpos
argument_list|,
name|scp
operator|->
name|cursor_oldpos
argument_list|)
condition|)
name|sc_remove_cursor_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|sc_draw_cursor_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|and_region
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|e
argument_list|,
name|scp
operator|->
name|cursor_pos
argument_list|,
name|scp
operator|->
name|cursor_pos
argument_list|)
condition|)
comment|/* cursor didn't move, but has been overwritten */
name|sc_draw_cursor_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|scp
operator|->
name|curs_attr
operator|.
name|flags
operator|&
name|CONS_BLINK_CURSOR
condition|)
comment|/* if it's a blinking cursor, update it */
call|(
modifier|*
name|scp
operator|->
name|rndr
operator|->
name|blink_cursor
call|)
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
argument_list|,
name|sc_inside_cutmark
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|SC_NO_CUTPASTE
comment|/* update "pseudo" mouse pointer image */
if|if
condition|(
name|scp
operator|->
name|sc
operator|->
name|flags
operator|&
name|SC_MOUSE_ENABLED
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|scp
operator|->
name|status
operator|&
operator|(
name|MOUSE_VISIBLE
operator||
name|MOUSE_HIDDEN
operator|)
operator|)
condition|)
block|{
name|scp
operator|->
name|status
operator|&=
operator|~
name|MOUSE_MOVED
expr_stmt|;
name|sc_draw_mouse_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* SC_NO_CUTPASTE */
name|scp
operator|->
name|end
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|start
operator|=
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
operator|-
literal|1
expr_stmt|;
name|SC_VIDEO_UNLOCK
argument_list|(
name|scp
operator|->
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEV_SPLASH
end_ifdef

begin_function
specifier|static
name|int
name|scsplash_callback
parameter_list|(
name|int
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|sc_softc_t
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
operator|(
name|sc_softc_t
operator|*
operator|)
name|arg
expr_stmt|;
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|SPLASH_INIT
case|:
if|if
condition|(
name|add_scrn_saver
argument_list|(
name|scsplash_saver
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|flags
operator|&=
operator|~
name|SC_SAVER_FAILED
expr_stmt|;
name|run_scrn_saver
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|cold
operator|&&
operator|!
operator|(
name|boothowto
operator|&
name|RB_VERBOSE
operator|)
condition|)
block|{
name|scsplash_stick
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
call|(
modifier|*
name|current_saver
call|)
argument_list|(
name|sc
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
case|case
name|SPLASH_TERM
case|:
if|if
condition|(
name|current_saver
operator|==
name|scsplash_saver
condition|)
block|{
name|scsplash_stick
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|error
operator|=
name|remove_scrn_saver
argument_list|(
name|scsplash_saver
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
return|return
literal|0
return|;
default|default:
return|return
name|EINVAL
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|scsplash_saver
parameter_list|(
name|sc_softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|show
parameter_list|)
block|{
specifier|static
name|int
name|busy
init|=
name|FALSE
decl_stmt|;
name|scr_stat
modifier|*
name|scp
decl_stmt|;
if|if
condition|(
name|busy
condition|)
return|return;
name|busy
operator|=
name|TRUE
expr_stmt|;
name|scp
operator|=
name|sc
operator|->
name|cur_scp
expr_stmt|;
if|if
condition|(
name|show
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|SC_SAVER_FAILED
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|SC_SCRN_BLANKED
operator|)
condition|)
name|set_scrn_saver_mode
argument_list|(
name|scp
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|splash
argument_list|(
name|sc
operator|->
name|adp
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* succeeded */
break|break;
case|case
name|EAGAIN
case|:
comment|/* try later */
name|restore_scrn_saver_mode
argument_list|(
name|scp
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|sc_touch_scrn_saver
argument_list|()
expr_stmt|;
comment|/* XXX */
break|break;
default|default:
name|sc
operator|->
name|flags
operator||=
name|SC_SAVER_FAILED
expr_stmt|;
name|scsplash_stick
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|restore_scrn_saver_mode
argument_list|(
name|scp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"scsplash_saver(): failed to put up the image\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|sticky_splash
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|flags
operator|&
name|SC_SCRN_BLANKED
operator|)
operator|&&
operator|(
name|splash
argument_list|(
name|sc
operator|->
name|adp
argument_list|,
name|FALSE
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|restore_scrn_saver_mode
argument_list|(
name|scp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|busy
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|add_scrn_saver
parameter_list|(
name|void
function_decl|(
modifier|*
name|this_saver
function_decl|)
parameter_list|(
name|sc_softc_t
modifier|*
parameter_list|,
name|int
parameter_list|)
parameter_list|)
block|{
if|#
directive|if
literal|0
block|int error;      if (current_saver != none_saver) { 	error = remove_scrn_saver(current_saver); 	if (error) 	    return error;     }
endif|#
directive|endif
if|if
condition|(
name|current_saver
operator|!=
name|none_saver
condition|)
return|return
name|EBUSY
return|;
name|run_scrn_saver
operator|=
name|FALSE
expr_stmt|;
name|saver_mode
operator|=
name|CONS_LKM_SAVER
expr_stmt|;
name|current_saver
operator|=
name|this_saver
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|remove_scrn_saver
parameter_list|(
name|void
function_decl|(
modifier|*
name|this_saver
function_decl|)
parameter_list|(
name|sc_softc_t
modifier|*
parameter_list|,
name|int
parameter_list|)
parameter_list|)
block|{
if|if
condition|(
name|current_saver
operator|!=
name|this_saver
condition|)
return|return
name|EINVAL
return|;
if|#
directive|if
literal|0
comment|/*      * In order to prevent `current_saver' from being called by      * the timeout routine `scrn_timer()' while we manipulate       * the saver list, we shall set `current_saver' to `none_saver'       * before stopping the current saver, rather than blocking by `splXX()'.      */
block|current_saver = none_saver;     if (scrn_blanked)         stop_scrn_saver(this_saver);
endif|#
directive|endif
comment|/* unblank all blanked screens */
name|wait_scrn_saver_stop
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|scrn_blanked
condition|)
return|return
name|EBUSY
return|;
name|current_saver
operator|=
name|none_saver
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_scrn_saver_mode
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|mode
parameter_list|,
name|u_char
modifier|*
name|pal
parameter_list|,
name|int
name|border
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
comment|/* assert(scp == scp->sc->cur_scp) */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ISGRAPHSC
argument_list|(
name|scp
argument_list|)
condition|)
name|sc_remove_cursor_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|scp
operator|->
name|splash_save_mode
operator|=
name|scp
operator|->
name|mode
expr_stmt|;
name|scp
operator|->
name|splash_save_status
operator|=
name|scp
operator|->
name|status
operator|&
operator|(
name|GRAPHICS_MODE
operator||
name|PIXEL_MODE
operator|)
expr_stmt|;
name|scp
operator|->
name|status
operator|&=
operator|~
operator|(
name|GRAPHICS_MODE
operator||
name|PIXEL_MODE
operator|)
expr_stmt|;
name|scp
operator|->
name|status
operator||=
operator|(
name|UNKNOWN_MODE
operator||
name|SAVER_RUNNING
operator|)
expr_stmt|;
name|scp
operator|->
name|sc
operator|->
name|flags
operator||=
name|SC_SCRN_BLANKED
expr_stmt|;
operator|++
name|scrn_blanked
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|scp
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|set_mode
argument_list|(
name|scp
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|scp
operator|->
name|sc
operator|->
name|adp
operator|->
name|va_info
operator|.
name|vi_flags
operator|&
name|V_INFO_GRAPHICS
condition|)
name|scp
operator|->
name|status
operator||=
name|GRAPHICS_MODE
expr_stmt|;
ifndef|#
directive|ifndef
name|SC_NO_PALETTE_LOADING
if|if
condition|(
name|pal
operator|!=
name|NULL
condition|)
name|vidd_load_palette
argument_list|(
name|scp
operator|->
name|sc
operator|->
name|adp
argument_list|,
name|pal
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc_set_border
argument_list|(
name|scp
argument_list|,
name|border
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|scp
operator|->
name|mode
operator|=
name|scp
operator|->
name|splash_save_mode
expr_stmt|;
name|scp
operator|->
name|status
operator|&=
operator|~
operator|(
name|UNKNOWN_MODE
operator||
name|SAVER_RUNNING
operator|)
expr_stmt|;
name|scp
operator|->
name|status
operator||=
name|scp
operator|->
name|splash_save_status
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|restore_scrn_saver_mode
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|changemode
parameter_list|)
block|{
name|int
name|mode
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* assert(scp == scp->sc->cur_scp) */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|mode
operator|=
name|scp
operator|->
name|mode
expr_stmt|;
name|status
operator|=
name|scp
operator|->
name|status
expr_stmt|;
name|scp
operator|->
name|mode
operator|=
name|scp
operator|->
name|splash_save_mode
expr_stmt|;
name|scp
operator|->
name|status
operator|&=
operator|~
operator|(
name|UNKNOWN_MODE
operator||
name|SAVER_RUNNING
operator|)
expr_stmt|;
name|scp
operator|->
name|status
operator||=
name|scp
operator|->
name|splash_save_status
expr_stmt|;
name|scp
operator|->
name|sc
operator|->
name|flags
operator|&=
operator|~
name|SC_SCRN_BLANKED
expr_stmt|;
if|if
condition|(
operator|!
name|changemode
condition|)
block|{
if|if
condition|(
operator|!
name|ISGRAPHSC
argument_list|(
name|scp
argument_list|)
condition|)
name|sc_draw_cursor_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
operator|--
name|scrn_blanked
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|set_mode
argument_list|(
name|scp
argument_list|)
operator|==
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|SC_NO_PALETTE_LOADING
ifdef|#
directive|ifdef
name|SC_PIXEL_MODE
if|if
condition|(
name|scp
operator|->
name|sc
operator|->
name|adp
operator|->
name|va_info
operator|.
name|vi_mem_model
operator|==
name|V_INFO_MM_DIRECT
condition|)
name|vidd_load_palette
argument_list|(
name|scp
operator|->
name|sc
operator|->
name|adp
argument_list|,
name|scp
operator|->
name|sc
operator|->
name|palette2
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|vidd_load_palette
argument_list|(
name|scp
operator|->
name|sc
operator|->
name|adp
argument_list|,
name|scp
operator|->
name|sc
operator|->
name|palette
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|--
name|scrn_blanked
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|scp
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
name|scp
operator|->
name|status
operator|=
name|status
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|stop_scrn_saver
parameter_list|(
name|sc_softc_t
modifier|*
name|sc
parameter_list|,
name|void
function_decl|(
modifier|*
name|saver
function_decl|)
parameter_list|(
name|sc_softc_t
modifier|*
parameter_list|,
name|int
parameter_list|)
parameter_list|)
block|{
call|(
modifier|*
name|saver
call|)
argument_list|(
name|sc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|run_scrn_saver
operator|=
name|FALSE
expr_stmt|;
comment|/* the screen saver may have chosen not to stop after all... */
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|SC_SCRN_BLANKED
condition|)
return|return;
name|mark_all
argument_list|(
name|sc
operator|->
name|cur_scp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|delayed_next_scr
condition|)
name|sc_switch_scr
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|delayed_next_scr
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugger
operator|==
literal|0
condition|)
name|wakeup
argument_list|(
operator|&
name|scrn_blanked
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|wait_scrn_saver_stop
parameter_list|(
name|sc_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|scrn_blanked
operator|>
literal|0
condition|)
block|{
name|run_scrn_saver
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|sc
operator|&&
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|SC_SCRN_BLANKED
operator|)
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|tsleep
argument_list|(
operator|&
name|scrn_blanked
argument_list|,
name|PZERO
operator||
name|PCATCH
argument_list|,
literal|"scrsav"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|error
operator|!=
name|ERESTART
operator|)
condition|)
break|break;
block|}
name|run_scrn_saver
operator|=
name|FALSE
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEV_SPLASH */
end_comment

begin_function
name|void
name|sc_touch_scrn_saver
parameter_list|(
name|void
parameter_list|)
block|{
name|scsplash_stick
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|run_scrn_saver
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sc_switch_scr
parameter_list|(
name|sc_softc_t
modifier|*
name|sc
parameter_list|,
name|u_int
name|next_scr
parameter_list|)
block|{
name|scr_stat
modifier|*
name|cur_scp
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|s
decl_stmt|;
name|DPRINTF
argument_list|(
literal|5
argument_list|,
operator|(
literal|"sc0: sc_switch_scr() %d "
operator|,
name|next_scr
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|cur_scp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* prevent switch if previously requested */
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|SC_SCRN_VTYLOCK
condition|)
block|{
name|sc_bell
argument_list|(
name|sc
operator|->
name|cur_scp
argument_list|,
name|sc
operator|->
name|cur_scp
operator|->
name|bell_pitch
argument_list|,
name|sc
operator|->
name|cur_scp
operator|->
name|bell_duration
argument_list|)
expr_stmt|;
return|return
name|EPERM
return|;
block|}
comment|/* delay switch if the screen is blanked or being updated */
if|if
condition|(
operator|(
name|sc
operator|->
name|flags
operator|&
name|SC_SCRN_BLANKED
operator|)
operator|||
name|sc
operator|->
name|write_in_progress
operator|||
name|sc
operator|->
name|blink_in_progress
condition|)
block|{
name|sc
operator|->
name|delayed_next_scr
operator|=
name|next_scr
operator|+
literal|1
expr_stmt|;
name|sc_touch_scrn_saver
argument_list|()
expr_stmt|;
name|DPRINTF
argument_list|(
literal|5
argument_list|,
operator|(
literal|"switch delayed\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sc
operator|->
name|delayed_next_scr
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|cur_scp
operator|=
name|sc
operator|->
name|cur_scp
expr_stmt|;
comment|/* we are in the middle of the vty switching process... */
if|if
condition|(
name|sc
operator|->
name|switch_in_progress
operator|&&
operator|(
name|cur_scp
operator|->
name|smode
operator|.
name|mode
operator|==
name|VT_PROCESS
operator|)
operator|&&
name|cur_scp
operator|->
name|proc
condition|)
block|{
name|p
operator|=
name|pfind
argument_list|(
name|cur_scp
operator|->
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_scp
operator|->
name|proc
operator|!=
name|p
condition|)
block|{
if|if
condition|(
name|p
condition|)
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/*  	     * The controlling process has died!!.  Do some clean up. 	     * NOTE:`cur_scp->proc' and `cur_scp->smode.mode'  	     * are not reset here yet; they will be cleared later. 	     */
name|DPRINTF
argument_list|(
literal|5
argument_list|,
operator|(
literal|"cur_scp controlling process %d died, "
operator|,
name|cur_scp
operator|->
name|pid
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_scp
operator|->
name|status
operator|&
name|SWITCH_WAIT_REL
condition|)
block|{
comment|/* 		 * Force the previous switch to finish, but return now  		 * with error. 		 */
name|DPRINTF
argument_list|(
literal|5
argument_list|,
operator|(
literal|"reset WAIT_REL, "
operator|)
argument_list|)
expr_stmt|;
name|finish_vt_rel
argument_list|(
name|cur_scp
argument_list|,
name|TRUE
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|5
argument_list|,
operator|(
literal|"finishing previous switch\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
elseif|else
if|if
condition|(
name|cur_scp
operator|->
name|status
operator|&
name|SWITCH_WAIT_ACQ
condition|)
block|{
comment|/* let's assume screen switch has been completed. */
name|DPRINTF
argument_list|(
literal|5
argument_list|,
operator|(
literal|"reset WAIT_ACQ, "
operator|)
argument_list|)
expr_stmt|;
name|finish_vt_acq
argument_list|(
name|cur_scp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*  	 	 * We are in between screen release and acquisition, and 		 * reached here via scgetc() or scrn_timer() which has  		 * interrupted exchange_scr(). Don't do anything stupid. 		 */
name|DPRINTF
argument_list|(
literal|5
argument_list|,
operator|(
literal|"waiting nothing, "
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|p
condition|)
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* 	     * The controlling process is alive, but not responding...  	     * It is either buggy or it may be just taking time. 	     * The following code is a gross kludge to cope with this 	     * problem for which there is no clean solution. XXX 	     */
if|if
condition|(
name|cur_scp
operator|->
name|status
operator|&
name|SWITCH_WAIT_REL
condition|)
block|{
switch|switch
condition|(
name|sc
operator|->
name|switch_in_progress
operator|++
condition|)
block|{
case|case
literal|1
case|:
break|break;
case|case
literal|2
case|:
name|DPRINTF
argument_list|(
literal|5
argument_list|,
operator|(
literal|"sending relsig again, "
operator|)
argument_list|)
expr_stmt|;
name|signal_vt_rel
argument_list|(
name|cur_scp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
break|break;
case|case
literal|4
case|:
default|default:
comment|/* 		     * Act as if the controlling program returned 		     * VT_FALSE. 		     */
name|DPRINTF
argument_list|(
literal|5
argument_list|,
operator|(
literal|"force reset WAIT_REL, "
operator|)
argument_list|)
expr_stmt|;
name|finish_vt_rel
argument_list|(
name|cur_scp
argument_list|,
name|FALSE
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|5
argument_list|,
operator|(
literal|"act as if VT_FALSE was seen\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|cur_scp
operator|->
name|status
operator|&
name|SWITCH_WAIT_ACQ
condition|)
block|{
switch|switch
condition|(
name|sc
operator|->
name|switch_in_progress
operator|++
condition|)
block|{
case|case
literal|1
case|:
break|break;
case|case
literal|2
case|:
name|DPRINTF
argument_list|(
literal|5
argument_list|,
operator|(
literal|"sending acqsig again, "
operator|)
argument_list|)
expr_stmt|;
name|signal_vt_acq
argument_list|(
name|cur_scp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
break|break;
case|case
literal|4
case|:
default|default:
comment|/* clear the flag and finish the previous switch */
name|DPRINTF
argument_list|(
literal|5
argument_list|,
operator|(
literal|"force reset WAIT_ACQ, "
operator|)
argument_list|)
expr_stmt|;
name|finish_vt_acq
argument_list|(
name|cur_scp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|/*      * Return error if an invalid argument is given, or vty switch      * is still in progress.      */
if|if
condition|(
operator|(
name|next_scr
operator|<
name|sc
operator|->
name|first_vty
operator|)
operator|||
operator|(
name|next_scr
operator|>=
name|sc
operator|->
name|first_vty
operator|+
name|sc
operator|->
name|vtys
operator|)
operator|||
name|sc
operator|->
name|switch_in_progress
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|sc_bell
argument_list|(
name|cur_scp
argument_list|,
name|bios_value
operator|.
name|bell_pitch
argument_list|,
name|BELL_DURATION
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|5
argument_list|,
operator|(
literal|"error 1\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/*      * Don't allow switching away from the graphics mode vty      * if the switch mode is VT_AUTO, unless the next vty is the same       * as the current or the current vty has been closed (but showing).      */
name|tp
operator|=
name|SC_DEV
argument_list|(
name|sc
argument_list|,
name|cur_scp
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cur_scp
operator|->
name|index
operator|!=
name|next_scr
operator|)
operator|&&
name|tty_opened
argument_list|(
name|tp
argument_list|)
operator|&&
operator|(
name|cur_scp
operator|->
name|smode
operator|.
name|mode
operator|==
name|VT_AUTO
operator|)
operator|&&
name|ISGRAPHSC
argument_list|(
name|cur_scp
argument_list|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|sc_bell
argument_list|(
name|cur_scp
argument_list|,
name|bios_value
operator|.
name|bell_pitch
argument_list|,
name|BELL_DURATION
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|5
argument_list|,
operator|(
literal|"error, graphics mode\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/*      * Is the wanted vty open? Don't allow switching to a closed vty.      * If we are in DDB, don't switch to a vty in the VT_PROCESS mode.      * Note that we always allow the user to switch to the kernel       * console even if it is closed.      */
if|if
condition|(
operator|(
name|sc_console
operator|==
name|NULL
operator|)
operator|||
operator|(
name|next_scr
operator|!=
name|sc_console
operator|->
name|index
operator|)
condition|)
block|{
name|tp
operator|=
name|SC_DEV
argument_list|(
name|sc
argument_list|,
name|next_scr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tty_opened
argument_list|(
name|tp
argument_list|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|sc_bell
argument_list|(
name|cur_scp
argument_list|,
name|bios_value
operator|.
name|bell_pitch
argument_list|,
name|BELL_DURATION
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|5
argument_list|,
operator|(
literal|"error 2, requested vty isn't open!\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
operator|(
name|debugger
operator|>
literal|0
operator|)
operator|&&
operator|(
name|SC_STAT
argument_list|(
name|tp
argument_list|)
operator|->
name|smode
operator|.
name|mode
operator|==
name|VT_PROCESS
operator|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|5
argument_list|,
operator|(
literal|"error 3, requested vty is in the VT_PROCESS mode\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
block|}
comment|/* this is the start of vty switching process... */
operator|++
name|sc
operator|->
name|switch_in_progress
expr_stmt|;
name|sc
operator|->
name|old_scp
operator|=
name|cur_scp
expr_stmt|;
name|sc
operator|->
name|new_scp
operator|=
name|sc_get_stat
argument_list|(
name|SC_DEV
argument_list|(
name|sc
argument_list|,
name|next_scr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|new_scp
operator|==
name|sc
operator|->
name|old_scp
condition|)
block|{
name|sc
operator|->
name|switch_in_progress
operator|=
literal|0
expr_stmt|;
comment|/* 	 * XXX wakeup() locks the scheduler lock which will hang if 	 * the lock is in an in-between state, e.g., when we stop at 	 * a breakpoint at fork_exit.  It has always been wrong to call 	 * wakeup() when the debugger is active.  In RELENG_4, wakeup() 	 * is supposed to be locked by splhigh(), but the debugger may 	 * be invoked at splhigh(). 	 */
if|if
condition|(
name|debugger
operator|==
literal|0
condition|)
name|wakeup
argument_list|(
name|VTY_WCHAN
argument_list|(
name|sc
argument_list|,
name|next_scr
argument_list|)
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|5
argument_list|,
operator|(
literal|"switch done (new == old)\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* has controlling process died? */
name|vt_proc_alive
argument_list|(
name|sc
operator|->
name|old_scp
argument_list|)
expr_stmt|;
name|vt_proc_alive
argument_list|(
name|sc
operator|->
name|new_scp
argument_list|)
expr_stmt|;
comment|/* wait for the controlling process to release the screen, if necessary */
if|if
condition|(
name|signal_vt_rel
argument_list|(
name|sc
operator|->
name|old_scp
argument_list|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* go set up the new vty screen */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|exchange_scr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* wake up processes waiting for this vty */
if|if
condition|(
name|debugger
operator|==
literal|0
condition|)
name|wakeup
argument_list|(
name|VTY_WCHAN
argument_list|(
name|sc
argument_list|,
name|next_scr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* wait for the controlling process to acknowledge, if necessary */
if|if
condition|(
name|signal_vt_acq
argument_list|(
name|sc
operator|->
name|cur_scp
argument_list|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sc
operator|->
name|switch_in_progress
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|unit
operator|==
name|sc_console_unit
condition|)
name|cnavailable
argument_list|(
name|sc_consptr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|5
argument_list|,
operator|(
literal|"switch done\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_switch_scr
parameter_list|(
name|sc_softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|s
parameter_list|)
block|{
name|vt_proc_alive
argument_list|(
name|sc
operator|->
name|new_scp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|exchange_scr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* sc->cur_scp == sc->new_scp */
name|wakeup
argument_list|(
name|VTY_WCHAN
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|cur_scp
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
comment|/* wait for the controlling process to acknowledge, if necessary */
if|if
condition|(
operator|!
name|signal_vt_acq
argument_list|(
name|sc
operator|->
name|cur_scp
argument_list|)
condition|)
block|{
name|sc
operator|->
name|switch_in_progress
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|unit
operator|==
name|sc_console_unit
condition|)
name|cnavailable
argument_list|(
name|sc_consptr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vt_proc_alive
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|scp
operator|->
name|proc
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|pfind
argument_list|(
name|scp
operator|->
name|pid
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|proc
operator|==
name|p
condition|)
return|return
name|TRUE
return|;
name|scp
operator|->
name|proc
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|smode
operator|.
name|mode
operator|=
name|VT_AUTO
expr_stmt|;
name|DPRINTF
argument_list|(
literal|5
argument_list|,
operator|(
literal|"vt controlling process %d died\n"
operator|,
name|scp
operator|->
name|pid
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|signal_vt_rel
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
if|if
condition|(
name|scp
operator|->
name|smode
operator|.
name|mode
operator|!=
name|VT_PROCESS
condition|)
return|return
name|FALSE
return|;
name|scp
operator|->
name|status
operator||=
name|SWITCH_WAIT_REL
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|scp
operator|->
name|proc
argument_list|)
expr_stmt|;
name|psignal
argument_list|(
name|scp
operator|->
name|proc
argument_list|,
name|scp
operator|->
name|smode
operator|.
name|relsig
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|scp
operator|->
name|proc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|5
argument_list|,
operator|(
literal|"sending relsig to %d\n"
operator|,
name|scp
operator|->
name|pid
operator|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|signal_vt_acq
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
if|if
condition|(
name|scp
operator|->
name|smode
operator|.
name|mode
operator|!=
name|VT_PROCESS
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|scp
operator|->
name|sc
operator|->
name|unit
operator|==
name|sc_console_unit
condition|)
name|cnavailable
argument_list|(
name|sc_consptr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|scp
operator|->
name|status
operator||=
name|SWITCH_WAIT_ACQ
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|scp
operator|->
name|proc
argument_list|)
expr_stmt|;
name|psignal
argument_list|(
name|scp
operator|->
name|proc
argument_list|,
name|scp
operator|->
name|smode
operator|.
name|acqsig
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|scp
operator|->
name|proc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|5
argument_list|,
operator|(
literal|"sending acqsig to %d\n"
operator|,
name|scp
operator|->
name|pid
operator|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|finish_vt_rel
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|release
parameter_list|,
name|int
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
name|scp
operator|==
name|scp
operator|->
name|sc
operator|->
name|old_scp
operator|&&
name|scp
operator|->
name|status
operator|&
name|SWITCH_WAIT_REL
condition|)
block|{
name|scp
operator|->
name|status
operator|&=
operator|~
name|SWITCH_WAIT_REL
expr_stmt|;
if|if
condition|(
name|release
condition|)
operator|*
name|s
operator|=
name|do_switch_scr
argument_list|(
name|scp
operator|->
name|sc
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
else|else
name|scp
operator|->
name|sc
operator|->
name|switch_in_progress
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|EINVAL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|finish_vt_acq
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
if|if
condition|(
name|scp
operator|==
name|scp
operator|->
name|sc
operator|->
name|new_scp
operator|&&
name|scp
operator|->
name|status
operator|&
name|SWITCH_WAIT_ACQ
condition|)
block|{
name|scp
operator|->
name|status
operator|&=
operator|~
name|SWITCH_WAIT_ACQ
expr_stmt|;
name|scp
operator|->
name|sc
operator|->
name|switch_in_progress
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|EINVAL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|exchange_scr
parameter_list|(
name|sc_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|scr_stat
modifier|*
name|scp
decl_stmt|;
comment|/* save the current state of video and keyboard */
name|sc_move_cursor
argument_list|(
name|sc
operator|->
name|old_scp
argument_list|,
name|sc
operator|->
name|old_scp
operator|->
name|xpos
argument_list|,
name|sc
operator|->
name|old_scp
operator|->
name|ypos
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISGRAPHSC
argument_list|(
name|sc
operator|->
name|old_scp
argument_list|)
condition|)
name|sc_remove_cursor_image
argument_list|(
name|sc
operator|->
name|old_scp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|old_scp
operator|->
name|kbd_mode
operator|==
name|K_XLATE
condition|)
name|save_kbd_state
argument_list|(
name|sc
operator|->
name|old_scp
argument_list|)
expr_stmt|;
comment|/* set up the video for the new screen */
name|scp
operator|=
name|sc
operator|->
name|cur_scp
operator|=
name|sc
operator|->
name|new_scp
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
if|if
condition|(
name|sc
operator|->
name|old_scp
operator|->
name|mode
operator|!=
name|scp
operator|->
name|mode
operator|||
name|ISUNKNOWNSC
argument_list|(
name|sc
operator|->
name|old_scp
argument_list|)
operator|||
name|ISUNKNOWNSC
argument_list|(
name|sc
operator|->
name|new_scp
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
name|sc
operator|->
name|old_scp
operator|->
name|mode
operator|!=
name|scp
operator|->
name|mode
operator|||
name|ISUNKNOWNSC
argument_list|(
name|sc
operator|->
name|old_scp
argument_list|)
condition|)
endif|#
directive|endif
name|set_mode
argument_list|(
name|scp
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__sparc64__
else|else
name|sc_vtb_init
argument_list|(
operator|&
name|scp
operator|->
name|scr
argument_list|,
name|VTB_FRAMEBUFFER
argument_list|,
name|scp
operator|->
name|xsize
argument_list|,
name|scp
operator|->
name|ysize
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
operator|->
name|adp
operator|->
name|va_window
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|scp
operator|->
name|status
operator||=
name|MOUSE_HIDDEN
expr_stmt|;
name|sc_move_cursor
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|xpos
argument_list|,
name|scp
operator|->
name|ypos
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISGRAPHSC
argument_list|(
name|scp
argument_list|)
condition|)
name|sc_set_cursor_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SC_NO_PALETTE_LOADING
if|if
condition|(
name|ISGRAPHSC
argument_list|(
name|sc
operator|->
name|old_scp
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SC_PIXEL_MODE
if|if
condition|(
name|sc
operator|->
name|adp
operator|->
name|va_info
operator|.
name|vi_mem_model
operator|==
name|V_INFO_MM_DIRECT
condition|)
name|vidd_load_palette
argument_list|(
name|sc
operator|->
name|adp
argument_list|,
name|sc
operator|->
name|palette2
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|vidd_load_palette
argument_list|(
name|sc
operator|->
name|adp
argument_list|,
name|sc
operator|->
name|palette
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|sc_set_border
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|border
argument_list|)
expr_stmt|;
comment|/* set up the keyboard for the new screen */
if|if
condition|(
name|sc
operator|->
name|old_scp
operator|->
name|kbd_mode
operator|!=
name|scp
operator|->
name|kbd_mode
condition|)
operator|(
name|void
operator|)
name|kbdd_ioctl
argument_list|(
name|sc
operator|->
name|kbd
argument_list|,
name|KDSKBMODE
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|scp
operator|->
name|kbd_mode
argument_list|)
expr_stmt|;
name|update_kbd_state
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|status
argument_list|,
name|LOCK_MASK
argument_list|)
expr_stmt|;
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sc_puts
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|kernel
parameter_list|)
block|{
name|int
name|need_unlock
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|DEV_SPLASH
comment|/* make screensaver happy */
if|if
condition|(
operator|!
name|sticky_splash
operator|&&
name|scp
operator|==
name|scp
operator|->
name|sc
operator|->
name|cur_scp
operator|&&
operator|!
name|sc_saver_keyb_only
condition|)
name|run_scrn_saver
operator|=
name|FALSE
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|scp
operator|->
name|tsw
condition|)
block|{
if|if
condition|(
operator|!
name|kdb_active
operator|&&
operator|!
name|mtx_owned
argument_list|(
operator|&
name|scp
operator|->
name|scr_lock
argument_list|)
condition|)
block|{
name|need_unlock
operator|=
literal|1
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|scp
operator|->
name|scr_lock
argument_list|)
expr_stmt|;
block|}
call|(
modifier|*
name|scp
operator|->
name|tsw
operator|->
name|te_puts
call|)
argument_list|(
name|scp
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|kernel
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_unlock
condition|)
name|mtx_unlock_spin
argument_list|(
operator|&
name|scp
operator|->
name|scr_lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scp
operator|->
name|sc
operator|->
name|delayed_next_scr
condition|)
name|sc_switch_scr
argument_list|(
name|scp
operator|->
name|sc
argument_list|,
name|scp
operator|->
name|sc
operator|->
name|delayed_next_scr
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sc_draw_cursor_image
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
comment|/* assert(scp == scp->sc->cur_scp); */
name|SC_VIDEO_LOCK
argument_list|(
name|scp
operator|->
name|sc
argument_list|)
expr_stmt|;
call|(
modifier|*
name|scp
operator|->
name|rndr
operator|->
name|draw_cursor
call|)
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
argument_list|,
name|scp
operator|->
name|curs_attr
operator|.
name|flags
operator|&
name|CONS_BLINK_CURSOR
argument_list|,
name|TRUE
argument_list|,
name|sc_inside_cutmark
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
argument_list|)
argument_list|)
expr_stmt|;
name|scp
operator|->
name|cursor_oldpos
operator|=
name|scp
operator|->
name|cursor_pos
expr_stmt|;
name|SC_VIDEO_UNLOCK
argument_list|(
name|scp
operator|->
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sc_remove_cursor_image
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
comment|/* assert(scp == scp->sc->cur_scp); */
name|SC_VIDEO_LOCK
argument_list|(
name|scp
operator|->
name|sc
argument_list|)
expr_stmt|;
call|(
modifier|*
name|scp
operator|->
name|rndr
operator|->
name|draw_cursor
call|)
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_oldpos
argument_list|,
name|scp
operator|->
name|curs_attr
operator|.
name|flags
operator|&
name|CONS_BLINK_CURSOR
argument_list|,
name|FALSE
argument_list|,
name|sc_inside_cutmark
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_oldpos
argument_list|)
argument_list|)
expr_stmt|;
name|SC_VIDEO_UNLOCK
argument_list|(
name|scp
operator|->
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|update_cursor_image
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
comment|/* assert(scp == scp->sc->cur_scp); */
name|sc_remove_cursor_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|sc_set_cursor_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|sc_draw_cursor_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sc_set_cursor_image
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|scp
operator|->
name|curs_attr
operator|.
name|flags
operator|=
name|scp
operator|->
name|curr_curs_attr
operator|.
name|flags
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|curs_attr
operator|.
name|flags
operator|&
name|CONS_HIDDEN_CURSOR
condition|)
block|{
comment|/* hidden cursor is internally represented as zero-height underline */
name|scp
operator|->
name|curs_attr
operator|.
name|flags
operator|=
name|CONS_CHAR_CURSOR
expr_stmt|;
name|scp
operator|->
name|curs_attr
operator|.
name|base
operator|=
name|scp
operator|->
name|curs_attr
operator|.
name|height
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scp
operator|->
name|curs_attr
operator|.
name|flags
operator|&
name|CONS_CHAR_CURSOR
condition|)
block|{
name|scp
operator|->
name|curs_attr
operator|.
name|base
operator|=
name|imin
argument_list|(
name|scp
operator|->
name|curr_curs_attr
operator|.
name|base
argument_list|,
name|scp
operator|->
name|font_size
operator|-
literal|1
argument_list|)
expr_stmt|;
name|scp
operator|->
name|curs_attr
operator|.
name|height
operator|=
name|imin
argument_list|(
name|scp
operator|->
name|curr_curs_attr
operator|.
name|height
argument_list|,
name|scp
operator|->
name|font_size
operator|-
name|scp
operator|->
name|curs_attr
operator|.
name|base
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* block cursor */
name|scp
operator|->
name|curs_attr
operator|.
name|base
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|curs_attr
operator|.
name|height
operator|=
name|scp
operator|->
name|font_size
expr_stmt|;
block|}
comment|/* assert(scp == scp->sc->cur_scp); */
name|SC_VIDEO_LOCK
argument_list|(
name|scp
operator|->
name|sc
argument_list|)
expr_stmt|;
call|(
modifier|*
name|scp
operator|->
name|rndr
operator|->
name|set_cursor
call|)
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|curs_attr
operator|.
name|base
argument_list|,
name|scp
operator|->
name|curs_attr
operator|.
name|height
argument_list|,
name|scp
operator|->
name|curs_attr
operator|.
name|flags
operator|&
name|CONS_BLINK_CURSOR
argument_list|)
expr_stmt|;
name|SC_VIDEO_UNLOCK
argument_list|(
name|scp
operator|->
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|change_cursor_shape
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|base
parameter_list|,
name|int
name|height
parameter_list|)
block|{
if|if
condition|(
operator|(
name|scp
operator|==
name|scp
operator|->
name|sc
operator|->
name|cur_scp
operator|)
operator|&&
operator|!
name|ISGRAPHSC
argument_list|(
name|scp
argument_list|)
condition|)
name|sc_remove_cursor_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|>=
literal|0
condition|)
name|scp
operator|->
name|curr_curs_attr
operator|.
name|base
operator|=
name|base
expr_stmt|;
if|if
condition|(
name|height
operator|>=
literal|0
condition|)
name|scp
operator|->
name|curr_curs_attr
operator|.
name|height
operator|=
name|height
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|CONS_RESET_CURSOR
condition|)
name|scp
operator|->
name|curr_curs_attr
operator|=
name|scp
operator|->
name|dflt_curs_attr
expr_stmt|;
else|else
name|scp
operator|->
name|curr_curs_attr
operator|.
name|flags
operator|=
name|flags
operator|&
name|CONS_CURSOR_ATTRS
expr_stmt|;
if|if
condition|(
operator|(
name|scp
operator|==
name|scp
operator|->
name|sc
operator|->
name|cur_scp
operator|)
operator|&&
operator|!
name|ISGRAPHSC
argument_list|(
name|scp
argument_list|)
condition|)
block|{
name|sc_set_cursor_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|sc_draw_cursor_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sc_change_cursor_shape
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|base
parameter_list|,
name|int
name|height
parameter_list|)
block|{
name|sc_softc_t
modifier|*
name|sc
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|!=
operator|-
literal|1
operator|)
operator|&&
operator|(
name|flags
operator|&
name|CONS_LOCAL_CURSOR
operator|)
condition|)
block|{
comment|/* local (per vty) change */
name|change_cursor_shape
argument_list|(
name|scp
argument_list|,
name|flags
argument_list|,
name|base
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* global change */
name|sc
operator|=
name|scp
operator|->
name|sc
expr_stmt|;
if|if
condition|(
name|base
operator|>=
literal|0
condition|)
name|sc
operator|->
name|curs_attr
operator|.
name|base
operator|=
name|base
expr_stmt|;
if|if
condition|(
name|height
operator|>=
literal|0
condition|)
name|sc
operator|->
name|curs_attr
operator|.
name|height
operator|=
name|height
expr_stmt|;
if|if
condition|(
name|flags
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|CONS_RESET_CURSOR
condition|)
name|sc
operator|->
name|curs_attr
operator|=
name|sc
operator|->
name|dflt_curs_attr
expr_stmt|;
else|else
name|sc
operator|->
name|curs_attr
operator|.
name|flags
operator|=
name|flags
operator|&
name|CONS_CURSOR_ATTRS
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|sc
operator|->
name|first_vty
init|;
name|i
operator|<
name|sc
operator|->
name|first_vty
operator|+
name|sc
operator|->
name|vtys
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
name|tp
operator|=
name|SC_DEV
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
name|scp
operator|=
name|sc_get_stat
argument_list|(
name|tp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
name|scp
operator|->
name|dflt_curs_attr
operator|=
name|sc
operator|->
name|curs_attr
expr_stmt|;
name|change_cursor_shape
argument_list|(
name|scp
argument_list|,
name|CONS_RESET_CURSOR
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|scinit
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
comment|/*      * When syscons is being initialized as the kernel console, malloc()      * is not yet functional, because various kernel structures has not been      * fully initialized yet.  Therefore, we need to declare the following      * static buffers for the console.  This is less than ideal,       * but is necessry evil for the time being.  XXX      */
ifdef|#
directive|ifdef
name|PC98
specifier|static
name|u_short
name|sc_buffer
index|[
name|ROW
operator|*
name|COL
operator|*
literal|2
index|]
decl_stmt|;
comment|/* XXX */
else|#
directive|else
specifier|static
name|u_short
name|sc_buffer
index|[
name|ROW
operator|*
name|COL
index|]
decl_stmt|;
comment|/* XXX */
endif|#
directive|endif
ifndef|#
directive|ifndef
name|SC_NO_FONT_LOADING
specifier|static
name|u_char
name|font_8
index|[
literal|256
operator|*
literal|8
index|]
decl_stmt|;
specifier|static
name|u_char
name|font_14
index|[
literal|256
operator|*
literal|14
index|]
decl_stmt|;
specifier|static
name|u_char
name|font_16
index|[
literal|256
operator|*
literal|16
index|]
decl_stmt|;
endif|#
directive|endif
name|sc_softc_t
modifier|*
name|sc
decl_stmt|;
name|scr_stat
modifier|*
name|scp
decl_stmt|;
name|video_adapter_t
modifier|*
name|adp
decl_stmt|;
name|int
name|col
decl_stmt|;
name|int
name|row
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* one time initialization */
if|if
condition|(
name|init_done
operator|==
name|COLD
condition|)
name|sc_get_bios_values
argument_list|(
operator|&
name|bios_value
argument_list|)
expr_stmt|;
name|init_done
operator|=
name|WARM
expr_stmt|;
comment|/*      * Allocate resources.  Even if we are being called for the second      * time, we must allocate them again, because they might have       * disappeared...      */
name|sc
operator|=
name|sc_get_softc
argument_list|(
name|unit
argument_list|,
name|flags
operator|&
name|SC_KERNEL_CONSOLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|flags
operator|&
name|SC_INIT_DONE
operator|)
operator|==
literal|0
condition|)
name|SC_VIDEO_LOCKINIT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|adp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|adapter
operator|>=
literal|0
condition|)
block|{
name|vid_release
argument_list|(
name|sc
operator|->
name|adp
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|sc
operator|->
name|adapter
argument_list|)
expr_stmt|;
name|adp
operator|=
name|sc
operator|->
name|adp
expr_stmt|;
name|sc
operator|->
name|adp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|keyboard
operator|>=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
literal|5
argument_list|,
operator|(
literal|"sc%d: releasing kbd%d\n"
operator|,
name|unit
operator|,
name|sc
operator|->
name|keyboard
operator|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|kbd_release
argument_list|(
name|sc
operator|->
name|kbd
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|sc
operator|->
name|keyboard
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|5
argument_list|,
operator|(
literal|"sc%d: kbd_release returned %d\n"
operator|,
name|unit
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|kbd
operator|!=
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
literal|5
argument_list|,
operator|(
literal|"sc%d: kbd != NULL!, index:%d, unit:%d, flags:0x%x\n"
operator|,
name|unit
operator|,
name|sc
operator|->
name|kbd
operator|->
name|kb_index
operator|,
name|sc
operator|->
name|kbd
operator|->
name|kb_unit
operator|,
name|sc
operator|->
name|kbd
operator|->
name|kb_flags
operator|)
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|kbd
operator|=
name|NULL
expr_stmt|;
block|}
name|sc
operator|->
name|adapter
operator|=
name|vid_allocate
argument_list|(
literal|"*"
argument_list|,
name|unit
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|sc
operator|->
name|adapter
argument_list|)
expr_stmt|;
name|sc
operator|->
name|adp
operator|=
name|vid_get_adapter
argument_list|(
name|sc
operator|->
name|adapter
argument_list|)
expr_stmt|;
comment|/* assert((sc->adapter>= 0)&& (sc->adp != NULL)) */
name|sc
operator|->
name|keyboard
operator|=
name|sc_allocate_keyboard
argument_list|(
name|sc
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"sc%d: keyboard %d\n"
operator|,
name|unit
operator|,
name|sc
operator|->
name|keyboard
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|kbd
operator|=
name|kbd_get_keyboard
argument_list|(
name|sc
operator|->
name|keyboard
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|kbd
operator|!=
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"sc%d: kbd index:%d, unit:%d, flags:0x%x\n"
operator|,
name|unit
operator|,
name|sc
operator|->
name|kbd
operator|->
name|kb_index
operator|,
name|sc
operator|->
name|kbd
operator|->
name|kb_unit
operator|,
name|sc
operator|->
name|kbd
operator|->
name|kb_flags
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|SC_INIT_DONE
operator|)
operator|||
operator|(
name|adp
operator|!=
name|sc
operator|->
name|adp
operator|)
condition|)
block|{
name|sc
operator|->
name|initial_mode
operator|=
name|sc
operator|->
name|adp
operator|->
name|va_initial_mode
expr_stmt|;
ifndef|#
directive|ifndef
name|SC_NO_FONT_LOADING
if|if
condition|(
name|flags
operator|&
name|SC_KERNEL_CONSOLE
condition|)
block|{
name|sc
operator|->
name|font_8
operator|=
name|font_8
expr_stmt|;
name|sc
operator|->
name|font_14
operator|=
name|font_14
expr_stmt|;
name|sc
operator|->
name|font_16
operator|=
name|font_16
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|font_8
operator|==
name|NULL
condition|)
block|{
comment|/* assert(sc_malloc) */
name|sc
operator|->
name|font_8
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|font_8
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sc
operator|->
name|font_14
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|font_14
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sc
operator|->
name|font_16
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|font_16
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* extract the hardware cursor location and hide the cursor for now */
name|vidd_read_hw_cursor
argument_list|(
name|sc
operator|->
name|adp
argument_list|,
operator|&
name|col
argument_list|,
operator|&
name|row
argument_list|)
expr_stmt|;
name|vidd_set_hw_cursor
argument_list|(
name|sc
operator|->
name|adp
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* set up the first console */
name|sc
operator|->
name|first_vty
operator|=
name|unit
operator|*
name|MAXCONS
expr_stmt|;
name|sc
operator|->
name|vtys
operator|=
name|MAXCONS
expr_stmt|;
comment|/* XXX: should be configurable */
if|if
condition|(
name|flags
operator|&
name|SC_KERNEL_CONSOLE
condition|)
block|{
comment|/* 	     * Set up devs structure but don't use it yet, calling make_dev() 	     * might panic kernel.  Wait for sc_attach_unit() to actually 	     * create the devices. 	     */
name|sc
operator|->
name|dev
operator|=
name|main_devs
expr_stmt|;
name|scp
operator|=
operator|&
name|main_console
expr_stmt|;
name|init_scp
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|first_vty
argument_list|,
name|scp
argument_list|)
expr_stmt|;
name|sc_vtb_init
argument_list|(
operator|&
name|scp
operator|->
name|vtb
argument_list|,
name|VTB_MEMORY
argument_list|,
name|scp
operator|->
name|xsize
argument_list|,
name|scp
operator|->
name|ysize
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc_buffer
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* move cursors to the initial positions */
if|if
condition|(
name|col
operator|>=
name|scp
operator|->
name|xsize
condition|)
name|col
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|row
operator|>=
name|scp
operator|->
name|ysize
condition|)
name|row
operator|=
name|scp
operator|->
name|ysize
operator|-
literal|1
expr_stmt|;
name|scp
operator|->
name|xpos
operator|=
name|col
expr_stmt|;
name|scp
operator|->
name|ypos
operator|=
name|row
expr_stmt|;
name|scp
operator|->
name|cursor_pos
operator|=
name|scp
operator|->
name|cursor_oldpos
operator|=
name|row
operator|*
name|scp
operator|->
name|xsize
operator|+
name|col
expr_stmt|;
if|if
condition|(
name|sc_init_emulator
argument_list|(
name|scp
argument_list|,
name|SC_DFLT_TERM
argument_list|)
condition|)
name|sc_init_emulator
argument_list|(
name|scp
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
call|(
modifier|*
name|scp
operator|->
name|tsw
operator|->
name|te_default_attr
call|)
argument_list|(
name|scp
argument_list|,
name|user_default
operator|.
name|std_color
argument_list|,
name|user_default
operator|.
name|rev_color
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* assert(sc_malloc) */
name|sc
operator|->
name|dev
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tty
operator|*
argument_list|)
operator|*
name|sc
operator|->
name|vtys
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
index|[
literal|0
index|]
operator|=
name|sc_alloc_tty
argument_list|(
literal|0
argument_list|,
name|unit
operator|*
name|MAXCONS
argument_list|)
expr_stmt|;
name|scp
operator|=
name|alloc_scp
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|first_vty
argument_list|)
expr_stmt|;
name|SC_STAT
argument_list|(
name|sc
operator|->
name|dev
index|[
literal|0
index|]
argument_list|)
operator|=
name|scp
expr_stmt|;
block|}
name|sc
operator|->
name|cur_scp
operator|=
name|scp
expr_stmt|;
ifndef|#
directive|ifndef
name|__sparc64__
comment|/* copy screen to temporary buffer */
name|sc_vtb_init
argument_list|(
operator|&
name|scp
operator|->
name|scr
argument_list|,
name|VTB_FRAMEBUFFER
argument_list|,
name|scp
operator|->
name|xsize
argument_list|,
name|scp
operator|->
name|ysize
argument_list|,
operator|(
name|void
operator|*
operator|)
name|scp
operator|->
name|sc
operator|->
name|adp
operator|->
name|va_window
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISTEXTSC
argument_list|(
name|scp
argument_list|)
condition|)
name|sc_vtb_copy
argument_list|(
operator|&
name|scp
operator|->
name|scr
argument_list|,
literal|0
argument_list|,
operator|&
name|scp
operator|->
name|vtb
argument_list|,
literal|0
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bios_value
operator|.
name|cursor_end
operator|<
name|scp
operator|->
name|font_size
condition|)
name|sc
operator|->
name|dflt_curs_attr
operator|.
name|base
operator|=
name|scp
operator|->
name|font_size
operator|-
name|bios_value
operator|.
name|cursor_end
operator|-
literal|1
expr_stmt|;
else|else
name|sc
operator|->
name|dflt_curs_attr
operator|.
name|base
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|bios_value
operator|.
name|cursor_end
operator|-
name|bios_value
operator|.
name|cursor_start
operator|+
literal|1
expr_stmt|;
name|sc
operator|->
name|dflt_curs_attr
operator|.
name|height
operator|=
name|imin
argument_list|(
name|i
argument_list|,
name|scp
operator|->
name|font_size
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dflt_curs_attr
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|curs_attr
operator|=
name|sc
operator|->
name|dflt_curs_attr
expr_stmt|;
name|scp
operator|->
name|curr_curs_attr
operator|=
name|scp
operator|->
name|dflt_curs_attr
operator|=
name|sc
operator|->
name|curs_attr
expr_stmt|;
ifndef|#
directive|ifndef
name|SC_NO_SYSMOUSE
name|sc_mouse_move
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|xpixel
operator|/
literal|2
argument_list|,
name|scp
operator|->
name|ypixel
operator|/
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|ISGRAPHSC
argument_list|(
name|scp
argument_list|)
condition|)
block|{
name|sc_set_cursor_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|sc_draw_cursor_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
comment|/* save font and palette */
ifndef|#
directive|ifndef
name|SC_NO_FONT_LOADING
name|sc
operator|->
name|fonts_loaded
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ISFONTAVAIL
argument_list|(
name|sc
operator|->
name|adp
operator|->
name|va_flags
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SC_DFLT_FONT
name|bcopy
argument_list|(
name|dflt_font_8
argument_list|,
name|sc
operator|->
name|font_8
argument_list|,
sizeof|sizeof
argument_list|(
name|dflt_font_8
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|dflt_font_14
argument_list|,
name|sc
operator|->
name|font_14
argument_list|,
sizeof|sizeof
argument_list|(
name|dflt_font_14
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|dflt_font_16
argument_list|,
name|sc
operator|->
name|font_16
argument_list|,
sizeof|sizeof
argument_list|(
name|dflt_font_16
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|fonts_loaded
operator|=
name|FONT_16
operator||
name|FONT_14
operator||
name|FONT_8
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|font_size
operator|<
literal|14
condition|)
block|{
name|sc_load_font
argument_list|(
name|scp
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
literal|8
argument_list|,
name|sc
operator|->
name|font_8
argument_list|,
literal|0
argument_list|,
literal|256
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scp
operator|->
name|font_size
operator|>=
literal|16
condition|)
block|{
name|sc_load_font
argument_list|(
name|scp
argument_list|,
literal|0
argument_list|,
literal|16
argument_list|,
literal|8
argument_list|,
name|sc
operator|->
name|font_16
argument_list|,
literal|0
argument_list|,
literal|256
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc_load_font
argument_list|(
name|scp
argument_list|,
literal|0
argument_list|,
literal|14
argument_list|,
literal|8
argument_list|,
name|sc
operator|->
name|font_14
argument_list|,
literal|0
argument_list|,
literal|256
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* !SC_DFLT_FONT */
if|if
condition|(
name|scp
operator|->
name|font_size
operator|<
literal|14
condition|)
block|{
name|sc_save_font
argument_list|(
name|scp
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
literal|8
argument_list|,
name|sc
operator|->
name|font_8
argument_list|,
literal|0
argument_list|,
literal|256
argument_list|)
expr_stmt|;
name|sc
operator|->
name|fonts_loaded
operator|=
name|FONT_8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scp
operator|->
name|font_size
operator|>=
literal|16
condition|)
block|{
name|sc_save_font
argument_list|(
name|scp
argument_list|,
literal|0
argument_list|,
literal|16
argument_list|,
literal|8
argument_list|,
name|sc
operator|->
name|font_16
argument_list|,
literal|0
argument_list|,
literal|256
argument_list|)
expr_stmt|;
name|sc
operator|->
name|fonts_loaded
operator|=
name|FONT_16
expr_stmt|;
block|}
else|else
block|{
name|sc_save_font
argument_list|(
name|scp
argument_list|,
literal|0
argument_list|,
literal|14
argument_list|,
literal|8
argument_list|,
name|sc
operator|->
name|font_14
argument_list|,
literal|0
argument_list|,
literal|256
argument_list|)
expr_stmt|;
name|sc
operator|->
name|fonts_loaded
operator|=
name|FONT_14
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SC_DFLT_FONT */
comment|/* FONT KLUDGE: always use the font page #0. XXX */
name|sc_show_font
argument_list|(
name|scp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !SC_NO_FONT_LOADING */
ifndef|#
directive|ifndef
name|SC_NO_PALETTE_LOADING
name|vidd_save_palette
argument_list|(
name|sc
operator|->
name|adp
argument_list|,
name|sc
operator|->
name|palette
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SC_PIXEL_MODE
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|palette2
argument_list|)
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|palette2
index|[
name|i
index|]
operator|=
name|i
operator|/
literal|3
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEV_SPLASH
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|SC_SPLASH_SCRN
operator|)
condition|)
block|{
comment|/* we are ready to put up the splash image! */
name|splash_init
argument_list|(
name|sc
operator|->
name|adp
argument_list|,
name|scsplash_callback
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator||=
name|SC_SPLASH_SCRN
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/* the rest is not necessary, if we have done it once */
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|SC_INIT_DONE
condition|)
return|return;
comment|/* initialize mapscrn arrays to a one to one map */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|scr_map
argument_list|)
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|scr_map
index|[
name|i
index|]
operator|=
name|sc
operator|->
name|scr_rmap
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|sc
operator|->
name|scr_map
index|[
literal|0x5c
index|]
operator|=
operator|(
name|u_char
operator|)
literal|0xfc
expr_stmt|;
comment|/* for backslash */
endif|#
directive|endif
name|sc
operator|->
name|flags
operator||=
name|SC_INIT_DONE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|scterm
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|sc_softc_t
modifier|*
name|sc
decl_stmt|;
name|scr_stat
modifier|*
name|scp
decl_stmt|;
name|sc
operator|=
name|sc_get_softc
argument_list|(
name|unit
argument_list|,
name|flags
operator|&
name|SC_KERNEL_CONSOLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return;
comment|/* shouldn't happen */
ifdef|#
directive|ifdef
name|DEV_SPLASH
comment|/* this console is no longer available for the splash screen */
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|SC_SPLASH_SCRN
condition|)
block|{
name|splash_term
argument_list|(
name|sc
operator|->
name|adp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator|&=
operator|~
name|SC_SPLASH_SCRN
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* XXX */
comment|/* move the hardware cursor to the upper-left corner */
block|vidd_set_hw_cursor(sc->adp, 0, 0);
endif|#
directive|endif
comment|/* release the keyboard and the video card */
if|if
condition|(
name|sc
operator|->
name|keyboard
operator|>=
literal|0
condition|)
name|kbd_release
argument_list|(
name|sc
operator|->
name|kbd
argument_list|,
operator|&
name|sc
operator|->
name|keyboard
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|adapter
operator|>=
literal|0
condition|)
name|vid_release
argument_list|(
name|sc
operator|->
name|adp
argument_list|,
operator|&
name|sc
operator|->
name|adapter
argument_list|)
expr_stmt|;
comment|/* stop the terminal emulator, if any */
name|scp
operator|=
name|sc_get_stat
argument_list|(
name|sc
operator|->
name|dev
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|tsw
condition|)
call|(
modifier|*
name|scp
operator|->
name|tsw
operator|->
name|te_term
call|)
argument_list|(
name|scp
argument_list|,
operator|&
name|scp
operator|->
name|ts
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|ts
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|scp
operator|->
name|ts
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|scp
operator|->
name|scr_lock
argument_list|)
expr_stmt|;
comment|/* clear the structure */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SC_KERNEL_CONSOLE
operator|)
condition|)
block|{
comment|/* XXX: We need delete_dev() for this */
name|free
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX: We need a ttyunregister for this */
block|free(sc->tty, M_DEVBUF);
endif|#
directive|endif
ifndef|#
directive|ifndef
name|SC_NO_FONT_LOADING
name|free
argument_list|(
name|sc
operator|->
name|font_8
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|font_14
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|font_16
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XXX vtb, history */
block|}
name|bzero
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|keyboard
operator|=
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|adapter
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|scshutdown
parameter_list|(
name|__unused
name|void
modifier|*
name|arg
parameter_list|,
name|__unused
name|int
name|howto
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|sc_console
operator|!=
name|NULL
argument_list|,
operator|(
literal|"sc_console != NULL"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc_console
operator|->
name|sc
operator|!=
name|NULL
argument_list|,
operator|(
literal|"sc_console->sc != NULL"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc_console
operator|->
name|sc
operator|->
name|cur_scp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"sc_console->sc->cur_scp != NULL"
operator|)
argument_list|)
expr_stmt|;
name|sc_touch_scrn_saver
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|cold
operator|&&
name|sc_console
operator|->
name|sc
operator|->
name|cur_scp
operator|->
name|index
operator|!=
name|sc_console
operator|->
name|index
operator|&&
name|sc_console
operator|->
name|sc
operator|->
name|cur_scp
operator|->
name|smode
operator|.
name|mode
operator|==
name|VT_AUTO
operator|&&
name|sc_console
operator|->
name|smode
operator|.
name|mode
operator|==
name|VT_AUTO
condition|)
name|sc_switch_scr
argument_list|(
name|sc_console
operator|->
name|sc
argument_list|,
name|sc_console
operator|->
name|index
argument_list|)
expr_stmt|;
name|shutdown_in_progress
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|scsuspend
parameter_list|(
name|__unused
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|retry
decl_stmt|;
name|KASSERT
argument_list|(
name|sc_console
operator|!=
name|NULL
argument_list|,
operator|(
literal|"sc_console != NULL"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc_console
operator|->
name|sc
operator|!=
name|NULL
argument_list|,
operator|(
literal|"sc_console->sc != NULL"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc_console
operator|->
name|sc
operator|->
name|cur_scp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"sc_console->sc->cur_scp != NULL"
operator|)
argument_list|)
expr_stmt|;
name|sc_susp_scr
operator|=
name|sc_console
operator|->
name|sc
operator|->
name|cur_scp
operator|->
name|index
expr_stmt|;
if|if
condition|(
name|sc_no_suspend_vtswitch
operator|||
name|sc_susp_scr
operator|==
name|sc_console
operator|->
name|index
condition|)
block|{
name|sc_touch_scrn_saver
argument_list|()
expr_stmt|;
name|sc_susp_scr
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
for|for
control|(
name|retry
operator|=
literal|0
init|;
name|retry
operator|<
literal|10
condition|;
name|retry
operator|++
control|)
block|{
name|sc_switch_scr
argument_list|(
name|sc_console
operator|->
name|sc
argument_list|,
name|sc_console
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc_console
operator|->
name|sc
operator|->
name|switch_in_progress
condition|)
break|break;
name|pause
argument_list|(
literal|"scsuspend"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
name|suspend_in_progress
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|scresume
parameter_list|(
name|__unused
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|sc_console
operator|!=
name|NULL
argument_list|,
operator|(
literal|"sc_console != NULL"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc_console
operator|->
name|sc
operator|!=
name|NULL
argument_list|,
operator|(
literal|"sc_console->sc != NULL"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc_console
operator|->
name|sc
operator|->
name|cur_scp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"sc_console->sc->cur_scp != NULL"
operator|)
argument_list|)
expr_stmt|;
name|suspend_in_progress
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|sc_susp_scr
operator|<
literal|0
condition|)
block|{
name|mark_all
argument_list|(
name|sc_console
operator|->
name|sc
operator|->
name|cur_scp
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc_switch_scr
argument_list|(
name|sc_console
operator|->
name|sc
argument_list|,
name|sc_susp_scr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sc_clean_up
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEV_SPLASH
name|int
name|error
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|scp
operator|->
name|sc
operator|->
name|flags
operator|&
name|SC_SCRN_BLANKED
condition|)
block|{
name|sc_touch_scrn_saver
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_SPLASH
if|if
condition|(
operator|(
name|error
operator|=
name|wait_scrn_saver_stop
argument_list|(
name|scp
operator|->
name|sc
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
endif|#
directive|endif
block|}
name|scp
operator|->
name|status
operator||=
name|MOUSE_HIDDEN
expr_stmt|;
name|sc_remove_mouse_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|sc_remove_cutmarking
argument_list|(
name|scp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|sc_alloc_scr_buffer
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|wait
parameter_list|,
name|int
name|discard
parameter_list|)
block|{
name|sc_vtb_t
name|new
decl_stmt|;
name|sc_vtb_t
name|old
decl_stmt|;
name|old
operator|=
name|scp
operator|->
name|vtb
expr_stmt|;
name|sc_vtb_init
argument_list|(
operator|&
name|new
argument_list|,
name|VTB_MEMORY
argument_list|,
name|scp
operator|->
name|xsize
argument_list|,
name|scp
operator|->
name|ysize
argument_list|,
name|NULL
argument_list|,
name|wait
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|discard
operator|&&
operator|(
name|old
operator|.
name|vtb_flags
operator|&
name|VTB_VALID
operator|)
condition|)
block|{
comment|/* retain the current cursor position and buffer contants */
name|scp
operator|->
name|cursor_oldpos
operator|=
name|scp
operator|->
name|cursor_pos
expr_stmt|;
comment|/*  	 * This works only if the old buffer has the same size as or larger  	 * than the new one. XXX 	 */
name|sc_vtb_copy
argument_list|(
operator|&
name|old
argument_list|,
literal|0
argument_list|,
operator|&
name|new
argument_list|,
literal|0
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
argument_list|)
expr_stmt|;
name|scp
operator|->
name|vtb
operator|=
name|new
expr_stmt|;
block|}
else|else
block|{
name|scp
operator|->
name|vtb
operator|=
name|new
expr_stmt|;
name|sc_vtb_destroy
argument_list|(
operator|&
name|old
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|SC_NO_SYSMOUSE
comment|/* move the mouse cursor at the center of the screen */
name|sc_mouse_move
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|xpixel
operator|/
literal|2
argument_list|,
name|scp
operator|->
name|ypixel
operator|/
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|scr_stat
modifier|*
name|alloc_scp
parameter_list|(
name|sc_softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|vty
parameter_list|)
block|{
name|scr_stat
modifier|*
name|scp
decl_stmt|;
comment|/* assert(sc_malloc) */
name|scp
operator|=
operator|(
name|scr_stat
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|scr_stat
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|init_scp
argument_list|(
name|sc
argument_list|,
name|vty
argument_list|,
name|scp
argument_list|)
expr_stmt|;
name|sc_alloc_scr_buffer
argument_list|(
name|scp
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc_init_emulator
argument_list|(
name|scp
argument_list|,
name|SC_DFLT_TERM
argument_list|)
condition|)
name|sc_init_emulator
argument_list|(
name|scp
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SC_NO_CUTPASTE
name|sc_alloc_cut_buffer
argument_list|(
name|scp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|SC_NO_HISTORY
name|sc_alloc_history_buffer
argument_list|(
name|scp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|scp
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_scp
parameter_list|(
name|sc_softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|vty
parameter_list|,
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|video_info_t
name|info
decl_stmt|;
name|bzero
argument_list|(
name|scp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scp
argument_list|)
argument_list|)
expr_stmt|;
name|scp
operator|->
name|index
operator|=
name|vty
expr_stmt|;
name|scp
operator|->
name|sc
operator|=
name|sc
expr_stmt|;
name|scp
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|mode
operator|=
name|sc
operator|->
name|initial_mode
expr_stmt|;
name|vidd_get_info
argument_list|(
name|sc
operator|->
name|adp
argument_list|,
name|scp
operator|->
name|mode
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|vi_flags
operator|&
name|V_INFO_GRAPHICS
condition|)
block|{
name|scp
operator|->
name|status
operator||=
name|GRAPHICS_MODE
expr_stmt|;
name|scp
operator|->
name|xpixel
operator|=
name|info
operator|.
name|vi_width
expr_stmt|;
name|scp
operator|->
name|ypixel
operator|=
name|info
operator|.
name|vi_height
expr_stmt|;
name|scp
operator|->
name|xsize
operator|=
name|info
operator|.
name|vi_width
operator|/
name|info
operator|.
name|vi_cwidth
expr_stmt|;
name|scp
operator|->
name|ysize
operator|=
name|info
operator|.
name|vi_height
operator|/
name|info
operator|.
name|vi_cheight
expr_stmt|;
name|scp
operator|->
name|font_size
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|font
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|scp
operator|->
name|xsize
operator|=
name|info
operator|.
name|vi_width
expr_stmt|;
name|scp
operator|->
name|ysize
operator|=
name|info
operator|.
name|vi_height
expr_stmt|;
name|scp
operator|->
name|xpixel
operator|=
name|scp
operator|->
name|xsize
operator|*
name|info
operator|.
name|vi_cwidth
expr_stmt|;
name|scp
operator|->
name|ypixel
operator|=
name|scp
operator|->
name|ysize
operator|*
name|info
operator|.
name|vi_cheight
expr_stmt|;
block|}
name|scp
operator|->
name|font_size
operator|=
name|info
operator|.
name|vi_cheight
expr_stmt|;
name|scp
operator|->
name|font_width
operator|=
name|info
operator|.
name|vi_cwidth
expr_stmt|;
ifndef|#
directive|ifndef
name|SC_NO_FONT_LOADING
if|if
condition|(
name|info
operator|.
name|vi_cheight
operator|<
literal|14
condition|)
name|scp
operator|->
name|font
operator|=
name|sc
operator|->
name|font_8
expr_stmt|;
elseif|else
if|if
condition|(
name|info
operator|.
name|vi_cheight
operator|>=
literal|16
condition|)
name|scp
operator|->
name|font
operator|=
name|sc
operator|->
name|font_16
expr_stmt|;
else|else
name|scp
operator|->
name|font
operator|=
name|sc
operator|->
name|font_14
expr_stmt|;
else|#
directive|else
name|scp
operator|->
name|font
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|sc_vtb_init
argument_list|(
operator|&
name|scp
operator|->
name|vtb
argument_list|,
name|VTB_MEMORY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__sparc64__
name|sc_vtb_init
argument_list|(
operator|&
name|scp
operator|->
name|scr
argument_list|,
name|VTB_FRAMEBUFFER
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|scp
operator|->
name|xoff
operator|=
name|scp
operator|->
name|yoff
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|xpos
operator|=
name|scp
operator|->
name|ypos
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|start
operator|=
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
operator|-
literal|1
expr_stmt|;
name|scp
operator|->
name|end
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|tsw
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|ts
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|rndr
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|border
operator|=
operator|(
name|SC_NORM_ATTR
operator|>>
literal|4
operator|)
operator|&
literal|0x0f
expr_stmt|;
name|scp
operator|->
name|curr_curs_attr
operator|=
name|scp
operator|->
name|dflt_curs_attr
operator|=
name|sc
operator|->
name|curs_attr
expr_stmt|;
name|scp
operator|->
name|mouse_cut_start
operator|=
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
expr_stmt|;
name|scp
operator|->
name|mouse_cut_end
operator|=
operator|-
literal|1
expr_stmt|;
name|scp
operator|->
name|mouse_signal
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|mouse_pid
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|mouse_proc
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|kbd_mode
operator|=
name|K_XLATE
expr_stmt|;
name|scp
operator|->
name|bell_pitch
operator|=
name|bios_value
operator|.
name|bell_pitch
expr_stmt|;
name|scp
operator|->
name|bell_duration
operator|=
name|BELL_DURATION
expr_stmt|;
name|scp
operator|->
name|status
operator||=
operator|(
name|bios_value
operator|.
name|shift_state
operator|&
name|NLKED
operator|)
expr_stmt|;
name|scp
operator|->
name|status
operator||=
name|CURSOR_ENABLED
operator||
name|MOUSE_HIDDEN
expr_stmt|;
name|scp
operator|->
name|pid
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|proc
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|smode
operator|.
name|mode
operator|=
name|VT_AUTO
expr_stmt|;
name|scp
operator|->
name|history
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|history_pos
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|history_size
operator|=
literal|0
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|scp
operator|->
name|scr_lock
argument_list|,
literal|"scrlock"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sc_init_emulator
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|sc_term_sw_t
modifier|*
name|sw
decl_stmt|;
name|sc_rndr_sw_t
modifier|*
name|rndr
decl_stmt|;
name|void
modifier|*
name|p
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
comment|/* if no name is given, use the current emulator */
name|sw
operator|=
name|scp
operator|->
name|tsw
expr_stmt|;
else|else
comment|/* ...otherwise find the named emulator */
name|sw
operator|=
name|sc_term_match
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sw
operator|==
name|NULL
condition|)
return|return
name|EINVAL
return|;
name|rndr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|sw
operator|->
name|te_renderer
argument_list|,
literal|"*"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|rndr
operator|=
name|sc_render_match
argument_list|(
name|scp
argument_list|,
name|sw
operator|->
name|te_renderer
argument_list|,
name|scp
operator|->
name|status
operator|&
operator|(
name|GRAPHICS_MODE
operator||
name|PIXEL_MODE
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rndr
operator|==
name|NULL
condition|)
block|{
name|rndr
operator|=
name|sc_render_match
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|sc
operator|->
name|adp
operator|->
name|va_name
argument_list|,
name|scp
operator|->
name|status
operator|&
operator|(
name|GRAPHICS_MODE
operator||
name|PIXEL_MODE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rndr
operator|==
name|NULL
condition|)
return|return
name|ENODEV
return|;
block|}
if|if
condition|(
name|sw
operator|==
name|scp
operator|->
name|tsw
condition|)
block|{
name|error
operator|=
call|(
modifier|*
name|sw
operator|->
name|te_init
call|)
argument_list|(
name|scp
argument_list|,
operator|&
name|scp
operator|->
name|ts
argument_list|,
name|SC_TE_WARM_INIT
argument_list|)
expr_stmt|;
name|scp
operator|->
name|rndr
operator|=
name|rndr
expr_stmt|;
name|scp
operator|->
name|rndr
operator|->
name|init
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|sc_clear_screen
argument_list|(
name|scp
argument_list|)
expr_stmt|;
comment|/* assert(error == 0); */
return|return
name|error
return|;
block|}
if|if
condition|(
name|sc_malloc
operator|&&
operator|(
name|sw
operator|->
name|te_size
operator|>
literal|0
operator|)
condition|)
name|p
operator|=
name|malloc
argument_list|(
name|sw
operator|->
name|te_size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|sw
operator|->
name|te_init
call|)
argument_list|(
name|scp
argument_list|,
operator|&
name|p
argument_list|,
name|SC_TE_COLD_INIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|scp
operator|->
name|tsw
condition|)
call|(
modifier|*
name|scp
operator|->
name|tsw
operator|->
name|te_term
call|)
argument_list|(
name|scp
argument_list|,
operator|&
name|scp
operator|->
name|ts
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|ts
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|scp
operator|->
name|ts
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|scp
operator|->
name|tsw
operator|=
name|sw
expr_stmt|;
name|scp
operator|->
name|ts
operator|=
name|p
expr_stmt|;
name|scp
operator|->
name|rndr
operator|=
name|rndr
expr_stmt|;
name|scp
operator|->
name|rndr
operator|->
name|init
argument_list|(
name|scp
argument_list|)
expr_stmt|;
comment|/* XXX */
call|(
modifier|*
name|sw
operator|->
name|te_default_attr
call|)
argument_list|(
name|scp
argument_list|,
name|user_default
operator|.
name|std_color
argument_list|,
name|user_default
operator|.
name|rev_color
argument_list|)
expr_stmt|;
name|sc_clear_screen
argument_list|(
name|scp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * scgetc(flags) - get character from keyboard.  * If flags& SCGETC_CN, then avoid harmful side effects.  * If flags& SCGETC_NONBLOCK, then wait until a key is pressed, else  * return NOKEY if there is nothing there.  */
end_comment

begin_function
specifier|static
name|u_int
name|scgetc
parameter_list|(
name|sc_softc_t
modifier|*
name|sc
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|scr_stat
modifier|*
name|scp
decl_stmt|;
ifndef|#
directive|ifndef
name|SC_NO_HISTORY
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
endif|#
directive|endif
name|u_int
name|c
decl_stmt|;
name|int
name|this_scr
decl_stmt|;
name|int
name|f
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|kbd
operator|==
name|NULL
condition|)
return|return
name|NOKEY
return|;
name|next_code
label|:
if|#
directive|if
literal|1
comment|/* I don't like this, but... XXX */
if|if
condition|(
name|flags
operator|&
name|SCGETC_CN
condition|)
name|sccnupdate
argument_list|(
name|sc
operator|->
name|cur_scp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|scp
operator|=
name|sc
operator|->
name|cur_scp
expr_stmt|;
comment|/* first see if there is something in the keyboard port */
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|kbdd_read_char
argument_list|(
name|sc
operator|->
name|kbd
argument_list|,
operator|!
operator|(
name|flags
operator|&
name|SCGETC_NONBLOCK
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|ERRKEY
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCGETC_CN
operator|)
condition|)
name|sc_bell
argument_list|(
name|scp
argument_list|,
name|bios_value
operator|.
name|bell_pitch
argument_list|,
name|BELL_DURATION
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|NOKEY
condition|)
return|return
name|c
return|;
else|else
break|break;
block|}
comment|/* make screensaver happy */
if|if
condition|(
operator|!
operator|(
name|c
operator|&
name|RELKEY
operator|)
condition|)
name|sc_touch_scrn_saver
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCGETC_CN
operator|)
condition|)
name|random_harvest
argument_list|(
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|RANDOM_KEYBOARD
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|kbd_mode
operator|!=
name|K_XLATE
condition|)
return|return
name|KEYCHAR
argument_list|(
name|c
argument_list|)
return|;
comment|/* if scroll-lock pressed allow history browsing */
if|if
condition|(
operator|!
name|ISGRAPHSC
argument_list|(
name|scp
argument_list|)
operator|&&
name|scp
operator|->
name|history
operator|&&
name|scp
operator|->
name|status
operator|&
name|SLKED
condition|)
block|{
name|scp
operator|->
name|status
operator|&=
operator|~
name|CURSOR_ENABLED
expr_stmt|;
name|sc_remove_cursor_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SC_NO_HISTORY
if|if
condition|(
operator|!
operator|(
name|scp
operator|->
name|status
operator|&
name|BUFFER_SAVED
operator|)
condition|)
block|{
name|scp
operator|->
name|status
operator||=
name|BUFFER_SAVED
expr_stmt|;
name|sc_hist_save
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
comment|/* FIXME: key codes */
case|case
name|SPCLKEY
operator||
name|FKEY
operator||
name|F
argument_list|(
literal|49
argument_list|)
case|:
comment|/* home key */
name|sc_remove_cutmarking
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|sc_hist_home
argument_list|(
name|scp
argument_list|)
expr_stmt|;
goto|goto
name|next_code
goto|;
case|case
name|SPCLKEY
operator||
name|FKEY
operator||
name|F
argument_list|(
literal|57
argument_list|)
case|:
comment|/* end key */
name|sc_remove_cutmarking
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|sc_hist_end
argument_list|(
name|scp
argument_list|)
expr_stmt|;
goto|goto
name|next_code
goto|;
case|case
name|SPCLKEY
operator||
name|FKEY
operator||
name|F
argument_list|(
literal|50
argument_list|)
case|:
comment|/* up arrow key */
name|sc_remove_cutmarking
argument_list|(
name|scp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc_hist_up_line
argument_list|(
name|scp
argument_list|)
condition|)
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCGETC_CN
operator|)
condition|)
name|sc_bell
argument_list|(
name|scp
argument_list|,
name|bios_value
operator|.
name|bell_pitch
argument_list|,
name|BELL_DURATION
argument_list|)
expr_stmt|;
goto|goto
name|next_code
goto|;
case|case
name|SPCLKEY
operator||
name|FKEY
operator||
name|F
argument_list|(
literal|58
argument_list|)
case|:
comment|/* down arrow key */
name|sc_remove_cutmarking
argument_list|(
name|scp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc_hist_down_line
argument_list|(
name|scp
argument_list|)
condition|)
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCGETC_CN
operator|)
condition|)
name|sc_bell
argument_list|(
name|scp
argument_list|,
name|bios_value
operator|.
name|bell_pitch
argument_list|,
name|BELL_DURATION
argument_list|)
expr_stmt|;
goto|goto
name|next_code
goto|;
case|case
name|SPCLKEY
operator||
name|FKEY
operator||
name|F
argument_list|(
literal|51
argument_list|)
case|:
comment|/* page up key */
name|sc_remove_cutmarking
argument_list|(
name|scp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|scp
operator|->
name|ysize
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sc_hist_up_line
argument_list|(
name|scp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCGETC_CN
operator|)
condition|)
name|sc_bell
argument_list|(
name|scp
argument_list|,
name|bios_value
operator|.
name|bell_pitch
argument_list|,
name|BELL_DURATION
argument_list|)
expr_stmt|;
break|break;
block|}
goto|goto
name|next_code
goto|;
case|case
name|SPCLKEY
operator||
name|FKEY
operator||
name|F
argument_list|(
literal|59
argument_list|)
case|:
comment|/* page down key */
name|sc_remove_cutmarking
argument_list|(
name|scp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|scp
operator|->
name|ysize
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sc_hist_down_line
argument_list|(
name|scp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCGETC_CN
operator|)
condition|)
name|sc_bell
argument_list|(
name|scp
argument_list|,
name|bios_value
operator|.
name|bell_pitch
argument_list|,
name|BELL_DURATION
argument_list|)
expr_stmt|;
break|break;
block|}
goto|goto
name|next_code
goto|;
block|}
endif|#
directive|endif
comment|/* SC_NO_HISTORY */
block|}
comment|/*       * Process and consume special keys here.  Return a plain char code      * or a char code with the META flag or a function key code.      */
if|if
condition|(
name|c
operator|&
name|RELKEY
condition|)
block|{
comment|/* key released */
comment|/* goto next_code */
block|}
else|else
block|{
comment|/* key pressed */
if|if
condition|(
name|c
operator|&
name|SPCLKEY
condition|)
block|{
name|c
operator|&=
operator|~
name|SPCLKEY
expr_stmt|;
switch|switch
condition|(
name|KEYCHAR
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* LOCKING KEYS */
case|case
name|NLK
case|:
case|case
name|CLK
case|:
case|case
name|ALK
case|:
break|break;
case|case
name|SLK
case|:
operator|(
name|void
operator|)
name|kbdd_ioctl
argument_list|(
name|sc
operator|->
name|kbd
argument_list|,
name|KDGKBSTATE
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|&
name|SLKED
condition|)
block|{
name|scp
operator|->
name|status
operator||=
name|SLKED
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|SLKED
condition|)
block|{
name|scp
operator|->
name|status
operator|&=
operator|~
name|SLKED
expr_stmt|;
ifndef|#
directive|ifndef
name|SC_NO_HISTORY
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|BUFFER_SAVED
condition|)
block|{
if|if
condition|(
operator|!
name|sc_hist_restore
argument_list|(
name|scp
argument_list|)
condition|)
name|sc_remove_cutmarking
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|scp
operator|->
name|status
operator|&=
operator|~
name|BUFFER_SAVED
expr_stmt|;
name|scp
operator|->
name|status
operator||=
name|CURSOR_ENABLED
expr_stmt|;
name|sc_draw_cursor_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
name|tp
operator|=
name|SC_DEV
argument_list|(
name|sc
argument_list|,
name|scp
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|kdb_active
operator|&&
name|tty_opened
argument_list|(
name|tp
argument_list|)
condition|)
name|sctty_outwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
break|break;
case|case
name|PASTE
case|:
ifndef|#
directive|ifndef
name|SC_NO_CUTPASTE
name|sc_mouse_paste
argument_list|(
name|scp
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
comment|/* NON-LOCKING KEYS */
case|case
name|NOP
case|:
case|case
name|LSH
case|:
case|case
name|RSH
case|:
case|case
name|LCTR
case|:
case|case
name|RCTR
case|:
case|case
name|LALT
case|:
case|case
name|RALT
case|:
case|case
name|ASH
case|:
case|case
name|META
case|:
break|break;
case|case
name|BTAB
case|:
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|SC_SCRN_BLANKED
operator|)
condition|)
return|return
name|c
return|;
break|break;
case|case
name|SPSC
case|:
ifdef|#
directive|ifdef
name|DEV_SPLASH
comment|/* force activatation/deactivation of the screen saver */
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|SC_SCRN_BLANKED
operator|)
condition|)
block|{
name|run_scrn_saver
operator|=
name|TRUE
expr_stmt|;
name|sc
operator|->
name|scrn_time_stamp
operator|-=
name|scrn_blank_time
expr_stmt|;
block|}
if|if
condition|(
name|cold
condition|)
block|{
comment|/* 		     * While devices are being probed, the screen saver need 		     * to be invoked explictly. XXX 		     */
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|SC_SCRN_BLANKED
condition|)
block|{
name|scsplash_stick
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|stop_scrn_saver
argument_list|(
name|sc
argument_list|,
name|current_saver
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|ISGRAPHSC
argument_list|(
name|scp
argument_list|)
condition|)
block|{
name|scsplash_stick
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
call|(
modifier|*
name|current_saver
call|)
argument_list|(
name|sc
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* DEV_SPLASH */
break|break;
case|case
name|RBT
case|:
ifndef|#
directive|ifndef
name|SC_DISABLE_REBOOT
if|if
condition|(
name|enable_reboot
condition|)
name|shutdown_nice
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|HALT
case|:
ifndef|#
directive|ifndef
name|SC_DISABLE_REBOOT
if|if
condition|(
name|enable_reboot
condition|)
name|shutdown_nice
argument_list|(
name|RB_HALT
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|PDWN
case|:
ifndef|#
directive|ifndef
name|SC_DISABLE_REBOOT
if|if
condition|(
name|enable_reboot
condition|)
name|shutdown_nice
argument_list|(
name|RB_HALT
operator||
name|RB_POWEROFF
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|SUSP
case|:
name|power_pm_suspend
argument_list|(
name|POWER_SLEEP_STATE_SUSPEND
argument_list|)
expr_stmt|;
break|break;
case|case
name|STBY
case|:
name|power_pm_suspend
argument_list|(
name|POWER_SLEEP_STATE_STANDBY
argument_list|)
expr_stmt|;
break|break;
case|case
name|DBG
case|:
ifndef|#
directive|ifndef
name|SC_DISABLE_KDBKEY
if|if
condition|(
name|enable_kdbkey
condition|)
name|kdb_enter
argument_list|(
name|KDB_WHY_BREAK
argument_list|,
literal|"manual escape to debugger"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|PNC
case|:
if|if
condition|(
name|enable_panic_key
condition|)
name|panic
argument_list|(
literal|"Forced by the panic key"
argument_list|)
expr_stmt|;
break|break;
case|case
name|NEXT
case|:
name|this_scr
operator|=
name|scp
operator|->
name|index
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|this_scr
operator|-
name|sc
operator|->
name|first_vty
operator|+
literal|1
operator|)
operator|%
name|sc
operator|->
name|vtys
init|;
name|sc
operator|->
name|first_vty
operator|+
name|i
operator|!=
name|this_scr
condition|;
name|i
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|sc
operator|->
name|vtys
control|)
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
name|SC_DEV
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|first_vty
operator|+
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|tty_opened
argument_list|(
name|tp
argument_list|)
condition|)
block|{
name|sc_switch_scr
argument_list|(
name|scp
operator|->
name|sc
argument_list|,
name|sc
operator|->
name|first_vty
operator|+
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|PREV
case|:
name|this_scr
operator|=
name|scp
operator|->
name|index
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|this_scr
operator|-
name|sc
operator|->
name|first_vty
operator|+
name|sc
operator|->
name|vtys
operator|-
literal|1
operator|)
operator|%
name|sc
operator|->
name|vtys
init|;
name|sc
operator|->
name|first_vty
operator|+
name|i
operator|!=
name|this_scr
condition|;
name|i
operator|=
operator|(
name|i
operator|+
name|sc
operator|->
name|vtys
operator|-
literal|1
operator|)
operator|%
name|sc
operator|->
name|vtys
control|)
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
name|SC_DEV
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|first_vty
operator|+
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|tty_opened
argument_list|(
name|tp
argument_list|)
condition|)
block|{
name|sc_switch_scr
argument_list|(
name|scp
operator|->
name|sc
argument_list|,
name|sc
operator|->
name|first_vty
operator|+
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
default|default:
if|if
condition|(
name|KEYCHAR
argument_list|(
name|c
argument_list|)
operator|>=
name|F_SCR
operator|&&
name|KEYCHAR
argument_list|(
name|c
argument_list|)
operator|<=
name|L_SCR
condition|)
block|{
name|sc_switch_scr
argument_list|(
name|scp
operator|->
name|sc
argument_list|,
name|sc
operator|->
name|first_vty
operator|+
name|KEYCHAR
argument_list|(
name|c
argument_list|)
operator|-
name|F_SCR
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* assert(c& FKEY) */
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|SC_SCRN_BLANKED
operator|)
condition|)
return|return
name|c
return|;
break|break;
block|}
comment|/* goto next_code */
block|}
else|else
block|{
comment|/* regular keys (maybe MKEY is set) */
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|SC_SCRN_BLANKED
operator|)
condition|)
return|return
name|c
return|;
block|}
block|}
goto|goto
name|next_code
goto|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctty_mmap
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|vm_ooffset_t
name|offset
parameter_list|,
name|vm_paddr_t
modifier|*
name|paddr
parameter_list|,
name|int
name|nprot
parameter_list|,
name|vm_memattr_t
modifier|*
name|memattr
parameter_list|)
block|{
name|scr_stat
modifier|*
name|scp
decl_stmt|;
name|scp
operator|=
name|sc_get_stat
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|!=
name|scp
operator|->
name|sc
operator|->
name|cur_scp
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|vidd_mmap
argument_list|(
name|scp
operator|->
name|sc
operator|->
name|adp
argument_list|,
name|offset
argument_list|,
name|paddr
argument_list|,
name|nprot
argument_list|,
name|memattr
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|save_kbd_state
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|int
name|state
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|kbdd_ioctl
argument_list|(
name|scp
operator|->
name|sc
operator|->
name|kbd
argument_list|,
name|KDGKBSTATE
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOIOCTL
condition|)
name|error
operator|=
name|ENODEV
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|scp
operator|->
name|status
operator|&=
operator|~
name|LOCK_MASK
expr_stmt|;
name|scp
operator|->
name|status
operator||=
name|state
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|update_kbd_state
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|new_bits
parameter_list|,
name|int
name|mask
parameter_list|)
block|{
name|int
name|state
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|mask
operator|!=
name|LOCK_MASK
condition|)
block|{
name|error
operator|=
name|kbdd_ioctl
argument_list|(
name|scp
operator|->
name|sc
operator|->
name|kbd
argument_list|,
name|KDGKBSTATE
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOIOCTL
condition|)
name|error
operator|=
name|ENODEV
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|state
operator|&=
operator|~
name|mask
expr_stmt|;
name|state
operator||=
name|new_bits
operator|&
name|mask
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|new_bits
operator|&
name|LOCK_MASK
expr_stmt|;
block|}
name|error
operator|=
name|kbdd_ioctl
argument_list|(
name|scp
operator|->
name|sc
operator|->
name|kbd
argument_list|,
name|KDSKBSTATE
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOIOCTL
condition|)
name|error
operator|=
name|ENODEV
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|update_kbd_leds
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|which
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|which
operator|&=
name|LOCK_MASK
expr_stmt|;
name|error
operator|=
name|kbdd_ioctl
argument_list|(
name|scp
operator|->
name|sc
operator|->
name|kbd
argument_list|,
name|KDSETLED
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|which
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOIOCTL
condition|)
name|error
operator|=
name|ENODEV
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|set_mode
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|video_info_t
name|info
decl_stmt|;
comment|/* reject unsupported mode */
if|if
condition|(
name|vidd_get_info
argument_list|(
name|scp
operator|->
name|sc
operator|->
name|adp
argument_list|,
name|scp
operator|->
name|mode
argument_list|,
operator|&
name|info
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* if this vty is not currently showing, do nothing */
if|if
condition|(
name|scp
operator|!=
name|scp
operator|->
name|sc
operator|->
name|cur_scp
condition|)
return|return
literal|0
return|;
comment|/* setup video hardware for the given mode */
name|vidd_set_mode
argument_list|(
name|scp
operator|->
name|sc
operator|->
name|adp
argument_list|,
name|scp
operator|->
name|mode
argument_list|)
expr_stmt|;
name|scp
operator|->
name|rndr
operator|->
name|init
argument_list|(
name|scp
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__sparc64__
name|sc_vtb_init
argument_list|(
operator|&
name|scp
operator|->
name|scr
argument_list|,
name|VTB_FRAMEBUFFER
argument_list|,
name|scp
operator|->
name|xsize
argument_list|,
name|scp
operator|->
name|ysize
argument_list|,
operator|(
name|void
operator|*
operator|)
name|scp
operator|->
name|sc
operator|->
name|adp
operator|->
name|va_window
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|SC_NO_FONT_LOADING
comment|/* load appropriate font */
if|if
condition|(
operator|!
operator|(
name|scp
operator|->
name|status
operator|&
name|GRAPHICS_MODE
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|scp
operator|->
name|status
operator|&
name|PIXEL_MODE
operator|)
operator|&&
name|ISFONTAVAIL
argument_list|(
name|scp
operator|->
name|sc
operator|->
name|adp
operator|->
name|va_flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|scp
operator|->
name|font_size
operator|<
literal|14
condition|)
block|{
if|if
condition|(
name|scp
operator|->
name|sc
operator|->
name|fonts_loaded
operator|&
name|FONT_8
condition|)
name|sc_load_font
argument_list|(
name|scp
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
literal|8
argument_list|,
name|scp
operator|->
name|sc
operator|->
name|font_8
argument_list|,
literal|0
argument_list|,
literal|256
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scp
operator|->
name|font_size
operator|>=
literal|16
condition|)
block|{
if|if
condition|(
name|scp
operator|->
name|sc
operator|->
name|fonts_loaded
operator|&
name|FONT_16
condition|)
name|sc_load_font
argument_list|(
name|scp
argument_list|,
literal|0
argument_list|,
literal|16
argument_list|,
literal|8
argument_list|,
name|scp
operator|->
name|sc
operator|->
name|font_16
argument_list|,
literal|0
argument_list|,
literal|256
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|scp
operator|->
name|sc
operator|->
name|fonts_loaded
operator|&
name|FONT_14
condition|)
name|sc_load_font
argument_list|(
name|scp
argument_list|,
literal|0
argument_list|,
literal|14
argument_list|,
literal|8
argument_list|,
name|scp
operator|->
name|sc
operator|->
name|font_14
argument_list|,
literal|0
argument_list|,
literal|256
argument_list|)
expr_stmt|;
block|}
comment|/* 	     * FONT KLUDGE: 	     * This is an interim kludge to display correct font. 	     * Always use the font page #0 on the video plane 2. 	     * Somehow we cannot show the font in other font pages on 	     * some video cards... XXX 	     */
name|sc_show_font
argument_list|(
name|scp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !SC_NO_FONT_LOADING */
name|sc_set_border
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|border
argument_list|)
expr_stmt|;
name|sc_set_cursor_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|sc_set_border
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|color
parameter_list|)
block|{
name|SC_VIDEO_LOCK
argument_list|(
name|scp
operator|->
name|sc
argument_list|)
expr_stmt|;
call|(
modifier|*
name|scp
operator|->
name|rndr
operator|->
name|draw_border
call|)
argument_list|(
name|scp
argument_list|,
name|color
argument_list|)
expr_stmt|;
name|SC_VIDEO_UNLOCK
argument_list|(
name|scp
operator|->
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|SC_NO_FONT_LOADING
end_ifndef

begin_function
name|void
name|sc_load_font
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|page
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|width
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
name|base
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|sc_softc_t
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|scp
operator|->
name|sc
expr_stmt|;
name|sc
operator|->
name|font_loading_in_progress
operator|=
name|TRUE
expr_stmt|;
name|vidd_load_font
argument_list|(
name|sc
operator|->
name|adp
argument_list|,
name|page
argument_list|,
name|size
argument_list|,
name|width
argument_list|,
name|buf
argument_list|,
name|base
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|sc
operator|->
name|font_loading_in_progress
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sc_save_font
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|page
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|width
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
name|base
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|sc_softc_t
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|scp
operator|->
name|sc
expr_stmt|;
name|sc
operator|->
name|font_loading_in_progress
operator|=
name|TRUE
expr_stmt|;
name|vidd_save_font
argument_list|(
name|sc
operator|->
name|adp
argument_list|,
name|page
argument_list|,
name|size
argument_list|,
name|width
argument_list|,
name|buf
argument_list|,
name|base
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|sc
operator|->
name|font_loading_in_progress
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sc_show_font
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|page
parameter_list|)
block|{
name|vidd_show_font
argument_list|(
name|scp
operator|->
name|sc
operator|->
name|adp
argument_list|,
name|page
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SC_NO_FONT_LOADING */
end_comment

begin_function
name|void
name|sc_paste
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|u_char
modifier|*
name|rmap
decl_stmt|;
name|tp
operator|=
name|SC_DEV
argument_list|(
name|scp
operator|->
name|sc
argument_list|,
name|scp
operator|->
name|sc
operator|->
name|cur_scp
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tty_opened
argument_list|(
name|tp
argument_list|)
condition|)
return|return;
name|rmap
operator|=
name|scp
operator|->
name|sc
operator|->
name|scr_rmap
expr_stmt|;
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
operator|--
name|count
control|)
name|ttydisc_rint
argument_list|(
name|tp
argument_list|,
name|rmap
index|[
operator|*
name|p
operator|++
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ttydisc_rint_done
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sc_respond
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|wakeup
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|tp
operator|=
name|SC_DEV
argument_list|(
name|scp
operator|->
name|sc
argument_list|,
name|scp
operator|->
name|sc
operator|->
name|cur_scp
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tty_opened
argument_list|(
name|tp
argument_list|)
condition|)
return|return;
name|ttydisc_rint_simple
argument_list|(
name|tp
argument_list|,
name|p
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|wakeup
condition|)
block|{
comment|/* XXX: we can't always call ttydisc_rint_done() here! */
name|ttydisc_rint_done
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sc_bell
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|pitch
parameter_list|,
name|int
name|duration
parameter_list|)
block|{
if|if
condition|(
name|cold
operator|||
name|shutdown_in_progress
operator|||
operator|!
name|enable_bell
condition|)
return|return;
if|if
condition|(
name|scp
operator|!=
name|scp
operator|->
name|sc
operator|->
name|cur_scp
operator|&&
operator|(
name|scp
operator|->
name|sc
operator|->
name|flags
operator|&
name|SC_QUIET_BELL
operator|)
condition|)
return|return;
if|if
condition|(
name|scp
operator|->
name|sc
operator|->
name|flags
operator|&
name|SC_VISUAL_BELL
condition|)
block|{
if|if
condition|(
name|scp
operator|->
name|sc
operator|->
name|blink_in_progress
condition|)
return|return;
name|scp
operator|->
name|sc
operator|->
name|blink_in_progress
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|scp
operator|!=
name|scp
operator|->
name|sc
operator|->
name|cur_scp
condition|)
name|scp
operator|->
name|sc
operator|->
name|blink_in_progress
operator|+=
literal|2
expr_stmt|;
name|blink_screen
argument_list|(
name|scp
operator|->
name|sc
operator|->
name|cur_scp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|duration
operator|!=
literal|0
operator|&&
name|pitch
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|scp
operator|!=
name|scp
operator|->
name|sc
operator|->
name|cur_scp
condition|)
name|pitch
operator|*=
literal|2
expr_stmt|;
name|sysbeep
argument_list|(
literal|1193182
operator|/
name|pitch
argument_list|,
name|duration
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|blink_screen
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|scr_stat
modifier|*
name|scp
init|=
name|arg
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
name|ISGRAPHSC
argument_list|(
name|scp
argument_list|)
operator|||
operator|(
name|scp
operator|->
name|sc
operator|->
name|blink_in_progress
operator|<=
literal|1
operator|)
condition|)
block|{
name|scp
operator|->
name|sc
operator|->
name|blink_in_progress
operator|=
literal|0
expr_stmt|;
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|tp
operator|=
name|SC_DEV
argument_list|(
name|scp
operator|->
name|sc
argument_list|,
name|scp
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|tty_opened
argument_list|(
name|tp
argument_list|)
condition|)
name|sctty_outwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|sc
operator|->
name|delayed_next_scr
condition|)
name|sc_switch_scr
argument_list|(
name|scp
operator|->
name|sc
argument_list|,
name|scp
operator|->
name|sc
operator|->
name|delayed_next_scr
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
call|(
modifier|*
name|scp
operator|->
name|rndr
operator|->
name|draw
call|)
argument_list|(
name|scp
argument_list|,
literal|0
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
argument_list|,
name|scp
operator|->
name|sc
operator|->
name|blink_in_progress
operator|&
literal|1
argument_list|)
expr_stmt|;
name|scp
operator|->
name|sc
operator|->
name|blink_in_progress
operator|--
expr_stmt|;
name|timeout
argument_list|(
name|blink_screen
argument_list|,
name|scp
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Until sc_attach_unit() gets called no dev structures will be available  * to store the per-screen current status.  This is the case when the  * kernel is initially booting and needs access to its console.  During  * this early phase of booting the console's current status is kept in  * one statically defined scr_stat structure, and any pointers to the  * dev structures will be NULL.  */
end_comment

begin_function
specifier|static
name|scr_stat
modifier|*
name|sc_get_stat
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|&
name|main_console
operator|)
return|;
return|return
operator|(
name|SC_STAT
argument_list|(
name|tp
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate active keyboard. Try to allocate "kbdmux" keyboard first, and,  * if found, add all non-busy keyboards to "kbdmux". Otherwise look for  * any keyboard.  */
end_comment

begin_function
specifier|static
name|int
name|sc_allocate_keyboard
parameter_list|(
name|sc_softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|int
name|idx0
decl_stmt|,
name|idx
decl_stmt|;
name|keyboard_t
modifier|*
name|k0
decl_stmt|,
modifier|*
name|k
decl_stmt|;
name|keyboard_info_t
name|ki
decl_stmt|;
name|idx0
operator|=
name|kbd_allocate
argument_list|(
literal|"kbdmux"
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|sc
operator|->
name|keyboard
argument_list|,
name|sckbdevent
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx0
operator|!=
operator|-
literal|1
condition|)
block|{
name|k0
operator|=
name|kbd_get_keyboard
argument_list|(
name|idx0
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
name|kbd_find_keyboard2
argument_list|(
literal|"*"
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
init|;
name|idx
operator|!=
operator|-
literal|1
condition|;
name|idx
operator|=
name|kbd_find_keyboard2
argument_list|(
literal|"*"
argument_list|,
operator|-
literal|1
argument_list|,
name|idx
operator|+
literal|1
argument_list|)
control|)
block|{
name|k
operator|=
name|kbd_get_keyboard
argument_list|(
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|==
name|idx0
operator|||
name|KBD_IS_BUSY
argument_list|(
name|k
argument_list|)
condition|)
continue|continue;
name|bzero
argument_list|(
operator|&
name|ki
argument_list|,
sizeof|sizeof
argument_list|(
name|ki
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ki
operator|.
name|kb_name
argument_list|,
name|k
operator|->
name|kb_name
argument_list|)
expr_stmt|;
name|ki
operator|.
name|kb_unit
operator|=
name|k
operator|->
name|kb_unit
expr_stmt|;
operator|(
name|void
operator|)
name|kbdd_ioctl
argument_list|(
name|k0
argument_list|,
name|KBADDKBD
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ki
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|idx0
operator|=
name|kbd_allocate
argument_list|(
literal|"*"
argument_list|,
name|unit
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|sc
operator|->
name|keyboard
argument_list|,
name|sckbdevent
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|idx0
operator|)
return|;
block|}
end_function

end_unit

