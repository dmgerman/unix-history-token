begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992-1998 SÃ¸ren Schmidt  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification, immediately at the beginning of the file.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  *	$Id: syscons.c,v 1.290 1999/01/11 03:18:27 yokota Exp $  */
end_comment

begin_include
include|#
directive|include
file|"sc.h"
end_include

begin_include
include|#
directive|include
file|"splash.h"
end_include

begin_include
include|#
directive|include
file|"apm.h"
end_include

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|"opt_devfs.h"
end_include

begin_include
include|#
directive|include
file|"opt_vesa.h"
end_include

begin_include
include|#
directive|include
file|"opt_vm86.h"
end_include

begin_include
include|#
directive|include
file|"opt_syscons.h"
end_include

begin_if
if|#
directive|if
name|NSC
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEVFS
end_ifdef

begin_include
include|#
directive|include
file|<sys/devfsext.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/bootinfo.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/cons.h>
end_include

begin_include
include|#
directive|include
file|<machine/console.h>
end_include

begin_include
include|#
directive|include
file|<machine/mouse.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/psl.h>
end_include

begin_include
include|#
directive|include
file|<machine/frame.h>
end_include

begin_include
include|#
directive|include
file|<machine/pc/display.h>
end_include

begin_include
include|#
directive|include
file|<machine/pc/vesa.h>
end_include

begin_include
include|#
directive|include
file|<machine/apm_bios.h>
end_include

begin_include
include|#
directive|include
file|<machine/random.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<dev/kbd/kbdreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/fb/fbreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/fb/vgareg.h>
end_include

begin_include
include|#
directive|include
file|<dev/fb/splashreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/syscons/syscons.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/timerreg.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAXCONS
argument_list|)
end_if

begin_define
define|#
directive|define
name|MAXCONS
value|16
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SC_MAX_HISTORY_SIZE
argument_list|)
end_if

begin_define
define|#
directive|define
name|SC_MAX_HISTORY_SIZE
value|(1000 * MAXCONS)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SC_HISTORY_SIZE
argument_list|)
end_if

begin_define
define|#
directive|define
name|SC_HISTORY_SIZE
value|(ROW * 4)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|SC_HISTORY_SIZE
operator|*
name|MAXCONS
operator|)
operator|>
name|SC_MAX_HISTORY_SIZE
end_if

begin_undef
undef|#
directive|undef
name|SC_MAX_HISTORY_SIZE
end_undef

begin_define
define|#
directive|define
name|SC_MAX_HISTORY_SIZE
value|(SC_HISTORY_SIZE * MAXCONS)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SC_MOUSE_CHAR
argument_list|)
end_if

begin_define
define|#
directive|define
name|SC_MOUSE_CHAR
value|(0xd0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|COLD
value|0
end_define

begin_define
define|#
directive|define
name|WARM
value|1
end_define

begin_define
define|#
directive|define
name|DEFAULT_BLANKTIME
value|(5*60)
end_define

begin_comment
comment|/* 5 minutes */
end_comment

begin_define
define|#
directive|define
name|MAX_BLANKTIME
value|(7*24*60*60)
end_define

begin_comment
comment|/* 7 days!? */
end_comment

begin_comment
comment|/* for backward compatibility */
end_comment

begin_define
define|#
directive|define
name|OLD_CONS_MOUSECTL
value|_IOWR('c', 10, old_mouse_info_t)
end_define

begin_typedef
typedef|typedef
struct|struct
name|old_mouse_data
block|{
name|int
name|x
decl_stmt|;
name|int
name|y
decl_stmt|;
name|int
name|buttons
decl_stmt|;
block|}
name|old_mouse_data_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|old_mouse_info
block|{
name|int
name|operation
decl_stmt|;
union|union
block|{
name|struct
name|old_mouse_data
name|data
decl_stmt|;
name|struct
name|mouse_mode
name|mode
decl_stmt|;
block|}
name|u
union|;
block|}
name|old_mouse_info_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|default_attr
name|user_default
init|=
block|{
operator|(
name|FG_LIGHTGREY
operator||
name|BG_BLACK
operator|)
operator|<<
literal|8
block|,
operator|(
name|FG_BLACK
operator||
name|BG_LIGHTGREY
operator|)
operator|<<
literal|8
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|default_attr
name|kernel_default
init|=
block|{
operator|(
name|FG_WHITE
operator||
name|BG_BLACK
operator|)
operator|<<
literal|8
block|,
operator|(
name|FG_BLACK
operator||
name|BG_LIGHTGREY
operator|)
operator|<<
literal|8
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|scr_stat
name|main_console
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|scr_stat
modifier|*
name|console
index|[
name|MAXCONS
index|]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEVFS
end_ifdef

begin_decl_stmt
specifier|static
name|void
modifier|*
name|sc_devfs_token
index|[
name|MAXCONS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|sc_mouse_devfs_token
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|sc_console_devfs_token
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|scr_stat
modifier|*
name|cur_console
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|scr_stat
modifier|*
name|new_scp
decl_stmt|,
modifier|*
name|old_scp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|term_stat
name|kernel_console
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|default_attr
modifier|*
name|current_default
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sc_flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|init_done
init|=
name|COLD
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_short
name|sc_buffer
index|[
name|ROW
operator|*
name|COL
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|shutdown_in_progress
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|font_loading_in_progress
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|switch_in_progress
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|write_in_progress
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|blink_in_progress
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|blinkrate
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|adapter
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|keyboard
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|keyboard_t
modifier|*
name|kbd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|delayed_next_scr
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|scrn_blank_time
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* screen saver timeout value */
end_comment

begin_decl_stmt
specifier|static
name|int
name|scrn_blanked
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* screen saver active flag */
end_comment

begin_decl_stmt
specifier|static
name|long
name|scrn_time_stamp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|saver_mode
init|=
name|CONS_LKM_SAVER
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* LKM/user saver */
end_comment

begin_decl_stmt
specifier|static
name|int
name|run_scrn_saver
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* should run the saver? */
end_comment

begin_decl_stmt
specifier|static
name|int
name|scrn_idle
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* about to run the saver */
end_comment

begin_decl_stmt
name|u_char
name|scr_map
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|scr_rmap
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|initial_video_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* initial video mode # */
end_comment

begin_decl_stmt
name|int
name|fonts_loaded
init|=
literal|0
ifdef|#
directive|ifdef
name|STD8X16FONT
operator||
name|FONT_16
endif|#
directive|endif
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|font_8
index|[
literal|256
operator|*
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|font_14
index|[
literal|256
operator|*
literal|14
index|]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|STD8X16FONT
end_ifdef

begin_decl_stmt
specifier|extern
endif|#
directive|endif
name|u_char
name|font_16
index|[
literal|256
operator|*
literal|16
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|palette
index|[
literal|256
operator|*
literal|3
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
modifier|*
name|cut_buffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cut_buffer_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mouse_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sysmouse protocol level */
end_comment

begin_decl_stmt
specifier|static
name|mousestatus_t
name|mouse_status
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_short
name|mouse_and_mask
index|[
literal|16
index|]
init|=
block|{
literal|0xc000
block|,
literal|0xe000
block|,
literal|0xf000
block|,
literal|0xf800
block|,
literal|0xfc00
block|,
literal|0xfe00
block|,
literal|0xff00
block|,
literal|0xff80
block|,
literal|0xfe00
block|,
literal|0x1e00
block|,
literal|0x1f00
block|,
literal|0x0f00
block|,
literal|0x0f00
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_short
name|mouse_or_mask
index|[
literal|16
index|]
init|=
block|{
literal|0x0000
block|,
literal|0x4000
block|,
literal|0x6000
block|,
literal|0x7000
block|,
literal|0x7800
block|,
literal|0x7c00
block|,
literal|0x7e00
block|,
literal|0x6800
block|,
literal|0x0c00
block|,
literal|0x0c00
block|,
literal|0x0600
block|,
literal|0x0600
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sc_history_size
init|=
name|SC_HISTORY_SIZE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|extra_history_size
init|=
name|SC_MAX_HISTORY_SIZE
operator|-
name|SC_HISTORY_SIZE
operator|*
name|MAXCONS
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|none_saver
parameter_list|(
name|int
name|blank
parameter_list|)
block|{ }
end_function

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|current_saver
function_decl|)
parameter_list|(
name|int
name|blank
parameter_list|)
init|=
name|none_saver
function_decl|;
end_function_decl

begin_decl_stmt
name|d_ioctl_t
modifier|*
name|sc_user_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sticky_splash
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* OS specific stuff */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|not_yet_done
end_ifdef

begin_define
define|#
directive|define
name|VIRTUAL_TTY
parameter_list|(
name|x
parameter_list|)
value|(sccons[x] = ttymalloc(sccons[x]))
end_define

begin_decl_stmt
name|struct
name|CONSOLE_TTY
argument_list|(
name|sccons
index|[
name|MAXCONS
index|]
operator|=
name|ttymalloc
argument_list|(
name|sccons
index|[
name|MAXCONS
index|]
argument_list|)
argument_list|)
decl|struct
name|MOUSE_TTY
argument_list|(
name|sccons
index|[
name|MAXCONS
operator|+
literal|1
index|]
operator|=
name|ttymalloc
argument_list|(
name|sccons
index|[
name|MAXCONS
operator|+
literal|1
index|]
argument_list|)
argument_list|)
decl|struct
name|tty
modifier|*
name|sccons
index|[
name|MAXCONS
operator|+
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|VIRTUAL_TTY
parameter_list|(
name|x
parameter_list|)
value|&sccons[x]
end_define

begin_define
define|#
directive|define
name|CONSOLE_TTY
value|&sccons[MAXCONS]
end_define

begin_define
define|#
directive|define
name|MOUSE_TTY
value|&sccons[MAXCONS+1]
end_define

begin_decl_stmt
specifier|static
name|struct
name|tty
name|sccons
index|[
name|MAXCONS
operator|+
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SC_MOUSE
value|128
end_define

begin_define
define|#
directive|define
name|SC_CONSOLE
value|255
end_define

begin_decl_stmt
name|u_short
modifier|*
name|Crtat
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|nsccons
init|=
name|MAXCONS
operator|+
literal|2
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|WRAPHIST
parameter_list|(
name|scp
parameter_list|,
name|pointer
parameter_list|,
name|offset
parameter_list|)
define|\
value|((scp)->history + ((((pointer) - (scp)->history) + (scp)->history_size \     + (offset)) % (scp)->history_size))
end_define

begin_define
define|#
directive|define
name|ISSIGVALID
parameter_list|(
name|sig
parameter_list|)
value|((sig)> 0&& (sig)< NSIG)
end_define

begin_comment
comment|/* some useful macros */
end_comment

begin_define
define|#
directive|define
name|kbd_read_char
parameter_list|(
name|kbd
parameter_list|,
name|wait
parameter_list|)
define|\
value|(*kbdsw[(kbd)->kb_index]->read_char)((kbd), (wait))
end_define

begin_define
define|#
directive|define
name|kbd_check_char
parameter_list|(
name|kbd
parameter_list|)
define|\
value|(*kbdsw[(kbd)->kb_index]->check_char)((kbd))
end_define

begin_define
define|#
directive|define
name|kbd_enable
parameter_list|(
name|kbd
parameter_list|)
define|\
value|(*kbdsw[(kbd)->kb_index]->enable)((kbd))
end_define

begin_define
define|#
directive|define
name|kbd_disable
parameter_list|(
name|kbd
parameter_list|)
define|\
value|(*kbdsw[(kbd)->kb_index]->disable)((kbd))
end_define

begin_define
define|#
directive|define
name|kbd_lock
parameter_list|(
name|kbd
parameter_list|,
name|lockf
parameter_list|)
define|\
value|(*kbdsw[(kbd)->kb_index]->lock)((kbd), (lockf))
end_define

begin_define
define|#
directive|define
name|kbd_ioctl
parameter_list|(
name|kbd
parameter_list|,
name|cmd
parameter_list|,
name|arg
parameter_list|)
define|\
value|(((kbd) == NULL) ?						\ 		ENODEV : (*kbdsw[(kbd)->kb_index]->ioctl)((kbd), (cmd), (arg)))
end_define

begin_define
define|#
directive|define
name|kbd_clear_state
parameter_list|(
name|kbd
parameter_list|)
define|\
value|(*kbdsw[(kbd)->kb_index]->clear_state)((kbd))
end_define

begin_define
define|#
directive|define
name|kbd_get_fkeystr
parameter_list|(
name|kbd
parameter_list|,
name|fkey
parameter_list|,
name|len
parameter_list|)
define|\
value|(*kbdsw[(kbd)->kb_index]->get_fkeystr)((kbd), (fkey), (len))
end_define

begin_comment
comment|/* prototypes */
end_comment

begin_function_decl
specifier|static
name|int
name|scattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|kbd_callback_func_t
name|sckbdevent
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|scparam
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|termios
modifier|*
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|scprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|scvidprobe
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|cons
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sckbdprobe
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|cons
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|scstart
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|scmousestart
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|scinit
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|scshutdown
parameter_list|(
name|int
name|howto
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|scgetc
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|,
name|u_int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|SCGETC_CN
value|1
end_define

begin_define
define|#
directive|define
name|SCGETC_NONBLOCK
value|2
end_define

begin_function_decl
specifier|static
name|int
name|sccngetch
parameter_list|(
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sccnupdate
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|scr_stat
modifier|*
name|alloc_scp
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_scp
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sc_bcopy
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|u_short
modifier|*
name|p
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|,
name|int
name|mark
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_scr_num
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|timeout_t
name|scrn_timer
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|scrn_update
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|show_cursor
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|NSPLASH
operator|>
literal|0
end_if

begin_function_decl
specifier|static
name|int
name|scsplash_callback
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|scsplash_saver
parameter_list|(
name|int
name|show
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|add_scrn_saver
parameter_list|(
name|void
function_decl|(
modifier|*
name|this_saver
function_decl|)
parameter_list|(
name|int
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|remove_scrn_saver
parameter_list|(
name|void
function_decl|(
modifier|*
name|this_saver
function_decl|)
parameter_list|(
name|int
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_scrn_saver_mode
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|mode
parameter_list|,
name|u_char
modifier|*
name|pal
parameter_list|,
name|int
name|border
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|restore_scrn_saver_mode
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stop_scrn_saver
parameter_list|(
name|void
function_decl|(
modifier|*
name|saver
function_decl|)
parameter_list|(
name|int
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wait_scrn_saver_stop
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|scsplash_stick
parameter_list|(
name|stick
parameter_list|)
value|(sticky_splash = (stick))
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !NSPLASH */
end_comment

begin_define
define|#
directive|define
name|stop_scrn_saver
parameter_list|(
name|saver
parameter_list|)
end_define

begin_define
define|#
directive|define
name|wait_scrn_saver_stop
parameter_list|()
value|0
end_define

begin_define
define|#
directive|define
name|scsplash_stick
parameter_list|(
name|stick
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NSPLASH */
end_comment

begin_function_decl
specifier|static
name|int
name|switch_scr
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|u_int
name|next_scr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|exchange_scr
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|scan_esc
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|u_char
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ansi_put
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|draw_cursor_image
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remove_cursor_image
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|move_crsr
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|history_to_screen
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|history_up_line
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|history_down_line
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mask2attr
parameter_list|(
name|struct
name|term_stat
modifier|*
name|term
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|save_kbd_state
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|update_kbd_state
parameter_list|(
name|int
name|state
parameter_list|,
name|int
name|mask
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|update_kbd_leds
parameter_list|(
name|int
name|which
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_destructive_cursor
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_mouse_pos
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|skip_spc_right
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|u_short
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|skip_spc_left
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|u_short
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mouse_cut
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mouse_cut_start
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mouse_cut_end
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mouse_cut_word
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mouse_cut_line
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mouse_cut_extend
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mouse_paste
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|draw_mouse_image
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remove_mouse_image
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|draw_cutmarking
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remove_cutmarking
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_bell
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|pitch
parameter_list|,
name|int
name|duration
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|timeout_t
name|blink_screen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cn_probe_t
name|sccnprobe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cn_init_t
name|sccninit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cn_getc_t
name|sccngetc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cn_checkc_t
name|sccncheckc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cn_putc_t
name|sccnputc
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|CONS_DRIVER
argument_list|(
name|sc
argument_list|,
name|sccnprobe
argument_list|,
name|sccninit
argument_list|,
name|sccngetc
argument_list|,
name|sccncheckc
argument_list|,
name|sccnputc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|isa_driver
name|scdriver
init|=
block|{
name|scprobe
block|,
name|scattach
block|,
literal|"sc"
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|scopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|scclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|scread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|scwrite
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|scioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_mmap_t
name|scmmap
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|12
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|sc_cdevsw
init|=
block|{
name|scopen
block|,
name|scclose
block|,
name|scread
block|,
name|scwrite
block|,
name|scioctl
block|,
name|nullstop
block|,
name|noreset
block|,
name|scdevtotty
block|,
name|ttpoll
block|,
name|scmmap
block|,
name|nostrategy
block|,
literal|"sc"
block|,
name|NULL
block|,
operator|-
literal|1
block|,
name|nodump
block|,
name|nopsize
block|,
name|D_TTY
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|draw_cursor_image
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|u_short
name|cursor_image
decl_stmt|;
name|u_short
modifier|*
name|ptr
decl_stmt|;
name|u_short
name|prev_image
decl_stmt|;
if|if
condition|(
name|ISPIXELSC
argument_list|(
name|scp
argument_list|)
condition|)
block|{
name|sc_bcopy
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|ptr
operator|=
operator|(
name|u_short
operator|*
operator|)
operator|(
name|scp
operator|->
name|adp
operator|->
name|va_window
operator|)
operator|+
operator|(
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
operator|)
expr_stmt|;
comment|/* do we have a destructive cursor ? */
if|if
condition|(
name|sc_flags
operator|&
name|CHAR_CURSOR
condition|)
block|{
name|prev_image
operator|=
name|scp
operator|->
name|cursor_saveunder
expr_stmt|;
name|cursor_image
operator|=
operator|*
name|ptr
operator|&
literal|0x00ff
expr_stmt|;
if|if
condition|(
name|cursor_image
operator|==
name|DEAD_CHAR
condition|)
name|cursor_image
operator|=
name|prev_image
operator|&
literal|0x00ff
expr_stmt|;
name|cursor_image
operator||=
operator|*
operator|(
name|scp
operator|->
name|cursor_pos
operator|)
operator|&
literal|0xff00
expr_stmt|;
name|scp
operator|->
name|cursor_saveunder
operator|=
name|cursor_image
expr_stmt|;
comment|/* update the cursor bitmap if the char under the cursor has changed */
if|if
condition|(
name|prev_image
operator|!=
name|cursor_image
condition|)
name|set_destructive_cursor
argument_list|(
name|scp
argument_list|)
expr_stmt|;
comment|/* modify cursor_image */
if|if
condition|(
operator|!
operator|(
name|sc_flags
operator|&
name|BLINK_CURSOR
operator|)
operator|||
operator|(
operator|(
name|sc_flags
operator|&
name|BLINK_CURSOR
operator|)
operator|&&
operator|(
name|blinkrate
operator|&
literal|4
operator|)
operator|)
condition|)
block|{
comment|/*  	     * When the mouse pointer is at the same position as the cursor, 	     * the cursor bitmap needs to be updated even if the char under  	     * the cursor hasn't changed, because the mouse pionter may  	     * have moved by a few dots within the cursor cel. 	     */
if|if
condition|(
operator|(
name|prev_image
operator|==
name|cursor_image
operator|)
operator|&&
operator|(
name|cursor_image
operator|!=
operator|*
operator|(
name|scp
operator|->
name|cursor_pos
operator|)
operator|)
condition|)
name|set_destructive_cursor
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|cursor_image
operator|&=
literal|0xff00
expr_stmt|;
name|cursor_image
operator||=
name|DEAD_CHAR
expr_stmt|;
block|}
block|}
else|else
block|{
name|cursor_image
operator|=
operator|(
operator|*
operator|(
name|ptr
operator|)
operator|&
literal|0x00ff
operator|)
operator||
operator|*
operator|(
name|scp
operator|->
name|cursor_pos
operator|)
operator|&
literal|0xff00
expr_stmt|;
name|scp
operator|->
name|cursor_saveunder
operator|=
name|cursor_image
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc_flags
operator|&
name|BLINK_CURSOR
operator|)
operator|||
operator|(
operator|(
name|sc_flags
operator|&
name|BLINK_CURSOR
operator|)
operator|&&
operator|(
name|blinkrate
operator|&
literal|4
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|cursor_image
operator|&
literal|0x7000
operator|)
operator|==
literal|0x7000
condition|)
block|{
name|cursor_image
operator|&=
literal|0x8fff
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cursor_image
operator|&
literal|0x0700
operator|)
condition|)
name|cursor_image
operator||=
literal|0x0700
expr_stmt|;
block|}
else|else
block|{
name|cursor_image
operator||=
literal|0x7000
expr_stmt|;
if|if
condition|(
operator|(
name|cursor_image
operator|&
literal|0x0700
operator|)
operator|==
literal|0x0700
condition|)
name|cursor_image
operator|&=
literal|0xf0ff
expr_stmt|;
block|}
block|}
block|}
operator|*
name|ptr
operator|=
name|cursor_image
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|remove_cursor_image
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
if|if
condition|(
name|ISPIXELSC
argument_list|(
name|scp
argument_list|)
condition|)
name|sc_bcopy
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|cursor_oldpos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|cursor_oldpos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
operator|*
operator|(
operator|(
name|u_short
operator|*
operator|)
operator|(
name|scp
operator|->
name|adp
operator|->
name|va_window
operator|)
operator|+
operator|(
name|scp
operator|->
name|cursor_oldpos
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|)
operator|=
name|scp
operator|->
name|cursor_saveunder
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|move_crsr
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
if|if
condition|(
name|x
operator|<
literal|0
condition|)
name|x
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|y
operator|<
literal|0
condition|)
name|y
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|x
operator|>=
name|scp
operator|->
name|xsize
condition|)
name|x
operator|=
name|scp
operator|->
name|xsize
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|y
operator|>=
name|scp
operator|->
name|ysize
condition|)
name|y
operator|=
name|scp
operator|->
name|ysize
operator|-
literal|1
expr_stmt|;
name|scp
operator|->
name|xpos
operator|=
name|x
expr_stmt|;
name|scp
operator|->
name|ypos
operator|=
name|y
expr_stmt|;
name|scp
operator|->
name|cursor_pos
operator|=
name|scp
operator|->
name|scr_buf
operator|+
name|scp
operator|->
name|ypos
operator|*
name|scp
operator|->
name|xsize
operator|+
name|scp
operator|->
name|xpos
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|scprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
if|if
condition|(
operator|!
name|scvidprobe
argument_list|(
name|dev
operator|->
name|id_unit
argument_list|,
name|dev
operator|->
name|id_flags
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"sc%d: no video adapter is found.\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|(
name|sckbdprobe
argument_list|(
name|dev
operator|->
name|id_unit
argument_list|,
name|dev
operator|->
name|id_flags
argument_list|,
name|FALSE
argument_list|)
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* probe video adapters, return TRUE if found */
end_comment

begin_function
specifier|static
name|int
name|scvidprobe
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|cons
parameter_list|)
block|{
name|video_adapter_t
modifier|*
name|adp
decl_stmt|;
comment|/*      * Access the video adapter driver through the back door!      * Video adapter drivers need to be configured before syscons.      * However, when syscons is being probed as the low-level console,      * they have not been initialized yet.  We force them to initialize      * themselves here. XXX      */
name|vid_configure
argument_list|(
name|cons
condition|?
name|VIO_PROBE_ONLY
else|:
literal|0
argument_list|)
expr_stmt|;
comment|/* allocate a frame buffer */
if|if
condition|(
name|adapter
operator|<
literal|0
condition|)
block|{
name|adapter
operator|=
name|vid_allocate
argument_list|(
literal|"*"
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|<
literal|0
condition|)
return|return
name|FALSE
return|;
block|}
name|adp
operator|=
name|vid_get_adapter
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* shouldn't fail */
name|Crtat
operator|=
operator|(
name|u_short
operator|*
operator|)
name|adp
operator|->
name|va_window
expr_stmt|;
name|initial_video_mode
operator|=
name|adp
operator|->
name|va_initial_mode
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* probe the keyboard, return TRUE if found */
end_comment

begin_function
specifier|static
name|int
name|sckbdprobe
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|cons
parameter_list|)
block|{
comment|/* access the keyboard driver through the backdoor! */
name|kbd_configure
argument_list|(
name|cons
condition|?
name|KB_CONF_PROBE_ONLY
else|:
literal|0
argument_list|)
expr_stmt|;
comment|/* allocate a keyboard and register the keyboard event handler */
if|if
condition|(
name|keyboard
operator|<
literal|0
condition|)
block|{
name|keyboard
operator|=
name|kbd_allocate
argument_list|(
literal|"*"
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|keyboard
argument_list|,
name|sckbdevent
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyboard
operator|<
literal|0
condition|)
return|return
name|FALSE
return|;
block|}
name|kbd
operator|=
name|kbd_get_keyboard
argument_list|(
name|keyboard
argument_list|)
expr_stmt|;
comment|/* shouldn't fail */
return|return
name|TRUE
return|;
block|}
end_function

begin_if
if|#
directive|if
name|NAPM
operator|>
literal|0
end_if

begin_function
specifier|static
name|int
name|scresume
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
if|if
condition|(
name|kbd
operator|!=
name|NULL
condition|)
name|kbd_clear_state
argument_list|(
name|kbd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|scattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|scr_stat
modifier|*
name|scp
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|VESA
argument_list|)
operator|&&
name|defined
argument_list|(
name|VM86
argument_list|)
name|video_info_t
name|info
decl_stmt|;
endif|#
directive|endif
name|dev_t
name|cdev
init|=
name|makedev
argument_list|(
name|CDEV_MAJOR
argument_list|,
literal|0
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|DEVFS
name|int
name|vc
decl_stmt|;
endif|#
directive|endif
name|scinit
argument_list|()
expr_stmt|;
name|scp
operator|=
name|console
index|[
literal|0
index|]
expr_stmt|;
name|sc_flags
operator|=
name|dev
operator|->
name|id_flags
expr_stmt|;
if|if
condition|(
operator|!
name|ISFONTAVAIL
argument_list|(
name|scp
operator|->
name|adp
operator|->
name|va_flags
argument_list|)
condition|)
name|sc_flags
operator|&=
operator|~
name|CHAR_CURSOR
expr_stmt|;
comment|/* copy temporary buffer to final buffer */
name|scp
operator|->
name|scr_buf
operator|=
name|NULL
expr_stmt|;
name|sc_alloc_scr_buffer
argument_list|(
name|scp
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|sc_buffer
argument_list|,
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
comment|/* cut buffer is available only when the mouse pointer is used */
if|if
condition|(
name|ISMOUSEAVAIL
argument_list|(
name|scp
operator|->
name|adp
operator|->
name|va_flags
argument_list|)
condition|)
name|sc_alloc_cut_buffer
argument_list|(
name|scp
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* initialize history buffer& pointers */
name|sc_alloc_history_buffer
argument_list|(
name|scp
argument_list|,
name|sc_history_size
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|VESA
argument_list|)
operator|&&
name|defined
argument_list|(
name|VM86
argument_list|)
if|if
condition|(
operator|(
name|sc_flags
operator|&
name|VESA800X600
operator|)
operator|&&
operator|(
operator|(
operator|*
name|vidsw
index|[
name|scp
operator|->
name|ad
index|]
operator|->
name|get_info
operator|)
operator|(
name|scp
operator|->
name|adp
operator|,
name|M_VESA_800x600
operator|,
operator|&
name|info
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
if|#
directive|if
name|NSPLASH
operator|>
literal|0
name|splash_term
argument_list|(
name|scp
operator|->
name|adp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc_set_graphics_mode
argument_list|(
name|scp
argument_list|,
name|NULL
argument_list|,
name|M_VESA_800x600
argument_list|)
expr_stmt|;
name|sc_set_pixel_mode
argument_list|(
name|scp
argument_list|,
name|NULL
argument_list|,
name|COL
argument_list|,
name|ROW
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|initial_video_mode
operator|=
name|M_VESA_800x600
expr_stmt|;
if|#
directive|if
name|NSPLASH
operator|>
literal|0
comment|/* put up the splash again! */
name|splash_init
argument_list|(
name|scp
operator|->
name|adp
argument_list|,
name|scsplash_callback
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* VESA&& VM86 */
comment|/* initialize cursor stuff */
if|if
condition|(
operator|!
name|ISGRAPHSC
argument_list|(
name|scp
argument_list|)
condition|)
name|draw_cursor_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
comment|/* get screen update going */
name|scrn_timer
argument_list|(
operator|(
name|void
operator|*
operator|)
name|TRUE
argument_list|)
expr_stmt|;
comment|/* set up the keyboard */
name|kbd_ioctl
argument_list|(
name|kbd
argument_list|,
name|KDSKBMODE
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|scp
operator|->
name|kbd_mode
argument_list|)
expr_stmt|;
name|update_kbd_state
argument_list|(
name|scp
operator|->
name|status
argument_list|,
name|LOCK_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"sc%d:"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|" fb%d"
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyboard
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|" kbd%d"
argument_list|,
name|keyboard
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"sc%d: "
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|scp
operator|->
name|adp
operator|->
name|va_type
condition|)
block|{
case|case
name|KD_VGA
case|:
name|printf
argument_list|(
literal|"VGA %s"
argument_list|,
operator|(
name|scp
operator|->
name|adp
operator|->
name|va_flags
operator|&
name|V_ADP_COLOR
operator|)
condition|?
literal|"color"
else|:
literal|"mono"
argument_list|)
expr_stmt|;
break|break;
case|case
name|KD_EGA
case|:
name|printf
argument_list|(
literal|"EGA %s"
argument_list|,
operator|(
name|scp
operator|->
name|adp
operator|->
name|va_flags
operator|&
name|V_ADP_COLOR
operator|)
condition|?
literal|"color"
else|:
literal|"mono"
argument_list|)
expr_stmt|;
break|break;
case|case
name|KD_CGA
case|:
name|printf
argument_list|(
literal|"CGA"
argument_list|)
expr_stmt|;
break|break;
case|case
name|KD_MONO
case|:
case|case
name|KD_HERCULES
case|:
default|default:
name|printf
argument_list|(
literal|"MDA/Hercules"
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"<%d virtual consoles, flags=0x%x>\n"
argument_list|,
name|MAXCONS
argument_list|,
name|sc_flags
argument_list|)
expr_stmt|;
if|#
directive|if
name|NAPM
operator|>
literal|0
name|scp
operator|->
name|r_hook
operator|.
name|ah_fun
operator|=
name|scresume
expr_stmt|;
name|scp
operator|->
name|r_hook
operator|.
name|ah_arg
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|r_hook
operator|.
name|ah_name
operator|=
literal|"system keyboard"
expr_stmt|;
name|scp
operator|->
name|r_hook
operator|.
name|ah_order
operator|=
name|APM_MID_ORDER
expr_stmt|;
name|apm_hook_establish
argument_list|(
name|APM_HOOK_RESUME
argument_list|,
operator|&
name|scp
operator|->
name|r_hook
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|at_shutdown
argument_list|(
name|scshutdown
argument_list|,
name|NULL
argument_list|,
name|SHUTDOWN_PRE_SYNC
argument_list|)
expr_stmt|;
name|cdevsw_add
argument_list|(
operator|&
name|cdev
argument_list|,
operator|&
name|sc_cdevsw
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVFS
for|for
control|(
name|vc
operator|=
literal|0
init|;
name|vc
operator|<
name|MAXCONS
condition|;
name|vc
operator|++
control|)
name|sc_devfs_token
index|[
name|vc
index|]
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|sc_cdevsw
argument_list|,
name|vc
argument_list|,
name|DV_CHR
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"ttyv%r"
argument_list|,
name|vc
argument_list|)
expr_stmt|;
name|sc_mouse_devfs_token
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|sc_cdevsw
argument_list|,
name|SC_MOUSE
argument_list|,
name|DV_CHR
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"sysmouse"
argument_list|)
expr_stmt|;
name|sc_console_devfs_token
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|sc_cdevsw
argument_list|,
name|SC_CONSOLE
argument_list|,
name|DV_CHR
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"consolectl"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
name|struct
name|tty
modifier|*
name|scdevtotty
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
name|int
name|unit
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|init_done
operator|==
name|COLD
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|unit
operator|==
name|SC_CONSOLE
condition|)
return|return
name|CONSOLE_TTY
return|;
if|if
condition|(
name|unit
operator|==
name|SC_MOUSE
condition|)
return|return
name|MOUSE_TTY
return|;
if|if
condition|(
name|unit
operator|>=
name|MAXCONS
operator|||
name|unit
operator|<
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
name|VIRTUAL_TTY
argument_list|(
name|unit
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|scopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
name|scdevtotty
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|keyarg_t
name|key
decl_stmt|;
if|if
condition|(
operator|!
name|tp
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|tp
operator|->
name|t_oproc
operator|=
operator|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|==
name|SC_MOUSE
operator|)
condition|?
name|scmousestart
else|:
name|scstart
expr_stmt|;
name|tp
operator|->
name|t_param
operator|=
name|scparam
expr_stmt|;
name|tp
operator|->
name|t_dev
operator|=
name|dev
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
condition|)
block|{
name|ttychars
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* Use the current setting of the<-- key as default VERASE. */
comment|/* If the Delete key is preferable, an stty is necessary     */
name|key
operator|.
name|keynum
operator|=
literal|0x0e
expr_stmt|;
comment|/* how do we know this magic number... XXX */
name|kbd_ioctl
argument_list|(
name|kbd
argument_list|,
name|GIO_KEYMAPENT
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|key
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_cc
index|[
name|VERASE
index|]
operator|=
name|key
operator|.
name|key
operator|.
name|map
index|[
literal|0
index|]
expr_stmt|;
name|tp
operator|->
name|t_iflag
operator|=
name|TTYDEF_IFLAG
expr_stmt|;
name|tp
operator|->
name|t_oflag
operator|=
name|TTYDEF_OFLAG
expr_stmt|;
name|tp
operator|->
name|t_cflag
operator|=
name|TTYDEF_CFLAG
expr_stmt|;
name|tp
operator|->
name|t_lflag
operator|=
name|TTYDEF_LFLAG
expr_stmt|;
name|tp
operator|->
name|t_ispeed
operator|=
name|tp
operator|->
name|t_ospeed
operator|=
name|TTYDEF_SPEED
expr_stmt|;
name|scparam
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|)
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
operator|)
operator|(
name|tp
operator|,
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|==
name|SC_MOUSE
condition|)
name|mouse_level
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
block|}
elseif|else
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_XCLUDE
operator|&&
name|p
operator|->
name|p_ucred
operator|->
name|cr_uid
operator|!=
literal|0
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|<
name|MAXCONS
operator|&&
operator|!
name|console
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
condition|)
block|{
name|console
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
operator|=
name|alloc_scp
argument_list|()
expr_stmt|;
if|if
condition|(
name|ISGRAPHSC
argument_list|(
name|console
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
argument_list|)
condition|)
name|sc_set_pixel_mode
argument_list|(
name|console
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
argument_list|,
name|NULL
argument_list|,
name|COL
argument_list|,
name|ROW
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|<
name|MAXCONS
operator|&&
operator|!
name|tp
operator|->
name|t_winsize
operator|.
name|ws_col
operator|&&
operator|!
name|tp
operator|->
name|t_winsize
operator|.
name|ws_row
condition|)
block|{
name|tp
operator|->
name|t_winsize
operator|.
name|ws_col
operator|=
name|console
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
operator|->
name|xsize
expr_stmt|;
name|tp
operator|->
name|t_winsize
operator|.
name|ws_row
operator|=
name|console
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
operator|->
name|ysize
expr_stmt|;
block|}
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_open
operator|)
operator|(
name|dev
operator|,
name|tp
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|scclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
name|scdevtotty
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|scr_stat
modifier|*
name|scp
decl_stmt|;
if|if
condition|(
operator|!
name|tp
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|<
name|MAXCONS
condition|)
block|{
name|scp
operator|=
name|sc_get_scr_stat
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|SWITCH_WAIT_ACQ
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|scp
operator|->
name|smode
argument_list|)
expr_stmt|;
if|#
directive|if
name|not_yet_done
if|if
condition|(
name|scp
operator|==
operator|&
name|main_console
condition|)
block|{
name|scp
operator|->
name|pid
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|proc
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|smode
operator|.
name|mode
operator|=
name|VT_AUTO
expr_stmt|;
block|}
else|else
block|{
name|free
argument_list|(
name|scp
operator|->
name|scr_buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|history
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|scp
operator|->
name|history
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|history_size
operator|/
name|scp
operator|->
name|xsize
operator|>
name|imax
argument_list|(
name|sc_history_size
argument_list|,
name|scp
operator|->
name|ysize
argument_list|)
condition|)
name|extra_history_size
operator|+=
name|scp
operator|->
name|history_size
operator|/
name|scp
operator|->
name|xsize
operator|-
name|imax
argument_list|(
name|sc_history_size
argument_list|,
name|scp
operator|->
name|ysize
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|scp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|console
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
operator|=
name|NULL
expr_stmt|;
block|}
else|#
directive|else
name|scp
operator|->
name|pid
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|proc
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|smode
operator|.
name|mode
operator|=
name|VT_AUTO
expr_stmt|;
endif|#
directive|endif
block|}
name|spltty
argument_list|()
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_close
operator|)
operator|(
name|tp
operator|,
name|flag
operator|)
expr_stmt|;
name|ttyclose
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|spl0
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|scread
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
name|scdevtotty
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tp
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_read
operator|)
operator|(
name|tp
operator|,
name|uio
operator|,
name|flag
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|scwrite
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
name|scdevtotty
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tp
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_write
operator|)
operator|(
name|tp
operator|,
name|uio
operator|,
name|flag
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sckbdevent
parameter_list|(
name|keyboard_t
modifier|*
name|thiskbd
parameter_list|,
name|int
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
specifier|static
name|struct
name|tty
modifier|*
name|cur_tty
decl_stmt|;
name|int
name|c
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|;
comment|/* assert(thiskbd == kbd) */
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|KBDIO_KEYINPUT
case|:
break|break;
case|case
name|KBDIO_UNLOADING
case|:
name|kbd
operator|=
name|NULL
expr_stmt|;
name|kbd_release
argument_list|(
name|thiskbd
argument_list|,
operator|(
name|void
operator|*
operator|)
name|keyboard
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
default|default:
return|return
name|EINVAL
return|;
block|}
comment|/*       * Loop while there is still input to get from the keyboard.      * I don't think this is nessesary, and it doesn't fix      * the Xaccel-2.1 keyboard hang, but it can't hurt.		XXX      */
while|while
condition|(
operator|(
name|c
operator|=
name|scgetc
argument_list|(
name|thiskbd
argument_list|,
name|SCGETC_NONBLOCK
argument_list|)
operator|)
operator|!=
name|NOKEY
condition|)
block|{
name|cur_tty
operator|=
name|VIRTUAL_TTY
argument_list|(
name|get_scr_num
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cur_tty
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
condition|)
if|if
condition|(
operator|!
operator|(
operator|(
name|cur_tty
operator|=
name|CONSOLE_TTY
operator|)
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
condition|)
continue|continue;
switch|switch
condition|(
name|KEYFLAGS
argument_list|(
name|c
argument_list|)
condition|)
block|{
case|case
literal|0x0000
case|:
comment|/* normal key */
operator|(
operator|*
name|linesw
index|[
name|cur_tty
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|KEYCHAR
argument_list|(
name|c
argument_list|)
operator|,
name|cur_tty
operator|)
expr_stmt|;
break|break;
case|case
name|FKEY
case|:
comment|/* function key, return string */
name|cp
operator|=
name|kbd_get_fkeystr
argument_list|(
name|thiskbd
argument_list|,
name|KEYCHAR
argument_list|(
name|c
argument_list|)
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
operator|(
operator|*
name|linesw
index|[
name|cur_tty
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
operator|*
name|cp
operator|++
operator|,
name|cur_tty
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|MKEY
case|:
comment|/* meta is active, prepend ESC */
operator|(
operator|*
name|linesw
index|[
name|cur_tty
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
literal|0x1b
operator|,
name|cur_tty
operator|)
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|cur_tty
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|KEYCHAR
argument_list|(
name|c
argument_list|)
operator|,
name|cur_tty
operator|)
expr_stmt|;
break|break;
case|case
name|BKEY
case|:
comment|/* backtab fixed sequence (esc [ Z) */
operator|(
operator|*
name|linesw
index|[
name|cur_tty
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
literal|0x1b
operator|,
name|cur_tty
operator|)
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|cur_tty
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
literal|'['
operator|,
name|cur_tty
operator|)
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|cur_tty
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
literal|'Z'
operator|,
name|cur_tty
operator|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|cur_console
operator|->
name|status
operator|&
name|MOUSE_VISIBLE
condition|)
block|{
name|remove_mouse_image
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
name|cur_console
operator|->
name|status
operator|&=
operator|~
name|MOUSE_VISIBLE
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|scparam
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|termios
modifier|*
name|t
parameter_list|)
block|{
name|tp
operator|->
name|t_ispeed
operator|=
name|t
operator|->
name|c_ispeed
expr_stmt|;
name|tp
operator|->
name|t_ospeed
operator|=
name|t
operator|->
name|c_ospeed
expr_stmt|;
name|tp
operator|->
name|t_cflag
operator|=
name|t
operator|->
name|c_cflag
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|scioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|u_int
name|delta_ehs
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|scr_stat
modifier|*
name|scp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|tp
operator|=
name|scdevtotty
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tp
condition|)
return|return
name|ENXIO
return|;
name|scp
operator|=
name|sc_get_scr_stat
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
expr_stmt|;
comment|/* If there is a user_ioctl function call that first */
if|if
condition|(
name|sc_user_ioctl
condition|)
block|{
name|error
operator|=
call|(
modifier|*
name|sc_user_ioctl
call|)
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOIOCTL
condition|)
return|return
name|error
return|;
block|}
name|error
operator|=
name|sc_vid_ioctl
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOIOCTL
condition|)
return|return
name|error
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
comment|/* process console hardware related ioctl's */
case|case
name|GIO_ATTR
case|:
comment|/* get current attributes */
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
expr_stmt|;
return|return
literal|0
return|;
case|case
name|GIO_COLOR
case|:
comment|/* is this a color console ? */
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
operator|(
name|scp
operator|->
name|adp
operator|->
name|va_flags
operator|&
name|V_ADP_COLOR
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
return|return
literal|0
return|;
case|case
name|CONS_BLANKTIME
case|:
comment|/* set screen saver timeout (0 = no saver) */
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|<
literal|0
operator|||
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|>
name|MAX_BLANKTIME
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|scrn_blank_time
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
name|run_scrn_saver
operator|=
operator|(
name|scrn_blank_time
operator|!=
literal|0
operator|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|CONS_CURSORTYPE
case|:
comment|/* set cursor type blink/noblink */
if|if
condition|(
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|)
operator|&
literal|0x01
condition|)
name|sc_flags
operator||=
name|BLINK_CURSOR
expr_stmt|;
else|else
name|sc_flags
operator|&=
operator|~
name|BLINK_CURSOR
expr_stmt|;
if|if
condition|(
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|)
operator|&
literal|0x02
condition|)
block|{
if|if
condition|(
operator|!
name|ISFONTAVAIL
argument_list|(
name|scp
operator|->
name|adp
operator|->
name|va_flags
argument_list|)
condition|)
return|return
name|ENXIO
return|;
name|sc_flags
operator||=
name|CHAR_CURSOR
expr_stmt|;
block|}
else|else
name|sc_flags
operator|&=
operator|~
name|CHAR_CURSOR
expr_stmt|;
comment|/*  	 * The cursor shape is global property; all virtual consoles 	 * are affected. Update the cursor in the current console... 	 */
if|if
condition|(
operator|!
name|ISGRAPHSC
argument_list|(
name|cur_console
argument_list|)
condition|)
block|{
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|remove_cursor_image
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc_flags
operator|&
name|CHAR_CURSOR
condition|)
name|set_destructive_cursor
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
name|draw_cursor_image
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
case|case
name|CONS_BELLTYPE
case|:
comment|/* set bell type sound/visual */
if|if
condition|(
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|)
operator|&
literal|0x01
condition|)
name|sc_flags
operator||=
name|VISUAL_BELL
expr_stmt|;
else|else
name|sc_flags
operator|&=
operator|~
name|VISUAL_BELL
expr_stmt|;
if|if
condition|(
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|)
operator|&
literal|0x02
condition|)
name|sc_flags
operator||=
name|QUIET_BELL
expr_stmt|;
else|else
name|sc_flags
operator|&=
operator|~
name|QUIET_BELL
expr_stmt|;
return|return
literal|0
return|;
case|case
name|CONS_HISTORY
case|:
comment|/* set history size */
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|>
literal|0
condition|)
block|{
name|int
name|lines
decl_stmt|;
comment|/* buffer size to allocate */
name|int
name|lines0
decl_stmt|;
comment|/* current buffer size */
name|lines
operator|=
name|imax
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|,
name|scp
operator|->
name|ysize
argument_list|)
expr_stmt|;
name|lines0
operator|=
operator|(
name|scp
operator|->
name|history
operator|!=
name|NULL
operator|)
condition|?
name|scp
operator|->
name|history_size
operator|/
name|scp
operator|->
name|xsize
else|:
name|scp
operator|->
name|ysize
expr_stmt|;
if|if
condition|(
name|lines0
operator|>
name|imax
argument_list|(
name|sc_history_size
argument_list|,
name|scp
operator|->
name|ysize
argument_list|)
condition|)
name|delta_ehs
operator|=
name|lines0
operator|-
name|imax
argument_list|(
name|sc_history_size
argument_list|,
name|scp
operator|->
name|ysize
argument_list|)
expr_stmt|;
else|else
name|delta_ehs
operator|=
literal|0
expr_stmt|;
comment|/* 	     * syscons unconditionally allocates buffers upto SC_HISTORY_SIZE 	     * lines or scp->ysize lines, whichever is larger. A value  	     * greater than that is allowed, subject to extra_history_size. 	     */
if|if
condition|(
name|lines
operator|>
name|imax
argument_list|(
name|sc_history_size
argument_list|,
name|scp
operator|->
name|ysize
argument_list|)
condition|)
if|if
condition|(
name|lines
operator|-
name|imax
argument_list|(
name|sc_history_size
argument_list|,
name|scp
operator|->
name|ysize
argument_list|)
operator|>
name|extra_history_size
operator|+
name|delta_ehs
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|cur_console
operator|->
name|status
operator|&
name|BUFFER_SAVED
condition|)
return|return
name|EBUSY
return|;
name|sc_alloc_history_buffer
argument_list|(
name|scp
argument_list|,
name|lines
argument_list|,
name|delta_ehs
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
name|EINVAL
return|;
case|case
name|CONS_MOUSECTL
case|:
comment|/* control mouse arrow */
case|case
name|OLD_CONS_MOUSECTL
case|:
block|{
comment|/* MOUSE_BUTTON?DOWN -> MOUSE_MSC_BUTTON?UP */
specifier|static
name|int
name|butmap
index|[
literal|8
index|]
init|=
block|{
name|MOUSE_MSC_BUTTON1UP
operator||
name|MOUSE_MSC_BUTTON2UP
operator||
name|MOUSE_MSC_BUTTON3UP
block|,
name|MOUSE_MSC_BUTTON2UP
operator||
name|MOUSE_MSC_BUTTON3UP
block|,
name|MOUSE_MSC_BUTTON1UP
operator||
name|MOUSE_MSC_BUTTON3UP
block|,
name|MOUSE_MSC_BUTTON3UP
block|,
name|MOUSE_MSC_BUTTON1UP
operator||
name|MOUSE_MSC_BUTTON2UP
block|,
name|MOUSE_MSC_BUTTON2UP
block|,
name|MOUSE_MSC_BUTTON1UP
block|,
literal|0
block|, 	}
decl_stmt|;
name|mouse_info_t
modifier|*
name|mouse
init|=
operator|(
name|mouse_info_t
operator|*
operator|)
name|data
decl_stmt|;
name|mouse_info_t
name|buf
decl_stmt|;
comment|/* FIXME: */
if|if
condition|(
operator|!
name|ISMOUSEAVAIL
argument_list|(
name|scp
operator|->
name|adp
operator|->
name|va_flags
argument_list|)
condition|)
return|return
name|ENODEV
return|;
if|if
condition|(
name|cmd
operator|==
name|OLD_CONS_MOUSECTL
condition|)
block|{
specifier|static
name|u_char
name|swapb
index|[]
init|=
block|{
literal|0
block|,
literal|4
block|,
literal|2
block|,
literal|6
block|,
literal|1
block|,
literal|5
block|,
literal|3
block|,
literal|7
block|}
decl_stmt|;
name|old_mouse_info_t
modifier|*
name|old_mouse
init|=
operator|(
name|old_mouse_info_t
operator|*
operator|)
name|data
decl_stmt|;
name|mouse
operator|=
operator|&
name|buf
expr_stmt|;
name|mouse
operator|->
name|operation
operator|=
name|old_mouse
operator|->
name|operation
expr_stmt|;
switch|switch
condition|(
name|mouse
operator|->
name|operation
condition|)
block|{
case|case
name|MOUSE_MODE
case|:
name|mouse
operator|->
name|u
operator|.
name|mode
operator|=
name|old_mouse
operator|->
name|u
operator|.
name|mode
expr_stmt|;
break|break;
case|case
name|MOUSE_SHOW
case|:
case|case
name|MOUSE_HIDE
case|:
break|break;
case|case
name|MOUSE_MOVEABS
case|:
case|case
name|MOUSE_MOVEREL
case|:
case|case
name|MOUSE_ACTION
case|:
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|x
operator|=
name|old_mouse
operator|->
name|u
operator|.
name|data
operator|.
name|x
expr_stmt|;
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|y
operator|=
name|old_mouse
operator|->
name|u
operator|.
name|data
operator|.
name|y
expr_stmt|;
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|z
operator|=
literal|0
expr_stmt|;
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|buttons
operator|=
name|swapb
index|[
name|old_mouse
operator|->
name|u
operator|.
name|data
operator|.
name|buttons
operator|&
literal|0x7
index|]
expr_stmt|;
break|break;
case|case
name|MOUSE_GETINFO
case|:
name|old_mouse
operator|->
name|u
operator|.
name|data
operator|.
name|x
operator|=
name|scp
operator|->
name|mouse_xpos
expr_stmt|;
name|old_mouse
operator|->
name|u
operator|.
name|data
operator|.
name|y
operator|=
name|scp
operator|->
name|mouse_ypos
expr_stmt|;
name|old_mouse
operator|->
name|u
operator|.
name|data
operator|.
name|buttons
operator|=
name|swapb
index|[
name|scp
operator|->
name|mouse_buttons
operator|&
literal|0x7
index|]
expr_stmt|;
break|break;
default|default:
return|return
name|EINVAL
return|;
block|}
block|}
switch|switch
condition|(
name|mouse
operator|->
name|operation
condition|)
block|{
case|case
name|MOUSE_MODE
case|:
if|if
condition|(
name|ISSIGVALID
argument_list|(
name|mouse
operator|->
name|u
operator|.
name|mode
operator|.
name|signal
argument_list|)
condition|)
block|{
name|scp
operator|->
name|mouse_signal
operator|=
name|mouse
operator|->
name|u
operator|.
name|mode
operator|.
name|signal
expr_stmt|;
name|scp
operator|->
name|mouse_proc
operator|=
name|p
expr_stmt|;
name|scp
operator|->
name|mouse_pid
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
block|}
else|else
block|{
name|scp
operator|->
name|mouse_signal
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|mouse_proc
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|mouse_pid
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
case|case
name|MOUSE_SHOW
case|:
if|if
condition|(
name|ISTEXTSC
argument_list|(
name|scp
argument_list|)
operator|&&
operator|!
operator|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_ENABLED
operator|)
condition|)
block|{
name|scp
operator|->
name|status
operator||=
operator|(
name|MOUSE_ENABLED
operator||
name|MOUSE_VISIBLE
operator|)
expr_stmt|;
name|scp
operator|->
name|mouse_oldpos
operator|=
name|scp
operator|->
name|mouse_pos
expr_stmt|;
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
name|EINVAL
return|;
break|break;
case|case
name|MOUSE_HIDE
case|:
if|if
condition|(
name|ISTEXTSC
argument_list|(
name|scp
argument_list|)
operator|&&
operator|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_ENABLED
operator|)
condition|)
block|{
name|scp
operator|->
name|status
operator|&=
operator|~
operator|(
name|MOUSE_ENABLED
operator||
name|MOUSE_VISIBLE
operator|)
expr_stmt|;
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
name|EINVAL
return|;
break|break;
case|case
name|MOUSE_MOVEABS
case|:
name|scp
operator|->
name|mouse_xpos
operator|=
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|x
expr_stmt|;
name|scp
operator|->
name|mouse_ypos
operator|=
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|y
expr_stmt|;
name|set_mouse_pos
argument_list|(
name|scp
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOUSE_MOVEREL
case|:
name|scp
operator|->
name|mouse_xpos
operator|+=
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|x
expr_stmt|;
name|scp
operator|->
name|mouse_ypos
operator|+=
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|y
expr_stmt|;
name|set_mouse_pos
argument_list|(
name|scp
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOUSE_GETINFO
case|:
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|x
operator|=
name|scp
operator|->
name|mouse_xpos
expr_stmt|;
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|y
operator|=
name|scp
operator|->
name|mouse_ypos
expr_stmt|;
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|z
operator|=
literal|0
expr_stmt|;
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|buttons
operator|=
name|scp
operator|->
name|mouse_buttons
expr_stmt|;
return|return
literal|0
return|;
case|case
name|MOUSE_ACTION
case|:
case|case
name|MOUSE_MOTION_EVENT
case|:
comment|/* this should maybe only be settable from /dev/consolectl SOS */
comment|/* send out mouse event on /dev/sysmouse */
name|mouse_status
operator|.
name|dx
operator|+=
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|x
expr_stmt|;
name|mouse_status
operator|.
name|dy
operator|+=
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|y
expr_stmt|;
name|mouse_status
operator|.
name|dz
operator|+=
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|z
expr_stmt|;
if|if
condition|(
name|mouse
operator|->
name|operation
operator|==
name|MOUSE_ACTION
condition|)
name|mouse_status
operator|.
name|button
operator|=
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|buttons
expr_stmt|;
name|mouse_status
operator|.
name|flags
operator||=
operator|(
operator|(
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|x
operator|||
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|y
operator|||
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|z
operator|)
condition|?
name|MOUSE_POSCHANGED
else|:
literal|0
operator|)
operator||
operator|(
name|mouse_status
operator|.
name|obutton
operator|^
name|mouse_status
operator|.
name|button
operator|)
expr_stmt|;
if|if
condition|(
name|mouse_status
operator|.
name|flags
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ISTEXTSC
argument_list|(
name|cur_console
argument_list|)
operator|&&
operator|(
name|cur_console
operator|->
name|status
operator|&
name|MOUSE_ENABLED
operator|)
condition|)
name|cur_console
operator|->
name|status
operator||=
name|MOUSE_VISIBLE
expr_stmt|;
if|if
condition|(
operator|(
name|MOUSE_TTY
operator|)
operator|->
name|t_state
operator|&
name|TS_ISOPEN
condition|)
block|{
name|u_char
name|buf
index|[
name|MOUSE_SYS_PACKETSIZE
index|]
decl_stmt|;
name|int
name|j
decl_stmt|;
comment|/* the first five bytes are compatible with MouseSystems' */
name|buf
index|[
literal|0
index|]
operator|=
name|MOUSE_MSC_SYNC
operator||
name|butmap
index|[
name|mouse_status
operator|.
name|button
operator|&
name|MOUSE_STDBUTTONS
index|]
expr_stmt|;
name|j
operator|=
name|imax
argument_list|(
name|imin
argument_list|(
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|x
argument_list|,
literal|255
argument_list|)
argument_list|,
operator|-
literal|256
argument_list|)
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|j
operator|>>
literal|1
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|j
operator|-
name|buf
index|[
literal|1
index|]
expr_stmt|;
name|j
operator|=
operator|-
name|imax
argument_list|(
name|imin
argument_list|(
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|y
argument_list|,
literal|255
argument_list|)
argument_list|,
operator|-
literal|256
argument_list|)
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|j
operator|>>
literal|1
expr_stmt|;
name|buf
index|[
literal|4
index|]
operator|=
name|j
operator|-
name|buf
index|[
literal|2
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MOUSE_MSC_PACKETSIZE
condition|;
name|j
operator|++
control|)
operator|(
operator|*
name|linesw
index|[
operator|(
name|MOUSE_TTY
operator|)
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|buf
index|[
name|j
index|]
operator|,
name|MOUSE_TTY
operator|)
expr_stmt|;
if|if
condition|(
name|mouse_level
operator|>=
literal|1
condition|)
block|{
comment|/* extended part */
name|j
operator|=
name|imax
argument_list|(
name|imin
argument_list|(
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|z
argument_list|,
literal|127
argument_list|)
argument_list|,
operator|-
literal|128
argument_list|)
expr_stmt|;
name|buf
index|[
literal|5
index|]
operator|=
operator|(
name|j
operator|>>
literal|1
operator|)
operator|&
literal|0x7f
expr_stmt|;
name|buf
index|[
literal|6
index|]
operator|=
operator|(
name|j
operator|-
operator|(
name|j
operator|>>
literal|1
operator|)
operator|)
operator|&
literal|0x7f
expr_stmt|;
comment|/* buttons 4-10 */
name|buf
index|[
literal|7
index|]
operator|=
operator|(
operator|~
name|mouse_status
operator|.
name|button
operator|>>
literal|3
operator|)
operator|&
literal|0x7f
expr_stmt|;
for|for
control|(
name|j
operator|=
name|MOUSE_MSC_PACKETSIZE
init|;
name|j
operator|<
name|MOUSE_SYS_PACKETSIZE
condition|;
name|j
operator|++
control|)
operator|(
operator|*
name|linesw
index|[
operator|(
name|MOUSE_TTY
operator|)
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|buf
index|[
name|j
index|]
operator|,
name|MOUSE_TTY
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cur_console
operator|->
name|mouse_signal
condition|)
block|{
name|cur_console
operator|->
name|mouse_buttons
operator|=
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|buttons
expr_stmt|;
comment|/* has controlling process died? */
if|if
condition|(
name|cur_console
operator|->
name|mouse_proc
operator|&&
operator|(
name|cur_console
operator|->
name|mouse_proc
operator|!=
name|pfind
argument_list|(
name|cur_console
operator|->
name|mouse_pid
argument_list|)
operator|)
condition|)
block|{
name|cur_console
operator|->
name|mouse_signal
operator|=
literal|0
expr_stmt|;
name|cur_console
operator|->
name|mouse_proc
operator|=
name|NULL
expr_stmt|;
name|cur_console
operator|->
name|mouse_pid
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|psignal
argument_list|(
name|cur_console
operator|->
name|mouse_proc
argument_list|,
name|cur_console
operator|->
name|mouse_signal
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mouse
operator|->
name|operation
operator|==
name|MOUSE_ACTION
operator|&&
name|cut_buffer
operator|!=
name|NULL
condition|)
block|{
comment|/* process button presses */
if|if
condition|(
operator|(
name|cur_console
operator|->
name|mouse_buttons
operator|^
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|buttons
operator|)
operator|&&
name|ISTEXTSC
argument_list|(
name|cur_console
argument_list|)
condition|)
block|{
name|cur_console
operator|->
name|mouse_buttons
operator|=
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|buttons
expr_stmt|;
if|if
condition|(
name|cur_console
operator|->
name|mouse_buttons
operator|&
name|MOUSE_BUTTON1DOWN
condition|)
name|mouse_cut_start
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
else|else
name|mouse_cut_end
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_console
operator|->
name|mouse_buttons
operator|&
name|MOUSE_BUTTON2DOWN
operator|||
name|cur_console
operator|->
name|mouse_buttons
operator|&
name|MOUSE_BUTTON3DOWN
condition|)
name|mouse_paste
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|x
operator|!=
literal|0
operator|||
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|y
operator|!=
literal|0
condition|)
block|{
name|cur_console
operator|->
name|mouse_xpos
operator|+=
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|x
expr_stmt|;
name|cur_console
operator|->
name|mouse_ypos
operator|+=
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|y
expr_stmt|;
name|set_mouse_pos
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MOUSE_BUTTON_EVENT
case|:
if|if
condition|(
operator|(
name|mouse
operator|->
name|u
operator|.
name|event
operator|.
name|id
operator|&
name|MOUSE_BUTTONS
operator|)
operator|==
literal|0
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|mouse
operator|->
name|u
operator|.
name|event
operator|.
name|value
operator|<
literal|0
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|mouse
operator|->
name|u
operator|.
name|event
operator|.
name|value
operator|>
literal|0
condition|)
block|{
name|cur_console
operator|->
name|mouse_buttons
operator||=
name|mouse
operator|->
name|u
operator|.
name|event
operator|.
name|id
expr_stmt|;
name|mouse_status
operator|.
name|button
operator||=
name|mouse
operator|->
name|u
operator|.
name|event
operator|.
name|id
expr_stmt|;
block|}
else|else
block|{
name|cur_console
operator|->
name|mouse_buttons
operator|&=
operator|~
name|mouse
operator|->
name|u
operator|.
name|event
operator|.
name|id
expr_stmt|;
name|mouse_status
operator|.
name|button
operator|&=
operator|~
name|mouse
operator|->
name|u
operator|.
name|event
operator|.
name|id
expr_stmt|;
block|}
name|mouse_status
operator|.
name|flags
operator||=
name|mouse_status
operator|.
name|obutton
operator|^
name|mouse_status
operator|.
name|button
expr_stmt|;
if|if
condition|(
name|mouse_status
operator|.
name|flags
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ISTEXTSC
argument_list|(
name|cur_console
argument_list|)
operator|&&
operator|(
name|cur_console
operator|->
name|status
operator|&
name|MOUSE_ENABLED
operator|)
condition|)
name|cur_console
operator|->
name|status
operator||=
name|MOUSE_VISIBLE
expr_stmt|;
if|if
condition|(
operator|(
name|MOUSE_TTY
operator|)
operator|->
name|t_state
operator|&
name|TS_ISOPEN
condition|)
block|{
name|u_char
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|MOUSE_MSC_SYNC
operator||
name|butmap
index|[
name|mouse_status
operator|.
name|button
operator|&
name|MOUSE_STDBUTTONS
index|]
expr_stmt|;
name|buf
index|[
literal|7
index|]
operator|=
operator|(
operator|~
name|mouse_status
operator|.
name|button
operator|>>
literal|3
operator|)
operator|&
literal|0x7f
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|buf
index|[
literal|2
index|]
operator|=
name|buf
index|[
literal|3
index|]
operator|=
name|buf
index|[
literal|4
index|]
operator|=
name|buf
index|[
literal|5
index|]
operator|=
name|buf
index|[
literal|6
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
operator|(
name|mouse_level
operator|>=
literal|1
operator|)
condition|?
name|MOUSE_SYS_PACKETSIZE
else|:
name|MOUSE_MSC_PACKETSIZE
operator|)
condition|;
name|i
operator|++
control|)
operator|(
operator|*
name|linesw
index|[
operator|(
name|MOUSE_TTY
operator|)
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|buf
index|[
name|i
index|]
operator|,
name|MOUSE_TTY
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|cur_console
operator|->
name|mouse_signal
condition|)
block|{
if|if
condition|(
name|cur_console
operator|->
name|mouse_proc
operator|&&
operator|(
name|cur_console
operator|->
name|mouse_proc
operator|!=
name|pfind
argument_list|(
name|cur_console
operator|->
name|mouse_pid
argument_list|)
operator|)
condition|)
block|{
name|cur_console
operator|->
name|mouse_signal
operator|=
literal|0
expr_stmt|;
name|cur_console
operator|->
name|mouse_proc
operator|=
name|NULL
expr_stmt|;
name|cur_console
operator|->
name|mouse_pid
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|psignal
argument_list|(
name|cur_console
operator|->
name|mouse_proc
argument_list|,
name|cur_console
operator|->
name|mouse_signal
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ISTEXTSC
argument_list|(
name|cur_console
argument_list|)
operator|||
operator|(
name|cut_buffer
operator|==
name|NULL
operator|)
condition|)
break|break;
switch|switch
condition|(
name|mouse
operator|->
name|u
operator|.
name|event
operator|.
name|id
condition|)
block|{
case|case
name|MOUSE_BUTTON1DOWN
case|:
switch|switch
condition|(
name|mouse
operator|->
name|u
operator|.
name|event
operator|.
name|value
operator|%
literal|4
condition|)
block|{
case|case
literal|0
case|:
comment|/* up */
name|mouse_cut_end
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|mouse_cut_start
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|mouse_cut_word
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|mouse_cut_line
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|MOUSE_BUTTON2DOWN
case|:
switch|switch
condition|(
name|mouse
operator|->
name|u
operator|.
name|event
operator|.
name|value
condition|)
block|{
case|case
literal|0
case|:
comment|/* up */
break|break;
default|default:
name|mouse_paste
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|MOUSE_BUTTON3DOWN
case|:
switch|switch
condition|(
name|mouse
operator|->
name|u
operator|.
name|event
operator|.
name|value
condition|)
block|{
case|case
literal|0
case|:
comment|/* up */
if|if
condition|(
operator|!
operator|(
name|cur_console
operator|->
name|mouse_buttons
operator|&
name|MOUSE_BUTTON1DOWN
operator|)
condition|)
name|mouse_cut_end
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
break|break;
default|default:
name|mouse_cut_extend
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
break|break;
default|default:
return|return
name|EINVAL
return|;
block|}
comment|/* make screensaver happy */
name|sc_touch_scrn_saver
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* MOUSE_XXX: /dev/sysmouse ioctls */
case|case
name|MOUSE_GETHWINFO
case|:
comment|/* get device information */
block|{
name|mousehw_t
modifier|*
name|hw
init|=
operator|(
name|mousehw_t
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|tp
operator|!=
name|MOUSE_TTY
condition|)
return|return
name|ENOTTY
return|;
name|hw
operator|->
name|buttons
operator|=
literal|10
expr_stmt|;
comment|/* XXX unknown */
name|hw
operator|->
name|iftype
operator|=
name|MOUSE_IF_SYSMOUSE
expr_stmt|;
name|hw
operator|->
name|type
operator|=
name|MOUSE_MOUSE
expr_stmt|;
name|hw
operator|->
name|model
operator|=
name|MOUSE_MODEL_GENERIC
expr_stmt|;
name|hw
operator|->
name|hwid
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
case|case
name|MOUSE_GETMODE
case|:
comment|/* get protocol/mode */
block|{
name|mousemode_t
modifier|*
name|mode
init|=
operator|(
name|mousemode_t
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|tp
operator|!=
name|MOUSE_TTY
condition|)
return|return
name|ENOTTY
return|;
name|mode
operator|->
name|level
operator|=
name|mouse_level
expr_stmt|;
switch|switch
condition|(
name|mode
operator|->
name|level
condition|)
block|{
case|case
literal|0
case|:
comment|/* at this level, sysmouse emulates MouseSystems protocol */
name|mode
operator|->
name|protocol
operator|=
name|MOUSE_PROTO_MSC
expr_stmt|;
name|mode
operator|->
name|rate
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* unknown */
name|mode
operator|->
name|resolution
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* unknown */
name|mode
operator|->
name|accelfactor
operator|=
literal|0
expr_stmt|;
comment|/* disabled */
name|mode
operator|->
name|packetsize
operator|=
name|MOUSE_MSC_PACKETSIZE
expr_stmt|;
name|mode
operator|->
name|syncmask
index|[
literal|0
index|]
operator|=
name|MOUSE_MSC_SYNCMASK
expr_stmt|;
name|mode
operator|->
name|syncmask
index|[
literal|1
index|]
operator|=
name|MOUSE_MSC_SYNC
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* at this level, sysmouse uses its own protocol */
name|mode
operator|->
name|protocol
operator|=
name|MOUSE_PROTO_SYSMOUSE
expr_stmt|;
name|mode
operator|->
name|rate
operator|=
operator|-
literal|1
expr_stmt|;
name|mode
operator|->
name|resolution
operator|=
operator|-
literal|1
expr_stmt|;
name|mode
operator|->
name|accelfactor
operator|=
literal|0
expr_stmt|;
name|mode
operator|->
name|packetsize
operator|=
name|MOUSE_SYS_PACKETSIZE
expr_stmt|;
name|mode
operator|->
name|syncmask
index|[
literal|0
index|]
operator|=
name|MOUSE_SYS_SYNCMASK
expr_stmt|;
name|mode
operator|->
name|syncmask
index|[
literal|1
index|]
operator|=
name|MOUSE_SYS_SYNC
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
case|case
name|MOUSE_SETMODE
case|:
comment|/* set protocol/mode */
block|{
name|mousemode_t
modifier|*
name|mode
init|=
operator|(
name|mousemode_t
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|tp
operator|!=
name|MOUSE_TTY
condition|)
return|return
name|ENOTTY
return|;
if|if
condition|(
operator|(
name|mode
operator|->
name|level
operator|<
literal|0
operator|)
operator|||
operator|(
name|mode
operator|->
name|level
operator|>
literal|1
operator|)
condition|)
return|return
name|EINVAL
return|;
name|mouse_level
operator|=
name|mode
operator|->
name|level
expr_stmt|;
return|return
literal|0
return|;
block|}
case|case
name|MOUSE_GETLEVEL
case|:
comment|/* get operation level */
if|if
condition|(
name|tp
operator|!=
name|MOUSE_TTY
condition|)
return|return
name|ENOTTY
return|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|mouse_level
expr_stmt|;
return|return
literal|0
return|;
case|case
name|MOUSE_SETLEVEL
case|:
comment|/* set operation level */
if|if
condition|(
name|tp
operator|!=
name|MOUSE_TTY
condition|)
return|return
name|ENOTTY
return|;
if|if
condition|(
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|<
literal|0
operator|)
operator|||
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|>
literal|1
operator|)
condition|)
return|return
name|EINVAL
return|;
name|mouse_level
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
return|return
literal|0
return|;
case|case
name|MOUSE_GETSTATUS
case|:
comment|/* get accumulated mouse events */
if|if
condition|(
name|tp
operator|!=
name|MOUSE_TTY
condition|)
return|return
name|ENOTTY
return|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
operator|*
operator|(
name|mousestatus_t
operator|*
operator|)
name|data
operator|=
name|mouse_status
expr_stmt|;
name|mouse_status
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|mouse_status
operator|.
name|obutton
operator|=
name|mouse_status
operator|.
name|button
expr_stmt|;
name|mouse_status
operator|.
name|dx
operator|=
literal|0
expr_stmt|;
name|mouse_status
operator|.
name|dy
operator|=
literal|0
expr_stmt|;
name|mouse_status
operator|.
name|dz
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
if|#
directive|if
name|notyet
case|case
name|MOUSE_GETVARS
case|:
comment|/* get internal mouse variables */
case|case
name|MOUSE_SETVARS
case|:
comment|/* set internal mouse variables */
if|if
condition|(
name|tp
operator|!=
name|MOUSE_TTY
condition|)
return|return
name|ENOTTY
return|;
return|return
name|ENODEV
return|;
endif|#
directive|endif
case|case
name|MOUSE_READSTATE
case|:
comment|/* read status from the device */
case|case
name|MOUSE_READDATA
case|:
comment|/* read data from the device */
if|if
condition|(
name|tp
operator|!=
name|MOUSE_TTY
condition|)
return|return
name|ENOTTY
return|;
return|return
name|ENODEV
return|;
case|case
name|CONS_GETINFO
case|:
comment|/* get current (virtual) console info */
block|{
name|vid_info_t
modifier|*
name|ptr
init|=
operator|(
name|vid_info_t
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|ptr
operator|->
name|size
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|vid_info
argument_list|)
condition|)
block|{
name|ptr
operator|->
name|m_num
operator|=
name|get_scr_num
argument_list|()
expr_stmt|;
name|ptr
operator|->
name|mv_col
operator|=
name|scp
operator|->
name|xpos
expr_stmt|;
name|ptr
operator|->
name|mv_row
operator|=
name|scp
operator|->
name|ypos
expr_stmt|;
name|ptr
operator|->
name|mv_csz
operator|=
name|scp
operator|->
name|xsize
expr_stmt|;
name|ptr
operator|->
name|mv_rsz
operator|=
name|scp
operator|->
name|ysize
expr_stmt|;
name|ptr
operator|->
name|mv_norm
operator|.
name|fore
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|std_color
operator|&
literal|0x0f00
operator|)
operator|>>
literal|8
expr_stmt|;
name|ptr
operator|->
name|mv_norm
operator|.
name|back
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|std_color
operator|&
literal|0xf000
operator|)
operator|>>
literal|12
expr_stmt|;
name|ptr
operator|->
name|mv_rev
operator|.
name|fore
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|rev_color
operator|&
literal|0x0f00
operator|)
operator|>>
literal|8
expr_stmt|;
name|ptr
operator|->
name|mv_rev
operator|.
name|back
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|rev_color
operator|&
literal|0xf000
operator|)
operator|>>
literal|12
expr_stmt|;
name|ptr
operator|->
name|mv_grfc
operator|.
name|fore
operator|=
literal|0
expr_stmt|;
comment|/* not supported */
name|ptr
operator|->
name|mv_grfc
operator|.
name|back
operator|=
literal|0
expr_stmt|;
comment|/* not supported */
name|ptr
operator|->
name|mv_ovscan
operator|=
name|scp
operator|->
name|border
expr_stmt|;
if|if
condition|(
name|scp
operator|==
name|cur_console
condition|)
name|save_kbd_state
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|mk_keylock
operator|=
name|scp
operator|->
name|status
operator|&
name|LOCK_MASK
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|EINVAL
return|;
block|}
case|case
name|CONS_GETVERS
case|:
comment|/* get version number */
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
literal|0x200
expr_stmt|;
comment|/* version 2.0 */
return|return
literal|0
return|;
case|case
name|CONS_IDLE
case|:
comment|/* see if the screen has been idle */
comment|/* 	 * When the screen is in the GRAPHICS_MODE or UNKNOWN_MODE, 	 * the user process may have been writing something on the 	 * screen and syscons is not aware of it. Declare the screen 	 * is NOT idle if it is in one of these modes. But there is 	 * an exception to it; if a screen saver is running in the  	 * graphics mode in the current screen, we should say that the 	 * screen has been idle. 	 */
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|scrn_idle
operator|&&
operator|(
operator|!
name|ISGRAPHSC
argument_list|(
name|cur_console
argument_list|)
operator|||
operator|(
name|cur_console
operator|->
name|status
operator|&
name|SAVER_RUNNING
operator|)
operator|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|CONS_SAVERMODE
case|:
comment|/* set saver mode */
switch|switch
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
block|{
case|case
name|CONS_USR_SAVER
case|:
comment|/* if a LKM screen saver is running, stop it first. */
name|scsplash_stick
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|saver_mode
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|wait_scrn_saver_stop
argument_list|()
operator|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|scp
operator|->
name|status
operator||=
name|SAVER_RUNNING
expr_stmt|;
name|scsplash_stick
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONS_LKM_SAVER
case|:
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|saver_mode
operator|==
name|CONS_USR_SAVER
operator|)
operator|&&
operator|(
name|scp
operator|->
name|status
operator|&
name|SAVER_RUNNING
operator|)
condition|)
name|scp
operator|->
name|status
operator|&=
operator|~
name|SAVER_RUNNING
expr_stmt|;
name|saver_mode
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|EINVAL
return|;
block|}
return|return
literal|0
return|;
case|case
name|CONS_SAVERSTART
case|:
comment|/* immediately start/stop the screen saver */
comment|/* 	 * Note that this ioctl does not guarantee the screen saver  	 * actually starts or stops. It merely attempts to do so... 	 */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|run_scrn_saver
operator|=
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|run_scrn_saver
condition|)
name|scrn_time_stamp
operator|-=
name|scrn_blank_time
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|VT_SETMODE
case|:
comment|/* set screen switcher mode */
block|{
name|struct
name|vt_mode
modifier|*
name|mode
decl_stmt|;
name|mode
operator|=
operator|(
expr|struct
name|vt_mode
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|ISSIGVALID
argument_list|(
name|mode
operator|->
name|relsig
argument_list|)
operator|&&
name|ISSIGVALID
argument_list|(
name|mode
operator|->
name|acqsig
argument_list|)
operator|&&
name|ISSIGVALID
argument_list|(
name|mode
operator|->
name|frsig
argument_list|)
condition|)
block|{
name|bcopy
argument_list|(
name|data
argument_list|,
operator|&
name|scp
operator|->
name|smode
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vt_mode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|smode
operator|.
name|mode
operator|==
name|VT_PROCESS
condition|)
block|{
name|scp
operator|->
name|proc
operator|=
name|p
expr_stmt|;
name|scp
operator|->
name|pid
operator|=
name|scp
operator|->
name|proc
operator|->
name|p_pid
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
else|else
return|return
name|EINVAL
return|;
block|}
case|case
name|VT_GETMODE
case|:
comment|/* get screen switcher mode */
name|bcopy
argument_list|(
operator|&
name|scp
operator|->
name|smode
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vt_mode
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|VT_RELDISP
case|:
comment|/* screen switcher ioctl */
switch|switch
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
block|{
case|case
name|VT_FALSE
case|:
comment|/* user refuses to release screen, abort */
if|if
condition|(
name|scp
operator|==
name|old_scp
operator|&&
operator|(
name|scp
operator|->
name|status
operator|&
name|SWITCH_WAIT_REL
operator|)
condition|)
block|{
name|old_scp
operator|->
name|status
operator|&=
operator|~
name|SWITCH_WAIT_REL
expr_stmt|;
name|switch_in_progress
operator|=
name|FALSE
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|EINVAL
return|;
case|case
name|VT_TRUE
case|:
comment|/* user has released screen, go on */
if|if
condition|(
name|scp
operator|==
name|old_scp
operator|&&
operator|(
name|scp
operator|->
name|status
operator|&
name|SWITCH_WAIT_REL
operator|)
condition|)
block|{
name|scp
operator|->
name|status
operator|&=
operator|~
name|SWITCH_WAIT_REL
expr_stmt|;
name|exchange_scr
argument_list|()
expr_stmt|;
if|if
condition|(
name|new_scp
operator|->
name|smode
operator|.
name|mode
operator|==
name|VT_PROCESS
condition|)
block|{
name|new_scp
operator|->
name|status
operator||=
name|SWITCH_WAIT_ACQ
expr_stmt|;
name|psignal
argument_list|(
name|new_scp
operator|->
name|proc
argument_list|,
name|new_scp
operator|->
name|smode
operator|.
name|acqsig
argument_list|)
expr_stmt|;
block|}
else|else
name|switch_in_progress
operator|=
name|FALSE
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|EINVAL
return|;
case|case
name|VT_ACKACQ
case|:
comment|/* acquire acknowledged, switch completed */
if|if
condition|(
name|scp
operator|==
name|new_scp
operator|&&
operator|(
name|scp
operator|->
name|status
operator|&
name|SWITCH_WAIT_ACQ
operator|)
condition|)
block|{
name|scp
operator|->
name|status
operator|&=
operator|~
name|SWITCH_WAIT_ACQ
expr_stmt|;
name|switch_in_progress
operator|=
name|FALSE
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|EINVAL
return|;
default|default:
return|return
name|EINVAL
return|;
block|}
comment|/* NOT REACHED */
case|case
name|VT_OPENQRY
case|:
comment|/* return free virtual console */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXCONS
condition|;
name|i
operator|++
control|)
block|{
name|tp
operator|=
name|VIRTUAL_TTY
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
condition|)
block|{
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|i
operator|+
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
name|EINVAL
return|;
case|case
name|VT_ACTIVATE
case|:
comment|/* switch to screen *data */
return|return
name|switch_scr
argument_list|(
name|scp
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|-
literal|1
argument_list|)
return|;
case|case
name|VT_WAITACTIVE
case|:
comment|/* wait for switch to occur */
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|>
name|MAXCONS
operator|||
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|<
literal|0
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|==
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|-
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|scp
operator|==
name|cur_console
condition|)
return|return
literal|0
return|;
block|}
else|else
name|scp
operator|=
name|console
index|[
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|-
literal|1
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|scp
operator|->
name|smode
argument_list|,
name|PZERO
operator||
name|PCATCH
argument_list|,
literal|"waitvt"
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|ERESTART
condition|)
empty_stmt|;
return|return
name|error
return|;
case|case
name|VT_GETACTIVE
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|get_scr_num
argument_list|()
operator|+
literal|1
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KDENABIO
case|:
comment|/* allow io operations */
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
if|if
condition|(
name|securelevel
operator|>
literal|0
condition|)
return|return
name|EPERM
return|;
name|p
operator|->
name|p_md
operator|.
name|md_regs
operator|->
name|tf_eflags
operator||=
name|PSL_IOPL
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KDDISABIO
case|:
comment|/* disallow io operations (default) */
name|p
operator|->
name|p_md
operator|.
name|md_regs
operator|->
name|tf_eflags
operator|&=
operator|~
name|PSL_IOPL
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KDSKBSTATE
case|:
comment|/* set keyboard state (locks) */
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
operator|~
name|LOCK_MASK
condition|)
return|return
name|EINVAL
return|;
name|scp
operator|->
name|status
operator|&=
operator|~
name|LOCK_MASK
expr_stmt|;
name|scp
operator|->
name|status
operator||=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|scp
operator|==
name|cur_console
condition|)
name|update_kbd_state
argument_list|(
name|scp
operator|->
name|status
argument_list|,
name|LOCK_MASK
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KDGKBSTATE
case|:
comment|/* get keyboard state (locks) */
if|if
condition|(
name|scp
operator|==
name|cur_console
condition|)
name|save_kbd_state
argument_list|(
name|scp
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|scp
operator|->
name|status
operator|&
name|LOCK_MASK
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KDSETRAD
case|:
comment|/* set keyboard repeat& delay rates */
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
operator|~
literal|0x7f
condition|)
return|return
name|EINVAL
return|;
name|error
operator|=
name|kbd_ioctl
argument_list|(
name|kbd
argument_list|,
name|KDSETRAD
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOIOCTL
condition|)
name|error
operator|=
name|ENODEV
expr_stmt|;
return|return
name|error
return|;
case|case
name|KDSKBMODE
case|:
comment|/* set keyboard mode */
switch|switch
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
block|{
case|case
name|K_XLATE
case|:
comment|/* switch to XLT ascii mode */
case|case
name|K_RAW
case|:
comment|/* switch to RAW scancode mode */
case|case
name|K_CODE
case|:
comment|/* switch to CODE mode */
name|scp
operator|->
name|kbd_mode
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|scp
operator|==
name|cur_console
condition|)
name|kbd_ioctl
argument_list|(
name|kbd
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
default|default:
return|return
name|EINVAL
return|;
block|}
comment|/* NOT REACHED */
case|case
name|KDGKBMODE
case|:
comment|/* get keyboard mode */
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|scp
operator|->
name|kbd_mode
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KDGKBINFO
case|:
name|error
operator|=
name|kbd_ioctl
argument_list|(
name|kbd
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOIOCTL
condition|)
name|error
operator|=
name|ENODEV
expr_stmt|;
return|return
name|error
return|;
case|case
name|KDMKTONE
case|:
comment|/* sound the bell */
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
name|do_bell
argument_list|(
name|scp
argument_list|,
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|)
operator|&
literal|0xffff
argument_list|,
operator|(
operator|(
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|)
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
operator|*
name|hz
operator|/
literal|1000
argument_list|)
expr_stmt|;
else|else
name|do_bell
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|bell_pitch
argument_list|,
name|scp
operator|->
name|bell_duration
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KIOCSOUND
case|:
comment|/* make tone (*data) hz */
if|if
condition|(
name|scp
operator|==
name|cur_console
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
block|{
name|int
name|pitch
init|=
name|timer_freq
operator|/
operator|*
operator|(
name|int
operator|*
operator|)
name|data
decl_stmt|;
comment|/* set command for counter 2, 2 byte write */
if|if
condition|(
name|acquire_timer2
argument_list|(
name|TIMER_16BIT
operator||
name|TIMER_SQWAVE
argument_list|)
condition|)
return|return
name|EBUSY
return|;
comment|/* set pitch */
name|outb
argument_list|(
name|TIMER_CNTR2
argument_list|,
name|pitch
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TIMER_CNTR2
argument_list|,
operator|(
name|pitch
operator|>>
literal|8
operator|)
argument_list|)
expr_stmt|;
comment|/* enable counter 2 output to speaker */
name|outb
argument_list|(
name|IO_PPI
argument_list|,
name|inb
argument_list|(
name|IO_PPI
argument_list|)
operator||
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* disable counter 2 output to speaker */
name|outb
argument_list|(
name|IO_PPI
argument_list|,
name|inb
argument_list|(
name|IO_PPI
argument_list|)
operator|&
literal|0xFC
argument_list|)
expr_stmt|;
name|release_timer2
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
case|case
name|KDGKBTYPE
case|:
comment|/* get keyboard type */
name|error
operator|=
name|kbd_ioctl
argument_list|(
name|kbd
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOIOCTL
condition|)
block|{
comment|/* always return something? XXX */
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
case|case
name|KDSETLED
case|:
comment|/* set keyboard LED status */
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
operator|~
name|LED_MASK
condition|)
comment|/* FIXME: LOCK_MASK? */
return|return
name|EINVAL
return|;
name|scp
operator|->
name|status
operator|&=
operator|~
name|LED_MASK
expr_stmt|;
name|scp
operator|->
name|status
operator||=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|scp
operator|==
name|cur_console
condition|)
name|update_kbd_leds
argument_list|(
name|scp
operator|->
name|status
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KDGETLED
case|:
comment|/* get keyboard LED status */
if|if
condition|(
name|scp
operator|==
name|cur_console
condition|)
name|save_kbd_state
argument_list|(
name|scp
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|scp
operator|->
name|status
operator|&
name|LED_MASK
expr_stmt|;
return|return
literal|0
return|;
case|case
name|CONS_SETKBD
case|:
comment|/* set the new keyboard */
block|{
name|keyboard_t
modifier|*
name|newkbd
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|newkbd
operator|=
name|kbd_get_keyboard
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|newkbd
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|kbd
operator|!=
name|newkbd
condition|)
block|{
name|i
operator|=
name|kbd_allocate
argument_list|(
name|newkbd
operator|->
name|kb_name
argument_list|,
name|newkbd
operator|->
name|kb_unit
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|keyboard
argument_list|,
name|sckbdevent
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* i == newkbd->kb_index */
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|kbd
operator|!=
name|NULL
condition|)
block|{
name|save_kbd_state
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
name|kbd_release
argument_list|(
name|kbd
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|keyboard
argument_list|)
expr_stmt|;
block|}
name|kbd
operator|=
name|kbd_get_keyboard
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* kbd == newkbd */
name|keyboard
operator|=
name|i
expr_stmt|;
name|kbd_ioctl
argument_list|(
name|kbd
argument_list|,
name|KDSKBMODE
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|cur_console
operator|->
name|kbd_mode
argument_list|)
expr_stmt|;
name|update_kbd_state
argument_list|(
name|cur_console
operator|->
name|status
argument_list|,
name|LOCK_MASK
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|EPERM
expr_stmt|;
comment|/* XXX */
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
case|case
name|CONS_RELKBD
case|:
comment|/* release the current keyboard */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|kbd
operator|!=
name|NULL
condition|)
block|{
name|save_kbd_state
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
name|error
operator|=
name|kbd_release
argument_list|(
name|kbd
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|keyboard
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|kbd
operator|=
name|NULL
expr_stmt|;
name|keyboard
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
case|case
name|GIO_SCRNMAP
case|:
comment|/* get output translation table */
name|bcopy
argument_list|(
operator|&
name|scr_map
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|scr_map
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|PIO_SCRNMAP
case|:
comment|/* set output translation table */
name|bcopy
argument_list|(
name|data
argument_list|,
operator|&
name|scr_map
argument_list|,
sizeof|sizeof
argument_list|(
name|scr_map
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|scr_map
argument_list|)
condition|;
name|i
operator|++
control|)
name|scr_rmap
index|[
name|scr_map
index|[
name|i
index|]
index|]
operator|=
name|i
expr_stmt|;
return|return
literal|0
return|;
case|case
name|GIO_KEYMAP
case|:
comment|/* get keyboard translation table */
case|case
name|PIO_KEYMAP
case|:
comment|/* set keyboard translation table */
case|case
name|GIO_DEADKEYMAP
case|:
comment|/* get accent key translation table */
case|case
name|PIO_DEADKEYMAP
case|:
comment|/* set accent key translation table */
case|case
name|GETFKEY
case|:
comment|/* get function key string */
case|case
name|SETFKEY
case|:
comment|/* set function key string */
name|error
operator|=
name|kbd_ioctl
argument_list|(
name|kbd
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOIOCTL
condition|)
name|error
operator|=
name|ENODEV
expr_stmt|;
return|return
name|error
return|;
case|case
name|PIO_FONT8x8
case|:
comment|/* set 8x8 dot font */
if|if
condition|(
operator|!
name|ISFONTAVAIL
argument_list|(
name|scp
operator|->
name|adp
operator|->
name|va_flags
argument_list|)
condition|)
return|return
name|ENXIO
return|;
name|bcopy
argument_list|(
name|data
argument_list|,
name|font_8
argument_list|,
literal|8
operator|*
literal|256
argument_list|)
expr_stmt|;
name|fonts_loaded
operator||=
name|FONT_8
expr_stmt|;
comment|/* 	 * FONT KLUDGE 	 * Always use the font page #0. XXX 	 * Don't load if the current font size is not 8x8. 	 */
if|if
condition|(
name|ISTEXTSC
argument_list|(
name|cur_console
argument_list|)
operator|&&
operator|(
name|cur_console
operator|->
name|font_size
operator|<
literal|14
operator|)
condition|)
name|copy_font
argument_list|(
name|cur_console
argument_list|,
name|LOAD
argument_list|,
literal|8
argument_list|,
name|font_8
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|GIO_FONT8x8
case|:
comment|/* get 8x8 dot font */
if|if
condition|(
operator|!
name|ISFONTAVAIL
argument_list|(
name|scp
operator|->
name|adp
operator|->
name|va_flags
argument_list|)
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
name|fonts_loaded
operator|&
name|FONT_8
condition|)
block|{
name|bcopy
argument_list|(
name|font_8
argument_list|,
name|data
argument_list|,
literal|8
operator|*
literal|256
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
name|ENXIO
return|;
case|case
name|PIO_FONT8x14
case|:
comment|/* set 8x14 dot font */
if|if
condition|(
operator|!
name|ISFONTAVAIL
argument_list|(
name|scp
operator|->
name|adp
operator|->
name|va_flags
argument_list|)
condition|)
return|return
name|ENXIO
return|;
name|bcopy
argument_list|(
name|data
argument_list|,
name|font_14
argument_list|,
literal|14
operator|*
literal|256
argument_list|)
expr_stmt|;
name|fonts_loaded
operator||=
name|FONT_14
expr_stmt|;
comment|/* 	 * FONT KLUDGE 	 * Always use the font page #0. XXX 	 * Don't load if the current font size is not 8x14. 	 */
if|if
condition|(
name|ISTEXTSC
argument_list|(
name|cur_console
argument_list|)
operator|&&
operator|(
name|cur_console
operator|->
name|font_size
operator|>=
literal|14
operator|)
operator|&&
operator|(
name|cur_console
operator|->
name|font_size
operator|<
literal|16
operator|)
condition|)
name|copy_font
argument_list|(
name|cur_console
argument_list|,
name|LOAD
argument_list|,
literal|14
argument_list|,
name|font_14
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|GIO_FONT8x14
case|:
comment|/* get 8x14 dot font */
if|if
condition|(
operator|!
name|ISFONTAVAIL
argument_list|(
name|scp
operator|->
name|adp
operator|->
name|va_flags
argument_list|)
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
name|fonts_loaded
operator|&
name|FONT_14
condition|)
block|{
name|bcopy
argument_list|(
name|font_14
argument_list|,
name|data
argument_list|,
literal|14
operator|*
literal|256
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
name|ENXIO
return|;
case|case
name|PIO_FONT8x16
case|:
comment|/* set 8x16 dot font */
if|if
condition|(
operator|!
name|ISFONTAVAIL
argument_list|(
name|scp
operator|->
name|adp
operator|->
name|va_flags
argument_list|)
condition|)
return|return
name|ENXIO
return|;
name|bcopy
argument_list|(
name|data
argument_list|,
name|font_16
argument_list|,
literal|16
operator|*
literal|256
argument_list|)
expr_stmt|;
name|fonts_loaded
operator||=
name|FONT_16
expr_stmt|;
comment|/* 	 * FONT KLUDGE 	 * Always use the font page #0. XXX 	 * Don't load if the current font size is not 8x16. 	 */
if|if
condition|(
name|ISTEXTSC
argument_list|(
name|cur_console
argument_list|)
operator|&&
operator|(
name|cur_console
operator|->
name|font_size
operator|>=
literal|16
operator|)
condition|)
name|copy_font
argument_list|(
name|cur_console
argument_list|,
name|LOAD
argument_list|,
literal|16
argument_list|,
name|font_16
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|GIO_FONT8x16
case|:
comment|/* get 8x16 dot font */
if|if
condition|(
operator|!
name|ISFONTAVAIL
argument_list|(
name|scp
operator|->
name|adp
operator|->
name|va_flags
argument_list|)
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
name|fonts_loaded
operator|&
name|FONT_16
condition|)
block|{
name|bcopy
argument_list|(
name|font_16
argument_list|,
name|data
argument_list|,
literal|16
operator|*
literal|256
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
name|ENXIO
return|;
default|default:
break|break;
block|}
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_ioctl
operator|)
operator|(
name|tp
operator|,
name|cmd
operator|,
name|data
operator|,
name|flag
operator|,
name|p
operator|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOIOCTL
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|ttioctl
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOIOCTL
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|scstart
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|clist
modifier|*
name|rbp
decl_stmt|;
name|int
name|s
decl_stmt|,
name|len
decl_stmt|;
name|u_char
name|buf
index|[
name|PCBURST
index|]
decl_stmt|;
name|scr_stat
modifier|*
name|scp
init|=
name|sc_get_scr_stat
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|SLKED
operator|||
name|blink_in_progress
condition|)
return|return;
comment|/* XXX who repeats the call when the above flags are cleared? */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_TIMEOUT
operator||
name|TS_BUSY
operator||
name|TS_TTSTOP
operator|)
operator|)
condition|)
block|{
name|tp
operator|->
name|t_state
operator||=
name|TS_BUSY
expr_stmt|;
name|rbp
operator|=
operator|&
name|tp
operator|->
name|t_outq
expr_stmt|;
while|while
condition|(
name|rbp
operator|->
name|c_cc
condition|)
block|{
name|len
operator|=
name|q_to_b
argument_list|(
name|rbp
argument_list|,
name|buf
argument_list|,
name|PCBURST
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ansi_put
argument_list|(
name|scp
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
block|}
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
name|ttwwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|scmousestart
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|clist
modifier|*
name|rbp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|u_char
name|buf
index|[
name|PCBURST
index|]
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_TIMEOUT
operator||
name|TS_BUSY
operator||
name|TS_TTSTOP
operator|)
operator|)
condition|)
block|{
name|tp
operator|->
name|t_state
operator||=
name|TS_BUSY
expr_stmt|;
name|rbp
operator|=
operator|&
name|tp
operator|->
name|t_outq
expr_stmt|;
while|while
condition|(
name|rbp
operator|->
name|c_cc
condition|)
block|{
name|q_to_b
argument_list|(
name|rbp
argument_list|,
name|buf
argument_list|,
name|PCBURST
argument_list|)
expr_stmt|;
block|}
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
name|ttwwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sccnprobe
parameter_list|(
name|struct
name|consdev
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|isa_device
modifier|*
name|dvp
decl_stmt|;
comment|/*      * Take control if we are the highest priority enabled display device.      */
name|dvp
operator|=
name|find_display
argument_list|()
expr_stmt|;
if|if
condition|(
name|dvp
operator|==
name|NULL
operator|||
name|dvp
operator|->
name|id_driver
operator|!=
operator|&
name|scdriver
condition|)
block|{
name|cp
operator|->
name|cn_pri
operator|=
name|CN_DEAD
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|scvidprobe
argument_list|(
name|dvp
operator|->
name|id_unit
argument_list|,
name|dvp
operator|->
name|id_flags
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
name|cp
operator|->
name|cn_pri
operator|=
name|CN_DEAD
expr_stmt|;
return|return;
block|}
name|sckbdprobe
argument_list|(
name|dvp
operator|->
name|id_unit
argument_list|,
name|dvp
operator|->
name|id_flags
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* initialize required fields */
name|cp
operator|->
name|cn_dev
operator|=
name|makedev
argument_list|(
name|CDEV_MAJOR
argument_list|,
name|SC_CONSOLE
argument_list|)
expr_stmt|;
name|cp
operator|->
name|cn_pri
operator|=
name|CN_INTERNAL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sccninit
parameter_list|(
name|struct
name|consdev
modifier|*
name|cp
parameter_list|)
block|{
name|scinit
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sccnputc
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|c
parameter_list|)
block|{
name|u_char
name|buf
index|[
literal|1
index|]
decl_stmt|;
name|scr_stat
modifier|*
name|scp
init|=
name|console
index|[
literal|0
index|]
decl_stmt|;
name|term_stat
name|save
init|=
name|scp
operator|->
name|term
decl_stmt|;
name|u_short
modifier|*
name|p
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|scp
operator|==
name|cur_console
operator|&&
name|scp
operator|->
name|status
operator|&
name|SLKED
condition|)
block|{
name|scp
operator|->
name|status
operator|&=
operator|~
name|SLKED
expr_stmt|;
name|update_kbd_state
argument_list|(
name|scp
operator|->
name|status
argument_list|,
name|SLKED
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_console
operator|->
name|status
operator|&
name|BUFFER_SAVED
condition|)
block|{
name|p
operator|=
name|cur_console
operator|->
name|history_save
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cur_console
operator|->
name|ysize
condition|;
operator|++
name|i
control|)
block|{
name|bcopy
argument_list|(
name|p
argument_list|,
name|cur_console
operator|->
name|scr_buf
operator|+
operator|(
name|cur_console
operator|->
name|xsize
operator|*
name|i
operator|)
argument_list|,
name|cur_console
operator|->
name|xsize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
name|cur_console
operator|->
name|xsize
expr_stmt|;
if|if
condition|(
name|p
operator|+
name|cur_console
operator|->
name|xsize
operator|>
name|cur_console
operator|->
name|history
operator|+
name|cur_console
operator|->
name|history_size
condition|)
name|p
operator|=
name|cur_console
operator|->
name|history
expr_stmt|;
block|}
name|cur_console
operator|->
name|status
operator|&=
operator|~
name|BUFFER_SAVED
expr_stmt|;
name|cur_console
operator|->
name|history_head
operator|=
name|cur_console
operator|->
name|history_save
expr_stmt|;
name|cur_console
operator|->
name|status
operator||=
name|CURSOR_ENABLED
expr_stmt|;
name|mark_all
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|1
comment|/* XXX */
name|scstart
argument_list|(
name|VIRTUAL_TTY
argument_list|(
name|get_scr_num
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|scp
operator|->
name|term
operator|=
name|kernel_console
expr_stmt|;
name|current_default
operator|=
operator|&
name|kernel_default
expr_stmt|;
if|if
condition|(
name|scp
operator|==
name|cur_console
operator|&&
operator|!
name|ISGRAPHSC
argument_list|(
name|scp
argument_list|)
condition|)
name|remove_cursor_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|ansi_put
argument_list|(
name|scp
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|kernel_console
operator|=
name|scp
operator|->
name|term
expr_stmt|;
name|current_default
operator|=
operator|&
name|user_default
expr_stmt|;
name|scp
operator|->
name|term
operator|=
name|save
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* block sckbdevent and scrn_timer */
name|sccnupdate
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sccngetc
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
return|return
name|sccngetch
argument_list|(
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sccncheckc
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
return|return
name|sccngetch
argument_list|(
name|SCGETC_NONBLOCK
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sccngetch
parameter_list|(
name|int
name|flags
parameter_list|)
block|{
name|int
name|cur_mode
decl_stmt|;
name|int
name|s
init|=
name|spltty
argument_list|()
decl_stmt|;
comment|/* block sckbdevent and scrn_timer while we poll */
name|int
name|c
decl_stmt|;
comment|/*       * Stop the screen saver and update the screen if necessary.      * What if we have been running in the screen saver code... XXX      */
name|sc_touch_scrn_saver
argument_list|()
expr_stmt|;
name|sccnupdate
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
if|if
condition|(
name|kbd
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/*       * Make sure the keyboard is accessible even when the kbd device      * driver is disabled.      */
name|kbd_enable
argument_list|(
name|kbd
argument_list|)
expr_stmt|;
comment|/* we shall always use the keyboard in the XLATE mode here */
name|cur_mode
operator|=
name|cur_console
operator|->
name|kbd_mode
expr_stmt|;
name|cur_console
operator|->
name|kbd_mode
operator|=
name|K_XLATE
expr_stmt|;
name|kbd_ioctl
argument_list|(
name|kbd
argument_list|,
name|KDSKBMODE
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|cur_console
operator|->
name|kbd_mode
argument_list|)
expr_stmt|;
name|c
operator|=
name|scgetc
argument_list|(
name|kbd
argument_list|,
name|SCGETC_CN
operator||
name|flags
argument_list|)
expr_stmt|;
name|cur_console
operator|->
name|kbd_mode
operator|=
name|cur_mode
expr_stmt|;
name|kbd_ioctl
argument_list|(
name|kbd
argument_list|,
name|KDSKBMODE
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|cur_console
operator|->
name|kbd_mode
argument_list|)
expr_stmt|;
name|kbd_disable
argument_list|(
name|kbd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|KEYFLAGS
argument_list|(
name|c
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* normal char */
return|return
name|KEYCHAR
argument_list|(
name|c
argument_list|)
return|;
case|case
name|FKEY
case|:
comment|/* function key */
return|return
name|c
return|;
comment|/* XXX */
case|case
name|NOKEY
case|:
case|case
name|ERRKEY
case|:
default|default:
return|return
operator|-
literal|1
return|;
block|}
comment|/* NOT REACHED */
block|}
end_function

begin_function
specifier|static
name|void
name|sccnupdate
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
comment|/* this is a cut-down version of scrn_timer()... */
if|if
condition|(
name|font_loading_in_progress
condition|)
return|return;
if|if
condition|(
name|panicstr
operator|||
name|shutdown_in_progress
condition|)
block|{
name|sc_touch_scrn_saver
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scp
operator|!=
name|cur_console
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
name|run_scrn_saver
condition|)
name|scrn_idle
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|saver_mode
operator|!=
name|CONS_LKM_SAVER
operator|)
operator|||
operator|!
name|scrn_idle
condition|)
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|SAVER_RUNNING
condition|)
name|stop_scrn_saver
argument_list|(
name|current_saver
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|!=
name|cur_console
operator|||
name|blink_in_progress
operator|||
name|switch_in_progress
condition|)
return|return;
if|if
condition|(
operator|!
name|ISGRAPHSC
argument_list|(
name|scp
argument_list|)
operator|&&
operator|!
operator|(
name|scp
operator|->
name|status
operator|&
name|SAVER_RUNNING
operator|)
condition|)
name|scrn_update
argument_list|(
name|scp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|scr_stat
modifier|*
name|sc_get_scr_stat
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
name|int
name|unit
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|unit
operator|==
name|SC_CONSOLE
condition|)
return|return
name|console
index|[
literal|0
index|]
return|;
if|if
condition|(
name|unit
operator|>=
name|MAXCONS
operator|||
name|unit
operator|<
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
name|console
index|[
name|unit
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_scr_num
parameter_list|()
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|i
operator|<
name|MAXCONS
operator|)
operator|&&
operator|(
name|cur_console
operator|!=
name|console
index|[
name|i
index|]
operator|)
condition|)
name|i
operator|++
expr_stmt|;
return|return
name|i
operator|<
name|MAXCONS
condition|?
name|i
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|scrn_timer
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
specifier|static
name|int
name|kbd_interval
init|=
literal|0
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|scr_stat
modifier|*
name|scp
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* don't do anything when we are touching font */
if|if
condition|(
name|font_loading_in_progress
condition|)
block|{
if|if
condition|(
name|arg
condition|)
name|timeout
argument_list|(
name|scrn_timer
argument_list|,
operator|(
name|void
operator|*
operator|)
name|TRUE
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
return|return;
block|}
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|kbd
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|sc_flags
operator|&
name|AUTODETECT_KBD
operator|)
condition|)
block|{
comment|/* try to allocate a keyboard automatically */
if|if
condition|(
operator|++
name|kbd_interval
operator|>=
literal|25
condition|)
block|{
name|keyboard
operator|=
name|kbd_allocate
argument_list|(
literal|"*"
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|keyboard
argument_list|,
name|sckbdevent
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyboard
operator|>=
literal|0
condition|)
block|{
name|kbd
operator|=
name|kbd_get_keyboard
argument_list|(
name|keyboard
argument_list|)
expr_stmt|;
name|kbd_ioctl
argument_list|(
name|kbd
argument_list|,
name|KDSKBMODE
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|cur_console
operator|->
name|kbd_mode
argument_list|)
expr_stmt|;
name|update_kbd_state
argument_list|(
name|cur_console
operator|->
name|status
argument_list|,
name|LOCK_MASK
argument_list|)
expr_stmt|;
block|}
name|kbd_interval
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|scp
operator|=
name|cur_console
expr_stmt|;
comment|/* should we stop the screen saver? */
name|getmicrouptime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
if|if
condition|(
name|panicstr
operator|||
name|shutdown_in_progress
condition|)
name|sc_touch_scrn_saver
argument_list|()
expr_stmt|;
if|if
condition|(
name|run_scrn_saver
condition|)
block|{
name|scrn_idle
operator|=
operator|(
name|tv
operator|.
name|tv_sec
operator|>
name|scrn_time_stamp
operator|+
name|scrn_blank_time
operator|)
expr_stmt|;
block|}
else|else
block|{
name|scrn_time_stamp
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
name|scrn_idle
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|scrn_blank_time
operator|>
literal|0
condition|)
name|run_scrn_saver
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|saver_mode
operator|!=
name|CONS_LKM_SAVER
operator|)
operator|||
operator|!
name|scrn_idle
condition|)
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|SAVER_RUNNING
condition|)
name|stop_scrn_saver
argument_list|(
name|current_saver
argument_list|)
expr_stmt|;
comment|/* should we just return ? */
if|if
condition|(
name|blink_in_progress
operator|||
name|switch_in_progress
condition|)
block|{
if|if
condition|(
name|arg
condition|)
name|timeout
argument_list|(
name|scrn_timer
argument_list|,
operator|(
name|void
operator|*
operator|)
name|TRUE
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Update the screen */
if|if
condition|(
operator|!
name|ISGRAPHSC
argument_list|(
name|scp
argument_list|)
operator|&&
operator|!
operator|(
name|scp
operator|->
name|status
operator|&
name|SAVER_RUNNING
operator|)
condition|)
name|scrn_update
argument_list|(
name|scp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* should we activate the screen saver? */
if|if
condition|(
operator|(
name|saver_mode
operator|==
name|CONS_LKM_SAVER
operator|)
operator|&&
name|scrn_idle
condition|)
if|if
condition|(
operator|!
name|ISGRAPHSC
argument_list|(
name|scp
argument_list|)
operator|||
operator|(
name|scp
operator|->
name|status
operator|&
name|SAVER_RUNNING
operator|)
condition|)
call|(
modifier|*
name|current_saver
call|)
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
condition|)
name|timeout
argument_list|(
name|scrn_timer
argument_list|,
operator|(
name|void
operator|*
operator|)
name|TRUE
argument_list|,
name|hz
operator|/
literal|25
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|scrn_update
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|show_cursor
parameter_list|)
block|{
comment|/* update screen image */
if|if
condition|(
name|scp
operator|->
name|start
operator|<=
name|scp
operator|->
name|end
condition|)
name|sc_bcopy
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|start
argument_list|,
name|scp
operator|->
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* we are not to show the cursor and the mouse pointer... */
if|if
condition|(
operator|!
name|show_cursor
condition|)
block|{
name|scp
operator|->
name|end
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|start
operator|=
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
operator|-
literal|1
expr_stmt|;
return|return;
block|}
comment|/* update "pseudo" mouse pointer image */
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_VISIBLE
condition|)
block|{
comment|/* did mouse move since last time ? */
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_MOVED
condition|)
block|{
comment|/* do we need to remove old mouse pointer image ? */
if|if
condition|(
name|scp
operator|->
name|mouse_cut_start
operator|!=
name|NULL
operator|||
operator|(
name|scp
operator|->
name|mouse_pos
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|<=
name|scp
operator|->
name|start
operator|||
operator|(
name|scp
operator|->
name|mouse_pos
operator|+
name|scp
operator|->
name|xsize
operator|+
literal|1
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|>=
name|scp
operator|->
name|end
condition|)
block|{
name|remove_mouse_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
name|scp
operator|->
name|status
operator|&=
operator|~
name|MOUSE_MOVED
expr_stmt|;
name|draw_mouse_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* mouse didn't move, has it been overwritten ? */
if|if
condition|(
operator|(
name|scp
operator|->
name|mouse_pos
operator|+
name|scp
operator|->
name|xsize
operator|+
literal|1
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|>=
name|scp
operator|->
name|start
operator|&&
operator|(
name|scp
operator|->
name|mouse_pos
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|<=
name|scp
operator|->
name|end
condition|)
block|{
name|draw_mouse_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* update cursor image */
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|CURSOR_ENABLED
condition|)
block|{
comment|/* did cursor move since last time ? */
if|if
condition|(
name|scp
operator|->
name|cursor_pos
operator|!=
name|scp
operator|->
name|cursor_oldpos
condition|)
block|{
comment|/* do we need to remove old cursor image ? */
if|if
condition|(
operator|(
name|scp
operator|->
name|cursor_oldpos
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|<
name|scp
operator|->
name|start
operator|||
operator|(
operator|(
name|scp
operator|->
name|cursor_oldpos
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|>
name|scp
operator|->
name|end
operator|)
condition|)
block|{
name|remove_cursor_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
name|scp
operator|->
name|cursor_oldpos
operator|=
name|scp
operator|->
name|cursor_pos
expr_stmt|;
name|draw_cursor_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* cursor didn't move, has it been overwritten ? */
if|if
condition|(
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
operator|>=
name|scp
operator|->
name|start
operator|&&
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
operator|<=
name|scp
operator|->
name|end
condition|)
block|{
name|draw_cursor_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* if its a blinking cursor, we may have to update it */
if|if
condition|(
name|sc_flags
operator|&
name|BLINK_CURSOR
condition|)
name|draw_cursor_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
block|}
name|blinkrate
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|scp
operator|->
name|mouse_cut_start
operator|!=
name|NULL
condition|)
name|draw_cutmarking
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|scp
operator|->
name|end
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|start
operator|=
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|NSPLASH
operator|>
literal|0
end_if

begin_function
specifier|static
name|int
name|scsplash_callback
parameter_list|(
name|int
name|event
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|SPLASH_INIT
case|:
if|if
condition|(
name|add_scrn_saver
argument_list|(
name|scsplash_saver
argument_list|)
operator|==
literal|0
condition|)
block|{
name|run_scrn_saver
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|cold
operator|&&
operator|!
operator|(
name|boothowto
operator|&
operator|(
name|RB_VERBOSE
operator||
name|RB_CONFIG
operator|)
operator|)
condition|)
block|{
name|scsplash_stick
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
call|(
modifier|*
name|current_saver
call|)
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
case|case
name|SPLASH_TERM
case|:
if|if
condition|(
name|current_saver
operator|==
name|scsplash_saver
condition|)
block|{
name|scsplash_stick
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|error
operator|=
name|remove_scrn_saver
argument_list|(
name|scsplash_saver
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
return|return
literal|0
return|;
default|default:
return|return
name|EINVAL
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|scsplash_saver
parameter_list|(
name|int
name|show
parameter_list|)
block|{
specifier|static
name|int
name|busy
init|=
name|FALSE
decl_stmt|;
specifier|static
name|int
name|failed
init|=
name|FALSE
decl_stmt|;
name|scr_stat
modifier|*
name|scp
decl_stmt|;
if|if
condition|(
name|busy
condition|)
return|return;
name|busy
operator|=
name|TRUE
expr_stmt|;
name|scp
operator|=
name|cur_console
expr_stmt|;
if|if
condition|(
name|show
condition|)
block|{
if|if
condition|(
operator|!
name|failed
condition|)
block|{
if|if
condition|(
operator|!
name|scrn_blanked
condition|)
name|set_scrn_saver_mode
argument_list|(
name|scp
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|splash
argument_list|(
name|scp
operator|->
name|adp
argument_list|,
name|TRUE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|scrn_blanked
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|failed
operator|=
name|TRUE
expr_stmt|;
name|scsplash_stick
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"scsplash_saver(): failed to put up the image\n"
argument_list|)
expr_stmt|;
name|restore_scrn_saver_mode
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|sticky_splash
condition|)
block|{
if|if
condition|(
name|scrn_blanked
operator|&&
operator|(
name|splash
argument_list|(
name|scp
operator|->
name|adp
argument_list|,
name|FALSE
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|restore_scrn_saver_mode
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|scrn_blanked
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
name|busy
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|add_scrn_saver
parameter_list|(
name|void
function_decl|(
modifier|*
name|this_saver
function_decl|)
parameter_list|(
name|int
parameter_list|)
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|current_saver
operator|!=
name|none_saver
condition|)
block|{
name|error
operator|=
name|remove_scrn_saver
argument_list|(
name|current_saver
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
name|run_scrn_saver
operator|=
name|FALSE
expr_stmt|;
name|saver_mode
operator|=
name|CONS_LKM_SAVER
expr_stmt|;
name|current_saver
operator|=
name|this_saver
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|remove_scrn_saver
parameter_list|(
name|void
function_decl|(
modifier|*
name|this_saver
function_decl|)
parameter_list|(
name|int
parameter_list|)
parameter_list|)
block|{
if|if
condition|(
name|current_saver
operator|!=
name|this_saver
condition|)
return|return
name|EINVAL
return|;
comment|/*      * In order to prevent `current_saver' from being called by      * the timeout routine `scrn_timer()' while we manipulate       * the saver list, we shall set `current_saver' to `none_saver'       * before stopping the current saver, rather than blocking by `splXX()'.      */
name|current_saver
operator|=
name|none_saver
expr_stmt|;
if|if
condition|(
name|scrn_blanked
condition|)
name|stop_scrn_saver
argument_list|(
name|this_saver
argument_list|)
expr_stmt|;
return|return
operator|(
name|scrn_blanked
condition|?
name|EBUSY
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_scrn_saver_mode
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|mode
parameter_list|,
name|u_char
modifier|*
name|pal
parameter_list|,
name|int
name|border
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
comment|/* assert(scp == cur_console) */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|scp
operator|->
name|splash_save_mode
operator|=
name|scp
operator|->
name|mode
expr_stmt|;
name|scp
operator|->
name|splash_save_status
operator|=
name|scp
operator|->
name|status
operator|&
operator|(
name|GRAPHICS_MODE
operator||
name|PIXEL_MODE
operator|)
expr_stmt|;
name|scp
operator|->
name|status
operator|&=
operator|~
name|PIXEL_MODE
expr_stmt|;
name|scp
operator|->
name|status
operator||=
operator|(
name|UNKNOWN_MODE
operator||
name|SAVER_RUNNING
operator|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|scp
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|set_mode
argument_list|(
name|scp
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|scp
operator|->
name|adp
operator|->
name|va_mode_flags
operator|&
name|V_INFO_GRAPHICS
condition|)
name|scp
operator|->
name|status
operator||=
name|GRAPHICS_MODE
expr_stmt|;
if|if
condition|(
name|pal
operator|!=
name|NULL
condition|)
name|load_palette
argument_list|(
name|scp
operator|->
name|adp
argument_list|,
name|pal
argument_list|)
expr_stmt|;
name|set_border
argument_list|(
name|scp
argument_list|,
name|border
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|scp
operator|->
name|mode
operator|=
name|scp
operator|->
name|splash_save_mode
expr_stmt|;
name|scp
operator|->
name|status
operator|&=
operator|~
operator|(
name|UNKNOWN_MODE
operator||
name|SAVER_RUNNING
operator|)
expr_stmt|;
name|scp
operator|->
name|status
operator||=
name|scp
operator|->
name|splash_save_status
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|restore_scrn_saver_mode
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|int
name|mode
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* assert(scp == cur_console) */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|mode
operator|=
name|scp
operator|->
name|mode
expr_stmt|;
name|status
operator|=
name|scp
operator|->
name|status
expr_stmt|;
name|scp
operator|->
name|mode
operator|=
name|scp
operator|->
name|splash_save_mode
expr_stmt|;
name|scp
operator|->
name|status
operator|&=
operator|~
operator|(
name|UNKNOWN_MODE
operator||
name|GRAPHICS_MODE
operator||
name|SAVER_RUNNING
operator|)
expr_stmt|;
name|scp
operator|->
name|status
operator||=
name|scp
operator|->
name|splash_save_status
expr_stmt|;
if|if
condition|(
name|set_mode
argument_list|(
name|scp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|load_palette
argument_list|(
name|scp
operator|->
name|adp
argument_list|,
name|palette
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|scp
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
name|scp
operator|->
name|status
operator|=
name|status
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|stop_scrn_saver
parameter_list|(
name|void
function_decl|(
modifier|*
name|saver
function_decl|)
parameter_list|(
name|int
parameter_list|)
parameter_list|)
block|{
call|(
modifier|*
name|saver
call|)
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|run_scrn_saver
operator|=
name|FALSE
expr_stmt|;
comment|/* the screen saver may have chosen not to stop after all... */
if|if
condition|(
name|scrn_blanked
condition|)
return|return;
name|mark_all
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
if|if
condition|(
name|delayed_next_scr
condition|)
name|switch_scr
argument_list|(
name|cur_console
argument_list|,
name|delayed_next_scr
operator|-
literal|1
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|scrn_blanked
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|wait_scrn_saver_stop
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|scrn_blanked
condition|)
block|{
name|run_scrn_saver
operator|=
name|FALSE
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|scrn_blanked
argument_list|,
name|PZERO
operator||
name|PCATCH
argument_list|,
literal|"scrsav"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|run_scrn_saver
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ERESTART
condition|)
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NSPLASH */
end_comment

begin_function
name|void
name|sc_touch_scrn_saver
parameter_list|(
name|void
parameter_list|)
block|{
name|scsplash_stick
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|run_scrn_saver
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sc_clear_screen
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|move_crsr
argument_list|(
name|scp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|scp
operator|->
name|cursor_oldpos
operator|=
name|scp
operator|->
name|cursor_pos
expr_stmt|;
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
argument_list|)
expr_stmt|;
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|remove_cutmarking
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|switch_scr
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|u_int
name|next_scr
parameter_list|)
block|{
comment|/* delay switch if actively updating screen */
if|if
condition|(
name|scrn_blanked
operator|||
name|write_in_progress
operator|||
name|blink_in_progress
condition|)
block|{
name|sc_touch_scrn_saver
argument_list|()
expr_stmt|;
name|delayed_next_scr
operator|=
name|next_scr
operator|+
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|switch_in_progress
operator|&&
operator|(
name|cur_console
operator|->
name|proc
operator|!=
name|pfind
argument_list|(
name|cur_console
operator|->
name|pid
argument_list|)
operator|)
condition|)
name|switch_in_progress
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|next_scr
operator|>=
name|MAXCONS
operator|||
name|switch_in_progress
operator|||
operator|(
name|cur_console
operator|->
name|smode
operator|.
name|mode
operator|==
name|VT_AUTO
operator|&&
name|ISGRAPHSC
argument_list|(
name|cur_console
argument_list|)
operator|)
condition|)
block|{
name|do_bell
argument_list|(
name|scp
argument_list|,
name|BELL_PITCH
argument_list|,
name|BELL_DURATION
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/* is the wanted virtual console open ? */
if|if
condition|(
name|next_scr
condition|)
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
name|VIRTUAL_TTY
argument_list|(
name|next_scr
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
condition|)
block|{
name|do_bell
argument_list|(
name|scp
argument_list|,
name|BELL_PITCH
argument_list|,
name|BELL_DURATION
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
block|}
name|switch_in_progress
operator|=
name|TRUE
expr_stmt|;
name|old_scp
operator|=
name|cur_console
expr_stmt|;
name|new_scp
operator|=
name|console
index|[
name|next_scr
index|]
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|new_scp
operator|->
name|smode
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_scp
operator|==
name|old_scp
condition|)
block|{
name|switch_in_progress
operator|=
name|FALSE
expr_stmt|;
name|delayed_next_scr
operator|=
name|FALSE
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* has controlling process died? */
if|if
condition|(
name|old_scp
operator|->
name|proc
operator|&&
operator|(
name|old_scp
operator|->
name|proc
operator|!=
name|pfind
argument_list|(
name|old_scp
operator|->
name|pid
argument_list|)
operator|)
condition|)
name|old_scp
operator|->
name|smode
operator|.
name|mode
operator|=
name|VT_AUTO
expr_stmt|;
if|if
condition|(
name|new_scp
operator|->
name|proc
operator|&&
operator|(
name|new_scp
operator|->
name|proc
operator|!=
name|pfind
argument_list|(
name|new_scp
operator|->
name|pid
argument_list|)
operator|)
condition|)
name|new_scp
operator|->
name|smode
operator|.
name|mode
operator|=
name|VT_AUTO
expr_stmt|;
comment|/* check the modes and switch appropriately */
if|if
condition|(
name|old_scp
operator|->
name|smode
operator|.
name|mode
operator|==
name|VT_PROCESS
condition|)
block|{
name|old_scp
operator|->
name|status
operator||=
name|SWITCH_WAIT_REL
expr_stmt|;
name|psignal
argument_list|(
name|old_scp
operator|->
name|proc
argument_list|,
name|old_scp
operator|->
name|smode
operator|.
name|relsig
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|exchange_scr
argument_list|()
expr_stmt|;
if|if
condition|(
name|new_scp
operator|->
name|smode
operator|.
name|mode
operator|==
name|VT_PROCESS
condition|)
block|{
name|new_scp
operator|->
name|status
operator||=
name|SWITCH_WAIT_ACQ
expr_stmt|;
name|psignal
argument_list|(
name|new_scp
operator|->
name|proc
argument_list|,
name|new_scp
operator|->
name|smode
operator|.
name|acqsig
argument_list|)
expr_stmt|;
block|}
else|else
name|switch_in_progress
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|exchange_scr
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* save the current state of video and keyboard */
name|move_crsr
argument_list|(
name|old_scp
argument_list|,
name|old_scp
operator|->
name|xpos
argument_list|,
name|old_scp
operator|->
name|ypos
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_scp
operator|->
name|kbd_mode
operator|==
name|K_XLATE
condition|)
name|save_kbd_state
argument_list|(
name|old_scp
argument_list|)
expr_stmt|;
comment|/* set up the video for the new screen */
name|cur_console
operator|=
name|new_scp
expr_stmt|;
if|if
condition|(
name|old_scp
operator|->
name|mode
operator|!=
name|new_scp
operator|->
name|mode
operator|||
name|ISUNKNOWNSC
argument_list|(
name|old_scp
argument_list|)
condition|)
name|set_mode
argument_list|(
name|new_scp
argument_list|)
expr_stmt|;
name|move_crsr
argument_list|(
name|new_scp
argument_list|,
name|new_scp
operator|->
name|xpos
argument_list|,
name|new_scp
operator|->
name|ypos
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISTEXTSC
argument_list|(
name|new_scp
argument_list|)
operator|&&
operator|(
name|sc_flags
operator|&
name|CHAR_CURSOR
operator|)
condition|)
name|set_destructive_cursor
argument_list|(
name|new_scp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISGRAPHSC
argument_list|(
name|old_scp
argument_list|)
condition|)
name|load_palette
argument_list|(
name|new_scp
operator|->
name|adp
argument_list|,
name|palette
argument_list|)
expr_stmt|;
name|set_border
argument_list|(
name|new_scp
argument_list|,
name|new_scp
operator|->
name|border
argument_list|)
expr_stmt|;
comment|/* set up the keyboard for the new screen */
if|if
condition|(
name|old_scp
operator|->
name|kbd_mode
operator|!=
name|new_scp
operator|->
name|kbd_mode
condition|)
name|kbd_ioctl
argument_list|(
name|kbd
argument_list|,
name|KDSKBMODE
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|new_scp
operator|->
name|kbd_mode
argument_list|)
expr_stmt|;
name|update_kbd_state
argument_list|(
name|new_scp
operator|->
name|status
argument_list|,
name|LOCK_MASK
argument_list|)
expr_stmt|;
name|delayed_next_scr
operator|=
name|FALSE
expr_stmt|;
name|mark_all
argument_list|(
name|new_scp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|scan_esc
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|u_char
name|c
parameter_list|)
block|{
specifier|static
name|u_char
name|ansi_col
index|[
literal|16
index|]
init|=
block|{
literal|0
block|,
literal|4
block|,
literal|2
block|,
literal|6
block|,
literal|1
block|,
literal|5
block|,
literal|3
block|,
literal|7
block|,
literal|8
block|,
literal|12
block|,
literal|10
block|,
literal|14
block|,
literal|9
block|,
literal|13
block|,
literal|11
block|,
literal|15
block|}
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|u_short
modifier|*
name|src
decl_stmt|,
modifier|*
name|dst
decl_stmt|,
name|count
decl_stmt|;
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|esc
operator|==
literal|1
condition|)
block|{
comment|/* seen ESC */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'7'
case|:
comment|/* Save cursor position */
name|scp
operator|->
name|saved_xpos
operator|=
name|scp
operator|->
name|xpos
expr_stmt|;
name|scp
operator|->
name|saved_ypos
operator|=
name|scp
operator|->
name|ypos
expr_stmt|;
break|break;
case|case
literal|'8'
case|:
comment|/* Restore saved cursor position */
if|if
condition|(
name|scp
operator|->
name|saved_xpos
operator|>=
literal|0
operator|&&
name|scp
operator|->
name|saved_ypos
operator|>=
literal|0
condition|)
name|move_crsr
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|saved_xpos
argument_list|,
name|scp
operator|->
name|saved_ypos
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'['
case|:
comment|/* Start ESC [ sequence */
name|scp
operator|->
name|term
operator|.
name|esc
operator|=
literal|2
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|last_param
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|scp
operator|->
name|term
operator|.
name|num_param
init|;
name|i
operator|<
name|MAX_ESC_PAR
condition|;
name|i
operator|++
control|)
name|scp
operator|->
name|term
operator|.
name|param
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|num_param
operator|=
literal|0
expr_stmt|;
return|return;
case|case
literal|'M'
case|:
comment|/* Move cursor up 1 line, scroll if at top */
if|if
condition|(
name|scp
operator|->
name|ypos
operator|>
literal|0
condition|)
name|move_crsr
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|xpos
argument_list|,
name|scp
operator|->
name|ypos
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|bcopy
argument_list|(
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|scr_buf
operator|+
name|scp
operator|->
name|xsize
argument_list|,
operator|(
name|scp
operator|->
name|ysize
operator|-
literal|1
operator|)
operator|*
name|scp
operator|->
name|xsize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
break|break;
if|#
directive|if
name|notyet
case|case
literal|'Q'
case|:
name|scp
operator|->
name|term
operator|.
name|esc
operator|=
literal|4
expr_stmt|;
return|return;
endif|#
directive|endif
case|case
literal|'c'
case|:
comment|/* Clear screen& home */
name|sc_clear_screen
argument_list|(
name|scp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'('
case|:
comment|/* iso-2022: designate 94 character set to G0 */
name|scp
operator|->
name|term
operator|.
name|esc
operator|=
literal|5
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|esc
operator|==
literal|2
condition|)
block|{
comment|/* seen ESC [ */
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|<
name|MAX_ESC_PAR
condition|)
block|{
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|last_param
operator|!=
name|scp
operator|->
name|term
operator|.
name|num_param
condition|)
block|{
name|scp
operator|->
name|term
operator|.
name|last_param
operator|=
name|scp
operator|->
name|term
operator|.
name|num_param
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|param
index|[
name|scp
operator|->
name|term
operator|.
name|num_param
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|scp
operator|->
name|term
operator|.
name|param
index|[
name|scp
operator|->
name|term
operator|.
name|num_param
index|]
operator|*=
literal|10
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|param
index|[
name|scp
operator|->
name|term
operator|.
name|num_param
index|]
operator|+=
name|c
operator|-
literal|'0'
expr_stmt|;
return|return;
block|}
block|}
name|scp
operator|->
name|term
operator|.
name|num_param
operator|=
name|scp
operator|->
name|term
operator|.
name|last_param
operator|+
literal|1
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|';'
case|:
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|<
name|MAX_ESC_PAR
condition|)
return|return;
break|break;
case|case
literal|'='
case|:
name|scp
operator|->
name|term
operator|.
name|esc
operator|=
literal|3
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|last_param
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|scp
operator|->
name|term
operator|.
name|num_param
init|;
name|i
operator|<
name|MAX_ESC_PAR
condition|;
name|i
operator|++
control|)
name|scp
operator|->
name|term
operator|.
name|param
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|num_param
operator|=
literal|0
expr_stmt|;
return|return;
case|case
literal|'A'
case|:
comment|/* up n rows */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|move_crsr
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|xpos
argument_list|,
name|scp
operator|->
name|ypos
operator|-
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
comment|/* down n rows */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|move_crsr
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|xpos
argument_list|,
name|scp
operator|->
name|ypos
operator|+
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* right n columns */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|move_crsr
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|xpos
operator|+
name|n
argument_list|,
name|scp
operator|->
name|ypos
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* left n columns */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|move_crsr
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|xpos
operator|-
name|n
argument_list|,
name|scp
operator|->
name|ypos
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
comment|/* cursor to start of line n lines down */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|move_crsr
argument_list|(
name|scp
argument_list|,
literal|0
argument_list|,
name|scp
operator|->
name|ypos
operator|+
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
comment|/* cursor to start of line n lines up */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|move_crsr
argument_list|(
name|scp
argument_list|,
literal|0
argument_list|,
name|scp
operator|->
name|ypos
operator|-
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* Cursor move */
case|case
literal|'H'
case|:
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|0
condition|)
name|move_crsr
argument_list|(
name|scp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|2
condition|)
name|move_crsr
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|1
index|]
operator|-
literal|1
argument_list|,
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'J'
case|:
comment|/* Clear all or part of display */
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|0
condition|)
name|n
operator|=
literal|0
expr_stmt|;
else|else
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|0
case|:
comment|/* clear form cursor to end of display */
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|cursor_pos
argument_list|,
name|scp
operator|->
name|scr_buf
operator|+
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
operator|-
name|scp
operator|->
name|cursor_pos
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
operator|-
literal|1
argument_list|)
expr_stmt|;
name|remove_cutmarking
argument_list|(
name|scp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* clear from beginning of display to cursor */
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|remove_cutmarking
argument_list|(
name|scp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* clear entire display */
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
argument_list|)
expr_stmt|;
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|remove_cutmarking
argument_list|(
name|scp
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'K'
case|:
comment|/* Clear all or part of line */
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|0
condition|)
name|n
operator|=
literal|0
expr_stmt|;
else|else
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|0
case|:
comment|/* clear form cursor to end of line */
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|cursor_pos
argument_list|,
name|scp
operator|->
name|xsize
operator|-
name|scp
operator|->
name|xpos
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
operator|+
name|scp
operator|->
name|xsize
operator|-
literal|1
operator|-
name|scp
operator|->
name|xpos
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* clear from beginning of line to cursor */
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|xpos
argument_list|,
name|scp
operator|->
name|xpos
operator|+
literal|1
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|ypos
operator|*
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* clear entire line */
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|xpos
argument_list|,
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|ypos
operator|*
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
operator|(
name|scp
operator|->
name|ypos
operator|+
literal|1
operator|)
operator|*
name|scp
operator|->
name|xsize
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'L'
case|:
comment|/* Insert n lines */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|scp
operator|->
name|ysize
operator|-
name|scp
operator|->
name|ypos
condition|)
name|n
operator|=
name|scp
operator|->
name|ysize
operator|-
name|scp
operator|->
name|ypos
expr_stmt|;
name|src
operator|=
name|scp
operator|->
name|scr_buf
operator|+
name|scp
operator|->
name|ypos
operator|*
name|scp
operator|->
name|xsize
expr_stmt|;
name|dst
operator|=
name|src
operator|+
name|n
operator|*
name|scp
operator|->
name|xsize
expr_stmt|;
name|count
operator|=
name|scp
operator|->
name|ysize
operator|-
operator|(
name|scp
operator|->
name|ypos
operator|+
name|n
operator|)
expr_stmt|;
name|bcopy
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|count
operator|*
name|scp
operator|->
name|xsize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|src
argument_list|,
name|n
operator|*
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|ypos
operator|*
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
comment|/* Delete n lines */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|scp
operator|->
name|ysize
operator|-
name|scp
operator|->
name|ypos
condition|)
name|n
operator|=
name|scp
operator|->
name|ysize
operator|-
name|scp
operator|->
name|ypos
expr_stmt|;
name|dst
operator|=
name|scp
operator|->
name|scr_buf
operator|+
name|scp
operator|->
name|ypos
operator|*
name|scp
operator|->
name|xsize
expr_stmt|;
name|src
operator|=
name|dst
operator|+
name|n
operator|*
name|scp
operator|->
name|xsize
expr_stmt|;
name|count
operator|=
name|scp
operator|->
name|ysize
operator|-
operator|(
name|scp
operator|->
name|ypos
operator|+
name|n
operator|)
expr_stmt|;
name|bcopy
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|count
operator|*
name|scp
operator|->
name|xsize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|=
name|dst
operator|+
name|count
operator|*
name|scp
operator|->
name|xsize
expr_stmt|;
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|src
argument_list|,
name|n
operator|*
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|ypos
operator|*
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
comment|/* Delete n chars */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|scp
operator|->
name|xsize
operator|-
name|scp
operator|->
name|xpos
condition|)
name|n
operator|=
name|scp
operator|->
name|xsize
operator|-
name|scp
operator|->
name|xpos
expr_stmt|;
name|dst
operator|=
name|scp
operator|->
name|cursor_pos
expr_stmt|;
name|src
operator|=
name|dst
operator|+
name|n
expr_stmt|;
name|count
operator|=
name|scp
operator|->
name|xsize
operator|-
operator|(
name|scp
operator|->
name|xpos
operator|+
name|n
operator|)
expr_stmt|;
name|bcopy
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|=
name|dst
operator|+
name|count
expr_stmt|;
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|src
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
operator|+
name|n
operator|+
name|count
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'@'
case|:
comment|/* Insert n chars */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|scp
operator|->
name|xsize
operator|-
name|scp
operator|->
name|xpos
condition|)
name|n
operator|=
name|scp
operator|->
name|xsize
operator|-
name|scp
operator|->
name|xpos
expr_stmt|;
name|src
operator|=
name|scp
operator|->
name|cursor_pos
expr_stmt|;
name|dst
operator|=
name|src
operator|+
name|n
expr_stmt|;
name|count
operator|=
name|scp
operator|->
name|xsize
operator|-
operator|(
name|scp
operator|->
name|xpos
operator|+
name|n
operator|)
expr_stmt|;
name|bcopy
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|src
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
operator|+
name|n
operator|+
name|count
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* scroll up n lines */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|scp
operator|->
name|ysize
condition|)
name|n
operator|=
name|scp
operator|->
name|ysize
expr_stmt|;
name|bcopy
argument_list|(
name|scp
operator|->
name|scr_buf
operator|+
operator|(
name|scp
operator|->
name|xsize
operator|*
name|n
operator|)
argument_list|,
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|xsize
operator|*
operator|(
name|scp
operator|->
name|ysize
operator|-
name|n
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|scr_buf
operator|+
name|scp
operator|->
name|xsize
operator|*
operator|(
name|scp
operator|->
name|ysize
operator|-
name|n
operator|)
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|n
argument_list|)
expr_stmt|;
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
comment|/* scroll down n lines */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|scp
operator|->
name|ysize
condition|)
name|n
operator|=
name|scp
operator|->
name|ysize
expr_stmt|;
name|bcopy
argument_list|(
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|scr_buf
operator|+
operator|(
name|scp
operator|->
name|xsize
operator|*
name|n
operator|)
argument_list|,
name|scp
operator|->
name|xsize
operator|*
operator|(
name|scp
operator|->
name|ysize
operator|-
name|n
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|n
argument_list|)
expr_stmt|;
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
comment|/* erase n characters in line */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|scp
operator|->
name|xsize
operator|-
name|scp
operator|->
name|xpos
condition|)
name|n
operator|=
name|scp
operator|->
name|xsize
operator|-
name|scp
operator|->
name|xpos
expr_stmt|;
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|cursor_pos
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
operator|+
name|n
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
comment|/* move n tabs backwards */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|scp
operator|->
name|xpos
operator|&
literal|0xf8
operator|)
operator|==
name|scp
operator|->
name|xpos
condition|)
name|i
operator|-=
literal|8
operator|*
name|n
expr_stmt|;
else|else
name|i
operator|-=
literal|8
operator|*
operator|(
name|n
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|i
operator|=
literal|0
expr_stmt|;
name|move_crsr
argument_list|(
name|scp
argument_list|,
name|i
argument_list|,
name|scp
operator|->
name|ypos
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'`'
case|:
comment|/* move cursor to column n */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|move_crsr
argument_list|(
name|scp
argument_list|,
name|n
operator|-
literal|1
argument_list|,
name|scp
operator|->
name|ypos
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
comment|/* move cursor n columns to the right */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|move_crsr
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|xpos
operator|+
name|n
argument_list|,
name|scp
operator|->
name|ypos
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* move cursor to row n */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|move_crsr
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|xpos
argument_list|,
name|n
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* move cursor n rows down */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|move_crsr
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|xpos
argument_list|,
name|scp
operator|->
name|ypos
operator|+
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* change attribute */
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|0
condition|)
block|{
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator|=
name|NORMAL_ATTR
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|scp
operator|->
name|term
operator|.
name|cur_color
operator|=
name|scp
operator|->
name|term
operator|.
name|std_color
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|scp
operator|->
name|term
operator|.
name|num_param
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
name|i
index|]
condition|)
block|{
case|case
literal|0
case|:
comment|/* back to normal */
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator|=
name|NORMAL_ATTR
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|scp
operator|->
name|term
operator|.
name|cur_color
operator|=
name|scp
operator|->
name|term
operator|.
name|std_color
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* bold */
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator||=
name|BOLD_ATTR
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* underline */
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator||=
name|UNDERLINE_ATTR
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* blink */
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator||=
name|BLINK_ATTR
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|/* reverse video */
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator||=
name|REVERSE_ATTR
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
break|break;
case|case
literal|30
case|:
case|case
literal|31
case|:
comment|/* set fg color */
case|case
literal|32
case|:
case|case
literal|33
case|:
case|case
literal|34
case|:
case|case
literal|35
case|:
case|case
literal|36
case|:
case|case
literal|37
case|:
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator||=
name|FOREGROUND_CHANGED
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_color
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator|&
literal|0xF000
operator|)
operator||
operator|(
name|ansi_col
index|[
operator|(
name|n
operator|-
literal|30
operator|)
operator|&
literal|7
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
break|break;
case|case
literal|40
case|:
case|case
literal|41
case|:
comment|/* set bg color */
case|case
literal|42
case|:
case|case
literal|43
case|:
case|case
literal|44
case|:
case|case
literal|45
case|:
case|case
literal|46
case|:
case|case
literal|47
case|:
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator||=
name|BACKGROUND_CHANGED
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_color
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator|&
literal|0x0F00
operator|)
operator||
operator|(
name|ansi_col
index|[
operator|(
name|n
operator|-
literal|40
operator|)
operator|&
literal|7
index|]
operator|<<
literal|12
operator|)
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
literal|'s'
case|:
comment|/* Save cursor position */
name|scp
operator|->
name|saved_xpos
operator|=
name|scp
operator|->
name|xpos
expr_stmt|;
name|scp
operator|->
name|saved_ypos
operator|=
name|scp
operator|->
name|ypos
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
comment|/* Restore saved cursor position */
if|if
condition|(
name|scp
operator|->
name|saved_xpos
operator|>=
literal|0
operator|&&
name|scp
operator|->
name|saved_ypos
operator|>=
literal|0
condition|)
name|move_crsr
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|saved_xpos
argument_list|,
name|scp
operator|->
name|saved_ypos
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|0
condition|)
name|n
operator|=
literal|0
expr_stmt|;
else|else
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|0
case|:
comment|/* reset attributes */
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator|=
name|NORMAL_ATTR
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|scp
operator|->
name|term
operator|.
name|cur_color
operator|=
name|scp
operator|->
name|term
operator|.
name|std_color
operator|=
name|current_default
operator|->
name|std_color
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|rev_color
operator|=
name|current_default
operator|->
name|rev_color
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* set ansi background */
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator|&=
operator|~
name|BACKGROUND_CHANGED
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_color
operator|=
name|scp
operator|->
name|term
operator|.
name|std_color
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|std_color
operator|&
literal|0x0F00
operator|)
operator||
operator|(
name|ansi_col
index|[
operator|(
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|1
index|]
operator|)
operator|&
literal|0x0F
index|]
operator|<<
literal|12
operator|)
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* set ansi foreground */
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator|&=
operator|~
name|FOREGROUND_CHANGED
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_color
operator|=
name|scp
operator|->
name|term
operator|.
name|std_color
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|std_color
operator|&
literal|0xF000
operator|)
operator||
operator|(
name|ansi_col
index|[
operator|(
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|1
index|]
operator|)
operator|&
literal|0x0F
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* set ansi attribute directly */
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator|&=
operator|~
operator|(
name|FOREGROUND_CHANGED
operator||
name|BACKGROUND_CHANGED
operator|)
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_color
operator|=
name|scp
operator|->
name|term
operator|.
name|std_color
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|1
index|]
operator|&
literal|0xFF
operator|)
operator|<<
literal|8
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* set ansi reverse video background */
name|scp
operator|->
name|term
operator|.
name|rev_color
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|rev_color
operator|&
literal|0x0F00
operator|)
operator||
operator|(
name|ansi_col
index|[
operator|(
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|1
index|]
operator|)
operator|&
literal|0x0F
index|]
operator|<<
literal|12
operator|)
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
comment|/* set ansi reverse video foreground */
name|scp
operator|->
name|term
operator|.
name|rev_color
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|rev_color
operator|&
literal|0xF000
operator|)
operator||
operator|(
name|ansi_col
index|[
operator|(
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|1
index|]
operator|)
operator|&
literal|0x0F
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|/* set ansi reverse video directly */
name|scp
operator|->
name|term
operator|.
name|rev_color
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|1
index|]
operator|&
literal|0xFF
operator|)
operator|<<
literal|8
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'z'
case|:
comment|/* switch to (virtual) console n */
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|1
condition|)
name|switch_scr
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|esc
operator|==
literal|3
condition|)
block|{
comment|/* seen ESC [0-9]+ = */
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|<
name|MAX_ESC_PAR
condition|)
block|{
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|last_param
operator|!=
name|scp
operator|->
name|term
operator|.
name|num_param
condition|)
block|{
name|scp
operator|->
name|term
operator|.
name|last_param
operator|=
name|scp
operator|->
name|term
operator|.
name|num_param
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|param
index|[
name|scp
operator|->
name|term
operator|.
name|num_param
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|scp
operator|->
name|term
operator|.
name|param
index|[
name|scp
operator|->
name|term
operator|.
name|num_param
index|]
operator|*=
literal|10
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|param
index|[
name|scp
operator|->
name|term
operator|.
name|num_param
index|]
operator|+=
name|c
operator|-
literal|'0'
expr_stmt|;
return|return;
block|}
block|}
name|scp
operator|->
name|term
operator|.
name|num_param
operator|=
name|scp
operator|->
name|term
operator|.
name|last_param
operator|+
literal|1
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|';'
case|:
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|<
name|MAX_ESC_PAR
condition|)
return|return;
break|break;
case|case
literal|'A'
case|:
comment|/* set display border color */
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|1
condition|)
block|{
name|scp
operator|->
name|border
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|scp
operator|==
name|cur_console
condition|)
name|set_border
argument_list|(
name|cur_console
argument_list|,
name|scp
operator|->
name|border
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'B'
case|:
comment|/* set bell pitch and duration */
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|2
condition|)
block|{
name|scp
operator|->
name|bell_pitch
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
name|scp
operator|->
name|bell_duration
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|1
index|]
expr_stmt|;
block|}
break|break;
case|case
literal|'C'
case|:
comment|/* set cursor type& shape */
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
operator|&
literal|0x01
condition|)
name|sc_flags
operator||=
name|BLINK_CURSOR
expr_stmt|;
else|else
name|sc_flags
operator|&=
operator|~
name|BLINK_CURSOR
expr_stmt|;
if|if
condition|(
operator|(
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
operator|&
literal|0x02
operator|)
operator|&&
name|ISFONTAVAIL
argument_list|(
name|scp
operator|->
name|adp
operator|->
name|va_flags
argument_list|)
condition|)
name|sc_flags
operator||=
name|CHAR_CURSOR
expr_stmt|;
else|else
name|sc_flags
operator|&=
operator|~
name|CHAR_CURSOR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|2
condition|)
block|{
name|scp
operator|->
name|cursor_start
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
operator|&
literal|0x1F
expr_stmt|;
name|scp
operator|->
name|cursor_end
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|1
index|]
operator|&
literal|0x1F
expr_stmt|;
block|}
comment|/*  	     * The cursor shape is global property; all virtual consoles 	     * are affected. Update the cursor in the current console... 	     */
if|if
condition|(
operator|!
name|ISGRAPHSC
argument_list|(
name|cur_console
argument_list|)
condition|)
block|{
name|i
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|remove_cursor_image
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc_flags
operator|&
name|CHAR_CURSOR
condition|)
name|set_destructive_cursor
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
name|draw_cursor_image
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'F'
case|:
comment|/* set ansi foreground */
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|1
condition|)
block|{
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator|&=
operator|~
name|FOREGROUND_CHANGED
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_color
operator|=
name|scp
operator|->
name|term
operator|.
name|std_color
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|std_color
operator|&
literal|0xF000
operator|)
operator||
operator|(
operator|(
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
operator|&
literal|0x0F
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'G'
case|:
comment|/* set ansi background */
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|1
condition|)
block|{
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator|&=
operator|~
name|BACKGROUND_CHANGED
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_color
operator|=
name|scp
operator|->
name|term
operator|.
name|std_color
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|std_color
operator|&
literal|0x0F00
operator|)
operator||
operator|(
operator|(
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
operator|&
literal|0x0F
operator|)
operator|<<
literal|12
operator|)
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'H'
case|:
comment|/* set ansi reverse video foreground */
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|1
condition|)
block|{
name|scp
operator|->
name|term
operator|.
name|rev_color
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|rev_color
operator|&
literal|0xF000
operator|)
operator||
operator|(
operator|(
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
operator|&
literal|0x0F
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'I'
case|:
comment|/* set ansi reverse video background */
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|1
condition|)
block|{
name|scp
operator|->
name|term
operator|.
name|rev_color
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|rev_color
operator|&
literal|0x0F00
operator|)
operator||
operator|(
operator|(
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
operator|&
literal|0x0F
operator|)
operator|<<
literal|12
operator|)
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
if|#
directive|if
name|notyet
elseif|else
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|esc
operator|==
literal|4
condition|)
block|{
comment|/* seen ESC Q */
comment|/* to be filled */
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|esc
operator|==
literal|5
condition|)
block|{
comment|/* seen ESC ( */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'B'
case|:
comment|/* iso-2022: desginate ASCII into G0 */
break|break;
comment|/* other items to be filled */
default|default:
break|break;
block|}
block|}
name|scp
operator|->
name|term
operator|.
name|esc
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ansi_put
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|u_char
modifier|*
name|ptr
init|=
name|buf
decl_stmt|;
comment|/* make screensaver happy */
if|if
condition|(
operator|!
name|sticky_splash
operator|&&
name|scp
operator|==
name|cur_console
condition|)
name|run_scrn_saver
operator|=
name|FALSE
expr_stmt|;
name|write_in_progress
operator|++
expr_stmt|;
name|outloop
label|:
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|esc
condition|)
block|{
name|scan_esc
argument_list|(
name|scp
argument_list|,
operator|*
name|ptr
operator|++
argument_list|)
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PRINTABLE
argument_list|(
operator|*
name|ptr
argument_list|)
condition|)
block|{
comment|/* Print only printables */
name|int
name|cnt
init|=
name|len
operator|<=
operator|(
name|scp
operator|->
name|xsize
operator|-
name|scp
operator|->
name|xpos
operator|)
condition|?
name|len
else|:
operator|(
name|scp
operator|->
name|xsize
operator|-
name|scp
operator|->
name|xpos
operator|)
decl_stmt|;
name|u_short
name|cur_attr
init|=
name|scp
operator|->
name|term
operator|.
name|cur_attr
decl_stmt|;
name|u_short
modifier|*
name|cursor_pos
init|=
name|scp
operator|->
name|cursor_pos
decl_stmt|;
do|do
block|{
comment|/* 	     * gcc-2.6.3 generates poor (un)sign extension code.  Casting the 	     * pointers in the following to volatile should have no effect, 	     * but in fact speeds up this inner loop from 26 to 18 cycles 	     * (+ cache misses) on i486's. 	     */
define|#
directive|define
name|UCVP
parameter_list|(
name|ucp
parameter_list|)
value|((u_char volatile *)(ucp))
operator|*
name|cursor_pos
operator|++
operator|=
name|UCVP
argument_list|(
name|scr_map
argument_list|)
index|[
operator|*
name|UCVP
argument_list|(
name|ptr
argument_list|)
index|]
operator||
name|cur_attr
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
name|cnt
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|cnt
operator|&&
name|PRINTABLE
argument_list|(
operator|*
name|ptr
argument_list|)
condition|)
do|;
name|len
operator|-=
operator|(
name|cursor_pos
operator|-
name|scp
operator|->
name|cursor_pos
operator|)
expr_stmt|;
name|scp
operator|->
name|xpos
operator|+=
operator|(
name|cursor_pos
operator|-
name|scp
operator|->
name|cursor_pos
operator|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|scp
operator|->
name|cursor_pos
operator|=
name|cursor_pos
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|xpos
operator|>=
name|scp
operator|->
name|xsize
condition|)
block|{
name|scp
operator|->
name|xpos
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|ypos
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
operator|*
name|ptr
condition|)
block|{
case|case
literal|0x07
case|:
name|do_bell
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|bell_pitch
argument_list|,
name|scp
operator|->
name|bell_duration
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x08
case|:
comment|/* non-destructive backspace */
if|if
condition|(
name|scp
operator|->
name|cursor_pos
operator|>
name|scp
operator|->
name|scr_buf
condition|)
block|{
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|scp
operator|->
name|cursor_pos
operator|--
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|xpos
operator|>
literal|0
condition|)
name|scp
operator|->
name|xpos
operator|--
expr_stmt|;
else|else
block|{
name|scp
operator|->
name|xpos
operator|+=
name|scp
operator|->
name|xsize
operator|-
literal|1
expr_stmt|;
name|scp
operator|->
name|ypos
operator|--
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|0x09
case|:
comment|/* non-destructive tab */
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|scp
operator|->
name|cursor_pos
operator|+=
operator|(
literal|8
operator|-
name|scp
operator|->
name|xpos
operator|%
literal|8u
operator|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scp
operator|->
name|xpos
operator|+=
operator|(
literal|8
operator|-
name|scp
operator|->
name|xpos
operator|%
literal|8u
operator|)
operator|)
operator|>=
name|scp
operator|->
name|xsize
condition|)
block|{
name|scp
operator|->
name|xpos
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|ypos
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|0x0a
case|:
comment|/* newline, same pos */
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|scp
operator|->
name|cursor_pos
operator|+=
name|scp
operator|->
name|xsize
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|scp
operator|->
name|ypos
operator|++
expr_stmt|;
break|break;
case|case
literal|0x0c
case|:
comment|/* form feed, clears screen */
name|sc_clear_screen
argument_list|(
name|scp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x0d
case|:
comment|/* return, return to pos 0 */
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|scp
operator|->
name|cursor_pos
operator|-=
name|scp
operator|->
name|xpos
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|scp
operator|->
name|xpos
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|0x1b
case|:
comment|/* start escape sequence */
name|scp
operator|->
name|term
operator|.
name|esc
operator|=
literal|1
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|num_param
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|ptr
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
comment|/* do we have to scroll ?? */
if|if
condition|(
name|scp
operator|->
name|cursor_pos
operator|>=
name|scp
operator|->
name|scr_buf
operator|+
name|scp
operator|->
name|ysize
operator|*
name|scp
operator|->
name|xsize
condition|)
block|{
name|remove_cutmarking
argument_list|(
name|scp
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|history
operator|!=
name|NULL
condition|)
block|{
name|bcopy
argument_list|(
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|history_head
argument_list|,
name|scp
operator|->
name|xsize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|scp
operator|->
name|history_head
operator|+=
name|scp
operator|->
name|xsize
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|history_head
operator|+
name|scp
operator|->
name|xsize
operator|>
name|scp
operator|->
name|history
operator|+
name|scp
operator|->
name|history_size
condition|)
name|scp
operator|->
name|history_head
operator|=
name|scp
operator|->
name|history
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|scp
operator|->
name|scr_buf
operator|+
name|scp
operator|->
name|xsize
argument_list|,
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|xsize
operator|*
operator|(
name|scp
operator|->
name|ysize
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|scr_buf
operator|+
name|scp
operator|->
name|xsize
operator|*
operator|(
name|scp
operator|->
name|ysize
operator|-
literal|1
operator|)
argument_list|,
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
name|scp
operator|->
name|cursor_pos
operator|-=
name|scp
operator|->
name|xsize
expr_stmt|;
name|scp
operator|->
name|ypos
operator|--
expr_stmt|;
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
condition|)
goto|goto
name|outloop
goto|;
name|write_in_progress
operator|--
expr_stmt|;
if|if
condition|(
name|delayed_next_scr
condition|)
name|switch_scr
argument_list|(
name|scp
argument_list|,
name|delayed_next_scr
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|scinit
parameter_list|(
name|void
parameter_list|)
block|{
name|video_adapter_t
modifier|*
name|adp
decl_stmt|;
name|int
name|col
decl_stmt|;
name|int
name|row
decl_stmt|;
name|u_int
name|i
decl_stmt|;
if|if
condition|(
name|init_done
operator|!=
name|COLD
condition|)
return|return;
name|init_done
operator|=
name|WARM
expr_stmt|;
comment|/* extract the hardware cursor location and hide the cursor for now */
name|adp
operator|=
name|vid_get_adapter
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
operator|(
operator|*
name|vidsw
index|[
name|adapter
index|]
operator|->
name|read_hw_cursor
operator|)
operator|(
name|adp
operator|,
operator|&
name|col
operator|,
operator|&
name|row
operator|)
expr_stmt|;
operator|(
operator|*
name|vidsw
index|[
name|adapter
index|]
operator|->
name|set_hw_cursor
operator|)
operator|(
name|adp
operator|,
operator|-
literal|1
operator|,
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* set up the first console */
name|current_default
operator|=
operator|&
name|user_default
expr_stmt|;
name|console
index|[
literal|0
index|]
operator|=
operator|&
name|main_console
expr_stmt|;
name|init_scp
argument_list|(
name|console
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|cur_console
operator|=
name|console
index|[
literal|0
index|]
expr_stmt|;
comment|/* copy screen to temporary buffer */
if|if
condition|(
name|ISTEXTSC
argument_list|(
name|console
index|[
literal|0
index|]
argument_list|)
condition|)
name|generic_bcopy
argument_list|(
operator|(
name|ushort
operator|*
operator|)
operator|(
name|console
index|[
literal|0
index|]
operator|->
name|adp
operator|->
name|va_window
operator|)
argument_list|,
name|sc_buffer
argument_list|,
name|console
index|[
literal|0
index|]
operator|->
name|xsize
operator|*
name|console
index|[
literal|0
index|]
operator|->
name|ysize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|console
index|[
literal|0
index|]
operator|->
name|scr_buf
operator|=
name|console
index|[
literal|0
index|]
operator|->
name|mouse_pos
operator|=
name|console
index|[
literal|0
index|]
operator|->
name|mouse_oldpos
operator|=
name|sc_buffer
expr_stmt|;
if|if
condition|(
name|col
operator|>=
name|console
index|[
literal|0
index|]
operator|->
name|xsize
condition|)
name|col
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|row
operator|>=
name|console
index|[
literal|0
index|]
operator|->
name|ysize
condition|)
name|row
operator|=
name|console
index|[
literal|0
index|]
operator|->
name|ysize
operator|-
literal|1
expr_stmt|;
name|console
index|[
literal|0
index|]
operator|->
name|xpos
operator|=
name|col
expr_stmt|;
name|console
index|[
literal|0
index|]
operator|->
name|ypos
operator|=
name|row
expr_stmt|;
name|console
index|[
literal|0
index|]
operator|->
name|cursor_pos
operator|=
name|console
index|[
literal|0
index|]
operator|->
name|cursor_oldpos
operator|=
name|sc_buffer
operator|+
name|row
operator|*
name|console
index|[
literal|0
index|]
operator|->
name|xsize
operator|+
name|col
expr_stmt|;
name|console
index|[
literal|0
index|]
operator|->
name|cursor_saveunder
operator|=
operator|*
name|console
index|[
literal|0
index|]
operator|->
name|cursor_pos
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|MAXCONS
condition|;
name|i
operator|++
control|)
name|console
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|kernel_console
operator|.
name|esc
operator|=
literal|0
expr_stmt|;
name|kernel_console
operator|.
name|attr_mask
operator|=
name|NORMAL_ATTR
expr_stmt|;
name|kernel_console
operator|.
name|cur_attr
operator|=
name|kernel_console
operator|.
name|cur_color
operator|=
name|kernel_console
operator|.
name|std_color
operator|=
name|kernel_default
operator|.
name|std_color
expr_stmt|;
name|kernel_console
operator|.
name|rev_color
operator|=
name|kernel_default
operator|.
name|rev_color
expr_stmt|;
comment|/* initialize mapscrn arrays to a one to one map */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|scr_map
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|scr_map
index|[
name|i
index|]
operator|=
name|scr_rmap
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
comment|/* Save font and palette */
if|if
condition|(
name|ISFONTAVAIL
argument_list|(
name|cur_console
operator|->
name|adp
operator|->
name|va_flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|fonts_loaded
operator|&
name|FONT_16
condition|)
block|{
name|copy_font
argument_list|(
name|cur_console
argument_list|,
name|LOAD
argument_list|,
literal|16
argument_list|,
name|font_16
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|copy_font
argument_list|(
name|cur_console
argument_list|,
name|SAVE
argument_list|,
literal|16
argument_list|,
name|font_16
argument_list|)
expr_stmt|;
name|fonts_loaded
operator|=
name|FONT_16
expr_stmt|;
name|set_destructive_cursor
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * FONT KLUDGE 	 * Always use the font page #0. XXX 	 */
operator|(
operator|*
name|vidsw
index|[
name|cur_console
operator|->
name|ad
index|]
operator|->
name|show_font
operator|)
operator|(
name|cur_console
operator|->
name|adp
operator|,
literal|0
operator|)
expr_stmt|;
block|}
name|save_palette
argument_list|(
name|cur_console
operator|->
name|adp
argument_list|,
name|palette
argument_list|)
expr_stmt|;
if|#
directive|if
name|NSPLASH
operator|>
literal|0
comment|/* we are ready to put up the splash image! */
name|splash_init
argument_list|(
name|cur_console
operator|->
name|adp
argument_list|,
name|scsplash_callback
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|scshutdown
parameter_list|(
name|int
name|howto
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|sc_touch_scrn_saver
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|cold
operator|&&
name|cur_console
operator|->
name|smode
operator|.
name|mode
operator|==
name|VT_AUTO
operator|&&
name|console
index|[
literal|0
index|]
operator|->
name|smode
operator|.
name|mode
operator|==
name|VT_AUTO
condition|)
name|switch_scr
argument_list|(
name|cur_console
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|shutdown_in_progress
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sc_clean_up
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|wait_scrn_saver_stop
argument_list|()
operator|)
condition|)
return|return
name|error
return|;
name|scp
operator|->
name|status
operator|&=
operator|~
name|MOUSE_VISIBLE
expr_stmt|;
name|remove_cutmarking
argument_list|(
name|scp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|sc_alloc_scr_buffer
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|wait
parameter_list|,
name|int
name|clear
parameter_list|)
block|{
if|if
condition|(
name|scp
operator|->
name|scr_buf
condition|)
name|free
argument_list|(
name|scp
operator|->
name|scr_buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|scp
operator|->
name|scr_buf
operator|=
operator|(
name|u_short
operator|*
operator|)
name|malloc
argument_list|(
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
operator|(
name|wait
operator|)
condition|?
name|M_WAITOK
else|:
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|clear
condition|)
block|{
comment|/* clear the screen and move the text cursor to the top-left position */
name|sc_clear_screen
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* retain the current cursor position, but adjust pointers */
name|move_crsr
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|xpos
argument_list|,
name|scp
operator|->
name|ypos
argument_list|)
expr_stmt|;
name|scp
operator|->
name|cursor_oldpos
operator|=
name|scp
operator|->
name|cursor_pos
expr_stmt|;
block|}
comment|/* move the mouse cursor at the center of the screen */
name|sc_move_mouse
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|xpixel
operator|/
literal|2
argument_list|,
name|scp
operator|->
name|ypixel
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sc_alloc_cut_buffer
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|wait
parameter_list|)
block|{
if|if
condition|(
operator|(
name|cut_buffer
operator|==
name|NULL
operator|)
operator|||
operator|(
name|cut_buffer_size
operator|<
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
operator|+
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|cut_buffer
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|cut_buffer
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|cut_buffer_size
operator|=
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
operator|+
literal|1
expr_stmt|;
name|cut_buffer
operator|=
operator|(
name|u_char
operator|*
operator|)
name|malloc
argument_list|(
name|cut_buffer_size
argument_list|,
name|M_DEVBUF
argument_list|,
operator|(
name|wait
operator|)
condition|?
name|M_WAITOK
else|:
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|cut_buffer
operator|!=
name|NULL
condition|)
name|cut_buffer
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sc_alloc_history_buffer
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|lines
parameter_list|,
name|int
name|extra
parameter_list|,
name|int
name|wait
parameter_list|)
block|{
name|u_short
modifier|*
name|usp
decl_stmt|;
if|if
condition|(
name|lines
operator|<
name|scp
operator|->
name|ysize
condition|)
name|lines
operator|=
name|scp
operator|->
name|ysize
expr_stmt|;
name|usp
operator|=
name|scp
operator|->
name|history
expr_stmt|;
name|scp
operator|->
name|history
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|usp
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|usp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra
operator|>
literal|0
condition|)
name|extra_history_size
operator|+=
name|extra
expr_stmt|;
block|}
name|scp
operator|->
name|history_size
operator|=
name|lines
operator|*
name|scp
operator|->
name|xsize
expr_stmt|;
if|if
condition|(
name|lines
operator|>
name|imax
argument_list|(
name|sc_history_size
argument_list|,
name|scp
operator|->
name|ysize
argument_list|)
condition|)
name|extra_history_size
operator|-=
name|lines
operator|-
name|imax
argument_list|(
name|sc_history_size
argument_list|,
name|scp
operator|->
name|ysize
argument_list|)
expr_stmt|;
name|usp
operator|=
operator|(
name|u_short
operator|*
operator|)
name|malloc
argument_list|(
name|scp
operator|->
name|history_size
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
operator|(
name|wait
operator|)
condition|?
name|M_WAITOK
else|:
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|usp
operator|!=
name|NULL
condition|)
name|bzero
argument_list|(
name|usp
argument_list|,
name|scp
operator|->
name|history_size
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|scp
operator|->
name|history_head
operator|=
name|scp
operator|->
name|history_pos
operator|=
name|usp
expr_stmt|;
name|scp
operator|->
name|history
operator|=
name|usp
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|scr_stat
modifier|*
name|alloc_scp
parameter_list|()
block|{
name|scr_stat
modifier|*
name|scp
decl_stmt|;
name|scp
operator|=
operator|(
name|scr_stat
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|scr_stat
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|init_scp
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|sc_alloc_scr_buffer
argument_list|(
name|scp
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISMOUSEAVAIL
argument_list|(
name|scp
operator|->
name|adp
operator|->
name|va_flags
argument_list|)
condition|)
name|sc_alloc_cut_buffer
argument_list|(
name|scp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|sc_alloc_history_buffer
argument_list|(
name|scp
argument_list|,
name|sc_history_size
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* SOS     if (scp->adp->va_flags& V_ADP_MODECHANGE) 	set_mode(scp); */
name|sc_clear_screen
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|scp
operator|->
name|cursor_saveunder
operator|=
operator|*
name|scp
operator|->
name|cursor_pos
expr_stmt|;
return|return
name|scp
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_scp
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|video_info_t
name|info
decl_stmt|;
name|scp
operator|->
name|ad
operator|=
name|adapter
expr_stmt|;
name|scp
operator|->
name|adp
operator|=
name|vid_get_adapter
argument_list|(
name|scp
operator|->
name|ad
argument_list|)
expr_stmt|;
operator|(
operator|*
name|vidsw
index|[
name|scp
operator|->
name|ad
index|]
operator|->
name|get_info
operator|)
operator|(
name|scp
operator|->
name|adp
operator|,
name|initial_video_mode
operator|,
operator|&
name|info
operator|)
expr_stmt|;
name|scp
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|mode
operator|=
name|initial_video_mode
expr_stmt|;
name|scp
operator|->
name|scr_buf
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|vi_flags
operator|&
name|V_INFO_GRAPHICS
condition|)
block|{
name|scp
operator|->
name|status
operator||=
name|GRAPHICS_MODE
expr_stmt|;
name|scp
operator|->
name|xpixel
operator|=
name|info
operator|.
name|vi_width
expr_stmt|;
name|scp
operator|->
name|ypixel
operator|=
name|info
operator|.
name|vi_height
expr_stmt|;
name|scp
operator|->
name|xsize
operator|=
name|info
operator|.
name|vi_width
operator|/
literal|8
expr_stmt|;
name|scp
operator|->
name|ysize
operator|=
name|info
operator|.
name|vi_height
operator|/
name|info
operator|.
name|vi_cheight
expr_stmt|;
name|scp
operator|->
name|font_size
operator|=
name|FONT_NONE
expr_stmt|;
block|}
else|else
block|{
name|scp
operator|->
name|xsize
operator|=
name|info
operator|.
name|vi_width
expr_stmt|;
name|scp
operator|->
name|ysize
operator|=
name|info
operator|.
name|vi_height
expr_stmt|;
name|scp
operator|->
name|xpixel
operator|=
name|scp
operator|->
name|xsize
operator|*
literal|8
expr_stmt|;
name|scp
operator|->
name|ypixel
operator|=
name|scp
operator|->
name|ysize
operator|*
name|info
operator|.
name|vi_cheight
expr_stmt|;
name|scp
operator|->
name|font_size
operator|=
name|info
operator|.
name|vi_cheight
expr_stmt|;
block|}
name|scp
operator|->
name|xoff
operator|=
name|scp
operator|->
name|yoff
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|xpos
operator|=
name|scp
operator|->
name|ypos
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|saved_xpos
operator|=
name|scp
operator|->
name|saved_ypos
operator|=
operator|-
literal|1
expr_stmt|;
name|scp
operator|->
name|start
operator|=
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
expr_stmt|;
name|scp
operator|->
name|end
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|esc
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator|=
name|NORMAL_ATTR
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|scp
operator|->
name|term
operator|.
name|cur_color
operator|=
name|scp
operator|->
name|term
operator|.
name|std_color
operator|=
name|current_default
operator|->
name|std_color
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|rev_color
operator|=
name|current_default
operator|->
name|rev_color
expr_stmt|;
name|scp
operator|->
name|border
operator|=
name|BG_BLACK
expr_stmt|;
name|scp
operator|->
name|cursor_start
operator|=
operator|*
operator|(
name|u_int8_t
operator|*
operator|)
name|pa_to_va
argument_list|(
literal|0x461
argument_list|)
expr_stmt|;
name|scp
operator|->
name|cursor_end
operator|=
operator|*
operator|(
name|u_int8_t
operator|*
operator|)
name|pa_to_va
argument_list|(
literal|0x460
argument_list|)
expr_stmt|;
name|scp
operator|->
name|mouse_xpos
operator|=
name|scp
operator|->
name|xsize
operator|*
literal|8
operator|/
literal|2
expr_stmt|;
name|scp
operator|->
name|mouse_ypos
operator|=
name|scp
operator|->
name|ysize
operator|*
name|scp
operator|->
name|font_size
operator|/
literal|2
expr_stmt|;
name|scp
operator|->
name|mouse_cut_start
operator|=
name|scp
operator|->
name|mouse_cut_end
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|mouse_signal
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|mouse_pid
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|mouse_proc
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|kbd_mode
operator|=
name|K_XLATE
expr_stmt|;
name|scp
operator|->
name|bell_pitch
operator|=
name|BELL_PITCH
expr_stmt|;
name|scp
operator|->
name|bell_duration
operator|=
name|BELL_DURATION
expr_stmt|;
name|scp
operator|->
name|status
operator||=
operator|(
operator|*
operator|(
name|u_int8_t
operator|*
operator|)
name|pa_to_va
argument_list|(
literal|0x417
argument_list|)
operator|&
literal|0x20
operator|)
condition|?
name|NLKED
else|:
literal|0
expr_stmt|;
name|scp
operator|->
name|status
operator||=
name|CURSOR_ENABLED
expr_stmt|;
name|scp
operator|->
name|pid
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|proc
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|smode
operator|.
name|mode
operator|=
name|VT_AUTO
expr_stmt|;
name|scp
operator|->
name|history_head
operator|=
name|scp
operator|->
name|history_pos
operator|=
name|scp
operator|->
name|history
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|history_size
operator|=
name|imax
argument_list|(
name|sc_history_size
argument_list|,
name|scp
operator|->
name|ysize
argument_list|)
operator|*
name|scp
operator|->
name|xsize
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|history_to_screen
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|scp
operator|->
name|ysize
condition|;
name|i
operator|++
control|)
name|bcopy
argument_list|(
name|scp
operator|->
name|history
operator|+
operator|(
operator|(
operator|(
name|scp
operator|->
name|history_pos
operator|-
name|scp
operator|->
name|history
operator|)
operator|+
name|scp
operator|->
name|history_size
operator|-
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
name|scp
operator|->
name|xsize
operator|)
operator|)
operator|%
name|scp
operator|->
name|history_size
operator|)
argument_list|,
name|scp
operator|->
name|scr_buf
operator|+
operator|(
name|scp
operator|->
name|xsize
operator|*
operator|(
name|scp
operator|->
name|ysize
operator|-
literal|1
operator|-
name|i
operator|)
operator|)
argument_list|,
name|scp
operator|->
name|xsize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|history_up_line
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
if|if
condition|(
name|WRAPHIST
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|history_pos
argument_list|,
operator|-
operator|(
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
operator|)
argument_list|)
operator|!=
name|scp
operator|->
name|history_head
condition|)
block|{
name|scp
operator|->
name|history_pos
operator|=
name|WRAPHIST
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|history_pos
argument_list|,
operator|-
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
name|history_to_screen
argument_list|(
name|scp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|history_down_line
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
if|if
condition|(
name|scp
operator|->
name|history_pos
operator|!=
name|scp
operator|->
name|history_head
condition|)
block|{
name|scp
operator|->
name|history_pos
operator|=
name|WRAPHIST
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|history_pos
argument_list|,
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
name|history_to_screen
argument_list|(
name|scp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * scgetc(flags) - get character from keyboard.  * If flags& SCGETC_CN, then avoid harmful side effects.  * If flags& SCGETC_NONBLOCK, then wait until a key is pressed, else  * return NOKEY if there is nothing there.  */
end_comment

begin_function
specifier|static
name|u_int
name|scgetc
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|u_int
name|c
decl_stmt|;
name|int
name|this_scr
decl_stmt|;
name|int
name|f
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|kbd
operator|==
name|NULL
condition|)
return|return
name|NOKEY
return|;
name|next_code
label|:
comment|/* I don't like this, but... XXX */
if|if
condition|(
name|flags
operator|&
name|SCGETC_CN
condition|)
name|sccnupdate
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
comment|/* first see if there is something in the keyboard port */
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|kbd_read_char
argument_list|(
name|kbd
argument_list|,
operator|!
operator|(
name|flags
operator|&
name|SCGETC_NONBLOCK
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|ERRKEY
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCGETC_CN
operator|)
condition|)
name|do_bell
argument_list|(
name|cur_console
argument_list|,
name|BELL_PITCH
argument_list|,
name|BELL_DURATION
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|NOKEY
condition|)
return|return
name|c
return|;
else|else
break|break;
block|}
comment|/* make screensaver happy */
if|if
condition|(
operator|!
operator|(
name|c
operator|&
name|RELKEY
operator|)
condition|)
name|sc_touch_scrn_saver
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCGETC_CN
operator|)
condition|)
comment|/* do the /dev/random device a favour */
name|add_keyboard_randomness
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_console
operator|->
name|kbd_mode
operator|!=
name|K_XLATE
condition|)
return|return
name|KEYCHAR
argument_list|(
name|c
argument_list|)
return|;
comment|/* if scroll-lock pressed allow history browsing */
if|if
condition|(
operator|!
name|ISGRAPHSC
argument_list|(
name|cur_console
argument_list|)
operator|&&
name|cur_console
operator|->
name|history
operator|&&
name|cur_console
operator|->
name|status
operator|&
name|SLKED
condition|)
block|{
name|cur_console
operator|->
name|status
operator|&=
operator|~
name|CURSOR_ENABLED
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cur_console
operator|->
name|status
operator|&
name|BUFFER_SAVED
operator|)
condition|)
block|{
name|cur_console
operator|->
name|status
operator||=
name|BUFFER_SAVED
expr_stmt|;
name|cur_console
operator|->
name|history_save
operator|=
name|cur_console
operator|->
name|history_head
expr_stmt|;
comment|/* copy screen into top of history buffer */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cur_console
operator|->
name|ysize
condition|;
name|i
operator|++
control|)
block|{
name|bcopy
argument_list|(
name|cur_console
operator|->
name|scr_buf
operator|+
operator|(
name|cur_console
operator|->
name|xsize
operator|*
name|i
operator|)
argument_list|,
name|cur_console
operator|->
name|history_head
argument_list|,
name|cur_console
operator|->
name|xsize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|cur_console
operator|->
name|history_head
operator|+=
name|cur_console
operator|->
name|xsize
expr_stmt|;
if|if
condition|(
name|cur_console
operator|->
name|history_head
operator|+
name|cur_console
operator|->
name|xsize
operator|>
name|cur_console
operator|->
name|history
operator|+
name|cur_console
operator|->
name|history_size
condition|)
name|cur_console
operator|->
name|history_head
operator|=
name|cur_console
operator|->
name|history
expr_stmt|;
block|}
name|cur_console
operator|->
name|history_pos
operator|=
name|cur_console
operator|->
name|history_head
expr_stmt|;
name|history_to_screen
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
comment|/* FIXME: key codes */
case|case
name|SPCLKEY
operator||
name|FKEY
operator||
name|F
argument_list|(
literal|49
argument_list|)
case|:
comment|/* home key */
name|remove_cutmarking
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
name|cur_console
operator|->
name|history_pos
operator|=
name|cur_console
operator|->
name|history_head
expr_stmt|;
name|history_to_screen
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
goto|goto
name|next_code
goto|;
case|case
name|SPCLKEY
operator||
name|FKEY
operator||
name|F
argument_list|(
literal|57
argument_list|)
case|:
comment|/* end key */
name|remove_cutmarking
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
name|cur_console
operator|->
name|history_pos
operator|=
name|WRAPHIST
argument_list|(
name|cur_console
argument_list|,
name|cur_console
operator|->
name|history_head
argument_list|,
name|cur_console
operator|->
name|xsize
operator|*
name|cur_console
operator|->
name|ysize
argument_list|)
expr_stmt|;
name|history_to_screen
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
goto|goto
name|next_code
goto|;
case|case
name|SPCLKEY
operator||
name|FKEY
operator||
name|F
argument_list|(
literal|50
argument_list|)
case|:
comment|/* up arrow key */
name|remove_cutmarking
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
if|if
condition|(
name|history_up_line
argument_list|(
name|cur_console
argument_list|)
condition|)
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCGETC_CN
operator|)
condition|)
name|do_bell
argument_list|(
name|cur_console
argument_list|,
name|BELL_PITCH
argument_list|,
name|BELL_DURATION
argument_list|)
expr_stmt|;
goto|goto
name|next_code
goto|;
case|case
name|SPCLKEY
operator||
name|FKEY
operator||
name|F
argument_list|(
literal|58
argument_list|)
case|:
comment|/* down arrow key */
name|remove_cutmarking
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
if|if
condition|(
name|history_down_line
argument_list|(
name|cur_console
argument_list|)
condition|)
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCGETC_CN
operator|)
condition|)
name|do_bell
argument_list|(
name|cur_console
argument_list|,
name|BELL_PITCH
argument_list|,
name|BELL_DURATION
argument_list|)
expr_stmt|;
goto|goto
name|next_code
goto|;
case|case
name|SPCLKEY
operator||
name|FKEY
operator||
name|F
argument_list|(
literal|51
argument_list|)
case|:
comment|/* page up key */
name|remove_cutmarking
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cur_console
operator|->
name|ysize
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|history_up_line
argument_list|(
name|cur_console
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCGETC_CN
operator|)
condition|)
name|do_bell
argument_list|(
name|cur_console
argument_list|,
name|BELL_PITCH
argument_list|,
name|BELL_DURATION
argument_list|)
expr_stmt|;
break|break;
block|}
goto|goto
name|next_code
goto|;
case|case
name|SPCLKEY
operator||
name|FKEY
operator||
name|F
argument_list|(
literal|59
argument_list|)
case|:
comment|/* page down key */
name|remove_cutmarking
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cur_console
operator|->
name|ysize
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|history_down_line
argument_list|(
name|cur_console
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCGETC_CN
operator|)
condition|)
name|do_bell
argument_list|(
name|cur_console
argument_list|,
name|BELL_PITCH
argument_list|,
name|BELL_DURATION
argument_list|)
expr_stmt|;
break|break;
block|}
goto|goto
name|next_code
goto|;
block|}
block|}
comment|/*       * Process and consume special keys here.  Return a plain char code      * or a char code with the META flag or a function key code.      */
if|if
condition|(
name|c
operator|&
name|RELKEY
condition|)
block|{
comment|/* key released */
comment|/* goto next_code */
block|}
else|else
block|{
comment|/* key pressed */
if|if
condition|(
name|c
operator|&
name|SPCLKEY
condition|)
block|{
name|c
operator|&=
operator|~
name|SPCLKEY
expr_stmt|;
switch|switch
condition|(
name|KEYCHAR
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* LOCKING KEYS */
case|case
name|NLK
case|:
case|case
name|CLK
case|:
case|case
name|ALK
case|:
break|break;
case|case
name|SLK
case|:
name|kbd_ioctl
argument_list|(
name|kbd
argument_list|,
name|KDGKBSTATE
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|&
name|SLKED
condition|)
block|{
name|cur_console
operator|->
name|status
operator||=
name|SLKED
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cur_console
operator|->
name|status
operator|&
name|SLKED
condition|)
block|{
name|cur_console
operator|->
name|status
operator|&=
operator|~
name|SLKED
expr_stmt|;
if|if
condition|(
name|cur_console
operator|->
name|status
operator|&
name|BUFFER_SAVED
condition|)
block|{
name|int
name|i
decl_stmt|;
name|u_short
modifier|*
name|ptr
init|=
name|cur_console
operator|->
name|history_save
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cur_console
operator|->
name|ysize
condition|;
name|i
operator|++
control|)
block|{
name|bcopy
argument_list|(
name|ptr
argument_list|,
name|cur_console
operator|->
name|scr_buf
operator|+
operator|(
name|cur_console
operator|->
name|xsize
operator|*
name|i
operator|)
argument_list|,
name|cur_console
operator|->
name|xsize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|ptr
operator|+=
name|cur_console
operator|->
name|xsize
expr_stmt|;
if|if
condition|(
name|ptr
operator|+
name|cur_console
operator|->
name|xsize
operator|>
name|cur_console
operator|->
name|history
operator|+
name|cur_console
operator|->
name|history_size
condition|)
name|ptr
operator|=
name|cur_console
operator|->
name|history
expr_stmt|;
block|}
name|cur_console
operator|->
name|status
operator|&=
operator|~
name|BUFFER_SAVED
expr_stmt|;
name|cur_console
operator|->
name|history_head
operator|=
name|cur_console
operator|->
name|history_save
expr_stmt|;
name|cur_console
operator|->
name|status
operator||=
name|CURSOR_ENABLED
expr_stmt|;
name|mark_all
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
block|}
name|scstart
argument_list|(
name|VIRTUAL_TTY
argument_list|(
name|get_scr_num
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
comment|/* NON-LOCKING KEYS */
case|case
name|NOP
case|:
case|case
name|LSH
case|:
case|case
name|RSH
case|:
case|case
name|LCTR
case|:
case|case
name|RCTR
case|:
case|case
name|LALT
case|:
case|case
name|RALT
case|:
case|case
name|ASH
case|:
case|case
name|META
case|:
break|break;
case|case
name|BTAB
case|:
return|return
name|c
return|;
case|case
name|SPSC
case|:
comment|/* force activatation/deactivation of the screen saver */
if|if
condition|(
operator|!
name|scrn_blanked
condition|)
block|{
name|run_scrn_saver
operator|=
name|TRUE
expr_stmt|;
name|scrn_time_stamp
operator|-=
name|scrn_blank_time
expr_stmt|;
block|}
if|#
directive|if
name|NSPLASH
operator|>
literal|0
if|if
condition|(
name|cold
condition|)
block|{
comment|/* 		     * While devices are being probed, the screen saver need 		     * to be invoked explictly. XXX 		     */
if|if
condition|(
name|scrn_blanked
condition|)
block|{
name|scsplash_stick
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|stop_scrn_saver
argument_list|(
name|current_saver
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|ISGRAPHSC
argument_list|(
name|cur_console
argument_list|)
condition|)
block|{
name|scsplash_stick
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
call|(
modifier|*
name|current_saver
call|)
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* NSPLASH */
break|break;
case|case
name|RBT
case|:
ifndef|#
directive|ifndef
name|SC_DISABLE_REBOOT
name|shutdown_nice
argument_list|()
expr_stmt|;
endif|#
directive|endif
break|break;
if|#
directive|if
name|NAPM
operator|>
literal|0
case|case
name|SUSP
case|:
name|apm_suspend
argument_list|(
name|PMST_SUSPEND
argument_list|)
expr_stmt|;
break|break;
case|case
name|STBY
case|:
name|apm_suspend
argument_list|(
name|PMST_STANDBY
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
case|case
name|SUSP
case|:
case|case
name|STBY
case|:
break|break;
endif|#
directive|endif
case|case
name|DBG
case|:
ifdef|#
directive|ifdef
name|DDB
comment|/* try to switch to console 0 */
comment|/* 		 * TRY to make sure the screen saver is stopped,  		 * and the screen is updated before switching to  		 * the vty0. 		 */
name|scrn_timer
argument_list|(
operator|(
name|void
operator|*
operator|)
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_console
operator|->
name|smode
operator|.
name|mode
operator|==
name|VT_AUTO
operator|&&
name|console
index|[
literal|0
index|]
operator|->
name|smode
operator|.
name|mode
operator|==
name|VT_AUTO
condition|)
name|switch_scr
argument_list|(
name|cur_console
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Debugger
argument_list|(
literal|"manual escape to debugger"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"No debugger in kernel\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|NEXT
case|:
name|this_scr
operator|=
name|get_scr_num
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
name|this_scr
operator|+
literal|1
init|;
name|i
operator|!=
name|this_scr
condition|;
name|i
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|MAXCONS
control|)
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
name|VIRTUAL_TTY
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
condition|)
block|{
name|switch_scr
argument_list|(
name|cur_console
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
default|default:
if|if
condition|(
name|KEYCHAR
argument_list|(
name|c
argument_list|)
operator|>=
name|F_SCR
operator|&&
name|KEYCHAR
argument_list|(
name|c
argument_list|)
operator|<=
name|L_SCR
condition|)
block|{
name|switch_scr
argument_list|(
name|cur_console
argument_list|,
name|KEYCHAR
argument_list|(
name|c
argument_list|)
operator|-
name|F_SCR
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* assert(c& FKEY) */
return|return
name|c
return|;
block|}
comment|/* goto next_code */
block|}
else|else
block|{
comment|/* regular keys (maybe MKEY is set) */
return|return
name|c
return|;
block|}
block|}
goto|goto
name|next_code
goto|;
block|}
end_function

begin_function
name|int
name|scmmap
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|vm_offset_t
name|offset
parameter_list|,
name|int
name|nprot
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|struct
name|scr_stat
modifier|*
name|scp
decl_stmt|;
name|tp
operator|=
name|scdevtotty
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tp
condition|)
return|return
name|ENXIO
return|;
name|scp
operator|=
name|sc_get_scr_stat
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
name|vidsw
index|[
name|scp
operator|->
name|ad
index|]
operator|->
name|mmap
operator|)
operator|(
name|scp
operator|->
name|adp
operator|,
name|offset
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate hardware attributes word using logical attributes mask and  * hardware colors  */
end_comment

begin_function
specifier|static
name|int
name|mask2attr
parameter_list|(
name|struct
name|term_stat
modifier|*
name|term
parameter_list|)
block|{
name|int
name|attr
decl_stmt|,
name|mask
init|=
name|term
operator|->
name|attr_mask
decl_stmt|;
if|if
condition|(
name|mask
operator|&
name|REVERSE_ATTR
condition|)
block|{
name|attr
operator|=
operator|(
operator|(
name|mask
operator|&
name|FOREGROUND_CHANGED
operator|)
condition|?
operator|(
operator|(
name|term
operator|->
name|cur_color
operator|&
literal|0xF000
operator|)
operator|>>
literal|4
operator|)
else|:
operator|(
name|term
operator|->
name|rev_color
operator|&
literal|0x0F00
operator|)
operator|)
operator||
operator|(
operator|(
name|mask
operator|&
name|BACKGROUND_CHANGED
operator|)
condition|?
operator|(
operator|(
name|term
operator|->
name|cur_color
operator|&
literal|0x0F00
operator|)
operator|<<
literal|4
operator|)
else|:
operator|(
name|term
operator|->
name|rev_color
operator|&
literal|0xF000
operator|)
operator|)
expr_stmt|;
block|}
else|else
name|attr
operator|=
name|term
operator|->
name|cur_color
expr_stmt|;
comment|/* XXX: underline mapping for Hercules adapter can be better */
if|if
condition|(
name|mask
operator|&
operator|(
name|BOLD_ATTR
operator||
name|UNDERLINE_ATTR
operator|)
condition|)
name|attr
operator|^=
literal|0x0800
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|BLINK_ATTR
condition|)
name|attr
operator|^=
literal|0x8000
expr_stmt|;
return|return
name|attr
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|save_kbd_state
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|int
name|state
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|kbd_ioctl
argument_list|(
name|kbd
argument_list|,
name|KDGKBSTATE
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOIOCTL
condition|)
name|error
operator|=
name|ENODEV
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|scp
operator|->
name|status
operator|&=
operator|~
name|LOCK_MASK
expr_stmt|;
name|scp
operator|->
name|status
operator||=
name|state
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|update_kbd_state
parameter_list|(
name|int
name|new_bits
parameter_list|,
name|int
name|mask
parameter_list|)
block|{
name|int
name|state
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|mask
operator|!=
name|LOCK_MASK
condition|)
block|{
name|error
operator|=
name|kbd_ioctl
argument_list|(
name|kbd
argument_list|,
name|KDGKBSTATE
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOIOCTL
condition|)
name|error
operator|=
name|ENODEV
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|state
operator|&=
operator|~
name|mask
expr_stmt|;
name|state
operator||=
name|new_bits
operator|&
name|mask
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|new_bits
operator|&
name|LOCK_MASK
expr_stmt|;
block|}
name|error
operator|=
name|kbd_ioctl
argument_list|(
name|kbd
argument_list|,
name|KDSKBSTATE
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOIOCTL
condition|)
name|error
operator|=
name|ENODEV
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|update_kbd_leds
parameter_list|(
name|int
name|which
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|which
operator|&=
name|LOCK_MASK
expr_stmt|;
name|error
operator|=
name|kbd_ioctl
argument_list|(
name|kbd
argument_list|,
name|KDSETLED
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|which
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOIOCTL
condition|)
name|error
operator|=
name|ENODEV
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|set_mode
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|video_info_t
name|info
decl_stmt|;
comment|/* reject unsupported mode */
if|if
condition|(
operator|(
operator|*
name|vidsw
index|[
name|scp
operator|->
name|ad
index|]
operator|->
name|get_info
operator|)
operator|(
name|scp
operator|->
name|adp
operator|,
name|scp
operator|->
name|mode
operator|,
operator|&
name|info
operator|)
condition|)
return|return
literal|1
return|;
comment|/* if this vty is not currently showing, do nothing */
if|if
condition|(
name|scp
operator|!=
name|cur_console
condition|)
return|return
literal|0
return|;
comment|/* setup video hardware for the given mode */
operator|(
operator|*
name|vidsw
index|[
name|scp
operator|->
name|ad
index|]
operator|->
name|set_mode
operator|)
operator|(
name|scp
operator|->
name|adp
operator|,
name|scp
operator|->
name|mode
operator|)
expr_stmt|;
name|Crtat
operator|=
operator|(
name|u_short
operator|*
operator|)
name|scp
operator|->
name|adp
operator|->
name|va_window
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|scp
operator|->
name|status
operator|&
name|GRAPHICS_MODE
operator|)
condition|)
block|{
comment|/* load appropriate font */
if|if
condition|(
operator|!
operator|(
name|scp
operator|->
name|status
operator|&
name|PIXEL_MODE
operator|)
operator|&&
name|ISFONTAVAIL
argument_list|(
name|scp
operator|->
name|adp
operator|->
name|va_flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|scp
operator|->
name|font_size
operator|<
literal|14
condition|)
block|{
if|if
condition|(
name|fonts_loaded
operator|&
name|FONT_8
condition|)
name|copy_font
argument_list|(
name|scp
argument_list|,
name|LOAD
argument_list|,
literal|8
argument_list|,
name|font_8
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scp
operator|->
name|font_size
operator|>=
literal|16
condition|)
block|{
if|if
condition|(
name|fonts_loaded
operator|&
name|FONT_16
condition|)
name|copy_font
argument_list|(
name|scp
argument_list|,
name|LOAD
argument_list|,
literal|16
argument_list|,
name|font_16
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fonts_loaded
operator|&
name|FONT_14
condition|)
name|copy_font
argument_list|(
name|scp
argument_list|,
name|LOAD
argument_list|,
literal|14
argument_list|,
name|font_14
argument_list|)
expr_stmt|;
block|}
comment|/* 	     * FONT KLUDGE: 	     * This is an interim kludge to display correct font. 	     * Always use the font page #0 on the video plane 2. 	     * Somehow we cannot show the font in other font pages on 	     * some video cards... XXX 	     */
operator|(
operator|*
name|vidsw
index|[
name|scp
operator|->
name|ad
index|]
operator|->
name|show_font
operator|)
operator|(
name|scp
operator|->
name|adp
operator|,
literal|0
operator|)
expr_stmt|;
block|}
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|PIXEL_MODE
condition|)
name|generic_bzero
argument_list|(
operator|(
name|u_char
operator|*
operator|)
operator|(
name|scp
operator|->
name|adp
operator|->
name|va_window
operator|)
argument_list|,
name|scp
operator|->
name|xpixel
operator|*
name|scp
operator|->
name|ypixel
operator|/
literal|8
argument_list|)
expr_stmt|;
name|set_border
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|border
argument_list|)
expr_stmt|;
comment|/* move hardware cursor out of the way */
operator|(
operator|*
name|vidsw
index|[
name|scp
operator|->
name|ad
index|]
operator|->
name|set_hw_cursor
operator|)
operator|(
name|scp
operator|->
name|adp
operator|,
operator|-
literal|1
operator|,
operator|-
literal|1
operator|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|set_border
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|color
parameter_list|)
block|{
name|u_char
modifier|*
name|p
decl_stmt|;
name|int
name|xoff
decl_stmt|;
name|int
name|yoff
decl_stmt|;
name|int
name|xlen
decl_stmt|;
name|int
name|ylen
decl_stmt|;
name|int
name|i
decl_stmt|;
operator|(
operator|*
name|vidsw
index|[
name|scp
operator|->
name|ad
index|]
operator|->
name|set_border
operator|)
operator|(
name|scp
operator|->
name|adp
operator|,
name|color
operator|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|PIXEL_MODE
condition|)
block|{
name|outw
argument_list|(
name|GDCIDX
argument_list|,
literal|0x0005
argument_list|)
expr_stmt|;
comment|/* read mode 0, write mode 0 */
name|outw
argument_list|(
name|GDCIDX
argument_list|,
literal|0x0003
argument_list|)
expr_stmt|;
comment|/* data rotate/function select */
name|outw
argument_list|(
name|GDCIDX
argument_list|,
literal|0x0f01
argument_list|)
expr_stmt|;
comment|/* set/reset enable */
name|outw
argument_list|(
name|GDCIDX
argument_list|,
literal|0xff08
argument_list|)
expr_stmt|;
comment|/* bit mask */
name|outw
argument_list|(
name|GDCIDX
argument_list|,
operator|(
name|color
operator|<<
literal|8
operator|)
operator||
literal|0x00
argument_list|)
expr_stmt|;
comment|/* set/reset */
name|p
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|scp
operator|->
name|adp
operator|->
name|va_window
operator|)
expr_stmt|;
name|xoff
operator|=
name|scp
operator|->
name|xoff
expr_stmt|;
name|yoff
operator|=
name|scp
operator|->
name|yoff
operator|*
name|scp
operator|->
name|font_size
expr_stmt|;
name|xlen
operator|=
name|scp
operator|->
name|xpixel
operator|/
literal|8
expr_stmt|;
name|ylen
operator|=
name|scp
operator|->
name|ysize
operator|*
name|scp
operator|->
name|font_size
expr_stmt|;
if|if
condition|(
name|yoff
operator|>
literal|0
condition|)
block|{
name|generic_bzero
argument_list|(
name|p
argument_list|,
name|xlen
operator|*
name|yoff
argument_list|)
expr_stmt|;
name|generic_bzero
argument_list|(
name|p
operator|+
name|xlen
operator|*
operator|(
name|yoff
operator|+
name|ylen
operator|)
argument_list|,
name|xlen
operator|*
name|scp
operator|->
name|ypixel
operator|-
name|xlen
operator|*
operator|(
name|yoff
operator|+
name|ylen
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xoff
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ylen
condition|;
operator|++
name|i
control|)
block|{
name|generic_bzero
argument_list|(
name|p
operator|+
name|xlen
operator|*
operator|(
name|yoff
operator|+
name|i
operator|)
argument_list|,
name|xoff
argument_list|)
expr_stmt|;
name|generic_bzero
argument_list|(
name|p
operator|+
name|xlen
operator|*
operator|(
name|yoff
operator|+
name|i
operator|)
operator|+
name|xoff
operator|+
name|scp
operator|->
name|xsize
argument_list|,
name|xlen
operator|-
name|xoff
operator|-
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
block|}
block|}
name|outw
argument_list|(
name|GDCIDX
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
comment|/* set/reset */
name|outw
argument_list|(
name|GDCIDX
argument_list|,
literal|0x0001
argument_list|)
expr_stmt|;
comment|/* set/reset enable */
block|}
block|}
end_function

begin_function
name|void
name|copy_font
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|operation
parameter_list|,
name|int
name|font_size
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|)
block|{
comment|/*      * FONT KLUDGE:      * This is an interim kludge to display correct font.      * Always use the font page #0 on the video plane 2.      * Somehow we cannot show the font in other font pages on      * some video cards... XXX      */
name|font_loading_in_progress
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|operation
operator|==
name|LOAD
condition|)
block|{
operator|(
operator|*
name|vidsw
index|[
name|scp
operator|->
name|ad
index|]
operator|->
name|load_font
operator|)
operator|(
name|scp
operator|->
name|adp
operator|,
literal|0
operator|,
name|font_size
operator|,
name|buf
operator|,
literal|0
operator|,
literal|256
operator|)
expr_stmt|;
if|if
condition|(
name|sc_flags
operator|&
name|CHAR_CURSOR
condition|)
name|set_destructive_cursor
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|operation
operator|==
name|SAVE
condition|)
block|{
operator|(
operator|*
name|vidsw
index|[
name|scp
operator|->
name|ad
index|]
operator|->
name|save_font
operator|)
operator|(
name|scp
operator|->
name|adp
operator|,
literal|0
operator|,
name|font_size
operator|,
name|buf
operator|,
literal|0
operator|,
literal|256
operator|)
expr_stmt|;
block|}
name|font_loading_in_progress
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_destructive_cursor
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|u_char
name|cursor
index|[
literal|32
index|]
decl_stmt|;
name|u_char
modifier|*
name|font_buffer
decl_stmt|;
name|int
name|font_size
decl_stmt|;
name|int
name|crtc_addr
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|ISFONTAVAIL
argument_list|(
name|scp
operator|->
name|adp
operator|->
name|va_flags
argument_list|)
operator|||
operator|(
name|scp
operator|->
name|status
operator|&
operator|(
name|GRAPHICS_MODE
operator||
name|PIXEL_MODE
operator|)
operator|)
condition|)
return|return;
if|if
condition|(
name|scp
operator|->
name|font_size
operator|<
literal|14
condition|)
block|{
name|font_buffer
operator|=
name|font_8
expr_stmt|;
name|font_size
operator|=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scp
operator|->
name|font_size
operator|>=
literal|16
condition|)
block|{
name|font_buffer
operator|=
name|font_16
expr_stmt|;
name|font_size
operator|=
literal|16
expr_stmt|;
block|}
else|else
block|{
name|font_buffer
operator|=
name|font_14
expr_stmt|;
name|font_size
operator|=
literal|14
expr_stmt|;
block|}
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_VISIBLE
condition|)
block|{
if|if
condition|(
operator|(
name|scp
operator|->
name|cursor_saveunder
operator|&
literal|0xff
operator|)
operator|==
name|SC_MOUSE_CHAR
condition|)
name|bcopy
argument_list|(
operator|&
name|scp
operator|->
name|mouse_cursor
index|[
literal|0
index|]
argument_list|,
name|cursor
argument_list|,
name|scp
operator|->
name|font_size
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|scp
operator|->
name|cursor_saveunder
operator|&
literal|0xff
operator|)
operator|==
name|SC_MOUSE_CHAR
operator|+
literal|1
condition|)
name|bcopy
argument_list|(
operator|&
name|scp
operator|->
name|mouse_cursor
index|[
literal|32
index|]
argument_list|,
name|cursor
argument_list|,
name|scp
operator|->
name|font_size
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|scp
operator|->
name|cursor_saveunder
operator|&
literal|0xff
operator|)
operator|==
name|SC_MOUSE_CHAR
operator|+
literal|2
condition|)
name|bcopy
argument_list|(
operator|&
name|scp
operator|->
name|mouse_cursor
index|[
literal|64
index|]
argument_list|,
name|cursor
argument_list|,
name|scp
operator|->
name|font_size
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|scp
operator|->
name|cursor_saveunder
operator|&
literal|0xff
operator|)
operator|==
name|SC_MOUSE_CHAR
operator|+
literal|3
condition|)
name|bcopy
argument_list|(
operator|&
name|scp
operator|->
name|mouse_cursor
index|[
literal|96
index|]
argument_list|,
name|cursor
argument_list|,
name|scp
operator|->
name|font_size
argument_list|)
expr_stmt|;
else|else
name|bcopy
argument_list|(
name|font_buffer
operator|+
operator|(
operator|(
name|scp
operator|->
name|cursor_saveunder
operator|&
literal|0xff
operator|)
operator|*
name|scp
operator|->
name|font_size
operator|)
argument_list|,
name|cursor
argument_list|,
name|scp
operator|->
name|font_size
argument_list|)
expr_stmt|;
block|}
else|else
name|bcopy
argument_list|(
name|font_buffer
operator|+
operator|(
operator|(
name|scp
operator|->
name|cursor_saveunder
operator|&
literal|0xff
operator|)
operator|*
name|scp
operator|->
name|font_size
operator|)
argument_list|,
name|cursor
argument_list|,
name|scp
operator|->
name|font_size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|i
operator|>=
name|scp
operator|->
name|cursor_start
operator|&&
name|i
operator|<=
name|scp
operator|->
name|cursor_end
operator|)
operator|||
operator|(
name|scp
operator|->
name|cursor_start
operator|>=
name|scp
operator|->
name|font_size
operator|&&
name|i
operator|==
name|scp
operator|->
name|font_size
operator|-
literal|1
operator|)
condition|)
name|cursor
index|[
name|i
index|]
operator||=
literal|0xff
expr_stmt|;
if|#
directive|if
literal|1
name|crtc_addr
operator|=
name|scp
operator|->
name|adp
operator|->
name|va_crtc_addr
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|crtc_addr
operator|+
literal|6
argument_list|)
operator|&
literal|0x08
operator|)
condition|)
comment|/* wait for vertical retrace */
empty_stmt|;
endif|#
directive|endif
name|font_loading_in_progress
operator|=
name|TRUE
expr_stmt|;
operator|(
operator|*
name|vidsw
index|[
name|scp
operator|->
name|ad
index|]
operator|->
name|load_font
operator|)
operator|(
name|scp
operator|->
name|adp
operator|,
literal|0
operator|,
name|font_size
operator|,
name|cursor
operator|,
name|DEAD_CHAR
operator|,
literal|1
operator|)
expr_stmt|;
name|font_loading_in_progress
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sc_move_mouse
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
name|scp
operator|->
name|mouse_xpos
operator|=
name|x
expr_stmt|;
name|scp
operator|->
name|mouse_ypos
operator|=
name|y
expr_stmt|;
name|scp
operator|->
name|mouse_pos
operator|=
name|scp
operator|->
name|mouse_oldpos
operator|=
name|scp
operator|->
name|scr_buf
operator|+
operator|(
name|y
operator|/
name|scp
operator|->
name|font_size
operator|)
operator|*
name|scp
operator|->
name|xsize
operator|+
name|x
operator|/
literal|8
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_mouse_pos
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
specifier|static
name|int
name|last_xpos
init|=
operator|-
literal|1
decl_stmt|,
name|last_ypos
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|scp
operator|->
name|mouse_xpos
operator|<
literal|0
condition|)
name|scp
operator|->
name|mouse_xpos
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|mouse_ypos
operator|<
literal|0
condition|)
name|scp
operator|->
name|mouse_ypos
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|ISTEXTSC
argument_list|(
name|scp
argument_list|)
condition|)
block|{
if|if
condition|(
name|scp
operator|->
name|mouse_xpos
operator|>
name|scp
operator|->
name|xpixel
operator|-
literal|1
condition|)
name|scp
operator|->
name|mouse_xpos
operator|=
name|scp
operator|->
name|xpixel
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|mouse_ypos
operator|>
name|scp
operator|->
name|ypixel
operator|-
literal|1
condition|)
name|scp
operator|->
name|mouse_ypos
operator|=
name|scp
operator|->
name|ypixel
operator|-
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|scp
operator|->
name|mouse_xpos
operator|>
operator|(
name|scp
operator|->
name|xsize
operator|*
literal|8
operator|)
operator|-
literal|1
condition|)
name|scp
operator|->
name|mouse_xpos
operator|=
operator|(
name|scp
operator|->
name|xsize
operator|*
literal|8
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|mouse_ypos
operator|>
operator|(
name|scp
operator|->
name|ysize
operator|*
name|scp
operator|->
name|font_size
operator|)
operator|-
literal|1
condition|)
name|scp
operator|->
name|mouse_ypos
operator|=
operator|(
name|scp
operator|->
name|ysize
operator|*
name|scp
operator|->
name|font_size
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|mouse_xpos
operator|!=
name|last_xpos
operator|||
name|scp
operator|->
name|mouse_ypos
operator|!=
name|last_ypos
condition|)
block|{
name|scp
operator|->
name|status
operator||=
name|MOUSE_MOVED
expr_stmt|;
name|scp
operator|->
name|mouse_pos
operator|=
name|scp
operator|->
name|scr_buf
operator|+
operator|(
operator|(
name|scp
operator|->
name|mouse_ypos
operator|/
name|scp
operator|->
name|font_size
operator|)
operator|*
name|scp
operator|->
name|xsize
operator|+
name|scp
operator|->
name|mouse_xpos
operator|/
literal|8
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_VISIBLE
operator|)
operator|&&
operator|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_CUTTING
operator|)
condition|)
name|mouse_cut
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|isspace
parameter_list|(
name|c
parameter_list|)
value|(((c)& 0xff) == ' ')
end_define

begin_function
specifier|static
name|int
name|skip_spc_right
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|u_short
modifier|*
name|p
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|p
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|%
name|scp
operator|->
name|xsize
init|;
name|i
operator|<
name|scp
operator|->
name|xsize
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
break|break;
operator|++
name|p
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|skip_spc_left
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|u_short
modifier|*
name|p
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|p
operator|--
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|%
name|scp
operator|->
name|xsize
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
break|break;
operator|--
name|p
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mouse_cut
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|u_short
modifier|*
name|end
decl_stmt|;
name|u_short
modifier|*
name|p
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
name|scp
operator|->
name|mouse_cut_end
operator|=
operator|(
name|scp
operator|->
name|mouse_pos
operator|>=
name|scp
operator|->
name|mouse_cut_start
operator|)
condition|?
name|scp
operator|->
name|mouse_pos
operator|+
literal|1
else|:
name|scp
operator|->
name|mouse_pos
expr_stmt|;
name|end
operator|=
operator|(
name|scp
operator|->
name|mouse_cut_start
operator|>
name|scp
operator|->
name|mouse_cut_end
operator|)
condition|?
name|scp
operator|->
name|mouse_cut_start
else|:
name|scp
operator|->
name|mouse_cut_end
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|(
name|scp
operator|->
name|mouse_cut_start
operator|>
name|scp
operator|->
name|mouse_cut_end
operator|)
condition|?
name|scp
operator|->
name|mouse_cut_end
else|:
name|scp
operator|->
name|mouse_cut_start
init|;
name|p
operator|<
name|end
condition|;
operator|++
name|p
control|)
block|{
name|cut_buffer
index|[
name|i
index|]
operator|=
operator|*
name|p
operator|&
literal|0xff
expr_stmt|;
comment|/* remember the position of the last non-space char */
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|cut_buffer
index|[
name|i
operator|++
index|]
argument_list|)
condition|)
name|j
operator|=
name|i
expr_stmt|;
comment|/* trim trailing blank when crossing lines */
if|if
condition|(
operator|(
operator|(
name|p
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|%
name|scp
operator|->
name|xsize
operator|)
operator|==
operator|(
name|scp
operator|->
name|xsize
operator|-
literal|1
operator|)
condition|)
block|{
name|cut_buffer
index|[
name|j
operator|++
index|]
operator|=
literal|'\r'
expr_stmt|;
name|i
operator|=
name|j
expr_stmt|;
block|}
block|}
name|cut_buffer
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* scan towards the end of the last line */
operator|--
name|p
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|p
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|%
name|scp
operator|->
name|xsize
init|;
name|i
operator|<
name|scp
operator|->
name|xsize
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
break|break;
operator|++
name|p
expr_stmt|;
block|}
comment|/* if there is nothing but blank chars, trim them, but mark towards eol */
if|if
condition|(
name|i
operator|>=
name|scp
operator|->
name|xsize
condition|)
block|{
if|if
condition|(
name|scp
operator|->
name|mouse_cut_start
operator|>
name|scp
operator|->
name|mouse_cut_end
condition|)
name|scp
operator|->
name|mouse_cut_start
operator|=
name|p
expr_stmt|;
else|else
name|scp
operator|->
name|mouse_cut_end
operator|=
name|p
expr_stmt|;
name|cut_buffer
index|[
name|j
operator|++
index|]
operator|=
literal|'\r'
expr_stmt|;
name|cut_buffer
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|mouse_cut_start
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|mouse_cut_end
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mouse_cut_start
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_VISIBLE
condition|)
block|{
if|if
condition|(
name|scp
operator|->
name|mouse_pos
operator|==
name|scp
operator|->
name|mouse_cut_start
operator|&&
name|scp
operator|->
name|mouse_cut_start
operator|==
name|scp
operator|->
name|mouse_cut_end
operator|-
literal|1
condition|)
block|{
name|cut_buffer
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|remove_cutmarking
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|skip_spc_right
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|mouse_pos
argument_list|)
operator|>=
name|scp
operator|->
name|xsize
condition|)
block|{
comment|/* if the pointer is on trailing blank chars, mark towards eol */
name|i
operator|=
name|skip_spc_left
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|mouse_pos
argument_list|)
operator|+
literal|1
expr_stmt|;
name|scp
operator|->
name|mouse_cut_start
operator|=
name|scp
operator|->
name|scr_buf
operator|+
operator|(
operator|(
name|scp
operator|->
name|mouse_pos
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|/
name|scp
operator|->
name|xsize
operator|)
operator|*
name|scp
operator|->
name|xsize
operator|+
name|i
expr_stmt|;
name|scp
operator|->
name|mouse_cut_end
operator|=
name|scp
operator|->
name|scr_buf
operator|+
operator|(
operator|(
name|scp
operator|->
name|mouse_pos
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|/
name|scp
operator|->
name|xsize
operator|+
literal|1
operator|)
operator|*
name|scp
operator|->
name|xsize
expr_stmt|;
name|cut_buffer
index|[
literal|0
index|]
operator|=
literal|'\r'
expr_stmt|;
name|cut_buffer
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|scp
operator|->
name|status
operator||=
name|MOUSE_CUTTING
expr_stmt|;
block|}
else|else
block|{
name|scp
operator|->
name|mouse_cut_start
operator|=
name|scp
operator|->
name|mouse_pos
expr_stmt|;
name|scp
operator|->
name|mouse_cut_end
operator|=
name|scp
operator|->
name|mouse_cut_start
operator|+
literal|1
expr_stmt|;
name|cut_buffer
index|[
literal|0
index|]
operator|=
operator|*
name|scp
operator|->
name|mouse_cut_start
operator|&
literal|0xff
expr_stmt|;
name|cut_buffer
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|scp
operator|->
name|status
operator||=
name|MOUSE_CUTTING
expr_stmt|;
block|}
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
comment|/* delete all other screens cut markings */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXCONS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|console
index|[
name|i
index|]
operator|==
name|NULL
operator|||
name|console
index|[
name|i
index|]
operator|==
name|scp
condition|)
continue|continue;
name|remove_cutmarking
argument_list|(
name|console
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mouse_cut_end
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_VISIBLE
condition|)
block|{
name|scp
operator|->
name|status
operator|&=
operator|~
name|MOUSE_CUTTING
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mouse_cut_word
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|u_short
modifier|*
name|p
decl_stmt|;
name|u_short
modifier|*
name|sol
decl_stmt|;
name|u_short
modifier|*
name|eol
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/*      * Because we don't have locale information in the kernel,      * we only distinguish space char and non-space chars.  Punctuation      * chars, symbols and other regular chars are all treated alike.      */
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_VISIBLE
condition|)
block|{
name|sol
operator|=
name|scp
operator|->
name|scr_buf
operator|+
operator|(
operator|(
name|scp
operator|->
name|mouse_pos
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|/
name|scp
operator|->
name|xsize
operator|)
operator|*
name|scp
operator|->
name|xsize
expr_stmt|;
name|eol
operator|=
name|sol
operator|+
name|scp
operator|->
name|xsize
expr_stmt|;
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|scp
operator|->
name|mouse_pos
argument_list|)
condition|)
block|{
for|for
control|(
name|p
operator|=
name|scp
operator|->
name|mouse_pos
init|;
name|p
operator|>=
name|sol
condition|;
operator|--
name|p
control|)
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
break|break;
name|scp
operator|->
name|mouse_cut_start
operator|=
operator|++
name|p
expr_stmt|;
for|for
control|(
name|p
operator|=
name|scp
operator|->
name|mouse_pos
init|;
name|p
operator|<
name|eol
condition|;
operator|++
name|p
control|)
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
break|break;
name|scp
operator|->
name|mouse_cut_end
operator|=
name|p
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|p
operator|=
name|scp
operator|->
name|mouse_pos
init|;
name|p
operator|>=
name|sol
condition|;
operator|--
name|p
control|)
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
break|break;
name|scp
operator|->
name|mouse_cut_start
operator|=
operator|++
name|p
expr_stmt|;
for|for
control|(
name|p
operator|=
name|scp
operator|->
name|mouse_pos
init|;
name|p
operator|<
name|eol
condition|;
operator|++
name|p
control|)
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
break|break;
name|scp
operator|->
name|mouse_cut_end
operator|=
name|p
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|scp
operator|->
name|mouse_cut_start
init|;
name|p
operator|<
name|scp
operator|->
name|mouse_cut_end
condition|;
operator|++
name|p
control|)
name|cut_buffer
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|p
operator|&
literal|0xff
expr_stmt|;
name|cut_buffer
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|scp
operator|->
name|status
operator||=
name|MOUSE_CUTTING
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mouse_cut_line
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|u_short
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_VISIBLE
condition|)
block|{
name|scp
operator|->
name|mouse_cut_start
operator|=
name|scp
operator|->
name|scr_buf
operator|+
operator|(
operator|(
name|scp
operator|->
name|mouse_pos
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|/
name|scp
operator|->
name|xsize
operator|)
operator|*
name|scp
operator|->
name|xsize
expr_stmt|;
name|scp
operator|->
name|mouse_cut_end
operator|=
name|scp
operator|->
name|mouse_cut_start
operator|+
name|scp
operator|->
name|xsize
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|scp
operator|->
name|mouse_cut_start
init|;
name|p
operator|<
name|scp
operator|->
name|mouse_cut_end
condition|;
operator|++
name|p
control|)
name|cut_buffer
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|p
operator|&
literal|0xff
expr_stmt|;
name|cut_buffer
index|[
name|i
operator|++
index|]
operator|=
literal|'\r'
expr_stmt|;
name|cut_buffer
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|scp
operator|->
name|status
operator||=
name|MOUSE_CUTTING
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mouse_cut_extend
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
if|if
condition|(
operator|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_VISIBLE
operator|)
operator|&&
operator|!
operator|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_CUTTING
operator|)
operator|&&
operator|(
name|scp
operator|->
name|mouse_cut_start
operator|!=
name|NULL
operator|)
condition|)
block|{
name|mouse_cut
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|scp
operator|->
name|status
operator||=
name|MOUSE_CUTTING
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mouse_paste
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_VISIBLE
condition|)
block|{
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|u_char
modifier|*
name|ptr
init|=
name|cut_buffer
decl_stmt|;
name|tp
operator|=
name|VIRTUAL_TTY
argument_list|(
name|get_scr_num
argument_list|()
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
condition|)
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|scr_rmap
index|[
operator|*
name|ptr
operator|++
index|]
operator|,
name|tp
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|draw_mouse_image
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|u_short
name|buffer
index|[
literal|32
index|]
decl_stmt|;
name|u_short
name|xoffset
decl_stmt|,
name|yoffset
decl_stmt|;
name|u_short
modifier|*
name|crt_pos
init|=
operator|(
name|u_short
operator|*
operator|)
operator|(
name|scp
operator|->
name|adp
operator|->
name|va_window
operator|)
operator|+
operator|(
name|scp
operator|->
name|mouse_pos
operator|-
name|scp
operator|->
name|scr_buf
operator|)
decl_stmt|;
name|u_char
modifier|*
name|font_buffer
decl_stmt|;
name|int
name|font_size
decl_stmt|;
name|int
name|crtc_addr
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|scp
operator|->
name|font_size
operator|<
literal|14
condition|)
block|{
name|font_buffer
operator|=
name|font_8
expr_stmt|;
name|font_size
operator|=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scp
operator|->
name|font_size
operator|>=
literal|16
condition|)
block|{
name|font_buffer
operator|=
name|font_16
expr_stmt|;
name|font_size
operator|=
literal|16
expr_stmt|;
block|}
else|else
block|{
name|font_buffer
operator|=
name|font_14
expr_stmt|;
name|font_size
operator|=
literal|14
expr_stmt|;
block|}
name|xoffset
operator|=
name|scp
operator|->
name|mouse_xpos
operator|%
literal|8
expr_stmt|;
name|yoffset
operator|=
name|scp
operator|->
name|mouse_ypos
operator|%
name|scp
operator|->
name|font_size
expr_stmt|;
comment|/* prepare mousepointer char's bitmaps */
name|bcopy
argument_list|(
name|font_buffer
operator|+
operator|(
operator|(
operator|*
operator|(
name|scp
operator|->
name|mouse_pos
operator|)
operator|&
literal|0xff
operator|)
operator|*
name|font_size
operator|)
argument_list|,
operator|&
name|scp
operator|->
name|mouse_cursor
index|[
literal|0
index|]
argument_list|,
name|font_size
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|font_buffer
operator|+
operator|(
operator|(
operator|*
operator|(
name|scp
operator|->
name|mouse_pos
operator|+
literal|1
operator|)
operator|&
literal|0xff
operator|)
operator|*
name|font_size
operator|)
argument_list|,
operator|&
name|scp
operator|->
name|mouse_cursor
index|[
literal|32
index|]
argument_list|,
name|font_size
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|font_buffer
operator|+
operator|(
operator|(
operator|*
operator|(
name|scp
operator|->
name|mouse_pos
operator|+
name|scp
operator|->
name|xsize
operator|)
operator|&
literal|0xff
operator|)
operator|*
name|font_size
operator|)
argument_list|,
operator|&
name|scp
operator|->
name|mouse_cursor
index|[
literal|64
index|]
argument_list|,
name|font_size
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|font_buffer
operator|+
operator|(
operator|(
operator|*
operator|(
name|scp
operator|->
name|mouse_pos
operator|+
name|scp
operator|->
name|xsize
operator|+
literal|1
operator|)
operator|&
literal|0xff
operator|)
operator|*
name|font_size
operator|)
argument_list|,
operator|&
name|scp
operator|->
name|mouse_cursor
index|[
literal|96
index|]
argument_list|,
name|font_size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|font_size
condition|;
name|i
operator|++
control|)
block|{
name|buffer
index|[
name|i
index|]
operator|=
name|scp
operator|->
name|mouse_cursor
index|[
name|i
index|]
operator|<<
literal|8
operator||
name|scp
operator|->
name|mouse_cursor
index|[
name|i
operator|+
literal|32
index|]
expr_stmt|;
name|buffer
index|[
name|i
operator|+
name|font_size
index|]
operator|=
name|scp
operator|->
name|mouse_cursor
index|[
name|i
operator|+
literal|64
index|]
operator|<<
literal|8
operator||
name|scp
operator|->
name|mouse_cursor
index|[
name|i
operator|+
literal|96
index|]
expr_stmt|;
block|}
comment|/* now and-or in the mousepointer image */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|buffer
index|[
name|i
operator|+
name|yoffset
index|]
operator|=
operator|(
name|buffer
index|[
name|i
operator|+
name|yoffset
index|]
operator|&
operator|~
operator|(
name|mouse_and_mask
index|[
name|i
index|]
operator|>>
name|xoffset
operator|)
operator|)
operator||
operator|(
name|mouse_or_mask
index|[
name|i
index|]
operator|>>
name|xoffset
operator|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|font_size
condition|;
name|i
operator|++
control|)
block|{
name|scp
operator|->
name|mouse_cursor
index|[
name|i
index|]
operator|=
operator|(
name|buffer
index|[
name|i
index|]
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
expr_stmt|;
name|scp
operator|->
name|mouse_cursor
index|[
name|i
operator|+
literal|32
index|]
operator|=
name|buffer
index|[
name|i
index|]
operator|&
literal|0xff
expr_stmt|;
name|scp
operator|->
name|mouse_cursor
index|[
name|i
operator|+
literal|64
index|]
operator|=
operator|(
name|buffer
index|[
name|i
operator|+
name|font_size
index|]
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
expr_stmt|;
name|scp
operator|->
name|mouse_cursor
index|[
name|i
operator|+
literal|96
index|]
operator|=
name|buffer
index|[
name|i
operator|+
name|font_size
index|]
operator|&
literal|0xff
expr_stmt|;
block|}
name|scp
operator|->
name|mouse_oldpos
operator|=
name|scp
operator|->
name|mouse_pos
expr_stmt|;
if|#
directive|if
literal|1
comment|/* wait for vertical retrace to avoid jitter on some videocards */
name|crtc_addr
operator|=
name|scp
operator|->
name|adp
operator|->
name|va_crtc_addr
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|crtc_addr
operator|+
literal|6
argument_list|)
operator|&
literal|0x08
operator|)
condition|)
comment|/* idle */
empty_stmt|;
endif|#
directive|endif
name|font_loading_in_progress
operator|=
name|TRUE
expr_stmt|;
operator|(
operator|*
name|vidsw
index|[
name|scp
operator|->
name|ad
index|]
operator|->
name|load_font
operator|)
operator|(
name|scp
operator|->
name|adp
operator|,
literal|0
operator|,
literal|32
operator|,
name|scp
operator|->
name|mouse_cursor
operator|,
name|SC_MOUSE_CHAR
operator|,
literal|4
operator|)
expr_stmt|;
name|font_loading_in_progress
operator|=
name|FALSE
expr_stmt|;
operator|*
operator|(
name|crt_pos
operator|)
operator|=
operator|(
operator|*
operator|(
name|scp
operator|->
name|mouse_pos
operator|)
operator|&
literal|0xff00
operator|)
operator||
name|SC_MOUSE_CHAR
expr_stmt|;
operator|*
operator|(
name|crt_pos
operator|+
name|scp
operator|->
name|xsize
operator|)
operator|=
operator|(
operator|*
operator|(
name|scp
operator|->
name|mouse_pos
operator|+
name|scp
operator|->
name|xsize
operator|)
operator|&
literal|0xff00
operator|)
operator||
operator|(
name|SC_MOUSE_CHAR
operator|+
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|mouse_xpos
operator|<
operator|(
name|scp
operator|->
name|xsize
operator|-
literal|1
operator|)
operator|*
literal|8
condition|)
block|{
operator|*
operator|(
name|crt_pos
operator|+
literal|1
operator|)
operator|=
operator|(
operator|*
operator|(
name|scp
operator|->
name|mouse_pos
operator|+
literal|1
operator|)
operator|&
literal|0xff00
operator|)
operator||
operator|(
name|SC_MOUSE_CHAR
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
operator|(
name|crt_pos
operator|+
name|scp
operator|->
name|xsize
operator|+
literal|1
operator|)
operator|=
operator|(
operator|*
operator|(
name|scp
operator|->
name|mouse_pos
operator|+
name|scp
operator|->
name|xsize
operator|+
literal|1
operator|)
operator|&
literal|0xff00
operator|)
operator||
operator|(
name|SC_MOUSE_CHAR
operator|+
literal|3
operator|)
expr_stmt|;
block|}
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|mouse_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|mouse_pos
operator|+
name|scp
operator|->
name|xsize
operator|+
literal|1
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|remove_mouse_image
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|u_short
modifier|*
name|crt_pos
decl_stmt|;
if|if
condition|(
operator|!
name|ISTEXTSC
argument_list|(
name|scp
argument_list|)
condition|)
return|return;
name|crt_pos
operator|=
operator|(
name|u_short
operator|*
operator|)
operator|(
name|scp
operator|->
name|adp
operator|->
name|va_window
operator|)
operator|+
operator|(
name|scp
operator|->
name|mouse_oldpos
operator|-
name|scp
operator|->
name|scr_buf
operator|)
expr_stmt|;
operator|*
operator|(
name|crt_pos
operator|)
operator|=
operator|*
operator|(
name|scp
operator|->
name|mouse_oldpos
operator|)
expr_stmt|;
operator|*
operator|(
name|crt_pos
operator|+
literal|1
operator|)
operator|=
operator|*
operator|(
name|scp
operator|->
name|mouse_oldpos
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
operator|(
name|crt_pos
operator|+
name|scp
operator|->
name|xsize
operator|)
operator|=
operator|*
operator|(
name|scp
operator|->
name|mouse_oldpos
operator|+
name|scp
operator|->
name|xsize
operator|)
expr_stmt|;
operator|*
operator|(
name|crt_pos
operator|+
name|scp
operator|->
name|xsize
operator|+
literal|1
operator|)
operator|=
operator|*
operator|(
name|scp
operator|->
name|mouse_oldpos
operator|+
name|scp
operator|->
name|xsize
operator|+
literal|1
operator|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|mouse_oldpos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|mouse_oldpos
operator|+
name|scp
operator|->
name|xsize
operator|+
literal|1
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|draw_cutmarking
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|u_short
modifier|*
name|crt_pos
decl_stmt|;
name|u_short
modifier|*
name|ptr
decl_stmt|;
name|u_short
name|och
decl_stmt|,
name|nch
decl_stmt|;
name|crt_pos
operator|=
operator|(
name|u_short
operator|*
operator|)
operator|(
name|scp
operator|->
name|adp
operator|->
name|va_window
operator|)
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|scp
operator|->
name|scr_buf
init|;
name|ptr
operator|<=
operator|(
name|scp
operator|->
name|scr_buf
operator|+
operator|(
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
operator|)
operator|)
condition|;
name|ptr
operator|++
control|)
block|{
name|nch
operator|=
name|och
operator|=
operator|*
operator|(
name|crt_pos
operator|+
operator|(
name|ptr
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|)
expr_stmt|;
comment|/* are we outside the selected area ? */
if|if
condition|(
name|ptr
operator|<
operator|(
name|scp
operator|->
name|mouse_cut_start
operator|>
name|scp
operator|->
name|mouse_cut_end
condition|?
name|scp
operator|->
name|mouse_cut_end
else|:
name|scp
operator|->
name|mouse_cut_start
operator|)
operator|||
name|ptr
operator|>=
operator|(
name|scp
operator|->
name|mouse_cut_start
operator|>
name|scp
operator|->
name|mouse_cut_end
condition|?
name|scp
operator|->
name|mouse_cut_start
else|:
name|scp
operator|->
name|mouse_cut_end
operator|)
condition|)
block|{
if|if
condition|(
name|ptr
operator|!=
name|scp
operator|->
name|cursor_pos
condition|)
name|nch
operator|=
operator|(
name|och
operator|&
literal|0xff
operator|)
operator||
operator|(
operator|*
name|ptr
operator|&
literal|0xff00
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* are we clear of the cursor image ? */
if|if
condition|(
name|ptr
operator|!=
name|scp
operator|->
name|cursor_pos
condition|)
name|nch
operator|=
operator|(
name|och
operator|&
literal|0x88ff
operator|)
operator||
operator|(
operator|*
name|ptr
operator|&
literal|0x7000
operator|)
operator|>>
literal|4
operator||
operator|(
operator|*
name|ptr
operator|&
literal|0x0700
operator|)
operator|<<
literal|4
expr_stmt|;
else|else
block|{
if|if
condition|(
name|sc_flags
operator|&
name|CHAR_CURSOR
condition|)
name|nch
operator|=
operator|(
name|och
operator|&
literal|0x88ff
operator|)
operator||
operator|(
operator|*
name|ptr
operator|&
literal|0x7000
operator|)
operator|>>
literal|4
operator||
operator|(
operator|*
name|ptr
operator|&
literal|0x0700
operator|)
operator|<<
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|sc_flags
operator|&
name|BLINK_CURSOR
operator|)
condition|)
name|nch
operator|=
operator|(
name|och
operator|&
literal|0xff
operator|)
operator||
operator|(
operator|*
name|ptr
operator|&
literal|0xff00
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nch
operator|!=
name|och
condition|)
operator|*
operator|(
name|crt_pos
operator|+
operator|(
name|ptr
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|)
operator|=
name|nch
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|remove_cutmarking
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|scp
operator|->
name|mouse_cut_start
operator|=
name|scp
operator|->
name|mouse_cut_end
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|status
operator|&=
operator|~
name|MOUSE_CUTTING
expr_stmt|;
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_bell
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|pitch
parameter_list|,
name|int
name|duration
parameter_list|)
block|{
if|if
condition|(
name|cold
operator|||
name|shutdown_in_progress
condition|)
return|return;
if|if
condition|(
name|scp
operator|!=
name|cur_console
operator|&&
operator|(
name|sc_flags
operator|&
name|QUIET_BELL
operator|)
condition|)
return|return;
if|if
condition|(
name|sc_flags
operator|&
name|VISUAL_BELL
condition|)
block|{
if|if
condition|(
name|blink_in_progress
condition|)
return|return;
name|blink_in_progress
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|scp
operator|!=
name|cur_console
condition|)
name|blink_in_progress
operator|+=
literal|2
expr_stmt|;
name|blink_screen
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|scp
operator|!=
name|cur_console
condition|)
name|pitch
operator|*=
literal|2
expr_stmt|;
name|sysbeep
argument_list|(
name|pitch
argument_list|,
name|duration
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|blink_screen
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|scr_stat
modifier|*
name|scp
init|=
name|arg
decl_stmt|;
if|if
condition|(
operator|!
name|ISTEXTSC
argument_list|(
name|scp
argument_list|)
operator|||
operator|(
name|blink_in_progress
operator|<=
literal|1
operator|)
condition|)
block|{
name|blink_in_progress
operator|=
name|FALSE
expr_stmt|;
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
if|if
condition|(
name|delayed_next_scr
condition|)
name|switch_scr
argument_list|(
name|scp
argument_list|,
name|delayed_next_scr
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|blink_in_progress
operator|&
literal|1
condition|)
name|fillw
argument_list|(
name|kernel_default
operator|.
name|std_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
operator|(
name|u_short
operator|*
operator|)
operator|(
name|scp
operator|->
name|adp
operator|->
name|va_window
operator|)
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
argument_list|)
expr_stmt|;
else|else
name|fillw
argument_list|(
name|kernel_default
operator|.
name|rev_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
operator|(
name|u_short
operator|*
operator|)
operator|(
name|scp
operator|->
name|adp
operator|->
name|va_window
operator|)
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
argument_list|)
expr_stmt|;
name|blink_in_progress
operator|--
expr_stmt|;
name|timeout
argument_list|(
name|blink_screen
argument_list|,
name|scp
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sc_bcopy
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|u_short
modifier|*
name|p
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|,
name|int
name|mark
parameter_list|)
block|{
name|u_char
modifier|*
name|font
decl_stmt|;
name|u_char
specifier|volatile
modifier|*
name|d
decl_stmt|;
name|u_char
modifier|*
name|e
decl_stmt|;
name|u_char
modifier|*
name|f
decl_stmt|;
name|int
name|font_size
decl_stmt|;
name|int
name|line_length
decl_stmt|;
name|int
name|xsize
decl_stmt|;
name|u_short
name|bg
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|u_char
name|c
decl_stmt|;
if|if
condition|(
name|ISTEXTSC
argument_list|(
name|scp
argument_list|)
condition|)
block|{
name|generic_bcopy
argument_list|(
name|p
operator|+
name|from
argument_list|,
operator|(
name|u_short
operator|*
operator|)
operator|(
name|scp
operator|->
name|adp
operator|->
name|va_window
operator|)
operator|+
name|from
argument_list|,
operator|(
name|to
operator|-
name|from
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* if ISPIXELSC(scp) */
block|{
if|if
condition|(
name|mark
condition|)
name|mark
operator|=
literal|255
expr_stmt|;
name|font_size
operator|=
name|scp
operator|->
name|font_size
expr_stmt|;
if|if
condition|(
name|font_size
operator|<
literal|14
condition|)
name|font
operator|=
name|font_8
expr_stmt|;
elseif|else
if|if
condition|(
name|font_size
operator|>=
literal|16
condition|)
name|font
operator|=
name|font_16
expr_stmt|;
else|else
name|font
operator|=
name|font_14
expr_stmt|;
name|line_length
operator|=
name|scp
operator|->
name|xpixel
operator|/
literal|8
expr_stmt|;
name|xsize
operator|=
name|scp
operator|->
name|xsize
expr_stmt|;
name|d
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|scp
operator|->
name|adp
operator|->
name|va_window
operator|)
operator|+
name|scp
operator|->
name|xoff
operator|+
name|scp
operator|->
name|yoff
operator|*
name|font_size
operator|*
name|line_length
operator|+
operator|(
name|from
operator|%
name|xsize
operator|)
operator|+
name|font_size
operator|*
name|line_length
operator|*
operator|(
name|from
operator|/
name|xsize
operator|)
expr_stmt|;
name|outw
argument_list|(
name|GDCIDX
argument_list|,
literal|0x0005
argument_list|)
expr_stmt|;
comment|/* read mode 0, write mode 0 */
name|outw
argument_list|(
name|GDCIDX
argument_list|,
literal|0x0003
argument_list|)
expr_stmt|;
comment|/* data rotate/function select */
name|outw
argument_list|(
name|GDCIDX
argument_list|,
literal|0x0f01
argument_list|)
expr_stmt|;
comment|/* set/reset enable */
name|bg
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|from
init|;
name|i
operator|<=
name|to
condition|;
name|i
operator|++
control|)
block|{
comment|/* set background color in EGA/VGA latch */
if|if
condition|(
name|bg
operator|!=
operator|(
name|p
index|[
name|i
index|]
operator|&
literal|0xf000
operator|)
condition|)
block|{
name|bg
operator|=
operator|(
name|p
index|[
name|i
index|]
operator|&
literal|0xf000
operator|)
expr_stmt|;
name|outw
argument_list|(
name|GDCIDX
argument_list|,
operator|(
name|bg
operator|>>
literal|4
operator|)
operator||
literal|0x00
argument_list|)
expr_stmt|;
comment|/* set/reset */
name|outw
argument_list|(
name|GDCIDX
argument_list|,
literal|0xff08
argument_list|)
expr_stmt|;
comment|/* bit mask */
operator|*
name|d
operator|=
literal|0
expr_stmt|;
name|c
operator|=
operator|*
name|d
expr_stmt|;
comment|/* set the background color in the latch */
block|}
comment|/* foreground color */
name|outw
argument_list|(
name|GDCIDX
argument_list|,
operator|(
name|p
index|[
name|i
index|]
operator|&
literal|0x0f00
operator|)
operator||
literal|0x00
argument_list|)
expr_stmt|;
comment|/* set/reset */
name|e
operator|=
operator|(
name|u_char
operator|*
operator|)
name|d
expr_stmt|;
name|f
operator|=
operator|&
name|font
index|[
operator|(
name|p
index|[
name|i
index|]
operator|&
literal|0x00ff
operator|)
operator|*
name|font_size
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|font_size
condition|;
name|j
operator|++
operator|,
name|f
operator|++
control|)
block|{
name|outw
argument_list|(
name|GDCIDX
argument_list|,
operator|(
operator|(
operator|*
name|f
operator|^
name|mark
operator|)
operator|<<
literal|8
operator|)
operator||
literal|0x08
argument_list|)
expr_stmt|;
comment|/* bit mask */
operator|*
name|e
operator|=
literal|0
expr_stmt|;
name|e
operator|+=
name|line_length
expr_stmt|;
block|}
name|d
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|%
name|xsize
operator|)
operator|==
name|xsize
operator|-
literal|1
condition|)
name|d
operator|+=
name|scp
operator|->
name|xoff
operator|*
literal|2
operator|+
operator|(
name|font_size
operator|-
literal|1
operator|)
operator|*
name|line_length
expr_stmt|;
block|}
name|outw
argument_list|(
name|GDCIDX
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
comment|/* set/reset */
name|outw
argument_list|(
name|GDCIDX
argument_list|,
literal|0x0001
argument_list|)
expr_stmt|;
comment|/* set/reset enable */
name|outw
argument_list|(
name|GDCIDX
argument_list|,
literal|0xff08
argument_list|)
expr_stmt|;
comment|/* bit mask */
if|#
directive|if
literal|0
comment|/* VGA only */
block|outw(GDCIDX, 0x0305);
comment|/* read mode 0, write mode 3 */
block|outw(GDCIDX, 0x0003);
comment|/* data rotate/function select */
block|outw(GDCIDX, 0x0f01);
comment|/* set/reset enable */
block|outw(GDCIDX, 0xff08);
comment|/* bit mask */
block|bg = -1; 	for (i = from ; i<= to ; i++) {
comment|/* set background color in EGA/VGA latch */
block|if (bg != (p[i]& 0xf000)) { 		bg = (p[i]& 0xf000); 		outw(GDCIDX, 0x0005);
comment|/* read mode 0, write mode 0 */
block|outw(GDCIDX, (bg>> 4) | 0x00);
comment|/* set/reset */
block|*d = 0; 		c = *d;
comment|/* set the background color in the latch */
block|outw(GDCIDX, 0x0305);
comment|/* read mode 0, write mode 3 */
block|}
comment|/* foreground color */
block|outw(GDCIDX, (p[i]& 0x0f00) | 0x00);
comment|/* set/reset */
block|e = (u_char *)d; 	    f =&font[(p[i]& 0x00ff)*font_size]; 	    for (j = 0 ; j< font_size; j++, f++) { 	        *e = *f^mark; 		e += line_length; 	    } 	    d++; 	    if ((i % xsize) == xsize - 1) 		d += scp->xoff*2 + (font_size - 1)*line_length; 	} 	outw(GDCIDX, 0x0005);
comment|/* read mode 0, write mode 0 */
block|outw(GDCIDX, 0x0000);
comment|/* set/reset */
block|outw(GDCIDX, 0x0001);
comment|/* set/reset enable */
endif|#
directive|endif
comment|/* 0 */
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NSC */
end_comment

end_unit

