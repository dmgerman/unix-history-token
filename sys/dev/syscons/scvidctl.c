begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1998 Kazutaka YOKOTA<yokota@zodiac.mech.utsunomiya-u.ac.jp>  * All rights reserved.  *  * This code is derived from software contributed to The DragonFly Project  * by Sascha Wildner<saw@online.de>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer as  *    the first lines of this file unmodified.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_compat.h"
end_include

begin_include
include|#
directive|include
file|"opt_syscons.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/fbio.h>
end_include

begin_include
include|#
directive|include
file|<sys/consio.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<dev/fb/fbreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/syscons/syscons.h>
end_include

begin_expr_stmt
name|SET_DECLARE
argument_list|(
name|scrndr_set
argument_list|,
specifier|const
name|sc_renderer_t
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* for compatibility with previous versions */
end_comment

begin_comment
comment|/* 3.0-RELEASE used the following structure */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|old_video_adapter
block|{
name|int
name|va_index
decl_stmt|;
name|int
name|va_type
decl_stmt|;
name|int
name|va_flags
decl_stmt|;
comment|/* flag bits are the same as the -CURRENT #define V_ADP_COLOR	(1<<0) #define V_ADP_MODECHANGE (1<<1) #define V_ADP_STATESAVE	(1<<2) #define V_ADP_STATELOAD	(1<<3) #define V_ADP_FONT	(1<<4) #define V_ADP_PALETTE	(1<<5) #define V_ADP_BORDER	(1<<6) #define V_ADP_VESA	(1<<7) */
name|int
name|va_crtc_addr
decl_stmt|;
name|u_int
name|va_window
decl_stmt|;
comment|/* virtual address */
name|size_t
name|va_window_size
decl_stmt|;
name|size_t
name|va_window_gran
decl_stmt|;
name|u_int
name|va_buffer
decl_stmt|;
comment|/* virtual address */
name|size_t
name|va_buffer_size
decl_stmt|;
name|int
name|va_initial_mode
decl_stmt|;
name|int
name|va_initial_bios_mode
decl_stmt|;
name|int
name|va_mode
decl_stmt|;
block|}
name|old_video_adapter_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|OLD_CONS_ADPINFO
value|_IOWR('c', 101, old_video_adapter_t)
end_define

begin_comment
comment|/* 3.1-RELEASE used the following structure */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|old_video_adapter_info
block|{
name|int
name|va_index
decl_stmt|;
name|int
name|va_type
decl_stmt|;
name|char
name|va_name
index|[
literal|16
index|]
decl_stmt|;
name|int
name|va_unit
decl_stmt|;
name|int
name|va_flags
decl_stmt|;
name|int
name|va_io_base
decl_stmt|;
name|int
name|va_io_size
decl_stmt|;
name|int
name|va_crtc_addr
decl_stmt|;
name|int
name|va_mem_base
decl_stmt|;
name|int
name|va_mem_size
decl_stmt|;
name|u_int
name|va_window
decl_stmt|;
comment|/* virtual address */
name|size_t
name|va_window_size
decl_stmt|;
name|size_t
name|va_window_gran
decl_stmt|;
name|u_int
name|va_buffer
decl_stmt|;
name|size_t
name|va_buffer_size
decl_stmt|;
name|int
name|va_initial_mode
decl_stmt|;
name|int
name|va_initial_bios_mode
decl_stmt|;
name|int
name|va_mode
decl_stmt|;
name|int
name|va_line_width
decl_stmt|;
block|}
name|old_video_adapter_info_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|OLD_CONS_ADPINFO2
value|_IOWR('c', 101, old_video_adapter_info_t)
end_define

begin_comment
comment|/* 3.0-RELEASE and 3.1-RELEASE used the following structure */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|old_video_info
block|{
name|int
name|vi_mode
decl_stmt|;
name|int
name|vi_flags
decl_stmt|;
comment|/* flag bits are the same as the -CURRENT #define V_INFO_COLOR	(1<<0) #define V_INFO_GRAPHICS	(1<<1) #define V_INFO_LINEAR	(1<<2) #define V_INFO_VESA	(1<<3) */
name|int
name|vi_width
decl_stmt|;
name|int
name|vi_height
decl_stmt|;
name|int
name|vi_cwidth
decl_stmt|;
name|int
name|vi_cheight
decl_stmt|;
name|int
name|vi_depth
decl_stmt|;
name|int
name|vi_planes
decl_stmt|;
name|u_int
name|vi_window
decl_stmt|;
comment|/* physical address */
name|size_t
name|vi_window_size
decl_stmt|;
name|size_t
name|vi_window_gran
decl_stmt|;
name|u_int
name|vi_buffer
decl_stmt|;
comment|/* physical address */
name|size_t
name|vi_buffer_size
decl_stmt|;
block|}
name|old_video_info_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|OLD_CONS_MODEINFO
value|_IOWR('c', 102, old_video_info_t)
end_define

begin_define
define|#
directive|define
name|OLD_CONS_FINDMODE
value|_IOWR('c', 103, old_video_info_t)
end_define

begin_function
name|int
name|sc_set_text_mode
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|int
name|mode
parameter_list|,
name|int
name|xsize
parameter_list|,
name|int
name|ysize
parameter_list|,
name|int
name|fontsize
parameter_list|,
name|int
name|fontwidth
parameter_list|)
block|{
name|video_info_t
name|info
decl_stmt|;
name|struct
name|winsize
name|wsz
decl_stmt|;
name|u_char
modifier|*
name|font
decl_stmt|;
name|int
name|prev_ysize
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|vidd_get_info
argument_list|(
name|scp
operator|->
name|sc
operator|->
name|adp
argument_list|,
name|mode
argument_list|,
operator|&
name|info
argument_list|)
condition|)
return|return
name|ENODEV
return|;
comment|/* adjust argument values */
if|if
condition|(
name|fontwidth
operator|<=
literal|0
condition|)
name|fontwidth
operator|=
name|info
operator|.
name|vi_cwidth
expr_stmt|;
if|if
condition|(
name|fontsize
operator|<=
literal|0
condition|)
name|fontsize
operator|=
name|info
operator|.
name|vi_cheight
expr_stmt|;
if|if
condition|(
name|fontsize
operator|<
literal|14
condition|)
name|fontsize
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|fontsize
operator|>=
literal|16
condition|)
name|fontsize
operator|=
literal|16
expr_stmt|;
else|else
name|fontsize
operator|=
literal|14
expr_stmt|;
ifndef|#
directive|ifndef
name|SC_NO_FONT_LOADING
switch|switch
condition|(
name|fontsize
condition|)
block|{
case|case
literal|8
case|:
if|if
condition|(
operator|(
name|scp
operator|->
name|sc
operator|->
name|fonts_loaded
operator|&
name|FONT_8
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|font
operator|=
name|scp
operator|->
name|sc
operator|->
name|font_8
expr_stmt|;
break|break;
case|case
literal|14
case|:
if|if
condition|(
operator|(
name|scp
operator|->
name|sc
operator|->
name|fonts_loaded
operator|&
name|FONT_14
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|font
operator|=
name|scp
operator|->
name|sc
operator|->
name|font_14
expr_stmt|;
break|break;
case|case
literal|16
case|:
if|if
condition|(
operator|(
name|scp
operator|->
name|sc
operator|->
name|fonts_loaded
operator|&
name|FONT_16
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|font
operator|=
name|scp
operator|->
name|sc
operator|->
name|font_16
expr_stmt|;
break|break;
block|}
else|#
directive|else
name|font
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|xsize
operator|<=
literal|0
operator|)
operator|||
operator|(
name|xsize
operator|>
name|info
operator|.
name|vi_width
operator|)
condition|)
name|xsize
operator|=
name|info
operator|.
name|vi_width
expr_stmt|;
if|if
condition|(
operator|(
name|ysize
operator|<=
literal|0
operator|)
operator|||
operator|(
name|ysize
operator|>
name|info
operator|.
name|vi_height
operator|)
condition|)
name|ysize
operator|=
name|info
operator|.
name|vi_height
expr_stmt|;
comment|/* stop screen saver, etc */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|sc_clean_up
argument_list|(
name|scp
argument_list|)
operator|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
name|sc_render_match
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|sc
operator|->
name|adp
operator|->
name|va_name
argument_list|,
literal|0
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ENODEV
return|;
block|}
comment|/* set up scp */
ifndef|#
directive|ifndef
name|SC_NO_HISTORY
if|if
condition|(
name|scp
operator|->
name|history
operator|!=
name|NULL
condition|)
name|sc_hist_save
argument_list|(
name|scp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|prev_ysize
operator|=
name|scp
operator|->
name|ysize
expr_stmt|;
comment|/*      * This is a kludge to fend off scrn_update() while we      * muck around with scp. XXX      */
name|scp
operator|->
name|status
operator||=
name|UNKNOWN_MODE
operator||
name|MOUSE_HIDDEN
expr_stmt|;
name|scp
operator|->
name|status
operator|&=
operator|~
operator|(
name|GRAPHICS_MODE
operator||
name|PIXEL_MODE
operator||
name|MOUSE_VISIBLE
operator|)
expr_stmt|;
name|scp
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
name|scp
operator|->
name|xsize
operator|=
name|xsize
expr_stmt|;
name|scp
operator|->
name|ysize
operator|=
name|ysize
expr_stmt|;
name|scp
operator|->
name|xoff
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|yoff
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|xpixel
operator|=
name|scp
operator|->
name|xsize
operator|*
literal|8
expr_stmt|;
name|scp
operator|->
name|ypixel
operator|=
name|scp
operator|->
name|ysize
operator|*
name|fontsize
expr_stmt|;
name|scp
operator|->
name|font
operator|=
name|font
expr_stmt|;
name|scp
operator|->
name|font_size
operator|=
name|fontsize
expr_stmt|;
name|scp
operator|->
name|font_width
operator|=
name|fontwidth
expr_stmt|;
comment|/* allocate buffers */
name|sc_alloc_scr_buffer
argument_list|(
name|scp
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|sc_init_emulator
argument_list|(
name|scp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SC_NO_CUTPASTE
name|sc_alloc_cut_buffer
argument_list|(
name|scp
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|SC_NO_HISTORY
name|sc_alloc_history_buffer
argument_list|(
name|scp
argument_list|,
literal|0
argument_list|,
name|prev_ysize
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|==
name|scp
operator|->
name|sc
operator|->
name|cur_scp
condition|)
name|set_mode
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|scp
operator|->
name|status
operator|&=
operator|~
name|UNKNOWN_MODE
expr_stmt|;
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|wsz
operator|.
name|ws_col
operator|=
name|scp
operator|->
name|xsize
expr_stmt|;
name|wsz
operator|.
name|ws_row
operator|=
name|scp
operator|->
name|ysize
expr_stmt|;
name|tty_set_winsize
argument_list|(
name|tp
argument_list|,
operator|&
name|wsz
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|sc_set_graphics_mode
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SC_NO_MODE_CHANGE
return|return
name|ENODEV
return|;
else|#
directive|else
name|video_info_t
name|info
decl_stmt|;
name|struct
name|winsize
name|wsz
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|vidd_get_info
argument_list|(
name|scp
operator|->
name|sc
operator|->
name|adp
argument_list|,
name|mode
argument_list|,
operator|&
name|info
argument_list|)
condition|)
return|return
name|ENODEV
return|;
comment|/* stop screen saver, etc */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|sc_clean_up
argument_list|(
name|scp
argument_list|)
operator|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
name|sc_render_match
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|sc
operator|->
name|adp
operator|->
name|va_name
argument_list|,
name|GRAPHICS_MODE
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ENODEV
return|;
block|}
comment|/* set up scp */
name|scp
operator|->
name|status
operator||=
operator|(
name|UNKNOWN_MODE
operator||
name|GRAPHICS_MODE
operator||
name|MOUSE_HIDDEN
operator|)
expr_stmt|;
name|scp
operator|->
name|status
operator|&=
operator|~
operator|(
name|PIXEL_MODE
operator||
name|MOUSE_VISIBLE
operator|)
expr_stmt|;
name|scp
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
comment|/*      * Don't change xsize and ysize; preserve the previous vty      * and history buffers.      */
name|scp
operator|->
name|xoff
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|yoff
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|xpixel
operator|=
name|info
operator|.
name|vi_width
expr_stmt|;
name|scp
operator|->
name|ypixel
operator|=
name|info
operator|.
name|vi_height
expr_stmt|;
name|scp
operator|->
name|font
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|font_size
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|SC_NO_SYSMOUSE
comment|/* move the mouse cursor at the center of the screen */
name|sc_mouse_move
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|xpixel
operator|/
literal|2
argument_list|,
name|scp
operator|->
name|ypixel
operator|/
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc_init_emulator
argument_list|(
name|scp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|==
name|scp
operator|->
name|sc
operator|->
name|cur_scp
condition|)
name|set_mode
argument_list|(
name|scp
argument_list|)
expr_stmt|;
comment|/* clear_graphics();*/
name|scp
operator|->
name|status
operator|&=
operator|~
name|UNKNOWN_MODE
expr_stmt|;
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|wsz
operator|.
name|ws_col
operator|=
name|scp
operator|->
name|xsize
expr_stmt|;
name|wsz
operator|.
name|ws_row
operator|=
name|scp
operator|->
name|ysize
expr_stmt|;
name|tty_set_winsize
argument_list|(
name|tp
argument_list|,
operator|&
name|wsz
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* SC_NO_MODE_CHANGE */
block|}
end_function

begin_function
name|int
name|sc_set_pixel_mode
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|int
name|xsize
parameter_list|,
name|int
name|ysize
parameter_list|,
name|int
name|fontsize
parameter_list|,
name|int
name|fontwidth
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|SC_PIXEL_MODE
return|return
name|ENODEV
return|;
else|#
directive|else
name|video_info_t
name|info
decl_stmt|;
name|struct
name|winsize
name|wsz
decl_stmt|;
name|u_char
modifier|*
name|font
decl_stmt|;
name|int
name|prev_ysize
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|vidd_get_info
argument_list|(
name|scp
operator|->
name|sc
operator|->
name|adp
argument_list|,
name|scp
operator|->
name|mode
argument_list|,
operator|&
name|info
argument_list|)
condition|)
return|return
name|ENODEV
return|;
comment|/* this shouldn't happen */
comment|/* adjust argument values */
if|if
condition|(
name|fontsize
operator|<=
literal|0
condition|)
name|fontsize
operator|=
name|info
operator|.
name|vi_cheight
expr_stmt|;
if|if
condition|(
name|fontsize
operator|<
literal|14
condition|)
name|fontsize
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|fontsize
operator|>=
literal|16
condition|)
name|fontsize
operator|=
literal|16
expr_stmt|;
else|else
name|fontsize
operator|=
literal|14
expr_stmt|;
ifndef|#
directive|ifndef
name|SC_NO_FONT_LOADING
switch|switch
condition|(
name|fontsize
condition|)
block|{
case|case
literal|8
case|:
if|if
condition|(
operator|(
name|scp
operator|->
name|sc
operator|->
name|fonts_loaded
operator|&
name|FONT_8
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|font
operator|=
name|scp
operator|->
name|sc
operator|->
name|font_8
expr_stmt|;
break|break;
case|case
literal|14
case|:
if|if
condition|(
operator|(
name|scp
operator|->
name|sc
operator|->
name|fonts_loaded
operator|&
name|FONT_14
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|font
operator|=
name|scp
operator|->
name|sc
operator|->
name|font_14
expr_stmt|;
break|break;
case|case
literal|16
case|:
if|if
condition|(
operator|(
name|scp
operator|->
name|sc
operator|->
name|fonts_loaded
operator|&
name|FONT_16
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|font
operator|=
name|scp
operator|->
name|sc
operator|->
name|font_16
expr_stmt|;
break|break;
block|}
else|#
directive|else
name|font
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|xsize
operator|<=
literal|0
condition|)
name|xsize
operator|=
name|info
operator|.
name|vi_width
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|ysize
operator|<=
literal|0
condition|)
name|ysize
operator|=
name|info
operator|.
name|vi_height
operator|/
name|fontsize
expr_stmt|;
if|if
condition|(
operator|(
name|info
operator|.
name|vi_width
operator|<
name|xsize
operator|*
literal|8
operator|)
operator|||
operator|(
name|info
operator|.
name|vi_height
operator|<
name|ysize
operator|*
name|fontsize
operator|)
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
operator|!
name|sc_support_pixel_mode
argument_list|(
operator|&
name|info
argument_list|)
condition|)
return|return
name|ENODEV
return|;
comment|/* stop screen saver, etc */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|sc_clean_up
argument_list|(
name|scp
argument_list|)
operator|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
name|sc_render_match
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|sc
operator|->
name|adp
operator|->
name|va_name
argument_list|,
name|PIXEL_MODE
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ENODEV
return|;
block|}
if|#
directive|if
literal|0
block|if (scp->tsw) 	(*scp->tsw->te_term)(scp, scp->ts);     scp->tsw = NULL;     scp->ts = NULL;
endif|#
directive|endif
comment|/* set up scp */
ifndef|#
directive|ifndef
name|SC_NO_HISTORY
if|if
condition|(
name|scp
operator|->
name|history
operator|!=
name|NULL
condition|)
name|sc_hist_save
argument_list|(
name|scp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|prev_ysize
operator|=
name|scp
operator|->
name|ysize
expr_stmt|;
name|scp
operator|->
name|status
operator||=
operator|(
name|UNKNOWN_MODE
operator||
name|PIXEL_MODE
operator||
name|MOUSE_HIDDEN
operator|)
expr_stmt|;
name|scp
operator|->
name|status
operator|&=
operator|~
operator|(
name|GRAPHICS_MODE
operator||
name|MOUSE_VISIBLE
operator|)
expr_stmt|;
name|scp
operator|->
name|xsize
operator|=
name|xsize
expr_stmt|;
name|scp
operator|->
name|ysize
operator|=
name|ysize
expr_stmt|;
name|scp
operator|->
name|xoff
operator|=
operator|(
name|scp
operator|->
name|xpixel
operator|/
literal|8
operator|-
name|xsize
operator|)
operator|/
literal|2
expr_stmt|;
name|scp
operator|->
name|yoff
operator|=
operator|(
name|scp
operator|->
name|ypixel
operator|/
name|fontsize
operator|-
name|ysize
operator|)
operator|/
literal|2
expr_stmt|;
name|scp
operator|->
name|font
operator|=
name|font
expr_stmt|;
name|scp
operator|->
name|font_size
operator|=
name|fontsize
expr_stmt|;
name|scp
operator|->
name|font_width
operator|=
name|fontwidth
expr_stmt|;
comment|/* allocate buffers */
name|sc_alloc_scr_buffer
argument_list|(
name|scp
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|sc_init_emulator
argument_list|(
name|scp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SC_NO_CUTPASTE
name|sc_alloc_cut_buffer
argument_list|(
name|scp
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|SC_NO_HISTORY
name|sc_alloc_history_buffer
argument_list|(
name|scp
argument_list|,
literal|0
argument_list|,
name|prev_ysize
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|==
name|scp
operator|->
name|sc
operator|->
name|cur_scp
condition|)
block|{
name|sc_set_border
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|border
argument_list|)
expr_stmt|;
name|sc_set_cursor_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
name|scp
operator|->
name|status
operator|&=
operator|~
name|UNKNOWN_MODE
expr_stmt|;
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|wsz
operator|.
name|ws_col
operator|=
name|scp
operator|->
name|xsize
expr_stmt|;
name|wsz
operator|.
name|ws_row
operator|=
name|scp
operator|->
name|ysize
expr_stmt|;
name|tty_set_winsize
argument_list|(
name|tp
argument_list|,
operator|&
name|wsz
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* SC_PIXEL_MODE */
block|}
end_function

begin_function
name|int
name|sc_support_pixel_mode
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SC_PIXEL_MODE
name|video_info_t
modifier|*
name|info
init|=
name|arg
decl_stmt|;
if|if
condition|(
operator|(
name|info
operator|->
name|vi_flags
operator|&
name|V_INFO_GRAPHICS
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * We currently support the following graphic modes: 	 * 	 * - 4 bpp planar modes whose memory size does not exceed 64K 	 * - 15, 16, 24 and 32 bpp linear modes 	 */
switch|switch
condition|(
name|info
operator|->
name|vi_mem_model
condition|)
block|{
case|case
name|V_INFO_MM_PLANAR
case|:
if|if
condition|(
name|info
operator|->
name|vi_planes
operator|!=
literal|4
condition|)
break|break;
comment|/* 		 * A memory size>64K requires bank switching to access 		 * the entire screen. XXX 		 */
if|if
condition|(
name|info
operator|->
name|vi_width
operator|*
name|info
operator|->
name|vi_height
operator|/
literal|8
operator|>
name|info
operator|->
name|vi_window_size
condition|)
break|break;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|V_INFO_MM_DIRECT
case|:
if|if
condition|(
operator|(
name|info
operator|->
name|vi_flags
operator|&
name|V_INFO_LINEAR
operator|)
operator|==
literal|0
operator|&&
name|info
operator|->
name|vi_depth
operator|!=
literal|15
operator|&&
name|info
operator|->
name|vi_depth
operator|!=
literal|16
operator|&&
name|info
operator|->
name|vi_depth
operator|!=
literal|24
operator|&&
name|info
operator|->
name|vi_depth
operator|!=
literal|32
condition|)
break|break;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|V_INFO_MM_PACKED
case|:
if|if
condition|(
operator|(
name|info
operator|->
name|vi_flags
operator|&
name|V_INFO_LINEAR
operator|)
operator|==
literal|0
operator|&&
name|info
operator|->
name|vi_depth
operator|!=
literal|8
condition|)
break|break;
return|return
operator|(
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|fb_ioctl
parameter_list|(
name|a
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|)
define|\
value|(((a) == NULL) ? ENODEV : 	\ 			 vidd_ioctl((a), (c), (caddr_t)(d)))
end_define

begin_function
name|int
name|sc_vid_ioctl
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|scr_stat
modifier|*
name|scp
decl_stmt|;
name|video_adapter_t
modifier|*
name|adp
decl_stmt|;
name|video_info_t
name|info
decl_stmt|;
name|video_adapter_info_t
name|adp_info
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|s
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_FREEBSD6
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_FREEBSD5
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|COMPAT_FREEBSD4
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_43
argument_list|)
name|int
name|ival
decl_stmt|;
endif|#
directive|endif
name|scp
operator|=
name|SC_STAT
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|==
name|NULL
condition|)
comment|/* tp == SC_MOUSE */
return|return
name|ENOIOCTL
return|;
name|adp
operator|=
name|scp
operator|->
name|sc
operator|->
name|adp
expr_stmt|;
if|if
condition|(
name|adp
operator|==
name|NULL
condition|)
comment|/* shouldn't happen??? */
return|return
name|ENODEV
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|CONS_CURRENTADP
case|:
comment|/* get current adapter index */
case|case
name|FBIO_ADAPTER
case|:
return|return
name|fb_ioctl
argument_list|(
name|adp
argument_list|,
name|FBIO_ADAPTER
argument_list|,
name|data
argument_list|)
return|;
case|case
name|CONS_CURRENT
case|:
comment|/* get current adapter type */
case|case
name|FBIO_ADPTYPE
case|:
return|return
name|fb_ioctl
argument_list|(
name|adp
argument_list|,
name|FBIO_ADPTYPE
argument_list|,
name|data
argument_list|)
return|;
case|case
name|OLD_CONS_ADPINFO
case|:
comment|/* adapter information (old interface) */
if|if
condition|(
operator|(
operator|(
name|old_video_adapter_t
operator|*
operator|)
name|data
operator|)
operator|->
name|va_index
operator|>=
literal|0
condition|)
block|{
name|adp
operator|=
name|vid_get_adapter
argument_list|(
operator|(
operator|(
name|old_video_adapter_t
operator|*
operator|)
name|data
operator|)
operator|->
name|va_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|adp
operator|==
name|NULL
condition|)
return|return
name|ENODEV
return|;
block|}
operator|(
operator|(
name|old_video_adapter_t
operator|*
operator|)
name|data
operator|)
operator|->
name|va_index
operator|=
name|adp
operator|->
name|va_index
expr_stmt|;
operator|(
operator|(
name|old_video_adapter_t
operator|*
operator|)
name|data
operator|)
operator|->
name|va_type
operator|=
name|adp
operator|->
name|va_type
expr_stmt|;
operator|(
operator|(
name|old_video_adapter_t
operator|*
operator|)
name|data
operator|)
operator|->
name|va_flags
operator|=
name|adp
operator|->
name|va_flags
expr_stmt|;
operator|(
operator|(
name|old_video_adapter_t
operator|*
operator|)
name|data
operator|)
operator|->
name|va_crtc_addr
operator|=
name|adp
operator|->
name|va_crtc_addr
expr_stmt|;
operator|(
operator|(
name|old_video_adapter_t
operator|*
operator|)
name|data
operator|)
operator|->
name|va_window
operator|=
name|adp
operator|->
name|va_window
expr_stmt|;
operator|(
operator|(
name|old_video_adapter_t
operator|*
operator|)
name|data
operator|)
operator|->
name|va_window_size
operator|=
name|adp
operator|->
name|va_window_size
expr_stmt|;
operator|(
operator|(
name|old_video_adapter_t
operator|*
operator|)
name|data
operator|)
operator|->
name|va_window_gran
operator|=
name|adp
operator|->
name|va_window_gran
expr_stmt|;
operator|(
operator|(
name|old_video_adapter_t
operator|*
operator|)
name|data
operator|)
operator|->
name|va_buffer
operator|=
name|adp
operator|->
name|va_buffer
expr_stmt|;
operator|(
operator|(
name|old_video_adapter_t
operator|*
operator|)
name|data
operator|)
operator|->
name|va_buffer_size
operator|=
name|adp
operator|->
name|va_buffer_size
expr_stmt|;
operator|(
operator|(
name|old_video_adapter_t
operator|*
operator|)
name|data
operator|)
operator|->
name|va_mode
operator|=
name|adp
operator|->
name|va_mode
expr_stmt|;
operator|(
operator|(
name|old_video_adapter_t
operator|*
operator|)
name|data
operator|)
operator|->
name|va_initial_mode
operator|=
name|adp
operator|->
name|va_initial_mode
expr_stmt|;
operator|(
operator|(
name|old_video_adapter_t
operator|*
operator|)
name|data
operator|)
operator|->
name|va_initial_bios_mode
operator|=
name|adp
operator|->
name|va_initial_bios_mode
expr_stmt|;
return|return
literal|0
return|;
case|case
name|OLD_CONS_ADPINFO2
case|:
comment|/* adapter information (yet another old I/F) */
name|adp_info
operator|.
name|va_index
operator|=
operator|(
operator|(
name|old_video_adapter_info_t
operator|*
operator|)
name|data
operator|)
operator|->
name|va_index
expr_stmt|;
if|if
condition|(
name|adp_info
operator|.
name|va_index
operator|>=
literal|0
condition|)
block|{
name|adp
operator|=
name|vid_get_adapter
argument_list|(
name|adp_info
operator|.
name|va_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|adp
operator|==
name|NULL
condition|)
return|return
name|ENODEV
return|;
block|}
name|error
operator|=
name|fb_ioctl
argument_list|(
name|adp
argument_list|,
name|FBIO_ADPINFO
argument_list|,
operator|&
name|adp_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|bcopy
argument_list|(
operator|&
name|adp_info
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|old_video_adapter_info_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
case|case
name|CONS_ADPINFO
case|:
comment|/* adapter information */
case|case
name|FBIO_ADPINFO
case|:
if|if
condition|(
operator|(
operator|(
name|video_adapter_info_t
operator|*
operator|)
name|data
operator|)
operator|->
name|va_index
operator|>=
literal|0
condition|)
block|{
name|adp
operator|=
name|vid_get_adapter
argument_list|(
operator|(
operator|(
name|video_adapter_info_t
operator|*
operator|)
name|data
operator|)
operator|->
name|va_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|adp
operator|==
name|NULL
condition|)
return|return
name|ENODEV
return|;
block|}
return|return
name|fb_ioctl
argument_list|(
name|adp
argument_list|,
name|FBIO_ADPINFO
argument_list|,
name|data
argument_list|)
return|;
case|case
name|CONS_GET
case|:
comment|/* get current video mode */
case|case
name|FBIO_GETMODE
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|scp
operator|->
name|mode
expr_stmt|;
return|return
literal|0
return|;
ifndef|#
directive|ifndef
name|SC_NO_MODE_CHANGE
case|case
name|FBIO_SETMODE
case|:
comment|/* set video mode */
if|if
condition|(
operator|!
operator|(
name|adp
operator|->
name|va_flags
operator|&
name|V_ADP_MODECHANGE
operator|)
condition|)
return|return
name|ENODEV
return|;
name|info
operator|.
name|vi_mode
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
name|fb_ioctl
argument_list|(
name|adp
argument_list|,
name|FBIO_MODEINFO
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|info
operator|.
name|vi_flags
operator|&
name|V_INFO_GRAPHICS
condition|)
return|return
name|sc_set_graphics_mode
argument_list|(
name|scp
argument_list|,
name|tp
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
return|;
else|else
return|return
name|sc_set_text_mode
argument_list|(
name|scp
argument_list|,
name|tp
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
endif|#
directive|endif
comment|/* SC_NO_MODE_CHANGE */
case|case
name|OLD_CONS_MODEINFO
case|:
comment|/* get mode information (old infterface) */
name|info
operator|.
name|vi_mode
operator|=
operator|(
operator|(
name|old_video_info_t
operator|*
operator|)
name|data
operator|)
operator|->
name|vi_mode
expr_stmt|;
name|error
operator|=
name|fb_ioctl
argument_list|(
name|adp
argument_list|,
name|FBIO_MODEINFO
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|bcopy
argument_list|(
operator|&
name|info
argument_list|,
operator|(
name|old_video_info_t
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|old_video_info_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
case|case
name|CONS_MODEINFO
case|:
comment|/* get mode information */
case|case
name|FBIO_MODEINFO
case|:
return|return
name|fb_ioctl
argument_list|(
name|adp
argument_list|,
name|FBIO_MODEINFO
argument_list|,
name|data
argument_list|)
return|;
case|case
name|OLD_CONS_FINDMODE
case|:
comment|/* find a matching video mode (old interface) */
name|bzero
argument_list|(
operator|&
name|info
argument_list|,
sizeof|sizeof
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|old_video_info_t
operator|*
operator|)
name|data
argument_list|,
operator|&
name|info
argument_list|,
sizeof|sizeof
argument_list|(
name|old_video_info_t
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|fb_ioctl
argument_list|(
name|adp
argument_list|,
name|FBIO_FINDMODE
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|bcopy
argument_list|(
operator|&
name|info
argument_list|,
operator|(
name|old_video_info_t
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|old_video_info_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
case|case
name|CONS_FINDMODE
case|:
comment|/* find a matching video mode */
case|case
name|FBIO_FINDMODE
case|:
return|return
name|fb_ioctl
argument_list|(
name|adp
argument_list|,
name|FBIO_FINDMODE
argument_list|,
name|data
argument_list|)
return|;
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_FREEBSD6
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_FREEBSD5
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|COMPAT_FREEBSD4
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_43
argument_list|)
case|case
name|_IO
argument_list|(
literal|'c'
argument_list|,
literal|104
argument_list|)
case|:
name|ival
operator|=
name|IOCPARM_IVAL
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|ival
expr_stmt|;
comment|/* FALLTHROUGH */
endif|#
directive|endif
case|case
name|CONS_SETWINORG
case|:
comment|/* set frame buffer window origin */
case|case
name|FBIO_SETWINORG
case|:
if|if
condition|(
name|scp
operator|!=
name|scp
operator|->
name|sc
operator|->
name|cur_scp
condition|)
return|return
name|ENODEV
return|;
comment|/* XXX */
return|return
name|fb_ioctl
argument_list|(
name|adp
argument_list|,
name|FBIO_SETWINORG
argument_list|,
name|data
argument_list|)
return|;
case|case
name|FBIO_GETWINORG
case|:
comment|/* get frame buffer window origin */
if|if
condition|(
name|scp
operator|!=
name|scp
operator|->
name|sc
operator|->
name|cur_scp
condition|)
return|return
name|ENODEV
return|;
comment|/* XXX */
return|return
name|fb_ioctl
argument_list|(
name|adp
argument_list|,
name|FBIO_GETWINORG
argument_list|,
name|data
argument_list|)
return|;
case|case
name|FBIO_GETDISPSTART
case|:
case|case
name|FBIO_SETDISPSTART
case|:
case|case
name|FBIO_GETLINEWIDTH
case|:
case|case
name|FBIO_SETLINEWIDTH
case|:
if|if
condition|(
name|scp
operator|!=
name|scp
operator|->
name|sc
operator|->
name|cur_scp
condition|)
return|return
name|ENODEV
return|;
comment|/* XXX */
return|return
name|fb_ioctl
argument_list|(
name|adp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
return|;
case|case
name|FBIO_GETPALETTE
case|:
case|case
name|FBIO_SETPALETTE
case|:
case|case
name|FBIOPUTCMAP
case|:
case|case
name|FBIOGETCMAP
case|:
case|case
name|FBIOGTYPE
case|:
case|case
name|FBIOGATTR
case|:
case|case
name|FBIOSVIDEO
case|:
case|case
name|FBIOGVIDEO
case|:
case|case
name|FBIOSCURSOR
case|:
case|case
name|FBIOGCURSOR
case|:
case|case
name|FBIOSCURPOS
case|:
case|case
name|FBIOGCURPOS
case|:
case|case
name|FBIOGCURMAX
case|:
if|if
condition|(
name|scp
operator|!=
name|scp
operator|->
name|sc
operator|->
name|cur_scp
condition|)
return|return
name|ENODEV
return|;
comment|/* XXX */
return|return
name|fb_ioctl
argument_list|(
name|adp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
return|;
case|case
name|FBIO_BLANK
case|:
if|if
condition|(
name|scp
operator|!=
name|scp
operator|->
name|sc
operator|->
name|cur_scp
condition|)
return|return
name|ENODEV
return|;
comment|/* XXX */
return|return
name|fb_ioctl
argument_list|(
name|adp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
return|;
ifndef|#
directive|ifndef
name|SC_NO_MODE_CHANGE
comment|/* generic text modes */
case|case
name|SW_TEXT_80x25
case|:
case|case
name|SW_TEXT_80x30
case|:
case|case
name|SW_TEXT_80x43
case|:
case|case
name|SW_TEXT_80x50
case|:
case|case
name|SW_TEXT_80x60
case|:
comment|/* FALLTHROUGH */
comment|/* VGA TEXT MODES */
case|case
name|SW_VGA_C40x25
case|:
case|case
name|SW_VGA_C80x25
case|:
case|case
name|SW_VGA_M80x25
case|:
case|case
name|SW_VGA_C80x30
case|:
case|case
name|SW_VGA_M80x30
case|:
case|case
name|SW_VGA_C80x50
case|:
case|case
name|SW_VGA_M80x50
case|:
case|case
name|SW_VGA_C80x60
case|:
case|case
name|SW_VGA_M80x60
case|:
case|case
name|SW_VGA_C90x25
case|:
case|case
name|SW_VGA_M90x25
case|:
case|case
name|SW_VGA_C90x30
case|:
case|case
name|SW_VGA_M90x30
case|:
case|case
name|SW_VGA_C90x43
case|:
case|case
name|SW_VGA_M90x43
case|:
case|case
name|SW_VGA_C90x50
case|:
case|case
name|SW_VGA_M90x50
case|:
case|case
name|SW_VGA_C90x60
case|:
case|case
name|SW_VGA_M90x60
case|:
case|case
name|SW_B40x25
case|:
case|case
name|SW_C40x25
case|:
case|case
name|SW_B80x25
case|:
case|case
name|SW_C80x25
case|:
case|case
name|SW_ENH_B40x25
case|:
case|case
name|SW_ENH_C40x25
case|:
case|case
name|SW_ENH_B80x25
case|:
case|case
name|SW_ENH_C80x25
case|:
case|case
name|SW_ENH_B80x43
case|:
case|case
name|SW_ENH_C80x43
case|:
case|case
name|SW_EGAMONO80x25
case|:
ifdef|#
directive|ifdef
name|PC98
comment|/* PC98 TEXT MODES */
case|case
name|SW_PC98_80x25
case|:
case|case
name|SW_PC98_80x30
case|:
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|adp
operator|->
name|va_flags
operator|&
name|V_ADP_MODECHANGE
operator|)
condition|)
return|return
name|ENODEV
return|;
return|return
name|sc_set_text_mode
argument_list|(
name|scp
argument_list|,
name|tp
argument_list|,
name|cmd
operator|&
literal|0xff
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
comment|/* GRAPHICS MODES */
case|case
name|SW_BG320
case|:
case|case
name|SW_BG640
case|:
case|case
name|SW_CG320
case|:
case|case
name|SW_CG320_D
case|:
case|case
name|SW_CG640_E
case|:
case|case
name|SW_CG640x350
case|:
case|case
name|SW_ENH_CG640
case|:
case|case
name|SW_BG640x480
case|:
case|case
name|SW_CG640x480
case|:
case|case
name|SW_VGA_CG320
case|:
case|case
name|SW_VGA_MODEX
case|:
ifdef|#
directive|ifdef
name|PC98
comment|/* PC98 GRAPHICS MODES */
case|case
name|SW_PC98_EGC640x400
case|:
case|case
name|SW_PC98_PEGC640x400
case|:
case|case
name|SW_PC98_PEGC640x480
case|:
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|adp
operator|->
name|va_flags
operator|&
name|V_ADP_MODECHANGE
operator|)
condition|)
return|return
name|ENODEV
return|;
return|return
name|sc_set_graphics_mode
argument_list|(
name|scp
argument_list|,
name|tp
argument_list|,
name|cmd
operator|&
literal|0xff
argument_list|)
return|;
endif|#
directive|endif
comment|/* SC_NO_MODE_CHANGE */
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_FREEBSD6
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_FREEBSD5
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|COMPAT_FREEBSD4
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_43
argument_list|)
case|case
name|_IO
argument_list|(
literal|'K'
argument_list|,
literal|10
argument_list|)
case|:
name|ival
operator|=
name|IOCPARM_IVAL
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|ival
expr_stmt|;
comment|/* FALLTHROUGH */
endif|#
directive|endif
case|case
name|KDSETMODE
case|:
comment|/* set current mode of this (virtual) console */
switch|switch
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
block|{
case|case
name|KD_TEXT
case|:
comment|/* switch to TEXT (known) mode */
comment|/* 	     * If scp->mode is of graphics modes, we don't know which 	     * text mode to switch back to... 	     */
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|GRAPHICS_MODE
condition|)
return|return
name|EINVAL
return|;
comment|/* restore fonts& palette ! */
if|#
directive|if
literal|0
ifndef|#
directive|ifndef
name|SC_NO_FONT_LOADING
block|if (ISFONTAVAIL(adp->va_flags)&& !(scp->status& (GRAPHICS_MODE | PIXEL_MODE)))
comment|/* 		 * FONT KLUDGE 		 * Don't load fonts for now... XXX 		 */
block|if (scp->sc->fonts_loaded& FONT_8) 		    sc_load_font(scp, 0, 8, 8, scp->sc->font_8, 0, 256); 		if (scp->sc->fonts_loaded& FONT_14) 		    sc_load_font(scp, 0, 14, 8, scp->sc->font_14, 0, 256); 		if (scp->sc->fonts_loaded& FONT_16) 		    sc_load_font(scp, 0, 16, 8, scp->sc->font_16, 0, 256); 	    }
endif|#
directive|endif
comment|/* SC_NO_FONT_LOADING */
endif|#
directive|endif
ifndef|#
directive|ifndef
name|SC_NO_PALETTE_LOADING
ifdef|#
directive|ifdef
name|SC_PIXEL_MODE
if|if
condition|(
name|adp
operator|->
name|va_info
operator|.
name|vi_mem_model
operator|==
name|V_INFO_MM_DIRECT
condition|)
name|vidd_load_palette
argument_list|(
name|adp
argument_list|,
name|scp
operator|->
name|sc
operator|->
name|palette2
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|vidd_load_palette
argument_list|(
name|adp
argument_list|,
name|scp
operator|->
name|sc
operator|->
name|palette
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|PC98
comment|/* move hardware cursor out of the way */
name|vidd_set_hw_cursor
argument_list|(
name|adp
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FALLTHROUGH */
case|case
name|KD_TEXT1
case|:
comment|/* switch to TEXT (known) mode */
comment|/* 	     * If scp->mode is of graphics modes, we don't know which 	     * text/pixel mode to switch back to... 	     */
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|GRAPHICS_MODE
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|sc_clean_up
argument_list|(
name|scp
argument_list|)
operator|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
ifndef|#
directive|ifndef
name|PC98
name|scp
operator|->
name|status
operator||=
name|UNKNOWN_MODE
operator||
name|MOUSE_HIDDEN
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* no restore fonts& palette */
if|if
condition|(
name|scp
operator|==
name|scp
operator|->
name|sc
operator|->
name|cur_scp
condition|)
name|set_mode
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|sc_clear_screen
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|scp
operator|->
name|status
operator|&=
operator|~
name|UNKNOWN_MODE
expr_stmt|;
else|#
directive|else
comment|/* PC98 */
name|scp
operator|->
name|status
operator|&=
operator|~
name|UNKNOWN_MODE
expr_stmt|;
comment|/* no restore fonts& palette */
if|if
condition|(
name|scp
operator|==
name|scp
operator|->
name|sc
operator|->
name|cur_scp
condition|)
name|set_mode
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|sc_clear_screen
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PC98 */
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|SC_PIXEL_MODE
case|case
name|KD_PIXEL
case|:
comment|/* pixel (raster) display */
if|if
condition|(
operator|!
operator|(
name|scp
operator|->
name|status
operator|&
operator|(
name|GRAPHICS_MODE
operator||
name|PIXEL_MODE
operator|)
operator|)
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|GRAPHICS_MODE
condition|)
return|return
name|sc_set_pixel_mode
argument_list|(
name|scp
argument_list|,
name|tp
argument_list|,
name|scp
operator|->
name|xsize
argument_list|,
name|scp
operator|->
name|ysize
argument_list|,
name|scp
operator|->
name|font_size
argument_list|,
name|scp
operator|->
name|font_width
argument_list|)
return|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|sc_clean_up
argument_list|(
name|scp
argument_list|)
operator|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|scp
operator|->
name|status
operator||=
operator|(
name|UNKNOWN_MODE
operator||
name|PIXEL_MODE
operator||
name|MOUSE_HIDDEN
operator|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|==
name|scp
operator|->
name|sc
operator|->
name|cur_scp
condition|)
block|{
name|set_mode
argument_list|(
name|scp
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SC_NO_PALETTE_LOADING
if|if
condition|(
name|adp
operator|->
name|va_info
operator|.
name|vi_mem_model
operator|==
name|V_INFO_MM_DIRECT
condition|)
name|vidd_load_palette
argument_list|(
name|adp
argument_list|,
name|scp
operator|->
name|sc
operator|->
name|palette2
argument_list|)
expr_stmt|;
else|else
name|vidd_load_palette
argument_list|(
name|adp
argument_list|,
name|scp
operator|->
name|sc
operator|->
name|palette
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|sc_clear_screen
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|scp
operator|->
name|status
operator|&=
operator|~
name|UNKNOWN_MODE
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* SC_PIXEL_MODE */
case|case
name|KD_GRAPHICS
case|:
comment|/* switch to GRAPHICS (unknown) mode */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|sc_clean_up
argument_list|(
name|scp
argument_list|)
operator|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|scp
operator|->
name|status
operator||=
name|UNKNOWN_MODE
operator||
name|MOUSE_HIDDEN
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
if|if
condition|(
name|scp
operator|==
name|scp
operator|->
name|sc
operator|->
name|cur_scp
condition|)
name|set_mode
argument_list|(
name|scp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
default|default:
return|return
name|EINVAL
return|;
block|}
comment|/* NOT REACHED */
ifdef|#
directive|ifdef
name|SC_PIXEL_MODE
case|case
name|KDRASTER
case|:
comment|/* set pixel (raster) display mode */
if|if
condition|(
name|ISUNKNOWNSC
argument_list|(
name|scp
argument_list|)
operator|||
name|ISTEXTSC
argument_list|(
name|scp
argument_list|)
condition|)
return|return
name|ENODEV
return|;
return|return
name|sc_set_pixel_mode
argument_list|(
name|scp
argument_list|,
name|tp
argument_list|,
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
index|[
literal|0
index|]
argument_list|,
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
index|[
literal|1
index|]
argument_list|,
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
index|[
literal|2
index|]
argument_list|,
literal|8
argument_list|)
return|;
endif|#
directive|endif
comment|/* SC_PIXEL_MODE */
case|case
name|KDGETMODE
case|:
comment|/* get current mode of this (virtual) console */
comment|/*  	 * From the user program's point of view, KD_PIXEL is the same  	 * as KD_TEXT...  	 */
operator|*
name|data
operator|=
name|ISGRAPHSC
argument_list|(
name|scp
argument_list|)
condition|?
name|KD_GRAPHICS
else|:
name|KD_TEXT
expr_stmt|;
return|return
literal|0
return|;
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_FREEBSD6
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_FREEBSD5
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|COMPAT_FREEBSD4
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_43
argument_list|)
case|case
name|_IO
argument_list|(
literal|'K'
argument_list|,
literal|13
argument_list|)
case|:
name|ival
operator|=
name|IOCPARM_IVAL
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|ival
expr_stmt|;
comment|/* FALLTHROUGH */
endif|#
directive|endif
case|case
name|KDSBORDER
case|:
comment|/* set border color of this (virtual) console */
name|scp
operator|->
name|border
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|scp
operator|==
name|scp
operator|->
name|sc
operator|->
name|cur_scp
condition|)
name|sc_set_border
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|border
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|ENOIOCTL
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument_list|,
argument|sc_renderer
argument_list|)
name|sc_rndr_list
operator|=
name|LIST_HEAD_INITIALIZER
argument_list|(
name|sc_rndr_list
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|sc_render_add
parameter_list|(
name|sc_renderer_t
modifier|*
name|rndr
parameter_list|)
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sc_rndr_list
argument_list|,
name|rndr
argument_list|,
name|link
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|sc_render_remove
parameter_list|(
name|sc_renderer_t
modifier|*
name|rndr
parameter_list|)
block|{
comment|/* 	LIST_REMOVE(rndr, link); 	*/
return|return
name|EBUSY
return|;
comment|/* XXX */
block|}
end_function

begin_function
name|sc_rndr_sw_t
modifier|*
name|sc_render_match
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
specifier|const
name|sc_renderer_t
modifier|*
modifier|*
name|list
decl_stmt|;
specifier|const
name|sc_renderer_t
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|sc_rndr_list
argument_list|)
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|p
argument_list|,
argument|&sc_rndr_list
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|mode
operator|==
name|p
operator|->
name|mode
operator|)
condition|)
block|{
name|scp
operator|->
name|status
operator|&=
operator|~
operator|(
name|VR_CURSOR_ON
operator||
name|VR_CURSOR_BLINK
operator|)
expr_stmt|;
return|return
name|p
operator|->
name|rndrsw
return|;
block|}
block|}
block|}
else|else
block|{
name|SET_FOREACH
argument_list|(
argument|list
argument_list|,
argument|scrndr_set
argument_list|)
block|{
name|p
operator|=
operator|*
name|list
expr_stmt|;
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|mode
operator|==
name|p
operator|->
name|mode
operator|)
condition|)
block|{
name|scp
operator|->
name|status
operator|&=
operator|~
operator|(
name|VR_CURSOR_ON
operator||
name|VR_CURSOR_BLINK
operator|)
expr_stmt|;
return|return
name|p
operator|->
name|rndrsw
return|;
block|}
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

end_unit

