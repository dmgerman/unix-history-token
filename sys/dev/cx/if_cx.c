begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Cronyx-Sigma adapter driver for FreeBSD.  * Supports PPP/HDLC and Cisco/HDLC protocol in synchronous mode,  * and asyncronous channels with full modem control.  * Keepalive protocol implemented in both Cisco and PPP modes.  *  * Copyright (C) 1994-2002 Cronyx Engineering.  * Author: Serge Vakulenko,<vak@cronyx.ru>  *  * Copyright (C) 1999-2004 Cronyx Engineering.  * Rewritten on DDK, ported to NETGRAPH, rewritten for FreeBSD 3.x-5.x by  * Kurakin Roman,<rik@cronyx.ru>  *  * This software is distributed with NO WARRANTIES, not even the implied  * warranties for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *  * Authors grant any other persons or organisations a permission to use,  * modify and redistribute this software in source and binary forms,  * as long as this message is kept with the software, all derivative  * works or modified versions.  *  * Cronyx Id: if_cx.c,v 1.1.2.34 2004/06/23 17:09:13 rik Exp $  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
end_if

begin_define
define|#
directive|define
name|NCX
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"cx.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|NCX
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<isa/isavar.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/interrupt.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<machine/cserial.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
end_if

begin_include
include|#
directive|include
file|<machine/ipl.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<=
literal|501000
end_if

begin_include
include|#
directive|include
file|<i386/isa/intr_machdep.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/cx/machdep.h>
end_include

begin_include
include|#
directive|include
file|<dev/cx/cxddk.h>
end_include

begin_include
include|#
directive|include
file|<dev/cx/cronyxfw.h>
end_include

begin_include
include|#
directive|include
file|"opt_ng_cronyx.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NETGRAPH_CRONYX
end_ifdef

begin_include
include|#
directive|include
file|"opt_netgraph.h"
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_message.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/netgraph.h>
end_include

begin_include
include|#
directive|include
file|<dev/cx/ng_cx.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
end_if

begin_include
include|#
directive|include
file|"sppp.h"
end_include

begin_if
if|#
directive|if
name|NSPPP
operator|<=
literal|0
end_if

begin_error
error|#
directive|error
error|The device cx requires sppp or netgraph.
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/if_sppp.h>
end_include

begin_define
define|#
directive|define
name|PP_CISCO
value|IFF_LINK2
end_define

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
end_if

begin_include
include|#
directive|include
file|<bpf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_define
define|#
directive|define
name|NBPFILTER
value|NBPF
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|502113
end_if

begin_define
define|#
directive|define
name|ttyld_modem
parameter_list|(
name|foo
parameter_list|,
name|bar
parameter_list|)
value|((*linesw[(foo)->t_line].l_modem)((foo), (bar)))
end_define

begin_define
define|#
directive|define
name|ttyld_rint
parameter_list|(
name|foo
parameter_list|,
name|bar
parameter_list|)
value|((*linesw[(foo)->t_line].l_rint)((bar), (foo)))
end_define

begin_define
define|#
directive|define
name|ttyld_start
parameter_list|(
name|foo
parameter_list|)
value|((*linesw[(foo)->t_line].l_start)((foo)))
end_define

begin_define
define|#
directive|define
name|ttyld_open
parameter_list|(
name|foo
parameter_list|,
name|bar
parameter_list|)
value|((*linesw[(foo)->t_line].l_open) ((bar), (foo)))
end_define

begin_define
define|#
directive|define
name|ttyld_close
parameter_list|(
name|foo
parameter_list|,
name|bar
parameter_list|)
value|((*linesw[(foo)->t_line].l_close) ((foo), (bar)))
end_define

begin_define
define|#
directive|define
name|ttyld_read
parameter_list|(
name|foo
parameter_list|,
name|bar
parameter_list|,
name|barf
parameter_list|)
value|((*linesw[(foo)->t_line].l_read) ((foo), (bar), (barf)))
end_define

begin_define
define|#
directive|define
name|ttyld_write
parameter_list|(
name|foo
parameter_list|,
name|bar
parameter_list|,
name|barf
parameter_list|)
value|((*linesw[(foo)->t_line].l_write) ((foo), (bar), (barf)))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If we don't have Cronyx's sppp version, we don't have fr support via sppp */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PP_FR
end_ifndef

begin_define
define|#
directive|define
name|PP_FR
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CX_DEBUG
parameter_list|(
name|d
parameter_list|,
name|s
parameter_list|)
value|({if (d->chan->debug) {\ 				printf ("%s: ", d->name); printf s;}})
end_define

begin_define
define|#
directive|define
name|CX_DEBUG2
parameter_list|(
name|d
parameter_list|,
name|s
parameter_list|)
value|({if (d->chan->debug>1) {\ 				printf ("%s: ", d->name); printf s;}})
end_define

begin_define
define|#
directive|define
name|UNIT
parameter_list|(
name|d
parameter_list|)
value|(minor(d)& 0x3f)
end_define

begin_define
define|#
directive|define
name|IF_CUNIT
parameter_list|(
name|d
parameter_list|)
value|(minor(d)& 0x40)
end_define

begin_define
define|#
directive|define
name|UNIT_CTL
value|0x3f
end_define

begin_define
define|#
directive|define
name|CALLOUT
parameter_list|(
name|d
parameter_list|)
value|(minor(d)& 0x80)
end_define

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|42
end_define

begin_typedef
typedef|typedef
struct|struct
name|_async_q
block|{
name|int
name|beg
decl_stmt|;
name|int
name|end
decl_stmt|;
define|#
directive|define
name|BF_SZ
value|14400
name|int
name|buf
index|[
name|BF_SZ
operator|+
literal|1
index|]
decl_stmt|;
block|}
name|async_q
typedef|;
end_typedef

begin_define
define|#
directive|define
name|AQ_GSZ
parameter_list|(
name|q
parameter_list|)
value|((BF_SZ + (q)->end - (q)->beg)%BF_SZ)
end_define

begin_define
define|#
directive|define
name|AQ_PUSH
parameter_list|(
name|q
parameter_list|,
name|c
parameter_list|)
value|{*((q)->buf + (q)->end) = c;\ 			(q)->end = ((q)->end + 1)%BF_SZ;}
end_define

begin_define
define|#
directive|define
name|AQ_POP
parameter_list|(
name|q
parameter_list|,
name|c
parameter_list|)
value|{c = *((q)->buf + (q)->beg);\ 			(q)->beg = ((q)->beg + 1)%BF_SZ;}
end_define

begin_decl_stmt
specifier|static
name|void
name|cx_identify
name|__P
argument_list|(
operator|(
name|driver_t
operator|*
operator|,
name|device_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cx_probe
name|__P
argument_list|(
operator|(
name|device_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cx_attach
name|__P
argument_list|(
operator|(
name|device_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cx_detach
name|__P
argument_list|(
operator|(
name|device_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|cx_isa_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_identify
argument_list|,
name|cx_identify
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|cx_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|cx_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|cx_detach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|_cx_dma_mem_t
block|{
name|unsigned
name|long
name|phys
decl_stmt|;
name|void
modifier|*
name|virt
decl_stmt|;
name|size_t
name|size
decl_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|bus_dma_tag_t
name|dmat
decl_stmt|;
name|bus_dmamap_t
name|mapp
decl_stmt|;
endif|#
directive|endif
block|}
name|cx_dma_mem_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|_drv_t
block|{
name|char
name|name
index|[
literal|8
index|]
decl_stmt|;
name|cx_chan_t
modifier|*
name|chan
decl_stmt|;
name|cx_board_t
modifier|*
name|board
decl_stmt|;
name|cx_dma_mem_t
name|dmamem
decl_stmt|;
name|struct
name|tty
modifier|*
name|tty
decl_stmt|;
name|struct
name|callout_handle
name|dcd_timeout_handle
decl_stmt|;
name|unsigned
name|callout
decl_stmt|;
name|unsigned
name|lock
decl_stmt|;
name|int
name|open_dev
decl_stmt|;
name|int
name|cd
decl_stmt|;
name|int
name|running
decl_stmt|;
ifdef|#
directive|ifdef
name|NETGRAPH
name|char
name|nodename
index|[
name|NG_NODELEN
operator|+
literal|1
index|]
decl_stmt|;
name|hook_p
name|hook
decl_stmt|;
name|hook_p
name|debug_hook
decl_stmt|;
name|node_p
name|node
decl_stmt|;
name|struct
name|ifqueue
name|lo_queue
decl_stmt|;
name|struct
name|ifqueue
name|hi_queue
decl_stmt|;
name|short
name|timeout
decl_stmt|;
name|struct
name|callout_handle
name|timeout_handle
decl_stmt|;
else|#
directive|else
name|struct
name|sppp
name|pp
decl_stmt|;
endif|#
directive|endif
name|struct
name|cdev
modifier|*
name|devt
index|[
literal|3
index|]
decl_stmt|;
name|async_q
name|aqueue
decl_stmt|;
define|#
directive|define
name|CX_READ
value|1
define|#
directive|define
name|CX_WRITE
value|2
name|int
name|intr_action
decl_stmt|;
name|short
name|atimeout
decl_stmt|;
block|}
name|drv_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|_bdrv_t
block|{
name|cx_board_t
modifier|*
name|board
decl_stmt|;
name|struct
name|resource
modifier|*
name|base_res
decl_stmt|;
name|struct
name|resource
modifier|*
name|drq_res
decl_stmt|;
name|struct
name|resource
modifier|*
name|irq_res
decl_stmt|;
name|int
name|base_rid
decl_stmt|;
name|int
name|drq_rid
decl_stmt|;
name|int
name|irq_rid
decl_stmt|;
name|void
modifier|*
name|intrhand
decl_stmt|;
name|drv_t
name|channel
index|[
name|NCHAN
index|]
decl_stmt|;
block|}
name|bdrv_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|driver_t
name|cx_isa_driver
init|=
block|{
literal|"cx"
block|,
name|cx_isa_methods
block|,
sizeof|sizeof
argument_list|(
name|bdrv_t
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|cx_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|csigma_fw_len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
specifier|const
name|char
modifier|*
name|csigma_fw_version
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
specifier|const
name|char
modifier|*
name|csigma_fw_date
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
specifier|const
name|char
modifier|*
name|csigma_fw_copyright
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
specifier|const
name|cr_dat_tst_t
name|csigma_fw_tvec
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
specifier|const
name|u_char
name|csigma_fw_data
index|[]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|cx_oproc
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cx_param
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|termios
modifier|*
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cx_stop
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|int
name|flag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cx_receive
parameter_list|(
name|cx_chan_t
modifier|*
name|c
parameter_list|,
name|char
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cx_transmit
parameter_list|(
name|cx_chan_t
modifier|*
name|c
parameter_list|,
name|void
modifier|*
name|attachment
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cx_error
parameter_list|(
name|cx_chan_t
modifier|*
name|c
parameter_list|,
name|int
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cx_modem
parameter_list|(
name|cx_chan_t
modifier|*
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cx_up
parameter_list|(
name|drv_t
modifier|*
name|d
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cx_start
parameter_list|(
name|drv_t
modifier|*
name|d
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|502113
end_if

begin_function_decl
specifier|static
name|void
name|ttyldoptim
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
end_if

begin_decl_stmt
specifier|static
name|swihand_t
name|cx_softintr
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|void
name|cx_softintr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
modifier|*
name|cx_fast_ih
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|cx_down
parameter_list|(
name|drv_t
modifier|*
name|d
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cx_watchdog
parameter_list|(
name|drv_t
modifier|*
name|d
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cx_carrier
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|NETGRAPH
end_ifdef

begin_decl_stmt
specifier|extern
name|struct
name|ng_type
name|typestruct
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|void
name|cx_ifstart
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cx_tlf
parameter_list|(
name|struct
name|sppp
modifier|*
name|sp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cx_tls
parameter_list|(
name|struct
name|sppp
modifier|*
name|sp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cx_ifwatchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cx_sioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cx_initialize
parameter_list|(
name|void
modifier|*
name|softc
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|cx_board_t
modifier|*
name|adapter
index|[
name|NCX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|drv_t
modifier|*
name|channel
index|[
name|NCX
operator|*
name|NCHAN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|callout_handle
name|led_timo
index|[
name|NCX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|callout_handle
name|timeout_handle
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|cdevsw
name|cx_cdevsw
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|MY_SOFT_INTR
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Print the mbuf chain, for debug purposes only.  */
end_comment

begin_function
specifier|static
name|void
name|printmbuf
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|printf
argument_list|(
literal|"mbuf:"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
condition|)
name|printf
argument_list|(
literal|" HDR %d:"
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
condition|)
name|printf
argument_list|(
literal|" EXT:"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %d"
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Make an mbuf from data.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|makembuf
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|u_int
name|len
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|o
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|len
operator|>=
name|MINCLSIZE
condition|)
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|m
expr_stmt|;
while|while
condition|(
name|len
condition|)
block|{
name|u_int
name|n
init|=
name|M_TRAILINGSPACE
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|>
name|len
condition|)
name|n
operator|=
name|len
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
block|{
comment|/* Allocate new mbuf. */
name|o
operator|=
name|p
expr_stmt|;
name|MGET
argument_list|(
name|p
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|len
operator|>=
name|MINCLSIZE
condition|)
name|MCLGET
argument_list|(
name|p
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
name|p
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|o
operator|->
name|m_next
operator|=
name|p
expr_stmt|;
name|n
operator|=
name|M_TRAILINGSPACE
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|len
condition|)
name|n
operator|=
name|len
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|buf
argument_list|,
name|mtod
argument_list|(
name|p
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|p
operator|->
name|m_len
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|p
operator|->
name|m_len
operator|+=
name|n
expr_stmt|;
name|buf
operator|=
name|n
operator|+
operator|(
name|char
operator|*
operator|)
name|buf
expr_stmt|;
name|len
operator|-=
name|n
expr_stmt|;
block|}
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/*  * Recover after lost transmit interrupts.  */
end_comment

begin_function
specifier|static
name|void
name|cx_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
decl_stmt|;
name|int
name|s
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCX
operator|*
name|NCHAN
condition|;
operator|++
name|i
control|)
block|{
name|d
operator|=
name|channel
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|d
condition|)
continue|continue;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|atimeout
operator|==
literal|1
operator|&&
name|d
operator|->
name|tty
operator|&&
name|d
operator|->
name|tty
operator|->
name|t_state
operator|&
name|TS_BUSY
condition|)
block|{
name|d
operator|->
name|tty
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|tty
operator|->
name|t_dev
condition|)
block|{
name|d
operator|->
name|intr_action
operator||=
name|CX_WRITE
expr_stmt|;
name|MY_SOFT_INTR
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|swi_sched
argument_list|(
name|cx_fast_ih
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|setsofttty
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
name|CX_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"cx_timeout\n"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|atimeout
condition|)
name|d
operator|->
name|atimeout
operator|--
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|timeout_handle
operator|=
name|timeout
argument_list|(
name|cx_timeout
argument_list|,
literal|0
argument_list|,
name|hz
operator|*
literal|5
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cx_led_off
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|cx_board_t
modifier|*
name|b
init|=
name|arg
decl_stmt|;
name|int
name|s
init|=
name|splhigh
argument_list|()
decl_stmt|;
name|cx_led
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|led_timo
index|[
name|b
operator|->
name|num
index|]
operator|.
name|callout
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Activate interupt handler from DDK.  */
end_comment

begin_function
specifier|static
name|void
name|cx_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|bdrv_t
modifier|*
name|bd
init|=
name|arg
decl_stmt|;
name|cx_board_t
modifier|*
name|b
init|=
name|bd
operator|->
name|board
decl_stmt|;
name|int
name|s
init|=
name|splhigh
argument_list|()
decl_stmt|;
comment|/* Turn LED on. */
name|cx_led
argument_list|(
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cx_int_handler
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* Turn LED off 50 msec later. */
if|if
condition|(
operator|!
name|led_timo
index|[
name|b
operator|->
name|num
index|]
operator|.
name|callout
condition|)
name|led_timo
index|[
name|b
operator|->
name|num
index|]
operator|=
name|timeout
argument_list|(
name|cx_led_off
argument_list|,
name|b
argument_list|,
name|hz
operator|/
literal|20
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|probe_irq
parameter_list|(
name|cx_board_t
modifier|*
name|b
parameter_list|,
name|int
name|irq
parameter_list|)
block|{
name|int
name|mask
decl_stmt|,
name|busy
decl_stmt|,
name|cnt
decl_stmt|;
comment|/* Clear pending irq, if any. */
name|cx_probe_irq
argument_list|(
name|b
argument_list|,
operator|-
name|irq
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
literal|5
condition|;
operator|++
name|cnt
control|)
block|{
comment|/* Get the mask of pending irqs, assuming they are busy. 		 * Activate the adapter on given irq. */
name|busy
operator|=
name|cx_probe_irq
argument_list|(
name|b
argument_list|,
name|irq
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* Get the mask of active irqs. 		 * Deactivate our irq. */
name|mask
operator|=
name|cx_probe_irq
argument_list|(
name|b
argument_list|,
operator|-
name|irq
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
operator|~
name|busy
operator|)
operator|==
literal|1
operator|<<
name|irq
condition|)
block|{
name|cx_probe_irq
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* printf ("cx%d: irq %d ok, mask=0x%04x, busy=0x%04x\n", 				b->num, irq, mask, busy); */
return|return
literal|1
return|;
block|}
block|}
comment|/* printf ("cx%d: irq %d not functional, mask=0x%04x, busy=0x%04x\n", 		b->num, irq, mask, busy); */
name|cx_probe_irq
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|short
name|porttab
index|[]
init|=
block|{
literal|0x200
block|,
literal|0x220
block|,
literal|0x240
block|,
literal|0x260
block|,
literal|0x280
block|,
literal|0x2a0
block|,
literal|0x2c0
block|,
literal|0x2e0
block|,
literal|0x300
block|,
literal|0x320
block|,
literal|0x340
block|,
literal|0x360
block|,
literal|0x380
block|,
literal|0x3a0
block|,
literal|0x3c0
block|,
literal|0x3e0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|dmatab
index|[]
init|=
block|{
literal|7
block|,
literal|6
block|,
literal|5
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|irqtab
index|[]
init|=
block|{
literal|5
block|,
literal|10
block|,
literal|11
block|,
literal|7
block|,
literal|3
block|,
literal|15
block|,
literal|12
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|cx_is_free_res
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|rid
parameter_list|,
name|int
name|type
parameter_list|,
name|u_long
name|start
parameter_list|,
name|u_long
name|end
parameter_list|,
name|u_long
name|count
parameter_list|)
block|{
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|type
argument_list|,
operator|&
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|RF_ALLOCATED
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cx_identify
parameter_list|(
name|driver_t
modifier|*
name|driver
parameter_list|,
name|device_t
name|dev
parameter_list|)
block|{
name|u_long
name|iobase
decl_stmt|,
name|rescount
decl_stmt|;
name|int
name|devcount
decl_stmt|;
name|device_t
modifier|*
name|devices
decl_stmt|;
name|device_t
name|child
decl_stmt|;
name|devclass_t
name|my_devclass
decl_stmt|;
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
if|if
condition|(
operator|(
name|my_devclass
operator|=
name|devclass_find
argument_list|(
literal|"cx"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|devclass_get_devices
argument_list|(
name|my_devclass
argument_list|,
operator|&
name|devices
argument_list|,
operator|&
name|devcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|devcount
operator|==
literal|0
condition|)
block|{
comment|/* We should find all devices by our self. We could alter other 		 * devices, but we don't have a choise 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|iobase
operator|=
name|porttab
index|[
name|i
index|]
operator|)
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|cx_is_free_res
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|iobase
argument_list|,
name|iobase
operator|+
name|NPORT
argument_list|,
name|NPORT
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|cx_probe_board
argument_list|(
name|iobase
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|devcount
operator|++
expr_stmt|;
name|child
operator|=
name|BUS_ADD_CHILD
argument_list|(
name|dev
argument_list|,
name|ISA_ORDER_SPECULATIVE
argument_list|,
literal|"cx"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|NULL
condition|)
return|return;
name|device_set_desc_copy
argument_list|(
name|child
argument_list|,
literal|"Cronyx Sigma"
argument_list|)
expr_stmt|;
name|device_set_driver
argument_list|(
name|child
argument_list|,
name|driver
argument_list|)
expr_stmt|;
name|bus_set_resource
argument_list|(
name|child
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|0
argument_list|,
name|iobase
argument_list|,
name|NPORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|devcount
operator|>=
name|NCX
condition|)
break|break;
block|}
block|}
else|else
block|{
specifier|static
name|short
name|porttab
index|[]
init|=
block|{
literal|0x200
block|,
literal|0x220
block|,
literal|0x240
block|,
literal|0x260
block|,
literal|0x280
block|,
literal|0x2a0
block|,
literal|0x2c0
block|,
literal|0x2e0
block|,
literal|0x300
block|,
literal|0x320
block|,
literal|0x340
block|,
literal|0x360
block|,
literal|0x380
block|,
literal|0x3a0
block|,
literal|0x3c0
block|,
literal|0x3e0
block|,
literal|0
block|}
decl_stmt|;
comment|/* Lets check user choise. 		 */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|devcount
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|bus_get_resource
argument_list|(
name|devices
index|[
name|k
index|]
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|0
argument_list|,
operator|&
name|iobase
argument_list|,
operator|&
name|rescount
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|porttab
index|[
name|i
index|]
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|porttab
index|[
name|i
index|]
operator|!=
name|iobase
condition|)
continue|continue;
if|if
condition|(
operator|!
name|cx_is_free_res
argument_list|(
name|devices
index|[
name|k
index|]
argument_list|,
literal|0
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|iobase
argument_list|,
name|iobase
operator|+
name|NPORT
argument_list|,
name|NPORT
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|cx_probe_board
argument_list|(
name|iobase
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|porttab
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|devices
index|[
name|k
index|]
argument_list|,
literal|"Cronyx Sigma"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|porttab
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|device_delete_child
argument_list|(
name|device_get_parent
argument_list|(
name|devices
index|[
name|k
index|]
argument_list|)
argument_list|,
name|devices
index|[
name|k
index|]
argument_list|)
expr_stmt|;
name|devices
index|[
name|k
index|]
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
block|}
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|devcount
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|devices
index|[
name|k
index|]
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|bus_get_resource
argument_list|(
name|devices
index|[
name|k
index|]
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|0
argument_list|,
operator|&
name|iobase
argument_list|,
operator|&
name|rescount
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|iobase
operator|=
name|porttab
index|[
name|i
index|]
operator|)
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|porttab
index|[
name|i
index|]
operator|==
operator|-
literal|1
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|!
name|cx_is_free_res
argument_list|(
name|devices
index|[
name|k
index|]
argument_list|,
literal|0
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|iobase
argument_list|,
name|iobase
operator|+
name|NPORT
argument_list|,
name|NPORT
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|cx_probe_board
argument_list|(
name|iobase
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|bus_set_resource
argument_list|(
name|devices
index|[
name|k
index|]
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|0
argument_list|,
name|iobase
argument_list|,
name|NPORT
argument_list|)
expr_stmt|;
name|porttab
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|devices
index|[
name|k
index|]
argument_list|,
literal|"Cronyx Sigma"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|porttab
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|device_delete_child
argument_list|(
name|device_get_parent
argument_list|(
name|devices
index|[
name|k
index|]
argument_list|)
argument_list|,
name|devices
index|[
name|k
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|devices
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|cx_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|unit
init|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_long
name|iobase
decl_stmt|,
name|rescount
decl_stmt|;
if|if
condition|(
operator|!
name|device_get_desc
argument_list|(
name|dev
argument_list|)
operator|||
name|strcmp
argument_list|(
name|device_get_desc
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"Cronyx Sigma"
argument_list|)
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|0
argument_list|,
operator|&
name|iobase
argument_list|,
operator|&
name|rescount
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"cx%d: Couldn't get IOPORT\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
operator|!
name|cx_is_free_res
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|iobase
argument_list|,
name|iobase
operator|+
name|NPORT
argument_list|,
name|NPORT
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"cx%d: Resource IOPORT isn't free %lx\n"
argument_list|,
name|unit
argument_list|,
name|iobase
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|porttab
index|[
name|i
index|]
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|porttab
index|[
name|i
index|]
operator|==
name|iobase
condition|)
block|{
name|porttab
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|porttab
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
operator|!
name|cx_probe_board
argument_list|(
name|iobase
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"cx%d: probing for Sigma at %lx faild\n"
argument_list|,
name|unit
argument_list|,
name|iobase
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
end_if

begin_function
specifier|static
name|void
name|cx_bus_dmamap_addr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|unsigned
name|long
modifier|*
name|addr
decl_stmt|;
if|if
condition|(
name|error
condition|)
return|return;
name|KASSERT
argument_list|(
name|nseg
operator|==
literal|1
argument_list|,
operator|(
literal|"too many DMA segments, %d should be 1"
operator|,
name|nseg
operator|)
argument_list|)
expr_stmt|;
name|addr
operator|=
name|arg
expr_stmt|;
operator|*
name|addr
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cx_bus_dma_mem_alloc
parameter_list|(
name|int
name|bnum
parameter_list|,
name|int
name|cnum
parameter_list|,
name|cx_dma_mem_t
modifier|*
name|dmem
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
literal|16
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_24BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|dmem
operator|->
name|size
argument_list|,
literal|1
argument_list|,
name|dmem
operator|->
name|size
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|dmem
operator|->
name|dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|cnum
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|"cx%d-%d: "
argument_list|,
name|bnum
argument_list|,
name|cnum
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"cx%d: "
argument_list|,
name|bnum
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"couldn't allocate tag for dma memory\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|dmem
operator|->
name|dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|dmem
operator|->
name|virt
argument_list|,
name|BUS_DMA_NOWAIT
operator||
name|BUS_DMA_ZERO
argument_list|,
operator|&
name|dmem
operator|->
name|mapp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|cnum
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|"cx%d-%d: "
argument_list|,
name|bnum
argument_list|,
name|cnum
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"cx%d: "
argument_list|,
name|bnum
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"couldn't allocate mem for dma memory\n"
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|dmem
operator|->
name|dmat
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|dmem
operator|->
name|dmat
argument_list|,
name|dmem
operator|->
name|mapp
argument_list|,
name|dmem
operator|->
name|virt
argument_list|,
name|dmem
operator|->
name|size
argument_list|,
name|cx_bus_dmamap_addr
argument_list|,
operator|&
name|dmem
operator|->
name|phys
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|cnum
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|"cx%d-%d: "
argument_list|,
name|bnum
argument_list|,
name|cnum
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"cx%d: "
argument_list|,
name|bnum
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"couldn't load mem map for dma memory\n"
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|dmem
operator|->
name|dmat
argument_list|,
name|dmem
operator|->
name|virt
argument_list|,
name|dmem
operator|->
name|mapp
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|dmem
operator|->
name|dmat
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cx_bus_dma_mem_free
parameter_list|(
name|cx_dma_mem_t
modifier|*
name|dmem
parameter_list|)
block|{
name|bus_dmamap_unload
argument_list|(
name|dmem
operator|->
name|dmat
argument_list|,
name|dmem
operator|->
name|mapp
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|dmem
operator|->
name|dmat
argument_list|,
name|dmem
operator|->
name|virt
argument_list|,
name|dmem
operator|->
name|mapp
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|dmem
operator|->
name|dmat
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|int
name|cx_bus_dma_mem_alloc
parameter_list|(
name|int
name|bnum
parameter_list|,
name|int
name|cnum
parameter_list|,
name|cx_dma_mem_t
modifier|*
name|dmem
parameter_list|)
block|{
name|dmem
operator|->
name|virt
operator|=
name|contigmalloc
argument_list|(
name|dmem
operator|->
name|size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|,
literal|0x100000
argument_list|,
literal|0x1000000
argument_list|,
literal|16
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dmem
operator|->
name|virt
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|cnum
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|"cx%d-%d: "
argument_list|,
name|bnum
argument_list|,
name|cnum
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"cx%d: "
argument_list|,
name|bnum
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"couldn't allocate memory for dma memory\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|dmem
operator|->
name|phys
operator|=
name|vtophys
argument_list|(
name|dmem
operator|->
name|virt
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cx_bus_dma_mem_free
parameter_list|(
name|cx_dma_mem_t
modifier|*
name|dmem
parameter_list|)
block|{
name|contigfree
argument_list|(
name|dmem
operator|->
name|virt
argument_list|,
name|dmem
operator|->
name|size
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * The adapter is present, initialize the driver structures.  */
end_comment

begin_function
specifier|static
name|int
name|cx_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|bdrv_t
modifier|*
name|bd
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_long
name|iobase
decl_stmt|,
name|drq
decl_stmt|,
name|irq
decl_stmt|,
name|rescount
decl_stmt|;
name|int
name|unit
init|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|cx_board_t
modifier|*
name|b
decl_stmt|;
name|cx_chan_t
modifier|*
name|c
decl_stmt|;
name|drv_t
modifier|*
name|d
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|s
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|bd
operator|!=
name|NULL
operator|)
argument_list|,
operator|(
literal|"cx%d: NULL device softc\n"
operator|,
name|unit
operator|)
argument_list|)
expr_stmt|;
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|0
argument_list|,
operator|&
name|iobase
argument_list|,
operator|&
name|rescount
argument_list|)
expr_stmt|;
name|bd
operator|->
name|base_rid
operator|=
literal|0
expr_stmt|;
name|bd
operator|->
name|base_res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|bd
operator|->
name|base_rid
argument_list|,
name|iobase
argument_list|,
name|iobase
operator|+
name|NPORT
argument_list|,
name|NPORT
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bd
operator|->
name|base_res
condition|)
block|{
name|printf
argument_list|(
literal|"cx%d: cannot allocate base address\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_DRQ
argument_list|,
literal|0
argument_list|,
operator|&
name|drq
argument_list|,
operator|&
name|rescount
argument_list|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|drq
operator|=
name|dmatab
index|[
name|i
index|]
operator|)
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|cx_is_free_res
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|SYS_RES_DRQ
argument_list|,
name|drq
argument_list|,
name|drq
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
condition|)
continue|continue;
name|bus_set_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_DRQ
argument_list|,
literal|0
argument_list|,
name|drq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dmatab
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|bd
operator|->
name|base_rid
argument_list|,
name|bd
operator|->
name|base_res
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cx%d: Couldn't get DRQ\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
block|}
name|bd
operator|->
name|drq_rid
operator|=
literal|0
expr_stmt|;
name|bd
operator|->
name|drq_res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_DRQ
argument_list|,
operator|&
name|bd
operator|->
name|drq_rid
argument_list|,
name|drq
argument_list|,
name|drq
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bd
operator|->
name|drq_res
condition|)
block|{
name|printf
argument_list|(
literal|"cx%d: cannot allocate drq\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|bd
operator|->
name|base_rid
argument_list|,
name|bd
operator|->
name|base_res
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
operator|&
name|irq
argument_list|,
operator|&
name|rescount
argument_list|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|irq
operator|=
name|irqtab
index|[
name|i
index|]
operator|)
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|cx_is_free_res
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|irq
argument_list|,
name|irq
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
condition|)
continue|continue;
name|bus_set_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|irq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|irqtab
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_DRQ
argument_list|,
name|bd
operator|->
name|drq_rid
argument_list|,
name|bd
operator|->
name|drq_res
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|bd
operator|->
name|base_rid
argument_list|,
name|bd
operator|->
name|base_res
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cx%d: Couldn't get IRQ\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
block|}
name|bd
operator|->
name|irq_rid
operator|=
literal|0
expr_stmt|;
name|bd
operator|->
name|irq_res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|bd
operator|->
name|irq_rid
argument_list|,
name|irq
argument_list|,
name|irq
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bd
operator|->
name|irq_res
condition|)
block|{
name|printf
argument_list|(
literal|"cx%d: Couldn't allocate irq\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_DRQ
argument_list|,
name|bd
operator|->
name|drq_rid
argument_list|,
name|bd
operator|->
name|drq_res
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|bd
operator|->
name|base_rid
argument_list|,
name|bd
operator|->
name|base_res
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|b
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|cx_board_t
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b
condition|)
block|{
name|printf
argument_list|(
literal|"cx:%d: Couldn't allocate memory\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|adapter
index|[
name|unit
index|]
operator|=
name|b
expr_stmt|;
name|bzero
argument_list|(
name|b
argument_list|,
sizeof|sizeof
argument_list|(
name|cx_board_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cx_open_board
argument_list|(
name|b
argument_list|,
name|unit
argument_list|,
name|iobase
argument_list|,
name|irq
argument_list|,
name|drq
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"cx%d: error loading firmware\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|b
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|bd
operator|->
name|irq_rid
argument_list|,
name|bd
operator|->
name|irq_res
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_DRQ
argument_list|,
name|bd
operator|->
name|drq_rid
argument_list|,
name|bd
operator|->
name|drq_res
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|bd
operator|->
name|base_rid
argument_list|,
name|bd
operator|->
name|base_res
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|bd
operator|->
name|board
operator|=
name|b
expr_stmt|;
if|if
condition|(
operator|!
name|probe_irq
argument_list|(
name|b
argument_list|,
name|irq
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"cx%d: irq %ld not functional\n"
argument_list|,
name|unit
argument_list|,
name|irq
argument_list|)
expr_stmt|;
name|bd
operator|->
name|board
operator|=
literal|0
expr_stmt|;
name|adapter
index|[
name|unit
index|]
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|b
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|bd
operator|->
name|irq_rid
argument_list|,
name|bd
operator|->
name|irq_res
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_DRQ
argument_list|,
name|bd
operator|->
name|drq_rid
argument_list|,
name|bd
operator|->
name|drq_res
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|bd
operator|->
name|base_rid
argument_list|,
name|bd
operator|->
name|base_res
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|bd
operator|->
name|irq_res
argument_list|,
name|INTR_TYPE_NET
argument_list|,
name|cx_intr
argument_list|,
name|bd
argument_list|,
operator|&
name|bd
operator|->
name|intrhand
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"cx%d: Can't setup irq %ld\n"
argument_list|,
name|unit
argument_list|,
name|irq
argument_list|)
expr_stmt|;
name|bd
operator|->
name|board
operator|=
literal|0
expr_stmt|;
name|adapter
index|[
name|unit
index|]
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|b
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|bd
operator|->
name|irq_rid
argument_list|,
name|bd
operator|->
name|irq_res
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_DRQ
argument_list|,
name|bd
operator|->
name|drq_rid
argument_list|,
name|bd
operator|->
name|drq_res
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|bd
operator|->
name|base_rid
argument_list|,
name|bd
operator|->
name|base_res
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|cx_init
argument_list|(
name|b
argument_list|,
name|b
operator|->
name|num
argument_list|,
name|b
operator|->
name|port
argument_list|,
name|irq
argument_list|,
name|drq
argument_list|)
expr_stmt|;
name|cx_setup_board
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cx%d:<Cronyx-Sigma-%s>\n"
argument_list|,
name|b
operator|->
name|num
argument_list|,
name|b
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|b
operator|->
name|chan
init|;
name|c
operator|<
name|b
operator|->
name|chan
operator|+
name|NCHAN
condition|;
operator|++
name|c
control|)
block|{
name|char
modifier|*
name|dnmt
init|=
literal|"tty %x"
decl_stmt|;
name|char
modifier|*
name|dnmc
init|=
literal|"cua %x"
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|T_NONE
condition|)
continue|continue;
name|d
operator|=
operator|&
name|bd
operator|->
name|channel
index|[
name|c
operator|->
name|num
index|]
expr_stmt|;
name|d
operator|->
name|dmamem
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
name|cx_buf_t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cx_bus_dma_mem_alloc
argument_list|(
name|unit
argument_list|,
name|c
operator|->
name|num
argument_list|,
operator|&
name|d
operator|->
name|dmamem
argument_list|)
condition|)
continue|continue;
name|channel
index|[
name|b
operator|->
name|num
operator|*
name|NCHAN
operator|+
name|c
operator|->
name|num
index|]
operator|=
name|d
expr_stmt|;
name|sprintf
argument_list|(
name|d
operator|->
name|name
argument_list|,
literal|"cx%d.%d"
argument_list|,
name|b
operator|->
name|num
argument_list|,
name|c
operator|->
name|num
argument_list|)
expr_stmt|;
name|d
operator|->
name|board
operator|=
name|b
expr_stmt|;
name|d
operator|->
name|chan
operator|=
name|c
expr_stmt|;
name|d
operator|->
name|open_dev
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|sys
operator|=
name|d
expr_stmt|;
switch|switch
condition|(
name|c
operator|->
name|type
condition|)
block|{
case|case
name|T_SYNC_RS232
case|:
case|case
name|T_SYNC_V35
case|:
case|case
name|T_SYNC_RS449
case|:
case|case
name|T_UNIV
case|:
case|case
name|T_UNIV_RS232
case|:
case|case
name|T_UNIV_RS449
case|:
case|case
name|T_UNIV_V35
case|:
ifdef|#
directive|ifdef
name|NETGRAPH
if|if
condition|(
name|ng_make_node_common
argument_list|(
operator|&
name|typestruct
argument_list|,
operator|&
name|d
operator|->
name|node
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: cannot make common node\n"
argument_list|,
name|d
operator|->
name|name
argument_list|)
expr_stmt|;
name|channel
index|[
name|b
operator|->
name|num
operator|*
name|NCHAN
operator|+
name|c
operator|->
name|num
index|]
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|sys
operator|=
literal|0
expr_stmt|;
name|cx_bus_dma_mem_free
argument_list|(
operator|&
name|d
operator|->
name|dmamem
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|NG_NODE_SET_PRIVATE
argument_list|(
name|d
operator|->
name|node
argument_list|,
name|d
argument_list|)
expr_stmt|;
else|#
directive|else
name|d
operator|->
name|node
operator|->
name|private
operator|=
name|d
expr_stmt|;
endif|#
directive|endif
name|sprintf
argument_list|(
name|d
operator|->
name|nodename
argument_list|,
literal|"%s%d"
argument_list|,
name|NG_CX_NODE_TYPE
argument_list|,
name|c
operator|->
name|board
operator|->
name|num
operator|*
name|NCHAN
operator|+
name|c
operator|->
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|ng_name_node
argument_list|(
name|d
operator|->
name|node
argument_list|,
name|d
operator|->
name|nodename
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: cannot name node\n"
argument_list|,
name|d
operator|->
name|nodename
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|NG_NODE_UNREF
argument_list|(
name|d
operator|->
name|node
argument_list|)
expr_stmt|;
else|#
directive|else
name|ng_rmnode
argument_list|(
name|d
operator|->
name|node
argument_list|)
expr_stmt|;
name|ng_unref
argument_list|(
name|d
operator|->
name|node
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|channel
index|[
name|b
operator|->
name|num
operator|*
name|NCHAN
operator|+
name|c
operator|->
name|num
index|]
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|sys
operator|=
literal|0
expr_stmt|;
name|cx_bus_dma_mem_free
argument_list|(
operator|&
name|d
operator|->
name|dmamem
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|d
operator|->
name|lo_queue
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|d
operator|->
name|hi_queue
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|mtx_init
argument_list|(
operator|&
name|d
operator|->
name|lo_queue
operator|.
name|ifq_mtx
argument_list|,
literal|"cx_queue_lo"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|d
operator|->
name|hi_queue
operator|.
name|ifq_mtx
argument_list|,
literal|"cx_queue_hi"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/*NETGRAPH*/
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_softc
operator|=
name|d
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>
literal|501000
name|if_initname
argument_list|(
operator|&
name|d
operator|->
name|pp
operator|.
name|pp_if
argument_list|,
literal|"cx"
argument_list|,
name|b
operator|->
name|num
operator|*
name|NCHAN
operator|+
name|c
operator|->
name|num
argument_list|)
expr_stmt|;
else|#
directive|else
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_unit
operator|=
name|b
operator|->
name|num
operator|*
name|NCHAN
operator|+
name|c
operator|->
name|num
expr_stmt|;
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_name
operator|=
literal|"cx"
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_mtu
operator|=
name|PP_MTU
expr_stmt|;
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_flags
operator|=
name|IFF_POINTOPOINT
operator||
name|IFF_MULTICAST
operator||
name|IFF_NEEDSGIANT
expr_stmt|;
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_ioctl
operator|=
name|cx_sioctl
expr_stmt|;
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_start
operator|=
name|cx_ifstart
expr_stmt|;
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_watchdog
operator|=
name|cx_ifwatchdog
expr_stmt|;
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_init
operator|=
name|cx_initialize
expr_stmt|;
name|sppp_attach
argument_list|(
operator|&
name|d
operator|->
name|pp
operator|.
name|pp_if
argument_list|)
expr_stmt|;
name|if_attach
argument_list|(
operator|&
name|d
operator|->
name|pp
operator|.
name|pp_if
argument_list|)
expr_stmt|;
name|d
operator|->
name|pp
operator|.
name|pp_tlf
operator|=
name|cx_tlf
expr_stmt|;
name|d
operator|->
name|pp
operator|.
name|pp_tls
operator|=
name|cx_tls
expr_stmt|;
comment|/* If BPF is in the kernel, call the attach for it. 		 * Size of PPP header is 4 bytes. */
name|bpfattach
argument_list|(
operator|&
name|d
operator|->
name|pp
operator|.
name|pp_if
argument_list|,
name|DLT_PPP
argument_list|,
literal|4
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*NETGRAPH*/
block|}
name|cx_start_chan
argument_list|(
name|c
argument_list|,
name|d
operator|->
name|dmamem
operator|.
name|virt
argument_list|,
name|d
operator|->
name|dmamem
operator|.
name|phys
argument_list|)
expr_stmt|;
name|cx_register_receive
argument_list|(
name|c
argument_list|,
operator|&
name|cx_receive
argument_list|)
expr_stmt|;
name|cx_register_transmit
argument_list|(
name|c
argument_list|,
operator|&
name|cx_transmit
argument_list|)
expr_stmt|;
name|cx_register_error
argument_list|(
name|c
argument_list|,
operator|&
name|cx_error
argument_list|)
expr_stmt|;
name|cx_register_modem
argument_list|(
name|c
argument_list|,
operator|&
name|cx_modem
argument_list|)
expr_stmt|;
name|dnmt
index|[
literal|3
index|]
operator|=
literal|'x'
operator|+
name|b
operator|->
name|num
expr_stmt|;
name|dnmc
index|[
literal|3
index|]
operator|=
literal|'x'
operator|+
name|b
operator|->
name|num
expr_stmt|;
name|d
operator|->
name|devt
index|[
literal|0
index|]
operator|=
name|make_dev
argument_list|(
operator|&
name|cx_cdevsw
argument_list|,
name|b
operator|->
name|num
operator|*
name|NCHAN
operator|+
name|c
operator|->
name|num
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0644
argument_list|,
name|dnmt
argument_list|,
name|b
operator|->
name|num
operator|*
name|NCHAN
operator|+
name|c
operator|->
name|num
argument_list|)
expr_stmt|;
name|d
operator|->
name|devt
index|[
literal|1
index|]
operator|=
name|make_dev
argument_list|(
operator|&
name|cx_cdevsw
argument_list|,
name|b
operator|->
name|num
operator|*
name|NCHAN
operator|+
name|c
operator|->
name|num
operator|+
literal|64
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"cx%d"
argument_list|,
name|b
operator|->
name|num
operator|*
name|NCHAN
operator|+
name|c
operator|->
name|num
argument_list|)
expr_stmt|;
name|d
operator|->
name|devt
index|[
literal|2
index|]
operator|=
name|make_dev
argument_list|(
operator|&
name|cx_cdevsw
argument_list|,
name|b
operator|->
name|num
operator|*
name|NCHAN
operator|+
name|c
operator|->
name|num
operator|+
literal|128
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0660
argument_list|,
name|dnmc
argument_list|,
name|b
operator|->
name|num
operator|*
name|NCHAN
operator|+
name|c
operator|->
name|num
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cx_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|bdrv_t
modifier|*
name|bd
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|cx_board_t
modifier|*
name|b
init|=
name|bd
operator|->
name|board
decl_stmt|;
name|cx_chan_t
modifier|*
name|c
decl_stmt|;
name|int
name|s
init|=
name|splhigh
argument_list|()
decl_stmt|;
comment|/* Check if the device is busy (open). */
for|for
control|(
name|c
operator|=
name|b
operator|->
name|chan
init|;
name|c
operator|<
name|b
operator|->
name|chan
operator|+
name|NCHAN
condition|;
operator|++
name|c
control|)
block|{
name|drv_t
modifier|*
name|d
init|=
operator|(
name|drv_t
operator|*
operator|)
name|c
operator|->
name|sys
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|||
name|d
operator|->
name|chan
operator|->
name|type
operator|==
name|T_NONE
condition|)
continue|continue;
if|if
condition|(
name|d
operator|->
name|lock
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
if|if
condition|(
name|c
operator|->
name|mode
operator|==
name|M_ASYNC
operator|&&
name|d
operator|->
name|tty
operator|&&
operator|(
name|d
operator|->
name|tty
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|&&
operator|(
name|d
operator|->
name|open_dev
operator||
literal|0x2
operator|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
if|if
condition|(
name|d
operator|->
name|running
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
block|}
comment|/* Deactivate the timeout routine. And soft interrupt*/
if|if
condition|(
name|led_timo
index|[
name|b
operator|->
name|num
index|]
operator|.
name|callout
condition|)
name|untimeout
argument_list|(
name|cx_led_off
argument_list|,
name|b
argument_list|,
name|led_timo
index|[
name|b
operator|->
name|num
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|b
operator|->
name|chan
init|;
name|c
operator|<
name|b
operator|->
name|chan
operator|+
name|NCHAN
condition|;
operator|++
name|c
control|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|c
operator|->
name|sys
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|||
name|d
operator|->
name|chan
operator|->
name|type
operator|==
name|T_NONE
condition|)
continue|continue;
if|if
condition|(
name|d
operator|->
name|dcd_timeout_handle
operator|.
name|callout
condition|)
name|untimeout
argument_list|(
name|cx_carrier
argument_list|,
name|c
argument_list|,
name|d
operator|->
name|dcd_timeout_handle
argument_list|)
expr_stmt|;
block|}
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|bd
operator|->
name|irq_res
argument_list|,
name|bd
operator|->
name|intrhand
argument_list|)
expr_stmt|;
name|bus_deactivate_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|bd
operator|->
name|irq_rid
argument_list|,
name|bd
operator|->
name|irq_res
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|bd
operator|->
name|irq_rid
argument_list|,
name|bd
operator|->
name|irq_res
argument_list|)
expr_stmt|;
name|bus_deactivate_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_DRQ
argument_list|,
name|bd
operator|->
name|drq_rid
argument_list|,
name|bd
operator|->
name|drq_res
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_DRQ
argument_list|,
name|bd
operator|->
name|drq_rid
argument_list|,
name|bd
operator|->
name|drq_res
argument_list|)
expr_stmt|;
name|bus_deactivate_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|bd
operator|->
name|base_rid
argument_list|,
name|bd
operator|->
name|irq_res
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|bd
operator|->
name|base_rid
argument_list|,
name|bd
operator|->
name|base_res
argument_list|)
expr_stmt|;
name|cx_close_board
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* Detach the interfaces, free buffer memory. */
for|for
control|(
name|c
operator|=
name|b
operator|->
name|chan
init|;
name|c
operator|<
name|b
operator|->
name|chan
operator|+
name|NCHAN
condition|;
operator|++
name|c
control|)
block|{
name|drv_t
modifier|*
name|d
init|=
operator|(
name|drv_t
operator|*
operator|)
name|c
operator|->
name|sys
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|||
name|d
operator|->
name|chan
operator|->
name|type
operator|==
name|T_NONE
condition|)
continue|continue;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|502113
if|if
condition|(
name|d
operator|->
name|tty
condition|)
block|{
name|ttyrel
argument_list|(
name|d
operator|->
name|tty
argument_list|)
expr_stmt|;
name|d
operator|->
name|tty
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NETGRAPH
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
if|if
condition|(
name|d
operator|->
name|node
condition|)
block|{
name|ng_rmnode_self
argument_list|(
name|d
operator|->
name|node
argument_list|)
expr_stmt|;
name|NG_NODE_UNREF
argument_list|(
name|d
operator|->
name|node
argument_list|)
expr_stmt|;
name|d
operator|->
name|node
operator|=
name|NULL
expr_stmt|;
block|}
name|mtx_destroy
argument_list|(
operator|&
name|d
operator|->
name|lo_queue
operator|.
name|ifq_mtx
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|d
operator|->
name|hi_queue
operator|.
name|ifq_mtx
argument_list|)
expr_stmt|;
else|#
directive|else
name|ng_rmnode
argument_list|(
name|d
operator|->
name|node
argument_list|)
expr_stmt|;
name|d
operator|->
name|node
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|410000
operator|&&
name|NBPFILTER
operator|>
literal|0
comment|/* Detach from the packet filter list of interfaces. */
name|bpfdetach
argument_list|(
operator|&
name|d
operator|->
name|pp
operator|.
name|pp_if
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Detach from the sync PPP list. */
name|sppp_detach
argument_list|(
operator|&
name|d
operator|->
name|pp
operator|.
name|pp_if
argument_list|)
expr_stmt|;
name|if_detach
argument_list|(
operator|&
name|d
operator|->
name|pp
operator|.
name|pp_if
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|destroy_dev
argument_list|(
name|d
operator|->
name|devt
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|destroy_dev
argument_list|(
name|d
operator|->
name|devt
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|destroy_dev
argument_list|(
name|d
operator|->
name|devt
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
name|cx_led_off
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|led_timo
index|[
name|b
operator|->
name|num
index|]
operator|.
name|callout
condition|)
name|untimeout
argument_list|(
name|cx_led_off
argument_list|,
name|b
argument_list|,
name|led_timo
index|[
name|b
operator|->
name|num
index|]
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
for|for
control|(
name|c
operator|=
name|b
operator|->
name|chan
init|;
name|c
operator|<
name|b
operator|->
name|chan
operator|+
name|NCHAN
condition|;
operator|++
name|c
control|)
block|{
name|drv_t
modifier|*
name|d
init|=
operator|(
name|drv_t
operator|*
operator|)
name|c
operator|->
name|sys
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|||
name|d
operator|->
name|chan
operator|->
name|type
operator|==
name|T_NONE
condition|)
continue|continue;
comment|/* Deallocate buffers. */
name|cx_bus_dma_mem_free
argument_list|(
operator|&
name|d
operator|->
name|dmamem
argument_list|)
expr_stmt|;
block|}
name|bd
operator|->
name|board
operator|=
literal|0
expr_stmt|;
name|adapter
index|[
name|b
operator|->
name|num
index|]
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|b
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NETGRAPH
end_ifndef

begin_function
specifier|static
name|void
name|cx_ifstart
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|cx_start
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cx_ifwatchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|cx_watchdog
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cx_tlf
parameter_list|(
name|struct
name|sppp
modifier|*
name|sp
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|sp
operator|->
name|pp_if
operator|.
name|if_softc
decl_stmt|;
name|CX_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"cx_tlf\n"
operator|)
argument_list|)
expr_stmt|;
comment|/*	cx_set_dtr (d->chan, 0);*/
comment|/*	cx_set_rts (d->chan, 0);*/
name|sp
operator|->
name|pp_down
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cx_tls
parameter_list|(
name|struct
name|sppp
modifier|*
name|sp
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|sp
operator|->
name|pp_if
operator|.
name|if_softc
decl_stmt|;
name|CX_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"cx_tls\n"
operator|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|pp_up
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialization of interface.  * It seems to be never called by upper level.  */
end_comment

begin_function
specifier|static
name|void
name|cx_initialize
parameter_list|(
name|void
modifier|*
name|softc
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|softc
decl_stmt|;
name|CX_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"cx_initialize\n"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process an ioctl request.  */
end_comment

begin_function
specifier|static
name|int
name|cx_sioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|s
decl_stmt|,
name|was_up
decl_stmt|,
name|should_be_up
decl_stmt|;
comment|/* No socket ioctls while the channel is in async mode. */
if|if
condition|(
name|d
operator|->
name|chan
operator|->
name|type
operator|==
name|T_NONE
operator|||
name|d
operator|->
name|chan
operator|->
name|mode
operator|==
name|M_ASYNC
condition|)
return|return
name|EBUSY
return|;
comment|/* Socket ioctls on slave subchannels are not allowed. */
name|was_up
operator|=
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|!=
literal|0
expr_stmt|;
name|error
operator|=
name|sppp_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
operator|)
condition|)
name|d
operator|->
name|chan
operator|->
name|debug
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|d
operator|->
name|chan
operator|->
name|debug
condition|)
name|d
operator|->
name|chan
operator|->
name|debug
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
default|default:
name|CX_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl 0x%lx\n"
operator|,
name|cmd
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SIOCADDMULTI
case|:
name|CX_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"SIOCADDMULTI\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SIOCDELMULTI
case|:
name|CX_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"SIOCDELMULTI\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SIOCSIFFLAGS
case|:
name|CX_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"SIOCSIFFLAGS\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFADDR
case|:
name|CX_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"SIOCSIFADDR\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* We get here only in case of SIFFLAGS or SIFADDR. */
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|should_be_up
operator|=
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|was_up
operator|&&
name|should_be_up
condition|)
block|{
comment|/* Interface goes up -- start it. */
name|cx_up
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|cx_start
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|was_up
operator|&&
operator|!
name|should_be_up
condition|)
block|{
comment|/* Interface is going down -- stop it. */
comment|/* if ((d->pp.pp_flags& PP_FR) || (ifp->if_flags& PP_CISCO))*/
name|cx_down
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*NETGRAPH*/
end_comment

begin_comment
comment|/*  * Stop the interface.  Called on splimp().  */
end_comment

begin_function
specifier|static
name|void
name|cx_down
parameter_list|(
name|drv_t
modifier|*
name|d
parameter_list|)
block|{
name|int
name|s
init|=
name|splhigh
argument_list|()
decl_stmt|;
name|CX_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"cx_down\n"
operator|)
argument_list|)
expr_stmt|;
name|cx_set_dtr
argument_list|(
name|d
operator|->
name|chan
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cx_set_rts
argument_list|(
name|d
operator|->
name|chan
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|d
operator|->
name|running
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start the interface.  Called on splimp().  */
end_comment

begin_function
specifier|static
name|void
name|cx_up
parameter_list|(
name|drv_t
modifier|*
name|d
parameter_list|)
block|{
name|int
name|s
init|=
name|splhigh
argument_list|()
decl_stmt|;
name|CX_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"cx_up\n"
operator|)
argument_list|)
expr_stmt|;
name|cx_set_dtr
argument_list|(
name|d
operator|->
name|chan
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cx_set_rts
argument_list|(
name|d
operator|->
name|chan
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|d
operator|->
name|running
operator|=
literal|1
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start output on the (slave) interface.  Get another datagram to send  * off of the interface queue, and copy it to the interface  * before starting the output.  */
end_comment

begin_function
specifier|static
name|void
name|cx_send
parameter_list|(
name|drv_t
modifier|*
name|d
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|u_short
name|len
decl_stmt|;
name|CX_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"cx_send\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* No output if the interface is down. */
if|if
condition|(
operator|!
name|d
operator|->
name|running
condition|)
return|return;
comment|/* No output if the modem is off. */
if|if
condition|(
operator|!
name|cx_get_dsr
argument_list|(
name|d
operator|->
name|chan
argument_list|)
operator|&&
operator|!
name|cx_get_loop
argument_list|(
name|d
operator|->
name|chan
argument_list|)
condition|)
return|return;
if|if
condition|(
name|cx_buf_free
argument_list|(
name|d
operator|->
name|chan
argument_list|)
condition|)
block|{
comment|/* Get the packet to send. */
ifdef|#
directive|ifdef
name|NETGRAPH
name|IF_DEQUEUE
argument_list|(
operator|&
name|d
operator|->
name|hi_queue
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
name|IF_DEQUEUE
argument_list|(
operator|&
name|d
operator|->
name|lo_queue
argument_list|,
name|m
argument_list|)
expr_stmt|;
else|#
directive|else
name|m
operator|=
name|sppp_dequeue
argument_list|(
operator|&
name|d
operator|->
name|pp
operator|.
name|pp_if
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|m
condition|)
return|return;
ifndef|#
directive|ifndef
name|NETGRAPH
if|if
condition|(
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_bpf
condition|)
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|BPF_MTAP
argument_list|(
operator|&
name|d
operator|->
name|pp
operator|.
name|pp_if
argument_list|,
name|m
argument_list|)
expr_stmt|;
else|#
directive|else
name|bpf_mtap
argument_list|(
operator|&
name|d
operator|->
name|pp
operator|.
name|pp_if
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
if|if
condition|(
operator|!
name|m
operator|->
name|m_next
condition|)
name|cx_send_packet
argument_list|(
name|d
operator|->
name|chan
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|u_char
name|buf
index|[
name|DMABUFSZ
index|]
decl_stmt|;
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|cx_send_packet
argument_list|(
name|d
operator|->
name|chan
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* Set up transmit timeout, 10 seconds. */
ifdef|#
directive|ifdef
name|NETGRAPH
name|d
operator|->
name|timeout
operator|=
literal|10
expr_stmt|;
else|#
directive|else
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_timer
operator|=
literal|10
expr_stmt|;
endif|#
directive|endif
block|}
ifndef|#
directive|ifndef
name|NETGRAPH
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Start output on the interface.  * Always called on splimp().  */
end_comment

begin_function
specifier|static
name|void
name|cx_start
parameter_list|(
name|drv_t
modifier|*
name|d
parameter_list|)
block|{
name|int
name|s
init|=
name|splhigh
argument_list|()
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|running
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|chan
operator|->
name|dtr
condition|)
name|cx_set_dtr
argument_list|(
name|d
operator|->
name|chan
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|chan
operator|->
name|rts
condition|)
name|cx_set_rts
argument_list|(
name|d
operator|->
name|chan
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cx_send
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle transmit timeouts.  * Recover after lost transmit interrupts.  * Always called on splimp().  */
end_comment

begin_function
specifier|static
name|void
name|cx_watchdog
parameter_list|(
name|drv_t
modifier|*
name|d
parameter_list|)
block|{
name|int
name|s
init|=
name|splhigh
argument_list|()
decl_stmt|;
name|CX_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"device timeout\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|running
condition|)
block|{
name|cx_setup_chan
argument_list|(
name|d
operator|->
name|chan
argument_list|)
expr_stmt|;
name|cx_start_chan
argument_list|(
name|d
operator|->
name|chan
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cx_set_dtr
argument_list|(
name|d
operator|->
name|chan
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cx_set_rts
argument_list|(
name|d
operator|->
name|chan
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cx_start
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Transmit callback function.  */
end_comment

begin_function
specifier|static
name|void
name|cx_transmit
parameter_list|(
name|cx_chan_t
modifier|*
name|c
parameter_list|,
name|void
modifier|*
name|attachment
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|c
operator|->
name|sys
decl_stmt|;
if|if
condition|(
operator|!
name|d
condition|)
return|return;
if|if
condition|(
name|c
operator|->
name|mode
operator|==
name|M_ASYNC
operator|&&
name|d
operator|->
name|tty
condition|)
block|{
name|d
operator|->
name|tty
operator|->
name|t_state
operator|&=
operator|~
operator|(
name|TS_BUSY
operator||
name|TS_FLUSH
operator|)
expr_stmt|;
name|d
operator|->
name|atimeout
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|tty
operator|->
name|t_dev
condition|)
block|{
name|d
operator|->
name|intr_action
operator||=
name|CX_WRITE
expr_stmt|;
name|MY_SOFT_INTR
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|swi_sched
argument_list|(
name|cx_fast_ih
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|setsofttty
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
return|return;
block|}
ifdef|#
directive|ifdef
name|NETGRAPH
name|d
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
else|#
directive|else
operator|++
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_opackets
expr_stmt|;
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_timer
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|cx_start
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process the received packet.  */
end_comment

begin_function
specifier|static
name|void
name|cx_receive
parameter_list|(
name|cx_chan_t
modifier|*
name|c
parameter_list|,
name|char
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|c
operator|->
name|sys
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|char
modifier|*
name|cc
init|=
name|data
decl_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
operator|&&
name|defined
name|NETGRAPH
name|int
name|error
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|d
condition|)
return|return;
if|if
condition|(
name|c
operator|->
name|mode
operator|==
name|M_ASYNC
operator|&&
name|d
operator|->
name|tty
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|tty
operator|->
name|t_state
operator|&
name|TS_ISOPEN
condition|)
block|{
name|async_q
modifier|*
name|q
init|=
operator|&
name|d
operator|->
name|aqueue
decl_stmt|;
name|int
name|size
init|=
name|BF_SZ
operator|-
literal|1
operator|-
name|AQ_GSZ
argument_list|(
name|q
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
operator|&&
operator|!
name|size
condition|)
return|return;
if|if
condition|(
name|len
operator|>
name|size
condition|)
block|{
name|c
operator|->
name|ierrs
operator|++
expr_stmt|;
name|cx_error
argument_list|(
name|c
argument_list|,
name|CX_OVERRUN
argument_list|)
expr_stmt|;
name|len
operator|=
name|size
operator|-
literal|1
expr_stmt|;
block|}
while|while
condition|(
name|len
operator|--
condition|)
block|{
name|AQ_PUSH
argument_list|(
name|q
argument_list|,
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|cc
argument_list|)
expr_stmt|;
name|cc
operator|++
expr_stmt|;
block|}
name|d
operator|->
name|intr_action
operator||=
name|CX_READ
expr_stmt|;
name|MY_SOFT_INTR
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|swi_sched
argument_list|(
name|cx_fast_ih
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|setsofttty
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
return|return;
block|}
if|if
condition|(
operator|!
name|d
operator|->
name|running
condition|)
return|return;
name|m
operator|=
name|makembuf
argument_list|(
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|CX_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"no memory for packet\n"
operator|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NETGRAPH
operator|++
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_iqdrops
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
if|if
condition|(
name|c
operator|->
name|debug
operator|>
literal|1
condition|)
name|printmbuf
argument_list|(
name|m
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NETGRAPH
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|NG_SEND_DATA_ONLY
argument_list|(
name|error
argument_list|,
name|d
operator|->
name|hook
argument_list|,
name|m
argument_list|)
expr_stmt|;
else|#
directive|else
name|ng_queue_data
argument_list|(
name|d
operator|->
name|hook
argument_list|,
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
operator|++
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_ipackets
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
operator|&
name|d
operator|->
name|pp
operator|.
name|pp_if
expr_stmt|;
comment|/* Check if there's a BPF listener on this interface. 	 * If so, hand off the raw packet to bpf. */
if|if
condition|(
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_bpf
condition|)
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|BPF_TAP
argument_list|(
operator|&
name|d
operator|->
name|pp
operator|.
name|pp_if
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|#
directive|else
name|bpf_tap
argument_list|(
operator|&
name|d
operator|->
name|pp
operator|.
name|pp_if
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sppp_input
argument_list|(
operator|&
name|d
operator|->
name|pp
operator|.
name|pp_if
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|502113
end_if

begin_define
define|#
directive|define
name|CONDITION
parameter_list|(
name|t
parameter_list|,
name|tp
parameter_list|)
value|(!(t->c_iflag& (ICRNL | IGNCR | IMAXBEL | INLCR | ISTRIP | IXON))\&& (!(tp->t_iflag& BRKINT) || (tp->t_iflag& IGNBRK))\&& (!(tp->t_iflag& PARMRK)\ 		|| (tp->t_iflag& (IGNPAR | IGNBRK)) == (IGNPAR | IGNBRK))\&& !(t->c_lflag& (ECHO | ICANON | IEXTEN | ISIG | PENDIN))\&& linesw[tp->t_line].l_rint == ttyinput)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CONDITION
parameter_list|(
name|t
parameter_list|,
name|tp
parameter_list|)
value|(!(t->c_iflag& (ICRNL | IGNCR | IMAXBEL | INLCR | ISTRIP | IXON))\&& (!(tp->t_iflag& BRKINT) || (tp->t_iflag& IGNBRK))\&& (!(tp->t_iflag& PARMRK)\ 		|| (tp->t_iflag& (IGNPAR | IGNBRK)) == (IGNPAR | IGNBRK))\&& !(t->c_lflag& (ECHO | ICANON | IEXTEN | ISIG | PENDIN))\&& linesw[tp->t_line]->l_rint == ttyinput)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Error callback function.  */
end_comment

begin_function
specifier|static
name|void
name|cx_error
parameter_list|(
name|cx_chan_t
modifier|*
name|c
parameter_list|,
name|int
name|data
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|c
operator|->
name|sys
decl_stmt|;
name|async_q
modifier|*
name|q
decl_stmt|;
if|if
condition|(
operator|!
name|d
condition|)
return|return;
name|q
operator|=
operator|&
operator|(
name|d
operator|->
name|aqueue
operator|)
expr_stmt|;
switch|switch
condition|(
name|data
condition|)
block|{
case|case
name|CX_FRAME
case|:
name|CX_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"frame error\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|mode
operator|==
name|M_ASYNC
operator|&&
name|d
operator|->
name|tty
operator|&&
operator|(
name|d
operator|->
name|tty
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|&&
operator|(
name|AQ_GSZ
argument_list|(
name|q
argument_list|)
operator|<
name|BF_SZ
operator|-
literal|1
operator|)
operator|&&
operator|(
operator|!
name|CONDITION
argument_list|(
operator|(
operator|&
name|d
operator|->
name|tty
operator|->
name|t_termios
operator|)
argument_list|,
operator|(
name|d
operator|->
name|tty
operator|)
argument_list|)
operator|||
operator|!
operator|(
name|d
operator|->
name|tty
operator|->
name|t_iflag
operator|&
operator|(
name|IGNPAR
operator||
name|PARMRK
operator|)
operator|)
operator|)
condition|)
block|{
name|AQ_PUSH
argument_list|(
name|q
argument_list|,
name|TTY_FE
argument_list|)
expr_stmt|;
name|d
operator|->
name|intr_action
operator||=
name|CX_READ
expr_stmt|;
name|MY_SOFT_INTR
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|swi_sched
argument_list|(
name|cx_fast_ih
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|setsofttty
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
ifndef|#
directive|ifndef
name|NETGRAPH
else|else
operator|++
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_ierrors
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|CX_CRC
case|:
name|CX_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"crc error\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|mode
operator|==
name|M_ASYNC
operator|&&
name|d
operator|->
name|tty
operator|&&
operator|(
name|d
operator|->
name|tty
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|&&
operator|(
name|AQ_GSZ
argument_list|(
name|q
argument_list|)
operator|<
name|BF_SZ
operator|-
literal|1
operator|)
operator|&&
operator|(
operator|!
name|CONDITION
argument_list|(
operator|(
operator|&
name|d
operator|->
name|tty
operator|->
name|t_termios
operator|)
argument_list|,
operator|(
name|d
operator|->
name|tty
operator|)
argument_list|)
operator|||
operator|!
operator|(
name|d
operator|->
name|tty
operator|->
name|t_iflag
operator|&
name|INPCK
operator|)
operator|||
operator|!
operator|(
name|d
operator|->
name|tty
operator|->
name|t_iflag
operator|&
operator|(
name|IGNPAR
operator||
name|PARMRK
operator|)
operator|)
operator|)
condition|)
block|{
name|AQ_PUSH
argument_list|(
name|q
argument_list|,
name|TTY_PE
argument_list|)
expr_stmt|;
name|d
operator|->
name|intr_action
operator||=
name|CX_READ
expr_stmt|;
name|MY_SOFT_INTR
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|swi_sched
argument_list|(
name|cx_fast_ih
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|setsofttty
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
ifndef|#
directive|ifndef
name|NETGRAPH
else|else
operator|++
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_ierrors
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|CX_OVERRUN
case|:
name|CX_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"overrun error\n"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TTY_OE
if|if
condition|(
name|c
operator|->
name|mode
operator|==
name|M_ASYNC
operator|&&
name|d
operator|->
name|tty
operator|&&
operator|(
name|d
operator|->
name|tty
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|&&
operator|(
name|AQ_GSZ
argument_list|(
name|q
argument_list|)
operator|<
name|BF_SZ
operator|-
literal|1
operator|)
operator|&&
operator|(
operator|!
name|CONDITION
argument_list|(
operator|(
operator|&
name|d
operator|->
name|tty
operator|->
name|t_termios
operator|)
argument_list|,
operator|(
name|d
operator|->
name|tty
operator|)
argument_list|)
operator|)
condition|)
block|{
name|AQ_PUSH
argument_list|(
name|q
argument_list|,
name|TTY_OE
argument_list|)
expr_stmt|;
name|d
operator|->
name|intr_action
operator||=
name|CX_READ
expr_stmt|;
name|MY_SOFT_INTR
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|swi_sched
argument_list|(
name|cx_fast_ih
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|setsofttty
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NETGRAPH
else|else
block|{
operator|++
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_collisions
expr_stmt|;
operator|++
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_ierrors
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
name|CX_OVERFLOW
case|:
name|CX_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"overflow error\n"
operator|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NETGRAPH
if|if
condition|(
name|c
operator|->
name|mode
operator|!=
name|M_ASYNC
condition|)
operator|++
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_ierrors
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|CX_UNDERRUN
case|:
name|CX_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"underrun error\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|mode
operator|!=
name|M_ASYNC
condition|)
block|{
ifdef|#
directive|ifdef
name|NETGRAPH
name|d
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
else|#
directive|else
operator|++
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_oerrors
expr_stmt|;
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_timer
operator|=
literal|0
expr_stmt|;
name|cx_start
argument_list|(
name|d
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
break|break;
case|case
name|CX_BREAK
case|:
name|CX_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"break error\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|mode
operator|==
name|M_ASYNC
operator|&&
name|d
operator|->
name|tty
operator|&&
operator|(
name|d
operator|->
name|tty
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|&&
operator|(
name|AQ_GSZ
argument_list|(
name|q
argument_list|)
operator|<
name|BF_SZ
operator|-
literal|1
operator|)
operator|&&
operator|(
operator|!
name|CONDITION
argument_list|(
operator|(
operator|&
name|d
operator|->
name|tty
operator|->
name|t_termios
operator|)
argument_list|,
operator|(
name|d
operator|->
name|tty
operator|)
argument_list|)
operator|||
operator|!
operator|(
name|d
operator|->
name|tty
operator|->
name|t_iflag
operator|&
operator|(
name|IGNBRK
operator||
name|BRKINT
operator||
name|PARMRK
operator|)
operator|)
operator|)
condition|)
block|{
name|AQ_PUSH
argument_list|(
name|q
argument_list|,
name|TTY_BI
argument_list|)
expr_stmt|;
name|d
operator|->
name|intr_action
operator||=
name|CX_READ
expr_stmt|;
name|MY_SOFT_INTR
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|swi_sched
argument_list|(
name|cx_fast_ih
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|setsofttty
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
ifndef|#
directive|ifndef
name|NETGRAPH
else|else
operator|++
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_ierrors
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
name|CX_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"error #%d\n"
operator|,
name|data
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
end_if

begin_decl_stmt
specifier|static
name|int
name|cx_open
argument_list|(
name|dev_t
name|dev
argument_list|,
name|int
name|flag
argument_list|,
name|int
name|mode
argument_list|,
expr|struct
name|proc
operator|*
name|p
argument_list|)
else|#
directive|else
decl|static
name|int
name|cx_open
argument_list|(
expr|struct
name|cdev
operator|*
name|dev
argument_list|,
name|int
name|flag
argument_list|,
name|int
name|mode
argument_list|,
expr|struct
name|thread
operator|*
name|td
argument_list|)
endif|#
directive|endif
block|{
name|int
name|unit
init|=
name|UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|drv_t
modifier|*
name|d
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NCX
operator|*
name|NCHAN
operator|||
operator|!
operator|(
name|d
operator|=
name|channel
index|[
name|unit
index|]
operator|)
condition|)
return|return
name|ENXIO
return|;
name|CX_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"cx_open unit=%d, flag=0x%x, mode=0x%x\n"
operator|,
name|unit
operator|,
name|flag
operator|,
name|mode
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|chan
operator|->
name|mode
operator|!=
name|M_ASYNC
operator|||
name|IF_CUNIT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|d
operator|->
name|open_dev
operator||=
literal|0x1
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|d
operator|->
name|tty
condition|)
block|{
name|d
operator|->
name|tty
operator|=
name|ttymalloc
argument_list|(
name|d
operator|->
name|tty
argument_list|)
expr_stmt|;
name|d
operator|->
name|tty
operator|->
name|t_oproc
operator|=
name|cx_oproc
expr_stmt|;
name|d
operator|->
name|tty
operator|->
name|t_param
operator|=
name|cx_param
expr_stmt|;
name|d
operator|->
name|tty
operator|->
name|t_stop
operator|=
name|cx_stop
expr_stmt|;
block|}
name|dev
operator|->
name|si_tty
operator|=
name|d
operator|->
name|tty
expr_stmt|;
name|d
operator|->
name|tty
operator|->
name|t_dev
operator|=
name|dev
expr_stmt|;
name|again
label|:
name|error
operator|=
name|ttydtrwaitsleep
argument_list|(
name|d
operator|->
name|tty
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|(
name|d
operator|->
name|tty
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|&&
operator|(
name|d
operator|->
name|tty
operator|->
name|t_state
operator|&
name|TS_XCLUDE
operator|)
operator|&&
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|suser
argument_list|(
name|td
argument_list|)
condition|)
else|#
directive|else
name|p
operator|->
name|p_ucred
operator|->
name|cr_uid
operator|!=
literal|0
block|)
endif|#
directive|endif
decl|return
name|EBUSY
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|d
operator|->
name|tty
operator|->
name|t_state
operator|&
name|TS_ISOPEN
condition|)
block|{
comment|/* 		 * Cannot open /dev/cua if /dev/tty already opened. 		 */
if|if
condition|(
name|CALLOUT
argument_list|(
name|dev
argument_list|)
operator|&&
operator|!
name|d
operator|->
name|callout
condition|)
return|return
name|EBUSY
return|;
comment|/* 		 * Opening /dev/tty when /dev/cua is already opened. 		 * Wait for close, then try again. 		 */
if|if
condition|(
operator|!
name|CALLOUT
argument_list|(
name|dev
argument_list|)
operator|&&
name|d
operator|->
name|callout
condition|)
block|{
if|if
condition|(
name|flag
operator|&
name|O_NONBLOCK
condition|)
return|return
name|EBUSY
return|;
name|error
operator|=
name|tsleep
argument_list|(
name|d
argument_list|,
name|TTIPRI
operator||
name|PCATCH
argument_list|,
literal|"cxbi"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
goto|goto
name|again
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|lock
operator|&&
operator|!
name|CALLOUT
argument_list|(
name|dev
argument_list|)
operator|&&
operator|(
name|flag
operator|&
name|O_NONBLOCK
operator|)
condition|)
comment|/* 		 * We try to open /dev/tty in non-blocking mode 		 * while somebody is already waiting for carrier on it. 		 */
return|return
name|EBUSY
return|;
else|else
block|{
name|ttychars
argument_list|(
name|d
operator|->
name|tty
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|tty
operator|->
name|t_ispeed
operator|==
literal|0
condition|)
block|{
name|d
operator|->
name|tty
operator|->
name|t_iflag
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|tty
operator|->
name|t_oflag
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|tty
operator|->
name|t_lflag
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|tty
operator|->
name|t_cflag
operator|=
name|CREAD
operator||
name|CS8
operator||
name|HUPCL
expr_stmt|;
name|d
operator|->
name|tty
operator|->
name|t_ispeed
operator|=
name|d
operator|->
name|chan
operator|->
name|rxbaud
expr_stmt|;
name|d
operator|->
name|tty
operator|->
name|t_ospeed
operator|=
name|d
operator|->
name|chan
operator|->
name|txbaud
expr_stmt|;
block|}
if|if
condition|(
name|CALLOUT
argument_list|(
name|dev
argument_list|)
condition|)
name|d
operator|->
name|tty
operator|->
name|t_cflag
operator||=
name|CLOCAL
expr_stmt|;
else|else
name|d
operator|->
name|tty
operator|->
name|t_cflag
operator|&=
operator|~
name|CLOCAL
expr_stmt|;
name|cx_param
argument_list|(
name|d
operator|->
name|tty
argument_list|,
operator|&
name|d
operator|->
name|tty
operator|->
name|t_termios
argument_list|)
expr_stmt|;
name|ttsetwater
argument_list|(
name|d
operator|->
name|tty
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|splhigh
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
operator|(
name|d
operator|->
name|tty
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
condition|)
block|{
name|cx_start_chan
argument_list|(
name|d
operator|->
name|chan
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cx_set_dtr
argument_list|(
name|d
operator|->
name|chan
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cx_set_rts
argument_list|(
name|d
operator|->
name|chan
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|d
operator|->
name|cd
operator|=
name|cx_get_cd
argument_list|(
name|d
operator|->
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|CALLOUT
argument_list|(
name|dev
argument_list|)
operator|||
name|cx_get_cd
argument_list|(
name|d
operator|->
name|chan
argument_list|)
condition|)
name|ttyld_modem
argument_list|(
name|d
operator|->
name|tty
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
operator|!
operator|(
name|flag
operator|&
name|O_NONBLOCK
operator|)
operator|&&
operator|!
operator|(
name|d
operator|->
name|tty
operator|->
name|t_cflag
operator|&
name|CLOCAL
operator|)
operator|&&
operator|!
operator|(
name|d
operator|->
name|tty
operator|->
name|t_state
operator|&
name|TS_CARR_ON
operator|)
condition|)
block|{
comment|/* Lock the channel against cxconfig while we are 		 * waiting for carrier. */
name|d
operator|->
name|lock
operator|++
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
operator|&
name|d
operator|->
name|tty
operator|->
name|t_rawq
argument_list|,
name|TTIPRI
operator||
name|PCATCH
argument_list|,
literal|"cxdcd"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Unlock the channel. */
name|d
operator|->
name|lock
operator|--
expr_stmt|;
name|spl0
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|failed
goto|;
goto|goto
name|again
goto|;
block|}
end_if

begin_expr_stmt
name|error
operator|=
name|ttyld_open
argument_list|(
name|d
operator|->
name|tty
argument_list|,
name|dev
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ttyldoptim
argument_list|(
name|d
operator|->
name|tty
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|spl0
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|error
condition|)
block|{
name|failed
label|:
if|if
condition|(
operator|!
operator|(
name|d
operator|->
name|tty
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
condition|)
block|{
name|splhigh
argument_list|()
expr_stmt|;
name|cx_set_dtr
argument_list|(
name|d
operator|->
name|chan
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cx_set_rts
argument_list|(
name|d
operator|->
name|chan
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ttydtrwaitstart
argument_list|(
name|d
operator|->
name|tty
argument_list|)
expr_stmt|;
name|spl0
argument_list|()
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_if

begin_if
if|if
condition|(
name|d
operator|->
name|tty
operator|->
name|t_state
operator|&
name|TS_ISOPEN
condition|)
name|d
operator|->
name|callout
operator|=
name|CALLOUT
argument_list|(
name|dev
argument_list|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
end_if

begin_expr_stmt
name|d
operator|->
name|open_dev
operator||=
literal|0x2
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CX_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"cx_open done\n"
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
literal|0
return|;
end_return

begin_if
unit|}
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
end_if

begin_decl_stmt
unit|static
name|int
name|cx_close
argument_list|(
name|dev_t
name|dev
argument_list|,
name|int
name|flag
argument_list|,
name|int
name|mode
argument_list|,
expr|struct
name|proc
operator|*
name|p
argument_list|)
else|#
directive|else
decl|static
name|int
name|cx_close
argument_list|(
expr|struct
name|cdev
operator|*
name|dev
argument_list|,
name|int
name|flag
argument_list|,
name|int
name|mode
argument_list|,
expr|struct
name|thread
operator|*
name|td
argument_list|)
endif|#
directive|endif
block|{
name|drv_t
modifier|*
name|d
init|=
name|channel
index|[
name|UNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
name|int
name|s
decl_stmt|;
name|CX_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"cx_close\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
operator|(
name|d
operator|->
name|open_dev
operator|&
literal|0x2
operator|)
operator|)
operator|||
name|IF_CUNIT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|d
operator|->
name|open_dev
operator|&=
operator|~
literal|0x1
expr_stmt|;
return|return
literal|0
return|;
block|}
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|ttyld_close
argument_list|(
name|d
operator|->
name|tty
argument_list|,
name|flag
argument_list|)
expr_stmt|;
name|ttyldoptim
argument_list|(
name|d
operator|->
name|tty
argument_list|)
expr_stmt|;
comment|/* Disable receiver. 	 * Transmitter continues sending the queued data. */
name|cx_enable_receive
argument_list|(
name|d
operator|->
name|chan
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Clear DTR and RTS. */
if|if
condition|(
operator|(
name|d
operator|->
name|tty
operator|->
name|t_cflag
operator|&
name|HUPCL
operator|)
operator|||
operator|!
operator|(
name|d
operator|->
name|tty
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
condition|)
block|{
name|cx_set_dtr
argument_list|(
name|d
operator|->
name|chan
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cx_set_rts
argument_list|(
name|d
operator|->
name|chan
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ttydtrwaitstart
argument_list|(
name|d
operator|->
name|tty
argument_list|)
expr_stmt|;
block|}
name|tty_close
argument_list|(
name|d
operator|->
name|tty
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|d
operator|->
name|callout
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Wake up bidirectional opens. 	 * Since we may be opened twice we couldn't call ttyrel() here. 	 * So just keep d->tty for future use. It would be freed by 	 * ttyrel() at cx_detach(). 	 */
name|wakeup
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|open_dev
operator|&=
operator|~
literal|0x2
expr_stmt|;
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_function
specifier|static
name|int
name|cx_read
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|channel
index|[
name|UNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|d
condition|)
name|CX_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"cx_read\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|||
name|d
operator|->
name|chan
operator|->
name|mode
operator|!=
name|M_ASYNC
operator|||
name|IF_CUNIT
argument_list|(
name|dev
argument_list|)
operator|||
operator|!
name|d
operator|->
name|tty
condition|)
return|return
name|EBADF
return|;
return|return
name|ttyld_read
argument_list|(
name|d
operator|->
name|tty
argument_list|,
name|uio
argument_list|,
name|flag
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cx_write
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|channel
index|[
name|UNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|d
condition|)
name|CX_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"cx_write\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|||
name|d
operator|->
name|chan
operator|->
name|mode
operator|!=
name|M_ASYNC
operator|||
name|IF_CUNIT
argument_list|(
name|dev
argument_list|)
operator|||
operator|!
name|d
operator|->
name|tty
condition|)
return|return
name|EBADF
return|;
return|return
name|ttyld_write
argument_list|(
name|d
operator|->
name|tty
argument_list|,
name|uio
argument_list|,
name|flag
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cx_modem_status
parameter_list|(
name|drv_t
modifier|*
name|d
parameter_list|)
block|{
name|int
name|status
init|=
literal|0
decl_stmt|,
name|s
init|=
name|splhigh
argument_list|()
decl_stmt|;
comment|/* Already opened by someone or network interface is up? */
if|if
condition|(
operator|(
name|d
operator|->
name|chan
operator|->
name|mode
operator|==
name|M_ASYNC
operator|&&
name|d
operator|->
name|tty
operator|&&
operator|(
name|d
operator|->
name|tty
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|&&
operator|(
name|d
operator|->
name|open_dev
operator||
literal|0x2
operator|)
operator|)
operator|||
operator|(
name|d
operator|->
name|chan
operator|->
name|mode
operator|!=
name|M_ASYNC
operator|&&
name|d
operator|->
name|running
operator|)
condition|)
name|status
operator|=
name|TIOCM_LE
expr_stmt|;
comment|/* always enabled while open */
if|if
condition|(
name|cx_get_dsr
argument_list|(
name|d
operator|->
name|chan
argument_list|)
condition|)
name|status
operator||=
name|TIOCM_DSR
expr_stmt|;
if|if
condition|(
name|cx_get_cd
argument_list|(
name|d
operator|->
name|chan
argument_list|)
condition|)
name|status
operator||=
name|TIOCM_CD
expr_stmt|;
if|if
condition|(
name|cx_get_cts
argument_list|(
name|d
operator|->
name|chan
argument_list|)
condition|)
name|status
operator||=
name|TIOCM_CTS
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|chan
operator|->
name|dtr
condition|)
name|status
operator||=
name|TIOCM_DTR
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|chan
operator|->
name|rts
condition|)
name|status
operator||=
name|TIOCM_RTS
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
end_if

begin_decl_stmt
specifier|static
name|int
name|cx_ioctl
argument_list|(
name|dev_t
name|dev
argument_list|,
name|u_long
name|cmd
argument_list|,
name|caddr_t
name|data
argument_list|,
name|int
name|flag
argument_list|,
expr|struct
name|proc
operator|*
name|p
argument_list|)
else|#
directive|else
decl|static
name|int
name|cx_ioctl
argument_list|(
expr|struct
name|cdev
operator|*
name|dev
argument_list|,
name|u_long
name|cmd
argument_list|,
name|caddr_t
name|data
argument_list|,
name|int
name|flag
argument_list|,
expr|struct
name|thread
operator|*
name|td
argument_list|)
endif|#
directive|endif
block|{
name|drv_t
modifier|*
name|d
init|=
name|channel
index|[
name|UNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
name|cx_chan_t
modifier|*
name|c
decl_stmt|;
name|struct
name|serial_statistics
modifier|*
name|st
decl_stmt|;
name|int
name|error
decl_stmt|,
name|s
decl_stmt|;
name|char
name|mask
index|[
literal|16
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|||
operator|!
operator|(
name|c
operator|=
name|d
operator|->
name|chan
operator|)
condition|)
return|return
name|EINVAL
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SERIAL_GETREGISTERED
case|:
name|CX_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getregistered\n"
operator|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|mask
argument_list|,
sizeof|sizeof
argument_list|(
name|mask
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|NCX
operator|*
name|NCHAN
condition|;
operator|++
name|s
control|)
if|if
condition|(
name|channel
index|[
name|s
index|]
condition|)
name|mask
index|[
name|s
operator|/
literal|8
index|]
operator||=
literal|1
operator|<<
operator|(
name|s
operator|&
literal|7
operator|)
expr_stmt|;
name|bcopy
argument_list|(
name|mask
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|mask
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETPORT
case|:
name|CX_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getport\n"
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|cx_get_port
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
else|else
return|return
literal|0
return|;
case|case
name|SERIAL_SETPORT
case|:
name|CX_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: setproto\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* __FreeBSD_version>= 500000 */
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* __FreeBSD_version>= 500000 */
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|cx_set_port
argument_list|(
name|c
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
ifndef|#
directive|ifndef
name|NETGRAPH
case|case
name|SERIAL_GETPROTO
case|:
name|CX_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getproto\n"
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
operator|(
name|c
operator|->
name|mode
operator|==
name|M_ASYNC
operator|)
condition|?
literal|"async"
else|:
operator|(
name|d
operator|->
name|pp
operator|.
name|pp_flags
operator|&
name|PP_FR
operator|)
condition|?
literal|"fr"
else|:
operator|(
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_flags
operator|&
name|PP_CISCO
operator|)
condition|?
literal|"cisco"
else|:
literal|"ppp"
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETPROTO
case|:
name|CX_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: setproto\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* __FreeBSD_version>= 500000 */
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* __FreeBSD_version>= 500000 */
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|c
operator|->
name|mode
operator|==
name|M_ASYNC
condition|)
return|return
name|EBUSY
return|;
if|if
condition|(
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
return|return
name|EBUSY
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"cisco"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
condition|)
block|{
name|d
operator|->
name|pp
operator|.
name|pp_flags
operator|&=
operator|~
operator|(
name|PP_FR
operator|)
expr_stmt|;
name|d
operator|->
name|pp
operator|.
name|pp_flags
operator||=
name|PP_KEEPALIVE
expr_stmt|;
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_flags
operator||=
name|PP_CISCO
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"fr"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
condition|)
block|{
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_flags
operator|&=
operator|~
operator|(
name|PP_CISCO
operator|)
expr_stmt|;
name|d
operator|->
name|pp
operator|.
name|pp_flags
operator||=
name|PP_FR
operator||
name|PP_KEEPALIVE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"ppp"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
condition|)
block|{
name|d
operator|->
name|pp
operator|.
name|pp_flags
operator|&=
operator|~
operator|(
name|PP_FR
operator||
name|PP_KEEPALIVE
operator|)
expr_stmt|;
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_flags
operator|&=
operator|~
operator|(
name|PP_CISCO
operator|)
expr_stmt|;
block|}
else|else
return|return
name|EINVAL
return|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETKEEPALIVE
case|:
name|CX_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getkeepalive\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|->
name|pp
operator|.
name|pp_flags
operator|&
name|PP_FR
operator|)
operator|||
operator|(
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_flags
operator|&
name|PP_CISCO
operator|)
operator|||
operator|(
name|c
operator|->
name|mode
operator|==
name|M_ASYNC
operator|)
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
operator|(
name|d
operator|->
name|pp
operator|.
name|pp_flags
operator|&
name|PP_KEEPALIVE
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETKEEPALIVE
case|:
name|CX_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: setkeepalive\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* __FreeBSD_version>= 500000 */
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* __FreeBSD_version>= 500000 */
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|(
name|d
operator|->
name|pp
operator|.
name|pp_flags
operator|&
name|PP_FR
operator|)
operator|||
operator|(
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_flags
operator|&
name|PP_CISCO
operator|)
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
name|d
operator|->
name|pp
operator|.
name|pp_flags
operator||=
name|PP_KEEPALIVE
expr_stmt|;
else|else
name|d
operator|->
name|pp
operator|.
name|pp_flags
operator|&=
operator|~
name|PP_KEEPALIVE
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
comment|/*NETGRAPH*/
case|case
name|SERIAL_GETMODE
case|:
name|CX_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getmode\n"
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
operator|(
name|c
operator|->
name|mode
operator|==
name|M_ASYNC
operator|)
condition|?
name|SERIAL_ASYNC
else|:
name|SERIAL_HDLC
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETMODE
case|:
name|CX_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: setmode\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* __FreeBSD_version>= 500000 */
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* __FreeBSD_version>= 500000 */
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
comment|/* Somebody is waiting for carrier? */
if|if
condition|(
name|d
operator|->
name|lock
condition|)
return|return
name|EBUSY
return|;
comment|/* /dev/ttyXX is already opened by someone? */
if|if
condition|(
name|c
operator|->
name|mode
operator|==
name|M_ASYNC
operator|&&
name|d
operator|->
name|tty
operator|&&
operator|(
name|d
operator|->
name|tty
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|&&
operator|(
name|d
operator|->
name|open_dev
operator||
literal|0x2
operator|)
condition|)
return|return
name|EBUSY
return|;
comment|/* Network interface is up? 		 * Cannot change to async mode. */
if|if
condition|(
name|c
operator|->
name|mode
operator|!=
name|M_ASYNC
operator|&&
name|d
operator|->
name|running
operator|&&
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|==
name|SERIAL_ASYNC
operator|)
condition|)
return|return
name|EBUSY
return|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|mode
operator|==
name|M_HDLC
operator|&&
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|==
name|SERIAL_ASYNC
condition|)
block|{
name|cx_set_mode
argument_list|(
name|c
argument_list|,
name|M_ASYNC
argument_list|)
expr_stmt|;
name|cx_enable_receive
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cx_enable_transmit
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|->
name|mode
operator|==
name|M_ASYNC
operator|&&
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|==
name|SERIAL_HDLC
condition|)
block|{
name|cx_set_mode
argument_list|(
name|c
argument_list|,
name|M_HDLC
argument_list|)
expr_stmt|;
name|cx_enable_receive
argument_list|(
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cx_enable_transmit
argument_list|(
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETSTAT
case|:
name|CX_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getestat\n"
operator|)
argument_list|)
expr_stmt|;
name|st
operator|=
operator|(
expr|struct
name|serial_statistics
operator|*
operator|)
name|data
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|st
operator|->
name|rintr
operator|=
name|c
operator|->
name|rintr
expr_stmt|;
name|st
operator|->
name|tintr
operator|=
name|c
operator|->
name|tintr
expr_stmt|;
name|st
operator|->
name|mintr
operator|=
name|c
operator|->
name|mintr
expr_stmt|;
name|st
operator|->
name|ibytes
operator|=
name|c
operator|->
name|ibytes
expr_stmt|;
name|st
operator|->
name|ipkts
operator|=
name|c
operator|->
name|ipkts
expr_stmt|;
name|st
operator|->
name|ierrs
operator|=
name|c
operator|->
name|ierrs
expr_stmt|;
name|st
operator|->
name|obytes
operator|=
name|c
operator|->
name|obytes
expr_stmt|;
name|st
operator|->
name|opkts
operator|=
name|c
operator|->
name|opkts
expr_stmt|;
name|st
operator|->
name|oerrs
operator|=
name|c
operator|->
name|oerrs
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_CLRSTAT
case|:
name|CX_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: clrstat\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* __FreeBSD_version>= 500000 */
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* __FreeBSD_version>= 500000 */
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|c
operator|->
name|rintr
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|tintr
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|mintr
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|ibytes
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|ipkts
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|ierrs
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|obytes
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|opkts
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|oerrs
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETBAUD
case|:
name|CX_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getbaud\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|mode
operator|==
name|M_ASYNC
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
operator|*
operator|(
name|long
operator|*
operator|)
name|data
operator|=
name|cx_get_baud
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETBAUD
case|:
name|CX_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: setbaud\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* __FreeBSD_version>= 500000 */
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* __FreeBSD_version>= 500000 */
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|c
operator|->
name|mode
operator|==
name|M_ASYNC
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|cx_set_baud
argument_list|(
name|c
argument_list|,
operator|*
operator|(
name|long
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETLOOP
case|:
name|CX_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getloop\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|mode
operator|==
name|M_ASYNC
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|cx_get_loop
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETLOOP
case|:
name|CX_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: setloop\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* __FreeBSD_version>= 500000 */
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* __FreeBSD_version>= 500000 */
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|c
operator|->
name|mode
operator|==
name|M_ASYNC
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|cx_set_loop
argument_list|(
name|c
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETDPLL
case|:
name|CX_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getdpll\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|mode
operator|==
name|M_ASYNC
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|cx_get_dpll
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETDPLL
case|:
name|CX_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: setdpll\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* __FreeBSD_version>= 500000 */
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* __FreeBSD_version>= 500000 */
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|c
operator|->
name|mode
operator|==
name|M_ASYNC
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|cx_set_dpll
argument_list|(
name|c
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETNRZI
case|:
name|CX_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getnrzi\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|mode
operator|==
name|M_ASYNC
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|cx_get_nrzi
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETNRZI
case|:
name|CX_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: setnrzi\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* __FreeBSD_version>= 500000 */
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* __FreeBSD_version>= 500000 */
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|c
operator|->
name|mode
operator|==
name|M_ASYNC
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|cx_set_nrzi
argument_list|(
name|c
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETDEBUG
case|:
name|CX_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getdebug\n"
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|c
operator|->
name|debug
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETDEBUG
case|:
name|CX_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: setdebug\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* __FreeBSD_version>= 500000 */
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* __FreeBSD_version>= 500000 */
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|c
operator|->
name|debug
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NETGRAPH
if|if
condition|(
name|d
operator|->
name|chan
operator|->
name|debug
condition|)
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_flags
operator||=
name|IFF_DEBUG
expr_stmt|;
else|else
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_flags
operator|&=
operator|(
operator|~
name|IFF_DEBUG
operator|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
if|if
condition|(
name|c
operator|->
name|mode
operator|==
name|M_ASYNC
operator|&&
operator|!
name|IF_CUNIT
argument_list|(
name|dev
argument_list|)
operator|&&
name|d
operator|->
name|tty
condition|)
block|{
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|502113
name|error
operator|=
name|ttyioctl
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|ttyldoptim
argument_list|(
name|d
operator|->
name|tty
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOTTY
condition|)
block|{
if|if
condition|(
name|error
condition|)
name|CX_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ttioctl: 0x%lx, error %d\n"
operator|,
name|cmd
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
else|#
directive|else
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|d
operator|->
name|tty
operator|->
name|t_line
index|]
operator|.
name|l_ioctl
operator|)
operator|(
name|d
operator|->
name|tty
operator|,
name|cmd
operator|,
name|data
operator|,
name|flag
operator|,
name|td
operator|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|d
operator|->
name|tty
operator|->
name|t_line
index|]
operator|.
name|l_ioctl
operator|)
operator|(
name|d
operator|->
name|tty
operator|,
name|cmd
operator|,
name|data
operator|,
name|flag
operator|,
name|p
operator|)
expr_stmt|;
endif|#
directive|endif
name|ttyldoptim
argument_list|(
name|d
operator|->
name|tty
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOIOCTL
condition|)
block|{
if|if
condition|(
name|error
condition|)
name|CX_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"l_ioctl: 0x%lx, error %d\n"
operator|,
name|cmd
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|error
operator|=
name|ttioctl
argument_list|(
name|d
operator|->
name|tty
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|)
expr_stmt|;
name|ttyldoptim
argument_list|(
name|d
operator|->
name|tty
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOIOCTL
condition|)
block|{
if|if
condition|(
name|error
condition|)
name|CX_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ttioctl: 0x%lx, error %d\n"
operator|,
name|cmd
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
endif|#
directive|endif
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|TIOCSBRK
case|:
comment|/* Start sending line break */
name|CX_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: tiocsbrk\n"
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|cx_send_break
argument_list|(
name|c
argument_list|,
literal|500
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|TIOCCBRK
case|:
comment|/* Stop sending line break */
name|CX_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: tioccbrk\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|TIOCSDTR
case|:
comment|/* Set DTR */
name|CX_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: tiocsdtr\n"
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|cx_set_dtr
argument_list|(
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|TIOCCDTR
case|:
comment|/* Clear DTR */
name|CX_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: tioccdtr\n"
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|cx_set_dtr
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|TIOCMSET
case|:
comment|/* Set DTR/RTS */
name|CX_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: tiocmset\n"
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|cx_set_dtr
argument_list|(
name|c
argument_list|,
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|TIOCM_DTR
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|cx_set_rts
argument_list|(
name|c
argument_list|,
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|TIOCM_RTS
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|TIOCMBIS
case|:
comment|/* Add DTR/RTS */
name|CX_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: tiocmbis\n"
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|TIOCM_DTR
condition|)
name|cx_set_dtr
argument_list|(
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|TIOCM_RTS
condition|)
name|cx_set_rts
argument_list|(
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|TIOCMBIC
case|:
comment|/* Clear DTR/RTS */
name|CX_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: tiocmbic\n"
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|TIOCM_DTR
condition|)
name|cx_set_dtr
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|TIOCM_RTS
condition|)
name|cx_set_rts
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|TIOCMGET
case|:
comment|/* Get modem status */
name|CX_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: tiocmget\n"
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|cx_modem_status
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|CX_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: 0x%lx\n"
operator|,
name|cmd
operator|)
argument_list|)
expr_stmt|;
return|return
name|ENOTTY
return|;
block|}
end_decl_stmt

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|502113
end_if

begin_function
specifier|static
name|void
name|ttyldoptim
parameter_list|(
name|tp
parameter_list|)
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
block|{
name|struct
name|termios
modifier|*
name|t
decl_stmt|;
name|t
operator|=
operator|&
name|tp
operator|->
name|t_termios
expr_stmt|;
if|if
condition|(
name|CONDITION
argument_list|(
name|t
argument_list|,
name|tp
argument_list|)
condition|)
name|tp
operator|->
name|t_state
operator||=
name|TS_CAN_BYPASS_L_RINT
expr_stmt|;
else|else
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_CAN_BYPASS_L_RINT
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
end_if

begin_decl_stmt
name|void
name|cx_softintr
argument_list|(
name|void
operator|*
name|unused
argument_list|)
else|#
directive|else
name|void
name|cx_softintr
argument_list|()
endif|#
directive|endif
block|{
name|drv_t
modifier|*
name|d
decl_stmt|;
name|async_q
modifier|*
name|q
decl_stmt|;
name|int
name|i
decl_stmt|,
name|s
decl_stmt|,
name|ic
decl_stmt|,
name|k
decl_stmt|;
while|while
condition|(
name|MY_SOFT_INTR
condition|)
block|{
name|MY_SOFT_INTR
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCX
operator|*
name|NCHAN
condition|;
operator|++
name|i
control|)
block|{
name|d
operator|=
name|channel
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|chan
operator|||
name|d
operator|->
name|chan
operator|->
name|type
operator|==
name|T_NONE
operator|||
name|d
operator|->
name|chan
operator|->
name|mode
operator|!=
name|M_ASYNC
operator|||
operator|!
name|d
operator|->
name|tty
operator|||
operator|!
name|d
operator|->
name|tty
operator|->
name|t_dev
condition|)
continue|continue;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|intr_action
operator|&
name|CX_READ
condition|)
block|{
name|q
operator|=
operator|&
operator|(
name|d
operator|->
name|aqueue
operator|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|tty
operator|->
name|t_state
operator|&
name|TS_CAN_BYPASS_L_RINT
condition|)
block|{
name|k
operator|=
name|AQ_GSZ
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|tty
operator|->
name|t_rawq
operator|.
name|c_cc
operator|+
name|k
operator|>
name|d
operator|->
name|tty
operator|->
name|t_ihiwat
operator|&&
operator|(
name|d
operator|->
name|tty
operator|->
name|t_cflag
operator|&
name|CRTS_IFLOW
operator|||
name|d
operator|->
name|tty
operator|->
name|t_iflag
operator|&
name|IXOFF
operator|)
operator|&&
operator|!
operator|(
name|d
operator|->
name|tty
operator|->
name|t_state
operator|&
name|TS_TBLOCK
operator|)
condition|)
name|ttyblock
argument_list|(
name|d
operator|->
name|tty
argument_list|)
expr_stmt|;
name|d
operator|->
name|tty
operator|->
name|t_rawcc
operator|+=
name|k
expr_stmt|;
while|while
condition|(
name|k
operator|>
literal|0
condition|)
block|{
name|k
operator|--
expr_stmt|;
name|AQ_POP
argument_list|(
name|q
argument_list|,
name|ic
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|ic
argument_list|,
operator|&
name|d
operator|->
name|tty
operator|->
name|t_rawq
argument_list|)
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
block|}
name|ttwakeup
argument_list|(
name|d
operator|->
name|tty
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|tty
operator|->
name|t_state
operator|&
name|TS_TTSTOP
operator|&&
operator|(
name|d
operator|->
name|tty
operator|->
name|t_iflag
operator|&
name|IXANY
operator|||
name|d
operator|->
name|tty
operator|->
name|t_cc
index|[
name|VSTART
index|]
operator|==
name|d
operator|->
name|tty
operator|->
name|t_cc
index|[
name|VSTOP
index|]
operator|)
condition|)
block|{
name|d
operator|->
name|tty
operator|->
name|t_state
operator|&=
operator|~
name|TS_TTSTOP
expr_stmt|;
name|d
operator|->
name|tty
operator|->
name|t_lflag
operator|&=
operator|~
name|FLUSHO
expr_stmt|;
name|d
operator|->
name|intr_action
operator||=
name|CX_WRITE
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|q
operator|->
name|end
operator|!=
name|q
operator|->
name|beg
condition|)
block|{
name|AQ_POP
argument_list|(
name|q
argument_list|,
name|ic
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ttyld_rint
argument_list|(
name|d
operator|->
name|tty
argument_list|,
name|ic
argument_list|)
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
block|}
block|}
name|d
operator|->
name|intr_action
operator|&=
operator|~
name|CX_READ
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|intr_action
operator|&
name|CX_WRITE
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|tty
operator|->
name|t_line
condition|)
name|ttyld_start
argument_list|(
name|d
operator|->
name|tty
argument_list|)
expr_stmt|;
else|else
name|cx_oproc
argument_list|(
name|d
operator|->
name|tty
argument_list|)
expr_stmt|;
name|d
operator|->
name|intr_action
operator|&=
operator|~
name|CX_WRITE
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_decl_stmt

begin_comment
comment|/*  * Fill transmitter buffer with data.  */
end_comment

begin_function
specifier|static
name|void
name|cx_oproc
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|int
name|s
init|=
name|splhigh
argument_list|()
decl_stmt|,
name|k
decl_stmt|;
name|drv_t
modifier|*
name|d
init|=
name|channel
index|[
name|UNIT
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
index|]
decl_stmt|;
specifier|static
name|u_char
name|buf
index|[
name|DMABUFSZ
index|]
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|;
name|u_short
name|len
init|=
literal|0
decl_stmt|,
name|sublen
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|d
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|CX_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"cx_oproc\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_cflag
operator|&
name|CRTSCTS
operator|&&
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TBLOCK
operator|)
operator|&&
name|d
operator|->
name|chan
operator|->
name|rts
condition|)
name|cx_set_rts
argument_list|(
name|d
operator|->
name|chan
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tp
operator|->
name|t_cflag
operator|&
name|CRTSCTS
operator|&&
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TBLOCK
operator|)
operator|&&
operator|!
name|d
operator|->
name|chan
operator|->
name|rts
condition|)
name|cx_set_rts
argument_list|(
name|d
operator|->
name|chan
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_TIMEOUT
operator||
name|TS_TTSTOP
operator|)
operator|)
condition|)
block|{
comment|/* Start transmitter. */
name|cx_enable_transmit
argument_list|(
name|d
operator|->
name|chan
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Is it busy? */
if|if
condition|(
operator|!
name|cx_buf_free
argument_list|(
name|d
operator|->
name|chan
argument_list|)
condition|)
block|{
name|tp
operator|->
name|t_state
operator||=
name|TS_BUSY
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|tp
operator|->
name|t_iflag
operator|&
name|IXOFF
condition|)
block|{
name|p
operator|=
operator|(
name|buf
operator|+
operator|(
name|DMABUFSZ
operator|/
literal|2
operator|)
operator|)
expr_stmt|;
name|sublen
operator|=
name|q_to_b
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
name|p
argument_list|,
operator|(
name|DMABUFSZ
operator|/
literal|2
operator|)
argument_list|)
expr_stmt|;
name|k
operator|=
name|sublen
expr_stmt|;
while|while
condition|(
name|k
operator|--
condition|)
block|{
comment|/* Send XON/XOFF out of band. */
if|if
condition|(
operator|*
name|p
operator|==
name|tp
operator|->
name|t_cc
index|[
name|VSTOP
index|]
condition|)
block|{
name|cx_xflow_ctl
argument_list|(
name|d
operator|->
name|chan
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|p
operator|==
name|tp
operator|->
name|t_cc
index|[
name|VSTART
index|]
condition|)
block|{
name|cx_xflow_ctl
argument_list|(
name|d
operator|->
name|chan
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
continue|continue;
block|}
name|buf
index|[
name|len
index|]
operator|=
operator|*
name|p
expr_stmt|;
name|len
operator|++
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|p
operator|=
name|buf
expr_stmt|;
name|len
operator|=
name|q_to_b
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
name|p
argument_list|,
operator|(
name|DMABUFSZ
operator|/
literal|2
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
condition|)
block|{
name|cx_send_packet
argument_list|(
name|d
operator|->
name|chan
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_state
operator||=
name|TS_BUSY
expr_stmt|;
name|d
operator|->
name|atimeout
operator|=
literal|10
expr_stmt|;
name|CX_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"out %d bytes\n"
operator|,
name|len
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|ttwwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cx_param
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|termios
modifier|*
name|t
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|channel
index|[
name|UNIT
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
index|]
decl_stmt|;
name|int
name|s
decl_stmt|,
name|bits
decl_stmt|,
name|parity
decl_stmt|;
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|c_ospeed
operator|==
literal|0
condition|)
block|{
comment|/* Clear DTR and RTS. */
name|cx_set_dtr
argument_list|(
name|d
operator|->
name|chan
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|CX_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"cx_param (hangup)\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|CX_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"cx_param\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Check requested parameters. */
if|if
condition|(
name|t
operator|->
name|c_ospeed
operator|<
literal|300
operator|||
name|t
operator|->
name|c_ospeed
operator|>
literal|256
operator|*
literal|1024
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|t
operator|->
name|c_ispeed
operator|&&
operator|(
name|t
operator|->
name|c_ispeed
operator|<
literal|300
operator|||
name|t
operator|->
name|c_ispeed
operator|>
literal|256
operator|*
literal|1024
operator|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/* And copy them to tty and channel structures. */
name|tp
operator|->
name|t_ispeed
operator|=
name|t
operator|->
name|c_ispeed
operator|=
name|tp
operator|->
name|t_ospeed
operator|=
name|t
operator|->
name|c_ospeed
expr_stmt|;
name|tp
operator|->
name|t_cflag
operator|=
name|t
operator|->
name|c_cflag
expr_stmt|;
comment|/* Set character length and parity mode. */
switch|switch
condition|(
name|t
operator|->
name|c_cflag
operator|&
name|CSIZE
condition|)
block|{
default|default:
case|case
name|CS8
case|:
name|bits
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|CS7
case|:
name|bits
operator|=
literal|7
expr_stmt|;
break|break;
case|case
name|CS6
case|:
name|bits
operator|=
literal|6
expr_stmt|;
break|break;
case|case
name|CS5
case|:
name|bits
operator|=
literal|5
expr_stmt|;
break|break;
block|}
name|parity
operator|=
operator|(
operator|(
name|t
operator|->
name|c_cflag
operator|&
name|PARENB
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
operator|*
operator|(
literal|1
operator|+
operator|(
operator|(
name|t
operator|->
name|c_cflag
operator|&
name|PARODD
operator|)
condition|?
literal|0
else|:
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* Set current channel number. */
if|if
condition|(
operator|!
name|d
operator|->
name|chan
operator|->
name|dtr
condition|)
name|cx_set_dtr
argument_list|(
name|d
operator|->
name|chan
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ttyldoptim
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|cx_set_async_param
argument_list|(
name|d
operator|->
name|chan
argument_list|,
name|t
operator|->
name|c_ospeed
argument_list|,
name|bits
argument_list|,
name|parity
argument_list|,
operator|(
name|t
operator|->
name|c_cflag
operator|&
name|CSTOPB
operator|)
argument_list|,
operator|!
operator|(
name|t
operator|->
name|c_cflag
operator|&
name|PARENB
operator|)
argument_list|,
operator|(
name|t
operator|->
name|c_cflag
operator|&
name|CRTSCTS
operator|)
argument_list|,
operator|(
name|t
operator|->
name|c_iflag
operator|&
name|IXON
operator|)
argument_list|,
operator|(
name|t
operator|->
name|c_iflag
operator|&
name|IXANY
operator|)
argument_list|,
name|t
operator|->
name|c_cc
index|[
name|VSTART
index|]
argument_list|,
name|t
operator|->
name|c_cc
index|[
name|VSTOP
index|]
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Stop output on a line  */
end_comment

begin_function
specifier|static
name|void
name|cx_stop
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|channel
index|[
name|UNIT
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
index|]
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|d
condition|)
return|return;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_BUSY
condition|)
block|{
comment|/* Stop transmitter */
name|CX_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"cx_stop\n"
operator|)
argument_list|)
expr_stmt|;
name|cx_transmitter_ctl
argument_list|(
name|d
operator|->
name|chan
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process the (delayed) carrier signal setup.  */
end_comment

begin_function
specifier|static
name|void
name|cx_carrier
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|arg
decl_stmt|;
name|cx_chan_t
modifier|*
name|c
init|=
name|d
operator|->
name|chan
decl_stmt|;
name|int
name|s
decl_stmt|,
name|cd
decl_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|cd
operator|=
name|cx_get_cd
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|cd
operator|!=
name|cd
condition|)
block|{
if|if
condition|(
name|cd
condition|)
block|{
name|CX_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"carrier on\n"
operator|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|cd
operator|=
literal|1
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|tty
condition|)
name|ttyld_modem
argument_list|(
name|d
operator|->
name|tty
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CX_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"carrier loss\n"
operator|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|cd
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|tty
condition|)
name|ttyld_modem
argument_list|(
name|d
operator|->
name|tty
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Modem signal callback function.  */
end_comment

begin_function
specifier|static
name|void
name|cx_modem
parameter_list|(
name|cx_chan_t
modifier|*
name|c
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|c
operator|->
name|sys
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|||
name|c
operator|->
name|mode
operator|!=
name|M_ASYNC
condition|)
return|return;
comment|/* Handle carrier detect/loss. */
name|untimeout
argument_list|(
name|cx_carrier
argument_list|,
name|c
argument_list|,
name|d
operator|->
name|dcd_timeout_handle
argument_list|)
expr_stmt|;
comment|/* Carrier changed - delay processing DCD for a while 	 * to give both sides some time to initialize. */
name|d
operator|->
name|dcd_timeout_handle
operator|=
name|timeout
argument_list|(
name|cx_carrier
argument_list|,
name|d
argument_list|,
name|hz
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
end_if

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|cx_cdevsw
init|=
block|{
name|cx_open
block|,
name|cx_close
block|,
name|cx_read
block|,
name|cx_write
block|,
name|cx_ioctl
block|,
name|ttypoll
block|,
name|nommap
block|,
name|nostrategy
block|,
literal|"cx"
block|,
name|CDEV_MAJOR
block|,
name|nodump
block|,
name|nopsize
block|,
name|D_TTY
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_elif
elif|#
directive|elif
name|__FreeBSD_version
operator|==
literal|500000
end_elif

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|cx_cdevsw
init|=
block|{
name|cx_open
block|,
name|cx_close
block|,
name|cx_read
block|,
name|cx_write
block|,
name|cx_ioctl
block|,
name|ttypoll
block|,
name|nommap
block|,
name|nostrategy
block|,
literal|"cx"
block|,
name|CDEV_MAJOR
block|,
name|nodump
block|,
name|nopsize
block|,
name|D_TTY
block|, 	}
decl_stmt|;
end_decl_stmt

begin_elif
elif|#
directive|elif
name|__FreeBSD_version
operator|<=
literal|501000
end_elif

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|cx_cdevsw
init|=
block|{
operator|.
name|d_open
operator|=
name|cx_open
block|,
operator|.
name|d_close
operator|=
name|cx_close
block|,
operator|.
name|d_read
operator|=
name|cx_read
block|,
operator|.
name|d_write
operator|=
name|cx_write
block|,
operator|.
name|d_ioctl
operator|=
name|cx_ioctl
block|,
operator|.
name|d_poll
operator|=
name|ttypoll
block|,
operator|.
name|d_mmap
operator|=
name|nommap
block|,
operator|.
name|d_strategy
operator|=
name|nostrategy
block|,
operator|.
name|d_name
operator|=
literal|"cx"
block|,
operator|.
name|d_maj
operator|=
name|CDEV_MAJOR
block|,
operator|.
name|d_dump
operator|=
name|nodump
block|,
operator|.
name|d_flags
operator|=
name|D_TTY
block|, }
decl_stmt|;
end_decl_stmt

begin_elif
elif|#
directive|elif
name|__FreeBSD_version
operator|<
literal|502103
end_elif

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|cx_cdevsw
init|=
block|{
operator|.
name|d_open
operator|=
name|cx_open
block|,
operator|.
name|d_close
operator|=
name|cx_close
block|,
operator|.
name|d_read
operator|=
name|cx_read
block|,
operator|.
name|d_write
operator|=
name|cx_write
block|,
operator|.
name|d_ioctl
operator|=
name|cx_ioctl
block|,
operator|.
name|d_poll
operator|=
name|ttypoll
block|,
operator|.
name|d_name
operator|=
literal|"cx"
block|,
operator|.
name|d_maj
operator|=
name|CDEV_MAJOR
block|,
operator|.
name|d_flags
operator|=
name|D_TTY
block|, }
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* __FreeBSD_version>= 502103 */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|cx_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_open
operator|=
name|cx_open
block|,
operator|.
name|d_close
operator|=
name|cx_close
block|,
operator|.
name|d_read
operator|=
name|cx_read
block|,
operator|.
name|d_write
operator|=
name|cx_write
block|,
operator|.
name|d_ioctl
operator|=
name|cx_ioctl
block|,
operator|.
name|d_name
operator|=
literal|"cx"
block|,
operator|.
name|d_maj
operator|=
name|CDEV_MAJOR
block|,
operator|.
name|d_flags
operator|=
name|D_TTY
operator||
name|D_NEEDGIANT
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NETGRAPH
end_ifdef

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
end_if

begin_function
specifier|static
name|int
name|ng_cx_constructor
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
else|#
directive|else
specifier|static
name|int
name|ng_cx_constructor
parameter_list|(
name|node_p
modifier|*
name|node
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
operator|(
operator|*
name|node
operator|)
operator|->
name|private
decl_stmt|;
endif|#
directive|endif
name|CX_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"Constructor\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
specifier|static
name|int
name|ng_cx_newhook
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|drv_t
modifier|*
name|d
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
else|#
directive|else
name|drv_t
modifier|*
name|d
init|=
name|node
operator|->
name|private
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|d
operator|->
name|chan
operator|->
name|mode
operator|==
name|M_ASYNC
condition|)
return|return
name|EINVAL
return|;
comment|/* Attach debug hook */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|NG_CX_HOOK_DEBUG
argument_list|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|NG_HOOK_SET_PRIVATE
argument_list|(
name|hook
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
name|hook
operator|->
name|private
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|debug_hook
operator|=
name|hook
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Check for raw hook */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|NG_CX_HOOK_RAW
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|EINVAL
return|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|NG_HOOK_SET_PRIVATE
argument_list|(
name|hook
argument_list|,
name|d
argument_list|)
expr_stmt|;
else|#
directive|else
name|hook
operator|->
name|private
operator|=
name|d
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|hook
operator|=
name|hook
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|cx_up
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
specifier|static
name|int
name|print_modems
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|cx_chan_t
modifier|*
name|c
parameter_list|,
name|int
name|need_header
parameter_list|)
block|{
name|int
name|status
init|=
name|cx_modem_status
argument_list|(
name|c
operator|->
name|sys
argument_list|)
decl_stmt|;
name|int
name|length
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|need_header
condition|)
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|"  LE   DTR  DSR  RTS  CTS  CD\n"
argument_list|)
expr_stmt|;
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|"%4s %4s %4s %4s %4s %4s\n"
argument_list|,
name|status
operator|&
name|TIOCM_LE
condition|?
literal|"On"
else|:
literal|"-"
argument_list|,
name|status
operator|&
name|TIOCM_DTR
condition|?
literal|"On"
else|:
literal|"-"
argument_list|,
name|status
operator|&
name|TIOCM_DSR
condition|?
literal|"On"
else|:
literal|"-"
argument_list|,
name|status
operator|&
name|TIOCM_RTS
condition|?
literal|"On"
else|:
literal|"-"
argument_list|,
name|status
operator|&
name|TIOCM_CTS
condition|?
literal|"On"
else|:
literal|"-"
argument_list|,
name|status
operator|&
name|TIOCM_CD
condition|?
literal|"On"
else|:
literal|"-"
argument_list|)
expr_stmt|;
return|return
name|length
return|;
block|}
specifier|static
name|int
name|print_stats
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|cx_chan_t
modifier|*
name|c
parameter_list|,
name|int
name|need_header
parameter_list|)
block|{
name|int
name|length
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|need_header
condition|)
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|"  Rintr   Tintr   Mintr   Ibytes   Ipkts   Ierrs   Obytes   Opkts   Oerrs\n"
argument_list|)
expr_stmt|;
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|"%7ld %7ld %7ld %8ld %7ld %7ld %8ld %7ld %7ld\n"
argument_list|,
name|c
operator|->
name|rintr
argument_list|,
name|c
operator|->
name|tintr
argument_list|,
name|c
operator|->
name|mintr
argument_list|,
name|c
operator|->
name|ibytes
argument_list|,
name|c
operator|->
name|ipkts
argument_list|,
name|c
operator|->
name|ierrs
argument_list|,
name|c
operator|->
name|obytes
argument_list|,
name|c
operator|->
name|opkts
argument_list|,
name|c
operator|->
name|oerrs
argument_list|)
expr_stmt|;
return|return
name|length
return|;
block|}
specifier|static
name|int
name|print_chan
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|cx_chan_t
modifier|*
name|c
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|c
operator|->
name|sys
decl_stmt|;
name|int
name|length
init|=
literal|0
decl_stmt|;
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|"cx%d"
argument_list|,
name|c
operator|->
name|board
operator|->
name|num
operator|*
name|NCHAN
operator|+
name|c
operator|->
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|chan
operator|->
name|debug
condition|)
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" debug=%d"
argument_list|,
name|d
operator|->
name|chan
operator|->
name|debug
argument_list|)
expr_stmt|;
if|if
condition|(
name|cx_get_baud
argument_list|(
name|c
argument_list|)
condition|)
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" %ld"
argument_list|,
name|cx_get_baud
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" extclock"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|mode
operator|==
name|M_HDLC
condition|)
block|{
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" dpll=%s"
argument_list|,
name|cx_get_dpll
argument_list|(
name|c
argument_list|)
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" nrzi=%s"
argument_list|,
name|cx_get_nrzi
argument_list|(
name|c
argument_list|)
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
block|}
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" loop=%s"
argument_list|,
name|cx_get_loop
argument_list|(
name|c
argument_list|)
condition|?
literal|"on\n"
else|:
literal|"off\n"
argument_list|)
expr_stmt|;
return|return
name|length
return|;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
specifier|static
name|int
name|ng_cx_rcvmsg
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|,
name|hook_p
name|lasthook
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|msg
decl_stmt|;
else|#
directive|else
specifier|static
name|int
name|ng_cx_rcvmsg
parameter_list|(
name|node_p
name|node
parameter_list|,
name|struct
name|ng_mesg
modifier|*
name|msg
parameter_list|,
specifier|const
name|char
modifier|*
name|retaddr
parameter_list|,
name|struct
name|ng_mesg
modifier|*
modifier|*
name|rptr
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|node
operator|->
name|private
decl_stmt|;
endif|#
directive|endif
name|struct
name|ng_mesg
modifier|*
name|resp
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|EINVAL
return|;
name|CX_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"Rcvmsg\n"
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|NGI_GET_MSG
argument_list|(
name|item
argument_list|,
name|msg
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|typecookie
condition|)
block|{
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|NGM_CX_COOKIE
case|:
name|printf
argument_list|(
literal|"Don't forget to implement\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|NGM_GENERIC_COOKIE
case|:
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
condition|)
block|{
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|NGM_TEXT_STATUS
case|:
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|l
init|=
literal|0
decl_stmt|;
name|int
name|dl
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|ng_mesg
argument_list|)
operator|+
literal|730
decl_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
name|dl
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|resp
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
else|#
directive|else
name|MALLOC
argument_list|(
name|resp
argument_list|,
expr|struct
name|ng_mesg
operator|*
argument_list|,
name|dl
argument_list|,
name|M_NETGRAPH
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|resp
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
name|bzero
argument_list|(
name|resp
argument_list|,
name|dl
argument_list|)
expr_stmt|;
name|s
operator|=
operator|(
name|resp
operator|)
operator|->
name|data
expr_stmt|;
name|l
operator|+=
name|print_chan
argument_list|(
name|s
operator|+
name|l
argument_list|,
name|d
operator|->
name|chan
argument_list|)
expr_stmt|;
name|l
operator|+=
name|print_stats
argument_list|(
name|s
operator|+
name|l
argument_list|,
name|d
operator|->
name|chan
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|l
operator|+=
name|print_modems
argument_list|(
name|s
operator|+
name|l
argument_list|,
name|d
operator|->
name|chan
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
operator|(
name|resp
operator|)
operator|->
name|header
operator|.
name|version
operator|=
name|NG_VERSION
expr_stmt|;
operator|(
name|resp
operator|)
operator|->
name|header
operator|.
name|arglen
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|(
name|resp
operator|)
operator|->
name|header
operator|.
name|token
operator|=
name|msg
operator|->
name|header
operator|.
name|token
expr_stmt|;
operator|(
name|resp
operator|)
operator|->
name|header
operator|.
name|typecookie
operator|=
name|NGM_CX_COOKIE
expr_stmt|;
operator|(
name|resp
operator|)
operator|->
name|header
operator|.
name|cmd
operator|=
name|msg
operator|->
name|header
operator|.
name|cmd
expr_stmt|;
endif|#
directive|endif
name|strncpy
argument_list|(
operator|(
name|resp
operator|)
operator|->
name|header
operator|.
name|cmdstr
argument_list|,
literal|"status"
argument_list|,
name|NG_CMDSTRLEN
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
break|break;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|NG_RESPOND_MSG
argument_list|(
name|error
argument_list|,
name|node
argument_list|,
name|item
argument_list|,
name|resp
argument_list|)
expr_stmt|;
name|NG_FREE_MSG
argument_list|(
name|msg
argument_list|)
expr_stmt|;
else|#
directive|else
operator|*
name|rptr
operator|=
name|resp
expr_stmt|;
name|FREE
argument_list|(
name|msg
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|error
return|;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
specifier|static
name|int
name|ng_cx_rcvdata
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|item_p
name|item
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ng_tag_prio
modifier|*
name|ptag
decl_stmt|;
else|#
directive|else
specifier|static
name|int
name|ng_cx_rcvdata
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|meta_p
name|meta
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|hook
operator|->
name|node
operator|->
name|private
decl_stmt|;
endif|#
directive|endif
name|struct
name|ifqueue
modifier|*
name|q
decl_stmt|;
name|int
name|s
decl_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|NGI_GET_M
argument_list|(
name|item
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
operator|||
operator|!
name|d
condition|)
block|{
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|hook
operator|->
name|private
operator|||
operator|!
name|d
condition|)
block|{
name|NG_FREE_DATA
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|ENETDOWN
return|;
block|}
comment|/* Check for high priority data */
if|if
condition|(
operator|(
name|ptag
operator|=
operator|(
expr|struct
name|ng_tag_prio
operator|*
operator|)
name|m_tag_locate
argument_list|(
name|m
argument_list|,
name|NGM_GENERIC_COOKIE
argument_list|,
name|NG_TAG_PRIO
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|ptag
operator|->
name|priority
operator|>
name|NG_PRIO_CUTOFF
operator|)
condition|)
name|q
operator|=
operator|&
name|d
operator|->
name|hi_queue
expr_stmt|;
else|else
name|q
operator|=
operator|&
name|d
operator|->
name|lo_queue
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|IF_LOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|_IF_QFULL
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|_IF_DROP
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|IF_UNLOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
name|_IF_ENQUEUE
argument_list|(
name|q
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|IF_UNLOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|IF_QFULL
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|IF_DROP
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|NG_FREE_DATA
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
name|IF_ENQUEUE
argument_list|(
name|q
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cx_start
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
specifier|static
name|int
name|ng_cx_rmnode
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|drv_t
modifier|*
name|d
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|CX_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"Rmnode\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|&&
name|d
operator|->
name|running
condition|)
block|{
name|int
name|s
init|=
name|splhigh
argument_list|()
decl_stmt|;
name|cx_down
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|KLD_MODULE
if|if
condition|(
name|node
operator|->
name|nd_flags
operator|&
name|NGF_REALLY_DIE
condition|)
block|{
name|NG_NODE_SET_PRIVATE
argument_list|(
name|node
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|NG_NODE_UNREF
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
name|NG_NODE_REVIVE
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* Persistant node */
endif|#
directive|endif
else|#
directive|else
comment|/* __FreeBSD_version< 500000 */
name|drv_t
modifier|*
name|d
init|=
name|node
operator|->
name|private
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|cx_down
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|node
operator|->
name|flags
operator||=
name|NG_INVALID
expr_stmt|;
name|ng_cutlinks
argument_list|(
name|node
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KLD_MODULE
name|ng_unname
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|ng_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
else|#
directive|else
name|node
operator|->
name|flags
operator|&=
operator|~
name|NG_INVALID
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
return|return
literal|0
return|;
block|}
specifier|static
name|void
name|ng_cx_watchdog
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|timeout
operator|==
literal|1
condition|)
name|cx_watchdog
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|timeout
condition|)
name|d
operator|->
name|timeout
operator|--
expr_stmt|;
name|d
operator|->
name|timeout_handle
operator|=
name|timeout
argument_list|(
name|ng_cx_watchdog
argument_list|,
name|d
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
specifier|static
name|int
name|ng_cx_connect
parameter_list|(
name|hook_p
name|hook
parameter_list|)
block|{
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|drv_t
modifier|*
name|d
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
argument_list|)
decl_stmt|;
else|#
directive|else
name|drv_t
modifier|*
name|d
init|=
name|hook
operator|->
name|node
operator|->
name|private
decl_stmt|;
endif|#
directive|endif
name|d
operator|->
name|timeout_handle
operator|=
name|timeout
argument_list|(
name|ng_cx_watchdog
argument_list|,
name|d
argument_list|,
name|hz
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
specifier|static
name|int
name|ng_cx_disconnect
parameter_list|(
name|hook_p
name|hook
parameter_list|)
block|{
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|drv_t
modifier|*
name|d
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
argument_list|)
decl_stmt|;
else|#
directive|else
name|drv_t
modifier|*
name|d
init|=
name|hook
operator|->
name|node
operator|->
name|private
decl_stmt|;
endif|#
directive|endif
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
if|if
condition|(
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
name|hook
operator|->
name|private
condition|)
endif|#
directive|endif
name|cx_down
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|ng_cx_watchdog
argument_list|,
name|d
argument_list|,
name|d
operator|->
name|timeout_handle
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/*NETGRAPH*/
specifier|static
name|int
name|cx_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|unused
parameter_list|)
block|{
specifier|static
name|int
name|load_count
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
operator|&&
name|defined
name|NETGRAPH
if|if
condition|(
name|ng_newtype
argument_list|(
operator|&
name|typestruct
argument_list|)
condition|)
name|printf
argument_list|(
literal|"Failed to register ng_cx\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|++
name|load_count
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<=
literal|500000
name|cdevsw_add
argument_list|(
operator|&
name|cx_cdevsw
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|timeout_handle
operator|=
name|timeout
argument_list|(
name|cx_timeout
argument_list|,
literal|0
argument_list|,
name|hz
operator|*
literal|5
argument_list|)
expr_stmt|;
comment|/* Software interrupt. */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
name|register_swi
argument_list|(
name|SWI_TTY
argument_list|,
name|cx_softintr
argument_list|)
expr_stmt|;
else|#
directive|else
name|swi_add
argument_list|(
operator|&
name|tty_ithd
argument_list|,
literal|"cx"
argument_list|,
name|cx_softintr
argument_list|,
name|NULL
argument_list|,
name|SWI_TTY
argument_list|,
literal|0
argument_list|,
operator|&
name|cx_fast_ih
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|MOD_UNLOAD
case|:
if|if
condition|(
name|load_count
operator|==
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"Removing device entry for Sigma\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<=
literal|500000
name|cdevsw_remove
argument_list|(
operator|&
name|cx_cdevsw
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
operator|&&
name|defined
name|NETGRAPH
name|ng_rmtype
argument_list|(
operator|&
name|typestruct
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|timeout_handle
operator|.
name|callout
condition|)
name|untimeout
argument_list|(
name|cx_timeout
argument_list|,
literal|0
argument_list|,
name|timeout_handle
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|ithread_remove_handler
argument_list|(
name|cx_fast_ih
argument_list|)
expr_stmt|;
else|#
directive|else
name|unregister_swi
argument_list|(
name|SWI_TTY
argument_list|,
name|cx_softintr
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|--
name|load_count
expr_stmt|;
break|break;
case|case
name|MOD_SHUTDOWN
case|:
break|break;
block|}
return|return
literal|0
return|;
block|}
ifdef|#
directive|ifdef
name|NETGRAPH
specifier|static
name|struct
name|ng_type
name|typestruct
init|=
block|{
operator|.
name|version
operator|=
name|NG_ABI_VERSION
block|,
operator|.
name|name
operator|=
name|NG_CX_NODE_TYPE
block|,
operator|.
name|constructor
operator|=
name|ng_cx_constructor
block|,
operator|.
name|rcvmsg
operator|=
name|ng_cx_rcvmsg
block|,
operator|.
name|shutdown
operator|=
name|ng_cx_rmnode
block|,
operator|.
name|newhook
operator|=
name|ng_cx_newhook
block|,
operator|.
name|connect
operator|=
name|ng_cx_connect
block|,
operator|.
name|rcvdata
operator|=
name|ng_cx_rcvdata
block|,
operator|.
name|disconnect
operator|=
name|ng_cx_disconnect
block|, }
decl_stmt|;
endif|#
directive|endif
comment|/*NETGRAPH*/
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
ifdef|#
directive|ifdef
name|NETGRAPH
name|MODULE_DEPEND
argument_list|(
name|ng_cx
argument_list|,
name|netgraph
argument_list|,
name|NG_ABI_VERSION
argument_list|,
name|NG_ABI_VERSION
argument_list|,
name|NG_ABI_VERSION
argument_list|)
expr_stmt|;
else|#
directive|else
name|MODULE_DEPEND
argument_list|(
name|isa_cx
argument_list|,
name|sppp
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KLD_MODULE
name|DRIVER_MODULE
argument_list|(
name|cxmod
argument_list|,
name|isa
argument_list|,
name|cx_isa_driver
argument_list|,
name|cx_devclass
argument_list|,
name|cx_modevent
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
name|DRIVER_MODULE
argument_list|(
name|cx
argument_list|,
name|isa
argument_list|,
name|cx_isa_driver
argument_list|,
name|cx_devclass
argument_list|,
name|cx_modevent
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
elif|#
directive|elif
name|__FreeBSD_version
operator|>=
literal|400000
ifdef|#
directive|ifdef
name|NETGRAPH
name|DRIVER_MODULE
argument_list|(
name|cx
argument_list|,
name|isa
argument_list|,
name|cx_isa_driver
argument_list|,
name|cx_devclass
argument_list|,
name|ng_mod_event
argument_list|,
operator|&
name|typestruct
argument_list|)
expr_stmt|;
else|#
directive|else
name|DRIVER_MODULE
argument_list|(
name|cx
argument_list|,
name|isa
argument_list|,
name|cx_isa_driver
argument_list|,
name|cx_devclass
argument_list|,
name|cx_modevent
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  __FreeBSD_version>= 400000 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NCX */
end_comment

end_unit

