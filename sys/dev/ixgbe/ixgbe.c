begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************    Copyright (c) 2001-2013, Intel Corporation    All rights reserved.      Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are met:       1. Redistributions of source code must retain the above copyright notice,        this list of conditions and the following disclaimer.       2. Redistributions in binary form must reproduce the above copyright        notice, this list of conditions and the following disclaimer in the        documentation and/or other materials provided with the distribution.       3. Neither the name of the Intel Corporation nor the names of its        contributors may be used to endorse or promote products derived from        this software without specific prior written permission.      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  ******************************************************************************/
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|"ixgbe.h"
end_include

begin_comment
comment|/*********************************************************************  *  Set this to one to display debug statistics  *********************************************************************/
end_comment

begin_decl_stmt
name|int
name|ixgbe_display_debug_stats
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************  *  Driver version  *********************************************************************/
end_comment

begin_decl_stmt
name|char
name|ixgbe_driver_version
index|[]
init|=
literal|"2.5.15"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************  *  PCI Device ID Table  *  *  Used by probe to select devices to load on  *  Last field stores an index into ixgbe_strings  *  Last entry must be all 0s  *  *  { Vendor ID, Device ID, SubVendor ID, SubDevice ID, String Index }  *********************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|ixgbe_vendor_info_t
name|ixgbe_vendor_info_array
index|[]
init|=
block|{
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_82598AF_DUAL_PORT
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_82598AF_SINGLE_PORT
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_82598EB_CX4
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_82598AT
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_82598AT2
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_82598
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_82598_DA_DUAL_PORT
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_82598_CX4_DUAL_PORT
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_82598EB_XF_LR
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_82598_SR_DUAL_PORT_EM
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_82598EB_SFP_LOM
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_82599_KX4
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_82599_KX4_MEZZ
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_82599_SFP
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_82599_XAUI_LOM
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_82599_CX4
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_82599_T3_LOM
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_82599_COMBO_BACKPLANE
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_82599_BACKPLANE_FCOE
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_82599_SFP_SF2
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_82599_SFP_FCOE
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_82599EN_SFP
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_82599_SFP_SF_QP
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_X540T
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* required last entry */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************  *  Table of branding strings  *********************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ixgbe_strings
index|[]
init|=
block|{
literal|"Intel(R) PRO/10GbE PCI-Express Network Driver"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************  *  Function prototypes  *********************************************************************/
end_comment

begin_function_decl
specifier|static
name|int
name|ixgbe_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_shutdown
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|IXGBE_LEGACY_TX
end_ifdef

begin_function_decl
specifier|static
name|void
name|ixgbe_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_start_locked
parameter_list|(
name|struct
name|tx_ring
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! IXGBE_LEGACY_TX */
end_comment

begin_function_decl
specifier|static
name|int
name|ixgbe_mq_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_mq_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|tx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_qflush
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_deferred_mq_start
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IXGBE_LEGACY_TX */
end_comment

begin_function_decl
specifier|static
name|int
name|ixgbe_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_init_locked
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_stop
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|ifmediareq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_identify_hardware
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_allocate_pci_resources
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_get_slot_info
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_allocate_msix
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_allocate_legacy
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_allocate_queues
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_setup_msix
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_free_pci_resources
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_local_timer
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_setup_interface
parameter_list|(
name|device_t
parameter_list|,
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_config_link
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_allocate_transmit_buffers
parameter_list|(
name|struct
name|tx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_setup_transmit_structures
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_setup_transmit_ring
parameter_list|(
name|struct
name|tx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_initialize_transmit_units
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_free_transmit_structures
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_free_transmit_buffers
parameter_list|(
name|struct
name|tx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_allocate_receive_buffers
parameter_list|(
name|struct
name|rx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_setup_receive_structures
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_setup_receive_ring
parameter_list|(
name|struct
name|rx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_initialize_receive_units
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_free_receive_structures
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_free_receive_buffers
parameter_list|(
name|struct
name|rx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_setup_hw_rsc
parameter_list|(
name|struct
name|rx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_enable_intr
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_disable_intr
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_update_stats_counters
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_txeof
parameter_list|(
name|struct
name|tx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ixgbe_rxeof
parameter_list|(
name|struct
name|ix_queue
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_rx_checksum
parameter_list|(
name|u32
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|u32
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_set_promisc
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_set_multi
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_update_link_status
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_refresh_mbufs
parameter_list|(
name|struct
name|rx_ring
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_xmit
parameter_list|(
name|struct
name|tx_ring
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_set_flowcntl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_set_advertise
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_set_thermal_test
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_dma_malloc
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|bus_size_t
parameter_list|,
name|struct
name|ixgbe_dma_alloc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_dma_free
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|ixgbe_dma_alloc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_tx_ctx_setup
parameter_list|(
name|struct
name|tx_ring
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|u32
modifier|*
parameter_list|,
name|u32
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_tso_setup
parameter_list|(
name|struct
name|tx_ring
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|u32
modifier|*
parameter_list|,
name|u32
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_set_ivar
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|u8
parameter_list|,
name|u8
parameter_list|,
name|s8
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_configure_ivars
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u8
modifier|*
name|ixgbe_mc_array_itr
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
parameter_list|,
name|u8
modifier|*
modifier|*
parameter_list|,
name|u32
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_setup_vlan_hw_support
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_register_vlan
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u16
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_unregister_vlan
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u16
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_add_hw_stats
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ixgbe_rx_discard
parameter_list|(
name|struct
name|rx_ring
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ixgbe_rx_input
parameter_list|(
name|struct
name|rx_ring
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|u32
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_enable_rx_drop
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_disable_rx_drop
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Support for pluggable optic modules */
end_comment

begin_function_decl
specifier|static
name|bool
name|ixgbe_sfp_probe
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_setup_optics
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Legacy (single vector interrupt handler */
end_comment

begin_function_decl
specifier|static
name|void
name|ixgbe_legacy_irq
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The MSI/X Interrupt handlers */
end_comment

begin_function_decl
specifier|static
name|void
name|ixgbe_msix_que
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_msix_link
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Deferred interrupt tasklets */
end_comment

begin_function_decl
specifier|static
name|void
name|ixgbe_handle_que
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_handle_link
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_handle_msf
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_handle_mod
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|IXGBE_FDIR
end_ifdef

begin_function_decl
specifier|static
name|void
name|ixgbe_atr
parameter_list|(
name|struct
name|tx_ring
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_reinit_fdir
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Missing shared code prototype */
end_comment

begin_function_decl
specifier|extern
name|void
name|ixgbe_stop_mac_link_on_d3_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*********************************************************************  *  FreeBSD Device Interface Entry Points  *********************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|device_method_t
name|ixgbe_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ixgbe_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ixgbe_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|ixgbe_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|ixgbe_shutdown
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|ixgbe_driver
init|=
block|{
literal|"ix"
block|,
name|ixgbe_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|adapter
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|devclass_t
name|ixgbe_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|ixgbe
argument_list|,
name|pci
argument_list|,
name|ixgbe_driver
argument_list|,
name|ixgbe_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ixgbe
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ixgbe
argument_list|,
name|ether
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ** TUNEABLE PARAMETERS: */
end_comment

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|ix
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"IXGBE driver parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ** AIM: Adaptive Interrupt Moderation ** which means that the interrupt rate ** is varied over time based on the ** traffic for that interrupt vector */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ixgbe_enable_aim
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ix.enable_aim"
argument_list|,
operator|&
name|ixgbe_enable_aim
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ix
argument_list|,
name|OID_AUTO
argument_list|,
name|enable_aim
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ixgbe_enable_aim
argument_list|,
literal|0
argument_list|,
literal|"Enable adaptive interrupt moderation"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ixgbe_max_interrupt_rate
init|=
operator|(
literal|4000000
operator|/
name|IXGBE_LOW_LATENCY
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ix.max_interrupt_rate"
argument_list|,
operator|&
name|ixgbe_max_interrupt_rate
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ix
argument_list|,
name|OID_AUTO
argument_list|,
name|max_interrupt_rate
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixgbe_max_interrupt_rate
argument_list|,
literal|0
argument_list|,
literal|"Maximum interrupts per second"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* How many packets rxeof tries to clean at a time */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ixgbe_rx_process_limit
init|=
literal|256
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ix.rx_process_limit"
argument_list|,
operator|&
name|ixgbe_rx_process_limit
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ix
argument_list|,
name|OID_AUTO
argument_list|,
name|rx_process_limit
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixgbe_rx_process_limit
argument_list|,
literal|0
argument_list|,
literal|"Maximum number of received packets to process at a time,"
literal|"-1 means unlimited"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* How many packets txeof tries to clean at a time */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ixgbe_tx_process_limit
init|=
literal|256
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ix.tx_process_limit"
argument_list|,
operator|&
name|ixgbe_tx_process_limit
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ix
argument_list|,
name|OID_AUTO
argument_list|,
name|tx_process_limit
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixgbe_tx_process_limit
argument_list|,
literal|0
argument_list|,
literal|"Maximum number of sent packets to process at a time,"
literal|"-1 means unlimited"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ** Smart speed setting, default to on ** this only works as a compile option ** right now as its during attach, set ** this to 'ixgbe_smart_speed_off' to ** disable. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ixgbe_smart_speed
init|=
name|ixgbe_smart_speed_on
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * MSIX should be the default for best performance,  * but this allows it to be forced off for testing.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ixgbe_enable_msix
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ix.enable_msix"
argument_list|,
operator|&
name|ixgbe_enable_msix
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ix
argument_list|,
name|OID_AUTO
argument_list|,
name|enable_msix
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixgbe_enable_msix
argument_list|,
literal|0
argument_list|,
literal|"Enable MSI-X interrupts"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Number of Queues, can be set to 0,  * it then autoconfigures based on the  * number of cpus with a max of 8. This  * can be overriden manually here.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ixgbe_num_queues
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ix.num_queues"
argument_list|,
operator|&
name|ixgbe_num_queues
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ix
argument_list|,
name|OID_AUTO
argument_list|,
name|num_queues
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixgbe_num_queues
argument_list|,
literal|0
argument_list|,
literal|"Number of queues to configure, 0 indicates autoconfigure"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ** Number of TX descriptors per ring, ** setting higher than RX as this seems ** the better performing choice. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ixgbe_txd
init|=
name|PERFORM_TXD
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ix.txd"
argument_list|,
operator|&
name|ixgbe_txd
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ix
argument_list|,
name|OID_AUTO
argument_list|,
name|txd
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixgbe_txd
argument_list|,
literal|0
argument_list|,
literal|"Number of transmit descriptors per queue"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Number of RX descriptors per ring */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ixgbe_rxd
init|=
name|PERFORM_RXD
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ix.rxd"
argument_list|,
operator|&
name|ixgbe_rxd
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ix
argument_list|,
name|OID_AUTO
argument_list|,
name|rxd
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixgbe_rxd
argument_list|,
literal|0
argument_list|,
literal|"Number of receive descriptors per queue"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ** Defining this on will allow the use ** of unsupported SFP+ modules, note that ** doing so you are on your own :) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|allow_unsupported_sfp
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ix.unsupported_sfp"
argument_list|,
operator|&
name|allow_unsupported_sfp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ** HW RSC control:  **  this feature only works with **  IPv4, and only on 82599 and later. **  Also this will cause IP forwarding to **  fail and that can't be controlled by **  the stack as LRO can. For all these **  reasons I've deemed it best to leave **  this off and not bother with a tuneable **  interface, this would need to be compiled **  to enable. */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|ixgbe_rsc_enable
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Keep running tab on them for sanity check */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ixgbe_total_ports
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|IXGBE_FDIR
end_ifdef

begin_comment
comment|/* ** For Flow Director: this is the ** number of TX packets we sample ** for the filter pool, this means ** every 20th packet will be probed. ** ** This feature can be disabled by  ** setting this to 0. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|atr_sample_rate
init|=
literal|20
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  ** Flow Director actually 'steals' ** part of the packet buffer as its ** filter pool, this variable controls ** how much it uses: **  0 = 64K, 1 = 128K, 2 = 256K */
end_comment

begin_decl_stmt
specifier|static
name|int
name|fdir_pballoc
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEV_NETMAP
end_ifdef

begin_comment
comment|/*  * The #ifdef DEV_NETMAP / #endif blocks in this file are meant to  * be a reference on how to implement netmap support in a driver.  * Additional comments are in ixgbe_netmap.h .  *  *<dev/netmap/ixgbe_netmap.h> contains functions for netmap support  * that extend the standard driver.  */
end_comment

begin_include
include|#
directive|include
file|<dev/netmap/ixgbe_netmap.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEV_NETMAP */
end_comment

begin_comment
comment|/*********************************************************************  *  Device identification routine  *  *  ixgbe_probe determines if the driver should be loaded on  *  adapter based on PCI vendor/device id of the adapter.  *  *  return BUS_PROBE_DEFAULT on success, positive on failure  *********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|ixgbe_vendor_info_t
modifier|*
name|ent
decl_stmt|;
name|u16
name|pci_vendor_id
init|=
literal|0
decl_stmt|;
name|u16
name|pci_device_id
init|=
literal|0
decl_stmt|;
name|u16
name|pci_subvendor_id
init|=
literal|0
decl_stmt|;
name|u16
name|pci_subdevice_id
init|=
literal|0
decl_stmt|;
name|char
name|adapter_name
index|[
literal|256
index|]
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixgbe_probe: begin"
argument_list|)
expr_stmt|;
name|pci_vendor_id
operator|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_vendor_id
operator|!=
name|IXGBE_INTEL_VENDOR_ID
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|pci_device_id
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_subvendor_id
operator|=
name|pci_get_subvendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_subdevice_id
operator|=
name|pci_get_subdevice
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ent
operator|=
name|ixgbe_vendor_info_array
expr_stmt|;
while|while
condition|(
name|ent
operator|->
name|vendor_id
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|pci_vendor_id
operator|==
name|ent
operator|->
name|vendor_id
operator|)
operator|&&
operator|(
name|pci_device_id
operator|==
name|ent
operator|->
name|device_id
operator|)
operator|&&
operator|(
operator|(
name|pci_subvendor_id
operator|==
name|ent
operator|->
name|subvendor_id
operator|)
operator|||
operator|(
name|ent
operator|->
name|subvendor_id
operator|==
literal|0
operator|)
operator|)
operator|&&
operator|(
operator|(
name|pci_subdevice_id
operator|==
name|ent
operator|->
name|subdevice_id
operator|)
operator|||
operator|(
name|ent
operator|->
name|subdevice_id
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|adapter_name
argument_list|,
literal|"%s, Version - %s"
argument_list|,
name|ixgbe_strings
index|[
name|ent
operator|->
name|index
index|]
argument_list|,
name|ixgbe_driver_version
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|adapter_name
argument_list|)
expr_stmt|;
operator|++
name|ixgbe_total_ports
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
name|ent
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Device initialization routine  *  *  The attach entry point is called when the driver is being loaded.  *  This routine identifies the type of hardware, allocates all resources  *  and initializes the hardware.  *  *  return 0 on success, positive on failure  *********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|u16
name|csum
decl_stmt|;
name|u32
name|ctrl_ext
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixgbe_attach: begin"
argument_list|)
expr_stmt|;
comment|/* Allocate, clear, and link in our adapter structure */
name|adapter
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|dev
operator|=
name|adapter
operator|->
name|osdep
operator|.
name|dev
operator|=
name|dev
expr_stmt|;
name|hw
operator|=
operator|&
name|adapter
operator|->
name|hw
expr_stmt|;
comment|/* Core Lock Init*/
name|IXGBE_CORE_LOCK_INIT
argument_list|(
name|adapter
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* SYSCTL APIs */
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"fc"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|adapter
argument_list|,
literal|0
argument_list|,
name|ixgbe_set_flowcntl
argument_list|,
literal|"I"
argument_list|,
literal|"Flow Control"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"enable_aim"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|ixgbe_enable_aim
argument_list|,
literal|1
argument_list|,
literal|"Interrupt Moderation"
argument_list|)
expr_stmt|;
comment|/* 	** Allow a kind of speed control by forcing the autoneg 	** advertised speed list to only a certain value, this 	** supports 1G on 82599 devices, and 100Mb on x540. 	*/
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"advertise_speed"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|adapter
argument_list|,
literal|0
argument_list|,
name|ixgbe_set_advertise
argument_list|,
literal|"I"
argument_list|,
literal|"Link Speed"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ts"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|adapter
argument_list|,
literal|0
argument_list|,
name|ixgbe_set_thermal_test
argument_list|,
literal|"I"
argument_list|,
literal|"Thermal Test"
argument_list|)
expr_stmt|;
comment|/* Set up the timer callout */
name|callout_init_mtx
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|,
operator|&
name|adapter
operator|->
name|core_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Determine hardware revision */
name|ixgbe_identify_hardware
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Do base PCI setup - map BAR0 */
if|if
condition|(
name|ixgbe_allocate_pci_resources
argument_list|(
name|adapter
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Allocation of PCI resources failed\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
comment|/* Do descriptor calc and sanity checks */
if|if
condition|(
operator|(
operator|(
name|ixgbe_txd
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|ixgbe_adv_tx_desc
argument_list|)
operator|)
operator|%
name|DBA_ALIGN
operator|)
operator|!=
literal|0
operator|||
name|ixgbe_txd
operator|<
name|MIN_TXD
operator|||
name|ixgbe_txd
operator|>
name|MAX_TXD
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"TXD config issue, using default!\n"
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|num_tx_desc
operator|=
name|DEFAULT_TXD
expr_stmt|;
block|}
else|else
name|adapter
operator|->
name|num_tx_desc
operator|=
name|ixgbe_txd
expr_stmt|;
comment|/* 	** With many RX rings it is easy to exceed the 	** system mbuf allocation. Tuning nmbclusters 	** can alleviate this. 	*/
if|if
condition|(
name|nmbclusters
operator|>
literal|0
condition|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
operator|(
name|ixgbe_rxd
operator|*
name|adapter
operator|->
name|num_queues
operator|)
operator|*
name|ixgbe_total_ports
expr_stmt|;
if|if
condition|(
name|s
operator|>
name|nmbclusters
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"RX Descriptors exceed "
literal|"system mbuf max, using default instead!\n"
argument_list|)
expr_stmt|;
name|ixgbe_rxd
operator|=
name|DEFAULT_RXD
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
operator|(
name|ixgbe_rxd
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|ixgbe_adv_rx_desc
argument_list|)
operator|)
operator|%
name|DBA_ALIGN
operator|)
operator|!=
literal|0
operator|||
name|ixgbe_rxd
operator|<
name|MIN_RXD
operator|||
name|ixgbe_rxd
operator|>
name|MAX_RXD
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"RXD config issue, using default!\n"
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|num_rx_desc
operator|=
name|DEFAULT_RXD
expr_stmt|;
block|}
else|else
name|adapter
operator|->
name|num_rx_desc
operator|=
name|ixgbe_rxd
expr_stmt|;
comment|/* Allocate our TX/RX Queues */
if|if
condition|(
name|ixgbe_allocate_queues
argument_list|(
name|adapter
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
comment|/* Allocate multicast array memory. */
name|adapter
operator|->
name|mta
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|u8
argument_list|)
operator|*
name|IXGBE_ETH_LENGTH_OF_ADDRESS
operator|*
name|MAX_NUM_MULTICAST_ADDRESSES
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|mta
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Can not allocate multicast setup array\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_late
goto|;
block|}
comment|/* Initialize the shared code */
name|hw
operator|->
name|allow_unsupported_sfp
operator|=
name|allow_unsupported_sfp
expr_stmt|;
name|error
operator|=
name|ixgbe_init_shared_code
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|IXGBE_ERR_SFP_NOT_PRESENT
condition|)
block|{
comment|/* 		** No optics in this port, set up 		** so the timer routine will probe  		** for later insertion. 		*/
name|adapter
operator|->
name|sfp_probe
operator|=
name|TRUE
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|==
name|IXGBE_ERR_SFP_NOT_SUPPORTED
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unsupported SFP+ module detected!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|err_late
goto|;
block|}
elseif|else
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to initialize the shared code\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|err_late
goto|;
block|}
comment|/* Make sure we have a good EEPROM before we read from it */
if|if
condition|(
name|ixgbe_validate_eeprom_checksum
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
operator|&
name|csum
argument_list|)
operator|<
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"The EEPROM Checksum Is Not Valid\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|err_late
goto|;
block|}
name|error
operator|=
name|ixgbe_init_hw
argument_list|(
name|hw
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|error
condition|)
block|{
case|case
name|IXGBE_ERR_EEPROM_VERSION
case|:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"This device is a pre-production adapter/"
literal|"LOM.  Please be aware there may be issues associated "
literal|"with your hardware.\n If you are experiencing problems "
literal|"please contact your Intel or hardware representative "
literal|"who provided you with this hardware.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|IXGBE_ERR_SFP_NOT_SUPPORTED
case|:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unsupported SFP+ Module\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|err_late
goto|;
case|case
name|IXGBE_ERR_SFP_NOT_PRESENT
case|:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"No SFP+ Module found\n"
argument_list|)
expr_stmt|;
comment|/* falls thru */
default|default:
break|break;
block|}
comment|/* Detect and set physical type */
name|ixgbe_setup_optics
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|adapter
operator|->
name|msix
operator|>
literal|1
operator|)
operator|&&
operator|(
name|ixgbe_enable_msix
operator|)
condition|)
name|error
operator|=
name|ixgbe_allocate_msix
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|ixgbe_allocate_legacy
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|err_late
goto|;
comment|/* Setup OS specific network interface */
if|if
condition|(
name|ixgbe_setup_interface
argument_list|(
name|dev
argument_list|,
name|adapter
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|err_late
goto|;
comment|/* Initialize statistics */
name|ixgbe_update_stats_counters
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Register for VLAN events */
name|adapter
operator|->
name|vlan_attach
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|vlan_config
argument_list|,
name|ixgbe_register_vlan
argument_list|,
name|adapter
argument_list|,
name|EVENTHANDLER_PRI_FIRST
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|vlan_detach
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|vlan_unconfig
argument_list|,
name|ixgbe_unregister_vlan
argument_list|,
name|adapter
argument_list|,
name|EVENTHANDLER_PRI_FIRST
argument_list|)
expr_stmt|;
comment|/* 	** Check PCIE slot type/speed/width 	*/
name|ixgbe_get_slot_info
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Set an initial default flow control value */
name|adapter
operator|->
name|fc
operator|=
name|ixgbe_fc_full
expr_stmt|;
comment|/* let hardware know driver is loaded */
name|ctrl_ext
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CTRL_EXT
argument_list|)
expr_stmt|;
name|ctrl_ext
operator||=
name|IXGBE_CTRL_EXT_DRV_LOAD
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CTRL_EXT
argument_list|,
name|ctrl_ext
argument_list|)
expr_stmt|;
name|ixgbe_add_hw_stats
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|ixgbe_netmap_attach
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEV_NETMAP */
name|INIT_DEBUGOUT
argument_list|(
literal|"ixgbe_attach: end"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|err_late
label|:
name|ixgbe_free_transmit_structures
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixgbe_free_receive_structures
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|err_out
label|:
if|if
condition|(
name|adapter
operator|->
name|ifp
operator|!=
name|NULL
condition|)
name|if_free
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|ixgbe_free_pci_resources
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|adapter
operator|->
name|mta
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Device removal routine  *  *  The detach entry point is called when the driver is being removed.  *  This routine stops the adapter and deallocates all the resources  *  that were allocated for driver operation.  *  *  return 0 on success, positive on failure  *********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ix_queue
modifier|*
name|que
init|=
name|adapter
operator|->
name|queues
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
name|u32
name|ctrl_ext
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixgbe_detach: begin"
argument_list|)
expr_stmt|;
comment|/* Make sure VLANS are not using driver */
if|if
condition|(
name|adapter
operator|->
name|ifp
operator|->
name|if_vlantrunk
operator|!=
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Vlan in use, detach first\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|IXGBE_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixgbe_stop
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|IXGBE_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
operator|,
name|txr
operator|++
control|)
block|{
if|if
condition|(
name|que
operator|->
name|tq
condition|)
block|{
ifndef|#
directive|ifndef
name|IXGBE_LEGACY_TX
name|taskqueue_drain
argument_list|(
name|que
operator|->
name|tq
argument_list|,
operator|&
name|txr
operator|->
name|txq_task
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|taskqueue_drain
argument_list|(
name|que
operator|->
name|tq
argument_list|,
operator|&
name|que
operator|->
name|que_task
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|que
operator|->
name|tq
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Drain the Link queue */
if|if
condition|(
name|adapter
operator|->
name|tq
condition|)
block|{
name|taskqueue_drain
argument_list|(
name|adapter
operator|->
name|tq
argument_list|,
operator|&
name|adapter
operator|->
name|link_task
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|adapter
operator|->
name|tq
argument_list|,
operator|&
name|adapter
operator|->
name|mod_task
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|adapter
operator|->
name|tq
argument_list|,
operator|&
name|adapter
operator|->
name|msf_task
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IXGBE_FDIR
name|taskqueue_drain
argument_list|(
name|adapter
operator|->
name|tq
argument_list|,
operator|&
name|adapter
operator|->
name|fdir_task
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|taskqueue_free
argument_list|(
name|adapter
operator|->
name|tq
argument_list|)
expr_stmt|;
block|}
comment|/* let hardware know driver is unloading */
name|ctrl_ext
operator|=
name|IXGBE_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_CTRL_EXT
argument_list|)
expr_stmt|;
name|ctrl_ext
operator|&=
operator|~
name|IXGBE_CTRL_EXT_DRV_LOAD
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_CTRL_EXT
argument_list|,
name|ctrl_ext
argument_list|)
expr_stmt|;
comment|/* Unregister VLAN events */
if|if
condition|(
name|adapter
operator|->
name|vlan_attach
operator|!=
name|NULL
condition|)
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|vlan_config
argument_list|,
name|adapter
operator|->
name|vlan_attach
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|vlan_detach
operator|!=
name|NULL
condition|)
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|vlan_unconfig
argument_list|,
name|adapter
operator|->
name|vlan_detach
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|netmap_detach
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEV_NETMAP */
name|ixgbe_free_pci_resources
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|bus_generic_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|ixgbe_free_transmit_structures
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixgbe_free_receive_structures
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|adapter
operator|->
name|mta
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|IXGBE_CORE_LOCK_DESTROY
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Shutdown entry point  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|IXGBE_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixgbe_stop
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|IXGBE_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|IXGBE_LEGACY_TX
end_ifdef

begin_comment
comment|/*********************************************************************  *  Transmit entry point  *  *  ixgbe_start is called by the stack to initiate a transmit.  *  The driver will remain in this routine as long as there are  *  packets to transmit and transmit resources are available.  *  In case resources are not available stack is notified and  *  the packet is requeued.  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_start_locked
parameter_list|(
name|struct
name|tx_ring
modifier|*
name|txr
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_head
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|txr
operator|->
name|adapter
decl_stmt|;
name|IXGBE_TX_LOCK_ASSERT
argument_list|(
name|txr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
name|adapter
operator|->
name|link_active
condition|)
return|return;
while|while
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
block|{
if|if
condition|(
name|txr
operator|->
name|tx_avail
operator|<=
name|IXGBE_QUEUE_MIN_FREE
condition|)
break|break;
name|IFQ_DRV_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_head
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|ixgbe_xmit
argument_list|(
name|txr
argument_list|,
operator|&
name|m_head
argument_list|)
condition|)
block|{
if|if
condition|(
name|m_head
operator|!=
name|NULL
condition|)
name|IFQ_DRV_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Send a copy of the frame to the BPF listener */
name|ETHER_BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
comment|/* Set watchdog on */
name|txr
operator|->
name|watchdog_time
operator|=
name|ticks
expr_stmt|;
name|txr
operator|->
name|queue_status
operator|=
name|IXGBE_QUEUE_WORKING
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * Legacy TX start - called by the stack, this  * always uses the first tx ring, and should  * not be used with multiqueue tx enabled.  */
end_comment

begin_function
specifier|static
name|void
name|ixgbe_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|IXGBE_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|ixgbe_start_locked
argument_list|(
name|txr
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|IXGBE_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! IXGBE_LEGACY_TX */
end_comment

begin_comment
comment|/* ** Multiqueue Transmit driver ** */
end_comment

begin_function
specifier|static
name|int
name|ixgbe_mq_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ix_queue
modifier|*
name|que
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
comment|/* Which queue to use */
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_FLOWID
operator|)
operator|!=
literal|0
condition|)
name|i
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|%
name|adapter
operator|->
name|num_queues
expr_stmt|;
else|else
name|i
operator|=
name|curcpu
operator|%
name|adapter
operator|->
name|num_queues
expr_stmt|;
name|txr
operator|=
operator|&
name|adapter
operator|->
name|tx_rings
index|[
name|i
index|]
expr_stmt|;
name|que
operator|=
operator|&
name|adapter
operator|->
name|queues
index|[
name|i
index|]
expr_stmt|;
name|err
operator|=
name|drbr_enqueue
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|IXGBE_TX_TRYLOCK
argument_list|(
name|txr
argument_list|)
condition|)
block|{
name|ixgbe_mq_start_locked
argument_list|(
name|ifp
argument_list|,
name|txr
argument_list|)
expr_stmt|;
name|IXGBE_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
block|}
else|else
name|taskqueue_enqueue
argument_list|(
name|que
operator|->
name|tq
argument_list|,
operator|&
name|txr
operator|->
name|txq_task
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixgbe_mq_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|tx_ring
modifier|*
name|txr
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|txr
operator|->
name|adapter
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|next
decl_stmt|;
name|int
name|enqueued
init|=
literal|0
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
operator|)
operator|||
name|adapter
operator|->
name|link_active
operator|==
literal|0
condition|)
return|return
operator|(
name|ENETDOWN
operator|)
return|;
comment|/* Process the queue */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|901504
name|next
operator|=
name|drbr_dequeue
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|)
expr_stmt|;
while|while
condition|(
name|next
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|ixgbe_xmit
argument_list|(
name|txr
argument_list|,
operator|&
name|next
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|next
operator|!=
name|NULL
condition|)
name|err
operator|=
name|drbr_enqueue
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|,
name|next
argument_list|)
expr_stmt|;
else|#
directive|else
while|while
condition|(
operator|(
name|next
operator|=
name|drbr_peek
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|ixgbe_xmit
argument_list|(
name|txr
argument_list|,
operator|&
name|next
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
block|{
name|drbr_advance
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|drbr_putback
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|901504
name|drbr_advance
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|enqueued
operator|++
expr_stmt|;
comment|/* Send a copy of the frame to the BPF listener */
name|ETHER_BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
break|break;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|901504
name|next
operator|=
name|drbr_dequeue
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|enqueued
operator|>
literal|0
condition|)
block|{
comment|/* Set watchdog on */
name|txr
operator|->
name|queue_status
operator|=
name|IXGBE_QUEUE_WORKING
expr_stmt|;
name|txr
operator|->
name|watchdog_time
operator|=
name|ticks
expr_stmt|;
block|}
if|if
condition|(
name|txr
operator|->
name|tx_avail
operator|<
name|IXGBE_TX_CLEANUP_THRESHOLD
condition|)
name|ixgbe_txeof
argument_list|(
name|txr
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/*  * Called from a taskqueue to drain queued transmit packets.  */
specifier|static
name|void
name|ixgbe_deferred_mq_start
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|arg
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|txr
operator|->
name|adapter
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|IXGBE_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|drbr_empty
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|)
condition|)
name|ixgbe_mq_start_locked
argument_list|(
name|ifp
argument_list|,
name|txr
argument_list|)
expr_stmt|;
name|IXGBE_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
block|}
comment|/* ** Flush all ring buffers */
specifier|static
name|void
name|ixgbe_qflush
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|txr
operator|++
control|)
block|{
name|IXGBE_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|buf_ring_dequeue_sc
argument_list|(
name|txr
operator|->
name|br
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|IXGBE_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
block|}
name|if_qflush
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* IXGBE_LEGACY_TX */
comment|/*********************************************************************  *  Ioctl entry point  *  *  ixgbe_ioctl is called when the user wants to configure the  *  interface.  *  *  return 0 on success, positive on failure  **********************************************************************/
specifier|static
name|int
name|ixgbe_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
name|bool
name|avoid_reset
init|=
name|FALSE
decl_stmt|;
endif|#
directive|endif
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
name|avoid_reset
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
name|avoid_reset
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
comment|/* 		** Calling init results in link renegotiation, 		** so we avoid doing it when possible. 		*/
if|if
condition|(
name|avoid_reset
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
name|ixgbe_init
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_NOARP
operator|)
condition|)
name|arp_ifinit
argument_list|(
name|ifp
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|SIOCSIFMTU
case|:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl: SIOCSIFMTU (Set Interface MTU)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|>
name|IXGBE_MAX_FRAME_SIZE
operator|-
name|ETHER_HDR_LEN
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|IXGBE_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
name|adapter
operator|->
name|max_frame_size
operator|=
name|ifp
operator|->
name|if_mtu
operator|+
name|ETHER_HDR_LEN
operator|+
name|ETHER_CRC_LEN
expr_stmt|;
name|ixgbe_init_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|IXGBE_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFFLAGS
case|:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl: SIOCSIFFLAGS (Set Interface Flags)"
argument_list|)
expr_stmt|;
name|IXGBE_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|^
name|adapter
operator|->
name|if_flags
operator|)
operator|&
operator|(
name|IFF_PROMISC
operator||
name|IFF_ALLMULTI
operator|)
condition|)
block|{
name|ixgbe_set_promisc
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|ixgbe_init_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|ixgbe_stop
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|if_flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
name|IXGBE_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl: SIOC(ADD|DEL)MULTI"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|IXGBE_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixgbe_disable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixgbe_set_multi
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixgbe_enable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|IXGBE_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl: SIOCxIFMEDIA (Get/Set Interface Media)"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
block|{
name|int
name|mask
init|=
name|ifr
operator|->
name|ifr_reqcap
operator|^
name|ifp
operator|->
name|if_capenable
decl_stmt|;
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl: SIOCSIFCAP (Set Capabilities)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_HWCSUM
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_HWCSUM
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO4
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TSO4
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO6
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TSO6
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_LRO
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_LRO
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWTAGGING
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWTAGGING
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWFILTER
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWFILTER
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWTSO
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWTSO
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|IXGBE_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixgbe_init_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|IXGBE_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
name|VLAN_CAPABILITIES
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SIOCGI2C
case|:
block|{
name|struct
name|ixgbe_i2c_req
name|i2c
decl_stmt|;
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl: SIOCGI2C (Get I2C Data)"
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|ifr
operator|->
name|ifr_data
argument_list|,
operator|&
name|i2c
argument_list|,
sizeof|sizeof
argument_list|(
name|i2c
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
operator|(
name|i2c
operator|.
name|dev_addr
operator|!=
literal|0xA0
operator|)
operator|||
operator|(
name|i2c
operator|.
name|dev_addr
operator|!=
literal|0xA2
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_i2c_byte
argument_list|(
name|hw
argument_list|,
name|i2c
operator|.
name|offset
argument_list|,
name|i2c
operator|.
name|dev_addr
argument_list|,
name|i2c
operator|.
name|data
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|i2c
argument_list|,
name|ifr
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|i2c
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|IOCTL_DEBUGOUT1
argument_list|(
literal|"ioctl: UNKNOWN (0x%X)\n"
argument_list|,
operator|(
name|int
operator|)
name|command
argument_list|)
expr_stmt|;
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/*********************************************************************  *  Init entry point  *  *  This routine is used in two ways. It is used by the stack as  *  init entry point in network interface structure. It is also used  *  by the driver as a hw/sw initialization routine to get to a  *  consistent state.  *  *  return 0 on success, positive on failure  **********************************************************************/
define|#
directive|define
name|IXGBE_MHADD_MFS_SHIFT
value|16
specifier|static
name|void
name|ixgbe_init_locked
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|u32
name|k
decl_stmt|,
name|txdctl
decl_stmt|,
name|mhadd
decl_stmt|,
name|gpie
decl_stmt|;
name|u32
name|rxdctl
decl_stmt|,
name|rxctrl
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|adapter
operator|->
name|core_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixgbe_init_locked: begin"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|adapter_stopped
operator|=
name|FALSE
expr_stmt|;
name|ixgbe_stop_adapter
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|)
expr_stmt|;
comment|/* reprogram the RAR[0] in case user changed it. */
name|ixgbe_set_rar
argument_list|(
name|hw
argument_list|,
literal|0
argument_list|,
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|addr
argument_list|,
literal|0
argument_list|,
name|IXGBE_RAH_AV
argument_list|)
expr_stmt|;
comment|/* Get the latest mac address, User can use a LAA */
name|bcopy
argument_list|(
name|IF_LLADDR
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|)
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|,
name|IXGBE_ETH_LENGTH_OF_ADDRESS
argument_list|)
expr_stmt|;
name|ixgbe_set_rar
argument_list|(
name|hw
argument_list|,
literal|0
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hw
operator|->
name|addr_ctrl
operator|.
name|rar_used_count
operator|=
literal|1
expr_stmt|;
comment|/* Set the various hardware offload abilities */
name|ifp
operator|->
name|if_hwassist
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
name|CSUM_TSO
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM
condition|)
block|{
name|ifp
operator|->
name|if_hwassist
operator||=
operator|(
name|CSUM_TCP
operator||
name|CSUM_UDP
operator|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800000
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|!=
name|ixgbe_mac_82598EB
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
name|CSUM_SCTP
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Prepare transmit descriptors and buffers */
if|if
condition|(
name|ixgbe_setup_transmit_structures
argument_list|(
name|adapter
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not setup transmit structures\n"
argument_list|)
expr_stmt|;
name|ixgbe_stop
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return;
block|}
name|ixgbe_init_hw
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|ixgbe_initialize_transmit_units
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Setup Multicast table */
name|ixgbe_set_multi
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* 	** Determine the correct mbuf pool 	** for doing jumbo frames 	*/
if|if
condition|(
name|adapter
operator|->
name|max_frame_size
operator|<=
literal|2048
condition|)
name|adapter
operator|->
name|rx_mbuf_sz
operator|=
name|MCLBYTES
expr_stmt|;
elseif|else
if|if
condition|(
name|adapter
operator|->
name|max_frame_size
operator|<=
literal|4096
condition|)
name|adapter
operator|->
name|rx_mbuf_sz
operator|=
name|MJUMPAGESIZE
expr_stmt|;
elseif|else
if|if
condition|(
name|adapter
operator|->
name|max_frame_size
operator|<=
literal|9216
condition|)
name|adapter
operator|->
name|rx_mbuf_sz
operator|=
name|MJUM9BYTES
expr_stmt|;
else|else
name|adapter
operator|->
name|rx_mbuf_sz
operator|=
name|MJUM16BYTES
expr_stmt|;
comment|/* Prepare receive descriptors and buffers */
if|if
condition|(
name|ixgbe_setup_receive_structures
argument_list|(
name|adapter
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not setup receive structures\n"
argument_list|)
expr_stmt|;
name|ixgbe_stop
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Configure RX settings */
name|ixgbe_initialize_receive_units
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|gpie
operator|=
name|IXGBE_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_GPIE
argument_list|)
expr_stmt|;
comment|/* Enable Fan Failure Interrupt */
name|gpie
operator||=
name|IXGBE_SDP1_GPIEN
expr_stmt|;
comment|/* Add for Module detection */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_82599EB
condition|)
name|gpie
operator||=
name|IXGBE_SDP2_GPIEN
expr_stmt|;
comment|/* Thermal Failure Detection */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_X540
condition|)
name|gpie
operator||=
name|IXGBE_SDP0_GPIEN
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|msix
operator|>
literal|1
condition|)
block|{
comment|/* Enable Enhanced MSIX mode */
name|gpie
operator||=
name|IXGBE_GPIE_MSIX_MODE
expr_stmt|;
name|gpie
operator||=
name|IXGBE_GPIE_EIAME
operator||
name|IXGBE_GPIE_PBA_SUPPORT
operator||
name|IXGBE_GPIE_OCD
expr_stmt|;
block|}
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GPIE
argument_list|,
name|gpie
argument_list|)
expr_stmt|;
comment|/* Set MTU size */
if|if
condition|(
name|ifp
operator|->
name|if_mtu
operator|>
name|ETHERMTU
condition|)
block|{
name|mhadd
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MHADD
argument_list|)
expr_stmt|;
name|mhadd
operator|&=
operator|~
name|IXGBE_MHADD_MFS_MASK
expr_stmt|;
name|mhadd
operator||=
name|adapter
operator|->
name|max_frame_size
operator|<<
name|IXGBE_MHADD_MFS_SHIFT
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MHADD
argument_list|,
name|mhadd
argument_list|)
expr_stmt|;
block|}
comment|/* Now enable all the queues */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|txdctl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_TXDCTL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|txdctl
operator||=
name|IXGBE_TXDCTL_ENABLE
expr_stmt|;
comment|/* Set WTHRESH to 8, burst writeback */
name|txdctl
operator||=
operator|(
literal|8
operator|<<
literal|16
operator|)
expr_stmt|;
comment|/* 		 * When the internal queue falls below PTHRESH (32), 		 * start prefetching as long as there are at least 		 * HTHRESH (1) buffers ready. The values are taken 		 * from the Intel linux driver 3.8.21. 		 * Prefetching enables tx line rate even with 1 queue. 		 */
name|txdctl
operator||=
operator|(
literal|32
operator|<<
literal|0
operator|)
operator||
operator|(
literal|1
operator|<<
literal|8
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_TXDCTL
argument_list|(
name|i
argument_list|)
argument_list|,
name|txdctl
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|rxdctl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXDCTL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_82598EB
condition|)
block|{
comment|/* 			** PTHRESH = 21 			** HTHRESH = 4 			** WTHRESH = 8 			*/
name|rxdctl
operator|&=
operator|~
literal|0x3FFFFF
expr_stmt|;
name|rxdctl
operator||=
literal|0x080420
expr_stmt|;
block|}
name|rxdctl
operator||=
name|IXGBE_RXDCTL_ENABLE
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXDCTL
argument_list|(
name|i
argument_list|)
argument_list|,
name|rxdctl
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|10
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXDCTL
argument_list|(
name|i
argument_list|)
argument_list|)
operator|&
name|IXGBE_RXDCTL_ENABLE
condition|)
break|break;
else|else
name|msec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|wmb
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
comment|/* 		 * In netmap mode, we must preserve the buffers made 		 * available to userspace before the if_init() 		 * (this is true by default on the TX side, because 		 * init makes all buffers available to userspace). 		 * 		 * netmap_reset() and the device specific routines 		 * (e.g. ixgbe_setup_receive_rings()) map these 		 * buffers at the end of the NIC ring, so here we 		 * must set the RDT (tail) register to make sure 		 * they are not overwritten. 		 * 		 * In this driver the NIC ring starts at RDH = 0, 		 * RDT points to the last slot available for reception (?), 		 * so RDT = num_rx_desc - 1 means the whole ring is available. 		 */
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_NETMAP
condition|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
decl_stmt|;
name|int
name|t
init|=
name|na
operator|->
name|num_rx_desc
operator|-
literal|1
operator|-
name|nm_kr_rxspace
argument_list|(
name|kring
argument_list|)
decl_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RDT
argument_list|(
name|i
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* DEV_NETMAP */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RDT
argument_list|(
name|i
argument_list|)
argument_list|,
name|adapter
operator|->
name|num_rx_desc
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Enable Receive engine */
name|rxctrl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXCTRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_82598EB
condition|)
name|rxctrl
operator||=
name|IXGBE_RXCTRL_DMBYPS
expr_stmt|;
name|rxctrl
operator||=
name|IXGBE_RXCTRL_RXEN
expr_stmt|;
name|ixgbe_enable_rx_dma
argument_list|(
name|hw
argument_list|,
name|rxctrl
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|,
name|hz
argument_list|,
name|ixgbe_local_timer
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
comment|/* Set up MSI/X routing */
if|if
condition|(
name|ixgbe_enable_msix
condition|)
block|{
name|ixgbe_configure_ivars
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Set up auto-mask */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_82598EB
condition|)
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EIAM
argument_list|,
name|IXGBE_EICS_RTX_QUEUE
argument_list|)
expr_stmt|;
else|else
block|{
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EIAM_EX
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EIAM_EX
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Simple settings for Legacy/MSI */
name|ixgbe_set_ivar
argument_list|(
name|adapter
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ixgbe_set_ivar
argument_list|(
name|adapter
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EIAM
argument_list|,
name|IXGBE_EICS_RTX_QUEUE
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IXGBE_FDIR
comment|/* Init Flow director */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|!=
name|ixgbe_mac_82598EB
condition|)
block|{
name|u32
name|hdrm
init|=
literal|32
operator|<<
name|fdir_pballoc
decl_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|setup_rxpba
argument_list|(
name|hw
argument_list|,
literal|0
argument_list|,
name|hdrm
argument_list|,
name|PBA_STRATEGY_EQUAL
argument_list|)
expr_stmt|;
name|ixgbe_init_fdir_signature_82599
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|fdir_pballoc
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	** Check on any SFP devices that 	** need to be kick-started 	*/
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|ixgbe_phy_none
condition|)
block|{
name|int
name|err
init|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|identify
argument_list|(
name|hw
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|==
name|IXGBE_ERR_SFP_NOT_SUPPORTED
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unsupported SFP+ module type was detected.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Set moderation on the Link interrupt */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EITR
argument_list|(
name|adapter
operator|->
name|linkvec
argument_list|)
argument_list|,
name|IXGBE_LINK_ITR
argument_list|)
expr_stmt|;
comment|/* Config/Enable Link */
name|ixgbe_config_link
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Hardware Packet Buffer& Flow Control setup */
block|{
name|u32
name|rxpb
decl_stmt|,
name|frame
decl_stmt|,
name|size
decl_stmt|,
name|tmp
decl_stmt|;
name|frame
operator|=
name|adapter
operator|->
name|max_frame_size
expr_stmt|;
comment|/* Calculate High Water */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_X540
condition|)
name|tmp
operator|=
name|IXGBE_DV_X540
argument_list|(
name|frame
argument_list|,
name|frame
argument_list|)
expr_stmt|;
else|else
name|tmp
operator|=
name|IXGBE_DV
argument_list|(
name|frame
argument_list|,
name|frame
argument_list|)
expr_stmt|;
name|size
operator|=
name|IXGBE_BT2KB
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|rxpb
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXPBSIZE
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|>>
literal|10
expr_stmt|;
name|hw
operator|->
name|fc
operator|.
name|high_water
index|[
literal|0
index|]
operator|=
name|rxpb
operator|-
name|size
expr_stmt|;
comment|/* Now calculate Low Water */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_X540
condition|)
name|tmp
operator|=
name|IXGBE_LOW_DV_X540
argument_list|(
name|frame
argument_list|)
expr_stmt|;
else|else
name|tmp
operator|=
name|IXGBE_LOW_DV
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|hw
operator|->
name|fc
operator|.
name|low_water
index|[
literal|0
index|]
operator|=
name|IXGBE_BT2KB
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|hw
operator|->
name|fc
operator|.
name|requested_mode
operator|=
name|adapter
operator|->
name|fc
expr_stmt|;
name|hw
operator|->
name|fc
operator|.
name|pause_time
operator|=
name|IXGBE_FC_PAUSE
expr_stmt|;
name|hw
operator|->
name|fc
operator|.
name|send_xon
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Initialize the FC settings */
name|ixgbe_start_hw
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Set up VLAN support and filter */
name|ixgbe_setup_vlan_hw_support
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* And now turn on interrupts */
name|ixgbe_enable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Now inform the stack we're ready */
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
return|return;
block|}
specifier|static
name|void
name|ixgbe_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|arg
decl_stmt|;
name|IXGBE_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixgbe_init_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|IXGBE_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* ** ** MSIX Interrupt Handlers and Tasklets ** */
specifier|static
specifier|inline
name|void
name|ixgbe_enable_queue
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|u32
name|vector
parameter_list|)
block|{
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|u64
name|queue
init|=
call|(
name|u64
call|)
argument_list|(
literal|1
operator|<<
name|vector
argument_list|)
decl_stmt|;
name|u32
name|mask
decl_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_82598EB
condition|)
block|{
name|mask
operator|=
operator|(
name|IXGBE_EIMS_RTX_QUEUE
operator|&
name|queue
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EIMS
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mask
operator|=
operator|(
name|queue
operator|&
literal|0xFFFFFFFF
operator|)
expr_stmt|;
if|if
condition|(
name|mask
condition|)
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EIMS_EX
argument_list|(
literal|0
argument_list|)
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|mask
operator|=
operator|(
name|queue
operator|>>
literal|32
operator|)
expr_stmt|;
if|if
condition|(
name|mask
condition|)
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EIMS_EX
argument_list|(
literal|1
argument_list|)
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
block|}
specifier|static
specifier|inline
name|void
name|ixgbe_disable_queue
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|u32
name|vector
parameter_list|)
block|{
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|u64
name|queue
init|=
call|(
name|u64
call|)
argument_list|(
literal|1
operator|<<
name|vector
argument_list|)
decl_stmt|;
name|u32
name|mask
decl_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_82598EB
condition|)
block|{
name|mask
operator|=
operator|(
name|IXGBE_EIMS_RTX_QUEUE
operator|&
name|queue
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EIMC
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mask
operator|=
operator|(
name|queue
operator|&
literal|0xFFFFFFFF
operator|)
expr_stmt|;
if|if
condition|(
name|mask
condition|)
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EIMC_EX
argument_list|(
literal|0
argument_list|)
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|mask
operator|=
operator|(
name|queue
operator|>>
literal|32
operator|)
expr_stmt|;
if|if
condition|(
name|mask
condition|)
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EIMC_EX
argument_list|(
literal|1
argument_list|)
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
block|}
specifier|static
name|void
name|ixgbe_handle_que
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|ix_queue
modifier|*
name|que
init|=
name|context
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|que
operator|->
name|adapter
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|que
operator|->
name|txr
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|bool
name|more
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|more
operator|=
name|ixgbe_rxeof
argument_list|(
name|que
argument_list|)
expr_stmt|;
name|IXGBE_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|ixgbe_txeof
argument_list|(
name|txr
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|IXGBE_LEGACY_TX
if|if
condition|(
operator|!
name|drbr_empty
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|)
condition|)
name|ixgbe_mq_start_locked
argument_list|(
name|ifp
argument_list|,
name|txr
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
name|ixgbe_start_locked
argument_list|(
name|txr
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|IXGBE_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
block|}
comment|/* Reenable this interrupt */
if|if
condition|(
name|que
operator|->
name|res
operator|!=
name|NULL
condition|)
name|ixgbe_enable_queue
argument_list|(
name|adapter
argument_list|,
name|que
operator|->
name|msix
argument_list|)
expr_stmt|;
else|else
name|ixgbe_enable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*********************************************************************  *  *  Legacy Interrupt Service routine  *  **********************************************************************/
specifier|static
name|void
name|ixgbe_legacy_irq
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ix_queue
modifier|*
name|que
init|=
name|arg
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|que
operator|->
name|adapter
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
name|bool
name|more
decl_stmt|;
name|u32
name|reg_eicr
decl_stmt|;
name|reg_eicr
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EICR
argument_list|)
expr_stmt|;
operator|++
name|que
operator|->
name|irqs
expr_stmt|;
if|if
condition|(
name|reg_eicr
operator|==
literal|0
condition|)
block|{
name|ixgbe_enable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return;
block|}
name|more
operator|=
name|ixgbe_rxeof
argument_list|(
name|que
argument_list|)
expr_stmt|;
name|IXGBE_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|ixgbe_txeof
argument_list|(
name|txr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IXGBE_LEGACY_TX
if|if
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
name|ixgbe_start_locked
argument_list|(
name|txr
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|drbr_empty
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|)
condition|)
name|ixgbe_mq_start_locked
argument_list|(
name|ifp
argument_list|,
name|txr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|IXGBE_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
comment|/* Check for fan failure */
if|if
condition|(
operator|(
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|==
name|ixgbe_media_type_copper
operator|)
operator|&&
operator|(
name|reg_eicr
operator|&
name|IXGBE_EICR_GPI_SDP1
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"\nCRITICAL: FAN FAILURE!! "
literal|"REPLACE IMMEDIATELY!!\n"
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EIMS
argument_list|,
name|IXGBE_EICR_GPI_SDP1
argument_list|)
expr_stmt|;
block|}
comment|/* Link status change */
if|if
condition|(
name|reg_eicr
operator|&
name|IXGBE_EICR_LSC
condition|)
name|taskqueue_enqueue
argument_list|(
name|adapter
operator|->
name|tq
argument_list|,
operator|&
name|adapter
operator|->
name|link_task
argument_list|)
expr_stmt|;
if|if
condition|(
name|more
condition|)
name|taskqueue_enqueue
argument_list|(
name|que
operator|->
name|tq
argument_list|,
operator|&
name|que
operator|->
name|que_task
argument_list|)
expr_stmt|;
else|else
name|ixgbe_enable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*********************************************************************  *  *  MSIX Queue Interrupt Service routine  *  **********************************************************************/
name|void
name|ixgbe_msix_que
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ix_queue
modifier|*
name|que
init|=
name|arg
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|que
operator|->
name|adapter
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|que
operator|->
name|txr
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
name|que
operator|->
name|rxr
decl_stmt|;
name|bool
name|more
decl_stmt|;
name|u32
name|newitr
init|=
literal|0
decl_stmt|;
comment|/* Protect against spurious interrupts */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return;
name|ixgbe_disable_queue
argument_list|(
name|adapter
argument_list|,
name|que
operator|->
name|msix
argument_list|)
expr_stmt|;
operator|++
name|que
operator|->
name|irqs
expr_stmt|;
name|more
operator|=
name|ixgbe_rxeof
argument_list|(
name|que
argument_list|)
expr_stmt|;
name|IXGBE_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|ixgbe_txeof
argument_list|(
name|txr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IXGBE_LEGACY_TX
if|if
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
name|ixgbe_start_locked
argument_list|(
name|txr
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|drbr_empty
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|)
condition|)
name|ixgbe_mq_start_locked
argument_list|(
name|ifp
argument_list|,
name|txr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|IXGBE_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
comment|/* Do AIM now? */
if|if
condition|(
name|ixgbe_enable_aim
operator|==
name|FALSE
condition|)
goto|goto
name|no_calc
goto|;
comment|/* 	** Do Adaptive Interrupt Moderation:         **  - Write out last calculated setting 	**  - Calculate based on average size over 	**    the last interval. 	*/
if|if
condition|(
name|que
operator|->
name|eitr_setting
condition|)
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_EITR
argument_list|(
name|que
operator|->
name|msix
argument_list|)
argument_list|,
name|que
operator|->
name|eitr_setting
argument_list|)
expr_stmt|;
name|que
operator|->
name|eitr_setting
operator|=
literal|0
expr_stmt|;
comment|/* Idle, do nothing */
if|if
condition|(
operator|(
name|txr
operator|->
name|bytes
operator|==
literal|0
operator|)
operator|&&
operator|(
name|rxr
operator|->
name|bytes
operator|==
literal|0
operator|)
condition|)
goto|goto
name|no_calc
goto|;
if|if
condition|(
operator|(
name|txr
operator|->
name|bytes
operator|)
operator|&&
operator|(
name|txr
operator|->
name|packets
operator|)
condition|)
name|newitr
operator|=
name|txr
operator|->
name|bytes
operator|/
name|txr
operator|->
name|packets
expr_stmt|;
if|if
condition|(
operator|(
name|rxr
operator|->
name|bytes
operator|)
operator|&&
operator|(
name|rxr
operator|->
name|packets
operator|)
condition|)
name|newitr
operator|=
name|max
argument_list|(
name|newitr
argument_list|,
operator|(
name|rxr
operator|->
name|bytes
operator|/
name|rxr
operator|->
name|packets
operator|)
argument_list|)
expr_stmt|;
name|newitr
operator|+=
literal|24
expr_stmt|;
comment|/* account for hardware frame, crc */
comment|/* set an upper boundary */
name|newitr
operator|=
name|min
argument_list|(
name|newitr
argument_list|,
literal|3000
argument_list|)
expr_stmt|;
comment|/* Be nice to the mid range */
if|if
condition|(
operator|(
name|newitr
operator|>
literal|300
operator|)
operator|&&
operator|(
name|newitr
operator|<
literal|1200
operator|)
condition|)
name|newitr
operator|=
operator|(
name|newitr
operator|/
literal|3
operator|)
expr_stmt|;
else|else
name|newitr
operator|=
operator|(
name|newitr
operator|/
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_82598EB
condition|)
name|newitr
operator||=
name|newitr
operator|<<
literal|16
expr_stmt|;
else|else
name|newitr
operator||=
name|IXGBE_EITR_CNT_WDIS
expr_stmt|;
comment|/* save for next interrupt */
name|que
operator|->
name|eitr_setting
operator|=
name|newitr
expr_stmt|;
comment|/* Reset state */
name|txr
operator|->
name|bytes
operator|=
literal|0
expr_stmt|;
name|txr
operator|->
name|packets
operator|=
literal|0
expr_stmt|;
name|rxr
operator|->
name|bytes
operator|=
literal|0
expr_stmt|;
name|rxr
operator|->
name|packets
operator|=
literal|0
expr_stmt|;
name|no_calc
label|:
if|if
condition|(
name|more
condition|)
name|taskqueue_enqueue
argument_list|(
name|que
operator|->
name|tq
argument_list|,
operator|&
name|que
operator|->
name|que_task
argument_list|)
expr_stmt|;
else|else
name|ixgbe_enable_queue
argument_list|(
name|adapter
argument_list|,
name|que
operator|->
name|msix
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|static
name|void
name|ixgbe_msix_link
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|arg
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|u32
name|reg_eicr
decl_stmt|;
operator|++
name|adapter
operator|->
name|link_irq
expr_stmt|;
comment|/* First get the cause */
name|reg_eicr
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EICS
argument_list|)
expr_stmt|;
comment|/* Be sure the queue bits are not cleared */
name|reg_eicr
operator|&=
operator|~
name|IXGBE_EICR_RTX_QUEUE
expr_stmt|;
comment|/* Clear interrupt with write */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EICR
argument_list|,
name|reg_eicr
argument_list|)
expr_stmt|;
comment|/* Link status change */
if|if
condition|(
name|reg_eicr
operator|&
name|IXGBE_EICR_LSC
condition|)
name|taskqueue_enqueue
argument_list|(
name|adapter
operator|->
name|tq
argument_list|,
operator|&
name|adapter
operator|->
name|link_task
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|!=
name|ixgbe_mac_82598EB
condition|)
block|{
ifdef|#
directive|ifdef
name|IXGBE_FDIR
if|if
condition|(
name|reg_eicr
operator|&
name|IXGBE_EICR_FLOW_DIR
condition|)
block|{
comment|/* This is probably overkill :) */
if|if
condition|(
operator|!
name|atomic_cmpset_int
argument_list|(
operator|&
name|adapter
operator|->
name|fdir_reinit
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
return|return;
comment|/* Disable the interrupt */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EIMC
argument_list|,
name|IXGBE_EICR_FLOW_DIR
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|adapter
operator|->
name|tq
argument_list|,
operator|&
name|adapter
operator|->
name|fdir_task
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|reg_eicr
operator|&
name|IXGBE_EICR_ECC
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"\nCRITICAL: ECC ERROR!! "
literal|"Please Reboot!!\n"
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EICR
argument_list|,
name|IXGBE_EICR_ECC
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reg_eicr
operator|&
name|IXGBE_EICR_GPI_SDP1
condition|)
block|{
comment|/* Clear the interrupt */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EICR
argument_list|,
name|IXGBE_EICR_GPI_SDP1
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|adapter
operator|->
name|tq
argument_list|,
operator|&
name|adapter
operator|->
name|msf_task
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reg_eicr
operator|&
name|IXGBE_EICR_GPI_SDP2
condition|)
block|{
comment|/* Clear the interrupt */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EICR
argument_list|,
name|IXGBE_EICR_GPI_SDP2
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|adapter
operator|->
name|tq
argument_list|,
operator|&
name|adapter
operator|->
name|mod_task
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Check for fan failure */
if|if
condition|(
operator|(
name|hw
operator|->
name|device_id
operator|==
name|IXGBE_DEV_ID_82598AT
operator|)
operator|&&
operator|(
name|reg_eicr
operator|&
name|IXGBE_EICR_GPI_SDP1
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"\nCRITICAL: FAN FAILURE!! "
literal|"REPLACE IMMEDIATELY!!\n"
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EICR
argument_list|,
name|IXGBE_EICR_GPI_SDP1
argument_list|)
expr_stmt|;
block|}
comment|/* Check for over temp condition */
if|if
condition|(
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_X540
operator|)
operator|&&
operator|(
name|reg_eicr
operator|&
name|IXGBE_EICR_TS
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"\nCRITICAL: OVER TEMP!! "
literal|"PHY IS SHUT DOWN!!\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"System shutdown required\n"
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EICR
argument_list|,
name|IXGBE_EICR_TS
argument_list|)
expr_stmt|;
block|}
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_EIMS
argument_list|,
name|IXGBE_EIMS_OTHER
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*********************************************************************  *  *  Media Ioctl callback  *  *  This routine is called whenever the user queries the status of  *  the interface using ifconfig.  *  **********************************************************************/
specifier|static
name|void
name|ixgbe_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixgbe_media_status: begin"
argument_list|)
expr_stmt|;
name|IXGBE_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixgbe_update_link_status
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
expr_stmt|;
if|if
condition|(
operator|!
name|adapter
operator|->
name|link_active
condition|)
block|{
name|IXGBE_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return;
block|}
name|ifmr
operator|->
name|ifm_status
operator||=
name|IFM_ACTIVE
expr_stmt|;
switch|switch
condition|(
name|adapter
operator|->
name|link_speed
condition|)
block|{
case|case
name|IXGBE_LINK_SPEED_100_FULL
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_100_TX
operator||
name|IFM_FDX
expr_stmt|;
break|break;
case|case
name|IXGBE_LINK_SPEED_1GB_FULL
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_1000_SX
operator||
name|IFM_FDX
expr_stmt|;
break|break;
case|case
name|IXGBE_LINK_SPEED_10GB_FULL
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|adapter
operator|->
name|optics
operator||
name|IFM_FDX
expr_stmt|;
break|break;
block|}
name|IXGBE_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*********************************************************************  *  *  Media Ioctl callback  *  *  This routine is called when the user changes speed/duplex using  *  media/mediopt option with ifconfig.  *  **********************************************************************/
specifier|static
name|int
name|ixgbe_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifmedia
modifier|*
name|ifm
init|=
operator|&
name|adapter
operator|->
name|media
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixgbe_media_change: begin"
argument_list|)
expr_stmt|;
if|if
condition|(
name|IFM_TYPE
argument_list|(
name|ifm
operator|->
name|ifm_media
argument_list|)
operator|!=
name|IFM_ETHER
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
switch|switch
condition|(
name|IFM_SUBTYPE
argument_list|(
name|ifm
operator|->
name|ifm_media
argument_list|)
condition|)
block|{
case|case
name|IFM_AUTO
case|:
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|autoneg_advertised
operator|=
name|IXGBE_LINK_SPEED_100_FULL
operator||
name|IXGBE_LINK_SPEED_1GB_FULL
operator||
name|IXGBE_LINK_SPEED_10GB_FULL
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"Only auto media type\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*********************************************************************  *  *  This routine maps the mbufs to tx descriptors, allowing the  *  TX engine to transmit the packets.   *  	- return 0 on success, positive on failure  *  **********************************************************************/
specifier|static
name|int
name|ixgbe_xmit
parameter_list|(
name|struct
name|tx_ring
modifier|*
name|txr
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m_headp
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|txr
operator|->
name|adapter
decl_stmt|;
name|u32
name|olinfo_status
init|=
literal|0
decl_stmt|,
name|cmd_type_len
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|error
decl_stmt|,
name|nsegs
decl_stmt|;
name|int
name|first
decl_stmt|;
name|bool
name|remap
init|=
name|TRUE
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_head
decl_stmt|;
name|bus_dma_segment_t
name|segs
index|[
name|adapter
operator|->
name|num_segs
index|]
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
name|struct
name|ixgbe_tx_buf
modifier|*
name|txbuf
decl_stmt|;
name|union
name|ixgbe_adv_tx_desc
modifier|*
name|txd
init|=
name|NULL
decl_stmt|;
name|m_head
operator|=
operator|*
name|m_headp
expr_stmt|;
comment|/* Basic descriptor defines */
name|cmd_type_len
operator|=
operator|(
name|IXGBE_ADVTXD_DTYP_DATA
operator||
name|IXGBE_ADVTXD_DCMD_IFCS
operator||
name|IXGBE_ADVTXD_DCMD_DEXT
operator|)
expr_stmt|;
if|if
condition|(
name|m_head
operator|->
name|m_flags
operator|&
name|M_VLANTAG
condition|)
name|cmd_type_len
operator||=
name|IXGBE_ADVTXD_DCMD_VLE
expr_stmt|;
comment|/*          * Important to capture the first descriptor          * used because it will contain the index of          * the one we tell the hardware to report back          */
name|first
operator|=
name|txr
operator|->
name|next_avail_desc
expr_stmt|;
name|txbuf
operator|=
operator|&
name|txr
operator|->
name|tx_buffers
index|[
name|first
index|]
expr_stmt|;
name|map
operator|=
name|txbuf
operator|->
name|map
expr_stmt|;
comment|/* 	 * Map the packet for DMA. 	 */
name|retry
label|:
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|map
argument_list|,
operator|*
name|m_headp
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|error
argument_list|)
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
switch|switch
condition|(
name|error
condition|)
block|{
case|case
name|EFBIG
case|:
comment|/* Try it again? - one try */
if|if
condition|(
name|remap
operator|==
name|TRUE
condition|)
block|{
name|remap
operator|=
name|FALSE
expr_stmt|;
name|m
operator|=
name|m_defrag
argument_list|(
operator|*
name|m_headp
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|adapter
operator|->
name|mbuf_defrag_failed
operator|++
expr_stmt|;
name|m_freem
argument_list|(
operator|*
name|m_headp
argument_list|)
expr_stmt|;
operator|*
name|m_headp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
operator|*
name|m_headp
operator|=
name|m
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
else|else
return|return
operator|(
name|error
operator|)
return|;
case|case
name|ENOMEM
case|:
name|txr
operator|->
name|no_tx_dma_setup
operator|++
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
default|default:
name|txr
operator|->
name|no_tx_dma_setup
operator|++
expr_stmt|;
name|m_freem
argument_list|(
operator|*
name|m_headp
argument_list|)
expr_stmt|;
operator|*
name|m_headp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* Make certain there are enough descriptors */
if|if
condition|(
name|nsegs
operator|>
name|txr
operator|->
name|tx_avail
operator|-
literal|2
condition|)
block|{
name|txr
operator|->
name|no_desc_avail
operator|++
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|m_head
operator|=
operator|*
name|m_headp
expr_stmt|;
comment|/* 	** Set up the appropriate offload context 	** this will consume the first descriptor 	*/
name|error
operator|=
name|ixgbe_tx_ctx_setup
argument_list|(
name|txr
argument_list|,
name|m_head
argument_list|,
operator|&
name|cmd_type_len
argument_list|,
operator|&
name|olinfo_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|error
argument_list|)
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|ENOBUFS
condition|)
operator|*
name|m_headp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|IXGBE_FDIR
comment|/* Do the flow director magic */
if|if
condition|(
operator|(
name|txr
operator|->
name|atr_sample
operator|)
operator|&&
operator|(
operator|!
name|adapter
operator|->
name|fdir_reinit
operator|)
condition|)
block|{
operator|++
name|txr
operator|->
name|atr_count
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|atr_count
operator|>=
name|atr_sample_rate
condition|)
block|{
name|ixgbe_atr
argument_list|(
name|txr
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
name|txr
operator|->
name|atr_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|i
operator|=
name|txr
operator|->
name|next_avail_desc
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nsegs
condition|;
name|j
operator|++
control|)
block|{
name|bus_size_t
name|seglen
decl_stmt|;
name|bus_addr_t
name|segaddr
decl_stmt|;
name|txbuf
operator|=
operator|&
name|txr
operator|->
name|tx_buffers
index|[
name|i
index|]
expr_stmt|;
name|txd
operator|=
operator|&
name|txr
operator|->
name|tx_base
index|[
name|i
index|]
expr_stmt|;
name|seglen
operator|=
name|segs
index|[
name|j
index|]
operator|.
name|ds_len
expr_stmt|;
name|segaddr
operator|=
name|htole64
argument_list|(
name|segs
index|[
name|j
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|txd
operator|->
name|read
operator|.
name|buffer_addr
operator|=
name|segaddr
expr_stmt|;
name|txd
operator|->
name|read
operator|.
name|cmd_type_len
operator|=
name|htole32
argument_list|(
name|txr
operator|->
name|txd_cmd
operator||
name|cmd_type_len
operator||
name|seglen
argument_list|)
expr_stmt|;
name|txd
operator|->
name|read
operator|.
name|olinfo_status
operator|=
name|htole32
argument_list|(
name|olinfo_status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|==
name|txr
operator|->
name|num_desc
condition|)
name|i
operator|=
literal|0
expr_stmt|;
block|}
name|txd
operator|->
name|read
operator|.
name|cmd_type_len
operator||=
name|htole32
argument_list|(
name|IXGBE_TXD_CMD_EOP
operator||
name|IXGBE_TXD_CMD_RS
argument_list|)
expr_stmt|;
name|txr
operator|->
name|tx_avail
operator|-=
name|nsegs
expr_stmt|;
name|txr
operator|->
name|next_avail_desc
operator|=
name|i
expr_stmt|;
name|txbuf
operator|->
name|m_head
operator|=
name|m_head
expr_stmt|;
comment|/* 	** Here we swap the map so the last descriptor, 	** which gets the completion interrupt has the 	** real map, and the first descriptor gets the 	** unused map from this descriptor. 	*/
name|txr
operator|->
name|tx_buffers
index|[
name|first
index|]
operator|.
name|map
operator|=
name|txbuf
operator|->
name|map
expr_stmt|;
name|txbuf
operator|->
name|map
operator|=
name|map
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* Set the EOP descriptor that will be marked done */
name|txbuf
operator|=
operator|&
name|txr
operator|->
name|tx_buffers
index|[
name|first
index|]
expr_stmt|;
name|txbuf
operator|->
name|eop
operator|=
name|txd
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|txdma
operator|.
name|dma_tag
argument_list|,
name|txr
operator|->
name|txdma
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* 	 * Advance the Transmit Descriptor Tail (Tdt), this tells the 	 * hardware that this frame is available to transmit. 	 */
operator|++
name|txr
operator|->
name|total_packets
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_TDT
argument_list|(
name|txr
operator|->
name|me
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|void
name|ixgbe_set_promisc
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|u_int32_t
name|reg_rctl
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|int
name|mcnt
init|=
literal|0
decl_stmt|;
name|reg_rctl
operator|=
name|IXGBE_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_FCTRL
argument_list|)
expr_stmt|;
name|reg_rctl
operator|&=
operator|(
operator|~
name|IXGBE_FCTRL_UPE
operator|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
condition|)
name|mcnt
operator|=
name|MAX_NUM_MULTICAST_ADDRESSES
expr_stmt|;
else|else
block|{
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|800000
name|IF_ADDR_LOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
else|#
directive|else
name|if_maddr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
if|if
condition|(
name|mcnt
operator|==
name|MAX_NUM_MULTICAST_ADDRESSES
condition|)
break|break;
name|mcnt
operator|++
expr_stmt|;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|800000
name|IF_ADDR_UNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
else|#
directive|else
name|if_maddr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|mcnt
operator|<
name|MAX_NUM_MULTICAST_ADDRESSES
condition|)
name|reg_rctl
operator|&=
operator|(
operator|~
name|IXGBE_FCTRL_MPE
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_FCTRL
argument_list|,
name|reg_rctl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
name|reg_rctl
operator||=
operator|(
name|IXGBE_FCTRL_UPE
operator||
name|IXGBE_FCTRL_MPE
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_FCTRL
argument_list|,
name|reg_rctl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
condition|)
block|{
name|reg_rctl
operator||=
name|IXGBE_FCTRL_MPE
expr_stmt|;
name|reg_rctl
operator|&=
operator|~
name|IXGBE_FCTRL_UPE
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_FCTRL
argument_list|,
name|reg_rctl
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/*********************************************************************  *  Multicast Update  *  *  This routine is called whenever multicast address list is updated.  *  **********************************************************************/
define|#
directive|define
name|IXGBE_RAR_ENTRIES
value|16
specifier|static
name|void
name|ixgbe_set_multi
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|u32
name|fctrl
decl_stmt|;
name|u8
modifier|*
name|mta
decl_stmt|;
name|u8
modifier|*
name|update_ptr
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|int
name|mcnt
init|=
literal|0
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ixgbe_set_multi: begin"
argument_list|)
expr_stmt|;
name|mta
operator|=
name|adapter
operator|->
name|mta
expr_stmt|;
name|bzero
argument_list|(
name|mta
argument_list|,
sizeof|sizeof
argument_list|(
name|u8
argument_list|)
operator|*
name|IXGBE_ETH_LENGTH_OF_ADDRESS
operator|*
name|MAX_NUM_MULTICAST_ADDRESSES
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|800000
name|IF_ADDR_LOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
else|#
directive|else
name|if_maddr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
if|if
condition|(
name|mcnt
operator|==
name|MAX_NUM_MULTICAST_ADDRESSES
condition|)
break|break;
name|bcopy
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|,
operator|&
name|mta
index|[
name|mcnt
operator|*
name|IXGBE_ETH_LENGTH_OF_ADDRESS
index|]
argument_list|,
name|IXGBE_ETH_LENGTH_OF_ADDRESS
argument_list|)
expr_stmt|;
name|mcnt
operator|++
expr_stmt|;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|800000
name|IF_ADDR_UNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
else|#
directive|else
name|if_maddr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fctrl
operator|=
name|IXGBE_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_FCTRL
argument_list|)
expr_stmt|;
name|fctrl
operator||=
operator|(
name|IXGBE_FCTRL_UPE
operator||
name|IXGBE_FCTRL_MPE
operator|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
name|fctrl
operator||=
operator|(
name|IXGBE_FCTRL_UPE
operator||
name|IXGBE_FCTRL_MPE
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mcnt
operator|>=
name|MAX_NUM_MULTICAST_ADDRESSES
operator|||
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
condition|)
block|{
name|fctrl
operator||=
name|IXGBE_FCTRL_MPE
expr_stmt|;
name|fctrl
operator|&=
operator|~
name|IXGBE_FCTRL_UPE
expr_stmt|;
block|}
else|else
name|fctrl
operator|&=
operator|~
operator|(
name|IXGBE_FCTRL_UPE
operator||
name|IXGBE_FCTRL_MPE
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_FCTRL
argument_list|,
name|fctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcnt
operator|<
name|MAX_NUM_MULTICAST_ADDRESSES
condition|)
block|{
name|update_ptr
operator|=
name|mta
expr_stmt|;
name|ixgbe_update_mc_addr_list
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|update_ptr
argument_list|,
name|mcnt
argument_list|,
name|ixgbe_mc_array_itr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/*  * This is an iterator function now needed by the multicast  * shared code. It simply feeds the shared code routine the  * addresses in the array of ixgbe_set_multi() one by one.  */
specifier|static
name|u8
modifier|*
name|ixgbe_mc_array_itr
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
modifier|*
name|update_ptr
parameter_list|,
name|u32
modifier|*
name|vmdq
parameter_list|)
block|{
name|u8
modifier|*
name|addr
init|=
operator|*
name|update_ptr
decl_stmt|;
name|u8
modifier|*
name|newptr
decl_stmt|;
operator|*
name|vmdq
operator|=
literal|0
expr_stmt|;
name|newptr
operator|=
name|addr
operator|+
name|IXGBE_ETH_LENGTH_OF_ADDRESS
expr_stmt|;
operator|*
name|update_ptr
operator|=
name|newptr
expr_stmt|;
return|return
name|addr
return|;
block|}
comment|/*********************************************************************  *  Timer routine  *  *  This routine checks for link status,updates statistics,  *  and runs the watchdog check.  *  **********************************************************************/
specifier|static
name|void
name|ixgbe_local_timer
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|arg
decl_stmt|;
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|struct
name|ix_queue
modifier|*
name|que
init|=
name|adapter
operator|->
name|queues
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
name|int
name|hung
init|=
literal|0
decl_stmt|,
name|paused
init|=
literal|0
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|adapter
operator|->
name|core_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* Check for pluggable optics */
if|if
condition|(
name|adapter
operator|->
name|sfp_probe
condition|)
if|if
condition|(
operator|!
name|ixgbe_sfp_probe
argument_list|(
name|adapter
argument_list|)
condition|)
goto|goto
name|out
goto|;
comment|/* Nothing to do */
name|ixgbe_update_link_status
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixgbe_update_stats_counters
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* 	 * If the interface has been paused 	 * then don't do the watchdog check 	 */
if|if
condition|(
name|IXGBE_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_TFCS
argument_list|)
operator|&
name|IXGBE_TFCS_TXOFF
condition|)
name|paused
operator|=
literal|1
expr_stmt|;
comment|/* 	** Check the TX queues status 	**      - watchdog only if all queues show hung 	*/
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
operator|,
name|txr
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|txr
operator|->
name|queue_status
operator|==
name|IXGBE_QUEUE_HUNG
operator|)
operator|&&
operator|(
name|paused
operator|==
literal|0
operator|)
condition|)
operator|++
name|hung
expr_stmt|;
elseif|else
if|if
condition|(
name|txr
operator|->
name|queue_status
operator|==
name|IXGBE_QUEUE_WORKING
condition|)
name|taskqueue_enqueue
argument_list|(
name|que
operator|->
name|tq
argument_list|,
operator|&
name|txr
operator|->
name|txq_task
argument_list|)
expr_stmt|;
block|}
comment|/* Only truely watchdog if all queues show hung */
if|if
condition|(
name|hung
operator|==
name|adapter
operator|->
name|num_queues
condition|)
goto|goto
name|watchdog
goto|;
name|out
label|:
name|callout_reset
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|,
name|hz
argument_list|,
name|ixgbe_local_timer
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
return|return;
name|watchdog
label|:
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"Watchdog timeout -- resetting\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Queue(%d) tdh = %d, hw tdt = %d\n"
argument_list|,
name|txr
operator|->
name|me
argument_list|,
name|IXGBE_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_TDH
argument_list|(
name|txr
operator|->
name|me
argument_list|)
argument_list|)
argument_list|,
name|IXGBE_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_TDT
argument_list|(
name|txr
operator|->
name|me
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"TX(%d) desc avail = %d,"
literal|"Next TX to Clean = %d\n"
argument_list|,
name|txr
operator|->
name|me
argument_list|,
name|txr
operator|->
name|tx_avail
argument_list|,
name|txr
operator|->
name|next_to_clean
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|adapter
operator|->
name|watchdog_events
operator|++
expr_stmt|;
name|ixgbe_init_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
comment|/* ** Note: this routine updates the OS on the link state **	the real check of the hardware only happens with **	a link interrupt. */
specifier|static
name|void
name|ixgbe_update_link_status
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
if|if
condition|(
name|adapter
operator|->
name|link_up
condition|)
block|{
if|if
condition|(
name|adapter
operator|->
name|link_active
operator|==
name|FALSE
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Link is up %d Gbps %s \n"
argument_list|,
operator|(
operator|(
name|adapter
operator|->
name|link_speed
operator|==
literal|128
operator|)
condition|?
literal|10
else|:
literal|1
operator|)
argument_list|,
literal|"Full Duplex"
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|link_active
operator|=
name|TRUE
expr_stmt|;
comment|/* Update any Flow Control changes */
name|ixgbe_fc_enable
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_UP
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Link down */
if|if
condition|(
name|adapter
operator|->
name|link_active
operator|==
name|TRUE
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Link is Down\n"
argument_list|)
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_DOWN
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|link_active
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
return|return;
block|}
comment|/*********************************************************************  *  *  This routine disables all traffic on the adapter by issuing a  *  global reset on the MAC and deallocates TX/RX buffers.  *  **********************************************************************/
specifier|static
name|void
name|ixgbe_stop
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|arg
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|ifp
operator|=
name|adapter
operator|->
name|ifp
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|adapter
operator|->
name|core_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixgbe_stop: begin\n"
argument_list|)
expr_stmt|;
name|ixgbe_disable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|)
expr_stmt|;
comment|/* Let the stack know...*/
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|ixgbe_reset_hw
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|hw
operator|->
name|adapter_stopped
operator|=
name|FALSE
expr_stmt|;
name|ixgbe_stop_adapter
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_82599EB
condition|)
name|ixgbe_stop_mac_link_on_d3_82599
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Turn off the laser - noop with no optics */
name|ixgbe_disable_tx_laser
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Update the stack */
name|adapter
operator|->
name|link_up
operator|=
name|FALSE
expr_stmt|;
name|ixgbe_update_link_status
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* reprogram the RAR[0] in case user changed it. */
name|ixgbe_set_rar
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
literal|0
argument_list|,
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|addr
argument_list|,
literal|0
argument_list|,
name|IXGBE_RAH_AV
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*********************************************************************  *  *  Determine hardware revision.  *  **********************************************************************/
specifier|static
name|void
name|ixgbe_identify_hardware
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
comment|/* Save off the information about this board */
name|hw
operator|->
name|vendor_id
operator|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|hw
operator|->
name|device_id
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|hw
operator|->
name|revision_id
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_REVID
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hw
operator|->
name|subsystem_vendor_id
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SUBVEND_0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|hw
operator|->
name|subsystem_device_id
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SUBDEV_0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* We need this here to set the num_segs below */
name|ixgbe_set_mac_type
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Pick up the 82599 and VF settings */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|!=
name|ixgbe_mac_82598EB
condition|)
block|{
name|hw
operator|->
name|phy
operator|.
name|smart_speed
operator|=
name|ixgbe_smart_speed
expr_stmt|;
name|adapter
operator|->
name|num_segs
operator|=
name|IXGBE_82599_SCATTER
expr_stmt|;
block|}
else|else
name|adapter
operator|->
name|num_segs
operator|=
name|IXGBE_82598_SCATTER
expr_stmt|;
return|return;
block|}
comment|/*********************************************************************  *  *  Determine optic type  *  **********************************************************************/
specifier|static
name|void
name|ixgbe_setup_optics
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|int
name|layer
decl_stmt|;
name|layer
operator|=
name|ixgbe_get_supported_physical_layer
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|layer
operator|&
name|IXGBE_PHYSICAL_LAYER_10GBASE_T
condition|)
block|{
name|adapter
operator|->
name|optics
operator|=
name|IFM_10G_T
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|layer
operator|&
name|IXGBE_PHYSICAL_LAYER_1000BASE_T
condition|)
block|{
name|adapter
operator|->
name|optics
operator|=
name|IFM_1000_T
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|layer
operator|&
name|IXGBE_PHYSICAL_LAYER_1000BASE_SX
condition|)
block|{
name|adapter
operator|->
name|optics
operator|=
name|IFM_1000_SX
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|layer
operator|&
operator|(
name|IXGBE_PHYSICAL_LAYER_10GBASE_LR
operator||
name|IXGBE_PHYSICAL_LAYER_10GBASE_LRM
operator|)
condition|)
block|{
name|adapter
operator|->
name|optics
operator|=
name|IFM_10G_LR
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|layer
operator|&
name|IXGBE_PHYSICAL_LAYER_10GBASE_SR
condition|)
block|{
name|adapter
operator|->
name|optics
operator|=
name|IFM_10G_SR
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|layer
operator|&
name|IXGBE_PHYSICAL_LAYER_SFP_PLUS_CU
condition|)
block|{
name|adapter
operator|->
name|optics
operator|=
name|IFM_10G_TWINAX
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|layer
operator|&
operator|(
name|IXGBE_PHYSICAL_LAYER_10GBASE_KX4
operator||
name|IXGBE_PHYSICAL_LAYER_10GBASE_CX4
operator|)
condition|)
block|{
name|adapter
operator|->
name|optics
operator|=
name|IFM_10G_CX4
expr_stmt|;
return|return;
block|}
comment|/* If we get here just set the default */
name|adapter
operator|->
name|optics
operator|=
name|IFM_ETHER
operator||
name|IFM_AUTO
expr_stmt|;
return|return;
block|}
comment|/*********************************************************************  *  *  Setup the Legacy or MSI Interrupt handler  *  **********************************************************************/
specifier|static
name|int
name|ixgbe_allocate_legacy
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|struct
name|ix_queue
modifier|*
name|que
init|=
name|adapter
operator|->
name|queues
decl_stmt|;
ifndef|#
directive|ifndef
name|IXGBE_LEGACY_TX
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
endif|#
directive|endif
name|int
name|error
decl_stmt|,
name|rid
init|=
literal|0
decl_stmt|;
comment|/* MSI RID at 1 */
if|if
condition|(
name|adapter
operator|->
name|msix
operator|==
literal|1
condition|)
name|rid
operator|=
literal|1
expr_stmt|;
comment|/* We allocate a single interrupt resource */
name|adapter
operator|->
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate bus resource: "
literal|"interrupt\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * Try allocating a fast interrupt and the associated deferred 	 * processing contexts. 	 */
ifndef|#
directive|ifndef
name|IXGBE_LEGACY_TX
name|TASK_INIT
argument_list|(
operator|&
name|txr
operator|->
name|txq_task
argument_list|,
literal|0
argument_list|,
name|ixgbe_deferred_mq_start
argument_list|,
name|txr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TASK_INIT
argument_list|(
operator|&
name|que
operator|->
name|que_task
argument_list|,
literal|0
argument_list|,
name|ixgbe_handle_que
argument_list|,
name|que
argument_list|)
expr_stmt|;
name|que
operator|->
name|tq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"ixgbe_que"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|que
operator|->
name|tq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|que
operator|->
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s ixq"
argument_list|,
name|device_get_nameunit
argument_list|(
name|adapter
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Tasklets for Link, SFP and Multispeed Fiber */
name|TASK_INIT
argument_list|(
operator|&
name|adapter
operator|->
name|link_task
argument_list|,
literal|0
argument_list|,
name|ixgbe_handle_link
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|adapter
operator|->
name|mod_task
argument_list|,
literal|0
argument_list|,
name|ixgbe_handle_mod
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|adapter
operator|->
name|msf_task
argument_list|,
literal|0
argument_list|,
name|ixgbe_handle_msf
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IXGBE_FDIR
name|TASK_INIT
argument_list|(
operator|&
name|adapter
operator|->
name|fdir_task
argument_list|,
literal|0
argument_list|,
name|ixgbe_reinit_fdir
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|adapter
operator|->
name|tq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"ixgbe_link"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|adapter
operator|->
name|tq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|adapter
operator|->
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s linkq"
argument_list|,
name|device_get_nameunit
argument_list|(
name|adapter
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|adapter
operator|->
name|res
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|ixgbe_legacy_irq
argument_list|,
name|que
argument_list|,
operator|&
name|adapter
operator|->
name|tag
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to register fast interrupt "
literal|"handler: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|que
operator|->
name|tq
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|adapter
operator|->
name|tq
argument_list|)
expr_stmt|;
name|que
operator|->
name|tq
operator|=
name|NULL
expr_stmt|;
name|adapter
operator|->
name|tq
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* For simplicity in the handlers */
name|adapter
operator|->
name|que_mask
operator|=
name|IXGBE_EIMS_ENABLE_MASK
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*********************************************************************  *  *  Setup MSIX Interrupt resources and handlers   *  **********************************************************************/
specifier|static
name|int
name|ixgbe_allocate_msix
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|struct
name|ix_queue
modifier|*
name|que
init|=
name|adapter
operator|->
name|queues
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
name|int
name|error
decl_stmt|,
name|rid
decl_stmt|,
name|vector
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|vector
operator|++
operator|,
name|que
operator|++
operator|,
name|txr
operator|++
control|)
block|{
name|rid
operator|=
name|vector
operator|+
literal|1
expr_stmt|;
name|que
operator|->
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|que
operator|->
name|res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate"
literal|" bus resource: que interrupt [%d]\n"
argument_list|,
name|vector
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Set the handler function */
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|que
operator|->
name|res
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|ixgbe_msix_que
argument_list|,
name|que
argument_list|,
operator|&
name|que
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|que
operator|->
name|res
operator|=
name|NULL
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to register QUE handler"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800504
name|bus_describe_intr
argument_list|(
name|dev
argument_list|,
name|que
operator|->
name|res
argument_list|,
name|que
operator|->
name|tag
argument_list|,
literal|"que %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|que
operator|->
name|msix
operator|=
name|vector
expr_stmt|;
name|adapter
operator|->
name|que_mask
operator||=
call|(
name|u64
call|)
argument_list|(
literal|1
operator|<<
name|que
operator|->
name|msix
argument_list|)
expr_stmt|;
comment|/* 		** Bind the msix vector, and thus the 		** ring to the corresponding cpu. 		*/
if|if
condition|(
name|adapter
operator|->
name|num_queues
operator|>
literal|1
condition|)
name|bus_bind_intr
argument_list|(
name|dev
argument_list|,
name|que
operator|->
name|res
argument_list|,
name|i
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|IXGBE_LEGACY_TX
name|TASK_INIT
argument_list|(
operator|&
name|txr
operator|->
name|txq_task
argument_list|,
literal|0
argument_list|,
name|ixgbe_deferred_mq_start
argument_list|,
name|txr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TASK_INIT
argument_list|(
operator|&
name|que
operator|->
name|que_task
argument_list|,
literal|0
argument_list|,
name|ixgbe_handle_que
argument_list|,
name|que
argument_list|)
expr_stmt|;
name|que
operator|->
name|tq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"ixgbe_que"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|que
operator|->
name|tq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|que
operator|->
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s que"
argument_list|,
name|device_get_nameunit
argument_list|(
name|adapter
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* and Link */
name|rid
operator|=
name|vector
operator|+
literal|1
expr_stmt|;
name|adapter
operator|->
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|adapter
operator|->
name|res
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate"
literal|" bus resource: Link interrupt [%d]\n"
argument_list|,
name|rid
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Set the link handler function */
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|adapter
operator|->
name|res
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|ixgbe_msix_link
argument_list|,
name|adapter
argument_list|,
operator|&
name|adapter
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|adapter
operator|->
name|res
operator|=
name|NULL
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to register LINK handler"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800504
name|bus_describe_intr
argument_list|(
name|dev
argument_list|,
name|adapter
operator|->
name|res
argument_list|,
name|adapter
operator|->
name|tag
argument_list|,
literal|"link"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|adapter
operator|->
name|linkvec
operator|=
name|vector
expr_stmt|;
comment|/* Tasklets for Link, SFP and Multispeed Fiber */
name|TASK_INIT
argument_list|(
operator|&
name|adapter
operator|->
name|link_task
argument_list|,
literal|0
argument_list|,
name|ixgbe_handle_link
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|adapter
operator|->
name|mod_task
argument_list|,
literal|0
argument_list|,
name|ixgbe_handle_mod
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|adapter
operator|->
name|msf_task
argument_list|,
literal|0
argument_list|,
name|ixgbe_handle_msf
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IXGBE_FDIR
name|TASK_INIT
argument_list|(
operator|&
name|adapter
operator|->
name|fdir_task
argument_list|,
literal|0
argument_list|,
name|ixgbe_reinit_fdir
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|adapter
operator|->
name|tq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"ixgbe_link"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|adapter
operator|->
name|tq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|adapter
operator|->
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s linkq"
argument_list|,
name|device_get_nameunit
argument_list|(
name|adapter
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * Setup Either MSI/X or MSI  */
specifier|static
name|int
name|ixgbe_setup_msix
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|int
name|rid
decl_stmt|,
name|want
decl_stmt|,
name|queues
decl_stmt|,
name|msgs
decl_stmt|;
comment|/* Override by tuneable */
if|if
condition|(
name|ixgbe_enable_msix
operator|==
literal|0
condition|)
goto|goto
name|msi
goto|;
comment|/* First try MSI/X */
name|msgs
operator|=
name|pci_msix_count
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|msgs
operator|==
literal|0
condition|)
goto|goto
name|msi
goto|;
name|rid
operator|=
name|PCIR_BAR
argument_list|(
name|MSIX_82598_BAR
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|msix_mem
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|msix_mem
operator|==
name|NULL
condition|)
block|{
name|rid
operator|+=
literal|4
expr_stmt|;
comment|/* 82599 maps in higher BAR */
name|adapter
operator|->
name|msix_mem
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|adapter
operator|->
name|msix_mem
operator|==
name|NULL
condition|)
block|{
comment|/* May not be enabled */
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"Unable to map MSIX table \n"
argument_list|)
expr_stmt|;
goto|goto
name|msi
goto|;
block|}
comment|/* Figure out a reasonable auto config value */
name|queues
operator|=
operator|(
name|mp_ncpus
operator|>
operator|(
name|msgs
operator|-
literal|1
operator|)
operator|)
condition|?
operator|(
name|msgs
operator|-
literal|1
operator|)
else|:
name|mp_ncpus
expr_stmt|;
if|if
condition|(
name|ixgbe_num_queues
operator|!=
literal|0
condition|)
name|queues
operator|=
name|ixgbe_num_queues
expr_stmt|;
comment|/* Set max queues to 8 when autoconfiguring */
elseif|else
if|if
condition|(
operator|(
name|ixgbe_num_queues
operator|==
literal|0
operator|)
operator|&&
operator|(
name|queues
operator|>
literal|8
operator|)
condition|)
name|queues
operator|=
literal|8
expr_stmt|;
comment|/* reflect correct sysctl value */
name|ixgbe_num_queues
operator|=
name|queues
expr_stmt|;
comment|/* 	** Want one vector (RX/TX pair) per queue 	** plus an additional for Link. 	*/
name|want
operator|=
name|queues
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|msgs
operator|>=
name|want
condition|)
name|msgs
operator|=
name|want
expr_stmt|;
else|else
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"MSIX Configuration Problem, "
literal|"%d vectors but %d queues wanted!\n"
argument_list|,
name|msgs
argument_list|,
name|want
argument_list|)
expr_stmt|;
goto|goto
name|msi
goto|;
block|}
if|if
condition|(
operator|(
name|pci_alloc_msix
argument_list|(
name|dev
argument_list|,
operator|&
name|msgs
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|msgs
operator|==
name|want
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"Using MSIX interrupts with %d vectors\n"
argument_list|,
name|msgs
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|num_queues
operator|=
name|queues
expr_stmt|;
return|return
operator|(
name|msgs
operator|)
return|;
block|}
comment|/* 	** If MSIX alloc failed or provided us with 	** less than needed, free and fall through to MSI 	*/
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|msi
label|:
if|if
condition|(
name|adapter
operator|->
name|msix_mem
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|rid
argument_list|,
name|adapter
operator|->
name|msix_mem
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|msix_mem
operator|=
name|NULL
expr_stmt|;
block|}
name|msgs
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pci_alloc_msi
argument_list|(
name|dev
argument_list|,
operator|&
name|msgs
argument_list|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"Using an MSI interrupt\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|msgs
operator|)
return|;
block|}
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"Using a Legacy interrupt\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|int
name|ixgbe_allocate_pci_resources
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|int
name|rid
decl_stmt|;
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|rid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|pci_mem
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|adapter
operator|->
name|pci_mem
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate bus resource: memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|adapter
operator|->
name|osdep
operator|.
name|mem_bus_space_tag
operator|=
name|rman_get_bustag
argument_list|(
name|adapter
operator|->
name|pci_mem
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|osdep
operator|.
name|mem_bus_space_handle
operator|=
name|rman_get_bushandle
argument_list|(
name|adapter
operator|->
name|pci_mem
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|hw_addr
operator|=
operator|(
name|u8
operator|*
operator|)
operator|&
name|adapter
operator|->
name|osdep
operator|.
name|mem_bus_space_handle
expr_stmt|;
comment|/* Legacy defaults */
name|adapter
operator|->
name|num_queues
operator|=
literal|1
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|back
operator|=
operator|&
name|adapter
operator|->
name|osdep
expr_stmt|;
comment|/* 	** Now setup MSI or MSI/X, should 	** return us the number of supported 	** vectors. (Will be 1 for MSI) 	*/
name|adapter
operator|->
name|msix
operator|=
name|ixgbe_setup_msix
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|void
name|ixgbe_free_pci_resources
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ix_queue
modifier|*
name|que
init|=
name|adapter
operator|->
name|queues
decl_stmt|;
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|int
name|rid
decl_stmt|,
name|memrid
decl_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_82598EB
condition|)
name|memrid
operator|=
name|PCIR_BAR
argument_list|(
name|MSIX_82598_BAR
argument_list|)
expr_stmt|;
else|else
name|memrid
operator|=
name|PCIR_BAR
argument_list|(
name|MSIX_82599_BAR
argument_list|)
expr_stmt|;
comment|/* 	** There is a slight possibility of a failure mode 	** in attach that will result in entering this function 	** before interrupt resources have been initialized, and 	** in that case we do not want to execute the loops below 	** We can detect this reliably by the state of the adapter 	** res pointer. 	*/
if|if
condition|(
name|adapter
operator|->
name|res
operator|==
name|NULL
condition|)
goto|goto
name|mem
goto|;
comment|/* 	**  Release all msix queue resources: 	*/
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
block|{
name|rid
operator|=
name|que
operator|->
name|msix
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|que
operator|->
name|tag
operator|!=
name|NULL
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|que
operator|->
name|res
argument_list|,
name|que
operator|->
name|tag
argument_list|)
expr_stmt|;
name|que
operator|->
name|tag
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|que
operator|->
name|res
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rid
argument_list|,
name|que
operator|->
name|res
argument_list|)
expr_stmt|;
block|}
comment|/* Clean the Legacy or Link interrupt last */
if|if
condition|(
name|adapter
operator|->
name|linkvec
condition|)
comment|/* we are doing MSIX */
name|rid
operator|=
name|adapter
operator|->
name|linkvec
operator|+
literal|1
expr_stmt|;
else|else
operator|(
name|adapter
operator|->
name|msix
operator|!=
literal|0
operator|)
condition|?
operator|(
name|rid
operator|=
literal|1
operator|)
else|:
operator|(
name|rid
operator|=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|tag
operator|!=
name|NULL
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|adapter
operator|->
name|res
argument_list|,
name|adapter
operator|->
name|tag
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|tag
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|adapter
operator|->
name|res
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rid
argument_list|,
name|adapter
operator|->
name|res
argument_list|)
expr_stmt|;
name|mem
label|:
if|if
condition|(
name|adapter
operator|->
name|msix
condition|)
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|msix_mem
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|memrid
argument_list|,
name|adapter
operator|->
name|msix_mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|pci_mem
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|adapter
operator|->
name|pci_mem
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*********************************************************************  *  *  Setup networking device structure and register an interface.  *  **********************************************************************/
specifier|static
name|int
name|ixgbe_setup_interface
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixgbe_setup_interface: begin"
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|adapter
operator|->
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can not allocate ifnet structure\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|1000025
name|ifp
operator|->
name|if_baudrate
operator|=
literal|1000000000
expr_stmt|;
else|#
directive|else
name|if_initbaudrate
argument_list|(
name|ifp
argument_list|,
name|IF_Gbps
argument_list|(
literal|10
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ifp
operator|->
name|if_init
operator|=
name|ixgbe_init
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|adapter
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|ixgbe_ioctl
expr_stmt|;
ifndef|#
directive|ifndef
name|IXGBE_LEGACY_TX
name|ifp
operator|->
name|if_transmit
operator|=
name|ixgbe_mq_start
expr_stmt|;
name|ifp
operator|->
name|if_qflush
operator|=
name|ixgbe_qflush
expr_stmt|;
else|#
directive|else
name|ifp
operator|->
name|if_start
operator|=
name|ixgbe_start
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|adapter
operator|->
name|num_tx_desc
operator|-
literal|2
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
operator|=
name|adapter
operator|->
name|num_tx_desc
operator|-
literal|2
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|addr
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|max_frame_size
operator|=
name|ifp
operator|->
name|if_mtu
operator|+
name|ETHER_HDR_LEN
operator|+
name|ETHER_CRC_LEN
expr_stmt|;
comment|/* 	 * Tell the upper layer(s) we support long frames. 	 */
name|ifp
operator|->
name|if_data
operator|.
name|ifi_hdrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_vlan_header
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_HWCSUM
operator||
name|IFCAP_TSO
operator||
name|IFCAP_VLAN_HWCSUM
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_JUMBO_MTU
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_LRO
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_VLAN_HWTAGGING
operator||
name|IFCAP_VLAN_HWTSO
operator||
name|IFCAP_VLAN_MTU
operator||
name|IFCAP_HWSTATS
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|=
name|ifp
operator|->
name|if_capabilities
expr_stmt|;
comment|/* 	** Don't turn this on by default, if vlans are 	** created on another pseudo device (eg. lagg) 	** then vlan events are not passed thru, breaking 	** operation, but with HW FILTER off it works. If 	** using vlans directly on the ixgbe driver you can 	** enable this and get full hardware tag filtering. 	*/
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_VLAN_HWFILTER
expr_stmt|;
comment|/* 	 * Specify the media types supported by this adapter and register 	 * callbacks to update media and link information 	 */
name|ifmedia_init
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_IMASK
argument_list|,
name|ixgbe_media_change
argument_list|,
name|ixgbe_media_status
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|adapter
operator|->
name|optics
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|adapter
operator|->
name|optics
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|device_id
operator|==
name|IXGBE_DEV_ID_82598AT
condition|)
block|{
name|ifmedia_add
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_1000_T
operator||
name|IFM_FDX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_1000_T
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|ifmedia_add
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|void
name|ixgbe_config_link
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|u32
name|autoneg
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
name|bool
name|sfp
decl_stmt|,
name|negotiate
decl_stmt|;
name|sfp
operator|=
name|ixgbe_is_sfp
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|sfp
condition|)
block|{
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|multispeed_fiber
condition|)
block|{
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|setup_sfp
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|ixgbe_enable_tx_laser
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|adapter
operator|->
name|tq
argument_list|,
operator|&
name|adapter
operator|->
name|msf_task
argument_list|)
expr_stmt|;
block|}
else|else
name|taskqueue_enqueue
argument_list|(
name|adapter
operator|->
name|tq
argument_list|,
operator|&
name|adapter
operator|->
name|mod_task
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|check_link
condition|)
name|err
operator|=
name|ixgbe_check_link
argument_list|(
name|hw
argument_list|,
operator|&
name|adapter
operator|->
name|link_speed
argument_list|,
operator|&
name|adapter
operator|->
name|link_up
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|autoneg
operator|=
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|autoneg
operator|)
operator|&&
operator|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|get_link_capabilities
operator|)
condition|)
name|err
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|get_link_capabilities
argument_list|(
name|hw
argument_list|,
operator|&
name|autoneg
argument_list|,
operator|&
name|negotiate
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|setup_link
condition|)
name|err
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|setup_link
argument_list|(
name|hw
argument_list|,
name|autoneg
argument_list|,
name|adapter
operator|->
name|link_up
argument_list|)
expr_stmt|;
block|}
name|out
label|:
return|return;
block|}
comment|/********************************************************************  * Manage DMA'able memory.  *******************************************************************/
specifier|static
name|void
name|ixgbe_dmamap_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
if|if
condition|(
name|error
condition|)
return|return;
operator|*
operator|(
name|bus_addr_t
operator|*
operator|)
name|arg
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
return|return;
block|}
specifier|static
name|int
name|ixgbe_dma_malloc
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|bus_size_t
name|size
parameter_list|,
name|struct
name|ixgbe_dma_alloc
modifier|*
name|dma
parameter_list|,
name|int
name|mapflags
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|int
name|r
decl_stmt|;
name|r
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|adapter
operator|->
name|dev
argument_list|)
argument_list|,
comment|/* parent */
name|DBA_ALIGN
argument_list|,
literal|0
argument_list|,
comment|/* alignment, bounds */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|size
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|size
argument_list|,
comment|/* maxsegsize */
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lockfunc */
name|NULL
argument_list|,
comment|/* lockfuncarg */
operator|&
name|dma
operator|->
name|dma_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ixgbe_dma_malloc: bus_dma_tag_create failed; "
literal|"error %u\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
goto|goto
name|fail_0
goto|;
block|}
name|r
operator|=
name|bus_dmamem_alloc
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|dma
operator|->
name|dma_vaddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ixgbe_dma_malloc: bus_dmamem_alloc failed; "
literal|"error %u\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
goto|goto
name|fail_1
goto|;
block|}
name|r
operator|=
name|bus_dmamap_load
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|,
name|dma
operator|->
name|dma_vaddr
argument_list|,
name|size
argument_list|,
name|ixgbe_dmamap_cb
argument_list|,
operator|&
name|dma
operator|->
name|dma_paddr
argument_list|,
name|mapflags
operator||
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ixgbe_dma_malloc: bus_dmamap_load failed; "
literal|"error %u\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
goto|goto
name|fail_2
goto|;
block|}
name|dma
operator|->
name|dma_size
operator|=
name|size
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail_2
label|:
name|bus_dmamem_free
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|dma
operator|->
name|dma_vaddr
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
name|fail_1
label|:
name|bus_dma_tag_destroy
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|)
expr_stmt|;
name|fail_0
label|:
name|dma
operator|->
name|dma_map
operator|=
name|NULL
expr_stmt|;
name|dma
operator|->
name|dma_tag
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
specifier|static
name|void
name|ixgbe_dma_free
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|struct
name|ixgbe_dma_alloc
modifier|*
name|dma
parameter_list|)
block|{
name|bus_dmamap_sync
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|dma
operator|->
name|dma_vaddr
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|)
expr_stmt|;
block|}
comment|/*********************************************************************  *  *  Allocate memory for the transmit and receive rings, and then  *  the descriptors associated with each, called only once at attach.  *  **********************************************************************/
specifier|static
name|int
name|ixgbe_allocate_queues
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|struct
name|ix_queue
modifier|*
name|que
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
decl_stmt|;
name|int
name|rsize
decl_stmt|,
name|tsize
decl_stmt|,
name|error
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|int
name|txconf
init|=
literal|0
decl_stmt|,
name|rxconf
init|=
literal|0
decl_stmt|;
comment|/* First allocate the top level queue structs */
if|if
condition|(
operator|!
operator|(
name|adapter
operator|->
name|queues
operator|=
operator|(
expr|struct
name|ix_queue
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ix_queue
argument_list|)
operator|*
name|adapter
operator|->
name|num_queues
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate queue memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* First allocate the TX ring struct memory */
if|if
condition|(
operator|!
operator|(
name|adapter
operator|->
name|tx_rings
operator|=
operator|(
expr|struct
name|tx_ring
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tx_ring
argument_list|)
operator|*
name|adapter
operator|->
name|num_queues
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate TX ring memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|tx_fail
goto|;
block|}
comment|/* Next allocate the RX */
if|if
condition|(
operator|!
operator|(
name|adapter
operator|->
name|rx_rings
operator|=
operator|(
expr|struct
name|rx_ring
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|rx_ring
argument_list|)
operator|*
name|adapter
operator|->
name|num_queues
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate RX ring memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|rx_fail
goto|;
block|}
comment|/* For the ring itself */
name|tsize
operator|=
name|roundup2
argument_list|(
name|adapter
operator|->
name|num_tx_desc
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|ixgbe_adv_tx_desc
argument_list|)
argument_list|,
name|DBA_ALIGN
argument_list|)
expr_stmt|;
comment|/* 	 * Now set up the TX queues, txconf is needed to handle the 	 * possibility that things fail midcourse and we need to 	 * undo memory gracefully 	 */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|txconf
operator|++
control|)
block|{
comment|/* Set up some basics */
name|txr
operator|=
operator|&
name|adapter
operator|->
name|tx_rings
index|[
name|i
index|]
expr_stmt|;
name|txr
operator|->
name|adapter
operator|=
name|adapter
expr_stmt|;
name|txr
operator|->
name|me
operator|=
name|i
expr_stmt|;
name|txr
operator|->
name|num_desc
operator|=
name|adapter
operator|->
name|num_tx_desc
expr_stmt|;
comment|/* Initialize the TX side lock */
name|snprintf
argument_list|(
name|txr
operator|->
name|mtx_name
argument_list|,
sizeof|sizeof
argument_list|(
name|txr
operator|->
name|mtx_name
argument_list|)
argument_list|,
literal|"%s:tx(%d)"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|txr
operator|->
name|me
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|txr
operator|->
name|tx_mtx
argument_list|,
name|txr
operator|->
name|mtx_name
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
if|if
condition|(
name|ixgbe_dma_malloc
argument_list|(
name|adapter
argument_list|,
name|tsize
argument_list|,
operator|&
name|txr
operator|->
name|txdma
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate TX Descriptor memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_tx_desc
goto|;
block|}
name|txr
operator|->
name|tx_base
operator|=
operator|(
expr|union
name|ixgbe_adv_tx_desc
operator|*
operator|)
name|txr
operator|->
name|txdma
operator|.
name|dma_vaddr
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|txr
operator|->
name|tx_base
argument_list|,
name|tsize
argument_list|)
expr_stmt|;
comment|/* Now allocate transmit buffers for the ring */
if|if
condition|(
name|ixgbe_allocate_transmit_buffers
argument_list|(
name|txr
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Critical Failure setting up transmit buffers\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_tx_desc
goto|;
block|}
ifndef|#
directive|ifndef
name|IXGBE_LEGACY_TX
comment|/* Allocate a buf ring */
name|txr
operator|->
name|br
operator|=
name|buf_ring_alloc
argument_list|(
name|IXGBE_BR_SIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|,
operator|&
name|txr
operator|->
name|tx_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|br
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Critical Failure setting up buf ring\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_tx_desc
goto|;
block|}
endif|#
directive|endif
block|}
comment|/* 	 * Next the RX queues... 	 */
name|rsize
operator|=
name|roundup2
argument_list|(
name|adapter
operator|->
name|num_rx_desc
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|ixgbe_adv_rx_desc
argument_list|)
argument_list|,
name|DBA_ALIGN
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|rxconf
operator|++
control|)
block|{
name|rxr
operator|=
operator|&
name|adapter
operator|->
name|rx_rings
index|[
name|i
index|]
expr_stmt|;
comment|/* Set up some basics */
name|rxr
operator|->
name|adapter
operator|=
name|adapter
expr_stmt|;
name|rxr
operator|->
name|me
operator|=
name|i
expr_stmt|;
name|rxr
operator|->
name|num_desc
operator|=
name|adapter
operator|->
name|num_rx_desc
expr_stmt|;
comment|/* Initialize the RX side lock */
name|snprintf
argument_list|(
name|rxr
operator|->
name|mtx_name
argument_list|,
sizeof|sizeof
argument_list|(
name|rxr
operator|->
name|mtx_name
argument_list|)
argument_list|,
literal|"%s:rx(%d)"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|rxr
operator|->
name|me
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|rxr
operator|->
name|rx_mtx
argument_list|,
name|rxr
operator|->
name|mtx_name
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
if|if
condition|(
name|ixgbe_dma_malloc
argument_list|(
name|adapter
argument_list|,
name|rsize
argument_list|,
operator|&
name|rxr
operator|->
name|rxdma
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate RxDescriptor memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_rx_desc
goto|;
block|}
name|rxr
operator|->
name|rx_base
operator|=
operator|(
expr|union
name|ixgbe_adv_rx_desc
operator|*
operator|)
name|rxr
operator|->
name|rxdma
operator|.
name|dma_vaddr
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|rxr
operator|->
name|rx_base
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
comment|/* Allocate receive buffers for the ring*/
if|if
condition|(
name|ixgbe_allocate_receive_buffers
argument_list|(
name|rxr
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Critical Failure setting up receive buffers\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_rx_desc
goto|;
block|}
block|}
comment|/* 	** Finally set up the queue holding structs 	*/
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|que
operator|=
operator|&
name|adapter
operator|->
name|queues
index|[
name|i
index|]
expr_stmt|;
name|que
operator|->
name|adapter
operator|=
name|adapter
expr_stmt|;
name|que
operator|->
name|txr
operator|=
operator|&
name|adapter
operator|->
name|tx_rings
index|[
name|i
index|]
expr_stmt|;
name|que
operator|->
name|rxr
operator|=
operator|&
name|adapter
operator|->
name|rx_rings
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|err_rx_desc
label|:
for|for
control|(
name|rxr
operator|=
name|adapter
operator|->
name|rx_rings
init|;
name|rxconf
operator|>
literal|0
condition|;
name|rxr
operator|++
operator|,
name|rxconf
operator|--
control|)
name|ixgbe_dma_free
argument_list|(
name|adapter
argument_list|,
operator|&
name|rxr
operator|->
name|rxdma
argument_list|)
expr_stmt|;
name|err_tx_desc
label|:
for|for
control|(
name|txr
operator|=
name|adapter
operator|->
name|tx_rings
init|;
name|txconf
operator|>
literal|0
condition|;
name|txr
operator|++
operator|,
name|txconf
operator|--
control|)
name|ixgbe_dma_free
argument_list|(
name|adapter
argument_list|,
operator|&
name|txr
operator|->
name|txdma
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|adapter
operator|->
name|rx_rings
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|rx_fail
label|:
name|free
argument_list|(
name|adapter
operator|->
name|tx_rings
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|tx_fail
label|:
name|free
argument_list|(
name|adapter
operator|->
name|queues
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|fail
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/*********************************************************************  *  *  Allocate memory for tx_buffer structures. The tx_buffer stores all  *  the information needed to transmit a packet on the wire. This is  *  called only once at attach, setup is done every reset.  *  **********************************************************************/
specifier|static
name|int
name|ixgbe_allocate_transmit_buffers
parameter_list|(
name|struct
name|tx_ring
modifier|*
name|txr
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|txr
operator|->
name|adapter
decl_stmt|;
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|struct
name|ixgbe_tx_buf
modifier|*
name|txbuf
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
comment|/* 	 * Setup DMA descriptor areas. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|adapter
operator|->
name|dev
argument_list|)
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* alignment, bounds */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|IXGBE_TSO_SIZE
argument_list|,
comment|/* maxsize */
name|adapter
operator|->
name|num_segs
argument_list|,
comment|/* nsegments */
name|PAGE_SIZE
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lockfunc */
name|NULL
argument_list|,
comment|/* lockfuncarg */
operator|&
name|txr
operator|->
name|txtag
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate TX DMA tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|txr
operator|->
name|tx_buffers
operator|=
operator|(
expr|struct
name|ixgbe_tx_buf
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ixgbe_tx_buf
argument_list|)
operator|*
name|adapter
operator|->
name|num_tx_desc
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate tx_buffer memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Create the descriptor buffer dma maps */
name|txbuf
operator|=
name|txr
operator|->
name|tx_buffers
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_tx_desc
condition|;
name|i
operator|++
operator|,
name|txbuf
operator|++
control|)
block|{
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
literal|0
argument_list|,
operator|&
name|txbuf
operator|->
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to create TX DMA map\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
return|return
literal|0
return|;
name|fail
label|:
comment|/* We free all, it handles case where we are in the middle */
name|ixgbe_free_transmit_structures
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/*********************************************************************  *  *  Initialize a transmit ring.  *  **********************************************************************/
specifier|static
name|void
name|ixgbe_setup_transmit_ring
parameter_list|(
name|struct
name|tx_ring
modifier|*
name|txr
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|txr
operator|->
name|adapter
decl_stmt|;
name|struct
name|ixgbe_tx_buf
modifier|*
name|txbuf
decl_stmt|;
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|netmap_slot
modifier|*
name|slot
decl_stmt|;
endif|#
directive|endif
comment|/* DEV_NETMAP */
comment|/* Clear the old ring contents */
name|IXGBE_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
comment|/* 	 * (under lock): if in netmap mode, do some consistency 	 * checks and set slot to entry 0 of the netmap ring. 	 */
name|slot
operator|=
name|netmap_reset
argument_list|(
name|na
argument_list|,
name|NR_TX
argument_list|,
name|txr
operator|->
name|me
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEV_NETMAP */
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|txr
operator|->
name|tx_base
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|union
name|ixgbe_adv_tx_desc
argument_list|)
operator|)
operator|*
name|adapter
operator|->
name|num_tx_desc
argument_list|)
expr_stmt|;
comment|/* Reset indices */
name|txr
operator|->
name|next_avail_desc
operator|=
literal|0
expr_stmt|;
name|txr
operator|->
name|next_to_clean
operator|=
literal|0
expr_stmt|;
comment|/* Free any existing tx buffers. */
name|txbuf
operator|=
name|txr
operator|->
name|tx_buffers
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|txr
operator|->
name|num_desc
condition|;
name|i
operator|++
operator|,
name|txbuf
operator|++
control|)
block|{
if|if
condition|(
name|txbuf
operator|->
name|m_head
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|txbuf
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|txbuf
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|txbuf
operator|->
name|m_head
argument_list|)
expr_stmt|;
name|txbuf
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEV_NETMAP
comment|/* 		 * In netmap mode, set the map for the packet buffer. 		 * NOTE: Some drivers (not this one) also need to set 		 * the physical buffer address in the NIC ring. 		 * Slots in the netmap ring (indexed by "si") are 		 * kring->nkr_hwofs positions "ahead" wrt the 		 * corresponding slot in the NIC ring. In some drivers 		 * (not here) nkr_hwofs can be negative. Function 		 * netmap_idx_n2k() handles wraparounds properly. 		 */
if|if
condition|(
name|slot
condition|)
block|{
name|int
name|si
init|=
name|netmap_idx_n2k
argument_list|(
operator|&
name|na
operator|->
name|tx_rings
index|[
name|txr
operator|->
name|me
index|]
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|netmap_load_map
argument_list|(
name|na
argument_list|,
name|txr
operator|->
name|txtag
argument_list|,
name|txbuf
operator|->
name|map
argument_list|,
name|NMB
argument_list|(
name|na
argument_list|,
name|slot
operator|+
name|si
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEV_NETMAP */
comment|/* Clear the EOP descriptor pointer */
name|txbuf
operator|->
name|eop
operator|=
name|NULL
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IXGBE_FDIR
comment|/* Set the rate at which we sample packets */
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|!=
name|ixgbe_mac_82598EB
condition|)
name|txr
operator|->
name|atr_sample
operator|=
name|atr_sample_rate
expr_stmt|;
endif|#
directive|endif
comment|/* Set number of descriptors available */
name|txr
operator|->
name|tx_avail
operator|=
name|adapter
operator|->
name|num_tx_desc
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|txdma
operator|.
name|dma_tag
argument_list|,
name|txr
operator|->
name|txdma
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|IXGBE_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
block|}
comment|/*********************************************************************  *  *  Initialize all transmit rings.  *  **********************************************************************/
specifier|static
name|int
name|ixgbe_setup_transmit_structures
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|txr
operator|++
control|)
name|ixgbe_setup_transmit_ring
argument_list|(
name|txr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*********************************************************************  *  *  Enable transmit unit.  *  **********************************************************************/
specifier|static
name|void
name|ixgbe_initialize_transmit_units
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
comment|/* Setup the Base and Length of the Tx Descriptor Ring */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|txr
operator|++
control|)
block|{
name|u64
name|tdba
init|=
name|txr
operator|->
name|txdma
operator|.
name|dma_paddr
decl_stmt|;
name|u32
name|txctrl
decl_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_TDBAL
argument_list|(
name|i
argument_list|)
argument_list|,
operator|(
name|tdba
operator|&
literal|0x00000000ffffffffULL
operator|)
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_TDBAH
argument_list|(
name|i
argument_list|)
argument_list|,
operator|(
name|tdba
operator|>>
literal|32
operator|)
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_TDLEN
argument_list|(
name|i
argument_list|)
argument_list|,
name|adapter
operator|->
name|num_tx_desc
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|ixgbe_adv_tx_desc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Setup the HW Tx Head and Tail descriptor pointers */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_TDH
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_TDT
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Setup Transmit Descriptor Cmd Settings */
name|txr
operator|->
name|txd_cmd
operator|=
name|IXGBE_TXD_CMD_IFCS
expr_stmt|;
name|txr
operator|->
name|queue_status
operator|=
name|IXGBE_QUEUE_IDLE
expr_stmt|;
comment|/* Set the processing limit */
name|txr
operator|->
name|process_limit
operator|=
name|ixgbe_tx_process_limit
expr_stmt|;
comment|/* Disable Head Writeback */
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|ixgbe_mac_82598EB
case|:
name|txctrl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DCA_TXCTRL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ixgbe_mac_82599EB
case|:
case|case
name|ixgbe_mac_X540
case|:
default|default:
name|txctrl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DCA_TXCTRL_82599
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|txctrl
operator|&=
operator|~
name|IXGBE_DCA_TXCTRL_DESC_WRO_EN
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|ixgbe_mac_82598EB
case|:
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DCA_TXCTRL
argument_list|(
name|i
argument_list|)
argument_list|,
name|txctrl
argument_list|)
expr_stmt|;
break|break;
case|case
name|ixgbe_mac_82599EB
case|:
case|case
name|ixgbe_mac_X540
case|:
default|default:
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DCA_TXCTRL_82599
argument_list|(
name|i
argument_list|)
argument_list|,
name|txctrl
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|!=
name|ixgbe_mac_82598EB
condition|)
block|{
name|u32
name|dmatxctl
decl_stmt|,
name|rttdcs
decl_stmt|;
name|dmatxctl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DMATXCTL
argument_list|)
expr_stmt|;
name|dmatxctl
operator||=
name|IXGBE_DMATXCTL_TE
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DMATXCTL
argument_list|,
name|dmatxctl
argument_list|)
expr_stmt|;
comment|/* Disable arbiter to set MTQC */
name|rttdcs
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RTTDCS
argument_list|)
expr_stmt|;
name|rttdcs
operator||=
name|IXGBE_RTTDCS_ARBDIS
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RTTDCS
argument_list|,
name|rttdcs
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MTQC
argument_list|,
name|IXGBE_MTQC_64Q_1PB
argument_list|)
expr_stmt|;
name|rttdcs
operator|&=
operator|~
name|IXGBE_RTTDCS_ARBDIS
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RTTDCS
argument_list|,
name|rttdcs
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/*********************************************************************  *  *  Free all transmit rings.  *  **********************************************************************/
specifier|static
name|void
name|ixgbe_free_transmit_structures
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|txr
operator|++
control|)
block|{
name|IXGBE_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|ixgbe_free_transmit_buffers
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|ixgbe_dma_free
argument_list|(
name|adapter
argument_list|,
operator|&
name|txr
operator|->
name|txdma
argument_list|)
expr_stmt|;
name|IXGBE_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|IXGBE_TX_LOCK_DESTROY
argument_list|(
name|txr
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|adapter
operator|->
name|tx_rings
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
comment|/*********************************************************************  *  *  Free transmit ring related data structures.  *  **********************************************************************/
specifier|static
name|void
name|ixgbe_free_transmit_buffers
parameter_list|(
name|struct
name|tx_ring
modifier|*
name|txr
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|txr
operator|->
name|adapter
decl_stmt|;
name|struct
name|ixgbe_tx_buf
modifier|*
name|tx_buffer
decl_stmt|;
name|int
name|i
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixgbe_free_transmit_ring: begin"
argument_list|)
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|tx_buffers
operator|==
name|NULL
condition|)
return|return;
name|tx_buffer
operator|=
name|txr
operator|->
name|tx_buffers
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_tx_desc
condition|;
name|i
operator|++
operator|,
name|tx_buffer
operator|++
control|)
block|{
if|if
condition|(
name|tx_buffer
operator|->
name|m_head
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|tx_buffer
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|tx_buffer
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|tx_buffer
operator|->
name|m_head
argument_list|)
expr_stmt|;
name|tx_buffer
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|tx_buffer
operator|->
name|map
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|tx_buffer
operator|->
name|map
argument_list|)
expr_stmt|;
name|tx_buffer
operator|->
name|map
operator|=
name|NULL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|tx_buffer
operator|->
name|map
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|tx_buffer
operator|->
name|map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|tx_buffer
operator|->
name|map
argument_list|)
expr_stmt|;
name|tx_buffer
operator|->
name|map
operator|=
name|NULL
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|IXGBE_LEGACY_TX
if|if
condition|(
name|txr
operator|->
name|br
operator|!=
name|NULL
condition|)
name|buf_ring_free
argument_list|(
name|txr
operator|->
name|br
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|txr
operator|->
name|tx_buffers
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|txr
operator|->
name|tx_buffers
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|txr
operator|->
name|tx_buffers
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|txr
operator|->
name|txtag
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|txr
operator|->
name|txtag
argument_list|)
expr_stmt|;
name|txr
operator|->
name|txtag
operator|=
name|NULL
expr_stmt|;
block|}
return|return;
block|}
comment|/*********************************************************************  *  *  Advanced Context Descriptor setup for VLAN, CSUM or TSO  *  **********************************************************************/
specifier|static
name|int
name|ixgbe_tx_ctx_setup
parameter_list|(
name|struct
name|tx_ring
modifier|*
name|txr
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mp
parameter_list|,
name|u32
modifier|*
name|cmd_type_len
parameter_list|,
name|u32
modifier|*
name|olinfo_status
parameter_list|)
block|{
name|struct
name|ixgbe_adv_tx_context_desc
modifier|*
name|TXD
decl_stmt|;
name|struct
name|ether_vlan_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|u32
name|vlan_macip_lens
init|=
literal|0
decl_stmt|,
name|type_tucmd_mlhl
init|=
literal|0
decl_stmt|;
name|int
name|ehdrlen
decl_stmt|,
name|ip_hlen
init|=
literal|0
decl_stmt|;
name|u16
name|etype
decl_stmt|;
name|u8
name|ipproto
init|=
literal|0
decl_stmt|;
name|int
name|offload
init|=
name|TRUE
decl_stmt|;
name|int
name|ctxd
init|=
name|txr
operator|->
name|next_avail_desc
decl_stmt|;
name|u16
name|vtag
init|=
literal|0
decl_stmt|;
comment|/* First check if TSO is to be used */
if|if
condition|(
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TSO
condition|)
return|return
operator|(
name|ixgbe_tso_setup
argument_list|(
name|txr
argument_list|,
name|mp
argument_list|,
name|cmd_type_len
argument_list|,
name|olinfo_status
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_OFFLOAD
operator|)
operator|==
literal|0
condition|)
name|offload
operator|=
name|FALSE
expr_stmt|;
comment|/* Indicate the whole packet as payload when not doing TSO */
operator|*
name|olinfo_status
operator||=
name|mp
operator|->
name|m_pkthdr
operator|.
name|len
operator|<<
name|IXGBE_ADVTXD_PAYLEN_SHIFT
expr_stmt|;
comment|/* Now ready a context descriptor */
name|TXD
operator|=
operator|(
expr|struct
name|ixgbe_adv_tx_context_desc
operator|*
operator|)
operator|&
name|txr
operator|->
name|tx_base
index|[
name|ctxd
index|]
expr_stmt|;
comment|/* 	** In advanced descriptors the vlan tag must  	** be placed into the context descriptor. Hence 	** we need to make one even if not doing offloads. 	*/
if|if
condition|(
name|mp
operator|->
name|m_flags
operator|&
name|M_VLANTAG
condition|)
block|{
name|vtag
operator|=
name|htole16
argument_list|(
name|mp
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
argument_list|)
expr_stmt|;
name|vlan_macip_lens
operator||=
operator|(
name|vtag
operator|<<
name|IXGBE_ADVTXD_VLAN_SHIFT
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|offload
operator|==
name|FALSE
condition|)
comment|/* ... no offload to do */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Determine where frame payload starts. 	 * Jump over vlan headers if already present, 	 * helpful for QinQ too. 	 */
name|eh
operator|=
name|mtod
argument_list|(
name|mp
argument_list|,
expr|struct
name|ether_vlan_header
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|evl_encap_proto
operator|==
name|htons
argument_list|(
name|ETHERTYPE_VLAN
argument_list|)
condition|)
block|{
name|etype
operator|=
name|ntohs
argument_list|(
name|eh
operator|->
name|evl_proto
argument_list|)
expr_stmt|;
name|ehdrlen
operator|=
name|ETHER_HDR_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
block|}
else|else
block|{
name|etype
operator|=
name|ntohs
argument_list|(
name|eh
operator|->
name|evl_encap_proto
argument_list|)
expr_stmt|;
name|ehdrlen
operator|=
name|ETHER_HDR_LEN
expr_stmt|;
block|}
comment|/* Set the ether header length */
name|vlan_macip_lens
operator||=
name|ehdrlen
operator|<<
name|IXGBE_ADVTXD_MACLEN_SHIFT
expr_stmt|;
switch|switch
condition|(
name|etype
condition|)
block|{
case|case
name|ETHERTYPE_IP
case|:
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|mp
operator|->
name|m_data
operator|+
name|ehdrlen
operator|)
expr_stmt|;
name|ip_hlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
name|ipproto
operator|=
name|ip
operator|->
name|ip_p
expr_stmt|;
name|type_tucmd_mlhl
operator||=
name|IXGBE_ADVTXD_TUCMD_IPV4
expr_stmt|;
break|break;
case|case
name|ETHERTYPE_IPV6
case|:
name|ip6
operator|=
operator|(
expr|struct
name|ip6_hdr
operator|*
operator|)
operator|(
name|mp
operator|->
name|m_data
operator|+
name|ehdrlen
operator|)
expr_stmt|;
name|ip_hlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
expr_stmt|;
comment|/* XXX-BZ this will go badly in case of ext hdrs. */
name|ipproto
operator|=
name|ip6
operator|->
name|ip6_nxt
expr_stmt|;
name|type_tucmd_mlhl
operator||=
name|IXGBE_ADVTXD_TUCMD_IPV6
expr_stmt|;
break|break;
default|default:
name|offload
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
name|vlan_macip_lens
operator||=
name|ip_hlen
expr_stmt|;
name|type_tucmd_mlhl
operator||=
name|IXGBE_ADVTXD_DCMD_DEXT
operator||
name|IXGBE_ADVTXD_DTYP_CTXT
expr_stmt|;
switch|switch
condition|(
name|ipproto
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
if|if
condition|(
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TCP
condition|)
name|type_tucmd_mlhl
operator||=
name|IXGBE_ADVTXD_TUCMD_L4T_TCP
expr_stmt|;
break|break;
case|case
name|IPPROTO_UDP
case|:
if|if
condition|(
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_UDP
condition|)
name|type_tucmd_mlhl
operator||=
name|IXGBE_ADVTXD_TUCMD_L4T_UDP
expr_stmt|;
break|break;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800000
case|case
name|IPPROTO_SCTP
case|:
if|if
condition|(
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_SCTP
condition|)
name|type_tucmd_mlhl
operator||=
name|IXGBE_ADVTXD_TUCMD_L4T_SCTP
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|offload
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|offload
condition|)
comment|/* For the TX descriptor setup */
operator|*
name|olinfo_status
operator||=
name|IXGBE_TXD_POPTS_TXSM
operator|<<
literal|8
expr_stmt|;
comment|/* Now copy bits into descriptor */
name|TXD
operator|->
name|vlan_macip_lens
operator|=
name|htole32
argument_list|(
name|vlan_macip_lens
argument_list|)
expr_stmt|;
name|TXD
operator|->
name|type_tucmd_mlhl
operator|=
name|htole32
argument_list|(
name|type_tucmd_mlhl
argument_list|)
expr_stmt|;
name|TXD
operator|->
name|seqnum_seed
operator|=
name|htole32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|TXD
operator|->
name|mss_l4len_idx
operator|=
name|htole32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* We've consumed the first desc, adjust counters */
if|if
condition|(
operator|++
name|ctxd
operator|==
name|txr
operator|->
name|num_desc
condition|)
name|ctxd
operator|=
literal|0
expr_stmt|;
name|txr
operator|->
name|next_avail_desc
operator|=
name|ctxd
expr_stmt|;
operator|--
name|txr
operator|->
name|tx_avail
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/**********************************************************************  *  *  Setup work for hardware segmentation offload (TSO) on  *  adapters using advanced tx descriptors  *  **********************************************************************/
specifier|static
name|int
name|ixgbe_tso_setup
parameter_list|(
name|struct
name|tx_ring
modifier|*
name|txr
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mp
parameter_list|,
name|u32
modifier|*
name|cmd_type_len
parameter_list|,
name|u32
modifier|*
name|olinfo_status
parameter_list|)
block|{
name|struct
name|ixgbe_adv_tx_context_desc
modifier|*
name|TXD
decl_stmt|;
name|u32
name|vlan_macip_lens
init|=
literal|0
decl_stmt|,
name|type_tucmd_mlhl
init|=
literal|0
decl_stmt|;
name|u32
name|mss_l4len_idx
init|=
literal|0
decl_stmt|,
name|paylen
decl_stmt|;
name|u16
name|vtag
init|=
literal|0
decl_stmt|,
name|eh_type
decl_stmt|;
name|int
name|ctxd
decl_stmt|,
name|ehdrlen
decl_stmt|,
name|ip_hlen
decl_stmt|,
name|tcp_hlen
decl_stmt|;
name|struct
name|ether_vlan_header
modifier|*
name|eh
decl_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
endif|#
directive|endif
name|struct
name|tcphdr
modifier|*
name|th
decl_stmt|;
comment|/* 	 * Determine where frame payload starts. 	 * Jump over vlan headers if already present 	 */
name|eh
operator|=
name|mtod
argument_list|(
name|mp
argument_list|,
expr|struct
name|ether_vlan_header
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|evl_encap_proto
operator|==
name|htons
argument_list|(
name|ETHERTYPE_VLAN
argument_list|)
condition|)
block|{
name|ehdrlen
operator|=
name|ETHER_HDR_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
name|eh_type
operator|=
name|eh
operator|->
name|evl_proto
expr_stmt|;
block|}
else|else
block|{
name|ehdrlen
operator|=
name|ETHER_HDR_LEN
expr_stmt|;
name|eh_type
operator|=
name|eh
operator|->
name|evl_encap_proto
expr_stmt|;
block|}
switch|switch
condition|(
name|ntohs
argument_list|(
name|eh_type
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
case|case
name|ETHERTYPE_IPV6
case|:
name|ip6
operator|=
operator|(
expr|struct
name|ip6_hdr
operator|*
operator|)
operator|(
name|mp
operator|->
name|m_data
operator|+
name|ehdrlen
operator|)
expr_stmt|;
comment|/* XXX-BZ For now we do not pretend to support ext. hdrs. */
if|if
condition|(
name|ip6
operator|->
name|ip6_nxt
operator|!=
name|IPPROTO_TCP
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|ip_hlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
expr_stmt|;
name|ip6
operator|=
operator|(
expr|struct
name|ip6_hdr
operator|*
operator|)
operator|(
name|mp
operator|->
name|m_data
operator|+
name|ehdrlen
operator|)
expr_stmt|;
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip6
operator|+
name|ip_hlen
operator|)
expr_stmt|;
name|th
operator|->
name|th_sum
operator|=
name|in6_cksum_pseudo
argument_list|(
name|ip6
argument_list|,
literal|0
argument_list|,
name|IPPROTO_TCP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|type_tucmd_mlhl
operator||=
name|IXGBE_ADVTXD_TUCMD_IPV6
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET
case|case
name|ETHERTYPE_IP
case|:
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|mp
operator|->
name|m_data
operator|+
name|ehdrlen
operator|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_p
operator|!=
name|IPPROTO_TCP
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|ip
operator|->
name|ip_sum
operator|=
literal|0
expr_stmt|;
name|ip_hlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip
operator|+
name|ip_hlen
operator|)
expr_stmt|;
name|th
operator|->
name|th_sum
operator|=
name|in_pseudo
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|,
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|,
name|htons
argument_list|(
name|IPPROTO_TCP
argument_list|)
argument_list|)
expr_stmt|;
name|type_tucmd_mlhl
operator||=
name|IXGBE_ADVTXD_TUCMD_IPV4
expr_stmt|;
comment|/* Tell transmit desc to also do IPv4 checksum. */
operator|*
name|olinfo_status
operator||=
name|IXGBE_TXD_POPTS_IXSM
operator|<<
literal|8
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|panic
argument_list|(
literal|"%s: CSUM_TSO but no supported IP version (0x%04x)"
argument_list|,
name|__func__
argument_list|,
name|ntohs
argument_list|(
name|eh_type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|ctxd
operator|=
name|txr
operator|->
name|next_avail_desc
expr_stmt|;
name|TXD
operator|=
operator|(
expr|struct
name|ixgbe_adv_tx_context_desc
operator|*
operator|)
operator|&
name|txr
operator|->
name|tx_base
index|[
name|ctxd
index|]
expr_stmt|;
name|tcp_hlen
operator|=
name|th
operator|->
name|th_off
operator|<<
literal|2
expr_stmt|;
comment|/* This is used in the transmit desc in encap */
name|paylen
operator|=
name|mp
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|ehdrlen
operator|-
name|ip_hlen
operator|-
name|tcp_hlen
expr_stmt|;
comment|/* VLAN MACLEN IPLEN */
if|if
condition|(
name|mp
operator|->
name|m_flags
operator|&
name|M_VLANTAG
condition|)
block|{
name|vtag
operator|=
name|htole16
argument_list|(
name|mp
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
argument_list|)
expr_stmt|;
name|vlan_macip_lens
operator||=
operator|(
name|vtag
operator|<<
name|IXGBE_ADVTXD_VLAN_SHIFT
operator|)
expr_stmt|;
block|}
name|vlan_macip_lens
operator||=
name|ehdrlen
operator|<<
name|IXGBE_ADVTXD_MACLEN_SHIFT
expr_stmt|;
name|vlan_macip_lens
operator||=
name|ip_hlen
expr_stmt|;
name|TXD
operator|->
name|vlan_macip_lens
operator|=
name|htole32
argument_list|(
name|vlan_macip_lens
argument_list|)
expr_stmt|;
comment|/* ADV DTYPE TUCMD */
name|type_tucmd_mlhl
operator||=
name|IXGBE_ADVTXD_DCMD_DEXT
operator||
name|IXGBE_ADVTXD_DTYP_CTXT
expr_stmt|;
name|type_tucmd_mlhl
operator||=
name|IXGBE_ADVTXD_TUCMD_L4T_TCP
expr_stmt|;
name|TXD
operator|->
name|type_tucmd_mlhl
operator|=
name|htole32
argument_list|(
name|type_tucmd_mlhl
argument_list|)
expr_stmt|;
comment|/* MSS L4LEN IDX */
name|mss_l4len_idx
operator||=
operator|(
name|mp
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
operator|<<
name|IXGBE_ADVTXD_MSS_SHIFT
operator|)
expr_stmt|;
name|mss_l4len_idx
operator||=
operator|(
name|tcp_hlen
operator|<<
name|IXGBE_ADVTXD_L4LEN_SHIFT
operator|)
expr_stmt|;
name|TXD
operator|->
name|mss_l4len_idx
operator|=
name|htole32
argument_list|(
name|mss_l4len_idx
argument_list|)
expr_stmt|;
name|TXD
operator|->
name|seqnum_seed
operator|=
name|htole32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|ctxd
operator|==
name|txr
operator|->
name|num_desc
condition|)
name|ctxd
operator|=
literal|0
expr_stmt|;
name|txr
operator|->
name|tx_avail
operator|--
expr_stmt|;
name|txr
operator|->
name|next_avail_desc
operator|=
name|ctxd
expr_stmt|;
operator|*
name|cmd_type_len
operator||=
name|IXGBE_ADVTXD_DCMD_TSE
expr_stmt|;
operator|*
name|olinfo_status
operator||=
name|IXGBE_TXD_POPTS_TXSM
operator|<<
literal|8
expr_stmt|;
operator|*
name|olinfo_status
operator||=
name|paylen
operator|<<
name|IXGBE_ADVTXD_PAYLEN_SHIFT
expr_stmt|;
operator|++
name|txr
operator|->
name|tso_tx
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|IXGBE_FDIR
comment|/* ** This routine parses packet headers so that Flow ** Director can make a hashed filter table entry  ** allowing traffic flows to be identified and kept ** on the same cpu.  This would be a performance ** hit, but we only do it at IXGBE_FDIR_RATE of ** packets. */
specifier|static
name|void
name|ixgbe_atr
parameter_list|(
name|struct
name|tx_ring
modifier|*
name|txr
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mp
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|txr
operator|->
name|adapter
decl_stmt|;
name|struct
name|ix_queue
modifier|*
name|que
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|th
decl_stmt|;
name|struct
name|udphdr
modifier|*
name|uh
decl_stmt|;
name|struct
name|ether_vlan_header
modifier|*
name|eh
decl_stmt|;
name|union
name|ixgbe_atr_hash_dword
name|input
init|=
block|{
operator|.
name|dword
operator|=
literal|0
block|}
decl_stmt|;
name|union
name|ixgbe_atr_hash_dword
name|common
init|=
block|{
operator|.
name|dword
operator|=
literal|0
block|}
decl_stmt|;
name|int
name|ehdrlen
decl_stmt|,
name|ip_hlen
decl_stmt|;
name|u16
name|etype
decl_stmt|;
name|eh
operator|=
name|mtod
argument_list|(
name|mp
argument_list|,
expr|struct
name|ether_vlan_header
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|evl_encap_proto
operator|==
name|htons
argument_list|(
name|ETHERTYPE_VLAN
argument_list|)
condition|)
block|{
name|ehdrlen
operator|=
name|ETHER_HDR_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
name|etype
operator|=
name|eh
operator|->
name|evl_proto
expr_stmt|;
block|}
else|else
block|{
name|ehdrlen
operator|=
name|ETHER_HDR_LEN
expr_stmt|;
name|etype
operator|=
name|eh
operator|->
name|evl_encap_proto
expr_stmt|;
block|}
comment|/* Only handling IPv4 */
if|if
condition|(
name|etype
operator|!=
name|htons
argument_list|(
name|ETHERTYPE_IP
argument_list|)
condition|)
return|return;
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|mp
operator|->
name|m_data
operator|+
name|ehdrlen
operator|)
expr_stmt|;
name|ip_hlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
comment|/* check if we're UDP or TCP */
switch|switch
condition|(
name|ip
operator|->
name|ip_p
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip
operator|+
name|ip_hlen
operator|)
expr_stmt|;
comment|/* src and dst are inverted */
name|common
operator|.
name|port
operator|.
name|dst
operator|^=
name|th
operator|->
name|th_sport
expr_stmt|;
name|common
operator|.
name|port
operator|.
name|src
operator|^=
name|th
operator|->
name|th_dport
expr_stmt|;
name|input
operator|.
name|formatted
operator|.
name|flow_type
operator|^=
name|IXGBE_ATR_FLOW_TYPE_TCPV4
expr_stmt|;
break|break;
case|case
name|IPPROTO_UDP
case|:
name|uh
operator|=
operator|(
expr|struct
name|udphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip
operator|+
name|ip_hlen
operator|)
expr_stmt|;
comment|/* src and dst are inverted */
name|common
operator|.
name|port
operator|.
name|dst
operator|^=
name|uh
operator|->
name|uh_sport
expr_stmt|;
name|common
operator|.
name|port
operator|.
name|src
operator|^=
name|uh
operator|->
name|uh_dport
expr_stmt|;
name|input
operator|.
name|formatted
operator|.
name|flow_type
operator|^=
name|IXGBE_ATR_FLOW_TYPE_UDPV4
expr_stmt|;
break|break;
default|default:
return|return;
block|}
name|input
operator|.
name|formatted
operator|.
name|vlan_id
operator|=
name|htobe16
argument_list|(
name|mp
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
condition|)
name|common
operator|.
name|flex_bytes
operator|^=
name|htons
argument_list|(
name|ETHERTYPE_VLAN
argument_list|)
expr_stmt|;
else|else
name|common
operator|.
name|flex_bytes
operator|^=
name|etype
expr_stmt|;
name|common
operator|.
name|ip
operator|^=
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
operator|^
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
expr_stmt|;
name|que
operator|=
operator|&
name|adapter
operator|->
name|queues
index|[
name|txr
operator|->
name|me
index|]
expr_stmt|;
comment|/* 	** This assumes the Rx queue and Tx 	** queue are bound to the same CPU 	*/
name|ixgbe_fdir_add_signature_filter_82599
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|input
argument_list|,
name|common
argument_list|,
name|que
operator|->
name|msix
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* IXGBE_FDIR */
comment|/**********************************************************************  *  *  Examine each tx_buffer in the used queue. If the hardware is done  *  processing the packet then free associated resources. The  *  tx_buffer is put back on the free queue.  *  **********************************************************************/
specifier|static
name|void
name|ixgbe_txeof
parameter_list|(
name|struct
name|tx_ring
modifier|*
name|txr
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|txr
operator|->
name|adapter
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|u32
name|work
decl_stmt|,
name|processed
init|=
literal|0
decl_stmt|;
name|u16
name|limit
init|=
name|txr
operator|->
name|process_limit
decl_stmt|;
name|struct
name|ixgbe_tx_buf
modifier|*
name|buf
decl_stmt|;
name|union
name|ixgbe_adv_tx_desc
modifier|*
name|txd
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|txr
operator|->
name|tx_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_NETMAP
condition|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|na
operator|->
name|tx_rings
index|[
name|txr
operator|->
name|me
index|]
decl_stmt|;
name|txd
operator|=
name|txr
operator|->
name|tx_base
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|txdma
operator|.
name|dma_tag
argument_list|,
name|txr
operator|->
name|txdma
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
comment|/* 		 * In netmap mode, all the work is done in the context 		 * of the client thread. Interrupt handlers only wake up 		 * clients, which may be sleeping on individual rings 		 * or on a global resource for all rings. 		 * To implement tx interrupt mitigation, we wake up the client 		 * thread roughly every half ring, even if the NIC interrupts 		 * more frequently. This is implemented as follows: 		 * - ixgbe_txsync() sets kring->nr_kflags with the index of 		 *   the slot that should wake up the thread (nkr_num_slots 		 *   means the user thread should not be woken up); 		 * - the driver ignores tx interrupts unless netmap_mitigate=0 		 *   or the slot has the DD bit set. 		 * 		 * When the driver has separate locks, we need to 		 * release and re-acquire txlock to avoid deadlocks. 		 * XXX see if we can find a better way. 		 */
if|if
condition|(
operator|!
name|netmap_mitigate
operator|||
operator|(
name|kring
operator|->
name|nr_kflags
operator|<
name|kring
operator|->
name|nkr_num_slots
operator|&&
name|txd
index|[
name|kring
operator|->
name|nr_kflags
index|]
operator|.
name|wb
operator|.
name|status
operator|&
name|IXGBE_TXD_STAT_DD
operator|)
condition|)
block|{
name|netmap_tx_irq
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|me
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
endif|#
directive|endif
comment|/* DEV_NETMAP */
if|if
condition|(
name|txr
operator|->
name|tx_avail
operator|==
name|txr
operator|->
name|num_desc
condition|)
block|{
name|txr
operator|->
name|queue_status
operator|=
name|IXGBE_QUEUE_IDLE
expr_stmt|;
return|return;
block|}
comment|/* Get work starting point */
name|work
operator|=
name|txr
operator|->
name|next_to_clean
expr_stmt|;
name|buf
operator|=
operator|&
name|txr
operator|->
name|tx_buffers
index|[
name|work
index|]
expr_stmt|;
name|txd
operator|=
operator|&
name|txr
operator|->
name|tx_base
index|[
name|work
index|]
expr_stmt|;
name|work
operator|-=
name|txr
operator|->
name|num_desc
expr_stmt|;
comment|/* The distance to ring end */
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|txdma
operator|.
name|dma_tag
argument_list|,
name|txr
operator|->
name|txdma
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
do|do
block|{
name|union
name|ixgbe_adv_tx_desc
modifier|*
name|eop
init|=
name|buf
operator|->
name|eop
decl_stmt|;
if|if
condition|(
name|eop
operator|==
name|NULL
condition|)
comment|/* No work */
break|break;
if|if
condition|(
operator|(
name|eop
operator|->
name|wb
operator|.
name|status
operator|&
name|IXGBE_TXD_STAT_DD
operator|)
operator|==
literal|0
condition|)
break|break;
comment|/* I/O not complete */
if|if
condition|(
name|buf
operator|->
name|m_head
condition|)
block|{
name|txr
operator|->
name|bytes
operator|+=
name|buf
operator|->
name|m_head
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|buf
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|buf
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|buf
operator|->
name|m_head
argument_list|)
expr_stmt|;
name|buf
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|map
operator|=
name|NULL
expr_stmt|;
block|}
name|buf
operator|->
name|eop
operator|=
name|NULL
expr_stmt|;
operator|++
name|txr
operator|->
name|tx_avail
expr_stmt|;
comment|/* We clean the range if multi segment */
while|while
condition|(
name|txd
operator|!=
name|eop
condition|)
block|{
operator|++
name|txd
expr_stmt|;
operator|++
name|buf
expr_stmt|;
operator|++
name|work
expr_stmt|;
comment|/* wrap the ring? */
if|if
condition|(
name|__predict_false
argument_list|(
operator|!
name|work
argument_list|)
condition|)
block|{
name|work
operator|-=
name|txr
operator|->
name|num_desc
expr_stmt|;
name|buf
operator|=
name|txr
operator|->
name|tx_buffers
expr_stmt|;
name|txd
operator|=
name|txr
operator|->
name|tx_base
expr_stmt|;
block|}
if|if
condition|(
name|buf
operator|->
name|m_head
condition|)
block|{
name|txr
operator|->
name|bytes
operator|+=
name|buf
operator|->
name|m_head
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|buf
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|buf
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|buf
operator|->
name|m_head
argument_list|)
expr_stmt|;
name|buf
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|map
operator|=
name|NULL
expr_stmt|;
block|}
operator|++
name|txr
operator|->
name|tx_avail
expr_stmt|;
name|buf
operator|->
name|eop
operator|=
name|NULL
expr_stmt|;
block|}
operator|++
name|txr
operator|->
name|packets
expr_stmt|;
operator|++
name|processed
expr_stmt|;
operator|++
name|ifp
operator|->
name|if_opackets
expr_stmt|;
name|txr
operator|->
name|watchdog_time
operator|=
name|ticks
expr_stmt|;
comment|/* Try the next packet */
operator|++
name|txd
expr_stmt|;
operator|++
name|buf
expr_stmt|;
operator|++
name|work
expr_stmt|;
comment|/* reset with a wrap */
if|if
condition|(
name|__predict_false
argument_list|(
operator|!
name|work
argument_list|)
condition|)
block|{
name|work
operator|-=
name|txr
operator|->
name|num_desc
expr_stmt|;
name|buf
operator|=
name|txr
operator|->
name|tx_buffers
expr_stmt|;
name|txd
operator|=
name|txr
operator|->
name|tx_base
expr_stmt|;
block|}
name|prefetch
argument_list|(
name|txd
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|__predict_true
argument_list|(
operator|--
name|limit
argument_list|)
condition|)
do|;
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|txdma
operator|.
name|dma_tag
argument_list|,
name|txr
operator|->
name|txdma
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|work
operator|+=
name|txr
operator|->
name|num_desc
expr_stmt|;
name|txr
operator|->
name|next_to_clean
operator|=
name|work
expr_stmt|;
comment|/* 	** Watchdog calculation, we know there's 	** work outstanding or the first return 	** would have been taken, so none processed 	** for too long indicates a hang. 	*/
if|if
condition|(
operator|(
operator|!
name|processed
operator|)
operator|&&
operator|(
operator|(
name|ticks
operator|-
name|txr
operator|->
name|watchdog_time
operator|)
operator|>
name|IXGBE_WATCHDOG
operator|)
condition|)
name|txr
operator|->
name|queue_status
operator|=
name|IXGBE_QUEUE_HUNG
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|tx_avail
operator|==
name|txr
operator|->
name|num_desc
condition|)
name|txr
operator|->
name|queue_status
operator|=
name|IXGBE_QUEUE_IDLE
expr_stmt|;
return|return;
block|}
comment|/*********************************************************************  *  *  Refresh mbuf buffers for RX descriptor rings  *   - now keeps its own state so discards due to resource  *     exhaustion are unnecessary, if an mbuf cannot be obtained  *     it just returns, keeping its placeholder, thus it can simply  *     be recalled to try again.  *  **********************************************************************/
specifier|static
name|void
name|ixgbe_refresh_mbufs
parameter_list|(
name|struct
name|rx_ring
modifier|*
name|rxr
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|rxr
operator|->
name|adapter
decl_stmt|;
name|bus_dma_segment_t
name|seg
index|[
literal|1
index|]
decl_stmt|;
name|struct
name|ixgbe_rx_buf
modifier|*
name|rxbuf
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|nsegs
decl_stmt|,
name|error
decl_stmt|;
name|bool
name|refreshed
init|=
name|FALSE
decl_stmt|;
name|i
operator|=
name|j
operator|=
name|rxr
operator|->
name|next_to_refresh
expr_stmt|;
comment|/* Control the loop with one beyond */
if|if
condition|(
operator|++
name|j
operator|==
name|rxr
operator|->
name|num_desc
condition|)
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|j
operator|!=
name|limit
condition|)
block|{
name|rxbuf
operator|=
operator|&
name|rxr
operator|->
name|rx_buffers
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|rxbuf
operator|->
name|buf
operator|==
name|NULL
condition|)
block|{
name|mp
operator|=
name|m_getjcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|,
name|rxr
operator|->
name|mbuf_sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|==
name|NULL
condition|)
goto|goto
name|update
goto|;
if|if
condition|(
name|adapter
operator|->
name|max_frame_size
operator|<=
operator|(
name|MCLBYTES
operator|-
name|ETHER_ALIGN
operator|)
condition|)
name|m_adj
argument_list|(
name|mp
argument_list|,
name|ETHER_ALIGN
argument_list|)
expr_stmt|;
block|}
else|else
name|mp
operator|=
name|rxbuf
operator|->
name|buf
expr_stmt|;
name|mp
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|mp
operator|->
name|m_len
operator|=
name|rxr
operator|->
name|mbuf_sz
expr_stmt|;
comment|/* If we're dealing with an mbuf that was copied rather 		 * than replaced, there's no need to go through busdma. 		 */
if|if
condition|(
operator|(
name|rxbuf
operator|->
name|flags
operator|&
name|IXGBE_RX_COPY
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Get the memory mapping */
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|rxr
operator|->
name|ptag
argument_list|,
name|rxbuf
operator|->
name|pmap
argument_list|,
name|mp
argument_list|,
name|seg
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Refresh mbufs: payload dmamap load"
literal|" failure - %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|rxbuf
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
goto|goto
name|update
goto|;
block|}
name|rxbuf
operator|->
name|buf
operator|=
name|mp
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|rxr
operator|->
name|ptag
argument_list|,
name|rxbuf
operator|->
name|pmap
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|rxbuf
operator|->
name|addr
operator|=
name|rxr
operator|->
name|rx_base
index|[
name|i
index|]
operator|.
name|read
operator|.
name|pkt_addr
operator|=
name|htole64
argument_list|(
name|seg
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rxr
operator|->
name|rx_base
index|[
name|i
index|]
operator|.
name|read
operator|.
name|pkt_addr
operator|=
name|rxbuf
operator|->
name|addr
expr_stmt|;
name|rxbuf
operator|->
name|flags
operator|&=
operator|~
name|IXGBE_RX_COPY
expr_stmt|;
block|}
name|refreshed
operator|=
name|TRUE
expr_stmt|;
comment|/* Next is precalculated */
name|i
operator|=
name|j
expr_stmt|;
name|rxr
operator|->
name|next_to_refresh
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|++
name|j
operator|==
name|rxr
operator|->
name|num_desc
condition|)
name|j
operator|=
literal|0
expr_stmt|;
block|}
name|update
label|:
if|if
condition|(
name|refreshed
condition|)
comment|/* Update hardware tail index */
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_RDT
argument_list|(
name|rxr
operator|->
name|me
argument_list|)
argument_list|,
name|rxr
operator|->
name|next_to_refresh
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*********************************************************************  *  *  Allocate memory for rx_buffer structures. Since we use one  *  rx_buffer per received packet, the maximum number of rx_buffer's  *  that we'll need is equal to the number of receive descriptors  *  that we've allocated.  *  **********************************************************************/
specifier|static
name|int
name|ixgbe_allocate_receive_buffers
parameter_list|(
name|struct
name|rx_ring
modifier|*
name|rxr
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|rxr
operator|->
name|adapter
decl_stmt|;
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|struct
name|ixgbe_rx_buf
modifier|*
name|rxbuf
decl_stmt|;
name|int
name|i
decl_stmt|,
name|bsize
decl_stmt|,
name|error
decl_stmt|;
name|bsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ixgbe_rx_buf
argument_list|)
operator|*
name|rxr
operator|->
name|num_desc
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|rxr
operator|->
name|rx_buffers
operator|=
operator|(
expr|struct
name|ixgbe_rx_buf
operator|*
operator|)
name|malloc
argument_list|(
name|bsize
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate rx_buffer memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* alignment, bounds */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|MJUM16BYTES
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|MJUM16BYTES
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lockfunc */
name|NULL
argument_list|,
comment|/* lockfuncarg */
operator|&
name|rxr
operator|->
name|ptag
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to create RX DMA tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rxr
operator|->
name|num_desc
condition|;
name|i
operator|++
operator|,
name|rxbuf
operator|++
control|)
block|{
name|rxbuf
operator|=
operator|&
name|rxr
operator|->
name|rx_buffers
index|[
name|i
index|]
expr_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|rxr
operator|->
name|ptag
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|rxbuf
operator|->
name|pmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to create RX dma map\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
comment|/* Frees all, but can handle partial completion */
name|ixgbe_free_receive_structures
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* ** Used to detect a descriptor that has ** been merged by Hardware RSC. */
specifier|static
specifier|inline
name|u32
name|ixgbe_rsc_count
parameter_list|(
name|union
name|ixgbe_adv_rx_desc
modifier|*
name|rx
parameter_list|)
block|{
return|return
operator|(
name|le32toh
argument_list|(
name|rx
operator|->
name|wb
operator|.
name|lower
operator|.
name|lo_dword
operator|.
name|data
argument_list|)
operator|&
name|IXGBE_RXDADV_RSCCNT_MASK
operator|)
operator|>>
name|IXGBE_RXDADV_RSCCNT_SHIFT
return|;
block|}
comment|/*********************************************************************  *  *  Initialize Hardware RSC (LRO) feature on 82599  *  for an RX ring, this is toggled by the LRO capability  *  even though it is transparent to the stack.  *  *  NOTE: since this HW feature only works with IPV4 and   *        our testing has shown soft LRO to be as effective  *        I have decided to disable this by default.  *  **********************************************************************/
specifier|static
name|void
name|ixgbe_setup_hw_rsc
parameter_list|(
name|struct
name|rx_ring
modifier|*
name|rxr
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|rxr
operator|->
name|adapter
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|u32
name|rscctrl
decl_stmt|,
name|rdrxctl
decl_stmt|;
comment|/* If turning LRO/RSC off we need to disable it */
if|if
condition|(
operator|(
name|adapter
operator|->
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_LRO
operator|)
operator|==
literal|0
condition|)
block|{
name|rscctrl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RSCCTL
argument_list|(
name|rxr
operator|->
name|me
argument_list|)
argument_list|)
expr_stmt|;
name|rscctrl
operator|&=
operator|~
name|IXGBE_RSCCTL_RSCEN
expr_stmt|;
return|return;
block|}
name|rdrxctl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RDRXCTL
argument_list|)
expr_stmt|;
name|rdrxctl
operator|&=
operator|~
name|IXGBE_RDRXCTL_RSCFRSTSIZE
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
comment|/* crcstrip is optional in netmap */
if|if
condition|(
name|adapter
operator|->
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_NETMAP
operator|&&
operator|!
name|ix_crcstrip
condition|)
endif|#
directive|endif
comment|/* DEV_NETMAP */
name|rdrxctl
operator||=
name|IXGBE_RDRXCTL_CRCSTRIP
expr_stmt|;
name|rdrxctl
operator||=
name|IXGBE_RDRXCTL_RSCACKC
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RDRXCTL
argument_list|,
name|rdrxctl
argument_list|)
expr_stmt|;
name|rscctrl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RSCCTL
argument_list|(
name|rxr
operator|->
name|me
argument_list|)
argument_list|)
expr_stmt|;
name|rscctrl
operator||=
name|IXGBE_RSCCTL_RSCEN
expr_stmt|;
comment|/* 	** Limit the total number of descriptors that 	** can be combined, so it does not exceed 64K 	*/
if|if
condition|(
name|rxr
operator|->
name|mbuf_sz
operator|==
name|MCLBYTES
condition|)
name|rscctrl
operator||=
name|IXGBE_RSCCTL_MAXDESC_16
expr_stmt|;
elseif|else
if|if
condition|(
name|rxr
operator|->
name|mbuf_sz
operator|==
name|MJUMPAGESIZE
condition|)
name|rscctrl
operator||=
name|IXGBE_RSCCTL_MAXDESC_8
expr_stmt|;
elseif|else
if|if
condition|(
name|rxr
operator|->
name|mbuf_sz
operator|==
name|MJUM9BYTES
condition|)
name|rscctrl
operator||=
name|IXGBE_RSCCTL_MAXDESC_4
expr_stmt|;
else|else
comment|/* Using 16K cluster */
name|rscctrl
operator||=
name|IXGBE_RSCCTL_MAXDESC_1
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RSCCTL
argument_list|(
name|rxr
operator|->
name|me
argument_list|)
argument_list|,
name|rscctrl
argument_list|)
expr_stmt|;
comment|/* Enable TCP header recognition */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PSRTYPE
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|(
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PSRTYPE
argument_list|(
literal|0
argument_list|)
argument_list|)
operator||
name|IXGBE_PSRTYPE_TCPHDR
operator|)
argument_list|)
expr_stmt|;
comment|/* Disable RSC for ACK packets */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RSCDBU
argument_list|,
operator|(
name|IXGBE_RSCDBU_RSCACKDIS
operator||
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RSCDBU
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|hw_rsc
operator|=
name|TRUE
expr_stmt|;
block|}
specifier|static
name|void
name|ixgbe_free_receive_ring
parameter_list|(
name|struct
name|rx_ring
modifier|*
name|rxr
parameter_list|)
block|{
name|struct
name|ixgbe_rx_buf
modifier|*
name|rxbuf
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rxr
operator|->
name|num_desc
condition|;
name|i
operator|++
control|)
block|{
name|rxbuf
operator|=
operator|&
name|rxr
operator|->
name|rx_buffers
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|rxbuf
operator|->
name|buf
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|rxr
operator|->
name|ptag
argument_list|,
name|rxbuf
operator|->
name|pmap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|rxr
operator|->
name|ptag
argument_list|,
name|rxbuf
operator|->
name|pmap
argument_list|)
expr_stmt|;
name|rxbuf
operator|->
name|buf
operator|->
name|m_flags
operator||=
name|M_PKTHDR
expr_stmt|;
name|m_freem
argument_list|(
name|rxbuf
operator|->
name|buf
argument_list|)
expr_stmt|;
name|rxbuf
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
name|rxbuf
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/*********************************************************************  *  *  Initialize a receive ring and its buffers.  *  **********************************************************************/
specifier|static
name|int
name|ixgbe_setup_receive_ring
parameter_list|(
name|struct
name|rx_ring
modifier|*
name|rxr
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|struct
name|ixgbe_rx_buf
modifier|*
name|rxbuf
decl_stmt|;
name|bus_dma_segment_t
name|seg
index|[
literal|1
index|]
decl_stmt|;
name|struct
name|lro_ctrl
modifier|*
name|lro
init|=
operator|&
name|rxr
operator|->
name|lro
decl_stmt|;
name|int
name|rsize
decl_stmt|,
name|nsegs
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|rxr
operator|->
name|adapter
operator|->
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|netmap_slot
modifier|*
name|slot
decl_stmt|;
endif|#
directive|endif
comment|/* DEV_NETMAP */
name|adapter
operator|=
name|rxr
operator|->
name|adapter
expr_stmt|;
name|ifp
operator|=
name|adapter
operator|->
name|ifp
expr_stmt|;
name|dev
operator|=
name|adapter
operator|->
name|dev
expr_stmt|;
comment|/* Clear the ring contents */
name|IXGBE_RX_LOCK
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
comment|/* same as in ixgbe_setup_transmit_ring() */
name|slot
operator|=
name|netmap_reset
argument_list|(
name|na
argument_list|,
name|NR_RX
argument_list|,
name|rxr
operator|->
name|me
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEV_NETMAP */
name|rsize
operator|=
name|roundup2
argument_list|(
name|adapter
operator|->
name|num_rx_desc
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|ixgbe_adv_rx_desc
argument_list|)
argument_list|,
name|DBA_ALIGN
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|rxr
operator|->
name|rx_base
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
comment|/* Cache the size */
name|rxr
operator|->
name|mbuf_sz
operator|=
name|adapter
operator|->
name|rx_mbuf_sz
expr_stmt|;
comment|/* Free current RX buffer structs and their mbufs */
name|ixgbe_free_receive_ring
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
comment|/* Now replenish the mbufs */
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|!=
name|rxr
operator|->
name|num_desc
condition|;
operator|++
name|j
control|)
block|{
name|struct
name|mbuf
modifier|*
name|mp
decl_stmt|;
name|rxbuf
operator|=
operator|&
name|rxr
operator|->
name|rx_buffers
index|[
name|j
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
comment|/* 		 * In netmap mode, fill the map and set the buffer 		 * address in the NIC ring, considering the offset 		 * between the netmap and NIC rings (see comment in 		 * ixgbe_setup_transmit_ring() ). No need to allocate 		 * an mbuf, so end the block with a continue; 		 */
if|if
condition|(
name|slot
condition|)
block|{
name|int
name|sj
init|=
name|netmap_idx_n2k
argument_list|(
operator|&
name|na
operator|->
name|rx_rings
index|[
name|rxr
operator|->
name|me
index|]
argument_list|,
name|j
argument_list|)
decl_stmt|;
name|uint64_t
name|paddr
decl_stmt|;
name|void
modifier|*
name|addr
decl_stmt|;
name|addr
operator|=
name|PNMB
argument_list|(
name|na
argument_list|,
name|slot
operator|+
name|sj
argument_list|,
operator|&
name|paddr
argument_list|)
expr_stmt|;
name|netmap_load_map
argument_list|(
name|na
argument_list|,
name|rxr
operator|->
name|ptag
argument_list|,
name|rxbuf
operator|->
name|pmap
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/* Update descriptor and the cached value */
name|rxr
operator|->
name|rx_base
index|[
name|j
index|]
operator|.
name|read
operator|.
name|pkt_addr
operator|=
name|htole64
argument_list|(
name|paddr
argument_list|)
expr_stmt|;
name|rxbuf
operator|->
name|addr
operator|=
name|htole64
argument_list|(
name|paddr
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
comment|/* DEV_NETMAP */
name|rxbuf
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|rxbuf
operator|->
name|buf
operator|=
name|m_getjcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|,
name|adapter
operator|->
name|rx_mbuf_sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|rxbuf
operator|->
name|buf
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|mp
operator|=
name|rxbuf
operator|->
name|buf
expr_stmt|;
name|mp
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|mp
operator|->
name|m_len
operator|=
name|rxr
operator|->
name|mbuf_sz
expr_stmt|;
comment|/* Get the memory mapping */
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|rxr
operator|->
name|ptag
argument_list|,
name|rxbuf
operator|->
name|pmap
argument_list|,
name|mp
argument_list|,
name|seg
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|bus_dmamap_sync
argument_list|(
name|rxr
operator|->
name|ptag
argument_list|,
name|rxbuf
operator|->
name|pmap
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
comment|/* Update the descriptor and the cached value */
name|rxr
operator|->
name|rx_base
index|[
name|j
index|]
operator|.
name|read
operator|.
name|pkt_addr
operator|=
name|htole64
argument_list|(
name|seg
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|rxbuf
operator|->
name|addr
operator|=
name|htole64
argument_list|(
name|seg
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
block|}
comment|/* Setup our descriptor indices */
name|rxr
operator|->
name|next_to_check
operator|=
literal|0
expr_stmt|;
name|rxr
operator|->
name|next_to_refresh
operator|=
literal|0
expr_stmt|;
name|rxr
operator|->
name|lro_enabled
operator|=
name|FALSE
expr_stmt|;
name|rxr
operator|->
name|rx_copies
operator|=
literal|0
expr_stmt|;
name|rxr
operator|->
name|rx_bytes
operator|=
literal|0
expr_stmt|;
name|rxr
operator|->
name|vtag_strip
operator|=
name|FALSE
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|rxr
operator|->
name|rxdma
operator|.
name|dma_tag
argument_list|,
name|rxr
operator|->
name|rxdma
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* 	** Now set up the LRO interface: 	*/
if|if
condition|(
name|ixgbe_rsc_enable
condition|)
name|ixgbe_setup_hw_rsc
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_LRO
condition|)
block|{
name|int
name|err
init|=
name|tcp_lro_init
argument_list|(
name|lro
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"LRO Initialization failed!\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|INIT_DEBUGOUT
argument_list|(
literal|"RX Soft LRO Initialized\n"
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|lro_enabled
operator|=
name|TRUE
expr_stmt|;
name|lro
operator|->
name|ifp
operator|=
name|adapter
operator|->
name|ifp
expr_stmt|;
block|}
name|IXGBE_RX_UNLOCK
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|ixgbe_free_receive_ring
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
name|IXGBE_RX_UNLOCK
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/*********************************************************************  *  *  Initialize all receive rings.  *  **********************************************************************/
specifier|static
name|int
name|ixgbe_setup_receive_structures
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
name|adapter
operator|->
name|rx_rings
decl_stmt|;
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|j
operator|++
operator|,
name|rxr
operator|++
control|)
if|if
condition|(
name|ixgbe_setup_receive_ring
argument_list|(
name|rxr
argument_list|)
condition|)
goto|goto
name|fail
goto|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
comment|/* 	 * Free RX buffers allocated so far, we will only handle 	 * the rings that completed, the failing case will have 	 * cleaned up for itself. 'j' failed, so its the terminus. 	 */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|j
condition|;
operator|++
name|i
control|)
block|{
name|rxr
operator|=
operator|&
name|adapter
operator|->
name|rx_rings
index|[
name|i
index|]
expr_stmt|;
name|ixgbe_free_receive_ring
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
comment|/*********************************************************************  *  *  Setup receive registers and features.  *  **********************************************************************/
define|#
directive|define
name|IXGBE_SRRCTL_BSIZEHDRSIZE_SHIFT
value|2
define|#
directive|define
name|BSIZEPKT_ROUNDUP
value|((1<<IXGBE_SRRCTL_BSIZEPKT_SHIFT)-1)
specifier|static
name|void
name|ixgbe_initialize_receive_units
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
name|adapter
operator|->
name|rx_rings
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|u32
name|bufsz
decl_stmt|,
name|rxctrl
decl_stmt|,
name|fctrl
decl_stmt|,
name|srrctl
decl_stmt|,
name|rxcsum
decl_stmt|;
name|u32
name|reta
decl_stmt|,
name|mrqc
init|=
literal|0
decl_stmt|,
name|hlreg
decl_stmt|,
name|random
index|[
literal|10
index|]
decl_stmt|;
comment|/* 	 * Make sure receives are disabled while 	 * setting up the descriptor ring 	 */
name|rxctrl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXCTRL
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXCTRL
argument_list|,
name|rxctrl
operator|&
operator|~
name|IXGBE_RXCTRL_RXEN
argument_list|)
expr_stmt|;
comment|/* Enable broadcasts */
name|fctrl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCTRL
argument_list|)
expr_stmt|;
name|fctrl
operator||=
name|IXGBE_FCTRL_BAM
expr_stmt|;
name|fctrl
operator||=
name|IXGBE_FCTRL_DPF
expr_stmt|;
name|fctrl
operator||=
name|IXGBE_FCTRL_PMCF
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCTRL
argument_list|,
name|fctrl
argument_list|)
expr_stmt|;
comment|/* Set for Jumbo Frames? */
name|hlreg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_HLREG0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_mtu
operator|>
name|ETHERMTU
condition|)
name|hlreg
operator||=
name|IXGBE_HLREG0_JUMBOEN
expr_stmt|;
else|else
name|hlreg
operator|&=
operator|~
name|IXGBE_HLREG0_JUMBOEN
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
comment|/* crcstrip is conditional in netmap (in RDRXCTL too ?) */
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_NETMAP
operator|&&
operator|!
name|ix_crcstrip
condition|)
name|hlreg
operator|&=
operator|~
name|IXGBE_HLREG0_RXCRCSTRP
expr_stmt|;
else|else
name|hlreg
operator||=
name|IXGBE_HLREG0_RXCRCSTRP
expr_stmt|;
endif|#
directive|endif
comment|/* DEV_NETMAP */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_HLREG0
argument_list|,
name|hlreg
argument_list|)
expr_stmt|;
name|bufsz
operator|=
operator|(
name|adapter
operator|->
name|rx_mbuf_sz
operator|+
name|BSIZEPKT_ROUNDUP
operator|)
operator|>>
name|IXGBE_SRRCTL_BSIZEPKT_SHIFT
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|rxr
operator|++
control|)
block|{
name|u64
name|rdba
init|=
name|rxr
operator|->
name|rxdma
operator|.
name|dma_paddr
decl_stmt|;
comment|/* Setup the Base and Length of the Rx Descriptor Ring */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RDBAL
argument_list|(
name|i
argument_list|)
argument_list|,
operator|(
name|rdba
operator|&
literal|0x00000000ffffffffULL
operator|)
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RDBAH
argument_list|(
name|i
argument_list|)
argument_list|,
operator|(
name|rdba
operator|>>
literal|32
operator|)
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RDLEN
argument_list|(
name|i
argument_list|)
argument_list|,
name|adapter
operator|->
name|num_rx_desc
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|ixgbe_adv_rx_desc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set up the SRRCTL register */
name|srrctl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SRRCTL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|srrctl
operator|&=
operator|~
name|IXGBE_SRRCTL_BSIZEHDR_MASK
expr_stmt|;
name|srrctl
operator|&=
operator|~
name|IXGBE_SRRCTL_BSIZEPKT_MASK
expr_stmt|;
name|srrctl
operator||=
name|bufsz
expr_stmt|;
name|srrctl
operator||=
name|IXGBE_SRRCTL_DESCTYPE_ADV_ONEBUF
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SRRCTL
argument_list|(
name|i
argument_list|)
argument_list|,
name|srrctl
argument_list|)
expr_stmt|;
comment|/* Setup the HW Rx Head and Tail Descriptor Pointers */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RDH
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RDT
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set the processing limit */
name|rxr
operator|->
name|process_limit
operator|=
name|ixgbe_rx_process_limit
expr_stmt|;
block|}
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|!=
name|ixgbe_mac_82598EB
condition|)
block|{
name|u32
name|psrtype
init|=
name|IXGBE_PSRTYPE_TCPHDR
operator||
name|IXGBE_PSRTYPE_UDPHDR
operator||
name|IXGBE_PSRTYPE_IPV4HDR
operator||
name|IXGBE_PSRTYPE_IPV6HDR
decl_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PSRTYPE
argument_list|(
literal|0
argument_list|)
argument_list|,
name|psrtype
argument_list|)
expr_stmt|;
block|}
name|rxcsum
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXCSUM
argument_list|)
expr_stmt|;
comment|/* Setup RSS */
if|if
condition|(
name|adapter
operator|->
name|num_queues
operator|>
literal|1
condition|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|reta
operator|=
literal|0
expr_stmt|;
comment|/* set up random bits */
name|arc4rand
argument_list|(
operator|&
name|random
argument_list|,
sizeof|sizeof
argument_list|(
name|random
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set up the redirection table */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
literal|128
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|==
name|adapter
operator|->
name|num_queues
condition|)
name|j
operator|=
literal|0
expr_stmt|;
name|reta
operator|=
operator|(
name|reta
operator|<<
literal|8
operator|)
operator||
operator|(
name|j
operator|*
literal|0x11
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|&
literal|3
operator|)
operator|==
literal|3
condition|)
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RETA
argument_list|(
name|i
operator|>>
literal|2
argument_list|)
argument_list|,
name|reta
argument_list|)
expr_stmt|;
block|}
comment|/* Now fill our hash function seeds */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RSSRK
argument_list|(
name|i
argument_list|)
argument_list|,
name|random
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Perform hash on these packet types */
name|mrqc
operator|=
name|IXGBE_MRQC_RSSEN
operator||
name|IXGBE_MRQC_RSS_FIELD_IPV4
operator||
name|IXGBE_MRQC_RSS_FIELD_IPV4_TCP
operator||
name|IXGBE_MRQC_RSS_FIELD_IPV4_UDP
operator||
name|IXGBE_MRQC_RSS_FIELD_IPV6_EX_TCP
operator||
name|IXGBE_MRQC_RSS_FIELD_IPV6_EX
operator||
name|IXGBE_MRQC_RSS_FIELD_IPV6
operator||
name|IXGBE_MRQC_RSS_FIELD_IPV6_TCP
operator||
name|IXGBE_MRQC_RSS_FIELD_IPV6_UDP
operator||
name|IXGBE_MRQC_RSS_FIELD_IPV6_EX_UDP
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MRQC
argument_list|,
name|mrqc
argument_list|)
expr_stmt|;
comment|/* RSS and RX IPP Checksum are mutually exclusive */
name|rxcsum
operator||=
name|IXGBE_RXCSUM_PCSD
expr_stmt|;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_RXCSUM
condition|)
name|rxcsum
operator||=
name|IXGBE_RXCSUM_PCSD
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|rxcsum
operator|&
name|IXGBE_RXCSUM_PCSD
operator|)
condition|)
name|rxcsum
operator||=
name|IXGBE_RXCSUM_IPPCSE
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXCSUM
argument_list|,
name|rxcsum
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*********************************************************************  *  *  Free all receive rings.  *  **********************************************************************/
specifier|static
name|void
name|ixgbe_free_receive_structures
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
name|adapter
operator|->
name|rx_rings
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixgbe_free_receive_structures: begin"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|rxr
operator|++
control|)
block|{
name|struct
name|lro_ctrl
modifier|*
name|lro
init|=
operator|&
name|rxr
operator|->
name|lro
decl_stmt|;
name|ixgbe_free_receive_buffers
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
comment|/* Free LRO memory */
name|tcp_lro_free
argument_list|(
name|lro
argument_list|)
expr_stmt|;
comment|/* Free the ring memory as well */
name|ixgbe_dma_free
argument_list|(
name|adapter
argument_list|,
operator|&
name|rxr
operator|->
name|rxdma
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|adapter
operator|->
name|rx_rings
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
comment|/*********************************************************************  *  *  Free receive ring data structures  *  **********************************************************************/
specifier|static
name|void
name|ixgbe_free_receive_buffers
parameter_list|(
name|struct
name|rx_ring
modifier|*
name|rxr
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|rxr
operator|->
name|adapter
decl_stmt|;
name|struct
name|ixgbe_rx_buf
modifier|*
name|rxbuf
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixgbe_free_receive_buffers: begin"
argument_list|)
expr_stmt|;
comment|/* Cleanup any existing buffers */
if|if
condition|(
name|rxr
operator|->
name|rx_buffers
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_rx_desc
condition|;
name|i
operator|++
control|)
block|{
name|rxbuf
operator|=
operator|&
name|rxr
operator|->
name|rx_buffers
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|rxbuf
operator|->
name|buf
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|rxr
operator|->
name|ptag
argument_list|,
name|rxbuf
operator|->
name|pmap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|rxr
operator|->
name|ptag
argument_list|,
name|rxbuf
operator|->
name|pmap
argument_list|)
expr_stmt|;
name|rxbuf
operator|->
name|buf
operator|->
name|m_flags
operator||=
name|M_PKTHDR
expr_stmt|;
name|m_freem
argument_list|(
name|rxbuf
operator|->
name|buf
argument_list|)
expr_stmt|;
block|}
name|rxbuf
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|rxbuf
operator|->
name|pmap
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|rxr
operator|->
name|ptag
argument_list|,
name|rxbuf
operator|->
name|pmap
argument_list|)
expr_stmt|;
name|rxbuf
operator|->
name|pmap
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rxr
operator|->
name|rx_buffers
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|rxr
operator|->
name|rx_buffers
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|rx_buffers
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rxr
operator|->
name|ptag
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|rxr
operator|->
name|ptag
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|ptag
operator|=
name|NULL
expr_stmt|;
block|}
return|return;
block|}
specifier|static
name|__inline
name|void
name|ixgbe_rx_input
parameter_list|(
name|struct
name|rx_ring
modifier|*
name|rxr
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|u32
name|ptype
parameter_list|)
block|{
comment|/*          * ATM LRO is only for IP/TCP packets and TCP checksum of the packet          * should be computed by hardware. Also it should not have VLAN tag in          * ethernet header.  In case of IPv6 we do not yet support ext. hdrs.          */
if|if
condition|(
name|rxr
operator|->
name|lro_enabled
operator|&&
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWTAGGING
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ptype
operator|&
name|IXGBE_RXDADV_PKTTYPE_ETQF
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|ptype
operator|&
operator|(
name|IXGBE_RXDADV_PKTTYPE_IPV4
operator||
name|IXGBE_RXDADV_PKTTYPE_TCP
operator|)
operator|)
operator|==
operator|(
name|IXGBE_RXDADV_PKTTYPE_IPV4
operator||
name|IXGBE_RXDADV_PKTTYPE_TCP
operator|)
operator|||
operator|(
name|ptype
operator|&
operator|(
name|IXGBE_RXDADV_PKTTYPE_IPV6
operator||
name|IXGBE_RXDADV_PKTTYPE_TCP
operator|)
operator|)
operator|==
operator|(
name|IXGBE_RXDADV_PKTTYPE_IPV6
operator||
name|IXGBE_RXDADV_PKTTYPE_TCP
operator|)
operator|)
operator|&&
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
operator|)
operator|==
operator|(
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
condition|)
block|{
comment|/*                  * Send to the stack if:                  **  - LRO not enabled, or                  **  - no LRO resources, or                  **  - lro enqueue fails                  */
if|if
condition|(
name|rxr
operator|->
name|lro
operator|.
name|lro_cnt
operator|!=
literal|0
condition|)
if|if
condition|(
name|tcp_lro_rx
argument_list|(
operator|&
name|rxr
operator|->
name|lro
argument_list|,
name|m
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return;
block|}
name|IXGBE_RX_UNLOCK
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|IXGBE_RX_LOCK
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
block|}
specifier|static
name|__inline
name|void
name|ixgbe_rx_discard
parameter_list|(
name|struct
name|rx_ring
modifier|*
name|rxr
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|struct
name|ixgbe_rx_buf
modifier|*
name|rbuf
decl_stmt|;
name|rbuf
operator|=
operator|&
name|rxr
operator|->
name|rx_buffers
index|[
name|i
index|]
expr_stmt|;
comment|/* 	** With advanced descriptors the writeback 	** clobbers the buffer addrs, so its easier 	** to just free the existing mbufs and take 	** the normal refresh path to get new buffers 	** and mapping. 	*/
if|if
condition|(
name|rbuf
operator|->
name|fmp
operator|!=
name|NULL
condition|)
block|{
comment|/* Partial chain ? */
name|rbuf
operator|->
name|fmp
operator|->
name|m_flags
operator||=
name|M_PKTHDR
expr_stmt|;
name|m_freem
argument_list|(
name|rbuf
operator|->
name|fmp
argument_list|)
expr_stmt|;
name|rbuf
operator|->
name|fmp
operator|=
name|NULL
expr_stmt|;
name|rbuf
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
comment|/* rbuf->buf is part of fmp's chain */
block|}
elseif|else
if|if
condition|(
name|rbuf
operator|->
name|buf
condition|)
block|{
name|m_free
argument_list|(
name|rbuf
operator|->
name|buf
argument_list|)
expr_stmt|;
name|rbuf
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
block|}
name|rbuf
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/*********************************************************************  *  *  This routine executes in interrupt context. It replenishes  *  the mbufs in the descriptor and sends data which has been  *  dma'ed into host memory to upper layer.  *  *  We loop at most count times if count is> 0, or until done if  *  count< 0.  *  *  Return TRUE for more work, FALSE for all clean.  *********************************************************************/
specifier|static
name|bool
name|ixgbe_rxeof
parameter_list|(
name|struct
name|ix_queue
modifier|*
name|que
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|que
operator|->
name|adapter
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
name|que
operator|->
name|rxr
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|struct
name|lro_ctrl
modifier|*
name|lro
init|=
operator|&
name|rxr
operator|->
name|lro
decl_stmt|;
name|struct
name|lro_entry
modifier|*
name|queued
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nextp
decl_stmt|,
name|processed
init|=
literal|0
decl_stmt|;
name|u32
name|staterr
init|=
literal|0
decl_stmt|;
name|u16
name|count
init|=
name|rxr
operator|->
name|process_limit
decl_stmt|;
name|union
name|ixgbe_adv_rx_desc
modifier|*
name|cur
decl_stmt|;
name|struct
name|ixgbe_rx_buf
modifier|*
name|rbuf
decl_stmt|,
modifier|*
name|nbuf
decl_stmt|;
name|IXGBE_RX_LOCK
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
comment|/* Same as the txeof routine: wakeup clients on intr. */
if|if
condition|(
name|netmap_rx_irq
argument_list|(
name|ifp
argument_list|,
name|rxr
operator|->
name|me
argument_list|,
operator|&
name|processed
argument_list|)
condition|)
block|{
name|IXGBE_RX_UNLOCK
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* DEV_NETMAP */
for|for
control|(
name|i
operator|=
name|rxr
operator|->
name|next_to_check
init|;
name|count
operator|!=
literal|0
condition|;
control|)
block|{
name|struct
name|mbuf
modifier|*
name|sendmp
decl_stmt|,
modifier|*
name|mp
decl_stmt|;
name|u32
name|rsc
decl_stmt|,
name|ptype
decl_stmt|;
name|u16
name|len
decl_stmt|;
name|u16
name|vtag
init|=
literal|0
decl_stmt|;
name|bool
name|eop
decl_stmt|;
comment|/* Sync the ring. */
name|bus_dmamap_sync
argument_list|(
name|rxr
operator|->
name|rxdma
operator|.
name|dma_tag
argument_list|,
name|rxr
operator|->
name|rxdma
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|cur
operator|=
operator|&
name|rxr
operator|->
name|rx_base
index|[
name|i
index|]
expr_stmt|;
name|staterr
operator|=
name|le32toh
argument_list|(
name|cur
operator|->
name|wb
operator|.
name|upper
operator|.
name|status_error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|staterr
operator|&
name|IXGBE_RXD_STAT_DD
operator|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
break|break;
name|count
operator|--
expr_stmt|;
name|sendmp
operator|=
name|NULL
expr_stmt|;
name|nbuf
operator|=
name|NULL
expr_stmt|;
name|rsc
operator|=
literal|0
expr_stmt|;
name|cur
operator|->
name|wb
operator|.
name|upper
operator|.
name|status_error
operator|=
literal|0
expr_stmt|;
name|rbuf
operator|=
operator|&
name|rxr
operator|->
name|rx_buffers
index|[
name|i
index|]
expr_stmt|;
name|mp
operator|=
name|rbuf
operator|->
name|buf
expr_stmt|;
name|len
operator|=
name|le16toh
argument_list|(
name|cur
operator|->
name|wb
operator|.
name|upper
operator|.
name|length
argument_list|)
expr_stmt|;
name|ptype
operator|=
name|le32toh
argument_list|(
name|cur
operator|->
name|wb
operator|.
name|lower
operator|.
name|lo_dword
operator|.
name|data
argument_list|)
operator|&
name|IXGBE_RXDADV_PKTTYPE_MASK
expr_stmt|;
name|eop
operator|=
operator|(
operator|(
name|staterr
operator|&
name|IXGBE_RXD_STAT_EOP
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
comment|/* Make sure bad packets are discarded */
if|if
condition|(
name|eop
operator|&&
operator|(
name|staterr
operator|&
name|IXGBE_RXDADV_ERR_FRAME_ERR_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
name|rxr
operator|->
name|rx_discarded
operator|++
expr_stmt|;
name|ixgbe_rx_discard
argument_list|(
name|rxr
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|next_desc
goto|;
block|}
comment|/* 		** On 82599 which supports a hardware 		** LRO (called HW RSC), packets need 		** not be fragmented across sequential 		** descriptors, rather the next descriptor 		** is indicated in bits of the descriptor. 		** This also means that we might proceses 		** more than one packet at a time, something 		** that has never been true before, it 		** required eliminating global chain pointers 		** in favor of what we are doing here.  -jfv 		*/
if|if
condition|(
operator|!
name|eop
condition|)
block|{
comment|/* 			** Figure out the next descriptor 			** of this frame. 			*/
if|if
condition|(
name|rxr
operator|->
name|hw_rsc
operator|==
name|TRUE
condition|)
block|{
name|rsc
operator|=
name|ixgbe_rsc_count
argument_list|(
name|cur
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|rsc_num
operator|+=
operator|(
name|rsc
operator|-
literal|1
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|rsc
condition|)
block|{
comment|/* Get hardware index */
name|nextp
operator|=
operator|(
operator|(
name|staterr
operator|&
name|IXGBE_RXDADV_NEXTP_MASK
operator|)
operator|>>
name|IXGBE_RXDADV_NEXTP_SHIFT
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Just sequential */
name|nextp
operator|=
name|i
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|nextp
operator|==
name|adapter
operator|->
name|num_rx_desc
condition|)
name|nextp
operator|=
literal|0
expr_stmt|;
block|}
name|nbuf
operator|=
operator|&
name|rxr
operator|->
name|rx_buffers
index|[
name|nextp
index|]
expr_stmt|;
name|prefetch
argument_list|(
name|nbuf
argument_list|)
expr_stmt|;
block|}
comment|/* 		** Rather than using the fmp/lmp global pointers 		** we now keep the head of a packet chain in the 		** buffer struct and pass this along from one 		** descriptor to the next, until we get EOP. 		*/
name|mp
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
comment|/* 		** See if there is a stored head 		** that determines what we are 		*/
name|sendmp
operator|=
name|rbuf
operator|->
name|fmp
expr_stmt|;
if|if
condition|(
name|sendmp
operator|!=
name|NULL
condition|)
block|{
comment|/* secondary frag */
name|rbuf
operator|->
name|buf
operator|=
name|rbuf
operator|->
name|fmp
operator|=
name|NULL
expr_stmt|;
name|mp
operator|->
name|m_flags
operator|&=
operator|~
name|M_PKTHDR
expr_stmt|;
name|sendmp
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|mp
operator|->
name|m_len
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Optimize.  This might be a small packet, 			 * maybe just a TCP ACK.  Do a fast copy that 			 * is cache aligned into a new mbuf, and 			 * leave the old mbuf+cluster for re-use. 			 */
if|if
condition|(
name|eop
operator|&&
name|len
operator|<=
name|IXGBE_RX_COPY_LEN
condition|)
block|{
name|sendmp
operator|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|sendmp
operator|!=
name|NULL
condition|)
block|{
name|sendmp
operator|->
name|m_data
operator|+=
name|IXGBE_RX_COPY_ALIGN
expr_stmt|;
name|ixgbe_bcopy
argument_list|(
name|mp
operator|->
name|m_data
argument_list|,
name|sendmp
operator|->
name|m_data
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|sendmp
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|rxr
operator|->
name|rx_copies
operator|++
expr_stmt|;
name|rbuf
operator|->
name|flags
operator||=
name|IXGBE_RX_COPY
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sendmp
operator|==
name|NULL
condition|)
block|{
name|rbuf
operator|->
name|buf
operator|=
name|rbuf
operator|->
name|fmp
operator|=
name|NULL
expr_stmt|;
name|sendmp
operator|=
name|mp
expr_stmt|;
block|}
comment|/* first desc of a non-ps chain */
name|sendmp
operator|->
name|m_flags
operator||=
name|M_PKTHDR
expr_stmt|;
name|sendmp
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|mp
operator|->
name|m_len
expr_stmt|;
block|}
operator|++
name|processed
expr_stmt|;
comment|/* Pass the head pointer on */
if|if
condition|(
name|eop
operator|==
literal|0
condition|)
block|{
name|nbuf
operator|->
name|fmp
operator|=
name|sendmp
expr_stmt|;
name|sendmp
operator|=
name|NULL
expr_stmt|;
name|mp
operator|->
name|m_next
operator|=
name|nbuf
operator|->
name|buf
expr_stmt|;
block|}
else|else
block|{
comment|/* Sending this frame */
name|sendmp
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
name|rxr
operator|->
name|rx_packets
operator|++
expr_stmt|;
comment|/* capture data for AIM */
name|rxr
operator|->
name|bytes
operator|+=
name|sendmp
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|rxr
operator|->
name|rx_bytes
operator|+=
name|sendmp
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* Process vlan info */
if|if
condition|(
operator|(
name|rxr
operator|->
name|vtag_strip
operator|)
operator|&&
operator|(
name|staterr
operator|&
name|IXGBE_RXD_STAT_VP
operator|)
condition|)
name|vtag
operator|=
name|le16toh
argument_list|(
name|cur
operator|->
name|wb
operator|.
name|upper
operator|.
name|vlan
argument_list|)
expr_stmt|;
if|if
condition|(
name|vtag
condition|)
block|{
name|sendmp
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
operator|=
name|vtag
expr_stmt|;
name|sendmp
operator|->
name|m_flags
operator||=
name|M_VLANTAG
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_RXCSUM
operator|)
operator|!=
literal|0
condition|)
name|ixgbe_rx_checksum
argument_list|(
name|staterr
argument_list|,
name|sendmp
argument_list|,
name|ptype
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800000
name|sendmp
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|=
name|que
operator|->
name|msix
expr_stmt|;
name|sendmp
operator|->
name|m_flags
operator||=
name|M_FLOWID
expr_stmt|;
endif|#
directive|endif
block|}
name|next_desc
label|:
name|bus_dmamap_sync
argument_list|(
name|rxr
operator|->
name|rxdma
operator|.
name|dma_tag
argument_list|,
name|rxr
operator|->
name|rxdma
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* Advance our pointers to the next descriptor. */
if|if
condition|(
operator|++
name|i
operator|==
name|rxr
operator|->
name|num_desc
condition|)
name|i
operator|=
literal|0
expr_stmt|;
comment|/* Now send to the stack or do LRO */
if|if
condition|(
name|sendmp
operator|!=
name|NULL
condition|)
block|{
name|rxr
operator|->
name|next_to_check
operator|=
name|i
expr_stmt|;
name|ixgbe_rx_input
argument_list|(
name|rxr
argument_list|,
name|ifp
argument_list|,
name|sendmp
argument_list|,
name|ptype
argument_list|)
expr_stmt|;
name|i
operator|=
name|rxr
operator|->
name|next_to_check
expr_stmt|;
block|}
comment|/* Every 8 descriptors we go to refresh mbufs */
if|if
condition|(
name|processed
operator|==
literal|8
condition|)
block|{
name|ixgbe_refresh_mbufs
argument_list|(
name|rxr
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|processed
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Refresh any remaining buf structs */
if|if
condition|(
name|ixgbe_rx_unrefreshed
argument_list|(
name|rxr
argument_list|)
condition|)
name|ixgbe_refresh_mbufs
argument_list|(
name|rxr
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|next_to_check
operator|=
name|i
expr_stmt|;
comment|/* 	 * Flush any outstanding LRO work 	 */
while|while
condition|(
operator|(
name|queued
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|lro
operator|->
name|lro_active
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|lro
operator|->
name|lro_active
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|tcp_lro_flush
argument_list|(
name|lro
argument_list|,
name|queued
argument_list|)
expr_stmt|;
block|}
name|IXGBE_RX_UNLOCK
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
comment|/* 	** Still have cleaning to do? 	*/
if|if
condition|(
operator|(
name|staterr
operator|&
name|IXGBE_RXD_STAT_DD
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
else|else
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/*********************************************************************  *  *  Verify that the hardware indicated that the checksum is valid.  *  Inform the stack about the status of checksum so that stack  *  doesn't spend time verifying the checksum.  *  *********************************************************************/
specifier|static
name|void
name|ixgbe_rx_checksum
parameter_list|(
name|u32
name|staterr
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mp
parameter_list|,
name|u32
name|ptype
parameter_list|)
block|{
name|u16
name|status
init|=
operator|(
name|u16
operator|)
name|staterr
decl_stmt|;
name|u8
name|errors
init|=
call|(
name|u8
call|)
argument_list|(
name|staterr
operator|>>
literal|24
argument_list|)
decl_stmt|;
name|bool
name|sctp
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|(
name|ptype
operator|&
name|IXGBE_RXDADV_PKTTYPE_ETQF
operator|)
operator|==
literal|0
operator|&&
operator|(
name|ptype
operator|&
name|IXGBE_RXDADV_PKTTYPE_SCTP
operator|)
operator|!=
literal|0
condition|)
name|sctp
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|IXGBE_RXD_STAT_IPCS
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|errors
operator|&
name|IXGBE_RXD_ERR_IPE
operator|)
condition|)
block|{
comment|/* IP Checksum Good */
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
name|CSUM_IP_CHECKED
expr_stmt|;
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_IP_VALID
expr_stmt|;
block|}
else|else
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|IXGBE_RXD_STAT_L4CS
condition|)
block|{
name|u64
name|type
init|=
operator|(
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
decl_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800000
if|if
condition|(
name|sctp
condition|)
name|type
operator|=
name|CSUM_SCTP_VALID
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|errors
operator|&
name|IXGBE_RXD_ERR_TCPE
operator|)
condition|)
block|{
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|type
expr_stmt|;
if|if
condition|(
operator|!
name|sctp
condition|)
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
name|htons
argument_list|(
literal|0xffff
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
comment|/* ** This routine is run via an vlan config EVENT, ** it enables us to use the HW Filter table since ** we can get the vlan id. This just creates the ** entry in the soft version of the VFTA, init will ** repopulate the real table. */
specifier|static
name|void
name|ixgbe_register_vlan
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u16
name|vtag
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|u16
name|index
decl_stmt|,
name|bit
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_softc
operator|!=
name|arg
condition|)
comment|/* Not our event */
return|return;
if|if
condition|(
operator|(
name|vtag
operator|==
literal|0
operator|)
operator|||
operator|(
name|vtag
operator|>
literal|4095
operator|)
condition|)
comment|/* Invalid */
return|return;
name|IXGBE_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|index
operator|=
operator|(
name|vtag
operator|>>
literal|5
operator|)
operator|&
literal|0x7F
expr_stmt|;
name|bit
operator|=
name|vtag
operator|&
literal|0x1F
expr_stmt|;
name|adapter
operator|->
name|shadow_vfta
index|[
name|index
index|]
operator||=
operator|(
literal|1
operator|<<
name|bit
operator|)
expr_stmt|;
operator|++
name|adapter
operator|->
name|num_vlans
expr_stmt|;
name|ixgbe_setup_vlan_hw_support
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|IXGBE_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
comment|/* ** This routine is run via an vlan ** unconfig EVENT, remove our entry ** in the soft vfta. */
specifier|static
name|void
name|ixgbe_unregister_vlan
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u16
name|vtag
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|u16
name|index
decl_stmt|,
name|bit
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_softc
operator|!=
name|arg
condition|)
return|return;
if|if
condition|(
operator|(
name|vtag
operator|==
literal|0
operator|)
operator|||
operator|(
name|vtag
operator|>
literal|4095
operator|)
condition|)
comment|/* Invalid */
return|return;
name|IXGBE_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|index
operator|=
operator|(
name|vtag
operator|>>
literal|5
operator|)
operator|&
literal|0x7F
expr_stmt|;
name|bit
operator|=
name|vtag
operator|&
literal|0x1F
expr_stmt|;
name|adapter
operator|->
name|shadow_vfta
index|[
name|index
index|]
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|bit
operator|)
expr_stmt|;
operator|--
name|adapter
operator|->
name|num_vlans
expr_stmt|;
comment|/* Re-init to load the changes */
name|ixgbe_setup_vlan_hw_support
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|IXGBE_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|ixgbe_setup_vlan_hw_support
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
decl_stmt|;
name|u32
name|ctrl
decl_stmt|;
comment|/* 	** We get here thru init_locked, meaning 	** a soft reset, this has already cleared 	** the VFTA and other state, so if there 	** have been no vlan's registered do nothing. 	*/
if|if
condition|(
name|adapter
operator|->
name|num_vlans
operator|==
literal|0
condition|)
return|return;
comment|/* Setup the queues for vlans */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|rxr
operator|=
operator|&
name|adapter
operator|->
name|rx_rings
index|[
name|i
index|]
expr_stmt|;
comment|/* On 82599 the VLAN enable is per/queue in RXDCTL */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|!=
name|ixgbe_mac_82598EB
condition|)
block|{
name|ctrl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXDCTL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|ctrl
operator||=
name|IXGBE_RXDCTL_VME
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXDCTL
argument_list|(
name|i
argument_list|)
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
block|}
name|rxr
operator|->
name|vtag_strip
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWFILTER
operator|)
operator|==
literal|0
condition|)
return|return;
comment|/* 	** A soft reset zero's out the VFTA, so 	** we need to repopulate it now. 	*/
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|IXGBE_VFTA_SIZE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|adapter
operator|->
name|shadow_vfta
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VFTA
argument_list|(
name|i
argument_list|)
argument_list|,
name|adapter
operator|->
name|shadow_vfta
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VLNCTRL
argument_list|)
expr_stmt|;
comment|/* Enable the Filter Table if enabled */
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWFILTER
condition|)
block|{
name|ctrl
operator|&=
operator|~
name|IXGBE_VLNCTRL_CFIEN
expr_stmt|;
name|ctrl
operator||=
name|IXGBE_VLNCTRL_VFE
expr_stmt|;
block|}
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_82598EB
condition|)
name|ctrl
operator||=
name|IXGBE_VLNCTRL_VME
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VLNCTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|ixgbe_enable_intr
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|struct
name|ix_queue
modifier|*
name|que
init|=
name|adapter
operator|->
name|queues
decl_stmt|;
name|u32
name|mask
decl_stmt|,
name|fwsm
decl_stmt|;
name|mask
operator|=
operator|(
name|IXGBE_EIMS_ENABLE_MASK
operator|&
operator|~
name|IXGBE_EIMS_RTX_QUEUE
operator|)
expr_stmt|;
comment|/* Enable Fan Failure detection */
if|if
condition|(
name|hw
operator|->
name|device_id
operator|==
name|IXGBE_DEV_ID_82598AT
condition|)
name|mask
operator||=
name|IXGBE_EIMS_GPI_SDP1
expr_stmt|;
switch|switch
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|ixgbe_mac_82599EB
case|:
name|mask
operator||=
name|IXGBE_EIMS_ECC
expr_stmt|;
name|mask
operator||=
name|IXGBE_EIMS_GPI_SDP0
expr_stmt|;
name|mask
operator||=
name|IXGBE_EIMS_GPI_SDP1
expr_stmt|;
name|mask
operator||=
name|IXGBE_EIMS_GPI_SDP2
expr_stmt|;
ifdef|#
directive|ifdef
name|IXGBE_FDIR
name|mask
operator||=
name|IXGBE_EIMS_FLOW_DIR
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|ixgbe_mac_X540
case|:
name|mask
operator||=
name|IXGBE_EIMS_ECC
expr_stmt|;
comment|/* Detect if Thermal Sensor is enabled */
name|fwsm
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FWSM
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwsm
operator|&
name|IXGBE_FWSM_TS_ENABLED
condition|)
name|mask
operator||=
name|IXGBE_EIMS_TS
expr_stmt|;
ifdef|#
directive|ifdef
name|IXGBE_FDIR
name|mask
operator||=
name|IXGBE_EIMS_FLOW_DIR
expr_stmt|;
endif|#
directive|endif
comment|/* falls through */
default|default:
break|break;
block|}
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EIMS
argument_list|,
name|mask
argument_list|)
expr_stmt|;
comment|/* With RSS we use auto clear */
if|if
condition|(
name|adapter
operator|->
name|msix_mem
condition|)
block|{
name|mask
operator|=
name|IXGBE_EIMS_ENABLE_MASK
expr_stmt|;
comment|/* Don't autoclear Link */
name|mask
operator|&=
operator|~
name|IXGBE_EIMS_OTHER
expr_stmt|;
name|mask
operator|&=
operator|~
name|IXGBE_EIMS_LSC
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EIAC
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
comment|/* 	** Now enable all queues, this is done separately to 	** allow for handling the extended (beyond 32) MSIX 	** vectors that can be used by 82599 	*/
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
name|ixgbe_enable_queue
argument_list|(
name|adapter
argument_list|,
name|que
operator|->
name|msix
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|static
name|void
name|ixgbe_disable_intr
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
if|if
condition|(
name|adapter
operator|->
name|msix_mem
condition|)
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_EIAC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_82598EB
condition|)
block|{
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_EIMC
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_EIMC
argument_list|,
literal|0xFFFF0000
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_EIMC_EX
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_EIMC_EX
argument_list|(
literal|1
argument_list|)
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
block|}
name|IXGBE_WRITE_FLUSH
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
return|return;
block|}
name|u16
name|ixgbe_read_pci_cfg
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|reg
parameter_list|)
block|{
name|u16
name|value
decl_stmt|;
name|value
operator|=
name|pci_read_config
argument_list|(
operator|(
operator|(
expr|struct
name|ixgbe_osdep
operator|*
operator|)
name|hw
operator|->
name|back
operator|)
operator|->
name|dev
argument_list|,
name|reg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
name|void
name|ixgbe_write_pci_cfg
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|reg
parameter_list|,
name|u16
name|value
parameter_list|)
block|{
name|pci_write_config
argument_list|(
operator|(
operator|(
expr|struct
name|ixgbe_osdep
operator|*
operator|)
name|hw
operator|->
name|back
operator|)
operator|->
name|dev
argument_list|,
name|reg
argument_list|,
name|value
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* ** Get the width and transaction speed of ** the slot this adapter is plugged into. */
specifier|static
name|void
name|ixgbe_get_slot_info
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|device_t
name|dev
init|=
operator|(
operator|(
expr|struct
name|ixgbe_osdep
operator|*
operator|)
name|hw
operator|->
name|back
operator|)
operator|->
name|dev
decl_stmt|;
name|struct
name|ixgbe_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|u16
name|link
decl_stmt|;
name|u32
name|offset
decl_stmt|;
comment|/* For most devices simply call the shared code routine */
if|if
condition|(
name|hw
operator|->
name|device_id
operator|!=
name|IXGBE_DEV_ID_82599_SFP_SF_QP
condition|)
block|{
name|ixgbe_get_bus_info
argument_list|(
name|hw
argument_list|)
expr_stmt|;
goto|goto
name|display
goto|;
block|}
comment|/* 	** For the Quad port adapter we need to parse back 	** up the PCI tree to find the speed of the expansion 	** slot into which this adapter is plugged. A bit more work. 	*/
name|dev
operator|=
name|device_get_parent
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IXGBE_DEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"parent pcib = %x,%x,%x\n"
argument_list|,
name|pci_get_bus
argument_list|(
name|dev
argument_list|)
argument_list|,
name|pci_get_slot
argument_list|(
name|dev
argument_list|)
argument_list|,
name|pci_get_function
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dev
operator|=
name|device_get_parent
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IXGBE_DEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"slot pcib = %x,%x,%x\n"
argument_list|,
name|pci_get_bus
argument_list|(
name|dev
argument_list|)
argument_list|,
name|pci_get_slot
argument_list|(
name|dev
argument_list|)
argument_list|,
name|pci_get_function
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Now get the PCI Express Capabilities offset */
name|pci_find_cap
argument_list|(
name|dev
argument_list|,
name|PCIY_EXPRESS
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
comment|/* ...and read the Link Status Register */
name|link
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|offset
operator|+
name|PCIER_LINK_STA
argument_list|,
literal|2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|link
operator|&
name|IXGBE_PCI_LINK_WIDTH
condition|)
block|{
case|case
name|IXGBE_PCI_LINK_WIDTH_1
case|:
name|hw
operator|->
name|bus
operator|.
name|width
operator|=
name|ixgbe_bus_width_pcie_x1
expr_stmt|;
break|break;
case|case
name|IXGBE_PCI_LINK_WIDTH_2
case|:
name|hw
operator|->
name|bus
operator|.
name|width
operator|=
name|ixgbe_bus_width_pcie_x2
expr_stmt|;
break|break;
case|case
name|IXGBE_PCI_LINK_WIDTH_4
case|:
name|hw
operator|->
name|bus
operator|.
name|width
operator|=
name|ixgbe_bus_width_pcie_x4
expr_stmt|;
break|break;
case|case
name|IXGBE_PCI_LINK_WIDTH_8
case|:
name|hw
operator|->
name|bus
operator|.
name|width
operator|=
name|ixgbe_bus_width_pcie_x8
expr_stmt|;
break|break;
default|default:
name|hw
operator|->
name|bus
operator|.
name|width
operator|=
name|ixgbe_bus_width_unknown
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|link
operator|&
name|IXGBE_PCI_LINK_SPEED
condition|)
block|{
case|case
name|IXGBE_PCI_LINK_SPEED_2500
case|:
name|hw
operator|->
name|bus
operator|.
name|speed
operator|=
name|ixgbe_bus_speed_2500
expr_stmt|;
break|break;
case|case
name|IXGBE_PCI_LINK_SPEED_5000
case|:
name|hw
operator|->
name|bus
operator|.
name|speed
operator|=
name|ixgbe_bus_speed_5000
expr_stmt|;
break|break;
case|case
name|IXGBE_PCI_LINK_SPEED_8000
case|:
name|hw
operator|->
name|bus
operator|.
name|speed
operator|=
name|ixgbe_bus_speed_8000
expr_stmt|;
break|break;
default|default:
name|hw
operator|->
name|bus
operator|.
name|speed
operator|=
name|ixgbe_bus_speed_unknown
expr_stmt|;
break|break;
block|}
name|mac
operator|->
name|ops
operator|.
name|set_lan_id
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|display
label|:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"PCI Express Bus: Speed %s %s\n"
argument_list|,
operator|(
operator|(
name|hw
operator|->
name|bus
operator|.
name|speed
operator|==
name|ixgbe_bus_speed_8000
operator|)
condition|?
literal|"8.0GT/s"
else|:
operator|(
name|hw
operator|->
name|bus
operator|.
name|speed
operator|==
name|ixgbe_bus_speed_5000
operator|)
condition|?
literal|"5.0GT/s"
else|:
operator|(
name|hw
operator|->
name|bus
operator|.
name|speed
operator|==
name|ixgbe_bus_speed_2500
operator|)
condition|?
literal|"2.5GT/s"
else|:
literal|"Unknown"
operator|)
argument_list|,
operator|(
name|hw
operator|->
name|bus
operator|.
name|width
operator|==
name|ixgbe_bus_width_pcie_x8
operator|)
condition|?
literal|"Width x8"
else|:
operator|(
name|hw
operator|->
name|bus
operator|.
name|width
operator|==
name|ixgbe_bus_width_pcie_x4
operator|)
condition|?
literal|"Width x4"
else|:
operator|(
name|hw
operator|->
name|bus
operator|.
name|width
operator|==
name|ixgbe_bus_width_pcie_x1
operator|)
condition|?
literal|"Width x1"
else|:
operator|(
literal|"Unknown"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hw
operator|->
name|device_id
operator|!=
name|IXGBE_DEV_ID_82599_SFP_SF_QP
operator|)
operator|&&
operator|(
operator|(
name|hw
operator|->
name|bus
operator|.
name|width
operator|<=
name|ixgbe_bus_width_pcie_x4
operator|)
operator|&&
operator|(
name|hw
operator|->
name|bus
operator|.
name|speed
operator|==
name|ixgbe_bus_speed_2500
operator|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"PCI-Express bandwidth available"
literal|" for this card\n     is not sufficient for"
literal|" optimal performance.\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"For optimal performance a x8 "
literal|"PCIE, or x4 PCIE Gen2 slot is required.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|hw
operator|->
name|device_id
operator|==
name|IXGBE_DEV_ID_82599_SFP_SF_QP
operator|)
operator|&&
operator|(
operator|(
name|hw
operator|->
name|bus
operator|.
name|width
operator|<=
name|ixgbe_bus_width_pcie_x8
operator|)
operator|&&
operator|(
name|hw
operator|->
name|bus
operator|.
name|speed
operator|<
name|ixgbe_bus_speed_8000
operator|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"PCI-Express bandwidth available"
literal|" for this card\n     is not sufficient for"
literal|" optimal performance.\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"For optimal performance a x8 "
literal|"PCIE Gen3 slot is required.\n"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* ** Setup the correct IVAR register for a particular MSIX interrupt **   (yes this is all very magic and confusing :) **  - entry is the register array entry **  - vector is the MSIX vector for this queue **  - type is RX/TX/MISC */
specifier|static
name|void
name|ixgbe_set_ivar
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|u8
name|entry
parameter_list|,
name|u8
name|vector
parameter_list|,
name|s8
name|type
parameter_list|)
block|{
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|u32
name|ivar
decl_stmt|,
name|index
decl_stmt|;
name|vector
operator||=
name|IXGBE_IVAR_ALLOC_VAL
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|ixgbe_mac_82598EB
case|:
if|if
condition|(
name|type
operator|==
operator|-
literal|1
condition|)
name|entry
operator|=
name|IXGBE_IVAR_OTHER_CAUSES_INDEX
expr_stmt|;
else|else
name|entry
operator|+=
operator|(
name|type
operator|*
literal|64
operator|)
expr_stmt|;
name|index
operator|=
operator|(
name|entry
operator|>>
literal|2
operator|)
operator|&
literal|0x1F
expr_stmt|;
name|ivar
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_IVAR
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|ivar
operator|&=
operator|~
operator|(
literal|0xFF
operator|<<
operator|(
literal|8
operator|*
operator|(
name|entry
operator|&
literal|0x3
operator|)
operator|)
operator|)
expr_stmt|;
name|ivar
operator||=
operator|(
name|vector
operator|<<
operator|(
literal|8
operator|*
operator|(
name|entry
operator|&
literal|0x3
operator|)
operator|)
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_IVAR
argument_list|(
name|index
argument_list|)
argument_list|,
name|ivar
argument_list|)
expr_stmt|;
break|break;
case|case
name|ixgbe_mac_82599EB
case|:
case|case
name|ixgbe_mac_X540
case|:
if|if
condition|(
name|type
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* MISC IVAR */
name|index
operator|=
operator|(
name|entry
operator|&
literal|1
operator|)
operator|*
literal|8
expr_stmt|;
name|ivar
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_IVAR_MISC
argument_list|)
expr_stmt|;
name|ivar
operator|&=
operator|~
operator|(
literal|0xFF
operator|<<
name|index
operator|)
expr_stmt|;
name|ivar
operator||=
operator|(
name|vector
operator|<<
name|index
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_IVAR_MISC
argument_list|,
name|ivar
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* RX/TX IVARS */
name|index
operator|=
operator|(
literal|16
operator|*
operator|(
name|entry
operator|&
literal|1
operator|)
operator|)
operator|+
operator|(
literal|8
operator|*
name|type
operator|)
expr_stmt|;
name|ivar
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_IVAR
argument_list|(
name|entry
operator|>>
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ivar
operator|&=
operator|~
operator|(
literal|0xFF
operator|<<
name|index
operator|)
expr_stmt|;
name|ivar
operator||=
operator|(
name|vector
operator|<<
name|index
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_IVAR
argument_list|(
name|entry
operator|>>
literal|1
argument_list|)
argument_list|,
name|ivar
argument_list|)
expr_stmt|;
block|}
default|default:
break|break;
block|}
block|}
specifier|static
name|void
name|ixgbe_configure_ivars
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ix_queue
modifier|*
name|que
init|=
name|adapter
operator|->
name|queues
decl_stmt|;
name|u32
name|newitr
decl_stmt|;
if|if
condition|(
name|ixgbe_max_interrupt_rate
operator|>
literal|0
condition|)
name|newitr
operator|=
operator|(
literal|4000000
operator|/
name|ixgbe_max_interrupt_rate
operator|)
operator|&
literal|0x0FF8
expr_stmt|;
else|else
name|newitr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
block|{
comment|/* First the RX queue entry */
name|ixgbe_set_ivar
argument_list|(
name|adapter
argument_list|,
name|i
argument_list|,
name|que
operator|->
name|msix
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ... and the TX */
name|ixgbe_set_ivar
argument_list|(
name|adapter
argument_list|,
name|i
argument_list|,
name|que
operator|->
name|msix
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Set an Initial EITR value */
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_EITR
argument_list|(
name|que
operator|->
name|msix
argument_list|)
argument_list|,
name|newitr
argument_list|)
expr_stmt|;
block|}
comment|/* For the Link interrupt */
name|ixgbe_set_ivar
argument_list|(
name|adapter
argument_list|,
literal|1
argument_list|,
name|adapter
operator|->
name|linkvec
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* ** ixgbe_sfp_probe - called in the local timer to ** determine if a port had optics inserted. */
specifier|static
name|bool
name|ixgbe_sfp_probe
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|bool
name|result
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|ixgbe_phy_nl
operator|)
operator|&&
operator|(
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|==
name|ixgbe_sfp_type_not_present
operator|)
condition|)
block|{
name|s32
name|ret
init|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|identify_sfp
argument_list|(
name|hw
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
name|ret
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|reset
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|IXGBE_ERR_SFP_NOT_SUPPORTED
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unsupported SFP+ module detected!"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" Reload driver with supported module.\n"
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|sfp_probe
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|out
goto|;
block|}
else|else
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"SFP+ module detected!\n"
argument_list|)
expr_stmt|;
comment|/* We now have supported optics */
name|adapter
operator|->
name|sfp_probe
operator|=
name|FALSE
expr_stmt|;
comment|/* Set the optics type so system reports correctly */
name|ixgbe_setup_optics
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|result
operator|=
name|TRUE
expr_stmt|;
block|}
name|out
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
comment|/* ** Tasklet handler for MSIX Link interrupts **  - do outside interrupt since it might sleep */
specifier|static
name|void
name|ixgbe_handle_link
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|context
decl_stmt|;
name|ixgbe_check_link
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
operator|&
name|adapter
operator|->
name|link_speed
argument_list|,
operator|&
name|adapter
operator|->
name|link_up
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ixgbe_update_link_status
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
comment|/* ** Tasklet for handling SFP module interrupts */
specifier|static
name|void
name|ixgbe_handle_mod
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|context
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|u32
name|err
decl_stmt|;
name|err
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|identify_sfp
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|IXGBE_ERR_SFP_NOT_SUPPORTED
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unsupported SFP+ module type was detected.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|err
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|setup_sfp
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|IXGBE_ERR_SFP_NOT_SUPPORTED
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Setup failure - unsupported SFP+ module type.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|taskqueue_enqueue
argument_list|(
name|adapter
operator|->
name|tq
argument_list|,
operator|&
name|adapter
operator|->
name|msf_task
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* ** Tasklet for handling MSF (multispeed fiber) interrupts */
specifier|static
name|void
name|ixgbe_handle_msf
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|context
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|u32
name|autoneg
decl_stmt|;
name|bool
name|negotiate
decl_stmt|;
name|autoneg
operator|=
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|autoneg
operator|)
operator|&&
operator|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|get_link_capabilities
operator|)
condition|)
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|get_link_capabilities
argument_list|(
name|hw
argument_list|,
operator|&
name|autoneg
argument_list|,
operator|&
name|negotiate
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|setup_link
condition|)
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|setup_link
argument_list|(
name|hw
argument_list|,
name|autoneg
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|IXGBE_FDIR
comment|/* ** Tasklet for reinitializing the Flow Director filter table */
specifier|static
name|void
name|ixgbe_reinit_fdir
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|context
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
if|if
condition|(
name|adapter
operator|->
name|fdir_reinit
operator|!=
literal|1
condition|)
comment|/* Shouldn't happen */
return|return;
name|ixgbe_reinit_fdir_tables_82599
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|fdir_reinit
operator|=
literal|0
expr_stmt|;
comment|/* re-enable flow director interrupts */
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_EIMS
argument_list|,
name|IXGBE_EIMS_FLOW_DIR
argument_list|)
expr_stmt|;
comment|/* Restart the interface */
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/**********************************************************************  *  *  Update the board statistics counters.  *  **********************************************************************/
specifier|static
name|void
name|ixgbe_update_stats_counters
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|u32
name|missed_rx
init|=
literal|0
decl_stmt|,
name|bprc
decl_stmt|,
name|lxon
decl_stmt|,
name|lxoff
decl_stmt|,
name|total
decl_stmt|;
name|u64
name|total_missed_rx
init|=
literal|0
decl_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|crcerrs
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CRCERRS
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|illerrc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ILLERRC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|errbc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ERRBC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|mspdc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MSPDC
argument_list|)
expr_stmt|;
comment|/* 	** Note: these are for the 8 possible traffic classes, 	**	 which in current implementation is unused, 	**	 therefore only 0 should read real data. 	*/
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|u32
name|mp
decl_stmt|;
name|mp
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MPC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|/* missed_rx tallies misses for the gprc workaround */
name|missed_rx
operator|+=
name|mp
expr_stmt|;
comment|/* global total per queue */
name|adapter
operator|->
name|stats
operator|.
name|mpc
index|[
name|i
index|]
operator|+=
name|mp
expr_stmt|;
comment|/* Running comprehensive total for stats display */
name|total_missed_rx
operator|+=
name|adapter
operator|->
name|stats
operator|.
name|mpc
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_82598EB
condition|)
block|{
name|adapter
operator|->
name|stats
operator|.
name|rnbc
index|[
name|i
index|]
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RNBC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|qbtc
index|[
name|i
index|]
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_QBTC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|qbrc
index|[
name|i
index|]
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_QBRC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|pxonrxc
index|[
name|i
index|]
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PXONRXC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|adapter
operator|->
name|stats
operator|.
name|pxonrxc
index|[
name|i
index|]
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PXONRXCNT
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|pxontxc
index|[
name|i
index|]
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PXONTXC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|pxofftxc
index|[
name|i
index|]
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PXOFFTXC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|pxoffrxc
index|[
name|i
index|]
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PXOFFRXC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|pxon2offc
index|[
name|i
index|]
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PXON2OFFCNT
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|adapter
operator|->
name|stats
operator|.
name|qprc
index|[
name|i
index|]
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_QPRC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|qptc
index|[
name|i
index|]
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_QPTC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|qprdc
index|[
name|i
index|]
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_QPRDC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|adapter
operator|->
name|stats
operator|.
name|mlfc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MLFC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|mrfc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MRFC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|rlec
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RLEC
argument_list|)
expr_stmt|;
comment|/* Hardware workaround, gprc counts missed packets */
name|adapter
operator|->
name|stats
operator|.
name|gprc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GPRC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|gprc
operator|-=
name|missed_rx
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|!=
name|ixgbe_mac_82598EB
condition|)
block|{
name|adapter
operator|->
name|stats
operator|.
name|gorc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GORCL
argument_list|)
operator|+
operator|(
operator|(
name|u64
operator|)
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GORCH
argument_list|)
operator|<<
literal|32
operator|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|gotc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GOTCL
argument_list|)
operator|+
operator|(
operator|(
name|u64
operator|)
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GOTCH
argument_list|)
operator|<<
literal|32
operator|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|tor
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_TORL
argument_list|)
operator|+
operator|(
operator|(
name|u64
operator|)
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_TORH
argument_list|)
operator|<<
literal|32
operator|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|lxonrxc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LXONRXCNT
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|lxoffrxc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LXOFFRXCNT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|adapter
operator|->
name|stats
operator|.
name|lxonrxc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LXONRXC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|lxoffrxc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LXOFFRXC
argument_list|)
expr_stmt|;
comment|/* 82598 only has a counter in the high register */
name|adapter
operator|->
name|stats
operator|.
name|gorc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GORCH
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|gotc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GOTCH
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|tor
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_TORH
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Workaround: mprc hardware is incorrectly counting 	 * broadcasts, so for now we subtract those. 	 */
name|bprc
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_BPRC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|bprc
operator|+=
name|bprc
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|mprc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MPRC
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_82598EB
condition|)
name|adapter
operator|->
name|stats
operator|.
name|mprc
operator|-=
name|bprc
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|prc64
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PRC64
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|prc127
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PRC127
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|prc255
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PRC255
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|prc511
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PRC511
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|prc1023
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PRC1023
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|prc1522
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PRC1522
argument_list|)
expr_stmt|;
name|lxon
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LXONTXC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|lxontxc
operator|+=
name|lxon
expr_stmt|;
name|lxoff
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LXOFFTXC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|lxofftxc
operator|+=
name|lxoff
expr_stmt|;
name|total
operator|=
name|lxon
operator|+
name|lxoff
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|gptc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GPTC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|mptc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MPTC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|ptc64
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PTC64
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|gptc
operator|-=
name|total
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|mptc
operator|-=
name|total
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|ptc64
operator|-=
name|total
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|gotc
operator|-=
name|total
operator|*
name|ETHER_MIN_LEN
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|ruc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RUC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|rfc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RFC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|roc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ROC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|rjc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RJC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|mngprc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MNGPRC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|mngpdc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MNGPDC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|mngptc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MNGPTC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|tpr
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_TPR
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|tpt
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_TPT
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|ptc127
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PTC127
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|ptc255
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PTC255
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|ptc511
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PTC511
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|ptc1023
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PTC1023
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|ptc1522
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PTC1522
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|bptc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_BPTC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|xec
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_XEC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|fccrc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCCRC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|fclast
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCLAST
argument_list|)
expr_stmt|;
comment|/* Only read FCOE on 82599 */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|!=
name|ixgbe_mac_82598EB
condition|)
block|{
name|adapter
operator|->
name|stats
operator|.
name|fcoerpdc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCOERPDC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|fcoeprc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCOEPRC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|fcoeptc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCOEPTC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|fcoedwrc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCOEDWRC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|fcoedwtc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCOEDWTC
argument_list|)
expr_stmt|;
block|}
comment|/* Fill out the OS statistics structure */
name|ifp
operator|->
name|if_ipackets
operator|=
name|adapter
operator|->
name|stats
operator|.
name|gprc
expr_stmt|;
name|ifp
operator|->
name|if_opackets
operator|=
name|adapter
operator|->
name|stats
operator|.
name|gptc
expr_stmt|;
name|ifp
operator|->
name|if_ibytes
operator|=
name|adapter
operator|->
name|stats
operator|.
name|gorc
expr_stmt|;
name|ifp
operator|->
name|if_obytes
operator|=
name|adapter
operator|->
name|stats
operator|.
name|gotc
expr_stmt|;
name|ifp
operator|->
name|if_imcasts
operator|=
name|adapter
operator|->
name|stats
operator|.
name|mprc
expr_stmt|;
name|ifp
operator|->
name|if_omcasts
operator|=
name|adapter
operator|->
name|stats
operator|.
name|mptc
expr_stmt|;
name|ifp
operator|->
name|if_collisions
operator|=
literal|0
expr_stmt|;
comment|/* Rx Errors */
name|ifp
operator|->
name|if_iqdrops
operator|=
name|total_missed_rx
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|=
name|adapter
operator|->
name|stats
operator|.
name|crcerrs
operator|+
name|adapter
operator|->
name|stats
operator|.
name|rlec
expr_stmt|;
block|}
comment|/** ixgbe_sysctl_tdh_handler - Handler function  *  Retrieves the TDH value from the hardware  */
specifier|static
name|int
name|ixgbe_sysctl_tdh_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|(
operator|(
expr|struct
name|tx_ring
operator|*
operator|)
name|oidp
operator|->
name|oid_arg1
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|txr
condition|)
return|return
literal|0
return|;
name|unsigned
name|val
init|=
name|IXGBE_READ_REG
argument_list|(
operator|&
name|txr
operator|->
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_TDH
argument_list|(
name|txr
operator|->
name|me
argument_list|)
argument_list|)
decl_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
name|error
return|;
return|return
literal|0
return|;
block|}
comment|/** ixgbe_sysctl_tdt_handler - Handler function  *  Retrieves the TDT value from the hardware  */
specifier|static
name|int
name|ixgbe_sysctl_tdt_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|(
operator|(
expr|struct
name|tx_ring
operator|*
operator|)
name|oidp
operator|->
name|oid_arg1
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|txr
condition|)
return|return
literal|0
return|;
name|unsigned
name|val
init|=
name|IXGBE_READ_REG
argument_list|(
operator|&
name|txr
operator|->
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_TDT
argument_list|(
name|txr
operator|->
name|me
argument_list|)
argument_list|)
decl_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
name|error
return|;
return|return
literal|0
return|;
block|}
comment|/** ixgbe_sysctl_rdh_handler - Handler function  *  Retrieves the RDH value from the hardware  */
specifier|static
name|int
name|ixgbe_sysctl_rdh_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
operator|(
operator|(
expr|struct
name|rx_ring
operator|*
operator|)
name|oidp
operator|->
name|oid_arg1
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|rxr
condition|)
return|return
literal|0
return|;
name|unsigned
name|val
init|=
name|IXGBE_READ_REG
argument_list|(
operator|&
name|rxr
operator|->
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_RDH
argument_list|(
name|rxr
operator|->
name|me
argument_list|)
argument_list|)
decl_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
name|error
return|;
return|return
literal|0
return|;
block|}
comment|/** ixgbe_sysctl_rdt_handler - Handler function  *  Retrieves the RDT value from the hardware  */
specifier|static
name|int
name|ixgbe_sysctl_rdt_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
operator|(
operator|(
expr|struct
name|rx_ring
operator|*
operator|)
name|oidp
operator|->
name|oid_arg1
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|rxr
condition|)
return|return
literal|0
return|;
name|unsigned
name|val
init|=
name|IXGBE_READ_REG
argument_list|(
operator|&
name|rxr
operator|->
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_RDT
argument_list|(
name|rxr
operator|->
name|me
argument_list|)
argument_list|)
decl_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
name|error
return|;
return|return
literal|0
return|;
block|}
specifier|static
name|int
name|ixgbe_sysctl_interrupt_rate_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|ix_queue
modifier|*
name|que
init|=
operator|(
operator|(
expr|struct
name|ix_queue
operator|*
operator|)
name|oidp
operator|->
name|oid_arg1
operator|)
decl_stmt|;
name|unsigned
name|int
name|reg
decl_stmt|,
name|usec
decl_stmt|,
name|rate
decl_stmt|;
name|reg
operator|=
name|IXGBE_READ_REG
argument_list|(
operator|&
name|que
operator|->
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_EITR
argument_list|(
name|que
operator|->
name|msix
argument_list|)
argument_list|)
expr_stmt|;
name|usec
operator|=
operator|(
operator|(
name|reg
operator|&
literal|0x0FF8
operator|)
operator|>>
literal|3
operator|)
expr_stmt|;
if|if
condition|(
name|usec
operator|>
literal|0
condition|)
name|rate
operator|=
literal|500000
operator|/
name|usec
expr_stmt|;
else|else
name|rate
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|rate
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
name|error
return|;
name|reg
operator|&=
operator|~
literal|0xfff
expr_stmt|;
comment|/* default, no limitation */
name|ixgbe_max_interrupt_rate
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rate
operator|>
literal|0
operator|&&
name|rate
operator|<
literal|500000
condition|)
block|{
if|if
condition|(
name|rate
operator|<
literal|1000
condition|)
name|rate
operator|=
literal|1000
expr_stmt|;
name|ixgbe_max_interrupt_rate
operator|=
name|rate
expr_stmt|;
name|reg
operator||=
operator|(
operator|(
literal|4000000
operator|/
name|rate
operator|)
operator|&
literal|0xff8
operator|)
expr_stmt|;
block|}
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|que
operator|->
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_EITR
argument_list|(
name|que
operator|->
name|msix
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*  * Add sysctl variables, one per statistic, to the system.  */
specifier|static
name|void
name|ixgbe_add_hw_stats
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
name|adapter
operator|->
name|rx_rings
decl_stmt|;
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
init|=
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|tree
init|=
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|child
init|=
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
decl_stmt|;
name|struct
name|ixgbe_hw_stats
modifier|*
name|stats
init|=
operator|&
name|adapter
operator|->
name|stats
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|stat_node
decl_stmt|,
modifier|*
name|queue_node
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|stat_list
decl_stmt|,
modifier|*
name|queue_list
decl_stmt|;
define|#
directive|define
name|QUEUE_NAME_LEN
value|32
name|char
name|namebuf
index|[
name|QUEUE_NAME_LEN
index|]
decl_stmt|;
comment|/* Driver Statistics */
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dropped"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|dropped_pkts
argument_list|,
literal|"Driver dropped packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mbuf_defrag_failed"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|mbuf_defrag_failed
argument_list|,
literal|"m_defrag() failed"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"watchdog_events"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|watchdog_events
argument_list|,
literal|"Watchdog timeouts"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"link_irq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|link_irq
argument_list|,
literal|"Link MSIX IRQ Handled"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|txr
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|namebuf
argument_list|,
name|QUEUE_NAME_LEN
argument_list|,
literal|"queue%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|queue_node
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
name|namebuf
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"Queue Name"
argument_list|)
expr_stmt|;
name|queue_list
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|queue_node
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"interrupt_rate"
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|adapter
operator|->
name|queues
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
operator|&
name|adapter
operator|->
name|queues
index|[
name|i
index|]
argument_list|)
argument_list|,
name|ixgbe_sysctl_interrupt_rate_handler
argument_list|,
literal|"IU"
argument_list|,
literal|"Interrupt Rate"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"irqs"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|adapter
operator|->
name|queues
index|[
name|i
index|]
operator|.
name|irqs
operator|)
argument_list|,
literal|"irqs on this queue"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"txd_head"
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RD
argument_list|,
name|txr
argument_list|,
sizeof|sizeof
argument_list|(
name|txr
argument_list|)
argument_list|,
name|ixgbe_sysctl_tdh_handler
argument_list|,
literal|"IU"
argument_list|,
literal|"Transmit Descriptor Head"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"txd_tail"
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RD
argument_list|,
name|txr
argument_list|,
sizeof|sizeof
argument_list|(
name|txr
argument_list|)
argument_list|,
name|ixgbe_sysctl_tdt_handler
argument_list|,
literal|"IU"
argument_list|,
literal|"Transmit Descriptor Tail"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tso_tx"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txr
operator|->
name|tso_tx
argument_list|,
literal|"TSO"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"no_tx_dma_setup"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txr
operator|->
name|no_tx_dma_setup
argument_list|,
literal|"Driver tx dma failure in xmit"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"no_desc_avail"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txr
operator|->
name|no_desc_avail
argument_list|,
literal|"Queue No Descriptor Available"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_packets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txr
operator|->
name|total_packets
argument_list|,
literal|"Queue Packets Transmitted"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|rxr
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|namebuf
argument_list|,
name|QUEUE_NAME_LEN
argument_list|,
literal|"queue%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|queue_node
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
name|namebuf
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"Queue Name"
argument_list|)
expr_stmt|;
name|queue_list
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|queue_node
argument_list|)
expr_stmt|;
name|struct
name|lro_ctrl
modifier|*
name|lro
init|=
operator|&
name|rxr
operator|->
name|lro
decl_stmt|;
name|snprintf
argument_list|(
name|namebuf
argument_list|,
name|QUEUE_NAME_LEN
argument_list|,
literal|"queue%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|queue_node
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
name|namebuf
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"Queue Name"
argument_list|)
expr_stmt|;
name|queue_list
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|queue_node
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rxd_head"
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RD
argument_list|,
name|rxr
argument_list|,
sizeof|sizeof
argument_list|(
name|rxr
argument_list|)
argument_list|,
name|ixgbe_sysctl_rdh_handler
argument_list|,
literal|"IU"
argument_list|,
literal|"Receive Descriptor Head"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rxd_tail"
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RD
argument_list|,
name|rxr
argument_list|,
sizeof|sizeof
argument_list|(
name|rxr
argument_list|)
argument_list|,
name|ixgbe_sysctl_rdt_handler
argument_list|,
literal|"IU"
argument_list|,
literal|"Receive Descriptor Tail"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_packets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|rxr
operator|->
name|rx_packets
argument_list|,
literal|"Queue Packets Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_bytes"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|rxr
operator|->
name|rx_bytes
argument_list|,
literal|"Queue Bytes Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_copies"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|rxr
operator|->
name|rx_copies
argument_list|,
literal|"Copied RX Frames"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"lro_queued"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|lro
operator|->
name|lro_queued
argument_list|,
literal|0
argument_list|,
literal|"LRO Queued"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"lro_flushed"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|lro
operator|->
name|lro_flushed
argument_list|,
literal|0
argument_list|,
literal|"LRO Flushed"
argument_list|)
expr_stmt|;
block|}
comment|/* MAC stats get the own sub node */
name|stat_node
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mac_stats"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"MAC Statistics"
argument_list|)
expr_stmt|;
name|stat_list
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|stat_node
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"crc_errs"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|crcerrs
argument_list|,
literal|"CRC Errors"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ill_errs"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|illerrc
argument_list|,
literal|"Illegal Byte Errors"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"byte_errs"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|errbc
argument_list|,
literal|"Byte Errors"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"short_discards"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|mspdc
argument_list|,
literal|"MAC Short Packets Discarded"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"local_faults"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|mlfc
argument_list|,
literal|"MAC Local Faults"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"remote_faults"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|mrfc
argument_list|,
literal|"MAC Remote Faults"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rec_len_errs"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|rlec
argument_list|,
literal|"Receive Length Errors"
argument_list|)
expr_stmt|;
comment|/* Flow Control stats */
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"xon_txd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|lxontxc
argument_list|,
literal|"Link XON Transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"xon_recvd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|lxonrxc
argument_list|,
literal|"Link XON Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"xoff_txd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|lxofftxc
argument_list|,
literal|"Link XOFF Transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"xoff_recvd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|lxoffrxc
argument_list|,
literal|"Link XOFF Received"
argument_list|)
expr_stmt|;
comment|/* Packet Reception Stats */
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"total_octets_rcvd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|tor
argument_list|,
literal|"Total Octets Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"good_octets_rcvd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|gorc
argument_list|,
literal|"Good Octets Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"total_pkts_rcvd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|tpr
argument_list|,
literal|"Total Packets Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"good_pkts_rcvd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|gprc
argument_list|,
literal|"Good Packets Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mcast_pkts_rcvd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|mprc
argument_list|,
literal|"Multicast Packets Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"bcast_pkts_rcvd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|bprc
argument_list|,
literal|"Broadcast Packets Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_frames_64"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|prc64
argument_list|,
literal|"64 byte frames received "
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_frames_65_127"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|prc127
argument_list|,
literal|"65-127 byte frames received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_frames_128_255"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|prc255
argument_list|,
literal|"128-255 byte frames received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_frames_256_511"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|prc511
argument_list|,
literal|"256-511 byte frames received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_frames_512_1023"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|prc1023
argument_list|,
literal|"512-1023 byte frames received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_frames_1024_1522"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|prc1522
argument_list|,
literal|"1023-1522 byte frames received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"recv_undersized"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|ruc
argument_list|,
literal|"Receive Undersized"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"recv_fragmented"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|rfc
argument_list|,
literal|"Fragmented Packets Received "
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"recv_oversized"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|roc
argument_list|,
literal|"Oversized Packets Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"recv_jabberd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|rjc
argument_list|,
literal|"Received Jabber"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"management_pkts_rcvd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|mngprc
argument_list|,
literal|"Management Packets Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"management_pkts_drpd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|mngptc
argument_list|,
literal|"Management Packets Dropped"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"checksum_errs"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|xec
argument_list|,
literal|"Checksum Errors"
argument_list|)
expr_stmt|;
comment|/* Packet Transmission Stats */
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"good_octets_txd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|gotc
argument_list|,
literal|"Good Octets Transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"total_pkts_txd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|tpt
argument_list|,
literal|"Total Packets Transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"good_pkts_txd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|gptc
argument_list|,
literal|"Good Packets Transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"bcast_pkts_txd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|bptc
argument_list|,
literal|"Broadcast Packets Transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mcast_pkts_txd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|mptc
argument_list|,
literal|"Multicast Packets Transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"management_pkts_txd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|mngptc
argument_list|,
literal|"Management Packets Transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_frames_64"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|ptc64
argument_list|,
literal|"64 byte frames transmitted "
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_frames_65_127"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|ptc127
argument_list|,
literal|"65-127 byte frames transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_frames_128_255"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|ptc255
argument_list|,
literal|"128-255 byte frames transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_frames_256_511"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|ptc511
argument_list|,
literal|"256-511 byte frames transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_frames_512_1023"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|ptc1023
argument_list|,
literal|"512-1023 byte frames transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_frames_1024_1522"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|ptc1522
argument_list|,
literal|"1024-1522 byte frames transmitted"
argument_list|)
expr_stmt|;
block|}
comment|/* ** Set flow control using sysctl: ** Flow control values: ** 	0 - off **	1 - rx pause **	2 - tx pause **	3 - full */
specifier|static
name|int
name|ixgbe_set_flowcntl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|last
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
init|=
operator|(
expr|struct
name|adapter
operator|*
operator|)
name|arg1
decl_stmt|;
name|last
operator|=
name|adapter
operator|->
name|fc
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|adapter
operator|->
name|fc
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|)
operator|||
operator|(
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Don't bother if it's not changed */
if|if
condition|(
name|adapter
operator|->
name|fc
operator|==
name|last
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|adapter
operator|->
name|fc
condition|)
block|{
case|case
name|ixgbe_fc_rx_pause
case|:
case|case
name|ixgbe_fc_tx_pause
case|:
case|case
name|ixgbe_fc_full
case|:
name|adapter
operator|->
name|hw
operator|.
name|fc
operator|.
name|requested_mode
operator|=
name|adapter
operator|->
name|fc
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|num_queues
operator|>
literal|1
condition|)
name|ixgbe_disable_rx_drop
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
break|break;
case|case
name|ixgbe_fc_none
case|:
name|adapter
operator|->
name|hw
operator|.
name|fc
operator|.
name|requested_mode
operator|=
name|ixgbe_fc_none
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|num_queues
operator|>
literal|1
condition|)
name|ixgbe_enable_rx_drop
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
break|break;
default|default:
name|adapter
operator|->
name|fc
operator|=
name|last
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Don't autoneg if forcing a value */
name|adapter
operator|->
name|hw
operator|.
name|fc
operator|.
name|disable_fc_autoneg
operator|=
name|TRUE
expr_stmt|;
name|ixgbe_fc_enable
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* ** Control link advertise speed: **	1 - advertise only 1G **	2 - advertise 100Mb **	3 - advertise normal */
specifier|static
name|int
name|ixgbe_set_advertise
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
decl_stmt|;
name|ixgbe_link_speed
name|speed
decl_stmt|,
name|last
decl_stmt|;
name|adapter
operator|=
operator|(
expr|struct
name|adapter
operator|*
operator|)
name|arg1
expr_stmt|;
name|dev
operator|=
name|adapter
operator|->
name|dev
expr_stmt|;
name|hw
operator|=
operator|&
name|adapter
operator|->
name|hw
expr_stmt|;
name|last
operator|=
name|adapter
operator|->
name|advertise
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|adapter
operator|->
name|advertise
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|)
operator|||
operator|(
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|adapter
operator|->
name|advertise
operator|==
name|last
condition|)
comment|/* no change */
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
operator|(
operator|(
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|==
name|ixgbe_media_type_copper
operator|)
operator|||
operator|(
name|hw
operator|->
name|phy
operator|.
name|multispeed_fiber
operator|)
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|adapter
operator|->
name|advertise
operator|==
literal|2
operator|)
operator|&&
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|!=
name|ixgbe_mac_X540
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Set Advertise: 100Mb on X540 only\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|adapter
operator|->
name|advertise
operator|==
literal|1
condition|)
name|speed
operator|=
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
elseif|else
if|if
condition|(
name|adapter
operator|->
name|advertise
operator|==
literal|2
condition|)
name|speed
operator|=
name|IXGBE_LINK_SPEED_100_FULL
expr_stmt|;
elseif|else
if|if
condition|(
name|adapter
operator|->
name|advertise
operator|==
literal|3
condition|)
name|speed
operator|=
name|IXGBE_LINK_SPEED_1GB_FULL
operator||
name|IXGBE_LINK_SPEED_10GB_FULL
expr_stmt|;
else|else
block|{
comment|/* bogus value */
name|adapter
operator|->
name|advertise
operator|=
name|last
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|hw
operator|->
name|mac
operator|.
name|autotry_restart
operator|=
name|TRUE
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|setup_link
argument_list|(
name|hw
argument_list|,
name|speed
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* ** Thermal Shutdown Trigger **   - cause a Thermal Overtemp IRQ **   - this now requires firmware enabling */
specifier|static
name|int
name|ixgbe_set_thermal_test
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|fire
init|=
literal|0
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
init|=
operator|(
expr|struct
name|adapter
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|!=
name|ixgbe_mac_X540
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|fire
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|)
operator|||
operator|(
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|fire
condition|)
block|{
name|u32
name|reg
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EICS
argument_list|)
decl_stmt|;
name|reg
operator||=
name|IXGBE_EICR_TS
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EICS
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* ** Enable the hardware to drop packets when the buffer is ** full. This is useful when multiqueue,so that no single ** queue being full stalls the entire RX engine. We only ** enable this when Multiqueue AND when Flow Control is  ** disabled. */
specifier|static
name|void
name|ixgbe_enable_rx_drop
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|u32
name|srrctl
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SRRCTL
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|srrctl
operator||=
name|IXGBE_SRRCTL_DROP_EN
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SRRCTL
argument_list|(
name|i
argument_list|)
argument_list|,
name|srrctl
argument_list|)
expr_stmt|;
block|}
block|}
specifier|static
name|void
name|ixgbe_disable_rx_drop
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|u32
name|srrctl
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SRRCTL
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|srrctl
operator|&=
operator|~
name|IXGBE_SRRCTL_DROP_EN
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SRRCTL
argument_list|(
name|i
argument_list|)
argument_list|,
name|srrctl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

