begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*******************************************************************************  Copyright (c) 2001-2007, Intel Corporation All rights reserved.  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:   1. Redistributions of source code must retain the above copyright notice,     this list of conditions and the following disclaimer.   2. Redistributions in binary form must reproduce the above copyright     notice, this list of conditions and the following disclaimer in the     documentation and/or other materials provided with the distribution.   3. Neither the name of the Intel Corporation nor the names of its     contributors may be used to endorse or promote products derived from     this software without specific prior written permission.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  ***************************************************************************/
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_KERNEL_OPTION_HEADERS
end_ifdef

begin_include
include|#
directive|include
file|"opt_device_polling.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ixgbe.h"
end_include

begin_comment
comment|/*********************************************************************  *  Set this to one to display debug statistics  *********************************************************************/
end_comment

begin_decl_stmt
name|int
name|ixgbe_display_debug_stats
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************  *  Driver version  *********************************************************************/
end_comment

begin_decl_stmt
name|char
name|ixgbe_driver_version
index|[]
init|=
literal|"1.1.3"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************  *  PCI Device ID Table  *  *  Used by probe to select devices to load on  *  Last field stores an index into ixgbe_strings  *  Last entry must be all 0s  *  *  { Vendor ID, Device ID, SubVendor ID, SubDevice ID, String Index }  *********************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|ixgbe_vendor_info_t
name|ixgbe_vendor_info_array
index|[]
init|=
block|{
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_82598
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_82598AF_DUAL_PORT
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_82598AF_SINGLE_PORT
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_82598AT_DUAL_PORT
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* required last entry */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************  *  Table of branding strings  *********************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ixgbe_strings
index|[]
init|=
block|{
literal|"Intel(R) PRO/10GbE PCI-Express Network Driver"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************  *  Function prototypes  *********************************************************************/
end_comment

begin_function_decl
specifier|static
name|int
name|ixgbe_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_shutdown
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_watchdog
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_init_locked
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_stop
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|ifmediareq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_identify_hardware
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_allocate_pci_resources
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_free_pci_resources
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_local_timer
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_hardware_init
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_setup_interface
parameter_list|(
name|device_t
parameter_list|,
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_allocate_queues
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_allocate_msix_resources
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_setup_msix
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_allocate_transmit_buffers
parameter_list|(
name|struct
name|tx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_setup_transmit_structures
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_setup_transmit_ring
parameter_list|(
name|struct
name|tx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_initialize_transmit_units
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_free_transmit_structures
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_free_transmit_buffers
parameter_list|(
name|struct
name|tx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_allocate_receive_buffers
parameter_list|(
name|struct
name|rx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_setup_receive_structures
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_setup_receive_ring
parameter_list|(
name|struct
name|rx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_initialize_receive_units
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_free_receive_structures
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_free_receive_buffers
parameter_list|(
name|struct
name|rx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_enable_intr
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_disable_intr
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_update_stats_counters
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean_t
name|ixgbe_txeof
parameter_list|(
name|struct
name|tx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_rxeof
parameter_list|(
name|struct
name|rx_ring
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_rx_checksum
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_set_promisc
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_disable_promisc
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_set_multi
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_print_hw_stats
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_print_debug_info
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_update_link_status
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_get_buf
parameter_list|(
name|struct
name|rx_ring
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_enable_vlans
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_encap
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_sysctl_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_sysctl_debug
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_dma_malloc
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|bus_size_t
parameter_list|,
name|struct
name|ixgbe_dma_alloc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_dma_free
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|ixgbe_dma_alloc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_add_rx_process_limit
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean_t
name|ixgbe_tx_csum_setup
parameter_list|(
name|struct
name|tx_ring
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean_t
name|ixgbe_tso_setup
parameter_list|(
name|struct
name|tx_ring
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|u32
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_set_ivar
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|u16
parameter_list|,
name|u8
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_configure_ivars
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Legacy Interrupt handler */
end_comment

begin_function_decl
specifier|static
name|void
name|ixgbe_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The MSI/X Interrupt handlers */
end_comment

begin_function_decl
specifier|static
name|void
name|ixgbe_txint
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_rxint
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_linkint
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*********************************************************************  *  FreeBSD Device Interface Entry Points  *********************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|device_method_t
name|ixgbe_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ixgbe_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ixgbe_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|ixgbe_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|ixgbe_shutdown
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|ixgbe_driver
init|=
block|{
literal|"ix"
block|,
name|ixgbe_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|adapter
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|ixgbe_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|ixgbe
argument_list|,
name|pci
argument_list|,
name|ixgbe_driver
argument_list|,
name|ixgbe_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ixgbe
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ixgbe
argument_list|,
name|ether
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* How many packets rxeof tries to clean at a time */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ixgbe_rx_process_limit
init|=
literal|100
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ixgbe.rx_process_limit"
argument_list|,
operator|&
name|ixgbe_rx_process_limit
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Should the driver do MSI/X and RSS/MQ?  *	- default to MSI/X and RSS enabled  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ixgbe_disable_msix
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ixgbe.disable_msix"
argument_list|,
operator|&
name|ixgbe_disable_msix
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ** Flow control tuneable: ** 	0 - off **	1 - rx pause **	2 - tx pause **	3 - full */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ixgbe_flow_control
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ixgbe.flow_control"
argument_list|,
operator|&
name|ixgbe_flow_control
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*********************************************************************  *  Device identification routine  *  *  ixgbe_probe determines if the driver should be loaded on  *  adapter based on PCI vendor/device id of the adapter.  *  *  return 0 on success, positive on failure  *********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|ixgbe_vendor_info_t
modifier|*
name|ent
decl_stmt|;
name|u_int16_t
name|pci_vendor_id
init|=
literal|0
decl_stmt|;
name|u_int16_t
name|pci_device_id
init|=
literal|0
decl_stmt|;
name|u_int16_t
name|pci_subvendor_id
init|=
literal|0
decl_stmt|;
name|u_int16_t
name|pci_subdevice_id
init|=
literal|0
decl_stmt|;
name|char
name|adapter_name
index|[
literal|60
index|]
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixgbe_probe: begin"
argument_list|)
expr_stmt|;
name|pci_vendor_id
operator|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_vendor_id
operator|!=
name|IXGBE_INTEL_VENDOR_ID
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|pci_device_id
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_subvendor_id
operator|=
name|pci_get_subvendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_subdevice_id
operator|=
name|pci_get_subdevice
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ent
operator|=
name|ixgbe_vendor_info_array
expr_stmt|;
while|while
condition|(
name|ent
operator|->
name|vendor_id
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|pci_vendor_id
operator|==
name|ent
operator|->
name|vendor_id
operator|)
operator|&&
operator|(
name|pci_device_id
operator|==
name|ent
operator|->
name|device_id
operator|)
operator|&&
operator|(
operator|(
name|pci_subvendor_id
operator|==
name|ent
operator|->
name|subvendor_id
operator|)
operator|||
operator|(
name|ent
operator|->
name|subvendor_id
operator|==
literal|0
operator|)
operator|)
operator|&&
operator|(
operator|(
name|pci_subdevice_id
operator|==
name|ent
operator|->
name|subdevice_id
operator|)
operator|||
operator|(
name|ent
operator|->
name|subdevice_id
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|adapter_name
argument_list|,
literal|"%s, Version - %s"
argument_list|,
name|ixgbe_strings
index|[
name|ent
operator|->
name|index
index|]
argument_list|,
name|ixgbe_driver_version
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|adapter_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ent
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Device initialization routine  *  *  The attach entry point is called when the driver is being loaded.  *  This routine identifies the type of hardware, allocates all resources  *  and initializes the hardware.  *  *  return 0 on success, positive on failure  *********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|uint32_t
name|ctrl_ext
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixgbe_attach: begin"
argument_list|)
expr_stmt|;
comment|/* Allocate, clear, and link in our adapter structure */
name|adapter
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|dev
operator|=
name|adapter
operator|->
name|osdep
operator|.
name|dev
operator|=
name|dev
expr_stmt|;
name|IXGBE_LOCK_INIT
argument_list|(
name|adapter
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* SYSCTL APIs */
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stats"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|adapter
argument_list|,
literal|0
argument_list|,
name|ixgbe_sysctl_stats
argument_list|,
literal|"I"
argument_list|,
literal|"Statistics"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"debug"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|adapter
argument_list|,
literal|0
argument_list|,
name|ixgbe_sysctl_debug
argument_list|,
literal|"I"
argument_list|,
literal|"Debug Info"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"flow control"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ixgbe_flow_control
argument_list|,
literal|0
argument_list|,
literal|"Flow Control"
argument_list|)
expr_stmt|;
comment|/* Set up the timer callout */
name|callout_init_mtx
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|,
operator|&
name|adapter
operator|->
name|mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Determine hardware revision */
name|ixgbe_identify_hardware
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* 	** Descriptors: (configurable by user), note these are 	** constant for all rings, I saw no reason to vary  	** them, but perhaps someone later would. 	*/
name|adapter
operator|->
name|num_tx_desc
operator|=
name|DEFAULT_TXD
expr_stmt|;
name|adapter
operator|->
name|num_rx_desc
operator|=
name|DEFAULT_RXD
expr_stmt|;
comment|/* Indicate to RX setup to use Jumbo Clusters */
name|adapter
operator|->
name|bigbufs
operator|=
name|TRUE
expr_stmt|;
comment|/* Do base PCI setup - map BAR0 */
if|if
condition|(
name|ixgbe_allocate_pci_resources
argument_list|(
name|adapter
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Allocation of PCI resources failed\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
comment|/* Allocate our TX/RX Queues */
if|if
condition|(
name|ixgbe_allocate_queues
argument_list|(
name|adapter
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
if|if
condition|(
name|adapter
operator|->
name|msix
condition|)
block|{
name|error
operator|=
name|ixgbe_setup_msix
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|err_out
goto|;
block|}
comment|/* Initialize the shared code */
if|if
condition|(
name|ixgbe_init_shared_code
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to initialize the shared code\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
comment|/* Initialize the hardware */
if|if
condition|(
name|ixgbe_hardware_init
argument_list|(
name|adapter
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to initialize the hardware\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
comment|/* Setup OS specific network interface */
name|ixgbe_setup_interface
argument_list|(
name|dev
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
comment|/* Sysctl for limiting the amount of work done in the taskqueue */
name|ixgbe_add_rx_process_limit
argument_list|(
name|adapter
argument_list|,
literal|"rx_processing_limit"
argument_list|,
literal|"max number of rx packets to process"
argument_list|,
operator|&
name|adapter
operator|->
name|rx_process_limit
argument_list|,
name|ixgbe_rx_process_limit
argument_list|)
expr_stmt|;
comment|/* Initialize statistics */
name|ixgbe_update_stats_counters
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* let hardware know driver is loaded */
name|ctrl_ext
operator|=
name|IXGBE_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_CTRL_EXT
argument_list|)
expr_stmt|;
name|ctrl_ext
operator||=
name|IXGBE_CTRL_EXT_DRV_LOAD
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_CTRL_EXT
argument_list|,
name|ctrl_ext
argument_list|)
expr_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixgbe_attach: end"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|err_out
label|:
name|ixgbe_free_pci_resources
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Device removal routine  *  *  The detach entry point is called when the driver is being removed.  *  This routine stops the adapter and deallocates all the resources  *  that were allocated for driver operation.  *  *  return 0 on success, positive on failure  *********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u32
name|ctrl_ext
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixgbe_detach: begin"
argument_list|)
expr_stmt|;
comment|/* Make sure VLANS are not using driver */
if|if
condition|(
name|adapter
operator|->
name|ifp
operator|->
name|if_vlantrunk
operator|!=
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Vlan in use, detach first\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|IXGBE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixgbe_stop
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|IXGBE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* let hardware know driver is unloading */
name|ctrl_ext
operator|=
name|IXGBE_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_CTRL_EXT
argument_list|)
expr_stmt|;
name|ctrl_ext
operator|&=
operator|~
name|IXGBE_CTRL_EXT_DRV_LOAD
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_CTRL_EXT
argument_list|,
name|ctrl_ext
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|)
expr_stmt|;
name|ixgbe_free_pci_resources
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|bus_generic_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|ixgbe_free_transmit_structures
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixgbe_free_receive_structures
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|IXGBE_LOCK_DESTROY
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Shutdown entry point  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|IXGBE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixgbe_stop
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|IXGBE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Transmit entry point  *  *  ixgbe_start is called by the stack to initiate a transmit.  *  The driver will remain in this routine as long as there are  *  packets to transmit and transmit resources are available.  *  In case resources are not available stack is notified and  *  the packet is requeued.  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_head
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|IXGBE_LOCK_ASSERT
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
operator|)
operator|!=
name|IFF_DRV_RUNNING
condition|)
return|return;
if|if
condition|(
operator|!
name|adapter
operator|->
name|link_active
condition|)
return|return;
while|while
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
block|{
name|IFQ_DRV_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_head
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|ixgbe_encap
argument_list|(
name|adapter
argument_list|,
operator|&
name|m_head
argument_list|)
condition|)
block|{
if|if
condition|(
name|m_head
operator|==
name|NULL
condition|)
break|break;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
name|IFQ_DRV_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Send a copy of the frame to the BPF listener */
name|BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
comment|/* Set timeout in case hardware has problems transmitting */
name|adapter
operator|->
name|watchdog_timer
operator|=
name|IXGBE_TX_TIMEOUT
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ixgbe_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|IXGBE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|ixgbe_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|IXGBE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Ioctl entry point  *  *  ixgbe_ioctl is called when the user wants to configure the  *  interface.  *  *  return 0 on success, positive on failure  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl: SIOCxIFADDR (Get/Set Interface Addr)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
name|IXGBE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixgbe_init_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|IXGBE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
name|arp_ifinit
argument_list|(
name|ifp
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
block|}
else|else
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFMTU
case|:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl: SIOCSIFMTU (Set Interface MTU)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|>
name|IXGBE_MAX_FRAME_SIZE
operator|-
name|ETHER_HDR_LEN
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|IXGBE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
name|adapter
operator|->
name|max_frame_size
operator|=
name|ifp
operator|->
name|if_mtu
operator|+
name|ETHER_HDR_LEN
operator|+
name|ETHER_CRC_LEN
expr_stmt|;
name|ixgbe_init_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|IXGBE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFFLAGS
case|:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl: SIOCSIFFLAGS (Set Interface Flags)"
argument_list|)
expr_stmt|;
name|IXGBE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|^
name|adapter
operator|->
name|if_flags
operator|)
operator|&
name|IFF_PROMISC
condition|)
block|{
name|ixgbe_disable_promisc
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixgbe_set_promisc
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|ixgbe_init_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|ixgbe_stop
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|if_flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
name|IXGBE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl: SIOC(ADD|DEL)MULTI"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|IXGBE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixgbe_disable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixgbe_set_multi
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixgbe_enable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|IXGBE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl: SIOCxIFMEDIA (Get/Set Interface Media)"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
block|{
name|int
name|mask
init|=
name|ifr
operator|->
name|ifr_reqcap
operator|^
name|ifp
operator|->
name|if_capenable
decl_stmt|;
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl: SIOCSIFCAP (Set Capabilities)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_HWCSUM
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_HWCSUM
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO4
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TSO4
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWTAGGING
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWTAGGING
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|ixgbe_init
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|VLAN_CAPABILITIES
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|IOCTL_DEBUGOUT1
argument_list|(
literal|"ioctl: UNKNOWN (0x%X)\n"
argument_list|,
operator|(
name|int
operator|)
name|command
argument_list|)
expr_stmt|;
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Watchdog entry point  *  *  This routine is called whenever hardware quits transmitting.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_watchdog
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|IXGBE_LOCK_ASSERT
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/*          * The timer is set to 5 every time ixgbe_start() queues a packet.          * Then ixgbe_txeof() keeps resetting to 5 as long as it cleans at          * least one descriptor.          * Finally, anytime all descriptors are clean the timer is          * set to 0.          */
if|if
condition|(
name|adapter
operator|->
name|watchdog_timer
operator|==
literal|0
operator|||
operator|--
name|adapter
operator|->
name|watchdog_timer
condition|)
return|return;
comment|/* 	 * If we are in this routine because of pause frames, then don't 	 * reset the hardware. 	 */
if|if
condition|(
name|IXGBE_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_TFCS
argument_list|)
operator|&
name|IXGBE_TFCS_TXOFF
condition|)
block|{
name|adapter
operator|->
name|watchdog_timer
operator|=
name|IXGBE_TX_TIMEOUT
expr_stmt|;
return|return;
block|}
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"Watchdog timeout -- resetting\n"
argument_list|)
expr_stmt|;
name|ixgbe_print_debug_info
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|adapter
operator|->
name|watchdog_events
operator|++
expr_stmt|;
name|ixgbe_init_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Init entry point  *  *  This routine is used in two ways. It is used by the stack as  *  init entry point in network interface structure. It is also used  *  by the driver as a hw/sw initialization routine to get to a  *  consistent state.  *  *  return 0 on success, positive on failure  **********************************************************************/
end_comment

begin_define
define|#
directive|define
name|IXGBE_MHADD_MFS_SHIFT
value|16
end_define

begin_function
specifier|static
name|void
name|ixgbe_init_locked
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|u32
name|txdctl
decl_stmt|,
name|rxdctl
decl_stmt|,
name|mhadd
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixgbe_init: begin"
argument_list|)
expr_stmt|;
name|IXGBE_LOCK_ASSERT
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixgbe_stop
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Get the latest mac address, User can use a LAA */
name|bcopy
argument_list|(
name|IF_LLADDR
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|)
argument_list|,
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|addr
argument_list|,
name|IXGBE_ETH_LENGTH_OF_ADDRESS
argument_list|)
expr_stmt|;
comment|/* Initialize the hardware */
if|if
condition|(
name|ixgbe_hardware_init
argument_list|(
name|adapter
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to initialize the hardware\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWTAGGING
condition|)
name|ixgbe_enable_vlans
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Prepare transmit descriptors and buffers */
if|if
condition|(
name|ixgbe_setup_transmit_structures
argument_list|(
name|adapter
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not setup transmit structures\n"
argument_list|)
expr_stmt|;
name|ixgbe_stop
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return;
block|}
name|ixgbe_initialize_transmit_units
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Setup Multicast table */
name|ixgbe_set_multi
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* 	** If we are resetting MTU smaller than 2K 	** drop to small RX buffers 	*/
if|if
condition|(
name|adapter
operator|->
name|max_frame_size
operator|<=
name|MCLBYTES
condition|)
name|adapter
operator|->
name|bigbufs
operator|=
name|FALSE
expr_stmt|;
comment|/* Prepare receive descriptors and buffers */
if|if
condition|(
name|ixgbe_setup_receive_structures
argument_list|(
name|adapter
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not setup receive structures\n"
argument_list|)
expr_stmt|;
name|ixgbe_stop
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Configure RX settings */
name|ixgbe_initialize_receive_units
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Enable Enhanced MSIX mode */
if|if
condition|(
name|adapter
operator|->
name|msix
condition|)
block|{
name|u32
name|gpie
decl_stmt|;
name|gpie
operator|=
name|IXGBE_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_GPIE
argument_list|)
expr_stmt|;
name|gpie
operator||=
name|IXGBE_GPIE_MSIX_MODE
expr_stmt|;
name|gpie
operator||=
name|IXGBE_GPIE_EIAME
operator||
name|IXGBE_GPIE_PBA_SUPPORT
operator||
name|IXGBE_GPIE_OCD
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_GPIE
argument_list|,
name|gpie
argument_list|)
expr_stmt|;
name|gpie
operator|=
name|IXGBE_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_GPIE
argument_list|)
expr_stmt|;
block|}
comment|/* Set the various hardware offload abilities */
name|ifp
operator|->
name|if_hwassist
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO4
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
name|CSUM_TSO
expr_stmt|;
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM
condition|)
name|ifp
operator|->
name|if_hwassist
operator|=
operator|(
name|CSUM_TCP
operator||
name|CSUM_UDP
operator|)
expr_stmt|;
comment|/* Set MTU size */
if|if
condition|(
name|ifp
operator|->
name|if_mtu
operator|>
name|ETHERMTU
condition|)
block|{
name|mhadd
operator|=
name|IXGBE_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_MHADD
argument_list|)
expr_stmt|;
name|mhadd
operator|&=
operator|~
name|IXGBE_MHADD_MFS_MASK
expr_stmt|;
name|mhadd
operator||=
name|adapter
operator|->
name|max_frame_size
operator|<<
name|IXGBE_MHADD_MFS_SHIFT
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_MHADD
argument_list|,
name|mhadd
argument_list|)
expr_stmt|;
block|}
comment|/* Now enable all the queues */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_tx_queues
condition|;
name|i
operator|++
control|)
block|{
name|txdctl
operator|=
name|IXGBE_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_TXDCTL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|txdctl
operator||=
name|IXGBE_TXDCTL_ENABLE
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_TXDCTL
argument_list|(
name|i
argument_list|)
argument_list|,
name|txdctl
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_rx_queues
condition|;
name|i
operator|++
control|)
block|{
name|rxdctl
operator|=
name|IXGBE_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_RXDCTL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|rxdctl
operator||=
name|IXGBE_RXDCTL_ENABLE
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_RXDCTL
argument_list|(
name|i
argument_list|)
argument_list|,
name|rxdctl
argument_list|)
expr_stmt|;
block|}
name|callout_reset
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|,
name|hz
argument_list|,
name|ixgbe_local_timer
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
comment|/* Set up MSI/X routing */
name|ixgbe_configure_ivars
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixgbe_enable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Now inform the stack we're ready */
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ixgbe_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|arg
decl_stmt|;
name|IXGBE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixgbe_init_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|IXGBE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Legacy Interrupt Service routine  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|u32
name|loop_cnt
init|=
name|MAX_INTR
decl_stmt|;
name|u32
name|reg_eicr
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
name|adapter
operator|->
name|rx_rings
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
name|IXGBE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|reg_eicr
operator|=
name|IXGBE_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_EICR
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_eicr
operator|==
literal|0
condition|)
block|{
name|IXGBE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Link status change */
if|if
condition|(
name|reg_eicr
operator|&
name|IXGBE_EICR_LSC
condition|)
block|{
name|callout_stop
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|)
expr_stmt|;
name|ixgbe_update_link_status
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|,
name|hz
argument_list|,
name|ixgbe_local_timer
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
operator|--
name|loop_cnt
operator|>
literal|0
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
name|ixgbe_rxeof
argument_list|(
name|rxr
argument_list|,
name|adapter
operator|->
name|rx_process_limit
argument_list|)
expr_stmt|;
name|ixgbe_txeof
argument_list|(
name|txr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|&&
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_head
operator|!=
name|NULL
condition|)
name|ixgbe_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|IXGBE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  MSI TX Interrupt Service routine  *  **********************************************************************/
end_comment

begin_function
name|void
name|ixgbe_txint
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|arg
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|txr
operator|->
name|adapter
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|uint32_t
name|loop_cnt
init|=
name|MAX_INTR
decl_stmt|;
name|IXGBE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
while|while
condition|(
name|loop_cnt
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|__predict_false
argument_list|(
operator|!
name|ixgbe_txeof
argument_list|(
name|txr
argument_list|)
argument_list|)
condition|)
break|break;
name|loop_cnt
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|&&
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_head
operator|!=
name|NULL
condition|)
name|ixgbe_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ixgbe_enable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|IXGBE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  MSI RX Interrupt Service routine  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_rxint
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
name|arg
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|rxr
operator|->
name|adapter
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
comment|//uint32_t       reg_eicr, loop = MAX_INTR;
name|uint32_t
name|loop
init|=
name|MAX_INTR
decl_stmt|;
name|IXGBE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|loop
operator|--
operator|>
literal|0
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
name|ixgbe_rxeof
argument_list|(
name|rxr
argument_list|,
name|adapter
operator|->
name|rx_process_limit
argument_list|)
expr_stmt|;
name|ixgbe_enable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|IXGBE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixgbe_linkint
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|arg
decl_stmt|;
name|uint32_t
name|reg_eicr
decl_stmt|;
name|IXGBE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|reg_eicr
operator|=
name|IXGBE_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_EICR
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_eicr
operator|&
name|IXGBE_EICR_LSC
condition|)
block|{
name|callout_stop
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|)
expr_stmt|;
name|ixgbe_update_link_status
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|,
name|hz
argument_list|,
name|ixgbe_local_timer
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
block|}
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_EIMS
argument_list|,
name|IXGBE_EIMS_OTHER
argument_list|)
expr_stmt|;
name|ixgbe_enable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|IXGBE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Media Ioctl callback  *  *  This routine is called whenever the user queries the status of  *  the interface using ifconfig.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixgbe_media_status: begin"
argument_list|)
expr_stmt|;
name|ixgbe_update_link_status
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
expr_stmt|;
if|if
condition|(
operator|!
name|adapter
operator|->
name|link_active
condition|)
return|return;
name|ifmr
operator|->
name|ifm_status
operator||=
name|IFM_ACTIVE
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10G_SR
operator||
name|IFM_FDX
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Media Ioctl callback  *  *  This routine is called when the user changes speed/duplex using  *  media/mediopt option with ifconfig.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifmedia
modifier|*
name|ifm
init|=
operator|&
name|adapter
operator|->
name|media
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixgbe_media_change: begin"
argument_list|)
expr_stmt|;
if|if
condition|(
name|IFM_TYPE
argument_list|(
name|ifm
operator|->
name|ifm_media
argument_list|)
operator|!=
name|IFM_ETHER
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  This routine maps the mbufs to tx descriptors.  *    WARNING: while this code is using an MQ style infrastructure,  *    it would NOT work as is with more than 1 queue.  *  *  return 0 on success, positive on failure  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_encap
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m_headp
parameter_list|)
block|{
name|u32
name|olinfo_status
init|=
literal|0
decl_stmt|,
name|cmd_type_len
init|=
literal|0
decl_stmt|;
name|u32
name|paylen
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|error
decl_stmt|,
name|nsegs
decl_stmt|;
name|int
name|first
decl_stmt|,
name|last
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_head
decl_stmt|;
name|bus_dma_segment_t
name|segs
index|[
name|IXGBE_MAX_SCATTER
index|]
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
name|struct
name|ixgbe_tx_buf
modifier|*
name|txbuf
decl_stmt|,
modifier|*
name|txbuf_mapped
decl_stmt|;
name|union
name|ixgbe_adv_tx_desc
modifier|*
name|txd
init|=
name|NULL
decl_stmt|;
name|m_head
operator|=
operator|*
name|m_headp
expr_stmt|;
name|paylen
operator|=
literal|0
expr_stmt|;
comment|/* Basic descriptor defines */
name|cmd_type_len
operator||=
name|IXGBE_ADVTXD_DTYP_DATA
expr_stmt|;
name|cmd_type_len
operator||=
name|IXGBE_ADVTXD_DCMD_IFCS
operator||
name|IXGBE_ADVTXD_DCMD_DEXT
expr_stmt|;
if|if
condition|(
name|m_head
operator|->
name|m_flags
operator|&
name|M_VLANTAG
condition|)
name|cmd_type_len
operator||=
name|IXGBE_ADVTXD_DCMD_VLE
expr_stmt|;
comment|/* 	 * Force a cleanup if number of TX descriptors 	 * available is below the threshold. If it fails 	 * to get above, then abort transmit. 	 */
if|if
condition|(
name|txr
operator|->
name|tx_avail
operator|<=
name|IXGBE_TX_CLEANUP_THRESHOLD
condition|)
block|{
name|ixgbe_txeof
argument_list|(
name|txr
argument_list|)
expr_stmt|;
comment|/* Make sure things have improved */
if|if
condition|(
name|txr
operator|->
name|tx_avail
operator|<=
name|IXGBE_TX_OP_THRESHOLD
condition|)
block|{
name|adapter
operator|->
name|no_tx_desc_avail1
operator|++
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
block|}
comment|/*          * Important to capture the first descriptor          * used because it will contain the index of          * the one we tell the hardware to report back          */
name|first
operator|=
name|txr
operator|->
name|next_avail_tx_desc
expr_stmt|;
name|txbuf
operator|=
operator|&
name|txr
operator|->
name|tx_buffers
index|[
name|first
index|]
expr_stmt|;
name|txbuf_mapped
operator|=
name|txbuf
expr_stmt|;
name|map
operator|=
name|txbuf
operator|->
name|map
expr_stmt|;
comment|/* 	 * Map the packet for DMA. 	 */
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|map
argument_list|,
operator|*
name|m_headp
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EFBIG
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|m
operator|=
name|m_defrag
argument_list|(
operator|*
name|m_headp
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|adapter
operator|->
name|mbuf_alloc_failed
operator|++
expr_stmt|;
name|m_freem
argument_list|(
operator|*
name|m_headp
argument_list|)
expr_stmt|;
operator|*
name|m_headp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
operator|*
name|m_headp
operator|=
name|m
expr_stmt|;
comment|/* Try it again */
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|map
argument_list|,
operator|*
name|m_headp
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOMEM
condition|)
block|{
name|adapter
operator|->
name|no_tx_dma_setup
operator|++
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|adapter
operator|->
name|no_tx_dma_setup
operator|++
expr_stmt|;
name|m_freem
argument_list|(
operator|*
name|m_headp
argument_list|)
expr_stmt|;
operator|*
name|m_headp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|error
operator|==
name|ENOMEM
condition|)
block|{
name|adapter
operator|->
name|no_tx_dma_setup
operator|++
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|adapter
operator|->
name|no_tx_dma_setup
operator|++
expr_stmt|;
name|m_freem
argument_list|(
operator|*
name|m_headp
argument_list|)
expr_stmt|;
operator|*
name|m_headp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Make certain there are enough descriptors */
if|if
condition|(
name|nsegs
operator|>
name|txr
operator|->
name|tx_avail
operator|-
literal|2
condition|)
block|{
name|adapter
operator|->
name|no_tx_desc_avail2
operator|++
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|encap_fail
goto|;
block|}
name|m_head
operator|=
operator|*
name|m_headp
expr_stmt|;
comment|/* 	** Set the appropriate offload context 	** this becomes the first descriptor of  	** a packet. 	*/
if|if
condition|(
name|ixgbe_tso_setup
argument_list|(
name|txr
argument_list|,
name|m_head
argument_list|,
operator|&
name|paylen
argument_list|)
condition|)
block|{
name|cmd_type_len
operator||=
name|IXGBE_ADVTXD_DCMD_TSE
expr_stmt|;
name|olinfo_status
operator||=
name|IXGBE_TXD_POPTS_IXSM
operator|<<
literal|8
expr_stmt|;
name|olinfo_status
operator||=
name|IXGBE_TXD_POPTS_TXSM
operator|<<
literal|8
expr_stmt|;
name|olinfo_status
operator||=
name|paylen
operator|<<
name|IXGBE_ADVTXD_PAYLEN_SHIFT
expr_stmt|;
operator|++
name|adapter
operator|->
name|tso_tx
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_OFFLOAD
condition|)
block|{
if|if
condition|(
name|ixgbe_tx_csum_setup
argument_list|(
name|txr
argument_list|,
name|m_head
argument_list|)
condition|)
name|olinfo_status
operator||=
name|IXGBE_TXD_POPTS_TXSM
operator|<<
literal|8
expr_stmt|;
block|}
name|i
operator|=
name|txr
operator|->
name|next_avail_tx_desc
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nsegs
condition|;
name|j
operator|++
control|)
block|{
name|bus_size_t
name|seglen
decl_stmt|;
name|bus_addr_t
name|segaddr
decl_stmt|;
name|txbuf
operator|=
operator|&
name|txr
operator|->
name|tx_buffers
index|[
name|i
index|]
expr_stmt|;
name|txd
operator|=
operator|&
name|txr
operator|->
name|tx_base
index|[
name|i
index|]
expr_stmt|;
name|seglen
operator|=
name|segs
index|[
name|j
index|]
operator|.
name|ds_len
expr_stmt|;
name|segaddr
operator|=
name|htole64
argument_list|(
name|segs
index|[
name|j
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|txd
operator|->
name|read
operator|.
name|buffer_addr
operator|=
name|segaddr
expr_stmt|;
name|txd
operator|->
name|read
operator|.
name|cmd_type_len
operator|=
name|htole32
argument_list|(
name|txr
operator|->
name|txd_cmd
operator||
name|cmd_type_len
operator||
name|seglen
argument_list|)
expr_stmt|;
name|txd
operator|->
name|read
operator|.
name|olinfo_status
operator|=
name|htole32
argument_list|(
name|olinfo_status
argument_list|)
expr_stmt|;
name|last
operator|=
name|i
expr_stmt|;
comment|/* Next descriptor that will get completed */
if|if
condition|(
operator|++
name|i
operator|==
name|adapter
operator|->
name|num_tx_desc
condition|)
name|i
operator|=
literal|0
expr_stmt|;
name|txbuf
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
name|txbuf
operator|->
name|next_eop
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 		** we have to do this inside the loop right now 		** because of the hardware workaround. 		*/
if|if
condition|(
name|j
operator|==
operator|(
name|nsegs
operator|-
literal|1
operator|)
condition|)
comment|/* Last descriptor gets EOP and RS */
name|txd
operator|->
name|read
operator|.
name|cmd_type_len
operator||=
name|htole32
argument_list|(
name|IXGBE_TXD_CMD_EOP
operator||
name|IXGBE_TXD_CMD_RS
argument_list|)
expr_stmt|;
block|}
name|txr
operator|->
name|tx_avail
operator|-=
name|nsegs
expr_stmt|;
name|txr
operator|->
name|next_avail_tx_desc
operator|=
name|i
expr_stmt|;
name|txbuf
operator|->
name|m_head
operator|=
name|m_head
expr_stmt|;
name|txbuf
operator|->
name|map
operator|=
name|map
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* Set the index of the descriptor that will be marked done */
name|txbuf
operator|=
operator|&
name|txr
operator|->
name|tx_buffers
index|[
name|first
index|]
expr_stmt|;
name|txbuf
operator|->
name|next_eop
operator|=
name|last
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|txdma
operator|.
name|dma_tag
argument_list|,
name|txr
operator|->
name|txdma
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* 	 * Advance the Transmit Descriptor Tail (Tdt), this tells the 	 * hardware that this frame is available to transmit. 	 */
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_TDT
argument_list|(
name|txr
operator|->
name|me
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|encap_fail
label|:
name|bus_dmamap_unload
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|txbuf
operator|->
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixgbe_set_promisc
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|u_int32_t
name|reg_rctl
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|reg_rctl
operator|=
name|IXGBE_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_FCTRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
name|reg_rctl
operator||=
operator|(
name|IXGBE_FCTRL_UPE
operator||
name|IXGBE_FCTRL_MPE
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_FCTRL
argument_list|,
name|reg_rctl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
condition|)
block|{
name|reg_rctl
operator||=
name|IXGBE_FCTRL_MPE
expr_stmt|;
name|reg_rctl
operator|&=
operator|~
name|IXGBE_FCTRL_UPE
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_FCTRL
argument_list|,
name|reg_rctl
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ixgbe_disable_promisc
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|u_int32_t
name|reg_rctl
decl_stmt|;
name|reg_rctl
operator|=
name|IXGBE_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_FCTRL
argument_list|)
expr_stmt|;
name|reg_rctl
operator|&=
operator|(
operator|~
name|IXGBE_FCTRL_UPE
operator|)
expr_stmt|;
name|reg_rctl
operator|&=
operator|(
operator|~
name|IXGBE_FCTRL_MPE
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_FCTRL
argument_list|,
name|reg_rctl
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Multicast Update  *  *  This routine is called whenever multicast address list is updated.  *  **********************************************************************/
end_comment

begin_define
define|#
directive|define
name|IXGBE_RAR_ENTRIES
value|16
end_define

begin_function
specifier|static
name|void
name|ixgbe_set_multi
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|uint32_t
name|fctrl
decl_stmt|;
name|uint8_t
name|mta
index|[
name|MAX_NUM_MULTICAST_ADDRESSES
operator|*
name|IXGBE_ETH_LENGTH_OF_ADDRESS
index|]
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|int
name|mcnt
init|=
literal|0
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ixgbe_set_multi: begin"
argument_list|)
expr_stmt|;
name|fctrl
operator|=
name|IXGBE_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_FCTRL
argument_list|)
expr_stmt|;
name|fctrl
operator||=
operator|(
name|IXGBE_FCTRL_UPE
operator||
name|IXGBE_FCTRL_MPE
operator|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
name|fctrl
operator||=
operator|(
name|IXGBE_FCTRL_UPE
operator||
name|IXGBE_FCTRL_MPE
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
condition|)
block|{
name|fctrl
operator||=
name|IXGBE_FCTRL_MPE
expr_stmt|;
name|fctrl
operator|&=
operator|~
name|IXGBE_FCTRL_UPE
expr_stmt|;
block|}
else|else
name|fctrl
operator|&=
operator|~
operator|(
name|IXGBE_FCTRL_UPE
operator||
name|IXGBE_FCTRL_MPE
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_FCTRL
argument_list|,
name|fctrl
argument_list|)
expr_stmt|;
name|IF_ADDR_LOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|bcopy
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|,
operator|&
name|mta
index|[
name|mcnt
operator|*
name|IXGBE_ETH_LENGTH_OF_ADDRESS
index|]
argument_list|,
name|IXGBE_ETH_LENGTH_OF_ADDRESS
argument_list|)
expr_stmt|;
name|mcnt
operator|++
expr_stmt|;
block|}
name|IF_ADDR_UNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ixgbe_update_mc_addr_list
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|mta
argument_list|,
name|mcnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Timer routine  *  *  This routine checks for link status,updates statistics,  *  and runs the watchdog timer.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_local_timer
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|IXGBE_LOCK_ASSERT
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixgbe_update_link_status
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixgbe_update_stats_counters
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|ixgbe_display_debug_stats
operator|&&
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|ixgbe_print_hw_stats
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Each second we check the watchdog 	 * to protect against hardware hangs. 	 */
name|ixgbe_watchdog
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|,
name|hz
argument_list|,
name|ixgbe_local_timer
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixgbe_update_link_status
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|uint32_t
name|link_speed
decl_stmt|;
name|boolean_t
name|link_up
init|=
name|FALSE
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|ixgbe_check_link
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
operator|&
name|link_speed
argument_list|,
operator|&
name|link_up
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_up
condition|)
block|{
if|if
condition|(
name|adapter
operator|->
name|link_active
operator|==
name|FALSE
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Link is up %d Mbps %s \n"
argument_list|,
literal|10000
argument_list|,
literal|"Full Duplex"
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|link_active
operator|=
name|TRUE
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_UP
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Link down */
if|if
condition|(
name|adapter
operator|->
name|link_active
operator|==
name|TRUE
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Link is Down\n"
argument_list|)
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_DOWN
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|link_active
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  This routine disables all traffic on the adapter by issuing a  *  global reset on the MAC and deallocates TX/RX buffers.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_stop
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|arg
decl_stmt|;
name|ifp
operator|=
name|adapter
operator|->
name|ifp
expr_stmt|;
name|IXGBE_LOCK_ASSERT
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixgbe_stop: begin\n"
argument_list|)
expr_stmt|;
name|ixgbe_disable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Tell the stack that the interface is no longer active */
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
name|ixgbe_reset_hw
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|adapter_stopped
operator|=
name|FALSE
expr_stmt|;
name|ixgbe_stop_adapter
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|)
expr_stmt|;
name|ixgbe_reset_hw
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Determine hardware revision.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_identify_hardware
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
comment|/* Save off the information about this board */
name|adapter
operator|->
name|hw
operator|.
name|vendor_id
operator|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|device_id
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|revision_id
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_REVID
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|subsystem_vendor_id
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SUBVEND_0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|subsystem_device_id
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SUBDEV_0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Setup MSIX: this is a prereq for doing Multiqueue/RSS.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_setup_msix
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
name|adapter
operator|->
name|rx_rings
decl_stmt|;
name|int
name|error
decl_stmt|,
name|vector
init|=
literal|0
decl_stmt|;
comment|/* TX setup: the code is here for multi tx, 	   there are other parts of the driver not ready for it */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_tx_queues
condition|;
name|i
operator|++
operator|,
name|vector
operator|++
operator|,
name|txr
operator|++
control|)
block|{
name|adapter
operator|->
name|res
index|[
name|vector
index|]
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|adapter
operator|->
name|rid
index|[
name|vector
index|]
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|adapter
operator|->
name|res
index|[
name|vector
index|]
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate"
literal|" bus resource: tx interrupt [%d]\n"
argument_list|,
name|vector
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Set the handler function */
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|adapter
operator|->
name|res
index|[
name|vector
index|]
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|ixgbe_txint
argument_list|,
name|txr
argument_list|,
operator|&
name|adapter
operator|->
name|tag
index|[
name|vector
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|adapter
operator|->
name|res
index|[
name|vector
index|]
operator|=
name|NULL
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to register TX handler"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|adapter
operator|->
name|msix
operator|++
expr_stmt|;
block|}
comment|/* RX setup */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_rx_queues
condition|;
name|i
operator|++
operator|,
name|vector
operator|++
operator|,
name|rxr
operator|++
control|)
block|{
name|adapter
operator|->
name|res
index|[
name|vector
index|]
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|adapter
operator|->
name|rid
index|[
name|vector
index|]
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|adapter
operator|->
name|res
index|[
name|vector
index|]
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate"
literal|" bus resource: rx interrupt [%d],"
literal|"rid = %d\n"
argument_list|,
name|i
argument_list|,
name|adapter
operator|->
name|rid
index|[
name|vector
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Set the handler function */
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|adapter
operator|->
name|res
index|[
name|vector
index|]
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|ixgbe_rxint
argument_list|,
name|rxr
argument_list|,
operator|&
name|adapter
operator|->
name|tag
index|[
name|vector
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|adapter
operator|->
name|res
index|[
name|vector
index|]
operator|=
name|NULL
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to register RX handler"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|adapter
operator|->
name|msix
operator|++
expr_stmt|;
block|}
comment|/* Now for Link changes */
name|adapter
operator|->
name|res
index|[
name|vector
index|]
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|adapter
operator|->
name|rid
index|[
name|vector
index|]
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|adapter
operator|->
name|res
index|[
name|vector
index|]
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate"
literal|" bus resource: Link interrupt [%d]\n"
argument_list|,
name|adapter
operator|->
name|rid
index|[
name|vector
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Set the link handler function */
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|adapter
operator|->
name|res
index|[
name|vector
index|]
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|ixgbe_linkint
argument_list|,
name|adapter
argument_list|,
operator|&
name|adapter
operator|->
name|tag
index|[
name|vector
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|adapter
operator|->
name|res
index|[
name|vector
index|]
operator|=
name|NULL
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to register LINK handler"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|adapter
operator|->
name|msix
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixgbe_allocate_pci_resources
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|rid
decl_stmt|;
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|rid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|res_memory
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|adapter
operator|->
name|res_memory
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate bus resource: memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|adapter
operator|->
name|osdep
operator|.
name|mem_bus_space_tag
operator|=
name|rman_get_bustag
argument_list|(
name|adapter
operator|->
name|res_memory
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|osdep
operator|.
name|mem_bus_space_handle
operator|=
name|rman_get_bushandle
argument_list|(
name|adapter
operator|->
name|res_memory
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|hw_addr
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|adapter
operator|->
name|osdep
operator|.
name|mem_bus_space_handle
expr_stmt|;
comment|/* 	 * First try to setup MSI/X interrupts, 	 * if that fails fall back to Legacy. 	 */
if|if
condition|(
name|ixgbe_allocate_msix_resources
argument_list|(
name|adapter
argument_list|)
condition|)
block|{
name|adapter
operator|->
name|num_tx_queues
operator|=
literal|1
expr_stmt|;
name|adapter
operator|->
name|num_rx_queues
operator|=
literal|1
expr_stmt|;
name|adapter
operator|->
name|msix
operator|=
literal|0
expr_stmt|;
name|rid
operator|=
literal|0
expr_stmt|;
name|adapter
operator|->
name|res
index|[
literal|0
index|]
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|adapter
operator|->
name|rid
index|[
literal|0
index|]
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|res
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate bus "
literal|"resource: interrupt\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Set the handler function */
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|adapter
operator|->
name|res
index|[
literal|0
index|]
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|ixgbe_intr
argument_list|,
name|adapter
argument_list|,
operator|&
name|adapter
operator|->
name|tag
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|adapter
operator|->
name|res
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to register Legacy handler"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|adapter
operator|->
name|hw
operator|.
name|back
operator|=
operator|&
name|adapter
operator|->
name|osdep
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attempt to configure MSI/X, the prefered  * interrupt option.  */
end_comment

begin_function
specifier|static
name|int
name|ixgbe_allocate_msix_resources
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|val
decl_stmt|,
name|want
decl_stmt|,
name|rid
decl_stmt|;
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|int
name|vector
init|=
literal|1
decl_stmt|;
comment|/* An artificial means to force it off */
if|if
condition|(
name|ixgbe_disable_msix
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* First map the MSIX table */
name|rid
operator|=
name|PCIR_BAR
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|res_msix
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|adapter
operator|->
name|res_msix
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to map MSIX table \n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Now figure out now many vectors we need to use */
name|val
operator|=
name|pci_msix_count
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* check configured values */
name|want
operator|=
name|IXGBE_TX_QUEUES
operator|+
name|IXGBE_RX_QUEUES
operator|+
name|IXGBE_OTHER
expr_stmt|;
comment|/* 	 *  We arent going to do anything fancy for now, 	 *  we either can meet desired config or we fail. 	 */
if|if
condition|(
name|val
operator|>=
name|want
condition|)
name|val
operator|=
name|want
expr_stmt|;
else|else
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"FAIL MSI/X setup:\n"
literal|"\tqueues wanted = %d\n"
literal|"\tqueues available = %d\n"
literal|"\tPlease reconfigure settings\n"
argument_list|,
name|want
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Initialize the resource arrays */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|IXGBE_MSGS
condition|;
name|i
operator|++
operator|,
name|vector
operator|++
control|)
block|{
name|adapter
operator|->
name|rid
index|[
name|i
index|]
operator|=
name|vector
expr_stmt|;
name|adapter
operator|->
name|tag
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|adapter
operator|->
name|res
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|adapter
operator|->
name|num_tx_queues
operator|=
name|IXGBE_TX_QUEUES
expr_stmt|;
name|adapter
operator|->
name|num_rx_queues
operator|=
name|IXGBE_RX_QUEUES
expr_stmt|;
comment|/* Now allocate the vectors */
if|if
condition|(
operator|(
name|error
operator|=
name|pci_alloc_msix
argument_list|(
name|dev
argument_list|,
operator|&
name|val
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|adapter
operator|->
name|msix
operator|=
literal|1
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"MSI/X enabled with %d vectors\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"FAIL pci_alloc_msix() %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixgbe_free_pci_resources
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|int
name|i
decl_stmt|,
name|loop
decl_stmt|;
comment|/* 	 * Legacy has this set to 0, but we need 	 * to run this once, so reset it. 	 */
if|if
condition|(
name|adapter
operator|->
name|msix
condition|)
name|loop
operator|=
name|adapter
operator|->
name|msix
expr_stmt|;
else|else
name|loop
operator|=
literal|1
expr_stmt|;
comment|/* 	 * First release all the interrupt resources: 	 * 	notice that since these are just kept 	 *	in an array we can do the same logic 	 * 	whether its MSIX or just legacy. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|adapter
operator|->
name|tag
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|adapter
operator|->
name|res
index|[
name|i
index|]
argument_list|,
name|adapter
operator|->
name|tag
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|tag
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|adapter
operator|->
name|res
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|adapter
operator|->
name|rid
index|[
name|i
index|]
argument_list|,
name|adapter
operator|->
name|res
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|adapter
operator|->
name|msix
condition|)
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|res_memory
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|IXGBE_MMBA
argument_list|,
name|adapter
operator|->
name|res_memory
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Initialize the hardware to a configuration as specified by the  *  adapter structure. The controller is reset, the EEPROM is  *  verified, the MAC address is set, then the shared initialization  *  routines are called.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_hardware_init
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|uint16_t
name|csum
decl_stmt|;
name|csum
operator|=
literal|0
expr_stmt|;
comment|/* Issue a global reset */
name|adapter
operator|->
name|hw
operator|.
name|adapter_stopped
operator|=
name|FALSE
expr_stmt|;
name|ixgbe_stop_adapter
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
comment|/* Make sure we have a good EEPROM before we read from it */
if|if
condition|(
name|ixgbe_validate_eeprom_checksum
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
operator|&
name|csum
argument_list|)
operator|<
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"The EEPROM Checksum Is Not Valid\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* Get Hardware Flow Control setting */
name|adapter
operator|->
name|hw
operator|.
name|fc
operator|.
name|original_type
operator|=
name|ixgbe_flow_control
expr_stmt|;
if|if
condition|(
name|ixgbe_init_hw
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Hardware Initialization Failed"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Setup networking device structure and register an interface.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_setup_interface
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixgbe_setup_interface: begin"
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|adapter
operator|->
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"%s: can not if_alloc()\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_baudrate
operator|=
literal|1000000000
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|ixgbe_init
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|adapter
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|ixgbe_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|ixgbe_start
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|NULL
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|adapter
operator|->
name|num_tx_desc
operator|-
literal|1
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|addr
argument_list|)
expr_stmt|;
comment|/* Override ether_ifattach */
name|ifp
operator|->
name|if_mtu
operator|=
name|PERFORMANCE_MTU
expr_stmt|;
comment|/* set to 9K by default */
name|adapter
operator|->
name|max_frame_size
operator|=
name|ifp
operator|->
name|if_mtu
operator|+
name|ETHER_HDR_LEN
operator|+
name|ETHER_CRC_LEN
expr_stmt|;
comment|/* 	 * Tell the upper layer(s) we support long frames. 	 */
name|ifp
operator|->
name|if_data
operator|.
name|ifi_hdrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_vlan_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|msix
condition|)
comment|/* Don't use CSUM with RSS */
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_TSO4
expr_stmt|;
else|else
name|ifp
operator|->
name|if_capabilities
operator||=
operator|(
name|IFCAP_HWCSUM
operator||
name|IFCAP_TSO4
operator|)
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_VLAN_HWTAGGING
operator||
name|IFCAP_VLAN_MTU
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_JUMBO_MTU
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|=
name|ifp
operator|->
name|if_capabilities
expr_stmt|;
comment|/* 	 * Specify the media types supported by this adapter and register 	 * callbacks to update media and link information 	 */
name|ifmedia_init
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_IMASK
argument_list|,
name|ixgbe_media_change
argument_list|,
name|ixgbe_media_status
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10G_SR
operator||
name|IFM_FDX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/********************************************************************  * Manage DMA'able memory.  *******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_dmamap_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
if|if
condition|(
name|error
condition|)
return|return;
operator|*
operator|(
name|bus_addr_t
operator|*
operator|)
name|arg
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|ixgbe_dma_malloc
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|bus_size_t
name|size
parameter_list|,
name|struct
name|ixgbe_dma_alloc
modifier|*
name|dma
parameter_list|,
name|int
name|mapflags
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|int
name|r
decl_stmt|;
name|r
operator|=
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
comment|/* parent */
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|,
comment|/* alignment, bounds */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|size
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|size
argument_list|,
comment|/* maxsegsize */
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lockfunc */
name|NULL
argument_list|,
comment|/* lockfuncarg */
operator|&
name|dma
operator|->
name|dma_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ixgbe_dma_malloc: bus_dma_tag_create failed; "
literal|"error %u\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
goto|goto
name|fail_0
goto|;
block|}
name|r
operator|=
name|bus_dmamem_alloc
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|dma
operator|->
name|dma_vaddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ixgbe_dma_malloc: bus_dmamem_alloc failed; "
literal|"error %u\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
goto|goto
name|fail_1
goto|;
block|}
name|r
operator|=
name|bus_dmamap_load
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|,
name|dma
operator|->
name|dma_vaddr
argument_list|,
name|size
argument_list|,
name|ixgbe_dmamap_cb
argument_list|,
operator|&
name|dma
operator|->
name|dma_paddr
argument_list|,
name|mapflags
operator||
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ixgbe_dma_malloc: bus_dmamap_load failed; "
literal|"error %u\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
goto|goto
name|fail_2
goto|;
block|}
name|dma
operator|->
name|dma_size
operator|=
name|size
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail_2
label|:
name|bus_dmamem_free
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|dma
operator|->
name|dma_vaddr
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
name|fail_1
label|:
name|bus_dma_tag_destroy
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|)
expr_stmt|;
name|fail_0
label|:
name|dma
operator|->
name|dma_map
operator|=
name|NULL
expr_stmt|;
name|dma
operator|->
name|dma_tag
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixgbe_dma_free
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|struct
name|ixgbe_dma_alloc
modifier|*
name|dma
parameter_list|)
block|{
name|bus_dmamap_unload
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|dma
operator|->
name|dma_vaddr
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Allocate memory for the transmit and receive rings, and then  *  the descriptors associated with each, called only once at attach.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_allocate_queues
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
decl_stmt|;
name|int
name|rsize
decl_stmt|,
name|error
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|int
name|txconf
init|=
literal|0
decl_stmt|,
name|rxconf
init|=
literal|0
decl_stmt|;
comment|/* First allocate the TX ring struct memory */
if|if
condition|(
operator|!
operator|(
name|adapter
operator|->
name|tx_rings
operator|=
operator|(
expr|struct
name|tx_ring
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tx_ring
argument_list|)
operator|*
name|adapter
operator|->
name|num_tx_queues
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate TX ring memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|txr
operator|=
name|adapter
operator|->
name|tx_rings
expr_stmt|;
comment|/* Next allocate the RX */
if|if
condition|(
operator|!
operator|(
name|adapter
operator|->
name|rx_rings
operator|=
operator|(
expr|struct
name|rx_ring
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|rx_ring
argument_list|)
operator|*
name|adapter
operator|->
name|num_rx_queues
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate RX ring memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|rx_fail
goto|;
block|}
name|rxr
operator|=
name|adapter
operator|->
name|rx_rings
expr_stmt|;
comment|/* Only do this once, RX and TX desc are the same size */
name|rsize
operator|=
name|roundup2
argument_list|(
name|adapter
operator|->
name|num_tx_desc
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|ixgbe_adv_tx_desc
argument_list|)
argument_list|,
literal|4096
argument_list|)
expr_stmt|;
comment|/* 	 * Now set up the TX queues, txconf is needed to handle the 	 * possibility that things fail midcourse and we need to 	 * undo memory gracefully 	 */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_tx_queues
condition|;
name|i
operator|++
operator|,
name|txconf
operator|++
control|)
block|{
comment|/* Set up some basics */
name|txr
operator|=
operator|&
name|adapter
operator|->
name|tx_rings
index|[
name|i
index|]
expr_stmt|;
name|txr
operator|->
name|adapter
operator|=
name|adapter
expr_stmt|;
name|txr
operator|->
name|me
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|ixgbe_dma_malloc
argument_list|(
name|adapter
argument_list|,
name|rsize
argument_list|,
operator|&
name|txr
operator|->
name|txdma
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate TX Descriptor memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_tx_desc
goto|;
block|}
name|txr
operator|->
name|tx_base
operator|=
operator|(
expr|union
name|ixgbe_adv_tx_desc
operator|*
operator|)
name|txr
operator|->
name|txdma
operator|.
name|dma_vaddr
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|txr
operator|->
name|tx_base
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
comment|/* Now allocate transmit buffers for the ring */
if|if
condition|(
name|ixgbe_allocate_transmit_buffers
argument_list|(
name|txr
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Critical Failure setting up transmit buffers\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_tx_desc
goto|;
block|}
block|}
comment|/* 	 * Next the RX queues... 	 */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_rx_queues
condition|;
name|i
operator|++
operator|,
name|rxconf
operator|++
control|)
block|{
name|rxr
operator|=
operator|&
name|adapter
operator|->
name|rx_rings
index|[
name|i
index|]
expr_stmt|;
comment|/* Set up some basics */
name|rxr
operator|->
name|adapter
operator|=
name|adapter
expr_stmt|;
name|rxr
operator|->
name|me
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|ixgbe_dma_malloc
argument_list|(
name|adapter
argument_list|,
name|rsize
argument_list|,
operator|&
name|rxr
operator|->
name|rxdma
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate RxDescriptor memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_rx_desc
goto|;
block|}
name|rxr
operator|->
name|rx_base
operator|=
operator|(
expr|union
name|ixgbe_adv_rx_desc
operator|*
operator|)
name|rxr
operator|->
name|rxdma
operator|.
name|dma_vaddr
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|rxr
operator|->
name|rx_base
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
comment|/* Allocate receive buffers for the ring*/
if|if
condition|(
name|ixgbe_allocate_receive_buffers
argument_list|(
name|rxr
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Critical Failure setting up receive buffers\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_rx_desc
goto|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|err_rx_desc
label|:
for|for
control|(
name|rxr
operator|=
name|adapter
operator|->
name|rx_rings
init|;
name|rxconf
operator|>
literal|0
condition|;
name|rxr
operator|++
operator|,
name|rxconf
operator|--
control|)
name|ixgbe_dma_free
argument_list|(
name|adapter
argument_list|,
operator|&
name|rxr
operator|->
name|rxdma
argument_list|)
expr_stmt|;
name|err_tx_desc
label|:
for|for
control|(
name|txr
operator|=
name|adapter
operator|->
name|tx_rings
init|;
name|txconf
operator|>
literal|0
condition|;
name|txr
operator|++
operator|,
name|txconf
operator|--
control|)
name|ixgbe_dma_free
argument_list|(
name|adapter
argument_list|,
operator|&
name|txr
operator|->
name|txdma
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|adapter
operator|->
name|rx_rings
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|rx_fail
label|:
name|free
argument_list|(
name|adapter
operator|->
name|tx_rings
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|fail
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Allocate memory for tx_buffer structures. The tx_buffer stores all  *  the information needed to transmit a packet on the wire. This is  *  called only once at attach, setup is done every reset.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_allocate_transmit_buffers
parameter_list|(
name|struct
name|tx_ring
modifier|*
name|txr
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|txr
operator|->
name|adapter
decl_stmt|;
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|struct
name|ixgbe_tx_buf
modifier|*
name|txbuf
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
comment|/* 	 * Setup DMA descriptor areas. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
comment|/* parent */
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|,
comment|/* alignment, bounds */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|IXGBE_TSO_SIZE
argument_list|,
comment|/* maxsize */
name|IXGBE_MAX_SCATTER
argument_list|,
comment|/* nsegments */
name|PAGE_SIZE
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lockfunc */
name|NULL
argument_list|,
comment|/* lockfuncarg */
operator|&
name|txr
operator|->
name|txtag
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate TX DMA tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|txr
operator|->
name|tx_buffers
operator|=
operator|(
expr|struct
name|ixgbe_tx_buf
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ixgbe_tx_buf
argument_list|)
operator|*
name|adapter
operator|->
name|num_tx_desc
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate tx_buffer memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Create the descriptor buffer dma maps */
name|txbuf
operator|=
name|txr
operator|->
name|tx_buffers
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_tx_desc
condition|;
name|i
operator|++
operator|,
name|txbuf
operator|++
control|)
block|{
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
literal|0
argument_list|,
operator|&
name|txbuf
operator|->
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to create TX DMA map\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
return|return
literal|0
return|;
name|fail
label|:
comment|/* We free all, it handles case where we are in the middle */
name|ixgbe_free_transmit_structures
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Initialize a transmit ring.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_setup_transmit_ring
parameter_list|(
name|struct
name|tx_ring
modifier|*
name|txr
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|txr
operator|->
name|adapter
decl_stmt|;
name|struct
name|ixgbe_tx_buf
modifier|*
name|txbuf
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Clear the old ring contents */
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|txr
operator|->
name|tx_base
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|union
name|ixgbe_adv_tx_desc
argument_list|)
operator|)
operator|*
name|adapter
operator|->
name|num_tx_desc
argument_list|)
expr_stmt|;
comment|/* Reset indices */
name|txr
operator|->
name|next_avail_tx_desc
operator|=
literal|0
expr_stmt|;
name|txr
operator|->
name|next_tx_to_clean
operator|=
literal|0
expr_stmt|;
comment|/* Free any existing tx buffers. */
name|txbuf
operator|=
name|txr
operator|->
name|tx_buffers
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_tx_desc
condition|;
name|i
operator|++
operator|,
name|txbuf
operator|++
control|)
block|{
if|if
condition|(
name|txbuf
operator|->
name|m_head
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|txbuf
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|txbuf
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|txbuf
operator|->
name|m_head
argument_list|)
expr_stmt|;
name|txbuf
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* clear the watch index */
name|txbuf
operator|->
name|next_eop
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Set number of descriptors available */
name|txr
operator|->
name|tx_avail
operator|=
name|adapter
operator|->
name|num_tx_desc
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|txdma
operator|.
name|dma_tag
argument_list|,
name|txr
operator|->
name|txdma
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Initialize all transmit rings.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_setup_transmit_structures
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_tx_queues
condition|;
name|i
operator|++
operator|,
name|txr
operator|++
control|)
name|ixgbe_setup_transmit_ring
argument_list|(
name|txr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Enable transmit unit.  *	NOTE: this will need to be changed if there are more than  *	one transmit queues.  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_initialize_transmit_units
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
name|uint64_t
name|tdba
init|=
name|txr
operator|->
name|txdma
operator|.
name|dma_paddr
decl_stmt|;
comment|/* Setup the Base and Length of the Tx Descriptor Ring */
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_TDBAL
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|(
name|tdba
operator|&
literal|0x00000000ffffffffULL
operator|)
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_TDBAH
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|(
name|tdba
operator|>>
literal|32
operator|)
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_TDLEN
argument_list|(
literal|0
argument_list|)
argument_list|,
name|adapter
operator|->
name|num_tx_desc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ixgbe_legacy_tx_desc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Setup the HW Tx Head and Tail descriptor pointers */
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_TDH
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_TDT
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_TIPG
argument_list|,
name|IXGBE_TIPG_FIBER_DEFAULT
argument_list|)
expr_stmt|;
comment|/* Setup Transmit Descriptor Cmd Settings */
name|txr
operator|->
name|txd_cmd
operator|=
name|IXGBE_TXD_CMD_IFCS
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Free all transmit rings.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_free_transmit_structures
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_tx_queues
condition|;
name|i
operator|++
operator|,
name|txr
operator|++
control|)
block|{
name|ixgbe_free_transmit_buffers
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|ixgbe_dma_free
argument_list|(
name|adapter
argument_list|,
operator|&
name|txr
operator|->
name|txdma
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|adapter
operator|->
name|tx_rings
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Free transmit ring related data structures.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_free_transmit_buffers
parameter_list|(
name|struct
name|tx_ring
modifier|*
name|txr
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|txr
operator|->
name|adapter
decl_stmt|;
name|struct
name|ixgbe_tx_buf
modifier|*
name|tx_buffer
decl_stmt|;
name|int
name|i
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"free_transmit_ring: begin"
argument_list|)
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|tx_buffers
operator|==
name|NULL
condition|)
return|return;
name|tx_buffer
operator|=
name|txr
operator|->
name|tx_buffers
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_tx_desc
condition|;
name|i
operator|++
operator|,
name|tx_buffer
operator|++
control|)
block|{
if|if
condition|(
name|tx_buffer
operator|->
name|m_head
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|tx_buffer
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|tx_buffer
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|tx_buffer
operator|->
name|m_head
argument_list|)
expr_stmt|;
name|tx_buffer
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|tx_buffer
operator|->
name|map
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|tx_buffer
operator|->
name|map
argument_list|)
expr_stmt|;
name|tx_buffer
operator|->
name|map
operator|=
name|NULL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|tx_buffer
operator|->
name|map
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|tx_buffer
operator|->
name|map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|tx_buffer
operator|->
name|map
argument_list|)
expr_stmt|;
name|tx_buffer
operator|->
name|map
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|txr
operator|->
name|tx_buffers
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|txr
operator|->
name|tx_buffers
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|txr
operator|->
name|tx_buffers
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|txr
operator|->
name|txtag
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|txr
operator|->
name|txtag
argument_list|)
expr_stmt|;
name|txr
operator|->
name|txtag
operator|=
name|NULL
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Advanced Context Descriptor setup for VLAN or CSUM  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|boolean_t
name|ixgbe_tx_csum_setup
parameter_list|(
name|struct
name|tx_ring
modifier|*
name|txr
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mp
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|txr
operator|->
name|adapter
decl_stmt|;
name|struct
name|ixgbe_adv_tx_context_desc
modifier|*
name|TXD
decl_stmt|;
name|struct
name|ixgbe_tx_buf
modifier|*
name|tx_buffer
decl_stmt|;
name|uint32_t
name|vlan_macip_lens
init|=
literal|0
decl_stmt|,
name|type_tucmd_mlhl
init|=
literal|0
decl_stmt|;
name|struct
name|ether_vlan_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|int
name|ehdrlen
decl_stmt|,
name|ip_hlen
decl_stmt|;
name|u16
name|etype
decl_stmt|;
name|u8
name|ipproto
decl_stmt|;
name|int
name|ctxd
init|=
name|txr
operator|->
name|next_avail_tx_desc
decl_stmt|;
name|u16
name|vtag
init|=
literal|0
decl_stmt|;
name|tx_buffer
operator|=
operator|&
name|txr
operator|->
name|tx_buffers
index|[
name|ctxd
index|]
expr_stmt|;
name|TXD
operator|=
operator|(
expr|struct
name|ixgbe_adv_tx_context_desc
operator|*
operator|)
operator|&
name|txr
operator|->
name|tx_base
index|[
name|ctxd
index|]
expr_stmt|;
comment|/* 	** In advanced descriptors the vlan tag must  	** be placed into the descriptor itself. 	*/
if|if
condition|(
name|mp
operator|->
name|m_flags
operator|&
name|M_VLANTAG
condition|)
block|{
name|vtag
operator|=
name|htole16
argument_list|(
name|mp
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
argument_list|)
expr_stmt|;
name|vlan_macip_lens
operator||=
operator|(
name|vtag
operator|<<
name|IXGBE_ADVTXD_VLAN_SHIFT
operator|)
expr_stmt|;
block|}
comment|/* 	 * Determine where frame payload starts. 	 * Jump over vlan headers if already present, 	 * helpful for QinQ too. 	 */
name|eh
operator|=
name|mtod
argument_list|(
name|mp
argument_list|,
expr|struct
name|ether_vlan_header
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|evl_encap_proto
operator|==
name|htons
argument_list|(
name|ETHERTYPE_VLAN
argument_list|)
condition|)
block|{
name|etype
operator|=
name|ntohs
argument_list|(
name|eh
operator|->
name|evl_proto
argument_list|)
expr_stmt|;
name|ehdrlen
operator|=
name|ETHER_HDR_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
block|}
else|else
block|{
name|etype
operator|=
name|ntohs
argument_list|(
name|eh
operator|->
name|evl_encap_proto
argument_list|)
expr_stmt|;
name|ehdrlen
operator|=
name|ETHER_HDR_LEN
expr_stmt|;
block|}
comment|/* Set the ether header length */
name|vlan_macip_lens
operator||=
name|ehdrlen
operator|<<
name|IXGBE_ADVTXD_MACLEN_SHIFT
expr_stmt|;
switch|switch
condition|(
name|etype
condition|)
block|{
case|case
name|ETHERTYPE_IP
case|:
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|mp
operator|->
name|m_data
operator|+
name|ehdrlen
operator|)
expr_stmt|;
name|ip_hlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_len
operator|<
name|ehdrlen
operator|+
name|ip_hlen
condition|)
return|return
name|FALSE
return|;
comment|/* failure */
name|ipproto
operator|=
name|ip
operator|->
name|ip_p
expr_stmt|;
name|type_tucmd_mlhl
operator||=
name|IXGBE_ADVTXD_TUCMD_IPV4
expr_stmt|;
break|break;
case|case
name|ETHERTYPE_IPV6
case|:
name|ip6
operator|=
operator|(
expr|struct
name|ip6_hdr
operator|*
operator|)
operator|(
name|mp
operator|->
name|m_data
operator|+
name|ehdrlen
operator|)
expr_stmt|;
name|ip_hlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_len
operator|<
name|ehdrlen
operator|+
name|ip_hlen
condition|)
return|return
name|FALSE
return|;
comment|/* failure */
name|ipproto
operator|=
name|ip6
operator|->
name|ip6_nxt
expr_stmt|;
name|type_tucmd_mlhl
operator||=
name|IXGBE_ADVTXD_TUCMD_IPV6
expr_stmt|;
break|break;
default|default:
return|return
name|FALSE
return|;
block|}
name|vlan_macip_lens
operator||=
name|ip_hlen
expr_stmt|;
name|type_tucmd_mlhl
operator||=
name|IXGBE_ADVTXD_DCMD_DEXT
operator||
name|IXGBE_ADVTXD_DTYP_CTXT
expr_stmt|;
switch|switch
condition|(
name|ipproto
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
if|if
condition|(
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TCP
condition|)
name|type_tucmd_mlhl
operator||=
name|IXGBE_ADVTXD_TUCMD_L4T_TCP
expr_stmt|;
break|break;
case|case
name|IPPROTO_UDP
case|:
if|if
condition|(
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_UDP
condition|)
name|type_tucmd_mlhl
operator||=
name|IXGBE_ADVTXD_TUCMD_L4T_UDP
expr_stmt|;
break|break;
block|}
comment|/* Now copy bits into descriptor */
name|TXD
operator|->
name|vlan_macip_lens
operator||=
name|htole32
argument_list|(
name|vlan_macip_lens
argument_list|)
expr_stmt|;
name|TXD
operator|->
name|type_tucmd_mlhl
operator||=
name|htole32
argument_list|(
name|type_tucmd_mlhl
argument_list|)
expr_stmt|;
name|TXD
operator|->
name|seqnum_seed
operator|=
name|htole32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|TXD
operator|->
name|mss_l4len_idx
operator|=
name|htole32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|tx_buffer
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
name|tx_buffer
operator|->
name|next_eop
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* We've consumed the first desc, adjust counters */
if|if
condition|(
operator|++
name|ctxd
operator|==
name|adapter
operator|->
name|num_tx_desc
condition|)
name|ctxd
operator|=
literal|0
expr_stmt|;
name|txr
operator|->
name|next_avail_tx_desc
operator|=
name|ctxd
expr_stmt|;
operator|--
name|txr
operator|->
name|tx_avail
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  *  *  Setup work for hardware segmentation offload (TSO) on  *  adapters using advanced tx descriptors  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|boolean_t
name|ixgbe_tso_setup
parameter_list|(
name|struct
name|tx_ring
modifier|*
name|txr
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mp
parameter_list|,
name|u32
modifier|*
name|paylen
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|txr
operator|->
name|adapter
decl_stmt|;
name|struct
name|ixgbe_adv_tx_context_desc
modifier|*
name|TXD
decl_stmt|;
name|struct
name|ixgbe_tx_buf
modifier|*
name|tx_buffer
decl_stmt|;
name|u32
name|vlan_macip_lens
init|=
literal|0
decl_stmt|,
name|type_tucmd_mlhl
init|=
literal|0
decl_stmt|;
name|u32
name|mss_l4len_idx
init|=
literal|0
decl_stmt|;
name|u16
name|vtag
init|=
literal|0
decl_stmt|;
name|int
name|ctxd
decl_stmt|,
name|ehdrlen
decl_stmt|,
name|hdrlen
decl_stmt|,
name|ip_hlen
decl_stmt|,
name|tcp_hlen
decl_stmt|;
name|struct
name|ether_vlan_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|th
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TSO
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|mp
operator|->
name|m_pkthdr
operator|.
name|len
operator|<=
name|IXGBE_TX_BUFFER_SIZE
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* 	 * Determine where frame payload starts. 	 * Jump over vlan headers if already present 	 */
name|eh
operator|=
name|mtod
argument_list|(
name|mp
argument_list|,
expr|struct
name|ether_vlan_header
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|evl_encap_proto
operator|==
name|htons
argument_list|(
name|ETHERTYPE_VLAN
argument_list|)
condition|)
name|ehdrlen
operator|=
name|ETHER_HDR_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
else|else
name|ehdrlen
operator|=
name|ETHER_HDR_LEN
expr_stmt|;
comment|/* Ensure we have at least the IP+TCP header in the first mbuf. */
if|if
condition|(
name|mp
operator|->
name|m_len
operator|<
name|ehdrlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|ctxd
operator|=
name|txr
operator|->
name|next_avail_tx_desc
expr_stmt|;
name|tx_buffer
operator|=
operator|&
name|txr
operator|->
name|tx_buffers
index|[
name|ctxd
index|]
expr_stmt|;
name|TXD
operator|=
operator|(
expr|struct
name|ixgbe_adv_tx_context_desc
operator|*
operator|)
operator|&
name|txr
operator|->
name|tx_base
index|[
name|ctxd
index|]
expr_stmt|;
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|mp
operator|->
name|m_data
operator|+
name|ehdrlen
operator|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_p
operator|!=
name|IPPROTO_TCP
condition|)
return|return
name|FALSE
return|;
comment|/* 0 */
name|ip
operator|->
name|ip_len
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|ip_sum
operator|=
literal|0
expr_stmt|;
name|ip_hlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip
operator|+
name|ip_hlen
operator|)
expr_stmt|;
name|th
operator|->
name|th_sum
operator|=
name|in_pseudo
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|,
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|,
name|htons
argument_list|(
name|IPPROTO_TCP
argument_list|)
argument_list|)
expr_stmt|;
name|tcp_hlen
operator|=
name|th
operator|->
name|th_off
operator|<<
literal|2
expr_stmt|;
name|hdrlen
operator|=
name|ehdrlen
operator|+
name|ip_hlen
operator|+
name|tcp_hlen
expr_stmt|;
comment|/* This is used in the transmit desc in encap */
operator|*
name|paylen
operator|=
name|mp
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|hdrlen
expr_stmt|;
comment|/* VLAN MACLEN IPLEN */
if|if
condition|(
name|mp
operator|->
name|m_flags
operator|&
name|M_VLANTAG
condition|)
block|{
name|vtag
operator|=
name|htole16
argument_list|(
name|mp
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
argument_list|)
expr_stmt|;
name|vlan_macip_lens
operator||=
operator|(
name|vtag
operator|<<
name|IXGBE_ADVTXD_VLAN_SHIFT
operator|)
expr_stmt|;
block|}
name|vlan_macip_lens
operator||=
name|ehdrlen
operator|<<
name|IXGBE_ADVTXD_MACLEN_SHIFT
expr_stmt|;
name|vlan_macip_lens
operator||=
name|ip_hlen
expr_stmt|;
name|TXD
operator|->
name|vlan_macip_lens
operator||=
name|htole32
argument_list|(
name|vlan_macip_lens
argument_list|)
expr_stmt|;
comment|/* ADV DTYPE TUCMD */
name|type_tucmd_mlhl
operator||=
name|IXGBE_ADVTXD_DCMD_DEXT
operator||
name|IXGBE_ADVTXD_DTYP_CTXT
expr_stmt|;
name|type_tucmd_mlhl
operator||=
name|IXGBE_ADVTXD_TUCMD_L4T_TCP
expr_stmt|;
name|type_tucmd_mlhl
operator||=
name|IXGBE_ADVTXD_TUCMD_IPV4
expr_stmt|;
name|TXD
operator|->
name|type_tucmd_mlhl
operator||=
name|htole32
argument_list|(
name|type_tucmd_mlhl
argument_list|)
expr_stmt|;
comment|/* MSS L4LEN IDX */
name|mss_l4len_idx
operator||=
operator|(
name|mp
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
operator|<<
name|IXGBE_ADVTXD_MSS_SHIFT
operator|)
expr_stmt|;
name|mss_l4len_idx
operator||=
operator|(
name|tcp_hlen
operator|<<
name|IXGBE_ADVTXD_L4LEN_SHIFT
operator|)
expr_stmt|;
name|TXD
operator|->
name|mss_l4len_idx
operator|=
name|htole32
argument_list|(
name|mss_l4len_idx
argument_list|)
expr_stmt|;
name|TXD
operator|->
name|seqnum_seed
operator|=
name|htole32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|tx_buffer
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
name|tx_buffer
operator|->
name|next_eop
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|++
name|ctxd
operator|==
name|adapter
operator|->
name|num_tx_desc
condition|)
name|ctxd
operator|=
literal|0
expr_stmt|;
name|txr
operator|->
name|tx_avail
operator|--
expr_stmt|;
name|txr
operator|->
name|next_avail_tx_desc
operator|=
name|ctxd
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  *  *  Examine each tx_buffer in the used queue. If the hardware is done  *  processing the packet then free associated resources. The  *  tx_buffer is put back on the free queue.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|boolean_t
name|ixgbe_txeof
parameter_list|(
name|struct
name|tx_ring
modifier|*
name|txr
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|txr
operator|->
name|adapter
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|int
name|first
decl_stmt|,
name|last
decl_stmt|,
name|done
decl_stmt|,
name|num_avail
decl_stmt|;
name|struct
name|ixgbe_tx_buf
modifier|*
name|tx_buffer
decl_stmt|;
name|struct
name|ixgbe_legacy_tx_desc
modifier|*
name|tx_desc
decl_stmt|,
modifier|*
name|eop_desc
decl_stmt|;
name|IXGBE_LOCK_ASSERT
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|tx_avail
operator|==
name|adapter
operator|->
name|num_tx_desc
condition|)
return|return
name|FALSE
return|;
name|num_avail
operator|=
name|txr
operator|->
name|tx_avail
expr_stmt|;
name|first
operator|=
name|txr
operator|->
name|next_tx_to_clean
expr_stmt|;
name|tx_buffer
operator|=
operator|&
name|txr
operator|->
name|tx_buffers
index|[
name|first
index|]
expr_stmt|;
comment|/* For cleanup we just use legacy struct */
name|tx_desc
operator|=
operator|(
expr|struct
name|ixgbe_legacy_tx_desc
operator|*
operator|)
operator|&
name|txr
operator|->
name|tx_base
index|[
name|first
index|]
expr_stmt|;
name|last
operator|=
name|tx_buffer
operator|->
name|next_eop
expr_stmt|;
if|if
condition|(
name|last
operator|==
operator|-
literal|1
condition|)
return|return
name|FALSE
return|;
name|eop_desc
operator|=
operator|(
expr|struct
name|ixgbe_legacy_tx_desc
operator|*
operator|)
operator|&
name|txr
operator|->
name|tx_base
index|[
name|last
index|]
expr_stmt|;
comment|/*          * What this does is get the index of the          * first descriptor AFTER the EOP of the          * first packet, that way we can do the          * simple comparison on the inner while loop 	 * below.          */
if|if
condition|(
operator|++
name|last
operator|==
name|adapter
operator|->
name|num_tx_desc
condition|)
name|last
operator|=
literal|0
expr_stmt|;
name|done
operator|=
name|last
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|txdma
operator|.
name|dma_tag
argument_list|,
name|txr
operator|->
name|txdma
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
while|while
condition|(
name|eop_desc
operator|->
name|upper
operator|.
name|fields
operator|.
name|status
operator|&
name|IXGBE_TXD_STAT_DD
condition|)
block|{
comment|/* We clean the range of the packet */
while|while
condition|(
name|first
operator|!=
name|done
condition|)
block|{
name|tx_desc
operator|->
name|upper
operator|.
name|data
operator|=
literal|0
expr_stmt|;
name|tx_desc
operator|->
name|lower
operator|.
name|data
operator|=
literal|0
expr_stmt|;
name|tx_desc
operator|->
name|buffer_addr
operator|=
literal|0
expr_stmt|;
name|num_avail
operator|++
expr_stmt|;
if|if
condition|(
name|tx_buffer
operator|->
name|m_head
condition|)
block|{
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|tx_buffer
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|tx_buffer
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|tx_buffer
operator|->
name|m_head
argument_list|)
expr_stmt|;
name|tx_buffer
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
name|tx_buffer
operator|->
name|map
operator|=
name|NULL
expr_stmt|;
block|}
name|tx_buffer
operator|->
name|next_eop
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|++
name|first
operator|==
name|adapter
operator|->
name|num_tx_desc
condition|)
name|first
operator|=
literal|0
expr_stmt|;
name|tx_buffer
operator|=
operator|&
name|txr
operator|->
name|tx_buffers
index|[
name|first
index|]
expr_stmt|;
name|tx_desc
operator|=
operator|(
expr|struct
name|ixgbe_legacy_tx_desc
operator|*
operator|)
operator|&
name|txr
operator|->
name|tx_base
index|[
name|first
index|]
expr_stmt|;
block|}
comment|/* See if we can continue to the next packet */
name|last
operator|=
name|tx_buffer
operator|->
name|next_eop
expr_stmt|;
if|if
condition|(
name|last
operator|!=
operator|-
literal|1
condition|)
block|{
name|eop_desc
operator|=
operator|(
expr|struct
name|ixgbe_legacy_tx_desc
operator|*
operator|)
operator|&
name|txr
operator|->
name|tx_base
index|[
name|last
index|]
expr_stmt|;
comment|/* Get new done point */
if|if
condition|(
operator|++
name|last
operator|==
name|adapter
operator|->
name|num_tx_desc
condition|)
name|last
operator|=
literal|0
expr_stmt|;
name|done
operator|=
name|last
expr_stmt|;
block|}
else|else
break|break;
block|}
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|txdma
operator|.
name|dma_tag
argument_list|,
name|txr
operator|->
name|txdma
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|txr
operator|->
name|next_tx_to_clean
operator|=
name|first
expr_stmt|;
comment|/* 	 * If we have enough room, clear IFF_DRV_OACTIVE to tell the stack that 	 * it is OK to send packets. If there are no pending descriptors, 	 * clear the timeout. Otherwise, if some descriptors have been freed, 	 * restart the timeout. 	 */
if|if
condition|(
name|num_avail
operator|>
name|IXGBE_TX_CLEANUP_THRESHOLD
condition|)
block|{
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
comment|/* If all are clean turn off the timer */
if|if
condition|(
name|num_avail
operator|==
name|adapter
operator|->
name|num_tx_desc
condition|)
name|adapter
operator|->
name|watchdog_timer
operator|=
literal|0
expr_stmt|;
comment|/* Some were cleaned, so reset timer */
elseif|else
if|if
condition|(
name|num_avail
operator|==
name|txr
operator|->
name|tx_avail
condition|)
name|adapter
operator|->
name|watchdog_timer
operator|=
name|IXGBE_TX_TIMEOUT
expr_stmt|;
block|}
name|txr
operator|->
name|tx_avail
operator|=
name|num_avail
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Get a buffer from system mbuf buffer pool.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_get_buf
parameter_list|(
name|struct
name|rx_ring
modifier|*
name|rxr
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|rxr
operator|->
name|adapter
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mp
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
name|int
name|nsegs
decl_stmt|,
name|error
decl_stmt|,
name|old
decl_stmt|,
name|s
init|=
literal|0
decl_stmt|;
name|int
name|size
init|=
name|MCLBYTES
decl_stmt|;
name|bus_dma_segment_t
name|segs
index|[
literal|1
index|]
decl_stmt|;
name|struct
name|ixgbe_rx_buf
modifier|*
name|rxbuf
decl_stmt|;
comment|/* Are we going to Jumbo clusters? */
if|if
condition|(
name|adapter
operator|->
name|bigbufs
condition|)
block|{
name|size
operator|=
name|MJUMPAGESIZE
expr_stmt|;
name|s
operator|=
literal|1
expr_stmt|;
block|}
empty_stmt|;
name|mp
operator|=
name|m_getjcl
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|==
name|NULL
condition|)
block|{
name|adapter
operator|->
name|mbuf_alloc_failed
operator|++
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|mp
operator|->
name|m_len
operator|=
name|mp
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|max_frame_size
operator|<=
operator|(
name|MCLBYTES
operator|-
name|ETHER_ALIGN
operator|)
condition|)
name|m_adj
argument_list|(
name|mp
argument_list|,
name|ETHER_ALIGN
argument_list|)
expr_stmt|;
comment|/* 	 * Using memory from the mbuf cluster pool, invoke the bus_dma 	 * machinery to arrange the memory mapping. 	 */
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|rxr
operator|->
name|rxtag
index|[
name|s
index|]
argument_list|,
name|rxr
operator|->
name|spare_map
index|[
name|s
index|]
argument_list|,
name|mp
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|m_free
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Now check our target buffer for existing mapping */
name|rxbuf
operator|=
operator|&
name|rxr
operator|->
name|rx_buffers
index|[
name|i
index|]
expr_stmt|;
name|old
operator|=
name|rxbuf
operator|->
name|bigbuf
expr_stmt|;
if|if
condition|(
name|rxbuf
operator|->
name|m_head
operator|!=
name|NULL
condition|)
name|bus_dmamap_unload
argument_list|(
name|rxr
operator|->
name|rxtag
index|[
name|old
index|]
argument_list|,
name|rxbuf
operator|->
name|map
index|[
name|old
index|]
argument_list|)
expr_stmt|;
name|map
operator|=
name|rxbuf
operator|->
name|map
index|[
name|old
index|]
expr_stmt|;
name|rxbuf
operator|->
name|map
index|[
name|s
index|]
operator|=
name|rxr
operator|->
name|spare_map
index|[
name|s
index|]
expr_stmt|;
name|rxr
operator|->
name|spare_map
index|[
name|old
index|]
operator|=
name|map
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|rxr
operator|->
name|rxtag
index|[
name|s
index|]
argument_list|,
name|rxbuf
operator|->
name|map
index|[
name|s
index|]
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|rxbuf
operator|->
name|m_head
operator|=
name|mp
expr_stmt|;
name|rxr
operator|->
name|rx_base
index|[
name|i
index|]
operator|.
name|read
operator|.
name|pkt_addr
operator|=
name|htole64
argument_list|(
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Allocate memory for rx_buffer structures. Since we use one  *  rx_buffer per received packet, the maximum number of rx_buffer's  *  that we'll need is equal to the number of receive descriptors  *  that we've allocated.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_allocate_receive_buffers
parameter_list|(
name|struct
name|rx_ring
modifier|*
name|rxr
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|rxr
operator|->
name|adapter
decl_stmt|;
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|struct
name|ixgbe_rx_buf
modifier|*
name|rxbuf
decl_stmt|;
name|int
name|i
decl_stmt|,
name|bsize
decl_stmt|,
name|error
decl_stmt|;
name|bsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ixgbe_rx_buf
argument_list|)
operator|*
name|adapter
operator|->
name|num_rx_desc
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|rxr
operator|->
name|rx_buffers
operator|=
operator|(
expr|struct
name|ixgbe_rx_buf
operator|*
operator|)
name|malloc
argument_list|(
name|bsize
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate rx_buffer memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* First make the small (2K) tag/map */
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
comment|/* parent */
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|,
comment|/* alignment, bounds */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|MCLBYTES
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|MCLBYTES
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lockfunc */
name|NULL
argument_list|,
comment|/* lockfuncarg */
operator|&
name|rxr
operator|->
name|rxtag
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to create RX Small DMA tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Next make the large (4K) tag/map */
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
comment|/* parent */
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|,
comment|/* alignment, bounds */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|MJUMPAGESIZE
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|MJUMPAGESIZE
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lockfunc */
name|NULL
argument_list|,
comment|/* lockfuncarg */
operator|&
name|rxr
operator|->
name|rxtag
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to create RX Large DMA tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Create the spare maps (used by getbuf) */
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|rxr
operator|->
name|rxtag
index|[
literal|0
index|]
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|rxr
operator|->
name|spare_map
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|rxr
operator|->
name|rxtag
index|[
literal|1
index|]
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|rxr
operator|->
name|spare_map
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: bus_dmamap_create failed: %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_rx_desc
condition|;
name|i
operator|++
operator|,
name|rxbuf
operator|++
control|)
block|{
name|rxbuf
operator|=
operator|&
name|rxr
operator|->
name|rx_buffers
index|[
name|i
index|]
expr_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|rxr
operator|->
name|rxtag
index|[
literal|0
index|]
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|rxbuf
operator|->
name|map
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to create Small RX DMA map\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|rxr
operator|->
name|rxtag
index|[
literal|1
index|]
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|rxbuf
operator|->
name|map
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to create Large RX DMA map\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
comment|/* Frees all, but can handle partial completion */
name|ixgbe_free_receive_structures
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Initialize a receive ring and its buffers.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_setup_receive_ring
parameter_list|(
name|struct
name|rx_ring
modifier|*
name|rxr
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
decl_stmt|;
name|struct
name|ixgbe_rx_buf
modifier|*
name|rxbuf
decl_stmt|;
name|int
name|j
decl_stmt|,
name|rsize
decl_stmt|,
name|s
decl_stmt|;
name|adapter
operator|=
name|rxr
operator|->
name|adapter
expr_stmt|;
name|rsize
operator|=
name|roundup2
argument_list|(
name|adapter
operator|->
name|num_rx_desc
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|ixgbe_adv_rx_desc
argument_list|)
argument_list|,
literal|4096
argument_list|)
expr_stmt|;
comment|/* Clear the ring contents */
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|rxr
operator|->
name|rx_base
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
comment|/* 	** Free current RX buffers: the size buffer 	** that is loaded is indicated by the buffer 	** bigbuf value. 	*/
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_rx_desc
condition|;
name|i
operator|++
control|)
block|{
name|rxbuf
operator|=
operator|&
name|rxr
operator|->
name|rx_buffers
index|[
name|i
index|]
expr_stmt|;
name|s
operator|=
name|rxbuf
operator|->
name|bigbuf
expr_stmt|;
if|if
condition|(
name|rxbuf
operator|->
name|m_head
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|rxr
operator|->
name|rxtag
index|[
name|s
index|]
argument_list|,
name|rxbuf
operator|->
name|map
index|[
name|s
index|]
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|rxr
operator|->
name|rxtag
index|[
name|s
index|]
argument_list|,
name|rxbuf
operator|->
name|map
index|[
name|s
index|]
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|rxbuf
operator|->
name|m_head
argument_list|)
expr_stmt|;
name|rxbuf
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
block|}
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|adapter
operator|->
name|num_rx_desc
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|ixgbe_get_buf
argument_list|(
name|rxr
argument_list|,
name|j
argument_list|)
operator|==
name|ENOBUFS
condition|)
block|{
name|rxr
operator|->
name|rx_buffers
index|[
name|j
index|]
operator|.
name|m_head
operator|=
name|NULL
expr_stmt|;
name|rxr
operator|->
name|rx_base
index|[
name|j
index|]
operator|.
name|read
operator|.
name|pkt_addr
operator|=
literal|0
expr_stmt|;
comment|/* If we fail some may have change size */
name|s
operator|=
name|adapter
operator|->
name|bigbufs
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
comment|/* Setup our descriptor indices */
name|rxr
operator|->
name|next_to_check
operator|=
literal|0
expr_stmt|;
name|rxr
operator|->
name|last_cleaned
operator|=
literal|0
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|rxr
operator|->
name|rxdma
operator|.
name|dma_tag
argument_list|,
name|rxr
operator|->
name|rxdma
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
comment|/* 	 * We need to clean up any buffers allocated so far 	 * 'j' is the failing index, decrement it to get the 	 * last success. 	 */
for|for
control|(
operator|--
name|j
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|rxbuf
operator|=
operator|&
name|rxr
operator|->
name|rx_buffers
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|rxbuf
operator|->
name|m_head
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|rxr
operator|->
name|rxtag
index|[
name|s
index|]
argument_list|,
name|rxbuf
operator|->
name|map
index|[
name|s
index|]
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|rxr
operator|->
name|rxtag
index|[
name|s
index|]
argument_list|,
name|rxbuf
operator|->
name|map
index|[
name|s
index|]
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|rxbuf
operator|->
name|m_head
argument_list|)
expr_stmt|;
name|rxbuf
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Initialize all receive rings.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_setup_receive_structures
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
name|adapter
operator|->
name|rx_rings
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|s
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_rx_queues
condition|;
name|i
operator|++
operator|,
name|rxr
operator|++
control|)
if|if
condition|(
name|ixgbe_setup_receive_ring
argument_list|(
name|rxr
argument_list|)
condition|)
goto|goto
name|fail
goto|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
comment|/* 	 * Free RX buffers allocated so far, we will only handle 	 * the rings that completed, the failing case will have 	 * cleaned up for itself. The value of 'i' will be the 	 * failed ring so we must pre-decrement it. 	 */
name|rxr
operator|=
name|adapter
operator|->
name|rx_rings
expr_stmt|;
for|for
control|(
operator|--
name|i
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
operator|,
name|rxr
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|adapter
operator|->
name|num_rx_desc
condition|;
name|j
operator|++
control|)
block|{
name|struct
name|ixgbe_rx_buf
modifier|*
name|rxbuf
decl_stmt|;
name|rxbuf
operator|=
operator|&
name|rxr
operator|->
name|rx_buffers
index|[
name|j
index|]
expr_stmt|;
name|s
operator|=
name|rxbuf
operator|->
name|bigbuf
expr_stmt|;
if|if
condition|(
name|rxbuf
operator|->
name|m_head
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|rxr
operator|->
name|rxtag
index|[
name|s
index|]
argument_list|,
name|rxbuf
operator|->
name|map
index|[
name|s
index|]
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|rxr
operator|->
name|rxtag
index|[
name|s
index|]
argument_list|,
name|rxbuf
operator|->
name|map
index|[
name|s
index|]
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|rxbuf
operator|->
name|m_head
argument_list|)
expr_stmt|;
name|rxbuf
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Enable receive unit.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_initialize_receive_units
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
name|adapter
operator|->
name|rx_rings
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|u32
name|rxctrl
decl_stmt|,
name|fctrl
decl_stmt|,
name|srrctl
decl_stmt|,
name|rxcsum
decl_stmt|;
name|u32
name|reta
decl_stmt|,
name|mrqc
decl_stmt|,
name|hlreg
decl_stmt|,
name|linkvec
decl_stmt|;
name|u32
name|random
index|[
literal|10
index|]
decl_stmt|;
comment|/* 	 * Make sure receives are disabled while 	 * setting up the descriptor ring 	 */
name|rxctrl
operator|=
name|IXGBE_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_RXCTRL
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_RXCTRL
argument_list|,
name|rxctrl
operator|&
operator|~
name|IXGBE_RXCTRL_RXEN
argument_list|)
expr_stmt|;
comment|/* Enable broadcasts */
name|fctrl
operator|=
name|IXGBE_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_FCTRL
argument_list|)
expr_stmt|;
name|fctrl
operator||=
name|IXGBE_FCTRL_BAM
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_FCTRL
argument_list|,
name|fctrl
argument_list|)
expr_stmt|;
name|hlreg
operator|=
name|IXGBE_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_HLREG0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_mtu
operator|>
name|ETHERMTU
condition|)
name|hlreg
operator||=
name|IXGBE_HLREG0_JUMBOEN
expr_stmt|;
else|else
name|hlreg
operator|&=
operator|~
name|IXGBE_HLREG0_JUMBOEN
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_HLREG0
argument_list|,
name|hlreg
argument_list|)
expr_stmt|;
name|srrctl
operator|=
name|IXGBE_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_SRRCTL
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|srrctl
operator|&=
operator|~
name|IXGBE_SRRCTL_BSIZEHDR_MASK
expr_stmt|;
name|srrctl
operator|&=
operator|~
name|IXGBE_SRRCTL_BSIZEPKT_MASK
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|bigbufs
condition|)
name|srrctl
operator||=
literal|4096
operator|>>
name|IXGBE_SRRCTL_BSIZEPKT_SHIFT
expr_stmt|;
else|else
name|srrctl
operator||=
literal|2048
operator|>>
name|IXGBE_SRRCTL_BSIZEPKT_SHIFT
expr_stmt|;
name|srrctl
operator||=
name|IXGBE_SRRCTL_DESCTYPE_ADV_ONEBUF
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_SRRCTL
argument_list|(
literal|0
argument_list|)
argument_list|,
name|srrctl
argument_list|)
expr_stmt|;
comment|/* Set Queue moderation rate */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|IXGBE_MSGS
condition|;
name|i
operator|++
control|)
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_EITR
argument_list|(
name|i
argument_list|)
argument_list|,
name|DEFAULT_ITR
argument_list|)
expr_stmt|;
comment|/* Set Link moderation lower */
name|linkvec
operator|=
name|adapter
operator|->
name|num_tx_queues
operator|+
name|adapter
operator|->
name|num_rx_queues
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_EITR
argument_list|(
name|linkvec
argument_list|)
argument_list|,
name|LINK_ITR
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_rx_queues
condition|;
name|i
operator|++
operator|,
name|rxr
operator|++
control|)
block|{
name|u64
name|rdba
init|=
name|rxr
operator|->
name|rxdma
operator|.
name|dma_paddr
decl_stmt|;
comment|/* Setup the Base and Length of the Rx Descriptor Ring */
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_RDBAL
argument_list|(
name|i
argument_list|)
argument_list|,
operator|(
name|rdba
operator|&
literal|0x00000000ffffffffULL
operator|)
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_RDBAH
argument_list|(
name|i
argument_list|)
argument_list|,
operator|(
name|rdba
operator|>>
literal|32
operator|)
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_RDLEN
argument_list|(
name|i
argument_list|)
argument_list|,
name|adapter
operator|->
name|num_rx_desc
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|ixgbe_adv_rx_desc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Setup the HW Rx Head and Tail Descriptor Pointers */
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_RDH
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_RDT
argument_list|(
name|i
argument_list|)
argument_list|,
name|adapter
operator|->
name|num_rx_desc
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|adapter
operator|->
name|num_rx_queues
operator|>
literal|1
condition|)
block|{
comment|/* set up random bits */
name|arc4rand
argument_list|(
operator|&
name|random
argument_list|,
sizeof|sizeof
argument_list|(
name|random
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|adapter
operator|->
name|num_rx_queues
condition|)
block|{
case|case
literal|8
case|:
case|case
literal|4
case|:
name|reta
operator|=
literal|0x00010203
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|reta
operator|=
literal|0x00010001
expr_stmt|;
break|break;
default|default:
name|reta
operator|=
literal|0x00000000
expr_stmt|;
block|}
comment|/* Set up the redirection table */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_RETA
argument_list|(
name|i
argument_list|)
argument_list|,
name|reta
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|num_rx_queues
operator|>
literal|4
condition|)
block|{
operator|++
name|i
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_RETA
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0x04050607
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now fill our hash function seeds */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
name|IXGBE_WRITE_REG_ARRAY
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_RSSRK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|i
argument_list|,
name|random
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|mrqc
operator|=
name|IXGBE_MRQC_RSSEN
comment|/* Perform hash on these packet types */
operator||
name|IXGBE_MRQC_RSS_FIELD_IPV4
operator||
name|IXGBE_MRQC_RSS_FIELD_IPV4_TCP
operator||
name|IXGBE_MRQC_RSS_FIELD_IPV4_UDP
operator||
name|IXGBE_MRQC_RSS_FIELD_IPV6_EX_TCP
operator||
name|IXGBE_MRQC_RSS_FIELD_IPV6_EX
operator||
name|IXGBE_MRQC_RSS_FIELD_IPV6
operator||
name|IXGBE_MRQC_RSS_FIELD_IPV6_TCP
operator||
name|IXGBE_MRQC_RSS_FIELD_IPV6_UDP
operator||
name|IXGBE_MRQC_RSS_FIELD_IPV6_EX_UDP
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_MRQC
argument_list|,
name|mrqc
argument_list|)
expr_stmt|;
comment|/* RSS and RX IPP Checksum are mutually exclusive */
name|rxcsum
operator|=
name|IXGBE_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_RXCSUM
argument_list|)
expr_stmt|;
name|rxcsum
operator||=
name|IXGBE_RXCSUM_PCSD
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_RXCSUM
argument_list|,
name|rxcsum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rxcsum
operator|=
name|IXGBE_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_RXCSUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_RXCSUM
condition|)
name|rxcsum
operator||=
name|IXGBE_RXCSUM_IPPCSE
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_RXCSUM
argument_list|,
name|rxcsum
argument_list|)
expr_stmt|;
block|}
comment|/* Enable Receive engine */
name|rxctrl
operator||=
operator|(
name|IXGBE_RXCTRL_RXEN
operator||
name|IXGBE_RXCTRL_DMBYPS
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_RXCTRL
argument_list|,
name|rxctrl
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Free all receive rings.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_free_receive_structures
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
name|adapter
operator|->
name|rx_rings
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_rx_queues
condition|;
name|i
operator|++
operator|,
name|rxr
operator|++
control|)
block|{
name|ixgbe_free_receive_buffers
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
comment|/* Free the ring memory as well */
name|ixgbe_dma_free
argument_list|(
name|adapter
argument_list|,
operator|&
name|rxr
operator|->
name|rxdma
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|adapter
operator|->
name|rx_rings
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Free receive ring data structures  *  **********************************************************************/
end_comment

begin_function
name|void
name|ixgbe_free_receive_buffers
parameter_list|(
name|struct
name|rx_ring
modifier|*
name|rxr
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|NULL
decl_stmt|;
name|struct
name|ixgbe_rx_buf
modifier|*
name|rxbuf
init|=
name|NULL
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"free_receive_buffers: begin"
argument_list|)
expr_stmt|;
name|adapter
operator|=
name|rxr
operator|->
name|adapter
expr_stmt|;
if|if
condition|(
name|rxr
operator|->
name|rx_buffers
operator|!=
name|NULL
condition|)
block|{
name|rxbuf
operator|=
operator|&
name|rxr
operator|->
name|rx_buffers
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_rx_desc
condition|;
name|i
operator|++
control|)
block|{
name|int
name|s
init|=
name|rxbuf
operator|->
name|bigbuf
decl_stmt|;
if|if
condition|(
name|rxbuf
operator|->
name|map
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|rxr
operator|->
name|rxtag
index|[
name|s
index|]
argument_list|,
name|rxbuf
operator|->
name|map
index|[
name|s
index|]
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|rxr
operator|->
name|rxtag
index|[
name|s
index|]
argument_list|,
name|rxbuf
operator|->
name|map
index|[
name|s
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rxbuf
operator|->
name|m_head
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|rxbuf
operator|->
name|m_head
argument_list|)
expr_stmt|;
block|}
name|rxbuf
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
operator|++
name|rxbuf
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rxr
operator|->
name|rx_buffers
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|rxr
operator|->
name|rx_buffers
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|rx_buffers
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|int
name|s
init|=
literal|0
init|;
name|s
operator|<
literal|2
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
name|rxr
operator|->
name|rxtag
index|[
name|s
index|]
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|rxr
operator|->
name|rxtag
index|[
name|s
index|]
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|rxtag
index|[
name|s
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  This routine executes in interrupt context. It replenishes  *  the mbufs in the descriptor and sends data which has been  *  dma'ed into host memory to upper layer.  *  *  We loop at most count times if count is> 0, or until done if  *  count< 0.  *  *********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_rxeof
parameter_list|(
name|struct
name|rx_ring
modifier|*
name|rxr
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|rxr
operator|->
name|adapter
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mp
decl_stmt|;
name|int
name|len
decl_stmt|,
name|i
decl_stmt|,
name|eop
init|=
literal|0
decl_stmt|;
name|uint8_t
name|accept_frame
init|=
literal|0
decl_stmt|;
name|uint32_t
name|staterr
decl_stmt|;
name|union
name|ixgbe_adv_rx_desc
modifier|*
name|cur
decl_stmt|;
name|i
operator|=
name|rxr
operator|->
name|next_to_check
expr_stmt|;
name|cur
operator|=
operator|&
name|rxr
operator|->
name|rx_base
index|[
name|i
index|]
expr_stmt|;
name|staterr
operator|=
name|cur
operator|->
name|wb
operator|.
name|upper
operator|.
name|status_error
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|staterr
operator|&
name|IXGBE_RXD_STAT_DD
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
while|while
condition|(
operator|(
name|staterr
operator|&
name|IXGBE_RXD_STAT_DD
operator|)
operator|&&
operator|(
name|count
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
name|int
name|s
decl_stmt|;
name|mp
operator|=
name|rxr
operator|->
name|rx_buffers
index|[
name|i
index|]
operator|.
name|m_head
expr_stmt|;
name|s
operator|=
name|rxr
operator|->
name|rx_buffers
index|[
name|i
index|]
operator|.
name|bigbuf
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|rxr
operator|->
name|rxtag
index|[
name|s
index|]
argument_list|,
name|rxr
operator|->
name|rx_buffers
index|[
name|i
index|]
operator|.
name|map
index|[
name|s
index|]
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|accept_frame
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|staterr
operator|&
name|IXGBE_RXD_STAT_EOP
condition|)
block|{
name|count
operator|--
expr_stmt|;
name|eop
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|eop
operator|=
literal|0
expr_stmt|;
block|}
name|len
operator|=
name|cur
operator|->
name|wb
operator|.
name|upper
operator|.
name|length
expr_stmt|;
if|if
condition|(
name|staterr
operator|&
name|IXGBE_RXDADV_ERR_FRAME_ERR_MASK
condition|)
name|accept_frame
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|accept_frame
condition|)
block|{
comment|/* Get a fresh buffer first */
if|if
condition|(
name|ixgbe_get_buf
argument_list|(
name|rxr
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_iqdrops
operator|++
expr_stmt|;
goto|goto
name|discard
goto|;
block|}
comment|/* Assign correct length to the current fragment */
name|mp
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|rxr
operator|->
name|fmp
operator|==
name|NULL
condition|)
block|{
name|mp
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|rxr
operator|->
name|fmp
operator|=
name|mp
expr_stmt|;
comment|/* Store the first mbuf */
name|rxr
operator|->
name|lmp
operator|=
name|mp
expr_stmt|;
block|}
else|else
block|{
comment|/* Chain mbuf's together */
name|mp
operator|->
name|m_flags
operator|&=
operator|~
name|M_PKTHDR
expr_stmt|;
name|rxr
operator|->
name|lmp
operator|->
name|m_next
operator|=
name|mp
expr_stmt|;
name|rxr
operator|->
name|lmp
operator|=
name|rxr
operator|->
name|lmp
operator|->
name|m_next
expr_stmt|;
name|rxr
operator|->
name|fmp
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|eop
condition|)
block|{
name|rxr
operator|->
name|fmp
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
name|rxr
operator|->
name|packet_count
operator|++
expr_stmt|;
name|rxr
operator|->
name|byte_count
operator|+=
name|rxr
operator|->
name|fmp
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|ixgbe_rx_checksum
argument_list|(
name|adapter
argument_list|,
name|staterr
argument_list|,
name|rxr
operator|->
name|fmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|staterr
operator|&
name|IXGBE_RXD_STAT_VP
condition|)
block|{
name|rxr
operator|->
name|fmp
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
operator|=
name|le16toh
argument_list|(
name|cur
operator|->
name|wb
operator|.
name|upper
operator|.
name|vlan
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|fmp
operator|->
name|m_flags
operator||=
name|M_VLANTAG
expr_stmt|;
block|}
name|m
operator|=
name|rxr
operator|->
name|fmp
expr_stmt|;
name|rxr
operator|->
name|fmp
operator|=
name|NULL
expr_stmt|;
name|rxr
operator|->
name|lmp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|discard
label|:
comment|/* Reuse loaded DMA map and just update mbuf chain */
name|mp
operator|=
name|rxr
operator|->
name|rx_buffers
index|[
name|i
index|]
operator|.
name|m_head
expr_stmt|;
name|mp
operator|->
name|m_len
operator|=
name|mp
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
operator|(
name|rxr
operator|->
name|rx_buffers
index|[
name|i
index|]
operator|.
name|bigbuf
condition|?
name|MJUMPAGESIZE
else|:
name|MCLBYTES
operator|)
expr_stmt|;
name|mp
operator|->
name|m_data
operator|=
name|mp
operator|->
name|m_ext
operator|.
name|ext_buf
expr_stmt|;
name|mp
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|max_frame_size
operator|<=
operator|(
name|MCLBYTES
operator|-
name|ETHER_ALIGN
operator|)
condition|)
name|m_adj
argument_list|(
name|mp
argument_list|,
name|ETHER_ALIGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|rxr
operator|->
name|fmp
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|rxr
operator|->
name|fmp
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|fmp
operator|=
name|NULL
expr_stmt|;
name|rxr
operator|->
name|lmp
operator|=
name|NULL
expr_stmt|;
block|}
name|m
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Zero out the receive descriptors status  */
name|cur
operator|->
name|wb
operator|.
name|upper
operator|.
name|status_error
operator|=
literal|0
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|rxr
operator|->
name|rxdma
operator|.
name|dma_tag
argument_list|,
name|rxr
operator|->
name|rxdma
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|last_cleaned
operator|=
name|i
expr_stmt|;
comment|/* for updating tail */
if|if
condition|(
operator|++
name|i
operator|==
name|adapter
operator|->
name|num_rx_desc
condition|)
name|i
operator|=
literal|0
expr_stmt|;
comment|/* Now send up to the stack */
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|rxr
operator|->
name|next_to_check
operator|=
name|i
expr_stmt|;
name|IXGBE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|IXGBE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|i
operator|=
name|rxr
operator|->
name|next_to_check
expr_stmt|;
block|}
comment|/* Get next descriptor */
name|cur
operator|=
operator|&
name|rxr
operator|->
name|rx_base
index|[
name|i
index|]
expr_stmt|;
name|staterr
operator|=
name|cur
operator|->
name|wb
operator|.
name|upper
operator|.
name|status_error
expr_stmt|;
block|}
name|rxr
operator|->
name|next_to_check
operator|=
name|i
expr_stmt|;
comment|/* Advance the IXGB's Receive Queue "Tail Pointer" */
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_RDT
argument_list|(
name|rxr
operator|->
name|me
argument_list|)
argument_list|,
name|rxr
operator|->
name|last_cleaned
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|staterr
operator|&
name|IXGBE_RXD_STAT_DD
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Verify that the hardware indicated that the checksum is valid.  *  Inform the stack about the status of checksum so that stack  *  doesn't spend time verifying the checksum.  *  *********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_rx_checksum
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|uint32_t
name|staterr
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mp
parameter_list|)
block|{
name|uint16_t
name|status
init|=
operator|(
name|uint16_t
operator|)
name|staterr
decl_stmt|;
name|uint8_t
name|errors
init|=
call|(
name|uint8_t
call|)
argument_list|(
name|staterr
operator|>>
literal|24
argument_list|)
decl_stmt|;
comment|/* Not offloaded */
if|if
condition|(
name|status
operator|&
name|IXGBE_RXD_STAT_IXSM
condition|)
block|{
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|status
operator|&
name|IXGBE_RXD_STAT_IPCS
condition|)
block|{
comment|/* Did it pass? */
if|if
condition|(
operator|!
operator|(
name|errors
operator|&
name|IXGBE_RXD_ERR_IPE
operator|)
condition|)
block|{
comment|/* IP Checksum Good */
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
name|CSUM_IP_CHECKED
expr_stmt|;
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_IP_VALID
expr_stmt|;
block|}
else|else
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|IXGBE_RXD_STAT_L4CS
condition|)
block|{
comment|/* Did it pass? */
if|if
condition|(
operator|!
operator|(
name|errors
operator|&
name|IXGBE_RXD_ERR_TCPE
operator|)
condition|)
block|{
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
operator|(
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
expr_stmt|;
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
name|htons
argument_list|(
literal|0xffff
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ixgbe_enable_vlans
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|uint32_t
name|ctrl
decl_stmt|;
name|ixgbe_disable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|IXGBE_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_VLNCTRL
argument_list|)
expr_stmt|;
name|ctrl
operator||=
name|IXGBE_VLNCTRL_VME
operator||
name|IXGBE_VLNCTRL_VFE
expr_stmt|;
name|ctrl
operator|&=
operator|~
name|IXGBE_VLNCTRL_CFIEN
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_VLNCTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
name|ixgbe_enable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ixgbe_enable_intr
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|u32
name|mask
decl_stmt|;
comment|/* Set up what to auto clear */
if|if
condition|(
name|adapter
operator|->
name|msix
condition|)
block|{
name|mask
operator|=
name|IXGBE_EIMS_ENABLE_MASK
expr_stmt|;
name|mask
operator|&=
operator|~
name|IXGBE_EIMS_OTHER
expr_stmt|;
name|mask
operator|&=
operator|~
name|IXGBE_EIMS_LSC
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_EIAC
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
name|mask
operator|=
name|IXGBE_EIMS_ENABLE_MASK
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_EIMS
argument_list|,
name|IXGBE_EIMS_ENABLE_MASK
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ixgbe_disable_intr
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_EIMC
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|u16
name|ixgbe_read_pci_cfg
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|reg
parameter_list|)
block|{
name|u16
name|value
decl_stmt|;
name|value
operator|=
name|pci_read_config
argument_list|(
operator|(
operator|(
expr|struct
name|ixgbe_osdep
operator|*
operator|)
name|hw
operator|->
name|back
operator|)
operator|->
name|dev
argument_list|,
name|reg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixgbe_set_ivar
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|u16
name|entry
parameter_list|,
name|u8
name|vector
parameter_list|)
block|{
name|u32
name|ivar
decl_stmt|,
name|index
decl_stmt|;
name|vector
operator||=
name|IXGBE_IVAR_ALLOC_VAL
expr_stmt|;
name|index
operator|=
operator|(
name|entry
operator|>>
literal|2
operator|)
operator|&
literal|0x1F
expr_stmt|;
name|ivar
operator|=
name|IXGBE_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_IVAR
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|ivar
operator||=
operator|(
name|vector
operator|<<
operator|(
literal|8
operator|*
operator|(
name|entry
operator|&
literal|0x3
operator|)
operator|)
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_IVAR
argument_list|(
name|index
argument_list|)
argument_list|,
name|ivar
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixgbe_configure_ivars
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|vec
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|vec
operator|=
literal|1
init|;
name|i
operator|<
name|adapter
operator|->
name|num_rx_queues
condition|;
name|i
operator|++
operator|,
name|vec
operator|++
control|)
name|ixgbe_set_ivar
argument_list|(
name|adapter
argument_list|,
name|IXGBE_IVAR_RX_QUEUE
argument_list|(
name|i
argument_list|)
argument_list|,
name|vec
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|vec
operator|=
literal|8
init|;
name|i
operator|<
name|adapter
operator|->
name|num_tx_queues
condition|;
name|i
operator|++
operator|,
name|vec
operator|++
control|)
name|ixgbe_set_ivar
argument_list|(
name|adapter
argument_list|,
name|IXGBE_IVAR_TX_QUEUE
argument_list|(
name|i
argument_list|)
argument_list|,
name|vec
argument_list|)
expr_stmt|;
comment|/* For the Link interrupt */
name|ixgbe_set_ivar
argument_list|(
name|adapter
argument_list|,
name|IXGBE_IVAR_OTHER_CAUSES_INDEX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  *  *  Update the board statistics counters.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_update_stats_counters
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|u64
name|good_rx
decl_stmt|,
name|missed_rx
decl_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|crcerrs
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CRCERRS
argument_list|)
expr_stmt|;
name|good_rx
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GPRC
argument_list|)
expr_stmt|;
name|missed_rx
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MPC
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|missed_rx
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MPC
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|missed_rx
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MPC
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|missed_rx
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MPC
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|missed_rx
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MPC
argument_list|(
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|missed_rx
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MPC
argument_list|(
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|missed_rx
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MPC
argument_list|(
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|missed_rx
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MPC
argument_list|(
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|gprc
operator|+=
operator|(
name|good_rx
operator|-
name|missed_rx
operator|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|mpc
index|[
literal|0
index|]
operator|+=
name|missed_rx
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|gorc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GORCH
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|bprc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_BPRC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|mprc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MPRC
argument_list|)
expr_stmt|;
comment|/* 	 * Workaround: mprc hardware is incorrectly counting 	 * broadcasts, so for now we subtract those. 	 */
name|adapter
operator|->
name|stats
operator|.
name|mprc
operator|-=
name|adapter
operator|->
name|stats
operator|.
name|bprc
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|roc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ROC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|prc64
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PRC64
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|prc127
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PRC127
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|prc255
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PRC255
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|prc511
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PRC511
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|prc1023
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PRC1023
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|prc1522
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PRC1522
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|rlec
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RLEC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|lxonrxc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LXONRXC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|lxontxc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LXONTXC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|lxoffrxc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LXOFFRXC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|lxofftxc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LXOFFTXC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|ruc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RUC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|gptc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GPTC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|gotc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GOTCH
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|rnbc
index|[
literal|0
index|]
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RNBC
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|ruc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RUC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|rfc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RFC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|rjc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RJC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|tor
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_TORH
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|gotc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GOTCH
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|tpr
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_TPR
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|ptc64
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PTC64
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|ptc127
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PTC127
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|ptc255
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PTC255
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|ptc511
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PTC511
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|ptc1023
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PTC1023
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|ptc1522
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PTC1522
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|mptc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MPTC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|bptc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_BPTC
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|adapter
operator|->
name|ifp
expr_stmt|;
comment|/* Fill out the OS statistics structure */
name|ifp
operator|->
name|if_ipackets
operator|=
name|adapter
operator|->
name|stats
operator|.
name|gprc
expr_stmt|;
name|ifp
operator|->
name|if_opackets
operator|=
name|adapter
operator|->
name|stats
operator|.
name|gptc
expr_stmt|;
name|ifp
operator|->
name|if_ibytes
operator|=
name|adapter
operator|->
name|stats
operator|.
name|gorc
expr_stmt|;
name|ifp
operator|->
name|if_obytes
operator|=
name|adapter
operator|->
name|stats
operator|.
name|gotc
expr_stmt|;
name|ifp
operator|->
name|if_imcasts
operator|=
name|adapter
operator|->
name|stats
operator|.
name|mprc
expr_stmt|;
name|ifp
operator|->
name|if_collisions
operator|=
literal|0
expr_stmt|;
comment|/* Rx Errors */
name|ifp
operator|->
name|if_ierrors
operator|=
name|adapter
operator|->
name|dropped_pkts
operator|+
name|adapter
operator|->
name|stats
operator|.
name|crcerrs
operator|+
name|adapter
operator|->
name|stats
operator|.
name|rlec
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  *  *  This routine is called only when ixgbe_display_debug_stats is enabled.  *  This routine provides a way to take a look at important statistics  *  maintained by the driver and hardware.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_print_hw_stats
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Tx Descriptors not Avail1 = %ld\n"
argument_list|,
name|adapter
operator|->
name|no_tx_desc_avail1
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Tx Descriptors not Avail2 = %ld\n"
argument_list|,
name|adapter
operator|->
name|no_tx_desc_avail2
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Std Mbuf Failed = %ld\n"
argument_list|,
name|adapter
operator|->
name|mbuf_alloc_failed
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Std Cluster Failed = %ld\n"
argument_list|,
name|adapter
operator|->
name|mbuf_cluster_failed
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Missed Packets = %lld\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|adapter
operator|->
name|stats
operator|.
name|mprc
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Receive length errors = %lld\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|adapter
operator|->
name|stats
operator|.
name|rlec
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Crc errors = %lld\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|adapter
operator|->
name|stats
operator|.
name|crcerrs
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Driver dropped packets = %ld\n"
argument_list|,
name|adapter
operator|->
name|dropped_pkts
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"XON Rcvd = %lld\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|adapter
operator|->
name|stats
operator|.
name|lxonrxc
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"XON Xmtd = %lld\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|adapter
operator|->
name|stats
operator|.
name|lxontxc
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"XOFF Rcvd = %lld\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|adapter
operator|->
name|stats
operator|.
name|lxoffrxc
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"XOFF Xmtd = %lld\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|adapter
operator|->
name|stats
operator|.
name|lxofftxc
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Total Packets Rcvd = %lld\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|adapter
operator|->
name|stats
operator|.
name|tpr
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Good Packets Rcvd = %lld\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|adapter
operator|->
name|stats
operator|.
name|gprc
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Good Packets Xmtd = %lld\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|adapter
operator|->
name|stats
operator|.
name|gptc
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"TSO Transmissions = %ld\n"
argument_list|,
name|adapter
operator|->
name|tso_tx
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**********************************************************************  *  *  This routine is called only when em_display_debug_stats is enabled.  *  This routine provides a way to take a look at important statistics  *  maintained by the driver and hardware.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_print_debug_info
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
name|adapter
operator|->
name|rx_rings
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|uint8_t
modifier|*
name|hw_addr
init|=
name|adapter
operator|->
name|hw
operator|.
name|hw_addr
decl_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Adapter hardware address = %p \n"
argument_list|,
name|hw_addr
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"CTRL = 0x%x RXCTRL = 0x%x \n"
argument_list|,
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_TXDCTL
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXCTRL
argument_list|)
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"RXDCTL(0) = 0x%x RXDCTL(1) = 0x%x"
literal|" RXCTRL(2) = 0x%x \n"
argument_list|,
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXDCTL
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXDCTL
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|,
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXDCTL
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"SRRCTL(0) = 0x%x SRRCTL(1) = 0x%x"
literal|" SRRCTL(2) = 0x%x \n"
argument_list|,
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SRRCTL
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SRRCTL
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|,
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SRRCTL
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"EIMC = 0x%x EIMS = 0x%x\n"
argument_list|,
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EIMC
argument_list|)
argument_list|,
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EIMS
argument_list|)
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Queue(0) tdh = %d, hw tdt = %d\n"
argument_list|,
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_TDH
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_TDT
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Total Packets Received = %d \n"
argument_list|,
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_TPR
argument_list|)
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Error Byte Count = %d \n"
argument_list|,
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ERRBC
argument_list|)
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Rx Length Errors = %d \n"
argument_list|,
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RLEC
argument_list|)
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Rx CRC Errors = %d \n"
argument_list|,
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CRCERRS
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_rx_queues
condition|;
name|i
operator|++
operator|,
name|rxr
operator|++
control|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Queue %d Packets Received: %lx\n"
argument_list|,
name|rxr
operator|->
name|me
argument_list|,
operator|(
name|long
operator|)
name|rxr
operator|->
name|packet_count
argument_list|)
expr_stmt|;
block|}
name|rxr
operator|=
name|adapter
operator|->
name|rx_rings
expr_stmt|;
comment|// Reset
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_rx_queues
condition|;
name|i
operator|++
operator|,
name|rxr
operator|++
control|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Queue %d Bytes Received: %lx\n"
argument_list|,
name|rxr
operator|->
name|me
argument_list|,
operator|(
name|long
operator|)
name|rxr
operator|->
name|byte_count
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_rx_queues
condition|;
name|i
operator|++
control|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Queue[%d]: rdh = %d, hw rdt = %d\n"
argument_list|,
name|i
argument_list|,
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RDH
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|,
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RDT
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Std mbuf failed = %ld\n"
argument_list|,
name|adapter
operator|->
name|mbuf_alloc_failed
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Std mbuf cluster failed = %ld\n"
argument_list|,
name|adapter
operator|->
name|mbuf_cluster_failed
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Driver dropped packets = %ld\n"
argument_list|,
name|adapter
operator|->
name|dropped_pkts
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|ixgbe_sysctl_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|result
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
decl_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|result
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|result
operator|==
literal|1
condition|)
block|{
name|adapter
operator|=
operator|(
expr|struct
name|adapter
operator|*
operator|)
name|arg1
expr_stmt|;
name|ixgbe_print_hw_stats
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixgbe_sysctl_debug
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|result
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
decl_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|result
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|result
operator|==
literal|1
condition|)
block|{
name|adapter
operator|=
operator|(
expr|struct
name|adapter
operator|*
operator|)
name|arg1
expr_stmt|;
name|ixgbe_print_debug_info
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixgbe_add_rx_process_limit
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|description
parameter_list|,
name|int
modifier|*
name|limit
parameter_list|,
name|int
name|value
parameter_list|)
block|{
operator|*
name|limit
operator|=
name|value
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|adapter
operator|->
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|adapter
operator|->
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|name
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|limit
argument_list|,
name|value
argument_list|,
name|description
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

