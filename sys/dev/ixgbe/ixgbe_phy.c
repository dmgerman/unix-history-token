begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************    Copyright (c) 2001-2008, Intel Corporation    All rights reserved.      Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are met:       1. Redistributions of source code must retain the above copyright notice,        this list of conditions and the following disclaimer.       2. Redistributions in binary form must reproduce the above copyright        notice, this list of conditions and the following disclaimer in the        documentation and/or other materials provided with the distribution.       3. Neither the name of the Intel Corporation nor the names of its        contributors may be used to endorse or promote products derived from        this software without specific prior written permission.      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  ******************************************************************************/
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_include
include|#
directive|include
file|"ixgbe_api.h"
end_include

begin_include
include|#
directive|include
file|"ixgbe_common.h"
end_include

begin_include
include|#
directive|include
file|"ixgbe_phy.h"
end_include

begin_comment
comment|/**  *  ixgbe_init_phy_ops_generic - Inits PHY function ptrs  *  @hw: pointer to the hardware structure  *  *  Initialize the function pointers.  **/
end_comment

begin_function
name|s32
name|ixgbe_init_phy_ops_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|ixgbe_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
comment|/* PHY */
name|phy
operator|->
name|ops
operator|.
name|identify
operator|=
operator|&
name|ixgbe_identify_phy_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|reset
operator|=
operator|&
name|ixgbe_reset_phy_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|read_reg
operator|=
operator|&
name|ixgbe_read_phy_reg_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|write_reg
operator|=
operator|&
name|ixgbe_write_phy_reg_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|setup_link
operator|=
operator|&
name|ixgbe_setup_phy_link_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|setup_link_speed
operator|=
operator|&
name|ixgbe_setup_phy_link_speed_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|check_link
operator|=
name|NULL
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|get_firmware_version
operator|=
name|NULL
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|identify_sfp
operator|=
operator|&
name|ixgbe_identify_sfp_module_generic
expr_stmt|;
name|phy
operator|->
name|sfp_type
operator|=
name|ixgbe_sfp_type_unknown
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_identify_phy_generic - Get physical layer module  *  @hw: pointer to hardware structure  *  *  Determines the physical layer module found on the current adapter.  **/
end_comment

begin_function
name|s32
name|ixgbe_identify_phy_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_ERR_PHY_ADDR_INVALID
decl_stmt|;
name|u32
name|phy_addr
decl_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|ixgbe_phy_unknown
condition|)
block|{
for|for
control|(
name|phy_addr
operator|=
literal|0
init|;
name|phy_addr
operator|<
name|IXGBE_MAX_PHY_ADDR
condition|;
name|phy_addr
operator|++
control|)
block|{
if|if
condition|(
name|ixgbe_validate_phy_addr
argument_list|(
name|hw
argument_list|,
name|phy_addr
argument_list|)
condition|)
block|{
name|hw
operator|->
name|phy
operator|.
name|addr
operator|=
name|phy_addr
expr_stmt|;
name|ixgbe_get_phy_id
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|ixgbe_get_phy_type_from_id
argument_list|(
name|hw
operator|->
name|phy
operator|.
name|id
argument_list|)
expr_stmt|;
name|status
operator|=
name|IXGBE_SUCCESS
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
name|status
operator|=
name|IXGBE_SUCCESS
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_validate_phy_addr - Determines phy address is valid  *  @hw: pointer to hardware structure  *  **/
end_comment

begin_function
name|bool
name|ixgbe_validate_phy_addr
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|phy_addr
parameter_list|)
block|{
name|u16
name|phy_id
init|=
literal|0
decl_stmt|;
name|bool
name|valid
init|=
name|FALSE
decl_stmt|;
name|hw
operator|->
name|phy
operator|.
name|addr
operator|=
name|phy_addr
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_PHY_ID_HIGH
argument_list|,
name|IXGBE_MDIO_PMA_PMD_DEV_TYPE
argument_list|,
operator|&
name|phy_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_id
operator|!=
literal|0xFFFF
operator|&&
name|phy_id
operator|!=
literal|0x0
condition|)
name|valid
operator|=
name|TRUE
expr_stmt|;
return|return
name|valid
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_phy_id - Get the phy type  *  @hw: pointer to hardware structure  *  **/
end_comment

begin_function
name|s32
name|ixgbe_get_phy_id
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|status
decl_stmt|;
name|u16
name|phy_id_high
init|=
literal|0
decl_stmt|;
name|u16
name|phy_id_low
init|=
literal|0
decl_stmt|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_PHY_ID_HIGH
argument_list|,
name|IXGBE_MDIO_PMA_PMD_DEV_TYPE
argument_list|,
operator|&
name|phy_id_high
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
condition|)
block|{
name|hw
operator|->
name|phy
operator|.
name|id
operator|=
call|(
name|u32
call|)
argument_list|(
name|phy_id_high
operator|<<
literal|16
argument_list|)
expr_stmt|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_PHY_ID_LOW
argument_list|,
name|IXGBE_MDIO_PMA_PMD_DEV_TYPE
argument_list|,
operator|&
name|phy_id_low
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|id
operator||=
call|(
name|u32
call|)
argument_list|(
name|phy_id_low
operator|&
name|IXGBE_PHY_REVISION_MASK
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|revision
operator|=
call|(
name|u32
call|)
argument_list|(
name|phy_id_low
operator|&
operator|~
name|IXGBE_PHY_REVISION_MASK
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_phy_type_from_id - Get the phy type  *  @hw: pointer to hardware structure  *  **/
end_comment

begin_function
name|enum
name|ixgbe_phy_type
name|ixgbe_get_phy_type_from_id
parameter_list|(
name|u32
name|phy_id
parameter_list|)
block|{
name|enum
name|ixgbe_phy_type
name|phy_type
decl_stmt|;
switch|switch
condition|(
name|phy_id
condition|)
block|{
case|case
name|TN1010_PHY_ID
case|:
name|phy_type
operator|=
name|ixgbe_phy_tn
expr_stmt|;
break|break;
case|case
name|QT2022_PHY_ID
case|:
name|phy_type
operator|=
name|ixgbe_phy_qt
expr_stmt|;
break|break;
case|case
name|ATH_PHY_ID
case|:
name|phy_type
operator|=
name|ixgbe_phy_nl
expr_stmt|;
break|break;
default|default:
name|phy_type
operator|=
name|ixgbe_phy_unknown
expr_stmt|;
break|break;
block|}
name|DEBUGOUT1
argument_list|(
literal|"phy type found is %d\n"
argument_list|,
name|phy_type
argument_list|)
expr_stmt|;
return|return
name|phy_type
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_reset_phy_generic - Performs a PHY reset  *  @hw: pointer to hardware structure  **/
end_comment

begin_function
name|s32
name|ixgbe_reset_phy_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
comment|/* 	 * Perform soft PHY reset to the PHY_XS. 	 * This will cause a soft reset to the PHY 	 */
return|return
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_PHY_XS_CONTROL
argument_list|,
name|IXGBE_MDIO_PHY_XS_DEV_TYPE
argument_list|,
name|IXGBE_MDIO_PHY_XS_RESET
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_read_phy_reg_generic - Reads a value from a specified PHY register  *  @hw: pointer to hardware structure  *  @reg_addr: 32 bit address of PHY register to read  *  @phy_data: Pointer to read data from PHY register  **/
end_comment

begin_function
name|s32
name|ixgbe_read_phy_reg_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|reg_addr
parameter_list|,
name|u32
name|device_type
parameter_list|,
name|u16
modifier|*
name|phy_data
parameter_list|)
block|{
name|u32
name|command
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|u32
name|data
decl_stmt|;
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u16
name|gssr
decl_stmt|;
if|if
condition|(
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_STATUS
argument_list|)
operator|&
name|IXGBE_STATUS_LAN_ID_1
condition|)
name|gssr
operator|=
name|IXGBE_GSSR_PHY1_SM
expr_stmt|;
else|else
name|gssr
operator|=
name|IXGBE_GSSR_PHY0_SM
expr_stmt|;
if|if
condition|(
name|ixgbe_acquire_swfw_sync
argument_list|(
name|hw
argument_list|,
name|gssr
argument_list|)
operator|!=
name|IXGBE_SUCCESS
condition|)
name|status
operator|=
name|IXGBE_ERR_SWFW_SYNC
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
condition|)
block|{
comment|/* Setup and write the address cycle command */
name|command
operator|=
operator|(
operator|(
name|reg_addr
operator|<<
name|IXGBE_MSCA_NP_ADDR_SHIFT
operator|)
operator||
operator|(
name|device_type
operator|<<
name|IXGBE_MSCA_DEV_TYPE_SHIFT
operator|)
operator||
operator|(
name|hw
operator|->
name|phy
operator|.
name|addr
operator|<<
name|IXGBE_MSCA_PHY_ADDR_SHIFT
operator|)
operator||
operator|(
name|IXGBE_MSCA_ADDR_CYCLE
operator||
name|IXGBE_MSCA_MDI_COMMAND
operator|)
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MSCA
argument_list|,
name|command
argument_list|)
expr_stmt|;
comment|/* 		 * Check every 10 usec to see if the address cycle completed. 		 * The MDI Command bit will clear when the operation is 		 * complete 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_MDIO_COMMAND_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|command
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MSCA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|command
operator|&
name|IXGBE_MSCA_MDI_COMMAND
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|command
operator|&
name|IXGBE_MSCA_MDI_COMMAND
operator|)
operator|!=
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PHY address command did not complete.\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IXGBE_ERR_PHY
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
condition|)
block|{
comment|/* 			 * Address cycle complete, setup and write the read 			 * command 			 */
name|command
operator|=
operator|(
operator|(
name|reg_addr
operator|<<
name|IXGBE_MSCA_NP_ADDR_SHIFT
operator|)
operator||
operator|(
name|device_type
operator|<<
name|IXGBE_MSCA_DEV_TYPE_SHIFT
operator|)
operator||
operator|(
name|hw
operator|->
name|phy
operator|.
name|addr
operator|<<
name|IXGBE_MSCA_PHY_ADDR_SHIFT
operator|)
operator||
operator|(
name|IXGBE_MSCA_READ
operator||
name|IXGBE_MSCA_MDI_COMMAND
operator|)
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MSCA
argument_list|,
name|command
argument_list|)
expr_stmt|;
comment|/* 			 * Check every 10 usec to see if the address cycle 			 * completed. The MDI Command bit will clear when the 			 * operation is complete 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_MDIO_COMMAND_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|command
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MSCA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|command
operator|&
name|IXGBE_MSCA_MDI_COMMAND
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|command
operator|&
name|IXGBE_MSCA_MDI_COMMAND
operator|)
operator|!=
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PHY read command didn't complete\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IXGBE_ERR_PHY
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Read operation is complete.  Get the data 				 * from MSRWD 				 */
name|data
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MSRWD
argument_list|)
expr_stmt|;
name|data
operator|>>=
name|IXGBE_MSRWD_READ_DATA_SHIFT
expr_stmt|;
operator|*
name|phy_data
operator|=
call|(
name|u16
call|)
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
block|}
name|ixgbe_release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|gssr
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_write_phy_reg_generic - Writes a value to specified PHY register  *  @hw: pointer to hardware structure  *  @reg_addr: 32 bit PHY register to write  *  @device_type: 5 bit device type  *  @phy_data: Data to write to the PHY register  **/
end_comment

begin_function
name|s32
name|ixgbe_write_phy_reg_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|reg_addr
parameter_list|,
name|u32
name|device_type
parameter_list|,
name|u16
name|phy_data
parameter_list|)
block|{
name|u32
name|command
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u16
name|gssr
decl_stmt|;
if|if
condition|(
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_STATUS
argument_list|)
operator|&
name|IXGBE_STATUS_LAN_ID_1
condition|)
name|gssr
operator|=
name|IXGBE_GSSR_PHY1_SM
expr_stmt|;
else|else
name|gssr
operator|=
name|IXGBE_GSSR_PHY0_SM
expr_stmt|;
if|if
condition|(
name|ixgbe_acquire_swfw_sync
argument_list|(
name|hw
argument_list|,
name|gssr
argument_list|)
operator|!=
name|IXGBE_SUCCESS
condition|)
name|status
operator|=
name|IXGBE_ERR_SWFW_SYNC
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
condition|)
block|{
comment|/* Put the data in the MDI single read and write data register*/
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MSRWD
argument_list|,
operator|(
name|u32
operator|)
name|phy_data
argument_list|)
expr_stmt|;
comment|/* Setup and write the address cycle command */
name|command
operator|=
operator|(
operator|(
name|reg_addr
operator|<<
name|IXGBE_MSCA_NP_ADDR_SHIFT
operator|)
operator||
operator|(
name|device_type
operator|<<
name|IXGBE_MSCA_DEV_TYPE_SHIFT
operator|)
operator||
operator|(
name|hw
operator|->
name|phy
operator|.
name|addr
operator|<<
name|IXGBE_MSCA_PHY_ADDR_SHIFT
operator|)
operator||
operator|(
name|IXGBE_MSCA_ADDR_CYCLE
operator||
name|IXGBE_MSCA_MDI_COMMAND
operator|)
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MSCA
argument_list|,
name|command
argument_list|)
expr_stmt|;
comment|/* 		 * Check every 10 usec to see if the address cycle completed. 		 * The MDI Command bit will clear when the operation is 		 * complete 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_MDIO_COMMAND_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|command
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MSCA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|command
operator|&
name|IXGBE_MSCA_MDI_COMMAND
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|command
operator|&
name|IXGBE_MSCA_MDI_COMMAND
operator|)
operator|!=
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PHY address cmd didn't complete\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IXGBE_ERR_PHY
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
condition|)
block|{
comment|/* 			 * Address cycle complete, setup and write the write 			 * command 			 */
name|command
operator|=
operator|(
operator|(
name|reg_addr
operator|<<
name|IXGBE_MSCA_NP_ADDR_SHIFT
operator|)
operator||
operator|(
name|device_type
operator|<<
name|IXGBE_MSCA_DEV_TYPE_SHIFT
operator|)
operator||
operator|(
name|hw
operator|->
name|phy
operator|.
name|addr
operator|<<
name|IXGBE_MSCA_PHY_ADDR_SHIFT
operator|)
operator||
operator|(
name|IXGBE_MSCA_WRITE
operator||
name|IXGBE_MSCA_MDI_COMMAND
operator|)
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MSCA
argument_list|,
name|command
argument_list|)
expr_stmt|;
comment|/* 			 * Check every 10 usec to see if the address cycle 			 * completed. The MDI Command bit will clear when the 			 * operation is complete 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_MDIO_COMMAND_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|command
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MSCA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|command
operator|&
name|IXGBE_MSCA_MDI_COMMAND
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|command
operator|&
name|IXGBE_MSCA_MDI_COMMAND
operator|)
operator|!=
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PHY address cmd didn't complete\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IXGBE_ERR_PHY
expr_stmt|;
block|}
block|}
name|ixgbe_release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|gssr
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_setup_phy_link_generic - Set and restart autoneg  *  @hw: pointer to hardware structure  *  *  Restart autonegotiation and PHY and waits for completion.  **/
end_comment

begin_function
name|s32
name|ixgbe_setup_phy_link_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_NOT_IMPLEMENTED
decl_stmt|;
name|u32
name|time_out
decl_stmt|;
name|u32
name|max_time_out
init|=
literal|10
decl_stmt|;
name|u16
name|autoneg_reg
init|=
name|IXGBE_MII_AUTONEG_REG
decl_stmt|;
comment|/* 	 * Set advertisement settings in PHY based on autoneg_advertised 	 * settings. If autoneg_advertised = 0, then advertise default values 	 * tnx devices cannot be "forced" to a autoneg 10G and fail.  But can 	 * for a 1G. 	 */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MII_SPEED_SELECTION_REG
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
operator|&
name|autoneg_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator|==
name|IXGBE_LINK_SPEED_1GB_FULL
condition|)
name|autoneg_reg
operator|&=
literal|0xEFFF
expr_stmt|;
comment|/* 0 in bit 12 is 1G operation */
else|else
name|autoneg_reg
operator||=
literal|0x1000
expr_stmt|;
comment|/* 1 in bit 12 is 10G/1G operation */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MII_SPEED_SELECTION_REG
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
name|autoneg_reg
argument_list|)
expr_stmt|;
comment|/* Restart PHY autonegotiation and wait for completion */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_CONTROL
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
operator|&
name|autoneg_reg
argument_list|)
expr_stmt|;
name|autoneg_reg
operator||=
name|IXGBE_MII_RESTART
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_CONTROL
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
name|autoneg_reg
argument_list|)
expr_stmt|;
comment|/* Wait for autonegotiation to finish */
for|for
control|(
name|time_out
operator|=
literal|0
init|;
name|time_out
operator|<
name|max_time_out
condition|;
name|time_out
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* Restart PHY autonegotiation and wait for completion */
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_STATUS
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
operator|&
name|autoneg_reg
argument_list|)
expr_stmt|;
name|autoneg_reg
operator|&=
name|IXGBE_MII_AUTONEG_COMPLETE
expr_stmt|;
if|if
condition|(
name|autoneg_reg
operator|==
name|IXGBE_MII_AUTONEG_COMPLETE
condition|)
block|{
name|status
operator|=
name|IXGBE_SUCCESS
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|time_out
operator|==
name|max_time_out
condition|)
name|status
operator|=
name|IXGBE_ERR_LINK_SETUP
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_setup_phy_link_speed_generic - Sets the auto advertised capabilities  *  @hw: pointer to hardware structure  *  @speed: new link speed  *  @autoneg: TRUE if autonegotiation enabled  **/
end_comment

begin_function
name|s32
name|ixgbe_setup_phy_link_speed_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
name|speed
parameter_list|,
name|bool
name|autoneg
parameter_list|,
name|bool
name|autoneg_wait_to_complete
parameter_list|)
block|{
name|UNREFERENCED_PARAMETER
argument_list|(
name|autoneg
argument_list|)
expr_stmt|;
name|UNREFERENCED_PARAMETER
argument_list|(
name|autoneg_wait_to_complete
argument_list|)
expr_stmt|;
comment|/* 	 * Clear autoneg_advertised and set new values based on input link 	 * speed. 	 */
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_10GB_FULL
condition|)
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator||=
name|IXGBE_LINK_SPEED_10GB_FULL
expr_stmt|;
if|if
condition|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_1GB_FULL
condition|)
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator||=
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
comment|/* Setup link based on the new speed settings */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|setup_link
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_check_phy_link_tnx - Determine link and speed status  *  @hw: pointer to hardware structure  *  *  Reads the VS1 register to determine if link is up and the current speed for  *  the PHY.  **/
end_comment

begin_function
name|s32
name|ixgbe_check_phy_link_tnx
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
modifier|*
name|speed
parameter_list|,
name|bool
modifier|*
name|link_up
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u32
name|time_out
decl_stmt|;
name|u32
name|max_time_out
init|=
literal|10
decl_stmt|;
name|u16
name|phy_link
init|=
literal|0
decl_stmt|;
name|u16
name|phy_speed
init|=
literal|0
decl_stmt|;
name|u16
name|phy_data
init|=
literal|0
decl_stmt|;
comment|/* Initialize speed and link to default case */
operator|*
name|link_up
operator|=
name|FALSE
expr_stmt|;
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_10GB_FULL
expr_stmt|;
comment|/* 	 * Check current speed and link status of the PHY register. 	 * This is a vendor specific register and may have to 	 * be changed for other copper PHYs. 	 */
for|for
control|(
name|time_out
operator|=
literal|0
init|;
name|time_out
operator|<
name|max_time_out
condition|;
name|time_out
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_STATUS
argument_list|,
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
name|phy_link
operator|=
name|phy_data
operator|&
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_LINK_STATUS
expr_stmt|;
name|phy_speed
operator|=
name|phy_data
operator|&
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_SPEED_STATUS
expr_stmt|;
if|if
condition|(
name|phy_link
operator|==
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_LINK_STATUS
condition|)
block|{
operator|*
name|link_up
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|phy_speed
operator|==
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_SPEED_STATUS
condition|)
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
break|break;
block|}
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_phy_firmware_version_tnx - Gets the PHY Firmware Version  *  @hw: pointer to hardware structure  *  @firmware_version: pointer to the PHY Firmware Version  **/
end_comment

begin_function
name|s32
name|ixgbe_get_phy_firmware_version_tnx
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|firmware_version
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|TNX_FW_REV
argument_list|,
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE
argument_list|,
name|firmware_version
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_reset_phy_nl - Performs a PHY reset  *  @hw: pointer to hardware structure  **/
end_comment

begin_function
name|s32
name|ixgbe_reset_phy_nl
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u16
name|phy_offset
decl_stmt|,
name|control
decl_stmt|,
name|eword
decl_stmt|,
name|edata
decl_stmt|,
name|block_crc
decl_stmt|;
name|bool
name|end_data
init|=
name|FALSE
decl_stmt|;
name|u16
name|list_offset
decl_stmt|,
name|data_offset
decl_stmt|;
name|u16
name|phy_data
init|=
literal|0
decl_stmt|;
name|s32
name|ret_val
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_PHY_XS_CONTROL
argument_list|,
name|IXGBE_MDIO_PHY_XS_DEV_TYPE
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
comment|/* reset the PHY and poll for completion */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_PHY_XS_CONTROL
argument_list|,
name|IXGBE_MDIO_PHY_XS_DEV_TYPE
argument_list|,
operator|(
name|phy_data
operator||
name|IXGBE_MDIO_PHY_XS_RESET
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_PHY_XS_CONTROL
argument_list|,
name|IXGBE_MDIO_PHY_XS_DEV_TYPE
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|phy_data
operator|&
name|IXGBE_MDIO_PHY_XS_RESET
operator|)
operator|==
literal|0
condition|)
break|break;
name|msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|phy_data
operator|&
name|IXGBE_MDIO_PHY_XS_RESET
operator|)
operator|!=
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PHY reset did not complete.\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|IXGBE_ERR_PHY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Get init offsets */
name|ret_val
operator|=
name|ixgbe_get_sfp_init_sequence_offsets
argument_list|(
name|hw
argument_list|,
operator|&
name|list_offset
argument_list|,
operator|&
name|data_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|data_offset
argument_list|,
operator|&
name|block_crc
argument_list|)
expr_stmt|;
name|data_offset
operator|++
expr_stmt|;
while|while
condition|(
operator|!
name|end_data
condition|)
block|{
comment|/* 		 * Read control word from PHY init contents offset 		 */
name|ret_val
operator|=
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|data_offset
argument_list|,
operator|&
name|eword
argument_list|)
expr_stmt|;
name|control
operator|=
operator|(
name|eword
operator|&
name|IXGBE_CONTROL_MASK_NL
operator|)
operator|>>
name|IXGBE_CONTROL_SHIFT_NL
expr_stmt|;
name|edata
operator|=
name|eword
operator|&
name|IXGBE_DATA_MASK_NL
expr_stmt|;
switch|switch
condition|(
name|control
condition|)
block|{
case|case
name|IXGBE_DELAY_NL
case|:
name|data_offset
operator|++
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"DELAY: %d MS\n"
argument_list|,
name|edata
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
name|edata
argument_list|)
expr_stmt|;
break|break;
case|case
name|IXGBE_DATA_NL
case|:
name|DEBUGOUT
argument_list|(
literal|"DATA:  \n"
argument_list|)
expr_stmt|;
name|data_offset
operator|++
expr_stmt|;
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|data_offset
operator|++
argument_list|,
operator|&
name|phy_offset
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|edata
condition|;
name|i
operator|++
control|)
block|{
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|data_offset
argument_list|,
operator|&
name|eword
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|phy_offset
argument_list|,
name|IXGBE_TWINAX_DEV
argument_list|,
name|eword
argument_list|)
expr_stmt|;
name|DEBUGOUT2
argument_list|(
literal|"Wrote %4.4x to %4.4x\n"
argument_list|,
name|eword
argument_list|,
name|phy_offset
argument_list|)
expr_stmt|;
name|data_offset
operator|++
expr_stmt|;
name|phy_offset
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|IXGBE_CONTROL_NL
case|:
name|data_offset
operator|++
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"CONTROL: \n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|edata
operator|==
name|IXGBE_CONTROL_EOL_NL
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"EOL\n"
argument_list|)
expr_stmt|;
name|end_data
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|edata
operator|==
name|IXGBE_CONTROL_SOL_NL
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"SOL\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"Bad control value\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|IXGBE_ERR_PHY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
break|break;
default|default:
name|DEBUGOUT
argument_list|(
literal|"Bad control type\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|IXGBE_ERR_PHY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_identify_sfp_module_generic - Identifies SFP modules  *  @hw: pointer to hardware structure  *  *  Searches for and identifies the SFP module and assigns appropriate PHY type.  **/
end_comment

begin_function
name|s32
name|ixgbe_identify_sfp_module_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_ERR_PHY_ADDR_INVALID
decl_stmt|;
name|u32
name|vendor_oui
init|=
literal|0
decl_stmt|;
name|u8
name|identifier
init|=
literal|0
decl_stmt|;
name|u8
name|comp_codes_1g
init|=
literal|0
decl_stmt|;
name|u8
name|comp_codes_10g
init|=
literal|0
decl_stmt|;
name|u8
name|oui_bytes
index|[
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|u8
name|transmission_media
init|=
literal|0
decl_stmt|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_i2c_eeprom
argument_list|(
name|hw
argument_list|,
name|IXGBE_SFF_IDENTIFIER
argument_list|,
operator|&
name|identifier
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|IXGBE_ERR_SFP_NOT_PRESENT
condition|)
block|{
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|=
name|ixgbe_sfp_type_not_present
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|identifier
operator|==
name|IXGBE_SFF_IDENTIFIER_SFP
condition|)
block|{
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_i2c_eeprom
argument_list|(
name|hw
argument_list|,
name|IXGBE_SFF_1GBE_COMP_CODES
argument_list|,
operator|&
name|comp_codes_1g
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_i2c_eeprom
argument_list|(
name|hw
argument_list|,
name|IXGBE_SFF_10GBE_COMP_CODES
argument_list|,
operator|&
name|comp_codes_10g
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_i2c_eeprom
argument_list|(
name|hw
argument_list|,
name|IXGBE_SFF_TRANSMISSION_MEDIA
argument_list|,
operator|&
name|transmission_media
argument_list|)
expr_stmt|;
comment|/* ID Module 		  * ========= 		  * 0   SFP_DA_CU 		  * 1   SFP_SR 		  * 2   SFP_LR 		  */
if|if
condition|(
name|transmission_media
operator|&
name|IXGBE_SFF_TWIN_AX_CAPABLE
condition|)
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|=
name|ixgbe_sfp_type_da_cu
expr_stmt|;
elseif|else
if|if
condition|(
name|comp_codes_10g
operator|&
name|IXGBE_SFF_10GBASESR_CAPABLE
condition|)
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|=
name|ixgbe_sfp_type_sr
expr_stmt|;
elseif|else
if|if
condition|(
name|comp_codes_10g
operator|&
name|IXGBE_SFF_10GBASELR_CAPABLE
condition|)
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|=
name|ixgbe_sfp_type_lr
expr_stmt|;
else|else
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|=
name|ixgbe_sfp_type_unknown
expr_stmt|;
comment|/* Determine if the SFP+ PHY is dual speed or not. */
if|if
condition|(
operator|(
name|comp_codes_1g
operator|&
name|IXGBE_SFF_1GBASESX_CAPABLE
operator|)
operator|&&
operator|(
name|comp_codes_10g
operator|&
name|IXGBE_SFF_10GBASESR_CAPABLE
operator|)
condition|)
name|hw
operator|->
name|phy
operator|.
name|multispeed_fiber
operator|=
name|TRUE
expr_stmt|;
comment|/* Determine PHY vendor */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|ixgbe_phy_unknown
condition|)
block|{
name|hw
operator|->
name|phy
operator|.
name|id
operator|=
name|identifier
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_i2c_eeprom
argument_list|(
name|hw
argument_list|,
name|IXGBE_SFF_VENDOR_OUI_BYTE0
argument_list|,
operator|&
name|oui_bytes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_i2c_eeprom
argument_list|(
name|hw
argument_list|,
name|IXGBE_SFF_VENDOR_OUI_BYTE1
argument_list|,
operator|&
name|oui_bytes
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_i2c_eeprom
argument_list|(
name|hw
argument_list|,
name|IXGBE_SFF_VENDOR_OUI_BYTE2
argument_list|,
operator|&
name|oui_bytes
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|vendor_oui
operator|=
operator|(
operator|(
name|oui_bytes
index|[
literal|0
index|]
operator|<<
name|IXGBE_SFF_VENDOR_OUI_BYTE0_SHIFT
operator|)
operator||
operator|(
name|oui_bytes
index|[
literal|1
index|]
operator|<<
name|IXGBE_SFF_VENDOR_OUI_BYTE1_SHIFT
operator|)
operator||
operator|(
name|oui_bytes
index|[
literal|2
index|]
operator|<<
name|IXGBE_SFF_VENDOR_OUI_BYTE2_SHIFT
operator|)
operator|)
expr_stmt|;
switch|switch
condition|(
name|vendor_oui
condition|)
block|{
case|case
name|IXGBE_SFF_VENDOR_OUI_TYCO
case|:
if|if
condition|(
name|transmission_media
operator|&
name|IXGBE_SFF_TWIN_AX_CAPABLE
condition|)
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|ixgbe_phy_tw_tyco
expr_stmt|;
break|break;
case|case
name|IXGBE_SFF_VENDOR_OUI_FTL
case|:
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|ixgbe_phy_sfp_ftl
expr_stmt|;
break|break;
case|case
name|IXGBE_SFF_VENDOR_OUI_AVAGO
case|:
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|ixgbe_phy_sfp_avago
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|transmission_media
operator|&
name|IXGBE_SFF_TWIN_AX_CAPABLE
condition|)
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|ixgbe_phy_tw_unknown
expr_stmt|;
else|else
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|ixgbe_phy_sfp_unknown
expr_stmt|;
break|break;
block|}
block|}
name|status
operator|=
name|IXGBE_SUCCESS
expr_stmt|;
block|}
name|out
label|:
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_sfp_init_sequence_offsets - Provides offset of PHY init sequence  *  @hw: pointer to hardware structure  *  @list_offset: offset to the SFP ID list  *  @data_offset: offset to the SFP data block  *  *  Checks the MAC's EEPROM to see if it supports a given SFP+ module type, if  *  so it returns the offsets to the phy init sequence block.  **/
end_comment

begin_function
name|s32
name|ixgbe_get_sfp_init_sequence_offsets
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|list_offset
parameter_list|,
name|u16
modifier|*
name|data_offset
parameter_list|)
block|{
name|u16
name|sfp_id
decl_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|==
name|ixgbe_sfp_type_unknown
condition|)
return|return
name|IXGBE_ERR_SFP_NOT_SUPPORTED
return|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|==
name|ixgbe_sfp_type_not_present
condition|)
return|return
name|IXGBE_ERR_SFP_NOT_PRESENT
return|;
if|if
condition|(
operator|(
name|hw
operator|->
name|device_id
operator|==
name|IXGBE_DEV_ID_82598_SR_DUAL_PORT_EM
operator|)
operator|&&
operator|(
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|==
name|ixgbe_sfp_type_da_cu
operator|)
condition|)
return|return
name|IXGBE_ERR_SFP_NOT_SUPPORTED
return|;
comment|/* Read offset to PHY init contents */
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|IXGBE_PHY_INIT_OFFSET_NL
argument_list|,
name|list_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
operator|*
name|list_offset
operator|)
operator|||
operator|(
operator|*
name|list_offset
operator|==
literal|0xFFFF
operator|)
condition|)
return|return
name|IXGBE_ERR_PHY
return|;
comment|/* Shift offset to first ID word */
operator|(
operator|*
name|list_offset
operator|)
operator|++
expr_stmt|;
comment|/* 	 * Find the matching SFP ID in the EEPROM 	 * and program the init sequence 	 */
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
operator|*
name|list_offset
argument_list|,
operator|&
name|sfp_id
argument_list|)
expr_stmt|;
while|while
condition|(
name|sfp_id
operator|!=
name|IXGBE_PHY_INIT_END_NL
condition|)
block|{
if|if
condition|(
name|sfp_id
operator|==
name|hw
operator|->
name|phy
operator|.
name|sfp_type
condition|)
block|{
operator|(
operator|*
name|list_offset
operator|)
operator|++
expr_stmt|;
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
operator|*
name|list_offset
argument_list|,
name|data_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
operator|*
name|data_offset
operator|)
operator|||
operator|(
operator|*
name|data_offset
operator|==
literal|0xFFFF
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"SFP+ module not supported\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_SFP_NOT_SUPPORTED
return|;
block|}
else|else
block|{
break|break;
block|}
block|}
else|else
block|{
operator|(
operator|*
name|list_offset
operator|)
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
operator|*
name|list_offset
argument_list|,
operator|&
name|sfp_id
argument_list|)
condition|)
return|return
name|IXGBE_ERR_PHY
return|;
block|}
block|}
if|if
condition|(
name|sfp_id
operator|==
name|IXGBE_PHY_INIT_END_NL
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"No matching SFP+ module found\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_SFP_NOT_SUPPORTED
return|;
block|}
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

end_unit

