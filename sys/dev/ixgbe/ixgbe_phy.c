begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************    Copyright (c) 2001-2017, Intel Corporation   All rights reserved.    Redistribution and use in source and binary forms, with or without   modification, are permitted provided that the following conditions are met:     1. Redistributions of source code must retain the above copyright notice,       this list of conditions and the following disclaimer.     2. Redistributions in binary form must reproduce the above copyright       notice, this list of conditions and the following disclaimer in the       documentation and/or other materials provided with the distribution.     3. Neither the name of the Intel Corporation nor the names of its       contributors may be used to endorse or promote products derived from       this software without specific prior written permission.    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  ******************************************************************************/
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_include
include|#
directive|include
file|"ixgbe_api.h"
end_include

begin_include
include|#
directive|include
file|"ixgbe_common.h"
end_include

begin_include
include|#
directive|include
file|"ixgbe_phy.h"
end_include

begin_function_decl
specifier|static
name|void
name|ixgbe_i2c_start
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_i2c_stop
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|ixgbe_clock_in_i2c_byte
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|ixgbe_clock_out_i2c_byte
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|ixgbe_get_i2c_ack
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|ixgbe_clock_in_i2c_bit
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|bool
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|ixgbe_clock_out_i2c_bit
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_raise_i2c_clk
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|i2cctl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_lower_i2c_clk
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|i2cctl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|ixgbe_set_i2c_data
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|i2cctl
parameter_list|,
name|bool
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ixgbe_get_i2c_data
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|i2cctl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|ixgbe_read_i2c_sff8472_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|byte_offset
parameter_list|,
name|u8
modifier|*
name|sff8472_data
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ixgbe_out_i2c_byte_ack - Send I2C byte with ack  * @hw: pointer to the hardware structure  * @byte: byte to send  *  * Returns an error code on error.  */
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_out_i2c_byte_ack
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|byte
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|status
operator|=
name|ixgbe_clock_out_i2c_byte
argument_list|(
name|hw
argument_list|,
name|byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|status
return|;
return|return
name|ixgbe_get_i2c_ack
argument_list|(
name|hw
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_in_i2c_byte_ack - Receive an I2C byte and send ack  * @hw: pointer to the hardware structure  * @byte: pointer to a u8 to receive the byte  *  * Returns an error code on error.  */
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_in_i2c_byte_ack
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|byte
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|status
operator|=
name|ixgbe_clock_in_i2c_byte
argument_list|(
name|hw
argument_list|,
name|byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|status
return|;
comment|/* ACK */
return|return
name|ixgbe_clock_out_i2c_bit
argument_list|(
name|hw
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_ones_comp_byte_add - Perform one's complement addition  * @add1 - addend 1  * @add2 - addend 2  *  * Returns one's complement 8-bit sum.  */
end_comment

begin_function
specifier|static
name|u8
name|ixgbe_ones_comp_byte_add
parameter_list|(
name|u8
name|add1
parameter_list|,
name|u8
name|add2
parameter_list|)
block|{
name|u16
name|sum
init|=
name|add1
operator|+
name|add2
decl_stmt|;
name|sum
operator|=
operator|(
name|sum
operator|&
literal|0xFF
operator|)
operator|+
operator|(
name|sum
operator|>>
literal|8
operator|)
expr_stmt|;
return|return
name|sum
operator|&
literal|0xFF
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_read_i2c_combined_generic_int - Perform I2C read combined operation  * @hw: pointer to the hardware structure  * @addr: I2C bus address to read from  * @reg: I2C device register to read from  * @val: pointer to location to receive read value  * @lock: TRUE if to take and release semaphore  *  * Returns an error code on error.  */
end_comment

begin_function
name|s32
name|ixgbe_read_i2c_combined_generic_int
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|addr
parameter_list|,
name|u16
name|reg
parameter_list|,
name|u16
modifier|*
name|val
parameter_list|,
name|bool
name|lock
parameter_list|)
block|{
name|u32
name|swfw_mask
init|=
name|hw
operator|->
name|phy
operator|.
name|phy_semaphore_mask
decl_stmt|;
name|int
name|max_retry
init|=
literal|3
decl_stmt|;
name|int
name|retry
init|=
literal|0
decl_stmt|;
name|u8
name|csum_byte
decl_stmt|;
name|u8
name|high_bits
decl_stmt|;
name|u8
name|low_bits
decl_stmt|;
name|u8
name|reg_high
decl_stmt|;
name|u8
name|csum
decl_stmt|;
name|reg_high
operator|=
operator|(
operator|(
name|reg
operator|>>
literal|7
operator|)
operator|&
literal|0xFE
operator|)
operator||
literal|1
expr_stmt|;
comment|/* Indicate read combined */
name|csum
operator|=
name|ixgbe_ones_comp_byte_add
argument_list|(
name|reg_high
argument_list|,
name|reg
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|csum
operator|=
operator|~
name|csum
expr_stmt|;
do|do
block|{
if|if
condition|(
name|lock
operator|&&
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|acquire_swfw_sync
argument_list|(
name|hw
argument_list|,
name|swfw_mask
argument_list|)
condition|)
return|return
name|IXGBE_ERR_SWFW_SYNC
return|;
name|ixgbe_i2c_start
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Device Address and write indication */
if|if
condition|(
name|ixgbe_out_i2c_byte_ack
argument_list|(
name|hw
argument_list|,
name|addr
argument_list|)
condition|)
goto|goto
name|fail
goto|;
comment|/* Write bits 14:8 */
if|if
condition|(
name|ixgbe_out_i2c_byte_ack
argument_list|(
name|hw
argument_list|,
name|reg_high
argument_list|)
condition|)
goto|goto
name|fail
goto|;
comment|/* Write bits 7:0 */
if|if
condition|(
name|ixgbe_out_i2c_byte_ack
argument_list|(
name|hw
argument_list|,
name|reg
operator|&
literal|0xFF
argument_list|)
condition|)
goto|goto
name|fail
goto|;
comment|/* Write csum */
if|if
condition|(
name|ixgbe_out_i2c_byte_ack
argument_list|(
name|hw
argument_list|,
name|csum
argument_list|)
condition|)
goto|goto
name|fail
goto|;
comment|/* Re-start condition */
name|ixgbe_i2c_start
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Device Address and read indication */
if|if
condition|(
name|ixgbe_out_i2c_byte_ack
argument_list|(
name|hw
argument_list|,
name|addr
operator||
literal|1
argument_list|)
condition|)
goto|goto
name|fail
goto|;
comment|/* Get upper bits */
if|if
condition|(
name|ixgbe_in_i2c_byte_ack
argument_list|(
name|hw
argument_list|,
operator|&
name|high_bits
argument_list|)
condition|)
goto|goto
name|fail
goto|;
comment|/* Get low bits */
if|if
condition|(
name|ixgbe_in_i2c_byte_ack
argument_list|(
name|hw
argument_list|,
operator|&
name|low_bits
argument_list|)
condition|)
goto|goto
name|fail
goto|;
comment|/* Get csum */
if|if
condition|(
name|ixgbe_clock_in_i2c_byte
argument_list|(
name|hw
argument_list|,
operator|&
name|csum_byte
argument_list|)
condition|)
goto|goto
name|fail
goto|;
comment|/* NACK */
if|if
condition|(
name|ixgbe_clock_out_i2c_bit
argument_list|(
name|hw
argument_list|,
name|FALSE
argument_list|)
condition|)
goto|goto
name|fail
goto|;
name|ixgbe_i2c_stop
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock
condition|)
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|swfw_mask
argument_list|)
expr_stmt|;
operator|*
name|val
operator|=
operator|(
name|high_bits
operator|<<
literal|8
operator|)
operator||
name|low_bits
expr_stmt|;
return|return
literal|0
return|;
name|fail
label|:
name|ixgbe_i2c_bus_clear
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock
condition|)
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|swfw_mask
argument_list|)
expr_stmt|;
name|retry
operator|++
expr_stmt|;
if|if
condition|(
name|retry
operator|<
name|max_retry
condition|)
name|DEBUGOUT
argument_list|(
literal|"I2C byte read combined error - Retrying.\n"
argument_list|)
expr_stmt|;
else|else
name|DEBUGOUT
argument_list|(
literal|"I2C byte read combined error.\n"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|retry
operator|<
name|max_retry
condition|)
do|;
return|return
name|IXGBE_ERR_I2C
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_write_i2c_combined_generic_int - Perform I2C write combined operation  * @hw: pointer to the hardware structure  * @addr: I2C bus address to write to  * @reg: I2C device register to write to  * @val: value to write  * @lock: TRUE if to take and release semaphore  *  * Returns an error code on error.  */
end_comment

begin_function
name|s32
name|ixgbe_write_i2c_combined_generic_int
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|addr
parameter_list|,
name|u16
name|reg
parameter_list|,
name|u16
name|val
parameter_list|,
name|bool
name|lock
parameter_list|)
block|{
name|u32
name|swfw_mask
init|=
name|hw
operator|->
name|phy
operator|.
name|phy_semaphore_mask
decl_stmt|;
name|int
name|max_retry
init|=
literal|1
decl_stmt|;
name|int
name|retry
init|=
literal|0
decl_stmt|;
name|u8
name|reg_high
decl_stmt|;
name|u8
name|csum
decl_stmt|;
name|reg_high
operator|=
operator|(
name|reg
operator|>>
literal|7
operator|)
operator|&
literal|0xFE
expr_stmt|;
comment|/* Indicate write combined */
name|csum
operator|=
name|ixgbe_ones_comp_byte_add
argument_list|(
name|reg_high
argument_list|,
name|reg
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|csum
operator|=
name|ixgbe_ones_comp_byte_add
argument_list|(
name|csum
argument_list|,
name|val
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|csum
operator|=
name|ixgbe_ones_comp_byte_add
argument_list|(
name|csum
argument_list|,
name|val
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|csum
operator|=
operator|~
name|csum
expr_stmt|;
do|do
block|{
if|if
condition|(
name|lock
operator|&&
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|acquire_swfw_sync
argument_list|(
name|hw
argument_list|,
name|swfw_mask
argument_list|)
condition|)
return|return
name|IXGBE_ERR_SWFW_SYNC
return|;
name|ixgbe_i2c_start
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Device Address and write indication */
if|if
condition|(
name|ixgbe_out_i2c_byte_ack
argument_list|(
name|hw
argument_list|,
name|addr
argument_list|)
condition|)
goto|goto
name|fail
goto|;
comment|/* Write bits 14:8 */
if|if
condition|(
name|ixgbe_out_i2c_byte_ack
argument_list|(
name|hw
argument_list|,
name|reg_high
argument_list|)
condition|)
goto|goto
name|fail
goto|;
comment|/* Write bits 7:0 */
if|if
condition|(
name|ixgbe_out_i2c_byte_ack
argument_list|(
name|hw
argument_list|,
name|reg
operator|&
literal|0xFF
argument_list|)
condition|)
goto|goto
name|fail
goto|;
comment|/* Write data 15:8 */
if|if
condition|(
name|ixgbe_out_i2c_byte_ack
argument_list|(
name|hw
argument_list|,
name|val
operator|>>
literal|8
argument_list|)
condition|)
goto|goto
name|fail
goto|;
comment|/* Write data 7:0 */
if|if
condition|(
name|ixgbe_out_i2c_byte_ack
argument_list|(
name|hw
argument_list|,
name|val
operator|&
literal|0xFF
argument_list|)
condition|)
goto|goto
name|fail
goto|;
comment|/* Write csum */
if|if
condition|(
name|ixgbe_out_i2c_byte_ack
argument_list|(
name|hw
argument_list|,
name|csum
argument_list|)
condition|)
goto|goto
name|fail
goto|;
name|ixgbe_i2c_stop
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock
condition|)
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|swfw_mask
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|fail
label|:
name|ixgbe_i2c_bus_clear
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock
condition|)
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|swfw_mask
argument_list|)
expr_stmt|;
name|retry
operator|++
expr_stmt|;
if|if
condition|(
name|retry
operator|<
name|max_retry
condition|)
name|DEBUGOUT
argument_list|(
literal|"I2C byte write combined error - Retrying.\n"
argument_list|)
expr_stmt|;
else|else
name|DEBUGOUT
argument_list|(
literal|"I2C byte write combined error.\n"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|retry
operator|<
name|max_retry
condition|)
do|;
return|return
name|IXGBE_ERR_I2C
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_init_phy_ops_generic - Inits PHY function ptrs  *  @hw: pointer to the hardware structure  *  *  Initialize the function pointers.  **/
end_comment

begin_function
name|s32
name|ixgbe_init_phy_ops_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|ixgbe_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_init_phy_ops_generic"
argument_list|)
expr_stmt|;
comment|/* PHY */
name|phy
operator|->
name|ops
operator|.
name|identify
operator|=
name|ixgbe_identify_phy_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|reset
operator|=
name|ixgbe_reset_phy_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|read_reg
operator|=
name|ixgbe_read_phy_reg_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|write_reg
operator|=
name|ixgbe_write_phy_reg_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|read_reg_mdi
operator|=
name|ixgbe_read_phy_reg_mdi
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|write_reg_mdi
operator|=
name|ixgbe_write_phy_reg_mdi
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|setup_link
operator|=
name|ixgbe_setup_phy_link_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|setup_link_speed
operator|=
name|ixgbe_setup_phy_link_speed_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|check_link
operator|=
name|NULL
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|get_firmware_version
operator|=
name|ixgbe_get_phy_firmware_version_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|read_i2c_byte
operator|=
name|ixgbe_read_i2c_byte_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|write_i2c_byte
operator|=
name|ixgbe_write_i2c_byte_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|read_i2c_sff8472
operator|=
name|ixgbe_read_i2c_sff8472_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|read_i2c_eeprom
operator|=
name|ixgbe_read_i2c_eeprom_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|write_i2c_eeprom
operator|=
name|ixgbe_write_i2c_eeprom_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|i2c_bus_clear
operator|=
name|ixgbe_i2c_bus_clear
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|identify_sfp
operator|=
name|ixgbe_identify_module_generic
expr_stmt|;
name|phy
operator|->
name|sfp_type
operator|=
name|ixgbe_sfp_type_unknown
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|read_i2c_byte_unlocked
operator|=
name|ixgbe_read_i2c_byte_generic_unlocked
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|write_i2c_byte_unlocked
operator|=
name|ixgbe_write_i2c_byte_generic_unlocked
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|check_overtemp
operator|=
name|ixgbe_tn_check_overtemp
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_probe_phy - Probe a single address for a PHY  * @hw: pointer to hardware structure  * @phy_addr: PHY address to probe  *  * Returns TRUE if PHY found  */
end_comment

begin_function
specifier|static
name|bool
name|ixgbe_probe_phy
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|phy_addr
parameter_list|)
block|{
name|u16
name|ext_ability
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|ixgbe_validate_phy_addr
argument_list|(
name|hw
argument_list|,
name|phy_addr
argument_list|)
condition|)
block|{
name|DEBUGOUT1
argument_list|(
literal|"Unable to validate PHY address 0x%04X\n"
argument_list|,
name|phy_addr
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|ixgbe_get_phy_id
argument_list|(
name|hw
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|ixgbe_get_phy_type_from_id
argument_list|(
name|hw
operator|->
name|phy
operator|.
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|ixgbe_phy_unknown
condition|)
block|{
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_PHY_EXT_ABILITY
argument_list|,
name|IXGBE_MDIO_PMA_PMD_DEV_TYPE
argument_list|,
operator|&
name|ext_ability
argument_list|)
expr_stmt|;
if|if
condition|(
name|ext_ability
operator|&
operator|(
name|IXGBE_MDIO_PHY_10GBASET_ABILITY
operator||
name|IXGBE_MDIO_PHY_1000BASET_ABILITY
operator|)
condition|)
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|ixgbe_phy_cu_unknown
expr_stmt|;
else|else
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|ixgbe_phy_generic
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_identify_phy_generic - Get physical layer module  *  @hw: pointer to hardware structure  *  *  Determines the physical layer module found on the current adapter.  **/
end_comment

begin_function
name|s32
name|ixgbe_identify_phy_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_ERR_PHY_ADDR_INVALID
decl_stmt|;
name|u16
name|phy_addr
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_identify_phy_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hw
operator|->
name|phy
operator|.
name|phy_semaphore_mask
condition|)
block|{
if|if
condition|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
condition|)
name|hw
operator|->
name|phy
operator|.
name|phy_semaphore_mask
operator|=
name|IXGBE_GSSR_PHY1_SM
expr_stmt|;
else|else
name|hw
operator|->
name|phy
operator|.
name|phy_semaphore_mask
operator|=
name|IXGBE_GSSR_PHY0_SM
expr_stmt|;
block|}
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|!=
name|ixgbe_phy_unknown
condition|)
return|return
name|IXGBE_SUCCESS
return|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|nw_mng_if_sel
condition|)
block|{
name|phy_addr
operator|=
operator|(
name|hw
operator|->
name|phy
operator|.
name|nw_mng_if_sel
operator|&
name|IXGBE_NW_MNG_IF_SEL_MDIO_PHY_ADD
operator|)
operator|>>
name|IXGBE_NW_MNG_IF_SEL_MDIO_PHY_ADD_SHIFT
expr_stmt|;
if|if
condition|(
name|ixgbe_probe_phy
argument_list|(
name|hw
argument_list|,
name|phy_addr
argument_list|)
condition|)
return|return
name|IXGBE_SUCCESS
return|;
else|else
return|return
name|IXGBE_ERR_PHY_ADDR_INVALID
return|;
block|}
for|for
control|(
name|phy_addr
operator|=
literal|0
init|;
name|phy_addr
operator|<
name|IXGBE_MAX_PHY_ADDR
condition|;
name|phy_addr
operator|++
control|)
block|{
if|if
condition|(
name|ixgbe_probe_phy
argument_list|(
name|hw
argument_list|,
name|phy_addr
argument_list|)
condition|)
block|{
name|status
operator|=
name|IXGBE_SUCCESS
expr_stmt|;
break|break;
block|}
block|}
comment|/* Certain media types do not have a phy so an address will not 	 * be found and the code will take this path.  Caller has to 	 * decide if it is an error or not. 	 */
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
name|hw
operator|->
name|phy
operator|.
name|addr
operator|=
literal|0
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_check_reset_blocked - check status of MNG FW veto bit  * @hw: pointer to the hardware structure  *  * This function checks the MMNGC.MNG_VETO bit to see if there are  * any constraints on link from manageability.  For MAC's that don't  * have this bit just return faluse since the link can not be blocked  * via this method.  **/
end_comment

begin_function
name|s32
name|ixgbe_check_reset_blocked
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|mmngc
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_check_reset_blocked"
argument_list|)
expr_stmt|;
comment|/* If we don't have this bit, it can't be blocking */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_82598EB
condition|)
return|return
name|FALSE
return|;
name|mmngc
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MMNGC
argument_list|)
expr_stmt|;
if|if
condition|(
name|mmngc
operator|&
name|IXGBE_MMNGC_MNG_VETO
condition|)
block|{
name|ERROR_REPORT1
argument_list|(
name|IXGBE_ERROR_SOFTWARE
argument_list|,
literal|"MNG_VETO bit detected.\n"
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_validate_phy_addr - Determines phy address is valid  *  @hw: pointer to hardware structure  *  **/
end_comment

begin_function
name|bool
name|ixgbe_validate_phy_addr
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|phy_addr
parameter_list|)
block|{
name|u16
name|phy_id
init|=
literal|0
decl_stmt|;
name|bool
name|valid
init|=
name|FALSE
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_validate_phy_addr"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|addr
operator|=
name|phy_addr
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_PHY_ID_HIGH
argument_list|,
name|IXGBE_MDIO_PMA_PMD_DEV_TYPE
argument_list|,
operator|&
name|phy_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_id
operator|!=
literal|0xFFFF
operator|&&
name|phy_id
operator|!=
literal|0x0
condition|)
name|valid
operator|=
name|TRUE
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"PHY ID HIGH is 0x%04X\n"
argument_list|,
name|phy_id
argument_list|)
expr_stmt|;
return|return
name|valid
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_phy_id - Get the phy type  *  @hw: pointer to hardware structure  *  **/
end_comment

begin_function
name|s32
name|ixgbe_get_phy_id
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|status
decl_stmt|;
name|u16
name|phy_id_high
init|=
literal|0
decl_stmt|;
name|u16
name|phy_id_low
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_phy_id"
argument_list|)
expr_stmt|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_PHY_ID_HIGH
argument_list|,
name|IXGBE_MDIO_PMA_PMD_DEV_TYPE
argument_list|,
operator|&
name|phy_id_high
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
condition|)
block|{
name|hw
operator|->
name|phy
operator|.
name|id
operator|=
call|(
name|u32
call|)
argument_list|(
name|phy_id_high
operator|<<
literal|16
argument_list|)
expr_stmt|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_PHY_ID_LOW
argument_list|,
name|IXGBE_MDIO_PMA_PMD_DEV_TYPE
argument_list|,
operator|&
name|phy_id_low
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|id
operator||=
call|(
name|u32
call|)
argument_list|(
name|phy_id_low
operator|&
name|IXGBE_PHY_REVISION_MASK
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|revision
operator|=
call|(
name|u32
call|)
argument_list|(
name|phy_id_low
operator|&
operator|~
name|IXGBE_PHY_REVISION_MASK
argument_list|)
expr_stmt|;
block|}
name|DEBUGOUT2
argument_list|(
literal|"PHY_ID_HIGH 0x%04X, PHY_ID_LOW 0x%04X\n"
argument_list|,
name|phy_id_high
argument_list|,
name|phy_id_low
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_phy_type_from_id - Get the phy type  *  @phy_id: PHY ID information  *  **/
end_comment

begin_function
name|enum
name|ixgbe_phy_type
name|ixgbe_get_phy_type_from_id
parameter_list|(
name|u32
name|phy_id
parameter_list|)
block|{
name|enum
name|ixgbe_phy_type
name|phy_type
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_phy_type_from_id"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|phy_id
condition|)
block|{
case|case
name|TN1010_PHY_ID
case|:
name|phy_type
operator|=
name|ixgbe_phy_tn
expr_stmt|;
break|break;
case|case
name|X550_PHY_ID2
case|:
case|case
name|X550_PHY_ID3
case|:
case|case
name|X540_PHY_ID
case|:
name|phy_type
operator|=
name|ixgbe_phy_aq
expr_stmt|;
break|break;
case|case
name|QT2022_PHY_ID
case|:
name|phy_type
operator|=
name|ixgbe_phy_qt
expr_stmt|;
break|break;
case|case
name|ATH_PHY_ID
case|:
name|phy_type
operator|=
name|ixgbe_phy_nl
expr_stmt|;
break|break;
case|case
name|X557_PHY_ID
case|:
case|case
name|X557_PHY_ID2
case|:
name|phy_type
operator|=
name|ixgbe_phy_x550em_ext_t
expr_stmt|;
break|break;
case|case
name|IXGBE_M88E1500_E_PHY_ID
case|:
case|case
name|IXGBE_M88E1543_E_PHY_ID
case|:
name|phy_type
operator|=
name|ixgbe_phy_ext_1g_t
expr_stmt|;
break|break;
default|default:
name|phy_type
operator|=
name|ixgbe_phy_unknown
expr_stmt|;
break|break;
block|}
return|return
name|phy_type
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_reset_phy_generic - Performs a PHY reset  *  @hw: pointer to hardware structure  **/
end_comment

begin_function
name|s32
name|ixgbe_reset_phy_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|i
decl_stmt|;
name|u16
name|ctrl
init|=
literal|0
decl_stmt|;
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_reset_phy_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|ixgbe_phy_unknown
condition|)
name|status
operator|=
name|ixgbe_identify_phy_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
operator|||
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|ixgbe_phy_none
condition|)
goto|goto
name|out
goto|;
comment|/* Don't reset PHY if it's shut down due to overtemp. */
if|if
condition|(
operator|!
name|hw
operator|->
name|phy
operator|.
name|reset_if_overtemp
operator|&&
operator|(
name|IXGBE_ERR_OVERTEMP
operator|==
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|check_overtemp
argument_list|(
name|hw
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
comment|/* Blocked by MNG FW so bail */
if|if
condition|(
name|ixgbe_check_reset_blocked
argument_list|(
name|hw
argument_list|)
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Perform soft PHY reset to the PHY_XS. 	 * This will cause a soft reset to the PHY 	 */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_PHY_XS_CONTROL
argument_list|,
name|IXGBE_MDIO_PHY_XS_DEV_TYPE
argument_list|,
name|IXGBE_MDIO_PHY_XS_RESET
argument_list|)
expr_stmt|;
comment|/* 	 * Poll for reset bit to self-clear indicating reset is complete. 	 * Some PHYs could take up to 3 seconds to complete and need about 	 * 1.7 usec delay after the reset is complete. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|30
condition|;
name|i
operator|++
control|)
block|{
name|msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|ixgbe_phy_x550em_ext_t
condition|)
block|{
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_TX_VENDOR_ALARMS_3
argument_list|,
name|IXGBE_MDIO_PMA_PMD_DEV_TYPE
argument_list|,
operator|&
name|ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
if|if
condition|(
name|ctrl
operator|&
name|IXGBE_MDIO_TX_VENDOR_ALARMS_3_RST_MASK
condition|)
block|{
name|usec_delay
argument_list|(
literal|2
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_PHY_XS_CONTROL
argument_list|,
name|IXGBE_MDIO_PHY_XS_DEV_TYPE
argument_list|,
operator|&
name|ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
if|if
condition|(
operator|!
operator|(
name|ctrl
operator|&
name|IXGBE_MDIO_PHY_XS_RESET
operator|)
condition|)
block|{
name|usec_delay
argument_list|(
literal|2
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|ctrl
operator|&
name|IXGBE_MDIO_PHY_XS_RESET
condition|)
block|{
name|status
operator|=
name|IXGBE_ERR_RESET_FAILED
expr_stmt|;
name|ERROR_REPORT1
argument_list|(
name|IXGBE_ERROR_POLLING
argument_list|,
literal|"PHY reset polling failed to complete.\n"
argument_list|)
expr_stmt|;
block|}
name|out
label|:
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_read_phy_mdi - Reads a value from a specified PHY register without  *  the SWFW lock  *  @hw: pointer to hardware structure  *  @reg_addr: 32 bit address of PHY register to read  *  @phy_data: Pointer to read data from PHY register  **/
end_comment

begin_function
name|s32
name|ixgbe_read_phy_reg_mdi
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|reg_addr
parameter_list|,
name|u32
name|device_type
parameter_list|,
name|u16
modifier|*
name|phy_data
parameter_list|)
block|{
name|u32
name|i
decl_stmt|,
name|data
decl_stmt|,
name|command
decl_stmt|;
comment|/* Setup and write the address cycle command */
name|command
operator|=
operator|(
operator|(
name|reg_addr
operator|<<
name|IXGBE_MSCA_NP_ADDR_SHIFT
operator|)
operator||
operator|(
name|device_type
operator|<<
name|IXGBE_MSCA_DEV_TYPE_SHIFT
operator|)
operator||
operator|(
name|hw
operator|->
name|phy
operator|.
name|addr
operator|<<
name|IXGBE_MSCA_PHY_ADDR_SHIFT
operator|)
operator||
operator|(
name|IXGBE_MSCA_ADDR_CYCLE
operator||
name|IXGBE_MSCA_MDI_COMMAND
operator|)
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MSCA
argument_list|,
name|command
argument_list|)
expr_stmt|;
comment|/* 	 * Check every 10 usec to see if the address cycle completed. 	 * The MDI Command bit will clear when the operation is 	 * complete 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_MDIO_COMMAND_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|command
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MSCA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|command
operator|&
name|IXGBE_MSCA_MDI_COMMAND
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|command
operator|&
name|IXGBE_MSCA_MDI_COMMAND
operator|)
operator|!=
literal|0
condition|)
block|{
name|ERROR_REPORT1
argument_list|(
name|IXGBE_ERROR_POLLING
argument_list|,
literal|"PHY address command did not complete.\n"
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"PHY address command did not complete, returning IXGBE_ERR_PHY\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_PHY
return|;
block|}
comment|/* 	 * Address cycle complete, setup and write the read 	 * command 	 */
name|command
operator|=
operator|(
operator|(
name|reg_addr
operator|<<
name|IXGBE_MSCA_NP_ADDR_SHIFT
operator|)
operator||
operator|(
name|device_type
operator|<<
name|IXGBE_MSCA_DEV_TYPE_SHIFT
operator|)
operator||
operator|(
name|hw
operator|->
name|phy
operator|.
name|addr
operator|<<
name|IXGBE_MSCA_PHY_ADDR_SHIFT
operator|)
operator||
operator|(
name|IXGBE_MSCA_READ
operator||
name|IXGBE_MSCA_MDI_COMMAND
operator|)
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MSCA
argument_list|,
name|command
argument_list|)
expr_stmt|;
comment|/* 	 * Check every 10 usec to see if the address cycle 	 * completed. The MDI Command bit will clear when the 	 * operation is complete 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_MDIO_COMMAND_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|command
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MSCA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|command
operator|&
name|IXGBE_MSCA_MDI_COMMAND
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|command
operator|&
name|IXGBE_MSCA_MDI_COMMAND
operator|)
operator|!=
literal|0
condition|)
block|{
name|ERROR_REPORT1
argument_list|(
name|IXGBE_ERROR_POLLING
argument_list|,
literal|"PHY read command didn't complete\n"
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"PHY read command didn't complete, returning IXGBE_ERR_PHY\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_PHY
return|;
block|}
comment|/* 	 * Read operation is complete.  Get the data 	 * from MSRWD 	 */
name|data
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MSRWD
argument_list|)
expr_stmt|;
name|data
operator|>>=
name|IXGBE_MSRWD_READ_DATA_SHIFT
expr_stmt|;
operator|*
name|phy_data
operator|=
call|(
name|u16
call|)
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_read_phy_reg_generic - Reads a value from a specified PHY register  *  using the SWFW lock - this function is needed in most cases  *  @hw: pointer to hardware structure  *  @reg_addr: 32 bit address of PHY register to read  *  @phy_data: Pointer to read data from PHY register  **/
end_comment

begin_function
name|s32
name|ixgbe_read_phy_reg_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|reg_addr
parameter_list|,
name|u32
name|device_type
parameter_list|,
name|u16
modifier|*
name|phy_data
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|u32
name|gssr
init|=
name|hw
operator|->
name|phy
operator|.
name|phy_semaphore_mask
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_read_phy_reg_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|acquire_swfw_sync
argument_list|(
name|hw
argument_list|,
name|gssr
argument_list|)
condition|)
return|return
name|IXGBE_ERR_SWFW_SYNC
return|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg_mdi
argument_list|(
name|hw
argument_list|,
name|reg_addr
argument_list|,
name|device_type
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|gssr
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_write_phy_reg_mdi - Writes a value to specified PHY register  *  without SWFW lock  *  @hw: pointer to hardware structure  *  @reg_addr: 32 bit PHY register to write  *  @device_type: 5 bit device type  *  @phy_data: Data to write to the PHY register  **/
end_comment

begin_function
name|s32
name|ixgbe_write_phy_reg_mdi
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|reg_addr
parameter_list|,
name|u32
name|device_type
parameter_list|,
name|u16
name|phy_data
parameter_list|)
block|{
name|u32
name|i
decl_stmt|,
name|command
decl_stmt|;
comment|/* Put the data in the MDI single read and write data register*/
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MSRWD
argument_list|,
operator|(
name|u32
operator|)
name|phy_data
argument_list|)
expr_stmt|;
comment|/* Setup and write the address cycle command */
name|command
operator|=
operator|(
operator|(
name|reg_addr
operator|<<
name|IXGBE_MSCA_NP_ADDR_SHIFT
operator|)
operator||
operator|(
name|device_type
operator|<<
name|IXGBE_MSCA_DEV_TYPE_SHIFT
operator|)
operator||
operator|(
name|hw
operator|->
name|phy
operator|.
name|addr
operator|<<
name|IXGBE_MSCA_PHY_ADDR_SHIFT
operator|)
operator||
operator|(
name|IXGBE_MSCA_ADDR_CYCLE
operator||
name|IXGBE_MSCA_MDI_COMMAND
operator|)
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MSCA
argument_list|,
name|command
argument_list|)
expr_stmt|;
comment|/* 	 * Check every 10 usec to see if the address cycle completed. 	 * The MDI Command bit will clear when the operation is 	 * complete 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_MDIO_COMMAND_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|command
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MSCA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|command
operator|&
name|IXGBE_MSCA_MDI_COMMAND
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|command
operator|&
name|IXGBE_MSCA_MDI_COMMAND
operator|)
operator|!=
literal|0
condition|)
block|{
name|ERROR_REPORT1
argument_list|(
name|IXGBE_ERROR_POLLING
argument_list|,
literal|"PHY address cmd didn't complete\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_PHY
return|;
block|}
comment|/* 	 * Address cycle complete, setup and write the write 	 * command 	 */
name|command
operator|=
operator|(
operator|(
name|reg_addr
operator|<<
name|IXGBE_MSCA_NP_ADDR_SHIFT
operator|)
operator||
operator|(
name|device_type
operator|<<
name|IXGBE_MSCA_DEV_TYPE_SHIFT
operator|)
operator||
operator|(
name|hw
operator|->
name|phy
operator|.
name|addr
operator|<<
name|IXGBE_MSCA_PHY_ADDR_SHIFT
operator|)
operator||
operator|(
name|IXGBE_MSCA_WRITE
operator||
name|IXGBE_MSCA_MDI_COMMAND
operator|)
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MSCA
argument_list|,
name|command
argument_list|)
expr_stmt|;
comment|/* 	 * Check every 10 usec to see if the address cycle 	 * completed. The MDI Command bit will clear when the 	 * operation is complete 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_MDIO_COMMAND_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|command
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MSCA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|command
operator|&
name|IXGBE_MSCA_MDI_COMMAND
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|command
operator|&
name|IXGBE_MSCA_MDI_COMMAND
operator|)
operator|!=
literal|0
condition|)
block|{
name|ERROR_REPORT1
argument_list|(
name|IXGBE_ERROR_POLLING
argument_list|,
literal|"PHY write cmd didn't complete\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_PHY
return|;
block|}
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_write_phy_reg_generic - Writes a value to specified PHY register  *  using SWFW lock- this function is needed in most cases  *  @hw: pointer to hardware structure  *  @reg_addr: 32 bit PHY register to write  *  @device_type: 5 bit device type  *  @phy_data: Data to write to the PHY register  **/
end_comment

begin_function
name|s32
name|ixgbe_write_phy_reg_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|reg_addr
parameter_list|,
name|u32
name|device_type
parameter_list|,
name|u16
name|phy_data
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|u32
name|gssr
init|=
name|hw
operator|->
name|phy
operator|.
name|phy_semaphore_mask
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_write_phy_reg_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|acquire_swfw_sync
argument_list|(
name|hw
argument_list|,
name|gssr
argument_list|)
operator|==
name|IXGBE_SUCCESS
condition|)
block|{
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg_mdi
argument_list|(
name|hw
argument_list|,
name|reg_addr
argument_list|,
name|device_type
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|gssr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|IXGBE_ERR_SWFW_SYNC
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_setup_phy_link_generic - Set and restart auto-neg  *  @hw: pointer to hardware structure  *  *  Restart auto-negotiation and PHY and waits for completion.  **/
end_comment

begin_function
name|s32
name|ixgbe_setup_phy_link_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u16
name|autoneg_reg
init|=
name|IXGBE_MII_AUTONEG_REG
decl_stmt|;
name|bool
name|autoneg
init|=
name|FALSE
decl_stmt|;
name|ixgbe_link_speed
name|speed
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_setup_phy_link_generic"
argument_list|)
expr_stmt|;
name|ixgbe_get_copper_link_capabilities_generic
argument_list|(
name|hw
argument_list|,
operator|&
name|speed
argument_list|,
operator|&
name|autoneg
argument_list|)
expr_stmt|;
comment|/* Set or unset auto-negotiation 10G advertisement */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MII_10GBASE_T_AUTONEG_CTRL_REG
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
operator|&
name|autoneg_reg
argument_list|)
expr_stmt|;
name|autoneg_reg
operator|&=
operator|~
name|IXGBE_MII_10GBASE_T_ADVERTISE
expr_stmt|;
if|if
condition|(
operator|(
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator|&
name|IXGBE_LINK_SPEED_10GB_FULL
operator|)
operator|&&
operator|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_10GB_FULL
operator|)
condition|)
name|autoneg_reg
operator||=
name|IXGBE_MII_10GBASE_T_ADVERTISE
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MII_10GBASE_T_AUTONEG_CTRL_REG
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
name|autoneg_reg
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MII_AUTONEG_VENDOR_PROVISION_1_REG
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
operator|&
name|autoneg_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_X550
condition|)
block|{
comment|/* Set or unset auto-negotiation 5G advertisement */
name|autoneg_reg
operator|&=
operator|~
name|IXGBE_MII_5GBASE_T_ADVERTISE
expr_stmt|;
if|if
condition|(
operator|(
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator|&
name|IXGBE_LINK_SPEED_5GB_FULL
operator|)
operator|&&
operator|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_5GB_FULL
operator|)
condition|)
name|autoneg_reg
operator||=
name|IXGBE_MII_5GBASE_T_ADVERTISE
expr_stmt|;
comment|/* Set or unset auto-negotiation 2.5G advertisement */
name|autoneg_reg
operator|&=
operator|~
name|IXGBE_MII_2_5GBASE_T_ADVERTISE
expr_stmt|;
if|if
condition|(
operator|(
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator|&
name|IXGBE_LINK_SPEED_2_5GB_FULL
operator|)
operator|&&
operator|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_2_5GB_FULL
operator|)
condition|)
name|autoneg_reg
operator||=
name|IXGBE_MII_2_5GBASE_T_ADVERTISE
expr_stmt|;
block|}
comment|/* Set or unset auto-negotiation 1G advertisement */
name|autoneg_reg
operator|&=
operator|~
name|IXGBE_MII_1GBASE_T_ADVERTISE
expr_stmt|;
if|if
condition|(
operator|(
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator|&
name|IXGBE_LINK_SPEED_1GB_FULL
operator|)
operator|&&
operator|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_1GB_FULL
operator|)
condition|)
name|autoneg_reg
operator||=
name|IXGBE_MII_1GBASE_T_ADVERTISE
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MII_AUTONEG_VENDOR_PROVISION_1_REG
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
name|autoneg_reg
argument_list|)
expr_stmt|;
comment|/* Set or unset auto-negotiation 100M advertisement */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MII_AUTONEG_ADVERTISE_REG
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
operator|&
name|autoneg_reg
argument_list|)
expr_stmt|;
name|autoneg_reg
operator|&=
operator|~
operator|(
name|IXGBE_MII_100BASE_T_ADVERTISE
operator||
name|IXGBE_MII_100BASE_T_ADVERTISE_HALF
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator|&
name|IXGBE_LINK_SPEED_100_FULL
operator|)
operator|&&
operator|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_100_FULL
operator|)
condition|)
name|autoneg_reg
operator||=
name|IXGBE_MII_100BASE_T_ADVERTISE
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MII_AUTONEG_ADVERTISE_REG
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
name|autoneg_reg
argument_list|)
expr_stmt|;
comment|/* Blocked by MNG FW so don't reset PHY */
if|if
condition|(
name|ixgbe_check_reset_blocked
argument_list|(
name|hw
argument_list|)
condition|)
return|return
name|status
return|;
comment|/* Restart PHY auto-negotiation. */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_CONTROL
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
operator|&
name|autoneg_reg
argument_list|)
expr_stmt|;
name|autoneg_reg
operator||=
name|IXGBE_MII_RESTART
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_CONTROL
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
name|autoneg_reg
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_setup_phy_link_speed_generic - Sets the auto advertised capabilities  *  @hw: pointer to hardware structure  *  @speed: new link speed  **/
end_comment

begin_function
name|s32
name|ixgbe_setup_phy_link_speed_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
name|speed
parameter_list|,
name|bool
name|autoneg_wait_to_complete
parameter_list|)
block|{
name|UNREFERENCED_1PARAMETER
argument_list|(
name|autoneg_wait_to_complete
argument_list|)
expr_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_setup_phy_link_speed_generic"
argument_list|)
expr_stmt|;
comment|/* 	 * Clear autoneg_advertised and set new values based on input link 	 * speed. 	 */
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_10GB_FULL
condition|)
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator||=
name|IXGBE_LINK_SPEED_10GB_FULL
expr_stmt|;
if|if
condition|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_5GB_FULL
condition|)
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator||=
name|IXGBE_LINK_SPEED_5GB_FULL
expr_stmt|;
if|if
condition|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_2_5GB_FULL
condition|)
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator||=
name|IXGBE_LINK_SPEED_2_5GB_FULL
expr_stmt|;
if|if
condition|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_1GB_FULL
condition|)
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator||=
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
if|if
condition|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_100_FULL
condition|)
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator||=
name|IXGBE_LINK_SPEED_100_FULL
expr_stmt|;
if|if
condition|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_10_FULL
condition|)
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator||=
name|IXGBE_LINK_SPEED_10_FULL
expr_stmt|;
comment|/* Setup link based on the new speed settings */
name|ixgbe_setup_phy_link
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_get_copper_speeds_supported - Get copper link speeds from phy  * @hw: pointer to hardware structure  *  * Determines the supported link capabilities by reading the PHY auto  * negotiation register.  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_get_copper_speeds_supported
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|u16
name|speed_ability
decl_stmt|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_PHY_SPEED_ABILITY
argument_list|,
name|IXGBE_MDIO_PMA_PMD_DEV_TYPE
argument_list|,
operator|&
name|speed_ability
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|status
return|;
if|if
condition|(
name|speed_ability
operator|&
name|IXGBE_MDIO_PHY_SPEED_10G
condition|)
name|hw
operator|->
name|phy
operator|.
name|speeds_supported
operator||=
name|IXGBE_LINK_SPEED_10GB_FULL
expr_stmt|;
if|if
condition|(
name|speed_ability
operator|&
name|IXGBE_MDIO_PHY_SPEED_1G
condition|)
name|hw
operator|->
name|phy
operator|.
name|speeds_supported
operator||=
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
if|if
condition|(
name|speed_ability
operator|&
name|IXGBE_MDIO_PHY_SPEED_100M
condition|)
name|hw
operator|->
name|phy
operator|.
name|speeds_supported
operator||=
name|IXGBE_LINK_SPEED_100_FULL
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|ixgbe_mac_X550
case|:
name|hw
operator|->
name|phy
operator|.
name|speeds_supported
operator||=
name|IXGBE_LINK_SPEED_2_5GB_FULL
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|speeds_supported
operator||=
name|IXGBE_LINK_SPEED_5GB_FULL
expr_stmt|;
break|break;
case|case
name|ixgbe_mac_X550EM_x
case|:
case|case
name|ixgbe_mac_X550EM_a
case|:
name|hw
operator|->
name|phy
operator|.
name|speeds_supported
operator|&=
operator|~
name|IXGBE_LINK_SPEED_100_FULL
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_copper_link_capabilities_generic - Determines link capabilities  *  @hw: pointer to hardware structure  *  @speed: pointer to link speed  *  @autoneg: boolean auto-negotiation value  **/
end_comment

begin_function
name|s32
name|ixgbe_get_copper_link_capabilities_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
modifier|*
name|speed
parameter_list|,
name|bool
modifier|*
name|autoneg
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_copper_link_capabilities_generic"
argument_list|)
expr_stmt|;
operator|*
name|autoneg
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|hw
operator|->
name|phy
operator|.
name|speeds_supported
condition|)
name|status
operator|=
name|ixgbe_get_copper_speeds_supported
argument_list|(
name|hw
argument_list|)
expr_stmt|;
operator|*
name|speed
operator|=
name|hw
operator|->
name|phy
operator|.
name|speeds_supported
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_check_phy_link_tnx - Determine link and speed status  *  @hw: pointer to hardware structure  *  *  Reads the VS1 register to determine if link is up and the current speed for  *  the PHY.  **/
end_comment

begin_function
name|s32
name|ixgbe_check_phy_link_tnx
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
modifier|*
name|speed
parameter_list|,
name|bool
modifier|*
name|link_up
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u32
name|time_out
decl_stmt|;
name|u32
name|max_time_out
init|=
literal|10
decl_stmt|;
name|u16
name|phy_link
init|=
literal|0
decl_stmt|;
name|u16
name|phy_speed
init|=
literal|0
decl_stmt|;
name|u16
name|phy_data
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_check_phy_link_tnx"
argument_list|)
expr_stmt|;
comment|/* Initialize speed and link to default case */
operator|*
name|link_up
operator|=
name|FALSE
expr_stmt|;
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_10GB_FULL
expr_stmt|;
comment|/* 	 * Check current speed and link status of the PHY register. 	 * This is a vendor specific register and may have to 	 * be changed for other copper PHYs. 	 */
for|for
control|(
name|time_out
operator|=
literal|0
init|;
name|time_out
operator|<
name|max_time_out
condition|;
name|time_out
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_STATUS
argument_list|,
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
name|phy_link
operator|=
name|phy_data
operator|&
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_LINK_STATUS
expr_stmt|;
name|phy_speed
operator|=
name|phy_data
operator|&
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_SPEED_STATUS
expr_stmt|;
if|if
condition|(
name|phy_link
operator|==
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_LINK_STATUS
condition|)
block|{
operator|*
name|link_up
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|phy_speed
operator|==
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_SPEED_STATUS
condition|)
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
break|break;
block|}
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *	ixgbe_setup_phy_link_tnx - Set and restart auto-neg  *	@hw: pointer to hardware structure  *  *	Restart auto-negotiation and PHY and waits for completion.  **/
end_comment

begin_function
name|s32
name|ixgbe_setup_phy_link_tnx
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u16
name|autoneg_reg
init|=
name|IXGBE_MII_AUTONEG_REG
decl_stmt|;
name|bool
name|autoneg
init|=
name|FALSE
decl_stmt|;
name|ixgbe_link_speed
name|speed
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_setup_phy_link_tnx"
argument_list|)
expr_stmt|;
name|ixgbe_get_copper_link_capabilities_generic
argument_list|(
name|hw
argument_list|,
operator|&
name|speed
argument_list|,
operator|&
name|autoneg
argument_list|)
expr_stmt|;
if|if
condition|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_10GB_FULL
condition|)
block|{
comment|/* Set or unset auto-negotiation 10G advertisement */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MII_10GBASE_T_AUTONEG_CTRL_REG
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
operator|&
name|autoneg_reg
argument_list|)
expr_stmt|;
name|autoneg_reg
operator|&=
operator|~
name|IXGBE_MII_10GBASE_T_ADVERTISE
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator|&
name|IXGBE_LINK_SPEED_10GB_FULL
condition|)
name|autoneg_reg
operator||=
name|IXGBE_MII_10GBASE_T_ADVERTISE
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MII_10GBASE_T_AUTONEG_CTRL_REG
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
name|autoneg_reg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_1GB_FULL
condition|)
block|{
comment|/* Set or unset auto-negotiation 1G advertisement */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MII_AUTONEG_XNP_TX_REG
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
operator|&
name|autoneg_reg
argument_list|)
expr_stmt|;
name|autoneg_reg
operator|&=
operator|~
name|IXGBE_MII_1GBASE_T_ADVERTISE_XNP_TX
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator|&
name|IXGBE_LINK_SPEED_1GB_FULL
condition|)
name|autoneg_reg
operator||=
name|IXGBE_MII_1GBASE_T_ADVERTISE_XNP_TX
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MII_AUTONEG_XNP_TX_REG
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
name|autoneg_reg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_100_FULL
condition|)
block|{
comment|/* Set or unset auto-negotiation 100M advertisement */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MII_AUTONEG_ADVERTISE_REG
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
operator|&
name|autoneg_reg
argument_list|)
expr_stmt|;
name|autoneg_reg
operator|&=
operator|~
name|IXGBE_MII_100BASE_T_ADVERTISE
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator|&
name|IXGBE_LINK_SPEED_100_FULL
condition|)
name|autoneg_reg
operator||=
name|IXGBE_MII_100BASE_T_ADVERTISE
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MII_AUTONEG_ADVERTISE_REG
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
name|autoneg_reg
argument_list|)
expr_stmt|;
block|}
comment|/* Blocked by MNG FW so don't reset PHY */
if|if
condition|(
name|ixgbe_check_reset_blocked
argument_list|(
name|hw
argument_list|)
condition|)
return|return
name|status
return|;
comment|/* Restart PHY auto-negotiation. */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_CONTROL
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
operator|&
name|autoneg_reg
argument_list|)
expr_stmt|;
name|autoneg_reg
operator||=
name|IXGBE_MII_RESTART
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_CONTROL
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
name|autoneg_reg
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_phy_firmware_version_tnx - Gets the PHY Firmware Version  *  @hw: pointer to hardware structure  *  @firmware_version: pointer to the PHY Firmware Version  **/
end_comment

begin_function
name|s32
name|ixgbe_get_phy_firmware_version_tnx
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|firmware_version
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_phy_firmware_version_tnx"
argument_list|)
expr_stmt|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|TNX_FW_REV
argument_list|,
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE
argument_list|,
name|firmware_version
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_phy_firmware_version_generic - Gets the PHY Firmware Version  *  @hw: pointer to hardware structure  *  @firmware_version: pointer to the PHY Firmware Version  **/
end_comment

begin_function
name|s32
name|ixgbe_get_phy_firmware_version_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|firmware_version
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_phy_firmware_version_generic"
argument_list|)
expr_stmt|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|AQ_FW_REV
argument_list|,
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE
argument_list|,
name|firmware_version
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_reset_phy_nl - Performs a PHY reset  *  @hw: pointer to hardware structure  **/
end_comment

begin_function
name|s32
name|ixgbe_reset_phy_nl
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u16
name|phy_offset
decl_stmt|,
name|control
decl_stmt|,
name|eword
decl_stmt|,
name|edata
decl_stmt|,
name|block_crc
decl_stmt|;
name|bool
name|end_data
init|=
name|FALSE
decl_stmt|;
name|u16
name|list_offset
decl_stmt|,
name|data_offset
decl_stmt|;
name|u16
name|phy_data
init|=
literal|0
decl_stmt|;
name|s32
name|ret_val
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_reset_phy_nl"
argument_list|)
expr_stmt|;
comment|/* Blocked by MNG FW so bail */
if|if
condition|(
name|ixgbe_check_reset_blocked
argument_list|(
name|hw
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_PHY_XS_CONTROL
argument_list|,
name|IXGBE_MDIO_PHY_XS_DEV_TYPE
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
comment|/* reset the PHY and poll for completion */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_PHY_XS_CONTROL
argument_list|,
name|IXGBE_MDIO_PHY_XS_DEV_TYPE
argument_list|,
operator|(
name|phy_data
operator||
name|IXGBE_MDIO_PHY_XS_RESET
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_PHY_XS_CONTROL
argument_list|,
name|IXGBE_MDIO_PHY_XS_DEV_TYPE
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|phy_data
operator|&
name|IXGBE_MDIO_PHY_XS_RESET
operator|)
operator|==
literal|0
condition|)
break|break;
name|msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|phy_data
operator|&
name|IXGBE_MDIO_PHY_XS_RESET
operator|)
operator|!=
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PHY reset did not complete.\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|IXGBE_ERR_PHY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Get init offsets */
name|ret_val
operator|=
name|ixgbe_get_sfp_init_sequence_offsets
argument_list|(
name|hw
argument_list|,
operator|&
name|list_offset
argument_list|,
operator|&
name|data_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|data_offset
argument_list|,
operator|&
name|block_crc
argument_list|)
expr_stmt|;
name|data_offset
operator|++
expr_stmt|;
while|while
condition|(
operator|!
name|end_data
condition|)
block|{
comment|/* 		 * Read control word from PHY init contents offset 		 */
name|ret_val
operator|=
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|data_offset
argument_list|,
operator|&
name|eword
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|err_eeprom
goto|;
name|control
operator|=
operator|(
name|eword
operator|&
name|IXGBE_CONTROL_MASK_NL
operator|)
operator|>>
name|IXGBE_CONTROL_SHIFT_NL
expr_stmt|;
name|edata
operator|=
name|eword
operator|&
name|IXGBE_DATA_MASK_NL
expr_stmt|;
switch|switch
condition|(
name|control
condition|)
block|{
case|case
name|IXGBE_DELAY_NL
case|:
name|data_offset
operator|++
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"DELAY: %d MS\n"
argument_list|,
name|edata
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
name|edata
argument_list|)
expr_stmt|;
break|break;
case|case
name|IXGBE_DATA_NL
case|:
name|DEBUGOUT
argument_list|(
literal|"DATA:\n"
argument_list|)
expr_stmt|;
name|data_offset
operator|++
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|data_offset
argument_list|,
operator|&
name|phy_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|err_eeprom
goto|;
name|data_offset
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|edata
condition|;
name|i
operator|++
control|)
block|{
name|ret_val
operator|=
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|data_offset
argument_list|,
operator|&
name|eword
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|err_eeprom
goto|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|phy_offset
argument_list|,
name|IXGBE_TWINAX_DEV
argument_list|,
name|eword
argument_list|)
expr_stmt|;
name|DEBUGOUT2
argument_list|(
literal|"Wrote %4.4x to %4.4x\n"
argument_list|,
name|eword
argument_list|,
name|phy_offset
argument_list|)
expr_stmt|;
name|data_offset
operator|++
expr_stmt|;
name|phy_offset
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|IXGBE_CONTROL_NL
case|:
name|data_offset
operator|++
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"CONTROL:\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|edata
operator|==
name|IXGBE_CONTROL_EOL_NL
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"EOL\n"
argument_list|)
expr_stmt|;
name|end_data
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|edata
operator|==
name|IXGBE_CONTROL_SOL_NL
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"SOL\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"Bad control value\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|IXGBE_ERR_PHY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
break|break;
default|default:
name|DEBUGOUT
argument_list|(
literal|"Bad control type\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|IXGBE_ERR_PHY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|out
label|:
return|return
name|ret_val
return|;
name|err_eeprom
label|:
name|ERROR_REPORT2
argument_list|(
name|IXGBE_ERROR_INVALID_STATE
argument_list|,
literal|"eeprom read at offset %d failed"
argument_list|,
name|data_offset
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_PHY
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_identify_module_generic - Identifies module type  *  @hw: pointer to hardware structure  *  *  Determines HW type and calls appropriate function.  **/
end_comment

begin_function
name|s32
name|ixgbe_identify_module_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_ERR_SFP_NOT_PRESENT
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_identify_module_generic"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|get_media_type
argument_list|(
name|hw
argument_list|)
condition|)
block|{
case|case
name|ixgbe_media_type_fiber
case|:
name|status
operator|=
name|ixgbe_identify_sfp_module_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
break|break;
case|case
name|ixgbe_media_type_fiber_qsfp
case|:
name|status
operator|=
name|ixgbe_identify_qsfp_module_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
break|break;
default|default:
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|=
name|ixgbe_sfp_type_not_present
expr_stmt|;
name|status
operator|=
name|IXGBE_ERR_SFP_NOT_PRESENT
expr_stmt|;
break|break;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_identify_sfp_module_generic - Identifies SFP modules  *  @hw: pointer to hardware structure  *  *  Searches for and identifies the SFP module and assigns appropriate PHY type.  **/
end_comment

begin_function
name|s32
name|ixgbe_identify_sfp_module_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_ERR_PHY_ADDR_INVALID
decl_stmt|;
name|u32
name|vendor_oui
init|=
literal|0
decl_stmt|;
name|enum
name|ixgbe_sfp_type
name|stored_sfp_type
init|=
name|hw
operator|->
name|phy
operator|.
name|sfp_type
decl_stmt|;
name|u8
name|identifier
init|=
literal|0
decl_stmt|;
name|u8
name|comp_codes_1g
init|=
literal|0
decl_stmt|;
name|u8
name|comp_codes_10g
init|=
literal|0
decl_stmt|;
name|u8
name|oui_bytes
index|[
literal|3
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|u8
name|cable_tech
init|=
literal|0
decl_stmt|;
name|u8
name|cable_spec
init|=
literal|0
decl_stmt|;
name|u16
name|enforce_sfp
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_identify_sfp_module_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|get_media_type
argument_list|(
name|hw
argument_list|)
operator|!=
name|ixgbe_media_type_fiber
condition|)
block|{
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|=
name|ixgbe_sfp_type_not_present
expr_stmt|;
name|status
operator|=
name|IXGBE_ERR_SFP_NOT_PRESENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* LAN ID is needed for I2C access */
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|set_lan_id
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_i2c_eeprom
argument_list|(
name|hw
argument_list|,
name|IXGBE_SFF_IDENTIFIER
argument_list|,
operator|&
name|identifier
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|err_read_i2c_eeprom
goto|;
if|if
condition|(
name|identifier
operator|!=
name|IXGBE_SFF_IDENTIFIER_SFP
condition|)
block|{
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|ixgbe_phy_sfp_unsupported
expr_stmt|;
name|status
operator|=
name|IXGBE_ERR_SFP_NOT_SUPPORTED
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_i2c_eeprom
argument_list|(
name|hw
argument_list|,
name|IXGBE_SFF_1GBE_COMP_CODES
argument_list|,
operator|&
name|comp_codes_1g
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|err_read_i2c_eeprom
goto|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_i2c_eeprom
argument_list|(
name|hw
argument_list|,
name|IXGBE_SFF_10GBE_COMP_CODES
argument_list|,
operator|&
name|comp_codes_10g
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|err_read_i2c_eeprom
goto|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_i2c_eeprom
argument_list|(
name|hw
argument_list|,
name|IXGBE_SFF_CABLE_TECHNOLOGY
argument_list|,
operator|&
name|cable_tech
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|err_read_i2c_eeprom
goto|;
comment|/* ID Module 		  * ========= 		  * 0   SFP_DA_CU 		  * 1   SFP_SR 		  * 2   SFP_LR 		  * 3   SFP_DA_CORE0 - 82599-specific 		  * 4   SFP_DA_CORE1 - 82599-specific 		  * 5   SFP_SR/LR_CORE0 - 82599-specific 		  * 6   SFP_SR/LR_CORE1 - 82599-specific 		  * 7   SFP_act_lmt_DA_CORE0 - 82599-specific 		  * 8   SFP_act_lmt_DA_CORE1 - 82599-specific 		  * 9   SFP_1g_cu_CORE0 - 82599-specific 		  * 10  SFP_1g_cu_CORE1 - 82599-specific 		  * 11  SFP_1g_sx_CORE0 - 82599-specific 		  * 12  SFP_1g_sx_CORE1 - 82599-specific 		  */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_82598EB
condition|)
block|{
if|if
condition|(
name|cable_tech
operator|&
name|IXGBE_SFF_DA_PASSIVE_CABLE
condition|)
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|=
name|ixgbe_sfp_type_da_cu
expr_stmt|;
elseif|else
if|if
condition|(
name|comp_codes_10g
operator|&
name|IXGBE_SFF_10GBASESR_CAPABLE
condition|)
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|=
name|ixgbe_sfp_type_sr
expr_stmt|;
elseif|else
if|if
condition|(
name|comp_codes_10g
operator|&
name|IXGBE_SFF_10GBASELR_CAPABLE
condition|)
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|=
name|ixgbe_sfp_type_lr
expr_stmt|;
else|else
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|=
name|ixgbe_sfp_type_unknown
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cable_tech
operator|&
name|IXGBE_SFF_DA_PASSIVE_CABLE
condition|)
block|{
if|if
condition|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
operator|==
literal|0
condition|)
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|=
name|ixgbe_sfp_type_da_cu_core0
expr_stmt|;
else|else
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|=
name|ixgbe_sfp_type_da_cu_core1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cable_tech
operator|&
name|IXGBE_SFF_DA_ACTIVE_CABLE
condition|)
block|{
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_i2c_eeprom
argument_list|(
name|hw
argument_list|,
name|IXGBE_SFF_CABLE_SPEC_COMP
argument_list|,
operator|&
name|cable_spec
argument_list|)
expr_stmt|;
if|if
condition|(
name|cable_spec
operator|&
name|IXGBE_SFF_DA_SPEC_ACTIVE_LIMITING
condition|)
block|{
if|if
condition|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
operator|==
literal|0
condition|)
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|=
name|ixgbe_sfp_type_da_act_lmt_core0
expr_stmt|;
else|else
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|=
name|ixgbe_sfp_type_da_act_lmt_core1
expr_stmt|;
block|}
else|else
block|{
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|=
name|ixgbe_sfp_type_unknown
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|comp_codes_10g
operator|&
operator|(
name|IXGBE_SFF_10GBASESR_CAPABLE
operator||
name|IXGBE_SFF_10GBASELR_CAPABLE
operator|)
condition|)
block|{
if|if
condition|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
operator|==
literal|0
condition|)
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|=
name|ixgbe_sfp_type_srlr_core0
expr_stmt|;
else|else
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|=
name|ixgbe_sfp_type_srlr_core1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|comp_codes_1g
operator|&
name|IXGBE_SFF_1GBASET_CAPABLE
condition|)
block|{
if|if
condition|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
operator|==
literal|0
condition|)
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|=
name|ixgbe_sfp_type_1g_cu_core0
expr_stmt|;
else|else
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|=
name|ixgbe_sfp_type_1g_cu_core1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|comp_codes_1g
operator|&
name|IXGBE_SFF_1GBASESX_CAPABLE
condition|)
block|{
if|if
condition|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
operator|==
literal|0
condition|)
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|=
name|ixgbe_sfp_type_1g_sx_core0
expr_stmt|;
else|else
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|=
name|ixgbe_sfp_type_1g_sx_core1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|comp_codes_1g
operator|&
name|IXGBE_SFF_1GBASELX_CAPABLE
condition|)
block|{
if|if
condition|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
operator|==
literal|0
condition|)
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|=
name|ixgbe_sfp_type_1g_lx_core0
expr_stmt|;
else|else
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|=
name|ixgbe_sfp_type_1g_lx_core1
expr_stmt|;
block|}
else|else
block|{
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|=
name|ixgbe_sfp_type_unknown
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|!=
name|stored_sfp_type
condition|)
name|hw
operator|->
name|phy
operator|.
name|sfp_setup_needed
operator|=
name|TRUE
expr_stmt|;
comment|/* Determine if the SFP+ PHY is dual speed or not. */
name|hw
operator|->
name|phy
operator|.
name|multispeed_fiber
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|comp_codes_1g
operator|&
name|IXGBE_SFF_1GBASESX_CAPABLE
operator|)
operator|&&
operator|(
name|comp_codes_10g
operator|&
name|IXGBE_SFF_10GBASESR_CAPABLE
operator|)
operator|)
operator|||
operator|(
operator|(
name|comp_codes_1g
operator|&
name|IXGBE_SFF_1GBASELX_CAPABLE
operator|)
operator|&&
operator|(
name|comp_codes_10g
operator|&
name|IXGBE_SFF_10GBASELR_CAPABLE
operator|)
operator|)
condition|)
name|hw
operator|->
name|phy
operator|.
name|multispeed_fiber
operator|=
name|TRUE
expr_stmt|;
comment|/* Determine PHY vendor */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|!=
name|ixgbe_phy_nl
condition|)
block|{
name|hw
operator|->
name|phy
operator|.
name|id
operator|=
name|identifier
expr_stmt|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_i2c_eeprom
argument_list|(
name|hw
argument_list|,
name|IXGBE_SFF_VENDOR_OUI_BYTE0
argument_list|,
operator|&
name|oui_bytes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|err_read_i2c_eeprom
goto|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_i2c_eeprom
argument_list|(
name|hw
argument_list|,
name|IXGBE_SFF_VENDOR_OUI_BYTE1
argument_list|,
operator|&
name|oui_bytes
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|err_read_i2c_eeprom
goto|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_i2c_eeprom
argument_list|(
name|hw
argument_list|,
name|IXGBE_SFF_VENDOR_OUI_BYTE2
argument_list|,
operator|&
name|oui_bytes
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|err_read_i2c_eeprom
goto|;
name|vendor_oui
operator|=
operator|(
operator|(
name|oui_bytes
index|[
literal|0
index|]
operator|<<
name|IXGBE_SFF_VENDOR_OUI_BYTE0_SHIFT
operator|)
operator||
operator|(
name|oui_bytes
index|[
literal|1
index|]
operator|<<
name|IXGBE_SFF_VENDOR_OUI_BYTE1_SHIFT
operator|)
operator||
operator|(
name|oui_bytes
index|[
literal|2
index|]
operator|<<
name|IXGBE_SFF_VENDOR_OUI_BYTE2_SHIFT
operator|)
operator|)
expr_stmt|;
switch|switch
condition|(
name|vendor_oui
condition|)
block|{
case|case
name|IXGBE_SFF_VENDOR_OUI_TYCO
case|:
if|if
condition|(
name|cable_tech
operator|&
name|IXGBE_SFF_DA_PASSIVE_CABLE
condition|)
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|ixgbe_phy_sfp_passive_tyco
expr_stmt|;
break|break;
case|case
name|IXGBE_SFF_VENDOR_OUI_FTL
case|:
if|if
condition|(
name|cable_tech
operator|&
name|IXGBE_SFF_DA_ACTIVE_CABLE
condition|)
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|ixgbe_phy_sfp_ftl_active
expr_stmt|;
else|else
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|ixgbe_phy_sfp_ftl
expr_stmt|;
break|break;
case|case
name|IXGBE_SFF_VENDOR_OUI_AVAGO
case|:
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|ixgbe_phy_sfp_avago
expr_stmt|;
break|break;
case|case
name|IXGBE_SFF_VENDOR_OUI_INTEL
case|:
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|ixgbe_phy_sfp_intel
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|cable_tech
operator|&
name|IXGBE_SFF_DA_PASSIVE_CABLE
condition|)
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|ixgbe_phy_sfp_passive_unknown
expr_stmt|;
elseif|else
if|if
condition|(
name|cable_tech
operator|&
name|IXGBE_SFF_DA_ACTIVE_CABLE
condition|)
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|ixgbe_phy_sfp_active_unknown
expr_stmt|;
else|else
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|ixgbe_phy_sfp_unknown
expr_stmt|;
break|break;
block|}
block|}
comment|/* Allow any DA cable vendor */
if|if
condition|(
name|cable_tech
operator|&
operator|(
name|IXGBE_SFF_DA_PASSIVE_CABLE
operator||
name|IXGBE_SFF_DA_ACTIVE_CABLE
operator|)
condition|)
block|{
name|status
operator|=
name|IXGBE_SUCCESS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Verify supported 1G SFP modules */
if|if
condition|(
name|comp_codes_10g
operator|==
literal|0
operator|&&
operator|!
operator|(
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|==
name|ixgbe_sfp_type_1g_cu_core1
operator|||
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|==
name|ixgbe_sfp_type_1g_cu_core0
operator|||
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|==
name|ixgbe_sfp_type_1g_lx_core0
operator|||
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|==
name|ixgbe_sfp_type_1g_lx_core1
operator|||
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|==
name|ixgbe_sfp_type_1g_sx_core0
operator|||
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|==
name|ixgbe_sfp_type_1g_sx_core1
operator|)
condition|)
block|{
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|ixgbe_phy_sfp_unsupported
expr_stmt|;
name|status
operator|=
name|IXGBE_ERR_SFP_NOT_SUPPORTED
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Anything else 82598-based is supported */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_82598EB
condition|)
block|{
name|status
operator|=
name|IXGBE_SUCCESS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ixgbe_get_device_caps
argument_list|(
name|hw
argument_list|,
operator|&
name|enforce_sfp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|enforce_sfp
operator|&
name|IXGBE_DEVICE_CAPS_ALLOW_ANY_SFP
operator|)
operator|&&
operator|!
operator|(
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|==
name|ixgbe_sfp_type_1g_cu_core0
operator|||
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|==
name|ixgbe_sfp_type_1g_cu_core1
operator|||
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|==
name|ixgbe_sfp_type_1g_lx_core0
operator|||
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|==
name|ixgbe_sfp_type_1g_lx_core1
operator|||
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|==
name|ixgbe_sfp_type_1g_sx_core0
operator|||
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|==
name|ixgbe_sfp_type_1g_sx_core1
operator|)
condition|)
block|{
comment|/* Make sure we're a supported PHY type */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|ixgbe_phy_sfp_intel
condition|)
block|{
name|status
operator|=
name|IXGBE_SUCCESS
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|hw
operator|->
name|allow_unsupported_sfp
operator|==
name|TRUE
condition|)
block|{
name|EWARN
argument_list|(
name|hw
argument_list|,
literal|"WARNING: Intel (R) Network Connections are quality tested using Intel (R) Ethernet Optics. Using untested modules is not supported and may cause unstable operation or damage to the module or the adapter. Intel Corporation is not responsible for any harm caused by using untested modules.\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IXGBE_SUCCESS
expr_stmt|;
block|}
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"SFP+ module not supported\n"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|ixgbe_phy_sfp_unsupported
expr_stmt|;
name|status
operator|=
name|IXGBE_ERR_SFP_NOT_SUPPORTED
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|status
operator|=
name|IXGBE_SUCCESS
expr_stmt|;
block|}
block|}
name|out
label|:
return|return
name|status
return|;
name|err_read_i2c_eeprom
label|:
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|=
name|ixgbe_sfp_type_not_present
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|!=
name|ixgbe_phy_nl
condition|)
block|{
name|hw
operator|->
name|phy
operator|.
name|id
operator|=
literal|0
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|ixgbe_phy_unknown
expr_stmt|;
block|}
return|return
name|IXGBE_ERR_SFP_NOT_PRESENT
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_supported_phy_sfp_layer_generic - Returns physical layer type  *  @hw: pointer to hardware structure  *  *  Determines physical layer capabilities of the current SFP.  */
end_comment

begin_function
name|u64
name|ixgbe_get_supported_phy_sfp_layer_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u64
name|physical_layer
init|=
name|IXGBE_PHYSICAL_LAYER_UNKNOWN
decl_stmt|;
name|u8
name|comp_codes_10g
init|=
literal|0
decl_stmt|;
name|u8
name|comp_codes_1g
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_supported_phy_sfp_layer_generic"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|identify_sfp
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|==
name|ixgbe_sfp_type_not_present
condition|)
return|return
name|physical_layer
return|;
switch|switch
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
condition|)
block|{
case|case
name|ixgbe_phy_sfp_passive_tyco
case|:
case|case
name|ixgbe_phy_sfp_passive_unknown
case|:
case|case
name|ixgbe_phy_qsfp_passive_unknown
case|:
name|physical_layer
operator|=
name|IXGBE_PHYSICAL_LAYER_SFP_PLUS_CU
expr_stmt|;
break|break;
case|case
name|ixgbe_phy_sfp_ftl_active
case|:
case|case
name|ixgbe_phy_sfp_active_unknown
case|:
case|case
name|ixgbe_phy_qsfp_active_unknown
case|:
name|physical_layer
operator|=
name|IXGBE_PHYSICAL_LAYER_SFP_ACTIVE_DA
expr_stmt|;
break|break;
case|case
name|ixgbe_phy_sfp_avago
case|:
case|case
name|ixgbe_phy_sfp_ftl
case|:
case|case
name|ixgbe_phy_sfp_intel
case|:
case|case
name|ixgbe_phy_sfp_unknown
case|:
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_i2c_eeprom
argument_list|(
name|hw
argument_list|,
name|IXGBE_SFF_1GBE_COMP_CODES
argument_list|,
operator|&
name|comp_codes_1g
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_i2c_eeprom
argument_list|(
name|hw
argument_list|,
name|IXGBE_SFF_10GBE_COMP_CODES
argument_list|,
operator|&
name|comp_codes_10g
argument_list|)
expr_stmt|;
if|if
condition|(
name|comp_codes_10g
operator|&
name|IXGBE_SFF_10GBASESR_CAPABLE
condition|)
name|physical_layer
operator|=
name|IXGBE_PHYSICAL_LAYER_10GBASE_SR
expr_stmt|;
elseif|else
if|if
condition|(
name|comp_codes_10g
operator|&
name|IXGBE_SFF_10GBASELR_CAPABLE
condition|)
name|physical_layer
operator|=
name|IXGBE_PHYSICAL_LAYER_10GBASE_LR
expr_stmt|;
elseif|else
if|if
condition|(
name|comp_codes_1g
operator|&
name|IXGBE_SFF_1GBASET_CAPABLE
condition|)
name|physical_layer
operator|=
name|IXGBE_PHYSICAL_LAYER_1000BASE_T
expr_stmt|;
elseif|else
if|if
condition|(
name|comp_codes_1g
operator|&
name|IXGBE_SFF_1GBASESX_CAPABLE
condition|)
name|physical_layer
operator|=
name|IXGBE_PHYSICAL_LAYER_1000BASE_SX
expr_stmt|;
break|break;
case|case
name|ixgbe_phy_qsfp_intel
case|:
case|case
name|ixgbe_phy_qsfp_unknown
case|:
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_i2c_eeprom
argument_list|(
name|hw
argument_list|,
name|IXGBE_SFF_QSFP_10GBE_COMP
argument_list|,
operator|&
name|comp_codes_10g
argument_list|)
expr_stmt|;
if|if
condition|(
name|comp_codes_10g
operator|&
name|IXGBE_SFF_10GBASESR_CAPABLE
condition|)
name|physical_layer
operator|=
name|IXGBE_PHYSICAL_LAYER_10GBASE_SR
expr_stmt|;
elseif|else
if|if
condition|(
name|comp_codes_10g
operator|&
name|IXGBE_SFF_10GBASELR_CAPABLE
condition|)
name|physical_layer
operator|=
name|IXGBE_PHYSICAL_LAYER_10GBASE_LR
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|physical_layer
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_identify_qsfp_module_generic - Identifies QSFP modules  *  @hw: pointer to hardware structure  *  *  Searches for and identifies the QSFP module and assigns appropriate PHY type  **/
end_comment

begin_function
name|s32
name|ixgbe_identify_qsfp_module_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_ERR_PHY_ADDR_INVALID
decl_stmt|;
name|u32
name|vendor_oui
init|=
literal|0
decl_stmt|;
name|enum
name|ixgbe_sfp_type
name|stored_sfp_type
init|=
name|hw
operator|->
name|phy
operator|.
name|sfp_type
decl_stmt|;
name|u8
name|identifier
init|=
literal|0
decl_stmt|;
name|u8
name|comp_codes_1g
init|=
literal|0
decl_stmt|;
name|u8
name|comp_codes_10g
init|=
literal|0
decl_stmt|;
name|u8
name|oui_bytes
index|[
literal|3
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|u16
name|enforce_sfp
init|=
literal|0
decl_stmt|;
name|u8
name|connector
init|=
literal|0
decl_stmt|;
name|u8
name|cable_length
init|=
literal|0
decl_stmt|;
name|u8
name|device_tech
init|=
literal|0
decl_stmt|;
name|bool
name|active_cable
init|=
name|FALSE
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_identify_qsfp_module_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|get_media_type
argument_list|(
name|hw
argument_list|)
operator|!=
name|ixgbe_media_type_fiber_qsfp
condition|)
block|{
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|=
name|ixgbe_sfp_type_not_present
expr_stmt|;
name|status
operator|=
name|IXGBE_ERR_SFP_NOT_PRESENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* LAN ID is needed for I2C access */
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|set_lan_id
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_i2c_eeprom
argument_list|(
name|hw
argument_list|,
name|IXGBE_SFF_IDENTIFIER
argument_list|,
operator|&
name|identifier
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|err_read_i2c_eeprom
goto|;
if|if
condition|(
name|identifier
operator|!=
name|IXGBE_SFF_IDENTIFIER_QSFP_PLUS
condition|)
block|{
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|ixgbe_phy_sfp_unsupported
expr_stmt|;
name|status
operator|=
name|IXGBE_ERR_SFP_NOT_SUPPORTED
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|hw
operator|->
name|phy
operator|.
name|id
operator|=
name|identifier
expr_stmt|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_i2c_eeprom
argument_list|(
name|hw
argument_list|,
name|IXGBE_SFF_QSFP_10GBE_COMP
argument_list|,
operator|&
name|comp_codes_10g
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|err_read_i2c_eeprom
goto|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_i2c_eeprom
argument_list|(
name|hw
argument_list|,
name|IXGBE_SFF_QSFP_1GBE_COMP
argument_list|,
operator|&
name|comp_codes_1g
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|err_read_i2c_eeprom
goto|;
if|if
condition|(
name|comp_codes_10g
operator|&
name|IXGBE_SFF_QSFP_DA_PASSIVE_CABLE
condition|)
block|{
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|ixgbe_phy_qsfp_passive_unknown
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
operator|==
literal|0
condition|)
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|=
name|ixgbe_sfp_type_da_cu_core0
expr_stmt|;
else|else
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|=
name|ixgbe_sfp_type_da_cu_core1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|comp_codes_10g
operator|&
operator|(
name|IXGBE_SFF_10GBASESR_CAPABLE
operator||
name|IXGBE_SFF_10GBASELR_CAPABLE
operator|)
condition|)
block|{
if|if
condition|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
operator|==
literal|0
condition|)
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|=
name|ixgbe_sfp_type_srlr_core0
expr_stmt|;
else|else
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|=
name|ixgbe_sfp_type_srlr_core1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|comp_codes_10g
operator|&
name|IXGBE_SFF_QSFP_DA_ACTIVE_CABLE
condition|)
name|active_cable
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|active_cable
condition|)
block|{
comment|/* check for active DA cables that pre-date 			 * SFF-8436 v3.6 */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_i2c_eeprom
argument_list|(
name|hw
argument_list|,
name|IXGBE_SFF_QSFP_CONNECTOR
argument_list|,
operator|&
name|connector
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_i2c_eeprom
argument_list|(
name|hw
argument_list|,
name|IXGBE_SFF_QSFP_CABLE_LENGTH
argument_list|,
operator|&
name|cable_length
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_i2c_eeprom
argument_list|(
name|hw
argument_list|,
name|IXGBE_SFF_QSFP_DEVICE_TECH
argument_list|,
operator|&
name|device_tech
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|connector
operator|==
name|IXGBE_SFF_QSFP_CONNECTOR_NOT_SEPARABLE
operator|)
operator|&&
operator|(
name|cable_length
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|(
name|device_tech
operator|>>
literal|4
operator|)
operator|==
name|IXGBE_SFF_QSFP_TRANSMITER_850NM_VCSEL
operator|)
condition|)
name|active_cable
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|active_cable
condition|)
block|{
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|ixgbe_phy_qsfp_active_unknown
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
operator|==
literal|0
condition|)
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|=
name|ixgbe_sfp_type_da_act_lmt_core0
expr_stmt|;
else|else
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|=
name|ixgbe_sfp_type_da_act_lmt_core1
expr_stmt|;
block|}
else|else
block|{
comment|/* unsupported module type */
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|ixgbe_phy_sfp_unsupported
expr_stmt|;
name|status
operator|=
name|IXGBE_ERR_SFP_NOT_SUPPORTED
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|!=
name|stored_sfp_type
condition|)
name|hw
operator|->
name|phy
operator|.
name|sfp_setup_needed
operator|=
name|TRUE
expr_stmt|;
comment|/* Determine if the QSFP+ PHY is dual speed or not. */
name|hw
operator|->
name|phy
operator|.
name|multispeed_fiber
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|comp_codes_1g
operator|&
name|IXGBE_SFF_1GBASESX_CAPABLE
operator|)
operator|&&
operator|(
name|comp_codes_10g
operator|&
name|IXGBE_SFF_10GBASESR_CAPABLE
operator|)
operator|)
operator|||
operator|(
operator|(
name|comp_codes_1g
operator|&
name|IXGBE_SFF_1GBASELX_CAPABLE
operator|)
operator|&&
operator|(
name|comp_codes_10g
operator|&
name|IXGBE_SFF_10GBASELR_CAPABLE
operator|)
operator|)
condition|)
name|hw
operator|->
name|phy
operator|.
name|multispeed_fiber
operator|=
name|TRUE
expr_stmt|;
comment|/* Determine PHY vendor for optical modules */
if|if
condition|(
name|comp_codes_10g
operator|&
operator|(
name|IXGBE_SFF_10GBASESR_CAPABLE
operator||
name|IXGBE_SFF_10GBASELR_CAPABLE
operator|)
condition|)
block|{
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_i2c_eeprom
argument_list|(
name|hw
argument_list|,
name|IXGBE_SFF_QSFP_VENDOR_OUI_BYTE0
argument_list|,
operator|&
name|oui_bytes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|err_read_i2c_eeprom
goto|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_i2c_eeprom
argument_list|(
name|hw
argument_list|,
name|IXGBE_SFF_QSFP_VENDOR_OUI_BYTE1
argument_list|,
operator|&
name|oui_bytes
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|err_read_i2c_eeprom
goto|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_i2c_eeprom
argument_list|(
name|hw
argument_list|,
name|IXGBE_SFF_QSFP_VENDOR_OUI_BYTE2
argument_list|,
operator|&
name|oui_bytes
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|err_read_i2c_eeprom
goto|;
name|vendor_oui
operator|=
operator|(
operator|(
name|oui_bytes
index|[
literal|0
index|]
operator|<<
name|IXGBE_SFF_VENDOR_OUI_BYTE0_SHIFT
operator|)
operator||
operator|(
name|oui_bytes
index|[
literal|1
index|]
operator|<<
name|IXGBE_SFF_VENDOR_OUI_BYTE1_SHIFT
operator|)
operator||
operator|(
name|oui_bytes
index|[
literal|2
index|]
operator|<<
name|IXGBE_SFF_VENDOR_OUI_BYTE2_SHIFT
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|vendor_oui
operator|==
name|IXGBE_SFF_VENDOR_OUI_INTEL
condition|)
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|ixgbe_phy_qsfp_intel
expr_stmt|;
else|else
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|ixgbe_phy_qsfp_unknown
expr_stmt|;
name|ixgbe_get_device_caps
argument_list|(
name|hw
argument_list|,
operator|&
name|enforce_sfp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|enforce_sfp
operator|&
name|IXGBE_DEVICE_CAPS_ALLOW_ANY_SFP
operator|)
condition|)
block|{
comment|/* Make sure we're a supported PHY type */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|ixgbe_phy_qsfp_intel
condition|)
block|{
name|status
operator|=
name|IXGBE_SUCCESS
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|hw
operator|->
name|allow_unsupported_sfp
operator|==
name|TRUE
condition|)
block|{
name|EWARN
argument_list|(
name|hw
argument_list|,
literal|"WARNING: Intel (R) Network Connections are quality tested using Intel (R) Ethernet Optics. Using untested modules is not supported and may cause unstable operation or damage to the module or the adapter. Intel Corporation is not responsible for any harm caused by using untested modules.\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IXGBE_SUCCESS
expr_stmt|;
block|}
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"QSFP module not supported\n"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|ixgbe_phy_sfp_unsupported
expr_stmt|;
name|status
operator|=
name|IXGBE_ERR_SFP_NOT_SUPPORTED
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|status
operator|=
name|IXGBE_SUCCESS
expr_stmt|;
block|}
block|}
name|out
label|:
return|return
name|status
return|;
name|err_read_i2c_eeprom
label|:
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|=
name|ixgbe_sfp_type_not_present
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|id
operator|=
literal|0
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|ixgbe_phy_unknown
expr_stmt|;
return|return
name|IXGBE_ERR_SFP_NOT_PRESENT
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_sfp_init_sequence_offsets - Provides offset of PHY init sequence  *  @hw: pointer to hardware structure  *  @list_offset: offset to the SFP ID list  *  @data_offset: offset to the SFP data block  *  *  Checks the MAC's EEPROM to see if it supports a given SFP+ module type, if  *  so it returns the offsets to the phy init sequence block.  **/
end_comment

begin_function
name|s32
name|ixgbe_get_sfp_init_sequence_offsets
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|list_offset
parameter_list|,
name|u16
modifier|*
name|data_offset
parameter_list|)
block|{
name|u16
name|sfp_id
decl_stmt|;
name|u16
name|sfp_type
init|=
name|hw
operator|->
name|phy
operator|.
name|sfp_type
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_sfp_init_sequence_offsets"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|==
name|ixgbe_sfp_type_unknown
condition|)
return|return
name|IXGBE_ERR_SFP_NOT_SUPPORTED
return|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|==
name|ixgbe_sfp_type_not_present
condition|)
return|return
name|IXGBE_ERR_SFP_NOT_PRESENT
return|;
if|if
condition|(
operator|(
name|hw
operator|->
name|device_id
operator|==
name|IXGBE_DEV_ID_82598_SR_DUAL_PORT_EM
operator|)
operator|&&
operator|(
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|==
name|ixgbe_sfp_type_da_cu
operator|)
condition|)
return|return
name|IXGBE_ERR_SFP_NOT_SUPPORTED
return|;
comment|/* 	 * Limiting active cables and 1G Phys must be initialized as 	 * SR modules 	 */
if|if
condition|(
name|sfp_type
operator|==
name|ixgbe_sfp_type_da_act_lmt_core0
operator|||
name|sfp_type
operator|==
name|ixgbe_sfp_type_1g_lx_core0
operator|||
name|sfp_type
operator|==
name|ixgbe_sfp_type_1g_cu_core0
operator|||
name|sfp_type
operator|==
name|ixgbe_sfp_type_1g_sx_core0
condition|)
name|sfp_type
operator|=
name|ixgbe_sfp_type_srlr_core0
expr_stmt|;
elseif|else
if|if
condition|(
name|sfp_type
operator|==
name|ixgbe_sfp_type_da_act_lmt_core1
operator|||
name|sfp_type
operator|==
name|ixgbe_sfp_type_1g_lx_core1
operator|||
name|sfp_type
operator|==
name|ixgbe_sfp_type_1g_cu_core1
operator|||
name|sfp_type
operator|==
name|ixgbe_sfp_type_1g_sx_core1
condition|)
name|sfp_type
operator|=
name|ixgbe_sfp_type_srlr_core1
expr_stmt|;
comment|/* Read offset to PHY init contents */
if|if
condition|(
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|IXGBE_PHY_INIT_OFFSET_NL
argument_list|,
name|list_offset
argument_list|)
condition|)
block|{
name|ERROR_REPORT2
argument_list|(
name|IXGBE_ERROR_INVALID_STATE
argument_list|,
literal|"eeprom read at offset %d failed"
argument_list|,
name|IXGBE_PHY_INIT_OFFSET_NL
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_SFP_NO_INIT_SEQ_PRESENT
return|;
block|}
if|if
condition|(
operator|(
operator|!
operator|*
name|list_offset
operator|)
operator|||
operator|(
operator|*
name|list_offset
operator|==
literal|0xFFFF
operator|)
condition|)
return|return
name|IXGBE_ERR_SFP_NO_INIT_SEQ_PRESENT
return|;
comment|/* Shift offset to first ID word */
operator|(
operator|*
name|list_offset
operator|)
operator|++
expr_stmt|;
comment|/* 	 * Find the matching SFP ID in the EEPROM 	 * and program the init sequence 	 */
if|if
condition|(
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
operator|*
name|list_offset
argument_list|,
operator|&
name|sfp_id
argument_list|)
condition|)
goto|goto
name|err_phy
goto|;
while|while
condition|(
name|sfp_id
operator|!=
name|IXGBE_PHY_INIT_END_NL
condition|)
block|{
if|if
condition|(
name|sfp_id
operator|==
name|sfp_type
condition|)
block|{
operator|(
operator|*
name|list_offset
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
operator|*
name|list_offset
argument_list|,
name|data_offset
argument_list|)
condition|)
goto|goto
name|err_phy
goto|;
if|if
condition|(
operator|(
operator|!
operator|*
name|data_offset
operator|)
operator|||
operator|(
operator|*
name|data_offset
operator|==
literal|0xFFFF
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"SFP+ module not supported\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_SFP_NOT_SUPPORTED
return|;
block|}
else|else
block|{
break|break;
block|}
block|}
else|else
block|{
operator|(
operator|*
name|list_offset
operator|)
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
operator|*
name|list_offset
argument_list|,
operator|&
name|sfp_id
argument_list|)
condition|)
goto|goto
name|err_phy
goto|;
block|}
block|}
if|if
condition|(
name|sfp_id
operator|==
name|IXGBE_PHY_INIT_END_NL
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"No matching SFP+ module found\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_SFP_NOT_SUPPORTED
return|;
block|}
return|return
name|IXGBE_SUCCESS
return|;
name|err_phy
label|:
name|ERROR_REPORT2
argument_list|(
name|IXGBE_ERROR_INVALID_STATE
argument_list|,
literal|"eeprom read at offset %d failed"
argument_list|,
operator|*
name|list_offset
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_PHY
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_read_i2c_eeprom_generic - Reads 8 bit EEPROM word over I2C interface  *  @hw: pointer to hardware structure  *  @byte_offset: EEPROM byte offset to read  *  @eeprom_data: value read  *  *  Performs byte read operation to SFP module's EEPROM over I2C interface.  **/
end_comment

begin_function
name|s32
name|ixgbe_read_i2c_eeprom_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|byte_offset
parameter_list|,
name|u8
modifier|*
name|eeprom_data
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_read_i2c_eeprom_generic"
argument_list|)
expr_stmt|;
return|return
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_i2c_byte
argument_list|(
name|hw
argument_list|,
name|byte_offset
argument_list|,
name|IXGBE_I2C_EEPROM_DEV_ADDR
argument_list|,
name|eeprom_data
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_read_i2c_sff8472_generic - Reads 8 bit word over I2C interface  *  @hw: pointer to hardware structure  *  @byte_offset: byte offset at address 0xA2  *  @eeprom_data: value read  *  *  Performs byte read operation to SFP module's SFF-8472 data over I2C  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_read_i2c_sff8472_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|byte_offset
parameter_list|,
name|u8
modifier|*
name|sff8472_data
parameter_list|)
block|{
return|return
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_i2c_byte
argument_list|(
name|hw
argument_list|,
name|byte_offset
argument_list|,
name|IXGBE_I2C_EEPROM_DEV_ADDR2
argument_list|,
name|sff8472_data
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_write_i2c_eeprom_generic - Writes 8 bit EEPROM word over I2C interface  *  @hw: pointer to hardware structure  *  @byte_offset: EEPROM byte offset to write  *  @eeprom_data: value to write  *  *  Performs byte write operation to SFP module's EEPROM over I2C interface.  **/
end_comment

begin_function
name|s32
name|ixgbe_write_i2c_eeprom_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|byte_offset
parameter_list|,
name|u8
name|eeprom_data
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_write_i2c_eeprom_generic"
argument_list|)
expr_stmt|;
return|return
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_i2c_byte
argument_list|(
name|hw
argument_list|,
name|byte_offset
argument_list|,
name|IXGBE_I2C_EEPROM_DEV_ADDR
argument_list|,
name|eeprom_data
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_is_sfp_probe - Returns TRUE if SFP is being detected  * @hw: pointer to hardware structure  * @offset: eeprom offset to be read  * @addr: I2C address to be read  */
end_comment

begin_function
specifier|static
name|bool
name|ixgbe_is_sfp_probe
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|offset
parameter_list|,
name|u8
name|addr
parameter_list|)
block|{
if|if
condition|(
name|addr
operator|==
name|IXGBE_I2C_EEPROM_DEV_ADDR
operator|&&
name|offset
operator|==
name|IXGBE_SFF_IDENTIFIER
operator|&&
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|==
name|ixgbe_sfp_type_not_present
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_read_i2c_byte_generic_int - Reads 8 bit word over I2C  *  @hw: pointer to hardware structure  *  @byte_offset: byte offset to read  *  @data: value read  *  @lock: TRUE if to take and release semaphore  *  *  Performs byte read operation to SFP module's EEPROM over I2C interface at  *  a specified device address.  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_read_i2c_byte_generic_int
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|byte_offset
parameter_list|,
name|u8
name|dev_addr
parameter_list|,
name|u8
modifier|*
name|data
parameter_list|,
name|bool
name|lock
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|u32
name|max_retry
init|=
literal|10
decl_stmt|;
name|u32
name|retry
init|=
literal|0
decl_stmt|;
name|u32
name|swfw_mask
init|=
name|hw
operator|->
name|phy
operator|.
name|phy_semaphore_mask
decl_stmt|;
name|bool
name|nack
init|=
literal|1
decl_stmt|;
operator|*
name|data
operator|=
literal|0
expr_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_read_i2c_byte_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|>=
name|ixgbe_mac_X550
condition|)
name|max_retry
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|ixgbe_is_sfp_probe
argument_list|(
name|hw
argument_list|,
name|byte_offset
argument_list|,
name|dev_addr
argument_list|)
condition|)
name|max_retry
operator|=
name|IXGBE_SFP_DETECT_RETRIES
expr_stmt|;
do|do
block|{
if|if
condition|(
name|lock
operator|&&
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|acquire_swfw_sync
argument_list|(
name|hw
argument_list|,
name|swfw_mask
argument_list|)
condition|)
return|return
name|IXGBE_ERR_SWFW_SYNC
return|;
name|ixgbe_i2c_start
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Device Address and write indication */
name|status
operator|=
name|ixgbe_clock_out_i2c_byte
argument_list|(
name|hw
argument_list|,
name|dev_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|fail
goto|;
name|status
operator|=
name|ixgbe_get_i2c_ack
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|fail
goto|;
name|status
operator|=
name|ixgbe_clock_out_i2c_byte
argument_list|(
name|hw
argument_list|,
name|byte_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|fail
goto|;
name|status
operator|=
name|ixgbe_get_i2c_ack
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|fail
goto|;
name|ixgbe_i2c_start
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Device Address and read indication */
name|status
operator|=
name|ixgbe_clock_out_i2c_byte
argument_list|(
name|hw
argument_list|,
operator|(
name|dev_addr
operator||
literal|0x1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|fail
goto|;
name|status
operator|=
name|ixgbe_get_i2c_ack
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|fail
goto|;
name|status
operator|=
name|ixgbe_clock_in_i2c_byte
argument_list|(
name|hw
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|fail
goto|;
name|status
operator|=
name|ixgbe_clock_out_i2c_bit
argument_list|(
name|hw
argument_list|,
name|nack
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|fail
goto|;
name|ixgbe_i2c_stop
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock
condition|)
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|swfw_mask
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
name|fail
label|:
name|ixgbe_i2c_bus_clear
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock
condition|)
block|{
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|swfw_mask
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
name|retry
operator|++
expr_stmt|;
if|if
condition|(
name|retry
operator|<
name|max_retry
condition|)
name|DEBUGOUT
argument_list|(
literal|"I2C byte read error - Retrying.\n"
argument_list|)
expr_stmt|;
else|else
name|DEBUGOUT
argument_list|(
literal|"I2C byte read error.\n"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|retry
operator|<
name|max_retry
condition|)
do|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_read_i2c_byte_generic - Reads 8 bit word over I2C  *  @hw: pointer to hardware structure  *  @byte_offset: byte offset to read  *  @data: value read  *  *  Performs byte read operation to SFP module's EEPROM over I2C interface at  *  a specified device address.  **/
end_comment

begin_function
name|s32
name|ixgbe_read_i2c_byte_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|byte_offset
parameter_list|,
name|u8
name|dev_addr
parameter_list|,
name|u8
modifier|*
name|data
parameter_list|)
block|{
return|return
name|ixgbe_read_i2c_byte_generic_int
argument_list|(
name|hw
argument_list|,
name|byte_offset
argument_list|,
name|dev_addr
argument_list|,
name|data
argument_list|,
name|TRUE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_read_i2c_byte_generic_unlocked - Reads 8 bit word over I2C  *  @hw: pointer to hardware structure  *  @byte_offset: byte offset to read  *  @data: value read  *  *  Performs byte read operation to SFP module's EEPROM over I2C interface at  *  a specified device address.  **/
end_comment

begin_function
name|s32
name|ixgbe_read_i2c_byte_generic_unlocked
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|byte_offset
parameter_list|,
name|u8
name|dev_addr
parameter_list|,
name|u8
modifier|*
name|data
parameter_list|)
block|{
return|return
name|ixgbe_read_i2c_byte_generic_int
argument_list|(
name|hw
argument_list|,
name|byte_offset
argument_list|,
name|dev_addr
argument_list|,
name|data
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_write_i2c_byte_generic_int - Writes 8 bit word over I2C  *  @hw: pointer to hardware structure  *  @byte_offset: byte offset to write  *  @data: value to write  *  @lock: TRUE if to take and release semaphore  *  *  Performs byte write operation to SFP module's EEPROM over I2C interface at  *  a specified device address.  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_write_i2c_byte_generic_int
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|byte_offset
parameter_list|,
name|u8
name|dev_addr
parameter_list|,
name|u8
name|data
parameter_list|,
name|bool
name|lock
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|u32
name|max_retry
init|=
literal|1
decl_stmt|;
name|u32
name|retry
init|=
literal|0
decl_stmt|;
name|u32
name|swfw_mask
init|=
name|hw
operator|->
name|phy
operator|.
name|phy_semaphore_mask
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_write_i2c_byte_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock
operator|&&
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|acquire_swfw_sync
argument_list|(
name|hw
argument_list|,
name|swfw_mask
argument_list|)
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|IXGBE_ERR_SWFW_SYNC
return|;
do|do
block|{
name|ixgbe_i2c_start
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|status
operator|=
name|ixgbe_clock_out_i2c_byte
argument_list|(
name|hw
argument_list|,
name|dev_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|fail
goto|;
name|status
operator|=
name|ixgbe_get_i2c_ack
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|fail
goto|;
name|status
operator|=
name|ixgbe_clock_out_i2c_byte
argument_list|(
name|hw
argument_list|,
name|byte_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|fail
goto|;
name|status
operator|=
name|ixgbe_get_i2c_ack
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|fail
goto|;
name|status
operator|=
name|ixgbe_clock_out_i2c_byte
argument_list|(
name|hw
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|fail
goto|;
name|status
operator|=
name|ixgbe_get_i2c_ack
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|fail
goto|;
name|ixgbe_i2c_stop
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock
condition|)
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|swfw_mask
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
name|fail
label|:
name|ixgbe_i2c_bus_clear
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|retry
operator|++
expr_stmt|;
if|if
condition|(
name|retry
operator|<
name|max_retry
condition|)
name|DEBUGOUT
argument_list|(
literal|"I2C byte write error - Retrying.\n"
argument_list|)
expr_stmt|;
else|else
name|DEBUGOUT
argument_list|(
literal|"I2C byte write error.\n"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|retry
operator|<
name|max_retry
condition|)
do|;
if|if
condition|(
name|lock
condition|)
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|swfw_mask
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_write_i2c_byte_generic - Writes 8 bit word over I2C  *  @hw: pointer to hardware structure  *  @byte_offset: byte offset to write  *  @data: value to write  *  *  Performs byte write operation to SFP module's EEPROM over I2C interface at  *  a specified device address.  **/
end_comment

begin_function
name|s32
name|ixgbe_write_i2c_byte_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|byte_offset
parameter_list|,
name|u8
name|dev_addr
parameter_list|,
name|u8
name|data
parameter_list|)
block|{
return|return
name|ixgbe_write_i2c_byte_generic_int
argument_list|(
name|hw
argument_list|,
name|byte_offset
argument_list|,
name|dev_addr
argument_list|,
name|data
argument_list|,
name|TRUE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_write_i2c_byte_generic_unlocked - Writes 8 bit word over I2C  *  @hw: pointer to hardware structure  *  @byte_offset: byte offset to write  *  @data: value to write  *  *  Performs byte write operation to SFP module's EEPROM over I2C interface at  *  a specified device address.  **/
end_comment

begin_function
name|s32
name|ixgbe_write_i2c_byte_generic_unlocked
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|byte_offset
parameter_list|,
name|u8
name|dev_addr
parameter_list|,
name|u8
name|data
parameter_list|)
block|{
return|return
name|ixgbe_write_i2c_byte_generic_int
argument_list|(
name|hw
argument_list|,
name|byte_offset
argument_list|,
name|dev_addr
argument_list|,
name|data
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_i2c_start - Sets I2C start condition  *  @hw: pointer to hardware structure  *  *  Sets I2C start condition (High -> Low on SDA while SCL is High)  *  Set bit-bang mode on X550 hardware.  **/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_i2c_start
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|i2cctl
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_I2CCTL_BY_MAC
argument_list|(
name|hw
argument_list|)
argument_list|)
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_i2c_start"
argument_list|)
expr_stmt|;
name|i2cctl
operator||=
name|IXGBE_I2C_BB_EN_BY_MAC
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Start condition must begin with data and clock high */
name|ixgbe_set_i2c_data
argument_list|(
name|hw
argument_list|,
operator|&
name|i2cctl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ixgbe_raise_i2c_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|i2cctl
argument_list|)
expr_stmt|;
comment|/* Setup time for start condition (4.7us) */
name|usec_delay
argument_list|(
name|IXGBE_I2C_T_SU_STA
argument_list|)
expr_stmt|;
name|ixgbe_set_i2c_data
argument_list|(
name|hw
argument_list|,
operator|&
name|i2cctl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Hold time for start condition (4us) */
name|usec_delay
argument_list|(
name|IXGBE_I2C_T_HD_STA
argument_list|)
expr_stmt|;
name|ixgbe_lower_i2c_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|i2cctl
argument_list|)
expr_stmt|;
comment|/* Minimum low period of clock is 4.7 us */
name|usec_delay
argument_list|(
name|IXGBE_I2C_T_LOW
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_i2c_stop - Sets I2C stop condition  *  @hw: pointer to hardware structure  *  *  Sets I2C stop condition (Low -> High on SDA while SCL is High)  *  Disables bit-bang mode and negates data output enable on X550  *  hardware.  **/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_i2c_stop
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|i2cctl
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_I2CCTL_BY_MAC
argument_list|(
name|hw
argument_list|)
argument_list|)
decl_stmt|;
name|u32
name|data_oe_bit
init|=
name|IXGBE_I2C_DATA_OE_N_EN_BY_MAC
argument_list|(
name|hw
argument_list|)
decl_stmt|;
name|u32
name|clk_oe_bit
init|=
name|IXGBE_I2C_CLK_OE_N_EN_BY_MAC
argument_list|(
name|hw
argument_list|)
decl_stmt|;
name|u32
name|bb_en_bit
init|=
name|IXGBE_I2C_BB_EN_BY_MAC
argument_list|(
name|hw
argument_list|)
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_i2c_stop"
argument_list|)
expr_stmt|;
comment|/* Stop condition must begin with data low and clock high */
name|ixgbe_set_i2c_data
argument_list|(
name|hw
argument_list|,
operator|&
name|i2cctl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ixgbe_raise_i2c_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|i2cctl
argument_list|)
expr_stmt|;
comment|/* Setup time for stop condition (4us) */
name|usec_delay
argument_list|(
name|IXGBE_I2C_T_SU_STO
argument_list|)
expr_stmt|;
name|ixgbe_set_i2c_data
argument_list|(
name|hw
argument_list|,
operator|&
name|i2cctl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* bus free time between stop and start (4.7us)*/
name|usec_delay
argument_list|(
name|IXGBE_I2C_T_BUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb_en_bit
operator|||
name|data_oe_bit
operator|||
name|clk_oe_bit
condition|)
block|{
name|i2cctl
operator|&=
operator|~
name|bb_en_bit
expr_stmt|;
name|i2cctl
operator||=
name|data_oe_bit
operator||
name|clk_oe_bit
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_I2CCTL_BY_MAC
argument_list|(
name|hw
argument_list|)
argument_list|,
name|i2cctl
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *  ixgbe_clock_in_i2c_byte - Clocks in one byte via I2C  *  @hw: pointer to hardware structure  *  @data: data byte to clock in  *  *  Clocks in one byte data via I2C data/clock  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_clock_in_i2c_byte
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|data
parameter_list|)
block|{
name|s32
name|i
decl_stmt|;
name|bool
name|bit
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_clock_in_i2c_byte"
argument_list|)
expr_stmt|;
operator|*
name|data
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|7
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|ixgbe_clock_in_i2c_bit
argument_list|(
name|hw
argument_list|,
operator|&
name|bit
argument_list|)
expr_stmt|;
operator|*
name|data
operator||=
name|bit
operator|<<
name|i
expr_stmt|;
block|}
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_clock_out_i2c_byte - Clocks out one byte via I2C  *  @hw: pointer to hardware structure  *  @data: data byte clocked out  *  *  Clocks out one byte data via I2C data/clock  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_clock_out_i2c_byte
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|data
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|s32
name|i
decl_stmt|;
name|u32
name|i2cctl
decl_stmt|;
name|bool
name|bit
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_clock_out_i2c_byte"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|7
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|bit
operator|=
operator|(
name|data
operator|>>
name|i
operator|)
operator|&
literal|0x1
expr_stmt|;
name|status
operator|=
name|ixgbe_clock_out_i2c_bit
argument_list|(
name|hw
argument_list|,
name|bit
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
break|break;
block|}
comment|/* Release SDA line (set high) */
name|i2cctl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_I2CCTL_BY_MAC
argument_list|(
name|hw
argument_list|)
argument_list|)
expr_stmt|;
name|i2cctl
operator||=
name|IXGBE_I2C_DATA_OUT_BY_MAC
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|i2cctl
operator||=
name|IXGBE_I2C_DATA_OE_N_EN_BY_MAC
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_I2CCTL_BY_MAC
argument_list|(
name|hw
argument_list|)
argument_list|,
name|i2cctl
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_i2c_ack - Polls for I2C ACK  *  @hw: pointer to hardware structure  *  *  Clocks in/out one bit via I2C data/clock  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_get_i2c_ack
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|data_oe_bit
init|=
name|IXGBE_I2C_DATA_OE_N_EN_BY_MAC
argument_list|(
name|hw
argument_list|)
decl_stmt|;
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u32
name|i
init|=
literal|0
decl_stmt|;
name|u32
name|i2cctl
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_I2CCTL_BY_MAC
argument_list|(
name|hw
argument_list|)
argument_list|)
decl_stmt|;
name|u32
name|timeout
init|=
literal|10
decl_stmt|;
name|bool
name|ack
init|=
literal|1
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_i2c_ack"
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_oe_bit
condition|)
block|{
name|i2cctl
operator||=
name|IXGBE_I2C_DATA_OUT_BY_MAC
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|i2cctl
operator||=
name|data_oe_bit
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_I2CCTL_BY_MAC
argument_list|(
name|hw
argument_list|)
argument_list|,
name|i2cctl
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
name|ixgbe_raise_i2c_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|i2cctl
argument_list|)
expr_stmt|;
comment|/* Minimum high period of clock is 4us */
name|usec_delay
argument_list|(
name|IXGBE_I2C_T_HIGH
argument_list|)
expr_stmt|;
comment|/* Poll for ACK.  Note that ACK in I2C spec is 	 * transition from 1 to 0 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|timeout
condition|;
name|i
operator|++
control|)
block|{
name|i2cctl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_I2CCTL_BY_MAC
argument_list|(
name|hw
argument_list|)
argument_list|)
expr_stmt|;
name|ack
operator|=
name|ixgbe_get_i2c_data
argument_list|(
name|hw
argument_list|,
operator|&
name|i2cctl
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ack
condition|)
break|break;
block|}
if|if
condition|(
name|ack
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"I2C ack was not received.\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IXGBE_ERR_I2C
expr_stmt|;
block|}
name|ixgbe_lower_i2c_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|i2cctl
argument_list|)
expr_stmt|;
comment|/* Minimum low period of clock is 4.7 us */
name|usec_delay
argument_list|(
name|IXGBE_I2C_T_LOW
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_clock_in_i2c_bit - Clocks in one bit via I2C data/clock  *  @hw: pointer to hardware structure  *  @data: read data value  *  *  Clocks in one bit via I2C data/clock  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_clock_in_i2c_bit
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|bool
modifier|*
name|data
parameter_list|)
block|{
name|u32
name|i2cctl
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_I2CCTL_BY_MAC
argument_list|(
name|hw
argument_list|)
argument_list|)
decl_stmt|;
name|u32
name|data_oe_bit
init|=
name|IXGBE_I2C_DATA_OE_N_EN_BY_MAC
argument_list|(
name|hw
argument_list|)
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_clock_in_i2c_bit"
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_oe_bit
condition|)
block|{
name|i2cctl
operator||=
name|IXGBE_I2C_DATA_OUT_BY_MAC
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|i2cctl
operator||=
name|data_oe_bit
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_I2CCTL_BY_MAC
argument_list|(
name|hw
argument_list|)
argument_list|,
name|i2cctl
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
name|ixgbe_raise_i2c_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|i2cctl
argument_list|)
expr_stmt|;
comment|/* Minimum high period of clock is 4us */
name|usec_delay
argument_list|(
name|IXGBE_I2C_T_HIGH
argument_list|)
expr_stmt|;
name|i2cctl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_I2CCTL_BY_MAC
argument_list|(
name|hw
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|data
operator|=
name|ixgbe_get_i2c_data
argument_list|(
name|hw
argument_list|,
operator|&
name|i2cctl
argument_list|)
expr_stmt|;
name|ixgbe_lower_i2c_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|i2cctl
argument_list|)
expr_stmt|;
comment|/* Minimum low period of clock is 4.7 us */
name|usec_delay
argument_list|(
name|IXGBE_I2C_T_LOW
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_clock_out_i2c_bit - Clocks in/out one bit via I2C data/clock  *  @hw: pointer to hardware structure  *  @data: data value to write  *  *  Clocks out one bit via I2C data/clock  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_clock_out_i2c_bit
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|data
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|u32
name|i2cctl
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_I2CCTL_BY_MAC
argument_list|(
name|hw
argument_list|)
argument_list|)
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_clock_out_i2c_bit"
argument_list|)
expr_stmt|;
name|status
operator|=
name|ixgbe_set_i2c_data
argument_list|(
name|hw
argument_list|,
operator|&
name|i2cctl
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
condition|)
block|{
name|ixgbe_raise_i2c_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|i2cctl
argument_list|)
expr_stmt|;
comment|/* Minimum high period of clock is 4us */
name|usec_delay
argument_list|(
name|IXGBE_I2C_T_HIGH
argument_list|)
expr_stmt|;
name|ixgbe_lower_i2c_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|i2cctl
argument_list|)
expr_stmt|;
comment|/* Minimum low period of clock is 4.7 us. 		 * This also takes care of the data hold time. 		 */
name|usec_delay
argument_list|(
name|IXGBE_I2C_T_LOW
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|IXGBE_ERR_I2C
expr_stmt|;
name|ERROR_REPORT2
argument_list|(
name|IXGBE_ERROR_INVALID_STATE
argument_list|,
literal|"I2C data was not set to %X\n"
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_raise_i2c_clk - Raises the I2C SCL clock  *  @hw: pointer to hardware structure  *  @i2cctl: Current value of I2CCTL register  *  *  Raises the I2C clock line '0'->'1'  *  Negates the I2C clock output enable on X550 hardware.  **/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_raise_i2c_clk
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|i2cctl
parameter_list|)
block|{
name|u32
name|clk_oe_bit
init|=
name|IXGBE_I2C_CLK_OE_N_EN_BY_MAC
argument_list|(
name|hw
argument_list|)
decl_stmt|;
name|u32
name|i
init|=
literal|0
decl_stmt|;
name|u32
name|timeout
init|=
name|IXGBE_I2C_CLOCK_STRETCHING_TIMEOUT
decl_stmt|;
name|u32
name|i2cctl_r
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_raise_i2c_clk"
argument_list|)
expr_stmt|;
if|if
condition|(
name|clk_oe_bit
condition|)
block|{
operator|*
name|i2cctl
operator||=
name|clk_oe_bit
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_I2CCTL_BY_MAC
argument_list|(
name|hw
argument_list|)
argument_list|,
operator|*
name|i2cctl
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|timeout
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|i2cctl
operator||=
name|IXGBE_I2C_CLK_OUT_BY_MAC
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_I2CCTL_BY_MAC
argument_list|(
name|hw
argument_list|)
argument_list|,
operator|*
name|i2cctl
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* SCL rise time (1000ns) */
name|usec_delay
argument_list|(
name|IXGBE_I2C_T_RISE
argument_list|)
expr_stmt|;
name|i2cctl_r
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_I2CCTL_BY_MAC
argument_list|(
name|hw
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i2cctl_r
operator|&
name|IXGBE_I2C_CLK_IN_BY_MAC
argument_list|(
name|hw
argument_list|)
condition|)
break|break;
block|}
block|}
end_function

begin_comment
comment|/**  *  ixgbe_lower_i2c_clk - Lowers the I2C SCL clock  *  @hw: pointer to hardware structure  *  @i2cctl: Current value of I2CCTL register  *  *  Lowers the I2C clock line '1'->'0'  *  Asserts the I2C clock output enable on X550 hardware.  **/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_lower_i2c_clk
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|i2cctl
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_lower_i2c_clk"
argument_list|)
expr_stmt|;
operator|*
name|i2cctl
operator|&=
operator|~
operator|(
name|IXGBE_I2C_CLK_OUT_BY_MAC
argument_list|(
name|hw
argument_list|)
operator|)
expr_stmt|;
operator|*
name|i2cctl
operator|&=
operator|~
name|IXGBE_I2C_CLK_OE_N_EN_BY_MAC
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_I2CCTL_BY_MAC
argument_list|(
name|hw
argument_list|)
argument_list|,
operator|*
name|i2cctl
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* SCL fall time (300ns) */
name|usec_delay
argument_list|(
name|IXGBE_I2C_T_FALL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_set_i2c_data - Sets the I2C data bit  *  @hw: pointer to hardware structure  *  @i2cctl: Current value of I2CCTL register  *  @data: I2C data value (0 or 1) to set  *  *  Sets the I2C data bit  *  Asserts the I2C data output enable on X550 hardware.  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_set_i2c_data
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|i2cctl
parameter_list|,
name|bool
name|data
parameter_list|)
block|{
name|u32
name|data_oe_bit
init|=
name|IXGBE_I2C_DATA_OE_N_EN_BY_MAC
argument_list|(
name|hw
argument_list|)
decl_stmt|;
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_set_i2c_data"
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
condition|)
operator|*
name|i2cctl
operator||=
name|IXGBE_I2C_DATA_OUT_BY_MAC
argument_list|(
name|hw
argument_list|)
expr_stmt|;
else|else
operator|*
name|i2cctl
operator|&=
operator|~
operator|(
name|IXGBE_I2C_DATA_OUT_BY_MAC
argument_list|(
name|hw
argument_list|)
operator|)
expr_stmt|;
operator|*
name|i2cctl
operator|&=
operator|~
name|data_oe_bit
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_I2CCTL_BY_MAC
argument_list|(
name|hw
argument_list|)
argument_list|,
operator|*
name|i2cctl
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Data rise/fall (1000ns/300ns) and set-up time (250ns) */
name|usec_delay
argument_list|(
name|IXGBE_I2C_T_RISE
operator|+
name|IXGBE_I2C_T_FALL
operator|+
name|IXGBE_I2C_T_SU_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|data
condition|)
comment|/* Can't verify data in this case */
return|return
name|IXGBE_SUCCESS
return|;
if|if
condition|(
name|data_oe_bit
condition|)
block|{
operator|*
name|i2cctl
operator||=
name|data_oe_bit
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_I2CCTL_BY_MAC
argument_list|(
name|hw
argument_list|)
argument_list|,
operator|*
name|i2cctl
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
comment|/* Verify data was set correctly */
operator|*
name|i2cctl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_I2CCTL_BY_MAC
argument_list|(
name|hw
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|!=
name|ixgbe_get_i2c_data
argument_list|(
name|hw
argument_list|,
name|i2cctl
argument_list|)
condition|)
block|{
name|status
operator|=
name|IXGBE_ERR_I2C
expr_stmt|;
name|ERROR_REPORT2
argument_list|(
name|IXGBE_ERROR_INVALID_STATE
argument_list|,
literal|"Error - I2C data was not set to %X.\n"
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_i2c_data - Reads the I2C SDA data bit  *  @hw: pointer to hardware structure  *  @i2cctl: Current value of I2CCTL register  *  *  Returns the I2C data bit value  *  Negates the I2C data output enable on X550 hardware.  **/
end_comment

begin_function
specifier|static
name|bool
name|ixgbe_get_i2c_data
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|i2cctl
parameter_list|)
block|{
name|u32
name|data_oe_bit
init|=
name|IXGBE_I2C_DATA_OE_N_EN_BY_MAC
argument_list|(
name|hw
argument_list|)
decl_stmt|;
name|bool
name|data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_i2c_data"
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_oe_bit
condition|)
block|{
operator|*
name|i2cctl
operator||=
name|data_oe_bit
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_I2CCTL_BY_MAC
argument_list|(
name|hw
argument_list|)
argument_list|,
operator|*
name|i2cctl
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
name|IXGBE_I2C_T_FALL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|i2cctl
operator|&
name|IXGBE_I2C_DATA_IN_BY_MAC
argument_list|(
name|hw
argument_list|)
condition|)
name|data
operator|=
literal|1
expr_stmt|;
else|else
name|data
operator|=
literal|0
expr_stmt|;
return|return
name|data
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_i2c_bus_clear - Clears the I2C bus  *  @hw: pointer to hardware structure  *  *  Clears the I2C bus by sending nine clock pulses.  *  Used when data line is stuck low.  **/
end_comment

begin_function
name|void
name|ixgbe_i2c_bus_clear
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|i2cctl
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_i2c_bus_clear"
argument_list|)
expr_stmt|;
name|ixgbe_i2c_start
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|i2cctl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_I2CCTL_BY_MAC
argument_list|(
name|hw
argument_list|)
argument_list|)
expr_stmt|;
name|ixgbe_set_i2c_data
argument_list|(
name|hw
argument_list|,
operator|&
name|i2cctl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|9
condition|;
name|i
operator|++
control|)
block|{
name|ixgbe_raise_i2c_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|i2cctl
argument_list|)
expr_stmt|;
comment|/* Min high period of clock is 4us */
name|usec_delay
argument_list|(
name|IXGBE_I2C_T_HIGH
argument_list|)
expr_stmt|;
name|ixgbe_lower_i2c_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|i2cctl
argument_list|)
expr_stmt|;
comment|/* Min low period of clock is 4.7us*/
name|usec_delay
argument_list|(
name|IXGBE_I2C_T_LOW
argument_list|)
expr_stmt|;
block|}
name|ixgbe_i2c_start
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Put the i2c bus back to default state */
name|ixgbe_i2c_stop
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_tn_check_overtemp - Checks if an overtemp occurred.  *  @hw: pointer to hardware structure  *  *  Checks if the LASI temp alarm status was triggered due to overtemp  **/
end_comment

begin_function
name|s32
name|ixgbe_tn_check_overtemp
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u16
name|phy_data
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_tn_check_overtemp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|device_id
operator|!=
name|IXGBE_DEV_ID_82599_T3_LOM
condition|)
goto|goto
name|out
goto|;
comment|/* Check that the LASI temp alarm status was triggered */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_TN_LASI_STATUS_REG
argument_list|,
name|IXGBE_MDIO_PMA_PMD_DEV_TYPE
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|phy_data
operator|&
name|IXGBE_TN_LASI_STATUS_TEMP_ALARM
operator|)
condition|)
goto|goto
name|out
goto|;
name|status
operator|=
name|IXGBE_ERR_OVERTEMP
expr_stmt|;
name|ERROR_REPORT1
argument_list|(
name|IXGBE_ERROR_CAUTION
argument_list|,
literal|"Device over temperature"
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_set_copper_phy_power - Control power for copper phy  * @hw: pointer to hardware structure  * @on: TRUE for on, FALSE for off  */
end_comment

begin_function
name|s32
name|ixgbe_set_copper_phy_power
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|on
parameter_list|)
block|{
name|u32
name|status
decl_stmt|;
name|u16
name|reg
decl_stmt|;
if|if
condition|(
operator|!
name|on
operator|&&
name|ixgbe_mng_present
argument_list|(
name|hw
argument_list|)
condition|)
return|return
literal|0
return|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_CONTROL
argument_list|,
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|status
return|;
if|if
condition|(
name|on
condition|)
block|{
name|reg
operator|&=
operator|~
name|IXGBE_MDIO_PHY_SET_LOW_POWER_MODE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ixgbe_check_reset_blocked
argument_list|(
name|hw
argument_list|)
condition|)
return|return
literal|0
return|;
name|reg
operator||=
name|IXGBE_MDIO_PHY_SET_LOW_POWER_MODE
expr_stmt|;
block|}
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_CONTROL
argument_list|,
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

end_unit

