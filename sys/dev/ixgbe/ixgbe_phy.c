begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************    Copyright (c) 2001-2013, Intel Corporation    All rights reserved.      Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are met:       1. Redistributions of source code must retain the above copyright notice,        this list of conditions and the following disclaimer.       2. Redistributions in binary form must reproduce the above copyright        notice, this list of conditions and the following disclaimer in the        documentation and/or other materials provided with the distribution.       3. Neither the name of the Intel Corporation nor the names of its        contributors may be used to endorse or promote products derived from        this software without specific prior written permission.      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  ******************************************************************************/
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_include
include|#
directive|include
file|"ixgbe_api.h"
end_include

begin_include
include|#
directive|include
file|"ixgbe_common.h"
end_include

begin_include
include|#
directive|include
file|"ixgbe_phy.h"
end_include

begin_function_decl
specifier|static
name|void
name|ixgbe_i2c_start
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_i2c_stop
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|ixgbe_clock_in_i2c_byte
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|ixgbe_clock_out_i2c_byte
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|ixgbe_get_i2c_ack
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|ixgbe_clock_in_i2c_bit
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|bool
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|ixgbe_clock_out_i2c_bit
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_raise_i2c_clk
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|i2cctl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_lower_i2c_clk
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|i2cctl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|ixgbe_set_i2c_data
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|i2cctl
parameter_list|,
name|bool
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ixgbe_get_i2c_data
parameter_list|(
name|u32
modifier|*
name|i2cctl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|ixgbe_read_i2c_sff8472_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|byte_offset
parameter_list|,
name|u8
modifier|*
name|sff8472_data
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  *  ixgbe_init_phy_ops_generic - Inits PHY function ptrs  *  @hw: pointer to the hardware structure  *  *  Initialize the function pointers.  **/
end_comment

begin_function
name|s32
name|ixgbe_init_phy_ops_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|ixgbe_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_init_phy_ops_generic"
argument_list|)
expr_stmt|;
comment|/* PHY */
name|phy
operator|->
name|ops
operator|.
name|identify
operator|=
operator|&
name|ixgbe_identify_phy_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|reset
operator|=
operator|&
name|ixgbe_reset_phy_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|read_reg
operator|=
operator|&
name|ixgbe_read_phy_reg_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|write_reg
operator|=
operator|&
name|ixgbe_write_phy_reg_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|setup_link
operator|=
operator|&
name|ixgbe_setup_phy_link_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|setup_link_speed
operator|=
operator|&
name|ixgbe_setup_phy_link_speed_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|check_link
operator|=
name|NULL
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|get_firmware_version
operator|=
name|ixgbe_get_phy_firmware_version_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|read_i2c_byte
operator|=
operator|&
name|ixgbe_read_i2c_byte_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|write_i2c_byte
operator|=
operator|&
name|ixgbe_write_i2c_byte_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|read_i2c_sff8472
operator|=
operator|&
name|ixgbe_read_i2c_sff8472_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|read_i2c_eeprom
operator|=
operator|&
name|ixgbe_read_i2c_eeprom_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|write_i2c_eeprom
operator|=
operator|&
name|ixgbe_write_i2c_eeprom_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|i2c_bus_clear
operator|=
operator|&
name|ixgbe_i2c_bus_clear
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|identify_sfp
operator|=
operator|&
name|ixgbe_identify_module_generic
expr_stmt|;
name|phy
operator|->
name|sfp_type
operator|=
name|ixgbe_sfp_type_unknown
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|check_overtemp
operator|=
operator|&
name|ixgbe_tn_check_overtemp
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_identify_phy_generic - Get physical layer module  *  @hw: pointer to hardware structure  *  *  Determines the physical layer module found on the current adapter.  **/
end_comment

begin_function
name|s32
name|ixgbe_identify_phy_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_ERR_PHY_ADDR_INVALID
decl_stmt|;
name|u32
name|phy_addr
decl_stmt|;
name|u16
name|ext_ability
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_identify_phy_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|ixgbe_phy_unknown
condition|)
block|{
for|for
control|(
name|phy_addr
operator|=
literal|0
init|;
name|phy_addr
operator|<
name|IXGBE_MAX_PHY_ADDR
condition|;
name|phy_addr
operator|++
control|)
block|{
if|if
condition|(
name|ixgbe_validate_phy_addr
argument_list|(
name|hw
argument_list|,
name|phy_addr
argument_list|)
condition|)
block|{
name|hw
operator|->
name|phy
operator|.
name|addr
operator|=
name|phy_addr
expr_stmt|;
name|ixgbe_get_phy_id
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|ixgbe_get_phy_type_from_id
argument_list|(
name|hw
operator|->
name|phy
operator|.
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|ixgbe_phy_unknown
condition|)
block|{
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_PHY_EXT_ABILITY
argument_list|,
name|IXGBE_MDIO_PMA_PMD_DEV_TYPE
argument_list|,
operator|&
name|ext_ability
argument_list|)
expr_stmt|;
if|if
condition|(
name|ext_ability
operator|&
operator|(
name|IXGBE_MDIO_PHY_10GBASET_ABILITY
operator||
name|IXGBE_MDIO_PHY_1000BASET_ABILITY
operator|)
condition|)
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|ixgbe_phy_cu_unknown
expr_stmt|;
else|else
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|ixgbe_phy_generic
expr_stmt|;
block|}
name|status
operator|=
name|IXGBE_SUCCESS
expr_stmt|;
break|break;
block|}
block|}
comment|/* clear value if nothing found */
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
name|hw
operator|->
name|phy
operator|.
name|addr
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|IXGBE_SUCCESS
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_validate_phy_addr - Determines phy address is valid  *  @hw: pointer to hardware structure  *  **/
end_comment

begin_function
name|bool
name|ixgbe_validate_phy_addr
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|phy_addr
parameter_list|)
block|{
name|u16
name|phy_id
init|=
literal|0
decl_stmt|;
name|bool
name|valid
init|=
name|FALSE
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_validate_phy_addr"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|addr
operator|=
name|phy_addr
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_PHY_ID_HIGH
argument_list|,
name|IXGBE_MDIO_PMA_PMD_DEV_TYPE
argument_list|,
operator|&
name|phy_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_id
operator|!=
literal|0xFFFF
operator|&&
name|phy_id
operator|!=
literal|0x0
condition|)
name|valid
operator|=
name|TRUE
expr_stmt|;
return|return
name|valid
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_phy_id - Get the phy type  *  @hw: pointer to hardware structure  *  **/
end_comment

begin_function
name|s32
name|ixgbe_get_phy_id
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|status
decl_stmt|;
name|u16
name|phy_id_high
init|=
literal|0
decl_stmt|;
name|u16
name|phy_id_low
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_phy_id"
argument_list|)
expr_stmt|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_PHY_ID_HIGH
argument_list|,
name|IXGBE_MDIO_PMA_PMD_DEV_TYPE
argument_list|,
operator|&
name|phy_id_high
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
condition|)
block|{
name|hw
operator|->
name|phy
operator|.
name|id
operator|=
call|(
name|u32
call|)
argument_list|(
name|phy_id_high
operator|<<
literal|16
argument_list|)
expr_stmt|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_PHY_ID_LOW
argument_list|,
name|IXGBE_MDIO_PMA_PMD_DEV_TYPE
argument_list|,
operator|&
name|phy_id_low
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|id
operator||=
call|(
name|u32
call|)
argument_list|(
name|phy_id_low
operator|&
name|IXGBE_PHY_REVISION_MASK
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|revision
operator|=
call|(
name|u32
call|)
argument_list|(
name|phy_id_low
operator|&
operator|~
name|IXGBE_PHY_REVISION_MASK
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_phy_type_from_id - Get the phy type  *  @hw: pointer to hardware structure  *  **/
end_comment

begin_function
name|enum
name|ixgbe_phy_type
name|ixgbe_get_phy_type_from_id
parameter_list|(
name|u32
name|phy_id
parameter_list|)
block|{
name|enum
name|ixgbe_phy_type
name|phy_type
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_phy_type_from_id"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|phy_id
condition|)
block|{
case|case
name|TN1010_PHY_ID
case|:
name|phy_type
operator|=
name|ixgbe_phy_tn
expr_stmt|;
break|break;
case|case
name|X540_PHY_ID
case|:
name|phy_type
operator|=
name|ixgbe_phy_aq
expr_stmt|;
break|break;
case|case
name|QT2022_PHY_ID
case|:
name|phy_type
operator|=
name|ixgbe_phy_qt
expr_stmt|;
break|break;
case|case
name|ATH_PHY_ID
case|:
name|phy_type
operator|=
name|ixgbe_phy_nl
expr_stmt|;
break|break;
default|default:
name|phy_type
operator|=
name|ixgbe_phy_unknown
expr_stmt|;
break|break;
block|}
name|DEBUGOUT1
argument_list|(
literal|"phy type found is %d\n"
argument_list|,
name|phy_type
argument_list|)
expr_stmt|;
return|return
name|phy_type
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_reset_phy_generic - Performs a PHY reset  *  @hw: pointer to hardware structure  **/
end_comment

begin_function
name|s32
name|ixgbe_reset_phy_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|i
decl_stmt|;
name|u16
name|ctrl
init|=
literal|0
decl_stmt|;
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_reset_phy_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|ixgbe_phy_unknown
condition|)
name|status
operator|=
name|ixgbe_identify_phy_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
operator|||
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|ixgbe_phy_none
condition|)
goto|goto
name|out
goto|;
comment|/* Don't reset PHY if it's shut down due to overtemp. */
if|if
condition|(
operator|!
name|hw
operator|->
name|phy
operator|.
name|reset_if_overtemp
operator|&&
operator|(
name|IXGBE_ERR_OVERTEMP
operator|==
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|check_overtemp
argument_list|(
name|hw
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Perform soft PHY reset to the PHY_XS. 	 * This will cause a soft reset to the PHY 	 */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_PHY_XS_CONTROL
argument_list|,
name|IXGBE_MDIO_PHY_XS_DEV_TYPE
argument_list|,
name|IXGBE_MDIO_PHY_XS_RESET
argument_list|)
expr_stmt|;
comment|/* 	 * Poll for reset bit to self-clear indicating reset is complete. 	 * Some PHYs could take up to 3 seconds to complete and need about 	 * 1.7 usec delay after the reset is complete. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|30
condition|;
name|i
operator|++
control|)
block|{
name|msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_PHY_XS_CONTROL
argument_list|,
name|IXGBE_MDIO_PHY_XS_DEV_TYPE
argument_list|,
operator|&
name|ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ctrl
operator|&
name|IXGBE_MDIO_PHY_XS_RESET
operator|)
condition|)
block|{
name|usec_delay
argument_list|(
literal|2
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ctrl
operator|&
name|IXGBE_MDIO_PHY_XS_RESET
condition|)
block|{
name|status
operator|=
name|IXGBE_ERR_RESET_FAILED
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"PHY reset polling failed to complete.\n"
argument_list|)
expr_stmt|;
block|}
name|out
label|:
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_read_phy_reg_generic - Reads a value from a specified PHY register  *  @hw: pointer to hardware structure  *  @reg_addr: 32 bit address of PHY register to read  *  @phy_data: Pointer to read data from PHY register  **/
end_comment

begin_function
name|s32
name|ixgbe_read_phy_reg_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|reg_addr
parameter_list|,
name|u32
name|device_type
parameter_list|,
name|u16
modifier|*
name|phy_data
parameter_list|)
block|{
name|u32
name|command
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|u32
name|data
decl_stmt|;
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u16
name|gssr
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_read_phy_reg_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_STATUS
argument_list|)
operator|&
name|IXGBE_STATUS_LAN_ID_1
condition|)
name|gssr
operator|=
name|IXGBE_GSSR_PHY1_SM
expr_stmt|;
else|else
name|gssr
operator|=
name|IXGBE_GSSR_PHY0_SM
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|acquire_swfw_sync
argument_list|(
name|hw
argument_list|,
name|gssr
argument_list|)
operator|!=
name|IXGBE_SUCCESS
condition|)
name|status
operator|=
name|IXGBE_ERR_SWFW_SYNC
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
condition|)
block|{
comment|/* Setup and write the address cycle command */
name|command
operator|=
operator|(
operator|(
name|reg_addr
operator|<<
name|IXGBE_MSCA_NP_ADDR_SHIFT
operator|)
operator||
operator|(
name|device_type
operator|<<
name|IXGBE_MSCA_DEV_TYPE_SHIFT
operator|)
operator||
operator|(
name|hw
operator|->
name|phy
operator|.
name|addr
operator|<<
name|IXGBE_MSCA_PHY_ADDR_SHIFT
operator|)
operator||
operator|(
name|IXGBE_MSCA_ADDR_CYCLE
operator||
name|IXGBE_MSCA_MDI_COMMAND
operator|)
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MSCA
argument_list|,
name|command
argument_list|)
expr_stmt|;
comment|/* 		 * Check every 10 usec to see if the address cycle completed. 		 * The MDI Command bit will clear when the operation is 		 * complete 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_MDIO_COMMAND_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|command
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MSCA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|command
operator|&
name|IXGBE_MSCA_MDI_COMMAND
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|command
operator|&
name|IXGBE_MSCA_MDI_COMMAND
operator|)
operator|!=
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PHY address command did not complete.\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IXGBE_ERR_PHY
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
condition|)
block|{
comment|/* 			 * Address cycle complete, setup and write the read 			 * command 			 */
name|command
operator|=
operator|(
operator|(
name|reg_addr
operator|<<
name|IXGBE_MSCA_NP_ADDR_SHIFT
operator|)
operator||
operator|(
name|device_type
operator|<<
name|IXGBE_MSCA_DEV_TYPE_SHIFT
operator|)
operator||
operator|(
name|hw
operator|->
name|phy
operator|.
name|addr
operator|<<
name|IXGBE_MSCA_PHY_ADDR_SHIFT
operator|)
operator||
operator|(
name|IXGBE_MSCA_READ
operator||
name|IXGBE_MSCA_MDI_COMMAND
operator|)
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MSCA
argument_list|,
name|command
argument_list|)
expr_stmt|;
comment|/* 			 * Check every 10 usec to see if the address cycle 			 * completed. The MDI Command bit will clear when the 			 * operation is complete 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_MDIO_COMMAND_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|command
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MSCA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|command
operator|&
name|IXGBE_MSCA_MDI_COMMAND
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|command
operator|&
name|IXGBE_MSCA_MDI_COMMAND
operator|)
operator|!=
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PHY read command didn't complete\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IXGBE_ERR_PHY
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Read operation is complete.  Get the data 				 * from MSRWD 				 */
name|data
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MSRWD
argument_list|)
expr_stmt|;
name|data
operator|>>=
name|IXGBE_MSRWD_READ_DATA_SHIFT
expr_stmt|;
operator|*
name|phy_data
operator|=
call|(
name|u16
call|)
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
block|}
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|gssr
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_write_phy_reg_generic - Writes a value to specified PHY register  *  @hw: pointer to hardware structure  *  @reg_addr: 32 bit PHY register to write  *  @device_type: 5 bit device type  *  @phy_data: Data to write to the PHY register  **/
end_comment

begin_function
name|s32
name|ixgbe_write_phy_reg_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|reg_addr
parameter_list|,
name|u32
name|device_type
parameter_list|,
name|u16
name|phy_data
parameter_list|)
block|{
name|u32
name|command
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u16
name|gssr
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_write_phy_reg_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_STATUS
argument_list|)
operator|&
name|IXGBE_STATUS_LAN_ID_1
condition|)
name|gssr
operator|=
name|IXGBE_GSSR_PHY1_SM
expr_stmt|;
else|else
name|gssr
operator|=
name|IXGBE_GSSR_PHY0_SM
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|acquire_swfw_sync
argument_list|(
name|hw
argument_list|,
name|gssr
argument_list|)
operator|!=
name|IXGBE_SUCCESS
condition|)
name|status
operator|=
name|IXGBE_ERR_SWFW_SYNC
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
condition|)
block|{
comment|/* Put the data in the MDI single read and write data register*/
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MSRWD
argument_list|,
operator|(
name|u32
operator|)
name|phy_data
argument_list|)
expr_stmt|;
comment|/* Setup and write the address cycle command */
name|command
operator|=
operator|(
operator|(
name|reg_addr
operator|<<
name|IXGBE_MSCA_NP_ADDR_SHIFT
operator|)
operator||
operator|(
name|device_type
operator|<<
name|IXGBE_MSCA_DEV_TYPE_SHIFT
operator|)
operator||
operator|(
name|hw
operator|->
name|phy
operator|.
name|addr
operator|<<
name|IXGBE_MSCA_PHY_ADDR_SHIFT
operator|)
operator||
operator|(
name|IXGBE_MSCA_ADDR_CYCLE
operator||
name|IXGBE_MSCA_MDI_COMMAND
operator|)
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MSCA
argument_list|,
name|command
argument_list|)
expr_stmt|;
comment|/* 		 * Check every 10 usec to see if the address cycle completed. 		 * The MDI Command bit will clear when the operation is 		 * complete 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_MDIO_COMMAND_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|command
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MSCA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|command
operator|&
name|IXGBE_MSCA_MDI_COMMAND
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|command
operator|&
name|IXGBE_MSCA_MDI_COMMAND
operator|)
operator|!=
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PHY address cmd didn't complete\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IXGBE_ERR_PHY
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
condition|)
block|{
comment|/* 			 * Address cycle complete, setup and write the write 			 * command 			 */
name|command
operator|=
operator|(
operator|(
name|reg_addr
operator|<<
name|IXGBE_MSCA_NP_ADDR_SHIFT
operator|)
operator||
operator|(
name|device_type
operator|<<
name|IXGBE_MSCA_DEV_TYPE_SHIFT
operator|)
operator||
operator|(
name|hw
operator|->
name|phy
operator|.
name|addr
operator|<<
name|IXGBE_MSCA_PHY_ADDR_SHIFT
operator|)
operator||
operator|(
name|IXGBE_MSCA_WRITE
operator||
name|IXGBE_MSCA_MDI_COMMAND
operator|)
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MSCA
argument_list|,
name|command
argument_list|)
expr_stmt|;
comment|/* 			 * Check every 10 usec to see if the address cycle 			 * completed. The MDI Command bit will clear when the 			 * operation is complete 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_MDIO_COMMAND_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|command
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MSCA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|command
operator|&
name|IXGBE_MSCA_MDI_COMMAND
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|command
operator|&
name|IXGBE_MSCA_MDI_COMMAND
operator|)
operator|!=
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PHY address cmd didn't complete\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IXGBE_ERR_PHY
expr_stmt|;
block|}
block|}
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|gssr
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_setup_phy_link_generic - Set and restart autoneg  *  @hw: pointer to hardware structure  *  *  Restart autonegotiation and PHY and waits for completion.  **/
end_comment

begin_function
name|s32
name|ixgbe_setup_phy_link_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u32
name|time_out
decl_stmt|;
name|u32
name|max_time_out
init|=
literal|10
decl_stmt|;
name|u16
name|autoneg_reg
init|=
name|IXGBE_MII_AUTONEG_REG
decl_stmt|;
name|bool
name|autoneg
init|=
name|FALSE
decl_stmt|;
name|ixgbe_link_speed
name|speed
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_setup_phy_link_generic"
argument_list|)
expr_stmt|;
name|ixgbe_get_copper_link_capabilities_generic
argument_list|(
name|hw
argument_list|,
operator|&
name|speed
argument_list|,
operator|&
name|autoneg
argument_list|)
expr_stmt|;
if|if
condition|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_10GB_FULL
condition|)
block|{
comment|/* Set or unset auto-negotiation 10G advertisement */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MII_10GBASE_T_AUTONEG_CTRL_REG
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
operator|&
name|autoneg_reg
argument_list|)
expr_stmt|;
name|autoneg_reg
operator|&=
operator|~
name|IXGBE_MII_10GBASE_T_ADVERTISE
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator|&
name|IXGBE_LINK_SPEED_10GB_FULL
condition|)
name|autoneg_reg
operator||=
name|IXGBE_MII_10GBASE_T_ADVERTISE
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MII_10GBASE_T_AUTONEG_CTRL_REG
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
name|autoneg_reg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_1GB_FULL
condition|)
block|{
comment|/* Set or unset auto-negotiation 1G advertisement */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MII_AUTONEG_VENDOR_PROVISION_1_REG
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
operator|&
name|autoneg_reg
argument_list|)
expr_stmt|;
name|autoneg_reg
operator|&=
operator|~
name|IXGBE_MII_1GBASE_T_ADVERTISE
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator|&
name|IXGBE_LINK_SPEED_1GB_FULL
condition|)
name|autoneg_reg
operator||=
name|IXGBE_MII_1GBASE_T_ADVERTISE
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MII_AUTONEG_VENDOR_PROVISION_1_REG
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
name|autoneg_reg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_100_FULL
condition|)
block|{
comment|/* Set or unset auto-negotiation 100M advertisement */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MII_AUTONEG_ADVERTISE_REG
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
operator|&
name|autoneg_reg
argument_list|)
expr_stmt|;
name|autoneg_reg
operator|&=
operator|~
operator|(
name|IXGBE_MII_100BASE_T_ADVERTISE
operator||
name|IXGBE_MII_100BASE_T_ADVERTISE_HALF
operator|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator|&
name|IXGBE_LINK_SPEED_100_FULL
condition|)
name|autoneg_reg
operator||=
name|IXGBE_MII_100BASE_T_ADVERTISE
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MII_AUTONEG_ADVERTISE_REG
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
name|autoneg_reg
argument_list|)
expr_stmt|;
block|}
comment|/* Restart PHY autonegotiation and wait for completion */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_CONTROL
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
operator|&
name|autoneg_reg
argument_list|)
expr_stmt|;
name|autoneg_reg
operator||=
name|IXGBE_MII_RESTART
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_CONTROL
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
name|autoneg_reg
argument_list|)
expr_stmt|;
comment|/* Wait for autonegotiation to finish */
for|for
control|(
name|time_out
operator|=
literal|0
init|;
name|time_out
operator|<
name|max_time_out
condition|;
name|time_out
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* Restart PHY autonegotiation and wait for completion */
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_STATUS
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
operator|&
name|autoneg_reg
argument_list|)
expr_stmt|;
name|autoneg_reg
operator|&=
name|IXGBE_MII_AUTONEG_COMPLETE
expr_stmt|;
if|if
condition|(
name|autoneg_reg
operator|==
name|IXGBE_MII_AUTONEG_COMPLETE
condition|)
break|break;
block|}
if|if
condition|(
name|time_out
operator|==
name|max_time_out
condition|)
block|{
name|status
operator|=
name|IXGBE_ERR_LINK_SETUP
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"ixgbe_setup_phy_link_generic: time out"
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_setup_phy_link_speed_generic - Sets the auto advertised capabilities  *  @hw: pointer to hardware structure  *  @speed: new link speed  **/
end_comment

begin_function
name|s32
name|ixgbe_setup_phy_link_speed_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
name|speed
parameter_list|,
name|bool
name|autoneg_wait_to_complete
parameter_list|)
block|{
name|UNREFERENCED_1PARAMETER
argument_list|(
name|autoneg_wait_to_complete
argument_list|)
expr_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_setup_phy_link_speed_generic"
argument_list|)
expr_stmt|;
comment|/* 	 * Clear autoneg_advertised and set new values based on input link 	 * speed. 	 */
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_10GB_FULL
condition|)
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator||=
name|IXGBE_LINK_SPEED_10GB_FULL
expr_stmt|;
if|if
condition|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_1GB_FULL
condition|)
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator||=
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
if|if
condition|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_100_FULL
condition|)
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator||=
name|IXGBE_LINK_SPEED_100_FULL
expr_stmt|;
comment|/* Setup link based on the new speed settings */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|setup_link
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_copper_link_capabilities_generic - Determines link capabilities  *  @hw: pointer to hardware structure  *  @speed: pointer to link speed  *  @autoneg: boolean auto-negotiation value  *  *  Determines the link capabilities by reading the AUTOC register.  **/
end_comment

begin_function
name|s32
name|ixgbe_get_copper_link_capabilities_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
modifier|*
name|speed
parameter_list|,
name|bool
modifier|*
name|autoneg
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_ERR_LINK_SETUP
decl_stmt|;
name|u16
name|speed_ability
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_copper_link_capabilities_generic"
argument_list|)
expr_stmt|;
operator|*
name|speed
operator|=
literal|0
expr_stmt|;
operator|*
name|autoneg
operator|=
name|TRUE
expr_stmt|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_PHY_SPEED_ABILITY
argument_list|,
name|IXGBE_MDIO_PMA_PMD_DEV_TYPE
argument_list|,
operator|&
name|speed_ability
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
condition|)
block|{
if|if
condition|(
name|speed_ability
operator|&
name|IXGBE_MDIO_PHY_SPEED_10G
condition|)
operator|*
name|speed
operator||=
name|IXGBE_LINK_SPEED_10GB_FULL
expr_stmt|;
if|if
condition|(
name|speed_ability
operator|&
name|IXGBE_MDIO_PHY_SPEED_1G
condition|)
operator|*
name|speed
operator||=
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
if|if
condition|(
name|speed_ability
operator|&
name|IXGBE_MDIO_PHY_SPEED_100M
condition|)
operator|*
name|speed
operator||=
name|IXGBE_LINK_SPEED_100_FULL
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_check_phy_link_tnx - Determine link and speed status  *  @hw: pointer to hardware structure  *  *  Reads the VS1 register to determine if link is up and the current speed for  *  the PHY.  **/
end_comment

begin_function
name|s32
name|ixgbe_check_phy_link_tnx
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
modifier|*
name|speed
parameter_list|,
name|bool
modifier|*
name|link_up
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u32
name|time_out
decl_stmt|;
name|u32
name|max_time_out
init|=
literal|10
decl_stmt|;
name|u16
name|phy_link
init|=
literal|0
decl_stmt|;
name|u16
name|phy_speed
init|=
literal|0
decl_stmt|;
name|u16
name|phy_data
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_check_phy_link_tnx"
argument_list|)
expr_stmt|;
comment|/* Initialize speed and link to default case */
operator|*
name|link_up
operator|=
name|FALSE
expr_stmt|;
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_10GB_FULL
expr_stmt|;
comment|/* 	 * Check current speed and link status of the PHY register. 	 * This is a vendor specific register and may have to 	 * be changed for other copper PHYs. 	 */
for|for
control|(
name|time_out
operator|=
literal|0
init|;
name|time_out
operator|<
name|max_time_out
condition|;
name|time_out
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_STATUS
argument_list|,
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
name|phy_link
operator|=
name|phy_data
operator|&
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_LINK_STATUS
expr_stmt|;
name|phy_speed
operator|=
name|phy_data
operator|&
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_SPEED_STATUS
expr_stmt|;
if|if
condition|(
name|phy_link
operator|==
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_LINK_STATUS
condition|)
block|{
operator|*
name|link_up
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|phy_speed
operator|==
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_SPEED_STATUS
condition|)
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
break|break;
block|}
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *	ixgbe_setup_phy_link_tnx - Set and restart autoneg  *	@hw: pointer to hardware structure  *  *	Restart autonegotiation and PHY and waits for completion.  **/
end_comment

begin_function
name|s32
name|ixgbe_setup_phy_link_tnx
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u32
name|time_out
decl_stmt|;
name|u32
name|max_time_out
init|=
literal|10
decl_stmt|;
name|u16
name|autoneg_reg
init|=
name|IXGBE_MII_AUTONEG_REG
decl_stmt|;
name|bool
name|autoneg
init|=
name|FALSE
decl_stmt|;
name|ixgbe_link_speed
name|speed
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_setup_phy_link_tnx"
argument_list|)
expr_stmt|;
name|ixgbe_get_copper_link_capabilities_generic
argument_list|(
name|hw
argument_list|,
operator|&
name|speed
argument_list|,
operator|&
name|autoneg
argument_list|)
expr_stmt|;
if|if
condition|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_10GB_FULL
condition|)
block|{
comment|/* Set or unset auto-negotiation 10G advertisement */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MII_10GBASE_T_AUTONEG_CTRL_REG
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
operator|&
name|autoneg_reg
argument_list|)
expr_stmt|;
name|autoneg_reg
operator|&=
operator|~
name|IXGBE_MII_10GBASE_T_ADVERTISE
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator|&
name|IXGBE_LINK_SPEED_10GB_FULL
condition|)
name|autoneg_reg
operator||=
name|IXGBE_MII_10GBASE_T_ADVERTISE
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MII_10GBASE_T_AUTONEG_CTRL_REG
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
name|autoneg_reg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_1GB_FULL
condition|)
block|{
comment|/* Set or unset auto-negotiation 1G advertisement */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MII_AUTONEG_XNP_TX_REG
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
operator|&
name|autoneg_reg
argument_list|)
expr_stmt|;
name|autoneg_reg
operator|&=
operator|~
name|IXGBE_MII_1GBASE_T_ADVERTISE_XNP_TX
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator|&
name|IXGBE_LINK_SPEED_1GB_FULL
condition|)
name|autoneg_reg
operator||=
name|IXGBE_MII_1GBASE_T_ADVERTISE_XNP_TX
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MII_AUTONEG_XNP_TX_REG
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
name|autoneg_reg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_100_FULL
condition|)
block|{
comment|/* Set or unset auto-negotiation 100M advertisement */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MII_AUTONEG_ADVERTISE_REG
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
operator|&
name|autoneg_reg
argument_list|)
expr_stmt|;
name|autoneg_reg
operator|&=
operator|~
name|IXGBE_MII_100BASE_T_ADVERTISE
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator|&
name|IXGBE_LINK_SPEED_100_FULL
condition|)
name|autoneg_reg
operator||=
name|IXGBE_MII_100BASE_T_ADVERTISE
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MII_AUTONEG_ADVERTISE_REG
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
name|autoneg_reg
argument_list|)
expr_stmt|;
block|}
comment|/* Restart PHY autonegotiation and wait for completion */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_CONTROL
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
operator|&
name|autoneg_reg
argument_list|)
expr_stmt|;
name|autoneg_reg
operator||=
name|IXGBE_MII_RESTART
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_CONTROL
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
name|autoneg_reg
argument_list|)
expr_stmt|;
comment|/* Wait for autonegotiation to finish */
for|for
control|(
name|time_out
operator|=
literal|0
init|;
name|time_out
operator|<
name|max_time_out
condition|;
name|time_out
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* Restart PHY autonegotiation and wait for completion */
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_STATUS
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
operator|&
name|autoneg_reg
argument_list|)
expr_stmt|;
name|autoneg_reg
operator|&=
name|IXGBE_MII_AUTONEG_COMPLETE
expr_stmt|;
if|if
condition|(
name|autoneg_reg
operator|==
name|IXGBE_MII_AUTONEG_COMPLETE
condition|)
break|break;
block|}
if|if
condition|(
name|time_out
operator|==
name|max_time_out
condition|)
block|{
name|status
operator|=
name|IXGBE_ERR_LINK_SETUP
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"ixgbe_setup_phy_link_tnx: time out"
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_phy_firmware_version_tnx - Gets the PHY Firmware Version  *  @hw: pointer to hardware structure  *  @firmware_version: pointer to the PHY Firmware Version  **/
end_comment

begin_function
name|s32
name|ixgbe_get_phy_firmware_version_tnx
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|firmware_version
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_phy_firmware_version_tnx"
argument_list|)
expr_stmt|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|TNX_FW_REV
argument_list|,
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE
argument_list|,
name|firmware_version
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_phy_firmware_version_generic - Gets the PHY Firmware Version  *  @hw: pointer to hardware structure  *  @firmware_version: pointer to the PHY Firmware Version  **/
end_comment

begin_function
name|s32
name|ixgbe_get_phy_firmware_version_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|firmware_version
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_phy_firmware_version_generic"
argument_list|)
expr_stmt|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|AQ_FW_REV
argument_list|,
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE
argument_list|,
name|firmware_version
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_reset_phy_nl - Performs a PHY reset  *  @hw: pointer to hardware structure  **/
end_comment

begin_function
name|s32
name|ixgbe_reset_phy_nl
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u16
name|phy_offset
decl_stmt|,
name|control
decl_stmt|,
name|eword
decl_stmt|,
name|edata
decl_stmt|,
name|block_crc
decl_stmt|;
name|bool
name|end_data
init|=
name|FALSE
decl_stmt|;
name|u16
name|list_offset
decl_stmt|,
name|data_offset
decl_stmt|;
name|u16
name|phy_data
init|=
literal|0
decl_stmt|;
name|s32
name|ret_val
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_reset_phy_nl"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_PHY_XS_CONTROL
argument_list|,
name|IXGBE_MDIO_PHY_XS_DEV_TYPE
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
comment|/* reset the PHY and poll for completion */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_PHY_XS_CONTROL
argument_list|,
name|IXGBE_MDIO_PHY_XS_DEV_TYPE
argument_list|,
operator|(
name|phy_data
operator||
name|IXGBE_MDIO_PHY_XS_RESET
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_PHY_XS_CONTROL
argument_list|,
name|IXGBE_MDIO_PHY_XS_DEV_TYPE
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|phy_data
operator|&
name|IXGBE_MDIO_PHY_XS_RESET
operator|)
operator|==
literal|0
condition|)
break|break;
name|msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|phy_data
operator|&
name|IXGBE_MDIO_PHY_XS_RESET
operator|)
operator|!=
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PHY reset did not complete.\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|IXGBE_ERR_PHY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Get init offsets */
name|ret_val
operator|=
name|ixgbe_get_sfp_init_sequence_offsets
argument_list|(
name|hw
argument_list|,
operator|&
name|list_offset
argument_list|,
operator|&
name|data_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|data_offset
argument_list|,
operator|&
name|block_crc
argument_list|)
expr_stmt|;
name|data_offset
operator|++
expr_stmt|;
while|while
condition|(
operator|!
name|end_data
condition|)
block|{
comment|/* 		 * Read control word from PHY init contents offset 		 */
name|ret_val
operator|=
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|data_offset
argument_list|,
operator|&
name|eword
argument_list|)
expr_stmt|;
name|control
operator|=
operator|(
name|eword
operator|&
name|IXGBE_CONTROL_MASK_NL
operator|)
operator|>>
name|IXGBE_CONTROL_SHIFT_NL
expr_stmt|;
name|edata
operator|=
name|eword
operator|&
name|IXGBE_DATA_MASK_NL
expr_stmt|;
switch|switch
condition|(
name|control
condition|)
block|{
case|case
name|IXGBE_DELAY_NL
case|:
name|data_offset
operator|++
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"DELAY: %d MS\n"
argument_list|,
name|edata
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
name|edata
argument_list|)
expr_stmt|;
break|break;
case|case
name|IXGBE_DATA_NL
case|:
name|DEBUGOUT
argument_list|(
literal|"DATA:\n"
argument_list|)
expr_stmt|;
name|data_offset
operator|++
expr_stmt|;
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|data_offset
operator|++
argument_list|,
operator|&
name|phy_offset
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|edata
condition|;
name|i
operator|++
control|)
block|{
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|data_offset
argument_list|,
operator|&
name|eword
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|phy_offset
argument_list|,
name|IXGBE_TWINAX_DEV
argument_list|,
name|eword
argument_list|)
expr_stmt|;
name|DEBUGOUT2
argument_list|(
literal|"Wrote %4.4x to %4.4x\n"
argument_list|,
name|eword
argument_list|,
name|phy_offset
argument_list|)
expr_stmt|;
name|data_offset
operator|++
expr_stmt|;
name|phy_offset
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|IXGBE_CONTROL_NL
case|:
name|data_offset
operator|++
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"CONTROL:\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|edata
operator|==
name|IXGBE_CONTROL_EOL_NL
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"EOL\n"
argument_list|)
expr_stmt|;
name|end_data
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|edata
operator|==
name|IXGBE_CONTROL_SOL_NL
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"SOL\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"Bad control value\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|IXGBE_ERR_PHY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
break|break;
default|default:
name|DEBUGOUT
argument_list|(
literal|"Bad control type\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|IXGBE_ERR_PHY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_identify_module_generic - Identifies module type  *  @hw: pointer to hardware structure  *  *  Determines HW type and calls appropriate function.  **/
end_comment

begin_function
name|s32
name|ixgbe_identify_module_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_ERR_SFP_NOT_PRESENT
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_identify_module_generic"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|get_media_type
argument_list|(
name|hw
argument_list|)
condition|)
block|{
case|case
name|ixgbe_media_type_fiber
case|:
name|status
operator|=
name|ixgbe_identify_sfp_module_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
break|break;
default|default:
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|=
name|ixgbe_sfp_type_not_present
expr_stmt|;
name|status
operator|=
name|IXGBE_ERR_SFP_NOT_PRESENT
expr_stmt|;
break|break;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_identify_sfp_module_generic - Identifies SFP modules  *  @hw: pointer to hardware structure  *  *  Searches for and identifies the SFP module and assigns appropriate PHY type.  **/
end_comment

begin_function
name|s32
name|ixgbe_identify_sfp_module_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_ERR_PHY_ADDR_INVALID
decl_stmt|;
name|u32
name|vendor_oui
init|=
literal|0
decl_stmt|;
name|enum
name|ixgbe_sfp_type
name|stored_sfp_type
init|=
name|hw
operator|->
name|phy
operator|.
name|sfp_type
decl_stmt|;
name|u8
name|identifier
init|=
literal|0
decl_stmt|;
name|u8
name|comp_codes_1g
init|=
literal|0
decl_stmt|;
name|u8
name|comp_codes_10g
init|=
literal|0
decl_stmt|;
name|u8
name|oui_bytes
index|[
literal|3
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|u8
name|cable_tech
init|=
literal|0
decl_stmt|;
name|u8
name|cable_spec
init|=
literal|0
decl_stmt|;
name|u16
name|enforce_sfp
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_identify_sfp_module_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|get_media_type
argument_list|(
name|hw
argument_list|)
operator|!=
name|ixgbe_media_type_fiber
condition|)
block|{
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|=
name|ixgbe_sfp_type_not_present
expr_stmt|;
name|status
operator|=
name|IXGBE_ERR_SFP_NOT_PRESENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_i2c_eeprom
argument_list|(
name|hw
argument_list|,
name|IXGBE_SFF_IDENTIFIER
argument_list|,
operator|&
name|identifier
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|err_read_i2c_eeprom
goto|;
comment|/* LAN ID is needed for sfp_type determination */
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|set_lan_id
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|identifier
operator|!=
name|IXGBE_SFF_IDENTIFIER_SFP
condition|)
block|{
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|ixgbe_phy_sfp_unsupported
expr_stmt|;
name|status
operator|=
name|IXGBE_ERR_SFP_NOT_SUPPORTED
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_i2c_eeprom
argument_list|(
name|hw
argument_list|,
name|IXGBE_SFF_1GBE_COMP_CODES
argument_list|,
operator|&
name|comp_codes_1g
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|err_read_i2c_eeprom
goto|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_i2c_eeprom
argument_list|(
name|hw
argument_list|,
name|IXGBE_SFF_10GBE_COMP_CODES
argument_list|,
operator|&
name|comp_codes_10g
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|err_read_i2c_eeprom
goto|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_i2c_eeprom
argument_list|(
name|hw
argument_list|,
name|IXGBE_SFF_CABLE_TECHNOLOGY
argument_list|,
operator|&
name|cable_tech
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|err_read_i2c_eeprom
goto|;
comment|/* ID Module 		  * ========= 		  * 0   SFP_DA_CU 		  * 1   SFP_SR 		  * 2   SFP_LR 		  * 3   SFP_DA_CORE0 - 82599-specific 		  * 4   SFP_DA_CORE1 - 82599-specific 		  * 5   SFP_SR/LR_CORE0 - 82599-specific 		  * 6   SFP_SR/LR_CORE1 - 82599-specific 		  * 7   SFP_act_lmt_DA_CORE0 - 82599-specific 		  * 8   SFP_act_lmt_DA_CORE1 - 82599-specific 		  * 9   SFP_1g_cu_CORE0 - 82599-specific 		  * 10  SFP_1g_cu_CORE1 - 82599-specific 		  * 11  SFP_1g_sx_CORE0 - 82599-specific 		  * 12  SFP_1g_sx_CORE1 - 82599-specific 		  */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_82598EB
condition|)
block|{
if|if
condition|(
name|cable_tech
operator|&
name|IXGBE_SFF_DA_PASSIVE_CABLE
condition|)
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|=
name|ixgbe_sfp_type_da_cu
expr_stmt|;
elseif|else
if|if
condition|(
name|comp_codes_10g
operator|&
name|IXGBE_SFF_10GBASESR_CAPABLE
condition|)
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|=
name|ixgbe_sfp_type_sr
expr_stmt|;
elseif|else
if|if
condition|(
name|comp_codes_10g
operator|&
name|IXGBE_SFF_10GBASELR_CAPABLE
condition|)
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|=
name|ixgbe_sfp_type_lr
expr_stmt|;
else|else
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|=
name|ixgbe_sfp_type_unknown
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_82599EB
condition|)
block|{
if|if
condition|(
name|cable_tech
operator|&
name|IXGBE_SFF_DA_PASSIVE_CABLE
condition|)
block|{
if|if
condition|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
operator|==
literal|0
condition|)
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|=
name|ixgbe_sfp_type_da_cu_core0
expr_stmt|;
else|else
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|=
name|ixgbe_sfp_type_da_cu_core1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cable_tech
operator|&
name|IXGBE_SFF_DA_ACTIVE_CABLE
condition|)
block|{
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_i2c_eeprom
argument_list|(
name|hw
argument_list|,
name|IXGBE_SFF_CABLE_SPEC_COMP
argument_list|,
operator|&
name|cable_spec
argument_list|)
expr_stmt|;
if|if
condition|(
name|cable_spec
operator|&
name|IXGBE_SFF_DA_SPEC_ACTIVE_LIMITING
condition|)
block|{
if|if
condition|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
operator|==
literal|0
condition|)
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|=
name|ixgbe_sfp_type_da_act_lmt_core0
expr_stmt|;
else|else
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|=
name|ixgbe_sfp_type_da_act_lmt_core1
expr_stmt|;
block|}
else|else
block|{
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|=
name|ixgbe_sfp_type_unknown
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|comp_codes_10g
operator|&
operator|(
name|IXGBE_SFF_10GBASESR_CAPABLE
operator||
name|IXGBE_SFF_10GBASELR_CAPABLE
operator|)
condition|)
block|{
if|if
condition|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
operator|==
literal|0
condition|)
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|=
name|ixgbe_sfp_type_srlr_core0
expr_stmt|;
else|else
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|=
name|ixgbe_sfp_type_srlr_core1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|comp_codes_1g
operator|&
name|IXGBE_SFF_1GBASET_CAPABLE
condition|)
block|{
if|if
condition|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
operator|==
literal|0
condition|)
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|=
name|ixgbe_sfp_type_1g_cu_core0
expr_stmt|;
else|else
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|=
name|ixgbe_sfp_type_1g_cu_core1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|comp_codes_1g
operator|&
name|IXGBE_SFF_1GBASESX_CAPABLE
condition|)
block|{
if|if
condition|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
operator|==
literal|0
condition|)
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|=
name|ixgbe_sfp_type_1g_sx_core0
expr_stmt|;
else|else
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|=
name|ixgbe_sfp_type_1g_sx_core1
expr_stmt|;
block|}
else|else
block|{
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|=
name|ixgbe_sfp_type_unknown
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|!=
name|stored_sfp_type
condition|)
name|hw
operator|->
name|phy
operator|.
name|sfp_setup_needed
operator|=
name|TRUE
expr_stmt|;
comment|/* Determine if the SFP+ PHY is dual speed or not. */
name|hw
operator|->
name|phy
operator|.
name|multispeed_fiber
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|comp_codes_1g
operator|&
name|IXGBE_SFF_1GBASESX_CAPABLE
operator|)
operator|&&
operator|(
name|comp_codes_10g
operator|&
name|IXGBE_SFF_10GBASESR_CAPABLE
operator|)
operator|)
operator|||
operator|(
operator|(
name|comp_codes_1g
operator|&
name|IXGBE_SFF_1GBASELX_CAPABLE
operator|)
operator|&&
operator|(
name|comp_codes_10g
operator|&
name|IXGBE_SFF_10GBASELR_CAPABLE
operator|)
operator|)
condition|)
name|hw
operator|->
name|phy
operator|.
name|multispeed_fiber
operator|=
name|TRUE
expr_stmt|;
comment|/* Determine PHY vendor */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|!=
name|ixgbe_phy_nl
condition|)
block|{
name|hw
operator|->
name|phy
operator|.
name|id
operator|=
name|identifier
expr_stmt|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_i2c_eeprom
argument_list|(
name|hw
argument_list|,
name|IXGBE_SFF_VENDOR_OUI_BYTE0
argument_list|,
operator|&
name|oui_bytes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|err_read_i2c_eeprom
goto|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_i2c_eeprom
argument_list|(
name|hw
argument_list|,
name|IXGBE_SFF_VENDOR_OUI_BYTE1
argument_list|,
operator|&
name|oui_bytes
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|err_read_i2c_eeprom
goto|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_i2c_eeprom
argument_list|(
name|hw
argument_list|,
name|IXGBE_SFF_VENDOR_OUI_BYTE2
argument_list|,
operator|&
name|oui_bytes
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|err_read_i2c_eeprom
goto|;
name|vendor_oui
operator|=
operator|(
operator|(
name|oui_bytes
index|[
literal|0
index|]
operator|<<
name|IXGBE_SFF_VENDOR_OUI_BYTE0_SHIFT
operator|)
operator||
operator|(
name|oui_bytes
index|[
literal|1
index|]
operator|<<
name|IXGBE_SFF_VENDOR_OUI_BYTE1_SHIFT
operator|)
operator||
operator|(
name|oui_bytes
index|[
literal|2
index|]
operator|<<
name|IXGBE_SFF_VENDOR_OUI_BYTE2_SHIFT
operator|)
operator|)
expr_stmt|;
switch|switch
condition|(
name|vendor_oui
condition|)
block|{
case|case
name|IXGBE_SFF_VENDOR_OUI_TYCO
case|:
if|if
condition|(
name|cable_tech
operator|&
name|IXGBE_SFF_DA_PASSIVE_CABLE
condition|)
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|ixgbe_phy_sfp_passive_tyco
expr_stmt|;
break|break;
case|case
name|IXGBE_SFF_VENDOR_OUI_FTL
case|:
if|if
condition|(
name|cable_tech
operator|&
name|IXGBE_SFF_DA_ACTIVE_CABLE
condition|)
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|ixgbe_phy_sfp_ftl_active
expr_stmt|;
else|else
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|ixgbe_phy_sfp_ftl
expr_stmt|;
break|break;
case|case
name|IXGBE_SFF_VENDOR_OUI_AVAGO
case|:
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|ixgbe_phy_sfp_avago
expr_stmt|;
break|break;
case|case
name|IXGBE_SFF_VENDOR_OUI_INTEL
case|:
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|ixgbe_phy_sfp_intel
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|cable_tech
operator|&
name|IXGBE_SFF_DA_PASSIVE_CABLE
condition|)
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|ixgbe_phy_sfp_passive_unknown
expr_stmt|;
elseif|else
if|if
condition|(
name|cable_tech
operator|&
name|IXGBE_SFF_DA_ACTIVE_CABLE
condition|)
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|ixgbe_phy_sfp_active_unknown
expr_stmt|;
else|else
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|ixgbe_phy_sfp_unknown
expr_stmt|;
break|break;
block|}
block|}
comment|/* Allow any DA cable vendor */
if|if
condition|(
name|cable_tech
operator|&
operator|(
name|IXGBE_SFF_DA_PASSIVE_CABLE
operator||
name|IXGBE_SFF_DA_ACTIVE_CABLE
operator|)
condition|)
block|{
name|status
operator|=
name|IXGBE_SUCCESS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Verify supported 1G SFP modules */
if|if
condition|(
name|comp_codes_10g
operator|==
literal|0
operator|&&
operator|!
operator|(
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|==
name|ixgbe_sfp_type_1g_cu_core1
operator|||
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|==
name|ixgbe_sfp_type_1g_cu_core0
operator|||
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|==
name|ixgbe_sfp_type_1g_sx_core0
operator|||
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|==
name|ixgbe_sfp_type_1g_sx_core1
operator|)
condition|)
block|{
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|ixgbe_phy_sfp_unsupported
expr_stmt|;
name|status
operator|=
name|IXGBE_ERR_SFP_NOT_SUPPORTED
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Anything else 82598-based is supported */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_82598EB
condition|)
block|{
name|status
operator|=
name|IXGBE_SUCCESS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ixgbe_get_device_caps
argument_list|(
name|hw
argument_list|,
operator|&
name|enforce_sfp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|enforce_sfp
operator|&
name|IXGBE_DEVICE_CAPS_ALLOW_ANY_SFP
operator|)
operator|&&
operator|!
operator|(
operator|(
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|==
name|ixgbe_sfp_type_1g_cu_core0
operator|)
operator|||
operator|(
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|==
name|ixgbe_sfp_type_1g_cu_core1
operator|)
operator|||
operator|(
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|==
name|ixgbe_sfp_type_1g_sx_core0
operator|)
operator|||
operator|(
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|==
name|ixgbe_sfp_type_1g_sx_core1
operator|)
operator|)
condition|)
block|{
comment|/* Make sure we're a supported PHY type */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|ixgbe_phy_sfp_intel
condition|)
block|{
name|status
operator|=
name|IXGBE_SUCCESS
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|hw
operator|->
name|allow_unsupported_sfp
operator|==
name|TRUE
condition|)
block|{
name|EWARN
argument_list|(
name|hw
argument_list|,
literal|"WARNING: Intel (R) Network "
literal|"Connections are quality tested "
literal|"using Intel (R) Ethernet Optics."
literal|" Using untested modules is not "
literal|"supported and may cause unstable"
literal|" operation or damage to the "
literal|"module or the adapter. Intel "
literal|"Corporation is not responsible "
literal|"for any harm caused by using "
literal|"untested modules.\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|status
operator|=
name|IXGBE_SUCCESS
expr_stmt|;
block|}
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"SFP+ module not supported\n"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|ixgbe_phy_sfp_unsupported
expr_stmt|;
name|status
operator|=
name|IXGBE_ERR_SFP_NOT_SUPPORTED
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|status
operator|=
name|IXGBE_SUCCESS
expr_stmt|;
block|}
block|}
name|out
label|:
return|return
name|status
return|;
name|err_read_i2c_eeprom
label|:
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|=
name|ixgbe_sfp_type_not_present
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|!=
name|ixgbe_phy_nl
condition|)
block|{
name|hw
operator|->
name|phy
operator|.
name|id
operator|=
literal|0
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|ixgbe_phy_unknown
expr_stmt|;
block|}
return|return
name|IXGBE_ERR_SFP_NOT_PRESENT
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_sfp_init_sequence_offsets - Provides offset of PHY init sequence  *  @hw: pointer to hardware structure  *  @list_offset: offset to the SFP ID list  *  @data_offset: offset to the SFP data block  *  *  Checks the MAC's EEPROM to see if it supports a given SFP+ module type, if  *  so it returns the offsets to the phy init sequence block.  **/
end_comment

begin_function
name|s32
name|ixgbe_get_sfp_init_sequence_offsets
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|list_offset
parameter_list|,
name|u16
modifier|*
name|data_offset
parameter_list|)
block|{
name|u16
name|sfp_id
decl_stmt|;
name|u16
name|sfp_type
init|=
name|hw
operator|->
name|phy
operator|.
name|sfp_type
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_sfp_init_sequence_offsets"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|==
name|ixgbe_sfp_type_unknown
condition|)
return|return
name|IXGBE_ERR_SFP_NOT_SUPPORTED
return|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|==
name|ixgbe_sfp_type_not_present
condition|)
return|return
name|IXGBE_ERR_SFP_NOT_PRESENT
return|;
if|if
condition|(
operator|(
name|hw
operator|->
name|device_id
operator|==
name|IXGBE_DEV_ID_82598_SR_DUAL_PORT_EM
operator|)
operator|&&
operator|(
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|==
name|ixgbe_sfp_type_da_cu
operator|)
condition|)
return|return
name|IXGBE_ERR_SFP_NOT_SUPPORTED
return|;
comment|/* 	 * Limiting active cables and 1G Phys must be initialized as 	 * SR modules 	 */
if|if
condition|(
name|sfp_type
operator|==
name|ixgbe_sfp_type_da_act_lmt_core0
operator|||
name|sfp_type
operator|==
name|ixgbe_sfp_type_1g_cu_core0
operator|||
name|sfp_type
operator|==
name|ixgbe_sfp_type_1g_sx_core0
condition|)
name|sfp_type
operator|=
name|ixgbe_sfp_type_srlr_core0
expr_stmt|;
elseif|else
if|if
condition|(
name|sfp_type
operator|==
name|ixgbe_sfp_type_da_act_lmt_core1
operator|||
name|sfp_type
operator|==
name|ixgbe_sfp_type_1g_cu_core1
operator|||
name|sfp_type
operator|==
name|ixgbe_sfp_type_1g_sx_core1
condition|)
name|sfp_type
operator|=
name|ixgbe_sfp_type_srlr_core1
expr_stmt|;
comment|/* Read offset to PHY init contents */
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|IXGBE_PHY_INIT_OFFSET_NL
argument_list|,
name|list_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
operator|*
name|list_offset
operator|)
operator|||
operator|(
operator|*
name|list_offset
operator|==
literal|0xFFFF
operator|)
condition|)
return|return
name|IXGBE_ERR_SFP_NO_INIT_SEQ_PRESENT
return|;
comment|/* Shift offset to first ID word */
operator|(
operator|*
name|list_offset
operator|)
operator|++
expr_stmt|;
comment|/* 	 * Find the matching SFP ID in the EEPROM 	 * and program the init sequence 	 */
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
operator|*
name|list_offset
argument_list|,
operator|&
name|sfp_id
argument_list|)
expr_stmt|;
while|while
condition|(
name|sfp_id
operator|!=
name|IXGBE_PHY_INIT_END_NL
condition|)
block|{
if|if
condition|(
name|sfp_id
operator|==
name|sfp_type
condition|)
block|{
operator|(
operator|*
name|list_offset
operator|)
operator|++
expr_stmt|;
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
operator|*
name|list_offset
argument_list|,
name|data_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
operator|*
name|data_offset
operator|)
operator|||
operator|(
operator|*
name|data_offset
operator|==
literal|0xFFFF
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"SFP+ module not supported\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_SFP_NOT_SUPPORTED
return|;
block|}
else|else
block|{
break|break;
block|}
block|}
else|else
block|{
operator|(
operator|*
name|list_offset
operator|)
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
operator|*
name|list_offset
argument_list|,
operator|&
name|sfp_id
argument_list|)
condition|)
return|return
name|IXGBE_ERR_PHY
return|;
block|}
block|}
if|if
condition|(
name|sfp_id
operator|==
name|IXGBE_PHY_INIT_END_NL
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"No matching SFP+ module found\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_SFP_NOT_SUPPORTED
return|;
block|}
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_read_i2c_eeprom_generic - Reads 8 bit EEPROM word over I2C interface  *  @hw: pointer to hardware structure  *  @byte_offset: EEPROM byte offset to read  *  @eeprom_data: value read  *  *  Performs byte read operation to SFP module's EEPROM over I2C interface.  **/
end_comment

begin_function
name|s32
name|ixgbe_read_i2c_eeprom_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|byte_offset
parameter_list|,
name|u8
modifier|*
name|eeprom_data
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_read_i2c_eeprom_generic"
argument_list|)
expr_stmt|;
return|return
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_i2c_byte
argument_list|(
name|hw
argument_list|,
name|byte_offset
argument_list|,
name|IXGBE_I2C_EEPROM_DEV_ADDR
argument_list|,
name|eeprom_data
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_read_i2c_sff8472_generic - Reads 8 bit word over I2C interface  *  @hw: pointer to hardware structure  *  @byte_offset: byte offset at address 0xA2  *  @eeprom_data: value read  *  *  Performs byte read operation to SFP module's SFF-8472 data over I2C  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_read_i2c_sff8472_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|byte_offset
parameter_list|,
name|u8
modifier|*
name|sff8472_data
parameter_list|)
block|{
return|return
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_i2c_byte
argument_list|(
name|hw
argument_list|,
name|byte_offset
argument_list|,
name|IXGBE_I2C_EEPROM_DEV_ADDR2
argument_list|,
name|sff8472_data
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_write_i2c_eeprom_generic - Writes 8 bit EEPROM word over I2C interface  *  @hw: pointer to hardware structure  *  @byte_offset: EEPROM byte offset to write  *  @eeprom_data: value to write  *  *  Performs byte write operation to SFP module's EEPROM over I2C interface.  **/
end_comment

begin_function
name|s32
name|ixgbe_write_i2c_eeprom_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|byte_offset
parameter_list|,
name|u8
name|eeprom_data
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_write_i2c_eeprom_generic"
argument_list|)
expr_stmt|;
return|return
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_i2c_byte
argument_list|(
name|hw
argument_list|,
name|byte_offset
argument_list|,
name|IXGBE_I2C_EEPROM_DEV_ADDR
argument_list|,
name|eeprom_data
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_read_i2c_byte_generic - Reads 8 bit word over I2C  *  @hw: pointer to hardware structure  *  @byte_offset: byte offset to read  *  @data: value read  *  *  Performs byte read operation to SFP module's EEPROM over I2C interface at  *  a specified device address.  **/
end_comment

begin_function
name|s32
name|ixgbe_read_i2c_byte_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|byte_offset
parameter_list|,
name|u8
name|dev_addr
parameter_list|,
name|u8
modifier|*
name|data
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u32
name|max_retry
init|=
literal|10
decl_stmt|;
name|u32
name|retry
init|=
literal|0
decl_stmt|;
name|u16
name|swfw_mask
init|=
literal|0
decl_stmt|;
name|bool
name|nack
init|=
literal|1
decl_stmt|;
operator|*
name|data
operator|=
literal|0
expr_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_read_i2c_byte_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_STATUS
argument_list|)
operator|&
name|IXGBE_STATUS_LAN_ID_1
condition|)
name|swfw_mask
operator|=
name|IXGBE_GSSR_PHY1_SM
expr_stmt|;
else|else
name|swfw_mask
operator|=
name|IXGBE_GSSR_PHY0_SM
expr_stmt|;
do|do
block|{
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|acquire_swfw_sync
argument_list|(
name|hw
argument_list|,
name|swfw_mask
argument_list|)
operator|!=
name|IXGBE_SUCCESS
condition|)
block|{
name|status
operator|=
name|IXGBE_ERR_SWFW_SYNC
expr_stmt|;
goto|goto
name|read_byte_out
goto|;
block|}
name|ixgbe_i2c_start
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Device Address and write indication */
name|status
operator|=
name|ixgbe_clock_out_i2c_byte
argument_list|(
name|hw
argument_list|,
name|dev_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|fail
goto|;
name|status
operator|=
name|ixgbe_get_i2c_ack
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|fail
goto|;
name|status
operator|=
name|ixgbe_clock_out_i2c_byte
argument_list|(
name|hw
argument_list|,
name|byte_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|fail
goto|;
name|status
operator|=
name|ixgbe_get_i2c_ack
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|fail
goto|;
name|ixgbe_i2c_start
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Device Address and read indication */
name|status
operator|=
name|ixgbe_clock_out_i2c_byte
argument_list|(
name|hw
argument_list|,
operator|(
name|dev_addr
operator||
literal|0x1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|fail
goto|;
name|status
operator|=
name|ixgbe_get_i2c_ack
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|fail
goto|;
name|status
operator|=
name|ixgbe_clock_in_i2c_byte
argument_list|(
name|hw
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|fail
goto|;
name|status
operator|=
name|ixgbe_clock_out_i2c_bit
argument_list|(
name|hw
argument_list|,
name|nack
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|fail
goto|;
name|ixgbe_i2c_stop
argument_list|(
name|hw
argument_list|)
expr_stmt|;
break|break;
name|fail
label|:
name|ixgbe_i2c_bus_clear
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|swfw_mask
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|retry
operator|++
expr_stmt|;
if|if
condition|(
name|retry
operator|<
name|max_retry
condition|)
name|DEBUGOUT
argument_list|(
literal|"I2C byte read error - Retrying.\n"
argument_list|)
expr_stmt|;
else|else
name|DEBUGOUT
argument_list|(
literal|"I2C byte read error.\n"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|retry
operator|<
name|max_retry
condition|)
do|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|swfw_mask
argument_list|)
expr_stmt|;
name|read_byte_out
label|:
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_write_i2c_byte_generic - Writes 8 bit word over I2C  *  @hw: pointer to hardware structure  *  @byte_offset: byte offset to write  *  @data: value to write  *  *  Performs byte write operation to SFP module's EEPROM over I2C interface at  *  a specified device address.  **/
end_comment

begin_function
name|s32
name|ixgbe_write_i2c_byte_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|byte_offset
parameter_list|,
name|u8
name|dev_addr
parameter_list|,
name|u8
name|data
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u32
name|max_retry
init|=
literal|1
decl_stmt|;
name|u32
name|retry
init|=
literal|0
decl_stmt|;
name|u16
name|swfw_mask
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_write_i2c_byte_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_STATUS
argument_list|)
operator|&
name|IXGBE_STATUS_LAN_ID_1
condition|)
name|swfw_mask
operator|=
name|IXGBE_GSSR_PHY1_SM
expr_stmt|;
else|else
name|swfw_mask
operator|=
name|IXGBE_GSSR_PHY0_SM
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|acquire_swfw_sync
argument_list|(
name|hw
argument_list|,
name|swfw_mask
argument_list|)
operator|!=
name|IXGBE_SUCCESS
condition|)
block|{
name|status
operator|=
name|IXGBE_ERR_SWFW_SYNC
expr_stmt|;
goto|goto
name|write_byte_out
goto|;
block|}
do|do
block|{
name|ixgbe_i2c_start
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|status
operator|=
name|ixgbe_clock_out_i2c_byte
argument_list|(
name|hw
argument_list|,
name|dev_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|fail
goto|;
name|status
operator|=
name|ixgbe_get_i2c_ack
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|fail
goto|;
name|status
operator|=
name|ixgbe_clock_out_i2c_byte
argument_list|(
name|hw
argument_list|,
name|byte_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|fail
goto|;
name|status
operator|=
name|ixgbe_get_i2c_ack
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|fail
goto|;
name|status
operator|=
name|ixgbe_clock_out_i2c_byte
argument_list|(
name|hw
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|fail
goto|;
name|status
operator|=
name|ixgbe_get_i2c_ack
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|fail
goto|;
name|ixgbe_i2c_stop
argument_list|(
name|hw
argument_list|)
expr_stmt|;
break|break;
name|fail
label|:
name|ixgbe_i2c_bus_clear
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|retry
operator|++
expr_stmt|;
if|if
condition|(
name|retry
operator|<
name|max_retry
condition|)
name|DEBUGOUT
argument_list|(
literal|"I2C byte write error - Retrying.\n"
argument_list|)
expr_stmt|;
else|else
name|DEBUGOUT
argument_list|(
literal|"I2C byte write error.\n"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|retry
operator|<
name|max_retry
condition|)
do|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|swfw_mask
argument_list|)
expr_stmt|;
name|write_byte_out
label|:
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_i2c_start - Sets I2C start condition  *  @hw: pointer to hardware structure  *  *  Sets I2C start condition (High -> Low on SDA while SCL is High)  **/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_i2c_start
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|i2cctl
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_I2CCTL
argument_list|)
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_i2c_start"
argument_list|)
expr_stmt|;
comment|/* Start condition must begin with data and clock high */
name|ixgbe_set_i2c_data
argument_list|(
name|hw
argument_list|,
operator|&
name|i2cctl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ixgbe_raise_i2c_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|i2cctl
argument_list|)
expr_stmt|;
comment|/* Setup time for start condition (4.7us) */
name|usec_delay
argument_list|(
name|IXGBE_I2C_T_SU_STA
argument_list|)
expr_stmt|;
name|ixgbe_set_i2c_data
argument_list|(
name|hw
argument_list|,
operator|&
name|i2cctl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Hold time for start condition (4us) */
name|usec_delay
argument_list|(
name|IXGBE_I2C_T_HD_STA
argument_list|)
expr_stmt|;
name|ixgbe_lower_i2c_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|i2cctl
argument_list|)
expr_stmt|;
comment|/* Minimum low period of clock is 4.7 us */
name|usec_delay
argument_list|(
name|IXGBE_I2C_T_LOW
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_i2c_stop - Sets I2C stop condition  *  @hw: pointer to hardware structure  *  *  Sets I2C stop condition (Low -> High on SDA while SCL is High)  **/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_i2c_stop
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|i2cctl
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_I2CCTL
argument_list|)
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_i2c_stop"
argument_list|)
expr_stmt|;
comment|/* Stop condition must begin with data low and clock high */
name|ixgbe_set_i2c_data
argument_list|(
name|hw
argument_list|,
operator|&
name|i2cctl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ixgbe_raise_i2c_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|i2cctl
argument_list|)
expr_stmt|;
comment|/* Setup time for stop condition (4us) */
name|usec_delay
argument_list|(
name|IXGBE_I2C_T_SU_STO
argument_list|)
expr_stmt|;
name|ixgbe_set_i2c_data
argument_list|(
name|hw
argument_list|,
operator|&
name|i2cctl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* bus free time between stop and start (4.7us)*/
name|usec_delay
argument_list|(
name|IXGBE_I2C_T_BUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_clock_in_i2c_byte - Clocks in one byte via I2C  *  @hw: pointer to hardware structure  *  @data: data byte to clock in  *  *  Clocks in one byte data via I2C data/clock  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_clock_in_i2c_byte
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|data
parameter_list|)
block|{
name|s32
name|i
decl_stmt|;
name|bool
name|bit
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_clock_in_i2c_byte"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|7
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|ixgbe_clock_in_i2c_bit
argument_list|(
name|hw
argument_list|,
operator|&
name|bit
argument_list|)
expr_stmt|;
operator|*
name|data
operator||=
name|bit
operator|<<
name|i
expr_stmt|;
block|}
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_clock_out_i2c_byte - Clocks out one byte via I2C  *  @hw: pointer to hardware structure  *  @data: data byte clocked out  *  *  Clocks out one byte data via I2C data/clock  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_clock_out_i2c_byte
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|data
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|s32
name|i
decl_stmt|;
name|u32
name|i2cctl
decl_stmt|;
name|bool
name|bit
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_clock_out_i2c_byte"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|7
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|bit
operator|=
operator|(
name|data
operator|>>
name|i
operator|)
operator|&
literal|0x1
expr_stmt|;
name|status
operator|=
name|ixgbe_clock_out_i2c_bit
argument_list|(
name|hw
argument_list|,
name|bit
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
break|break;
block|}
comment|/* Release SDA line (set high) */
name|i2cctl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_I2CCTL
argument_list|)
expr_stmt|;
name|i2cctl
operator||=
name|IXGBE_I2C_DATA_OUT
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_I2CCTL
argument_list|,
name|i2cctl
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_i2c_ack - Polls for I2C ACK  *  @hw: pointer to hardware structure  *  *  Clocks in/out one bit via I2C data/clock  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_get_i2c_ack
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u32
name|i
init|=
literal|0
decl_stmt|;
name|u32
name|i2cctl
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_I2CCTL
argument_list|)
decl_stmt|;
name|u32
name|timeout
init|=
literal|10
decl_stmt|;
name|bool
name|ack
init|=
literal|1
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_i2c_ack"
argument_list|)
expr_stmt|;
name|ixgbe_raise_i2c_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|i2cctl
argument_list|)
expr_stmt|;
comment|/* Minimum high period of clock is 4us */
name|usec_delay
argument_list|(
name|IXGBE_I2C_T_HIGH
argument_list|)
expr_stmt|;
comment|/* Poll for ACK.  Note that ACK in I2C spec is 	 * transition from 1 to 0 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|timeout
condition|;
name|i
operator|++
control|)
block|{
name|i2cctl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_I2CCTL
argument_list|)
expr_stmt|;
name|ack
operator|=
name|ixgbe_get_i2c_data
argument_list|(
operator|&
name|i2cctl
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ack
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|ack
operator|==
literal|1
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"I2C ack was not received.\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IXGBE_ERR_I2C
expr_stmt|;
block|}
name|ixgbe_lower_i2c_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|i2cctl
argument_list|)
expr_stmt|;
comment|/* Minimum low period of clock is 4.7 us */
name|usec_delay
argument_list|(
name|IXGBE_I2C_T_LOW
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_clock_in_i2c_bit - Clocks in one bit via I2C data/clock  *  @hw: pointer to hardware structure  *  @data: read data value  *  *  Clocks in one bit via I2C data/clock  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_clock_in_i2c_bit
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|bool
modifier|*
name|data
parameter_list|)
block|{
name|u32
name|i2cctl
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_I2CCTL
argument_list|)
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_clock_in_i2c_bit"
argument_list|)
expr_stmt|;
name|ixgbe_raise_i2c_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|i2cctl
argument_list|)
expr_stmt|;
comment|/* Minimum high period of clock is 4us */
name|usec_delay
argument_list|(
name|IXGBE_I2C_T_HIGH
argument_list|)
expr_stmt|;
name|i2cctl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_I2CCTL
argument_list|)
expr_stmt|;
operator|*
name|data
operator|=
name|ixgbe_get_i2c_data
argument_list|(
operator|&
name|i2cctl
argument_list|)
expr_stmt|;
name|ixgbe_lower_i2c_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|i2cctl
argument_list|)
expr_stmt|;
comment|/* Minimum low period of clock is 4.7 us */
name|usec_delay
argument_list|(
name|IXGBE_I2C_T_LOW
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_clock_out_i2c_bit - Clocks in/out one bit via I2C data/clock  *  @hw: pointer to hardware structure  *  @data: data value to write  *  *  Clocks out one bit via I2C data/clock  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_clock_out_i2c_bit
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|data
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|u32
name|i2cctl
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_I2CCTL
argument_list|)
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_clock_out_i2c_bit"
argument_list|)
expr_stmt|;
name|status
operator|=
name|ixgbe_set_i2c_data
argument_list|(
name|hw
argument_list|,
operator|&
name|i2cctl
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
condition|)
block|{
name|ixgbe_raise_i2c_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|i2cctl
argument_list|)
expr_stmt|;
comment|/* Minimum high period of clock is 4us */
name|usec_delay
argument_list|(
name|IXGBE_I2C_T_HIGH
argument_list|)
expr_stmt|;
name|ixgbe_lower_i2c_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|i2cctl
argument_list|)
expr_stmt|;
comment|/* Minimum low period of clock is 4.7 us. 		 * This also takes care of the data hold time. 		 */
name|usec_delay
argument_list|(
name|IXGBE_I2C_T_LOW
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|IXGBE_ERR_I2C
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"I2C data was not set to %X\n"
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_raise_i2c_clk - Raises the I2C SCL clock  *  @hw: pointer to hardware structure  *  @i2cctl: Current value of I2CCTL register  *  *  Raises the I2C clock line '0'->'1'  **/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_raise_i2c_clk
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|i2cctl
parameter_list|)
block|{
name|u32
name|i
init|=
literal|0
decl_stmt|;
name|u32
name|timeout
init|=
name|IXGBE_I2C_CLOCK_STRETCHING_TIMEOUT
decl_stmt|;
name|u32
name|i2cctl_r
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_raise_i2c_clk"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|timeout
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|i2cctl
operator||=
name|IXGBE_I2C_CLK_OUT
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_I2CCTL
argument_list|,
operator|*
name|i2cctl
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* SCL rise time (1000ns) */
name|usec_delay
argument_list|(
name|IXGBE_I2C_T_RISE
argument_list|)
expr_stmt|;
name|i2cctl_r
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_I2CCTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|i2cctl_r
operator|&
name|IXGBE_I2C_CLK_IN
condition|)
break|break;
block|}
block|}
end_function

begin_comment
comment|/**  *  ixgbe_lower_i2c_clk - Lowers the I2C SCL clock  *  @hw: pointer to hardware structure  *  @i2cctl: Current value of I2CCTL register  *  *  Lowers the I2C clock line '1'->'0'  **/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_lower_i2c_clk
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|i2cctl
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_lower_i2c_clk"
argument_list|)
expr_stmt|;
operator|*
name|i2cctl
operator|&=
operator|~
name|IXGBE_I2C_CLK_OUT
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_I2CCTL
argument_list|,
operator|*
name|i2cctl
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* SCL fall time (300ns) */
name|usec_delay
argument_list|(
name|IXGBE_I2C_T_FALL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_set_i2c_data - Sets the I2C data bit  *  @hw: pointer to hardware structure  *  @i2cctl: Current value of I2CCTL register  *  @data: I2C data value (0 or 1) to set  *  *  Sets the I2C data bit  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_set_i2c_data
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|i2cctl
parameter_list|,
name|bool
name|data
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_set_i2c_data"
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
condition|)
operator|*
name|i2cctl
operator||=
name|IXGBE_I2C_DATA_OUT
expr_stmt|;
else|else
operator|*
name|i2cctl
operator|&=
operator|~
name|IXGBE_I2C_DATA_OUT
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_I2CCTL
argument_list|,
operator|*
name|i2cctl
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Data rise/fall (1000ns/300ns) and set-up time (250ns) */
name|usec_delay
argument_list|(
name|IXGBE_I2C_T_RISE
operator|+
name|IXGBE_I2C_T_FALL
operator|+
name|IXGBE_I2C_T_SU_DATA
argument_list|)
expr_stmt|;
comment|/* Verify data was set correctly */
operator|*
name|i2cctl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_I2CCTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|!=
name|ixgbe_get_i2c_data
argument_list|(
name|i2cctl
argument_list|)
condition|)
block|{
name|status
operator|=
name|IXGBE_ERR_I2C
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"Error - I2C data was not set to %X.\n"
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_i2c_data - Reads the I2C SDA data bit  *  @hw: pointer to hardware structure  *  @i2cctl: Current value of I2CCTL register  *  *  Returns the I2C data bit value  **/
end_comment

begin_function
specifier|static
name|bool
name|ixgbe_get_i2c_data
parameter_list|(
name|u32
modifier|*
name|i2cctl
parameter_list|)
block|{
name|bool
name|data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_i2c_data"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|i2cctl
operator|&
name|IXGBE_I2C_DATA_IN
condition|)
name|data
operator|=
literal|1
expr_stmt|;
else|else
name|data
operator|=
literal|0
expr_stmt|;
return|return
name|data
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_i2c_bus_clear - Clears the I2C bus  *  @hw: pointer to hardware structure  *  *  Clears the I2C bus by sending nine clock pulses.  *  Used when data line is stuck low.  **/
end_comment

begin_function
name|void
name|ixgbe_i2c_bus_clear
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|i2cctl
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_I2CCTL
argument_list|)
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_i2c_bus_clear"
argument_list|)
expr_stmt|;
name|ixgbe_i2c_start
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|ixgbe_set_i2c_data
argument_list|(
name|hw
argument_list|,
operator|&
name|i2cctl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|9
condition|;
name|i
operator|++
control|)
block|{
name|ixgbe_raise_i2c_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|i2cctl
argument_list|)
expr_stmt|;
comment|/* Min high period of clock is 4us */
name|usec_delay
argument_list|(
name|IXGBE_I2C_T_HIGH
argument_list|)
expr_stmt|;
name|ixgbe_lower_i2c_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|i2cctl
argument_list|)
expr_stmt|;
comment|/* Min low period of clock is 4.7us*/
name|usec_delay
argument_list|(
name|IXGBE_I2C_T_LOW
argument_list|)
expr_stmt|;
block|}
name|ixgbe_i2c_start
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Put the i2c bus back to default state */
name|ixgbe_i2c_stop
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_tn_check_overtemp - Checks if an overtemp occurred.  *  @hw: pointer to hardware structure  *  *  Checks if the LASI temp alarm status was triggered due to overtemp  **/
end_comment

begin_function
name|s32
name|ixgbe_tn_check_overtemp
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u16
name|phy_data
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_tn_check_overtemp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|device_id
operator|!=
name|IXGBE_DEV_ID_82599_T3_LOM
condition|)
goto|goto
name|out
goto|;
comment|/* Check that the LASI temp alarm status was triggered */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_TN_LASI_STATUS_REG
argument_list|,
name|IXGBE_MDIO_PMA_PMD_DEV_TYPE
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|phy_data
operator|&
name|IXGBE_TN_LASI_STATUS_TEMP_ALARM
operator|)
condition|)
goto|goto
name|out
goto|;
name|status
operator|=
name|IXGBE_ERR_OVERTEMP
expr_stmt|;
name|out
label|:
return|return
name|status
return|;
block|}
end_function

end_unit

