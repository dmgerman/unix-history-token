begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************    Copyright (c) 2001-2009, Intel Corporation    All rights reserved.      Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are met:       1. Redistributions of source code must retain the above copyright notice,        this list of conditions and the following disclaimer.       2. Redistributions in binary form must reproduce the above copyright        notice, this list of conditions and the following disclaimer in the        documentation and/or other materials provided with the distribution.       3. Neither the name of the Intel Corporation nor the names of its        contributors may be used to endorse or promote products derived from        this software without specific prior written permission.      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  ******************************************************************************/
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_include
include|#
directive|include
file|"ixgbe_common.h"
end_include

begin_include
include|#
directive|include
file|"ixgbe_api.h"
end_include

begin_function_decl
specifier|static
name|s32
name|ixgbe_acquire_eeprom
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|ixgbe_get_eeprom_semaphore
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_release_eeprom_semaphore
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|ixgbe_ready_eeprom
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_standby_eeprom
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_shift_out_eeprom_bits
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|data
parameter_list|,
name|u16
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u16
name|ixgbe_shift_in_eeprom_bits
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_raise_eeprom_clk
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|eec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_lower_eeprom_clk
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|eec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_release_eeprom
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|ixgbe_mta_vector
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|mc_addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|ixgbe_get_san_mac_addr_offset
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|san_mac_offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|s32
name|ixgbe_find_vlvf_slot
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|vlan
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  *  ixgbe_init_ops_generic - Inits function ptrs  *  @hw: pointer to the hardware structure  *  *  Initialize the function pointers.  **/
end_comment

begin_function
name|s32
name|ixgbe_init_ops_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|ixgbe_eeprom_info
modifier|*
name|eeprom
init|=
operator|&
name|hw
operator|->
name|eeprom
decl_stmt|;
name|struct
name|ixgbe_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|u32
name|eec
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC
argument_list|)
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_init_ops_generic"
argument_list|)
expr_stmt|;
comment|/* EEPROM */
name|eeprom
operator|->
name|ops
operator|.
name|init_params
operator|=
operator|&
name|ixgbe_init_eeprom_params_generic
expr_stmt|;
comment|/* If EEPROM is valid (bit 8 = 1), use EERD otherwise use bit bang */
if|if
condition|(
name|eec
operator|&
operator|(
literal|1
operator|<<
literal|8
operator|)
condition|)
name|eeprom
operator|->
name|ops
operator|.
name|read
operator|=
operator|&
name|ixgbe_read_eerd_generic
expr_stmt|;
else|else
name|eeprom
operator|->
name|ops
operator|.
name|read
operator|=
operator|&
name|ixgbe_read_eeprom_bit_bang_generic
expr_stmt|;
name|eeprom
operator|->
name|ops
operator|.
name|write
operator|=
operator|&
name|ixgbe_write_eeprom_generic
expr_stmt|;
name|eeprom
operator|->
name|ops
operator|.
name|validate_checksum
operator|=
operator|&
name|ixgbe_validate_eeprom_checksum_generic
expr_stmt|;
name|eeprom
operator|->
name|ops
operator|.
name|update_checksum
operator|=
operator|&
name|ixgbe_update_eeprom_checksum_generic
expr_stmt|;
name|eeprom
operator|->
name|ops
operator|.
name|calc_checksum
operator|=
operator|&
name|ixgbe_calc_eeprom_checksum_generic
expr_stmt|;
comment|/* MAC */
name|mac
operator|->
name|ops
operator|.
name|init_hw
operator|=
operator|&
name|ixgbe_init_hw_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|reset_hw
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|start_hw
operator|=
operator|&
name|ixgbe_start_hw_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|clear_hw_cntrs
operator|=
operator|&
name|ixgbe_clear_hw_cntrs_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_media_type
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_supported_physical_layer
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|enable_rx_dma
operator|=
operator|&
name|ixgbe_enable_rx_dma_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_mac_addr
operator|=
operator|&
name|ixgbe_get_mac_addr_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|stop_adapter
operator|=
operator|&
name|ixgbe_stop_adapter_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_bus_info
operator|=
operator|&
name|ixgbe_get_bus_info_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|set_lan_id
operator|=
operator|&
name|ixgbe_set_lan_id_multi_port_pcie
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|acquire_swfw_sync
operator|=
operator|&
name|ixgbe_acquire_swfw_sync
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|release_swfw_sync
operator|=
operator|&
name|ixgbe_release_swfw_sync
expr_stmt|;
comment|/* LEDs */
name|mac
operator|->
name|ops
operator|.
name|led_on
operator|=
operator|&
name|ixgbe_led_on_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|led_off
operator|=
operator|&
name|ixgbe_led_off_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|blink_led_start
operator|=
operator|&
name|ixgbe_blink_led_start_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|blink_led_stop
operator|=
operator|&
name|ixgbe_blink_led_stop_generic
expr_stmt|;
comment|/* RAR, Multicast, VLAN */
name|mac
operator|->
name|ops
operator|.
name|set_rar
operator|=
operator|&
name|ixgbe_set_rar_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|clear_rar
operator|=
operator|&
name|ixgbe_clear_rar_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|insert_mac_addr
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|set_vmdq
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|clear_vmdq
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|init_rx_addrs
operator|=
operator|&
name|ixgbe_init_rx_addrs_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|update_uc_addr_list
operator|=
operator|&
name|ixgbe_update_uc_addr_list_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|update_mc_addr_list
operator|=
operator|&
name|ixgbe_update_mc_addr_list_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|enable_mc
operator|=
operator|&
name|ixgbe_enable_mc_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|disable_mc
operator|=
operator|&
name|ixgbe_disable_mc_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|clear_vfta
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|set_vfta
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|init_uta_tables
operator|=
name|NULL
expr_stmt|;
comment|/* Flow Control */
name|mac
operator|->
name|ops
operator|.
name|fc_enable
operator|=
operator|&
name|ixgbe_fc_enable_generic
expr_stmt|;
comment|/* Link */
name|mac
operator|->
name|ops
operator|.
name|get_link_capabilities
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|setup_link
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|check_link
operator|=
name|NULL
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_start_hw_generic - Prepare hardware for Tx/Rx  *  @hw: pointer to hardware structure  *  *  Starts the hardware by filling the bus info structure and media type, clears  *  all on chip counters, initializes receive address registers, multicast  *  table, VLAN filter table, calls routine to set up link and flow control  *  settings, and leaves transmit and receive units disabled and uninitialized  **/
end_comment

begin_function
name|s32
name|ixgbe_start_hw_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|ctrl_ext
decl_stmt|;
name|s32
name|ret_val
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_start_hw_generic"
argument_list|)
expr_stmt|;
comment|/* Set the media type */
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|get_media_type
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* PHY ops initialization must be done in reset_hw() */
comment|/* Clear the VLAN filter table */
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|clear_vfta
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Clear statistics registers */
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|clear_hw_cntrs
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Set No Snoop Disable */
name|ctrl_ext
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CTRL_EXT
argument_list|)
expr_stmt|;
name|ctrl_ext
operator||=
name|IXGBE_CTRL_EXT_NS_DIS
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CTRL_EXT
argument_list|,
name|ctrl_ext
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Setup flow control */
name|ixgbe_setup_fc
argument_list|(
name|hw
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Clear adapter stopped flag */
name|hw
operator|->
name|adapter_stopped
operator|=
name|FALSE
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_init_hw_generic - Generic hardware initialization  *  @hw: pointer to hardware structure  *  *  Initialize the hardware by resetting the hardware, filling the bus info  *  structure and media type, clears all on chip counters, initializes receive  *  address registers, multicast table, VLAN filter table, calls routine to set  *  up link and flow control settings, and leaves transmit and receive units  *  disabled and uninitialized  **/
end_comment

begin_function
name|s32
name|ixgbe_init_hw_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_init_hw_generic"
argument_list|)
expr_stmt|;
comment|/* Reset the hardware */
name|status
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|reset_hw
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
condition|)
block|{
comment|/* Start the HW */
name|status
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|start_hw
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_clear_hw_cntrs_generic - Generic clear hardware counters  *  @hw: pointer to hardware structure  *  *  Clears all hardware statistics counters by reading them from the hardware  *  Statistics counters are clear on read.  **/
end_comment

begin_function
name|s32
name|ixgbe_clear_hw_cntrs_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u16
name|i
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_clear_hw_cntrs_generic"
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CRCERRS
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ILLERRC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ERRBC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MSPDC
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MPC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MLFC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MRFC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RLEC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LXONTXC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LXOFFTXC
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|>=
name|ixgbe_mac_82599EB
condition|)
block|{
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LXONRXCNT
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LXOFFRXCNT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LXONRXC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LXOFFRXC
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PXONTXC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PXOFFTXC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|>=
name|ixgbe_mac_82599EB
condition|)
block|{
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PXONRXCNT
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PXOFFRXCNT
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PXONRXC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PXOFFRXC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|>=
name|ixgbe_mac_82599EB
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PXON2OFFCNT
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PRC64
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PRC127
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PRC255
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PRC511
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PRC1023
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PRC1522
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GPRC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_BPRC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MPRC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GPTC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GORCL
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GORCH
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GOTCL
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GOTCH
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RNBC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RUC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RFC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ROC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RJC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MNGPRC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MNGPDC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MNGPTC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_TORL
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_TORH
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_TPR
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_TPT
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PTC64
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PTC127
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PTC255
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PTC511
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PTC1023
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PTC1522
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MPTC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_BPTC
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_QPRC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_QBRC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_QPTC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_QBTC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_read_pba_num_generic - Reads part number from EEPROM  *  @hw: pointer to hardware structure  *  @pba_num: stores the part number from the EEPROM  *  *  Reads the part number from the EEPROM.  **/
end_comment

begin_function
name|s32
name|ixgbe_read_pba_num_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|pba_num
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u16
name|data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_read_pba_num_generic"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|IXGBE_PBANUM0_PTR
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"NVM Read Error\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
operator|*
name|pba_num
operator|=
call|(
name|u32
call|)
argument_list|(
name|data
operator|<<
literal|16
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|IXGBE_PBANUM1_PTR
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"NVM Read Error\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
operator|*
name|pba_num
operator||=
name|data
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_mac_addr_generic - Generic get MAC address  *  @hw: pointer to hardware structure  *  @mac_addr: Adapter MAC address  *  *  Reads the adapter's MAC address from first Receive Address Register (RAR0)  *  A reset of the adapter must be performed prior to calling this function  *  in order for the MAC address to have been loaded from the EEPROM into RAR0  **/
end_comment

begin_function
name|s32
name|ixgbe_get_mac_addr_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|mac_addr
parameter_list|)
block|{
name|u32
name|rar_high
decl_stmt|;
name|u32
name|rar_low
decl_stmt|;
name|u16
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_mac_addr_generic"
argument_list|)
expr_stmt|;
name|rar_high
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RAH
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|rar_low
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RAL
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|mac_addr
index|[
name|i
index|]
operator|=
call|(
name|u8
call|)
argument_list|(
name|rar_low
operator|>>
operator|(
name|i
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
name|mac_addr
index|[
name|i
operator|+
literal|4
index|]
operator|=
call|(
name|u8
call|)
argument_list|(
name|rar_high
operator|>>
operator|(
name|i
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_bus_info_generic - Generic set PCI bus info  *  @hw: pointer to hardware structure  *  *  Sets the PCI bus info (speed, width, type) within the ixgbe_hw structure  **/
end_comment

begin_function
name|s32
name|ixgbe_get_bus_info_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|ixgbe_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|u16
name|link_status
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_bus_info_generic"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|bus
operator|.
name|type
operator|=
name|ixgbe_bus_type_pci_express
expr_stmt|;
comment|/* Get the negotiated link width and speed from PCI config space */
name|link_status
operator|=
name|IXGBE_READ_PCIE_WORD
argument_list|(
name|hw
argument_list|,
name|IXGBE_PCI_LINK_STATUS
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|link_status
operator|&
name|IXGBE_PCI_LINK_WIDTH
condition|)
block|{
case|case
name|IXGBE_PCI_LINK_WIDTH_1
case|:
name|hw
operator|->
name|bus
operator|.
name|width
operator|=
name|ixgbe_bus_width_pcie_x1
expr_stmt|;
break|break;
case|case
name|IXGBE_PCI_LINK_WIDTH_2
case|:
name|hw
operator|->
name|bus
operator|.
name|width
operator|=
name|ixgbe_bus_width_pcie_x2
expr_stmt|;
break|break;
case|case
name|IXGBE_PCI_LINK_WIDTH_4
case|:
name|hw
operator|->
name|bus
operator|.
name|width
operator|=
name|ixgbe_bus_width_pcie_x4
expr_stmt|;
break|break;
case|case
name|IXGBE_PCI_LINK_WIDTH_8
case|:
name|hw
operator|->
name|bus
operator|.
name|width
operator|=
name|ixgbe_bus_width_pcie_x8
expr_stmt|;
break|break;
default|default:
name|hw
operator|->
name|bus
operator|.
name|width
operator|=
name|ixgbe_bus_width_unknown
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|link_status
operator|&
name|IXGBE_PCI_LINK_SPEED
condition|)
block|{
case|case
name|IXGBE_PCI_LINK_SPEED_2500
case|:
name|hw
operator|->
name|bus
operator|.
name|speed
operator|=
name|ixgbe_bus_speed_2500
expr_stmt|;
break|break;
case|case
name|IXGBE_PCI_LINK_SPEED_5000
case|:
name|hw
operator|->
name|bus
operator|.
name|speed
operator|=
name|ixgbe_bus_speed_5000
expr_stmt|;
break|break;
default|default:
name|hw
operator|->
name|bus
operator|.
name|speed
operator|=
name|ixgbe_bus_speed_unknown
expr_stmt|;
break|break;
block|}
name|mac
operator|->
name|ops
operator|.
name|set_lan_id
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_set_lan_id_multi_port_pcie - Set LAN id for PCIe multiple port devices  *  @hw: pointer to the HW structure  *  *  Determines the LAN function id by reading memory-mapped registers  *  and swaps the port value if requested.  **/
end_comment

begin_function
name|void
name|ixgbe_set_lan_id_multi_port_pcie
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|ixgbe_bus_info
modifier|*
name|bus
init|=
operator|&
name|hw
operator|->
name|bus
decl_stmt|;
name|u32
name|reg
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_set_lan_id_multi_port_pcie"
argument_list|)
expr_stmt|;
name|reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_STATUS
argument_list|)
expr_stmt|;
name|bus
operator|->
name|func
operator|=
operator|(
name|reg
operator|&
name|IXGBE_STATUS_LAN_ID
operator|)
operator|>>
name|IXGBE_STATUS_LAN_ID_SHIFT
expr_stmt|;
name|bus
operator|->
name|lan_id
operator|=
name|bus
operator|->
name|func
expr_stmt|;
comment|/* check for a port swap */
name|reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FACTPS
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|IXGBE_FACTPS_LFS
condition|)
name|bus
operator|->
name|func
operator|^=
literal|0x1
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_stop_adapter_generic - Generic stop Tx/Rx units  *  @hw: pointer to hardware structure  *  *  Sets the adapter_stopped flag within ixgbe_hw struct. Clears interrupts,  *  disables transmit and receive units. The adapter_stopped flag is used by  *  the shared code and drivers to determine if the adapter is in a stopped  *  state and should not touch the hardware.  **/
end_comment

begin_function
name|s32
name|ixgbe_stop_adapter_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|number_of_queues
decl_stmt|;
name|u32
name|reg_val
decl_stmt|;
name|u16
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_stop_adapter_generic"
argument_list|)
expr_stmt|;
comment|/* 	 * Set the adapter_stopped flag so other driver functions stop touching 	 * the hardware 	 */
name|hw
operator|->
name|adapter_stopped
operator|=
name|TRUE
expr_stmt|;
comment|/* Disable the receive unit */
name|reg_val
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXCTRL
argument_list|)
expr_stmt|;
name|reg_val
operator|&=
operator|~
operator|(
name|IXGBE_RXCTRL_RXEN
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXCTRL
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* Clear interrupt mask to stop from interrupts being generated */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EIMC
argument_list|,
name|IXGBE_IRQ_CLEAR_MASK
argument_list|)
expr_stmt|;
comment|/* Clear any pending interrupts */
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EICR
argument_list|)
expr_stmt|;
comment|/* Disable the transmit unit.  Each queue must be disabled. */
name|number_of_queues
operator|=
name|hw
operator|->
name|mac
operator|.
name|max_tx_queues
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|number_of_queues
condition|;
name|i
operator|++
control|)
block|{
name|reg_val
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_TXDCTL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_val
operator|&
name|IXGBE_TXDCTL_ENABLE
condition|)
block|{
name|reg_val
operator|&=
operator|~
name|IXGBE_TXDCTL_ENABLE
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_TXDCTL
argument_list|(
name|i
argument_list|)
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Prevent the PCI-E bus from from hanging by disabling PCI-E master 	 * access and verify no pending requests 	 */
if|if
condition|(
name|ixgbe_disable_pcie_master
argument_list|(
name|hw
argument_list|)
operator|!=
name|IXGBE_SUCCESS
condition|)
name|DEBUGOUT
argument_list|(
literal|"PCI-E Master disable polling has failed.\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_led_on_generic - Turns on the software controllable LEDs.  *  @hw: pointer to hardware structure  *  @index: led number to turn on  **/
end_comment

begin_function
name|s32
name|ixgbe_led_on_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|index
parameter_list|)
block|{
name|u32
name|led_reg
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LEDCTL
argument_list|)
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_led_on_generic"
argument_list|)
expr_stmt|;
comment|/* To turn on the LED, set mode to ON. */
name|led_reg
operator|&=
operator|~
name|IXGBE_LED_MODE_MASK
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|led_reg
operator||=
name|IXGBE_LED_ON
operator|<<
name|IXGBE_LED_MODE_SHIFT
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LEDCTL
argument_list|,
name|led_reg
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_led_off_generic - Turns off the software controllable LEDs.  *  @hw: pointer to hardware structure  *  @index: led number to turn off  **/
end_comment

begin_function
name|s32
name|ixgbe_led_off_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|index
parameter_list|)
block|{
name|u32
name|led_reg
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LEDCTL
argument_list|)
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_led_off_generic"
argument_list|)
expr_stmt|;
comment|/* To turn off the LED, set mode to OFF. */
name|led_reg
operator|&=
operator|~
name|IXGBE_LED_MODE_MASK
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|led_reg
operator||=
name|IXGBE_LED_OFF
operator|<<
name|IXGBE_LED_MODE_SHIFT
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LEDCTL
argument_list|,
name|led_reg
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_init_eeprom_params_generic - Initialize EEPROM params  *  @hw: pointer to hardware structure  *  *  Initializes the EEPROM parameters ixgbe_eeprom_info within the  *  ixgbe_hw struct in order to set up EEPROM access.  **/
end_comment

begin_function
name|s32
name|ixgbe_init_eeprom_params_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|ixgbe_eeprom_info
modifier|*
name|eeprom
init|=
operator|&
name|hw
operator|->
name|eeprom
decl_stmt|;
name|u32
name|eec
decl_stmt|;
name|u16
name|eeprom_size
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_init_eeprom_params_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|eeprom
operator|->
name|type
operator|==
name|ixgbe_eeprom_uninitialized
condition|)
block|{
name|eeprom
operator|->
name|type
operator|=
name|ixgbe_eeprom_none
expr_stmt|;
comment|/* Set default semaphore delay to 10ms which is a well 		 * tested value */
name|eeprom
operator|->
name|semaphore_delay
operator|=
literal|10
expr_stmt|;
comment|/* 		 * Check for EEPROM present first. 		 * If not present leave as none 		 */
name|eec
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC
argument_list|)
expr_stmt|;
if|if
condition|(
name|eec
operator|&
name|IXGBE_EEC_PRES
condition|)
block|{
name|eeprom
operator|->
name|type
operator|=
name|ixgbe_eeprom_spi
expr_stmt|;
comment|/* 			 * SPI EEPROM is assumed here.  This code would need to 			 * change if a future EEPROM is not SPI. 			 */
name|eeprom_size
operator|=
call|(
name|u16
call|)
argument_list|(
operator|(
name|eec
operator|&
name|IXGBE_EEC_SIZE
operator|)
operator|>>
name|IXGBE_EEC_SIZE_SHIFT
argument_list|)
expr_stmt|;
name|eeprom
operator|->
name|word_size
operator|=
literal|1
operator|<<
operator|(
name|eeprom_size
operator|+
name|IXGBE_EEPROM_WORD_SIZE_BASE_SHIFT
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|eec
operator|&
name|IXGBE_EEC_ADDR_SIZE
condition|)
name|eeprom
operator|->
name|address_bits
operator|=
literal|16
expr_stmt|;
else|else
name|eeprom
operator|->
name|address_bits
operator|=
literal|8
expr_stmt|;
name|DEBUGOUT3
argument_list|(
literal|"Eeprom params: type = %d, size = %d, address bits: "
literal|"%d\n"
argument_list|,
name|eeprom
operator|->
name|type
argument_list|,
name|eeprom
operator|->
name|word_size
argument_list|,
name|eeprom
operator|->
name|address_bits
argument_list|)
expr_stmt|;
block|}
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_write_eeprom_generic - Writes 16 bit value to EEPROM  *  @hw: pointer to hardware structure  *  @offset: offset within the EEPROM to be written to  *  @data: 16 bit word to be written to the EEPROM  *  *  If ixgbe_eeprom_update_checksum is not called after this function, the  *  EEPROM will most likely contain an invalid checksum.  **/
end_comment

begin_function
name|s32
name|ixgbe_write_eeprom_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
name|data
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|u8
name|write_opcode
init|=
name|IXGBE_EEPROM_WRITE_OPCODE_SPI
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_write_eeprom_generic"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|init_params
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
name|hw
operator|->
name|eeprom
operator|.
name|word_size
condition|)
block|{
name|status
operator|=
name|IXGBE_ERR_EEPROM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Prepare the EEPROM for writing  */
name|status
operator|=
name|ixgbe_acquire_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
condition|)
block|{
if|if
condition|(
name|ixgbe_ready_eeprom
argument_list|(
name|hw
argument_list|)
operator|!=
name|IXGBE_SUCCESS
condition|)
block|{
name|ixgbe_release_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|status
operator|=
name|IXGBE_ERR_EEPROM
expr_stmt|;
block|}
block|}
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
condition|)
block|{
name|ixgbe_standby_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/*  Send the WRITE ENABLE command (8 bit opcode )  */
name|ixgbe_shift_out_eeprom_bits
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEPROM_WREN_OPCODE_SPI
argument_list|,
name|IXGBE_EEPROM_OPCODE_BITS
argument_list|)
expr_stmt|;
name|ixgbe_standby_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* 		 * Some SPI eeproms use the 8th address bit embedded in the 		 * opcode 		 */
if|if
condition|(
operator|(
name|hw
operator|->
name|eeprom
operator|.
name|address_bits
operator|==
literal|8
operator|)
operator|&&
operator|(
name|offset
operator|>=
literal|128
operator|)
condition|)
name|write_opcode
operator||=
name|IXGBE_EEPROM_A8_OPCODE_SPI
expr_stmt|;
comment|/* Send the Write command (8-bit opcode + addr) */
name|ixgbe_shift_out_eeprom_bits
argument_list|(
name|hw
argument_list|,
name|write_opcode
argument_list|,
name|IXGBE_EEPROM_OPCODE_BITS
argument_list|)
expr_stmt|;
name|ixgbe_shift_out_eeprom_bits
argument_list|(
name|hw
argument_list|,
call|(
name|u16
call|)
argument_list|(
name|offset
operator|*
literal|2
argument_list|)
argument_list|,
name|hw
operator|->
name|eeprom
operator|.
name|address_bits
argument_list|)
expr_stmt|;
comment|/* Send the data */
name|data
operator|=
operator|(
name|data
operator|>>
literal|8
operator|)
operator||
operator|(
name|data
operator|<<
literal|8
operator|)
expr_stmt|;
name|ixgbe_shift_out_eeprom_bits
argument_list|(
name|hw
argument_list|,
name|data
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|ixgbe_standby_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Done with writing - release the EEPROM */
name|ixgbe_release_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
name|out
label|:
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_read_eeprom_bit_bang_generic - Read EEPROM word using bit-bang  *  @hw: pointer to hardware structure  *  @offset: offset within the EEPROM to be read  *  @data: read 16 bit value from EEPROM  *  *  Reads 16 bit value from EEPROM through bit-bang method  **/
end_comment

begin_function
name|s32
name|ixgbe_read_eeprom_bit_bang_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|u16
name|word_in
decl_stmt|;
name|u8
name|read_opcode
init|=
name|IXGBE_EEPROM_READ_OPCODE_SPI
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_read_eeprom_bit_bang_generic"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|init_params
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
name|hw
operator|->
name|eeprom
operator|.
name|word_size
condition|)
block|{
name|status
operator|=
name|IXGBE_ERR_EEPROM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Prepare the EEPROM for reading  */
name|status
operator|=
name|ixgbe_acquire_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
condition|)
block|{
if|if
condition|(
name|ixgbe_ready_eeprom
argument_list|(
name|hw
argument_list|)
operator|!=
name|IXGBE_SUCCESS
condition|)
block|{
name|ixgbe_release_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|status
operator|=
name|IXGBE_ERR_EEPROM
expr_stmt|;
block|}
block|}
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
condition|)
block|{
name|ixgbe_standby_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* 		 * Some SPI eeproms use the 8th address bit embedded in the 		 * opcode 		 */
if|if
condition|(
operator|(
name|hw
operator|->
name|eeprom
operator|.
name|address_bits
operator|==
literal|8
operator|)
operator|&&
operator|(
name|offset
operator|>=
literal|128
operator|)
condition|)
name|read_opcode
operator||=
name|IXGBE_EEPROM_A8_OPCODE_SPI
expr_stmt|;
comment|/* Send the READ command (opcode + addr) */
name|ixgbe_shift_out_eeprom_bits
argument_list|(
name|hw
argument_list|,
name|read_opcode
argument_list|,
name|IXGBE_EEPROM_OPCODE_BITS
argument_list|)
expr_stmt|;
name|ixgbe_shift_out_eeprom_bits
argument_list|(
name|hw
argument_list|,
call|(
name|u16
call|)
argument_list|(
name|offset
operator|*
literal|2
argument_list|)
argument_list|,
name|hw
operator|->
name|eeprom
operator|.
name|address_bits
argument_list|)
expr_stmt|;
comment|/* Read the data. */
name|word_in
operator|=
name|ixgbe_shift_in_eeprom_bits
argument_list|(
name|hw
argument_list|,
literal|16
argument_list|)
expr_stmt|;
operator|*
name|data
operator|=
operator|(
name|word_in
operator|>>
literal|8
operator|)
operator||
operator|(
name|word_in
operator|<<
literal|8
operator|)
expr_stmt|;
comment|/* End this read operation */
name|ixgbe_release_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
name|out
label|:
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_read_eerd_generic - Read EEPROM word using EERD  *  @hw: pointer to hardware structure  *  @offset: offset of  word in the EEPROM to read  *  @data: word read from the EEPROM  *  *  Reads a 16 bit word from the EEPROM using the EERD register.  **/
end_comment

begin_function
name|s32
name|ixgbe_read_eerd_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|u32
name|eerd
decl_stmt|;
name|s32
name|status
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_read_eerd_generic"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|init_params
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
name|hw
operator|->
name|eeprom
operator|.
name|word_size
condition|)
block|{
name|status
operator|=
name|IXGBE_ERR_EEPROM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|eerd
operator|=
operator|(
name|offset
operator|<<
name|IXGBE_EEPROM_RW_ADDR_SHIFT
operator|)
operator|+
name|IXGBE_EEPROM_RW_REG_START
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EERD
argument_list|,
name|eerd
argument_list|)
expr_stmt|;
name|status
operator|=
name|ixgbe_poll_eerd_eewr_done
argument_list|(
name|hw
argument_list|,
name|IXGBE_NVM_POLL_READ
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
condition|)
operator|*
name|data
operator|=
operator|(
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EERD
argument_list|)
operator|>>
name|IXGBE_EEPROM_RW_REG_DATA
operator|)
expr_stmt|;
else|else
name|DEBUGOUT
argument_list|(
literal|"Eeprom read timed out\n"
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_poll_eerd_eewr_done - Poll EERD read or EEWR write status  *  @hw: pointer to hardware structure  *  @ee_reg: EEPROM flag for polling  *  *  Polls the status bit (bit 1) of the EERD or EEWR to determine when the  *  read or write is done respectively.  **/
end_comment

begin_function
name|s32
name|ixgbe_poll_eerd_eewr_done
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|ee_reg
parameter_list|)
block|{
name|u32
name|i
decl_stmt|;
name|u32
name|reg
decl_stmt|;
name|s32
name|status
init|=
name|IXGBE_ERR_EEPROM
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_poll_eerd_eewr_done"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_EERD_EEWR_ATTEMPTS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ee_reg
operator|==
name|IXGBE_NVM_POLL_READ
condition|)
name|reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EERD
argument_list|)
expr_stmt|;
else|else
name|reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|IXGBE_EEPROM_RW_REG_DONE
condition|)
block|{
name|status
operator|=
name|IXGBE_SUCCESS
expr_stmt|;
break|break;
block|}
name|usec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_acquire_eeprom - Acquire EEPROM using bit-bang  *  @hw: pointer to hardware structure  *  *  Prepares EEPROM for access using bit-bang method. This function should  *  be called before issuing a command to the EEPROM.  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_acquire_eeprom
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u32
name|eec
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_acquire_eeprom"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ixgbe_acquire_swfw_sync
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR_EEP_SM
argument_list|)
operator|!=
name|IXGBE_SUCCESS
condition|)
name|status
operator|=
name|IXGBE_ERR_SWFW_SYNC
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
condition|)
block|{
name|eec
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC
argument_list|)
expr_stmt|;
comment|/* Request EEPROM Access */
name|eec
operator||=
name|IXGBE_EEC_REQ
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC
argument_list|,
name|eec
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_EEPROM_GRANT_ATTEMPTS
condition|;
name|i
operator|++
control|)
block|{
name|eec
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC
argument_list|)
expr_stmt|;
if|if
condition|(
name|eec
operator|&
name|IXGBE_EEC_GNT
condition|)
break|break;
name|usec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
comment|/* Release if grant not acquired */
if|if
condition|(
operator|!
operator|(
name|eec
operator|&
name|IXGBE_EEC_GNT
operator|)
condition|)
block|{
name|eec
operator|&=
operator|~
name|IXGBE_EEC_REQ
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC
argument_list|,
name|eec
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Could not acquire EEPROM grant\n"
argument_list|)
expr_stmt|;
name|ixgbe_release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR_EEP_SM
argument_list|)
expr_stmt|;
name|status
operator|=
name|IXGBE_ERR_EEPROM
expr_stmt|;
block|}
block|}
comment|/* Setup EEPROM for Read/Write */
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
condition|)
block|{
comment|/* Clear CS and SK */
name|eec
operator|&=
operator|~
operator|(
name|IXGBE_EEC_CS
operator||
name|IXGBE_EEC_SK
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC
argument_list|,
name|eec
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_eeprom_semaphore - Get hardware semaphore  *  @hw: pointer to hardware structure  *  *  Sets the hardware semaphores so EEPROM access can occur for bit-bang method  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_get_eeprom_semaphore
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_ERR_EEPROM
decl_stmt|;
name|u32
name|timeout
init|=
literal|2000
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|u32
name|swsm
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_eeprom_semaphore"
argument_list|)
expr_stmt|;
comment|/* Get SMBI software semaphore between device drivers first */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|timeout
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * If the SMBI bit is 0 when we read it, then the bit will be 		 * set and we have the semaphore 		 */
name|swsm
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SWSM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|swsm
operator|&
name|IXGBE_SWSM_SMBI
operator|)
condition|)
block|{
name|status
operator|=
name|IXGBE_SUCCESS
expr_stmt|;
break|break;
block|}
name|usec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
comment|/* Now get the semaphore between SW/FW through the SWESMBI bit */
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|timeout
condition|;
name|i
operator|++
control|)
block|{
name|swsm
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SWSM
argument_list|)
expr_stmt|;
comment|/* Set the SW EEPROM semaphore bit to request access */
name|swsm
operator||=
name|IXGBE_SWSM_SWESMBI
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SWSM
argument_list|,
name|swsm
argument_list|)
expr_stmt|;
comment|/* 			 * If we set the bit successfully then we got the 			 * semaphore. 			 */
name|swsm
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SWSM
argument_list|)
expr_stmt|;
if|if
condition|(
name|swsm
operator|&
name|IXGBE_SWSM_SWESMBI
condition|)
break|break;
name|usec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Release semaphores and return error if SW EEPROM semaphore 		 * was not granted because we don't have access to the EEPROM 		 */
if|if
condition|(
name|i
operator|>=
name|timeout
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"SWESMBI Software EEPROM semaphore "
literal|"not granted.\n"
argument_list|)
expr_stmt|;
name|ixgbe_release_eeprom_semaphore
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|status
operator|=
name|IXGBE_ERR_EEPROM
expr_stmt|;
block|}
block|}
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"Software semaphore SMBI between device drivers "
literal|"not granted.\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_release_eeprom_semaphore - Release hardware semaphore  *  @hw: pointer to hardware structure  *  *  This function clears hardware semaphore bits.  **/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_release_eeprom_semaphore
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|swsm
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_release_eeprom_semaphore"
argument_list|)
expr_stmt|;
name|swsm
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SWSM
argument_list|)
expr_stmt|;
comment|/* Release both semaphores by writing 0 to the bits SWESMBI and SMBI */
name|swsm
operator|&=
operator|~
operator|(
name|IXGBE_SWSM_SWESMBI
operator||
name|IXGBE_SWSM_SMBI
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SWSM
argument_list|,
name|swsm
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_ready_eeprom - Polls for EEPROM ready  *  @hw: pointer to hardware structure  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_ready_eeprom
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u16
name|i
decl_stmt|;
name|u8
name|spi_stat_reg
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_ready_eeprom"
argument_list|)
expr_stmt|;
comment|/* 	 * Read "Status Register" repeatedly until the LSB is cleared.  The 	 * EEPROM will signal that the command has been completed by clearing 	 * bit 0 of the internal status register.  If it's not cleared within 	 * 5 milliseconds, then error out. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_EEPROM_MAX_RETRY_SPI
condition|;
name|i
operator|+=
literal|5
control|)
block|{
name|ixgbe_shift_out_eeprom_bits
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEPROM_RDSR_OPCODE_SPI
argument_list|,
name|IXGBE_EEPROM_OPCODE_BITS
argument_list|)
expr_stmt|;
name|spi_stat_reg
operator|=
operator|(
name|u8
operator|)
name|ixgbe_shift_in_eeprom_bits
argument_list|(
name|hw
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|spi_stat_reg
operator|&
name|IXGBE_EEPROM_STATUS_RDY_SPI
operator|)
condition|)
break|break;
name|usec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|ixgbe_standby_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/* 	 * On some parts, SPI write time could vary from 0-20mSec on 3.3V 	 * devices (and only 0-5mSec on 5V devices) 	 */
if|if
condition|(
name|i
operator|>=
name|IXGBE_EEPROM_MAX_RETRY_SPI
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"SPI EEPROM Status error\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IXGBE_ERR_EEPROM
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_standby_eeprom - Returns EEPROM to a "standby" state  *  @hw: pointer to hardware structure  **/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_standby_eeprom
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|eec
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_standby_eeprom"
argument_list|)
expr_stmt|;
name|eec
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC
argument_list|)
expr_stmt|;
comment|/* Toggle CS to flush commands */
name|eec
operator||=
name|IXGBE_EEC_CS
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC
argument_list|,
name|eec
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|eec
operator|&=
operator|~
name|IXGBE_EEC_CS
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC
argument_list|,
name|eec
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_shift_out_eeprom_bits - Shift data bits out to the EEPROM.  *  @hw: pointer to hardware structure  *  @data: data to send to the EEPROM  *  @count: number of bits to shift out  **/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_shift_out_eeprom_bits
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|data
parameter_list|,
name|u16
name|count
parameter_list|)
block|{
name|u32
name|eec
decl_stmt|;
name|u32
name|mask
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_shift_out_eeprom_bits"
argument_list|)
expr_stmt|;
name|eec
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC
argument_list|)
expr_stmt|;
comment|/* 	 * Mask is used to shift "count" bits of "data" out to the EEPROM 	 * one bit at a time.  Determine the starting bit based on count 	 */
name|mask
operator|=
literal|0x01
operator|<<
operator|(
name|count
operator|-
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * A "1" is shifted out to the EEPROM by setting bit "DI" to a 		 * "1", and then raising and then lowering the clock (the SK 		 * bit controls the clock input to the EEPROM).  A "0" is 		 * shifted out to the EEPROM by setting "DI" to "0" and then 		 * raising and then lowering the clock. 		 */
if|if
condition|(
name|data
operator|&
name|mask
condition|)
name|eec
operator||=
name|IXGBE_EEC_DI
expr_stmt|;
else|else
name|eec
operator|&=
operator|~
name|IXGBE_EEC_DI
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC
argument_list|,
name|eec
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ixgbe_raise_eeprom_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|eec
argument_list|)
expr_stmt|;
name|ixgbe_lower_eeprom_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|eec
argument_list|)
expr_stmt|;
comment|/* 		 * Shift mask to signify next bit of data to shift in to the 		 * EEPROM 		 */
name|mask
operator|=
name|mask
operator|>>
literal|1
expr_stmt|;
block|}
empty_stmt|;
comment|/* We leave the "DI" bit set to "0" when we leave this routine. */
name|eec
operator|&=
operator|~
name|IXGBE_EEC_DI
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC
argument_list|,
name|eec
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_shift_in_eeprom_bits - Shift data bits in from the EEPROM  *  @hw: pointer to hardware structure  **/
end_comment

begin_function
specifier|static
name|u16
name|ixgbe_shift_in_eeprom_bits
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|count
parameter_list|)
block|{
name|u32
name|eec
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|u16
name|data
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_shift_in_eeprom_bits"
argument_list|)
expr_stmt|;
comment|/* 	 * In order to read a register from the EEPROM, we need to shift 	 * 'count' bits in from the EEPROM. Bits are "shifted in" by raising 	 * the clock input to the EEPROM (setting the SK bit), and then reading 	 * the value of the "DO" bit.  During this "shifting in" process the 	 * "DI" bit should always be clear. 	 */
name|eec
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC
argument_list|)
expr_stmt|;
name|eec
operator|&=
operator|~
operator|(
name|IXGBE_EEC_DO
operator||
name|IXGBE_EEC_DI
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|data
operator|=
name|data
operator|<<
literal|1
expr_stmt|;
name|ixgbe_raise_eeprom_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|eec
argument_list|)
expr_stmt|;
name|eec
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC
argument_list|)
expr_stmt|;
name|eec
operator|&=
operator|~
operator|(
name|IXGBE_EEC_DI
operator|)
expr_stmt|;
if|if
condition|(
name|eec
operator|&
name|IXGBE_EEC_DO
condition|)
name|data
operator||=
literal|1
expr_stmt|;
name|ixgbe_lower_eeprom_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|eec
argument_list|)
expr_stmt|;
block|}
return|return
name|data
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_raise_eeprom_clk - Raises the EEPROM's clock input.  *  @hw: pointer to hardware structure  *  @eec: EEC register's current value  **/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_raise_eeprom_clk
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|eec
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_raise_eeprom_clk"
argument_list|)
expr_stmt|;
comment|/* 	 * Raise the clock input to the EEPROM 	 * (setting the SK bit), then delay 	 */
operator|*
name|eec
operator|=
operator|*
name|eec
operator||
name|IXGBE_EEC_SK
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC
argument_list|,
operator|*
name|eec
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_lower_eeprom_clk - Lowers the EEPROM's clock input.  *  @hw: pointer to hardware structure  *  @eecd: EECD's current value  **/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_lower_eeprom_clk
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|eec
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_lower_eeprom_clk"
argument_list|)
expr_stmt|;
comment|/* 	 * Lower the clock input to the EEPROM (clearing the SK bit), then 	 * delay 	 */
operator|*
name|eec
operator|=
operator|*
name|eec
operator|&
operator|~
name|IXGBE_EEC_SK
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC
argument_list|,
operator|*
name|eec
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_release_eeprom - Release EEPROM, release semaphores  *  @hw: pointer to hardware structure  **/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_release_eeprom
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|eec
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_release_eeprom"
argument_list|)
expr_stmt|;
name|eec
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC
argument_list|)
expr_stmt|;
name|eec
operator||=
name|IXGBE_EEC_CS
expr_stmt|;
comment|/* Pull CS high */
name|eec
operator|&=
operator|~
name|IXGBE_EEC_SK
expr_stmt|;
comment|/* Lower SCK */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC
argument_list|,
name|eec
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Stop requesting EEPROM access */
name|eec
operator|&=
operator|~
name|IXGBE_EEC_REQ
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC
argument_list|,
name|eec
argument_list|)
expr_stmt|;
name|ixgbe_release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR_EEP_SM
argument_list|)
expr_stmt|;
comment|/* Delay before attempt to obtain semaphore again to allow FW access */
name|msec_delay
argument_list|(
name|hw
operator|->
name|eeprom
operator|.
name|semaphore_delay
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_calc_eeprom_checksum_generic - Calculates and returns the checksum  *  @hw: pointer to hardware structure  **/
end_comment

begin_function
name|u16
name|ixgbe_calc_eeprom_checksum_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u16
name|i
decl_stmt|;
name|u16
name|j
decl_stmt|;
name|u16
name|checksum
init|=
literal|0
decl_stmt|;
name|u16
name|length
init|=
literal|0
decl_stmt|;
name|u16
name|pointer
init|=
literal|0
decl_stmt|;
name|u16
name|word
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_calc_eeprom_checksum_generic"
argument_list|)
expr_stmt|;
comment|/* Include 0x0-0x3F in the checksum */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_EEPROM_CHECKSUM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|i
argument_list|,
operator|&
name|word
argument_list|)
operator|!=
name|IXGBE_SUCCESS
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM read failed\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|checksum
operator|+=
name|word
expr_stmt|;
block|}
comment|/* Include all data from pointers except for the fw pointer */
for|for
control|(
name|i
operator|=
name|IXGBE_PCIE_ANALOG_PTR
init|;
name|i
operator|<
name|IXGBE_FW_PTR
condition|;
name|i
operator|++
control|)
block|{
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|i
argument_list|,
operator|&
name|pointer
argument_list|)
expr_stmt|;
comment|/* Make sure the pointer seems valid */
if|if
condition|(
name|pointer
operator|!=
literal|0xFFFF
operator|&&
name|pointer
operator|!=
literal|0
condition|)
block|{
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|pointer
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|!=
literal|0xFFFF
operator|&&
name|length
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|j
operator|=
name|pointer
operator|+
literal|1
init|;
name|j
operator|<=
name|pointer
operator|+
name|length
condition|;
name|j
operator|++
control|)
block|{
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|j
argument_list|,
operator|&
name|word
argument_list|)
expr_stmt|;
name|checksum
operator|+=
name|word
expr_stmt|;
block|}
block|}
block|}
block|}
name|checksum
operator|=
operator|(
name|u16
operator|)
name|IXGBE_EEPROM_SUM
operator|-
name|checksum
expr_stmt|;
return|return
name|checksum
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_validate_eeprom_checksum_generic - Validate EEPROM checksum  *  @hw: pointer to hardware structure  *  @checksum_val: calculated checksum  *  *  Performs checksum calculation and validates the EEPROM checksum.  If the  *  caller does not need checksum_val, the value can be NULL.  **/
end_comment

begin_function
name|s32
name|ixgbe_validate_eeprom_checksum_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|checksum_val
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|u16
name|checksum
decl_stmt|;
name|u16
name|read_checksum
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_validate_eeprom_checksum_generic"
argument_list|)
expr_stmt|;
comment|/* 	 * Read the first word from the EEPROM. If this times out or fails, do 	 * not continue or we could be in for a very long wait while every 	 * EEPROM read fails 	 */
name|status
operator|=
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
literal|0
argument_list|,
operator|&
name|checksum
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
condition|)
block|{
name|checksum
operator|=
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|calc_checksum
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEPROM_CHECKSUM
argument_list|,
operator|&
name|read_checksum
argument_list|)
expr_stmt|;
comment|/* 		 * Verify read checksum from EEPROM is the same as 		 * calculated checksum 		 */
if|if
condition|(
name|read_checksum
operator|!=
name|checksum
condition|)
name|status
operator|=
name|IXGBE_ERR_EEPROM_CHECKSUM
expr_stmt|;
comment|/* If the user cares, return the calculated checksum */
if|if
condition|(
name|checksum_val
condition|)
operator|*
name|checksum_val
operator|=
name|checksum
expr_stmt|;
block|}
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM read failed\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_update_eeprom_checksum_generic - Updates the EEPROM checksum  *  @hw: pointer to hardware structure  **/
end_comment

begin_function
name|s32
name|ixgbe_update_eeprom_checksum_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|u16
name|checksum
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_update_eeprom_checksum_generic"
argument_list|)
expr_stmt|;
comment|/* 	 * Read the first word from the EEPROM. If this times out or fails, do 	 * not continue or we could be in for a very long wait while every 	 * EEPROM read fails 	 */
name|status
operator|=
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
literal|0
argument_list|,
operator|&
name|checksum
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
condition|)
block|{
name|checksum
operator|=
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|calc_checksum
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|status
operator|=
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|write
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEPROM_CHECKSUM
argument_list|,
name|checksum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM read failed\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_validate_mac_addr - Validate MAC address  *  @mac_addr: pointer to MAC address.  *  *  Tests a MAC address to ensure it is a valid Individual Address  **/
end_comment

begin_function
name|s32
name|ixgbe_validate_mac_addr
parameter_list|(
name|u8
modifier|*
name|mac_addr
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_validate_mac_addr"
argument_list|)
expr_stmt|;
comment|/* Make sure it is not a multicast address */
if|if
condition|(
name|IXGBE_IS_MULTICAST
argument_list|(
name|mac_addr
argument_list|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"MAC address is multicast\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IXGBE_ERR_INVALID_MAC_ADDR
expr_stmt|;
comment|/* Not a broadcast address */
block|}
elseif|else
if|if
condition|(
name|IXGBE_IS_BROADCAST
argument_list|(
name|mac_addr
argument_list|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"MAC address is broadcast\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IXGBE_ERR_INVALID_MAC_ADDR
expr_stmt|;
comment|/* Reject the zero address */
block|}
elseif|else
if|if
condition|(
name|mac_addr
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|mac_addr
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|mac_addr
index|[
literal|2
index|]
operator|==
literal|0
operator|&&
name|mac_addr
index|[
literal|3
index|]
operator|==
literal|0
operator|&&
name|mac_addr
index|[
literal|4
index|]
operator|==
literal|0
operator|&&
name|mac_addr
index|[
literal|5
index|]
operator|==
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"MAC address is all zeros\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IXGBE_ERR_INVALID_MAC_ADDR
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_set_rar_generic - Set Rx address register  *  @hw: pointer to hardware structure  *  @index: Receive address register to write  *  @addr: Address to put into receive address register  *  @vmdq: VMDq "set" or "pool" index  *  @enable_addr: set flag that address is active  *  *  Puts an ethernet address into a receive address register.  **/
end_comment

begin_function
name|s32
name|ixgbe_set_rar_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|index
parameter_list|,
name|u8
modifier|*
name|addr
parameter_list|,
name|u32
name|vmdq
parameter_list|,
name|u32
name|enable_addr
parameter_list|)
block|{
name|u32
name|rar_low
decl_stmt|,
name|rar_high
decl_stmt|;
name|u32
name|rar_entries
init|=
name|hw
operator|->
name|mac
operator|.
name|num_rar_entries
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_set_rar_generic"
argument_list|)
expr_stmt|;
comment|/* setup VMDq pool selection before this RAR gets enabled */
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|set_vmdq
argument_list|(
name|hw
argument_list|,
name|index
argument_list|,
name|vmdq
argument_list|)
expr_stmt|;
comment|/* Make sure we are using a valid rar index range */
if|if
condition|(
name|index
operator|<
name|rar_entries
condition|)
block|{
comment|/* 		 * HW expects these in little endian so we reverse the byte 		 * order from network order (big endian) to little endian 		 */
name|rar_low
operator|=
operator|(
operator|(
name|u32
operator|)
name|addr
index|[
literal|0
index|]
operator||
operator|(
operator|(
name|u32
operator|)
name|addr
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|u32
operator|)
name|addr
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|u32
operator|)
name|addr
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
operator|)
expr_stmt|;
comment|/* 		 * Some parts put the VMDq setting in the extra RAH bits, 		 * so save everything except the lower 16 bits that hold part 		 * of the address and the address valid bit. 		 */
name|rar_high
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RAH
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|rar_high
operator|&=
operator|~
operator|(
literal|0x0000FFFF
operator||
name|IXGBE_RAH_AV
operator|)
expr_stmt|;
name|rar_high
operator||=
operator|(
operator|(
name|u32
operator|)
name|addr
index|[
literal|4
index|]
operator||
operator|(
operator|(
name|u32
operator|)
name|addr
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|enable_addr
operator|!=
literal|0
condition|)
name|rar_high
operator||=
name|IXGBE_RAH_AV
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RAL
argument_list|(
name|index
argument_list|)
argument_list|,
name|rar_low
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RAH
argument_list|(
name|index
argument_list|)
argument_list|,
name|rar_high
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DEBUGOUT1
argument_list|(
literal|"RAR index %d is out of range.\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_clear_rar_generic - Remove Rx address register  *  @hw: pointer to hardware structure  *  @index: Receive address register to write  *  *  Clears an ethernet address from a receive address register.  **/
end_comment

begin_function
name|s32
name|ixgbe_clear_rar_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|index
parameter_list|)
block|{
name|u32
name|rar_high
decl_stmt|;
name|u32
name|rar_entries
init|=
name|hw
operator|->
name|mac
operator|.
name|num_rar_entries
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_clear_rar_generic"
argument_list|)
expr_stmt|;
comment|/* Make sure we are using a valid rar index range */
if|if
condition|(
name|index
operator|<
name|rar_entries
condition|)
block|{
comment|/* 		 * Some parts put the VMDq setting in the extra RAH bits, 		 * so save everything except the lower 16 bits that hold part 		 * of the address and the address valid bit. 		 */
name|rar_high
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RAH
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|rar_high
operator|&=
operator|~
operator|(
literal|0x0000FFFF
operator||
name|IXGBE_RAH_AV
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RAL
argument_list|(
name|index
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RAH
argument_list|(
name|index
argument_list|)
argument_list|,
name|rar_high
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DEBUGOUT1
argument_list|(
literal|"RAR index %d is out of range.\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
comment|/* clear VMDq pool/queue selection for this RAR */
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|clear_vmdq
argument_list|(
name|hw
argument_list|,
name|index
argument_list|,
name|IXGBE_CLEAR_VMDQ_ALL
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_init_rx_addrs_generic - Initializes receive address filters.  *  @hw: pointer to hardware structure  *  *  Places the MAC address in receive address register 0 and clears the rest  *  of the receive address registers. Clears the multicast table. Assumes  *  the receiver is in reset when the routine is called.  **/
end_comment

begin_function
name|s32
name|ixgbe_init_rx_addrs_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|i
decl_stmt|;
name|u32
name|rar_entries
init|=
name|hw
operator|->
name|mac
operator|.
name|num_rar_entries
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_init_rx_addrs_generic"
argument_list|)
expr_stmt|;
comment|/* 	 * If the current mac address is valid, assume it is a software override 	 * to the permanent address. 	 * Otherwise, use the permanent address from the eeprom. 	 */
if|if
condition|(
name|ixgbe_validate_mac_addr
argument_list|(
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|)
operator|==
name|IXGBE_ERR_INVALID_MAC_ADDR
condition|)
block|{
comment|/* Get the MAC address from the RAR0 for later reference */
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|get_mac_addr
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|)
expr_stmt|;
name|DEBUGOUT3
argument_list|(
literal|" Keeping Current RAR0 Addr =%.2X %.2X %.2X "
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
index|[
literal|0
index|]
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
index|[
literal|1
index|]
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|DEBUGOUT3
argument_list|(
literal|"%.2X %.2X %.2X\n"
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
index|[
literal|3
index|]
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
index|[
literal|4
index|]
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Setup the receive address. */
name|DEBUGOUT
argument_list|(
literal|"Overriding MAC Address in RAR[0]\n"
argument_list|)
expr_stmt|;
name|DEBUGOUT3
argument_list|(
literal|" New MAC Addr =%.2X %.2X %.2X "
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
index|[
literal|0
index|]
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
index|[
literal|1
index|]
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|DEBUGOUT3
argument_list|(
literal|"%.2X %.2X %.2X\n"
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
index|[
literal|3
index|]
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
index|[
literal|4
index|]
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|set_rar
argument_list|(
name|hw
argument_list|,
literal|0
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|,
literal|0
argument_list|,
name|IXGBE_RAH_AV
argument_list|)
expr_stmt|;
block|}
name|hw
operator|->
name|addr_ctrl
operator|.
name|overflow_promisc
operator|=
literal|0
expr_stmt|;
name|hw
operator|->
name|addr_ctrl
operator|.
name|rar_used_count
operator|=
literal|1
expr_stmt|;
comment|/* Zero out the other receive addresses. */
name|DEBUGOUT1
argument_list|(
literal|"Clearing RAR[1-%d]\n"
argument_list|,
name|rar_entries
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|rar_entries
condition|;
name|i
operator|++
control|)
block|{
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RAL
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RAH
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Clear the MTA */
name|hw
operator|->
name|addr_ctrl
operator|.
name|mta_in_use
operator|=
literal|0
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MCSTCTRL
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|mc_filter_type
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|" Clearing MTA\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hw
operator|->
name|mac
operator|.
name|mcft_size
condition|;
name|i
operator|++
control|)
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MTA
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ixgbe_init_uta_tables
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_add_uc_addr - Adds a secondary unicast address.  *  @hw: pointer to hardware structure  *  @addr: new address  *  *  Adds it to unused receive address register or goes into promiscuous mode.  **/
end_comment

begin_function
name|void
name|ixgbe_add_uc_addr
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|addr
parameter_list|,
name|u32
name|vmdq
parameter_list|)
block|{
name|u32
name|rar_entries
init|=
name|hw
operator|->
name|mac
operator|.
name|num_rar_entries
decl_stmt|;
name|u32
name|rar
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_add_uc_addr"
argument_list|)
expr_stmt|;
name|DEBUGOUT6
argument_list|(
literal|" UC Addr = %.2X %.2X %.2X %.2X %.2X %.2X\n"
argument_list|,
name|addr
index|[
literal|0
index|]
argument_list|,
name|addr
index|[
literal|1
index|]
argument_list|,
name|addr
index|[
literal|2
index|]
argument_list|,
name|addr
index|[
literal|3
index|]
argument_list|,
name|addr
index|[
literal|4
index|]
argument_list|,
name|addr
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Place this address in the RAR if there is room, 	 * else put the controller into promiscuous mode 	 */
if|if
condition|(
name|hw
operator|->
name|addr_ctrl
operator|.
name|rar_used_count
operator|<
name|rar_entries
condition|)
block|{
name|rar
operator|=
name|hw
operator|->
name|addr_ctrl
operator|.
name|rar_used_count
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|set_rar
argument_list|(
name|hw
argument_list|,
name|rar
argument_list|,
name|addr
argument_list|,
name|vmdq
argument_list|,
name|IXGBE_RAH_AV
argument_list|)
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"Added a secondary address to RAR[%d]\n"
argument_list|,
name|rar
argument_list|)
expr_stmt|;
name|hw
operator|->
name|addr_ctrl
operator|.
name|rar_used_count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|hw
operator|->
name|addr_ctrl
operator|.
name|overflow_promisc
operator|++
expr_stmt|;
block|}
name|DEBUGOUT
argument_list|(
literal|"ixgbe_add_uc_addr Complete\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_update_uc_addr_list_generic - Updates MAC list of secondary addresses  *  @hw: pointer to hardware structure  *  @addr_list: the list of new addresses  *  @addr_count: number of addresses  *  @next: iterator function to walk the address list  *  *  The given list replaces any existing list.  Clears the secondary addrs from  *  receive address registers.  Uses unused receive address registers for the  *  first secondary addresses, and falls back to promiscuous mode as needed.  *  *  Drivers using secondary unicast addresses must set user_set_promisc when  *  manually putting the device into promiscuous mode.  **/
end_comment

begin_function
name|s32
name|ixgbe_update_uc_addr_list_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|addr_list
parameter_list|,
name|u32
name|addr_count
parameter_list|,
name|ixgbe_mc_addr_itr
name|next
parameter_list|)
block|{
name|u8
modifier|*
name|addr
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|u32
name|old_promisc_setting
init|=
name|hw
operator|->
name|addr_ctrl
operator|.
name|overflow_promisc
decl_stmt|;
name|u32
name|uc_addr_in_use
decl_stmt|;
name|u32
name|fctrl
decl_stmt|;
name|u32
name|vmdq
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_update_uc_addr_list_generic"
argument_list|)
expr_stmt|;
comment|/* 	 * Clear accounting of old secondary address list, 	 * don't count RAR[0] 	 */
name|uc_addr_in_use
operator|=
name|hw
operator|->
name|addr_ctrl
operator|.
name|rar_used_count
operator|-
literal|1
expr_stmt|;
name|hw
operator|->
name|addr_ctrl
operator|.
name|rar_used_count
operator|-=
name|uc_addr_in_use
expr_stmt|;
name|hw
operator|->
name|addr_ctrl
operator|.
name|overflow_promisc
operator|=
literal|0
expr_stmt|;
comment|/* Zero out the other receive addresses */
name|DEBUGOUT1
argument_list|(
literal|"Clearing RAR[1-%d]\n"
argument_list|,
name|uc_addr_in_use
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|uc_addr_in_use
condition|;
name|i
operator|++
control|)
block|{
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RAL
argument_list|(
literal|1
operator|+
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RAH
argument_list|(
literal|1
operator|+
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Add the new addresses */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|addr_count
condition|;
name|i
operator|++
control|)
block|{
name|DEBUGOUT
argument_list|(
literal|" Adding the secondary addresses:\n"
argument_list|)
expr_stmt|;
name|addr
operator|=
name|next
argument_list|(
name|hw
argument_list|,
operator|&
name|addr_list
argument_list|,
operator|&
name|vmdq
argument_list|)
expr_stmt|;
name|ixgbe_add_uc_addr
argument_list|(
name|hw
argument_list|,
name|addr
argument_list|,
name|vmdq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hw
operator|->
name|addr_ctrl
operator|.
name|overflow_promisc
condition|)
block|{
comment|/* enable promisc if not already in overflow or set by user */
if|if
condition|(
operator|!
name|old_promisc_setting
operator|&&
operator|!
name|hw
operator|->
name|addr_ctrl
operator|.
name|user_set_promisc
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|" Entering address overflow promisc mode\n"
argument_list|)
expr_stmt|;
name|fctrl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCTRL
argument_list|)
expr_stmt|;
name|fctrl
operator||=
name|IXGBE_FCTRL_UPE
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCTRL
argument_list|,
name|fctrl
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* only disable if set by overflow, not by user */
if|if
condition|(
name|old_promisc_setting
operator|&&
operator|!
name|hw
operator|->
name|addr_ctrl
operator|.
name|user_set_promisc
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|" Leaving address overflow promisc mode\n"
argument_list|)
expr_stmt|;
name|fctrl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCTRL
argument_list|)
expr_stmt|;
name|fctrl
operator|&=
operator|~
name|IXGBE_FCTRL_UPE
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCTRL
argument_list|,
name|fctrl
argument_list|)
expr_stmt|;
block|}
block|}
name|DEBUGOUT
argument_list|(
literal|"ixgbe_update_uc_addr_list_generic Complete\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_mta_vector - Determines bit-vector in multicast table to set  *  @hw: pointer to hardware structure  *  @mc_addr: the multicast address  *  *  Extracts the 12 bits, from a multicast address, to determine which  *  bit-vector to set in the multicast table. The hardware uses 12 bits, from  *  incoming rx multicast addresses, to determine the bit-vector to check in  *  the MTA. Which of the 4 combination, of 12-bits, the hardware uses is set  *  by the MO field of the MCSTCTRL. The MO field is set during initialization  *  to mc_filter_type.  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_mta_vector
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|mc_addr
parameter_list|)
block|{
name|u32
name|vector
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_mta_vector"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|mc_filter_type
condition|)
block|{
case|case
literal|0
case|:
comment|/* use bits [47:36] of the address */
name|vector
operator|=
operator|(
operator|(
name|mc_addr
index|[
literal|4
index|]
operator|>>
literal|4
operator|)
operator||
operator|(
operator|(
operator|(
name|u16
operator|)
name|mc_addr
index|[
literal|5
index|]
operator|)
operator|<<
literal|4
operator|)
operator|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* use bits [46:35] of the address */
name|vector
operator|=
operator|(
operator|(
name|mc_addr
index|[
literal|4
index|]
operator|>>
literal|3
operator|)
operator||
operator|(
operator|(
operator|(
name|u16
operator|)
name|mc_addr
index|[
literal|5
index|]
operator|)
operator|<<
literal|5
operator|)
operator|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* use bits [45:34] of the address */
name|vector
operator|=
operator|(
operator|(
name|mc_addr
index|[
literal|4
index|]
operator|>>
literal|2
operator|)
operator||
operator|(
operator|(
operator|(
name|u16
operator|)
name|mc_addr
index|[
literal|5
index|]
operator|)
operator|<<
literal|6
operator|)
operator|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* use bits [43:32] of the address */
name|vector
operator|=
operator|(
operator|(
name|mc_addr
index|[
literal|4
index|]
operator|)
operator||
operator|(
operator|(
operator|(
name|u16
operator|)
name|mc_addr
index|[
literal|5
index|]
operator|)
operator|<<
literal|8
operator|)
operator|)
expr_stmt|;
break|break;
default|default:
comment|/* Invalid mc_filter_type */
name|DEBUGOUT
argument_list|(
literal|"MC filter type param set incorrectly\n"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* vector can only be 12-bits or boundary will be exceeded */
name|vector
operator|&=
literal|0xFFF
expr_stmt|;
return|return
name|vector
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_set_mta - Set bit-vector in multicast table  *  @hw: pointer to hardware structure  *  @hash_value: Multicast address hash value  *  *  Sets the bit-vector in the multicast table.  **/
end_comment

begin_function
name|void
name|ixgbe_set_mta
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|mc_addr
parameter_list|)
block|{
name|u32
name|vector
decl_stmt|;
name|u32
name|vector_bit
decl_stmt|;
name|u32
name|vector_reg
decl_stmt|;
name|u32
name|mta_reg
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_set_mta"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|addr_ctrl
operator|.
name|mta_in_use
operator|++
expr_stmt|;
name|vector
operator|=
name|ixgbe_mta_vector
argument_list|(
name|hw
argument_list|,
name|mc_addr
argument_list|)
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|" bit-vector = 0x%03X\n"
argument_list|,
name|vector
argument_list|)
expr_stmt|;
comment|/* 	 * The MTA is a register array of 128 32-bit registers. It is treated 	 * like an array of 4096 bits.  We want to set bit 	 * BitArray[vector_value]. So we figure out what register the bit is 	 * in, read it, OR in the new bit, then write back the new value.  The 	 * register is determined by the upper 7 bits of the vector value and 	 * the bit within that register are determined by the lower 5 bits of 	 * the value. 	 */
name|vector_reg
operator|=
operator|(
name|vector
operator|>>
literal|5
operator|)
operator|&
literal|0x7F
expr_stmt|;
name|vector_bit
operator|=
name|vector
operator|&
literal|0x1F
expr_stmt|;
name|mta_reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MTA
argument_list|(
name|vector_reg
argument_list|)
argument_list|)
expr_stmt|;
name|mta_reg
operator||=
operator|(
literal|1
operator|<<
name|vector_bit
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MTA
argument_list|(
name|vector_reg
argument_list|)
argument_list|,
name|mta_reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_update_mc_addr_list_generic - Updates MAC list of multicast addresses  *  @hw: pointer to hardware structure  *  @mc_addr_list: the list of new multicast addresses  *  @mc_addr_count: number of addresses  *  @next: iterator function to walk the multicast address list  *  *  The given list replaces any existing list. Clears the MC addrs from receive  *  address registers and the multicast table. Uses unused receive address  *  registers for the first multicast addresses, and hashes the rest into the  *  multicast table.  **/
end_comment

begin_function
name|s32
name|ixgbe_update_mc_addr_list_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|mc_addr_list
parameter_list|,
name|u32
name|mc_addr_count
parameter_list|,
name|ixgbe_mc_addr_itr
name|next
parameter_list|)
block|{
name|u32
name|i
decl_stmt|;
name|u32
name|vmdq
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_update_mc_addr_list_generic"
argument_list|)
expr_stmt|;
comment|/* 	 * Set the new number of MC addresses that we are being requested to 	 * use. 	 */
name|hw
operator|->
name|addr_ctrl
operator|.
name|num_mc_addrs
operator|=
name|mc_addr_count
expr_stmt|;
name|hw
operator|->
name|addr_ctrl
operator|.
name|mta_in_use
operator|=
literal|0
expr_stmt|;
comment|/* Clear the MTA */
name|DEBUGOUT
argument_list|(
literal|" Clearing MTA\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hw
operator|->
name|mac
operator|.
name|mcft_size
condition|;
name|i
operator|++
control|)
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MTA
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Add the new addresses */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mc_addr_count
condition|;
name|i
operator|++
control|)
block|{
name|DEBUGOUT
argument_list|(
literal|" Adding the multicast addresses:\n"
argument_list|)
expr_stmt|;
name|ixgbe_set_mta
argument_list|(
name|hw
argument_list|,
name|next
argument_list|(
name|hw
argument_list|,
operator|&
name|mc_addr_list
argument_list|,
operator|&
name|vmdq
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Enable mta */
if|if
condition|(
name|hw
operator|->
name|addr_ctrl
operator|.
name|mta_in_use
operator|>
literal|0
condition|)
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MCSTCTRL
argument_list|,
name|IXGBE_MCSTCTRL_MFE
operator||
name|hw
operator|->
name|mac
operator|.
name|mc_filter_type
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"ixgbe_update_mc_addr_list_generic Complete\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_enable_mc_generic - Enable multicast address in RAR  *  @hw: pointer to hardware structure  *  *  Enables multicast address in RAR and the use of the multicast hash table.  **/
end_comment

begin_function
name|s32
name|ixgbe_enable_mc_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|ixgbe_addr_filter_info
modifier|*
name|a
init|=
operator|&
name|hw
operator|->
name|addr_ctrl
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_enable_mc_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|mta_in_use
operator|>
literal|0
condition|)
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MCSTCTRL
argument_list|,
name|IXGBE_MCSTCTRL_MFE
operator||
name|hw
operator|->
name|mac
operator|.
name|mc_filter_type
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_disable_mc_generic - Disable multicast address in RAR  *  @hw: pointer to hardware structure  *  *  Disables multicast address in RAR and the use of the multicast hash table.  **/
end_comment

begin_function
name|s32
name|ixgbe_disable_mc_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|ixgbe_addr_filter_info
modifier|*
name|a
init|=
operator|&
name|hw
operator|->
name|addr_ctrl
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_disable_mc_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|mta_in_use
operator|>
literal|0
condition|)
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MCSTCTRL
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|mc_filter_type
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_fc_enable_generic - Enable flow control  *  @hw: pointer to hardware structure  *  @packetbuf_num: packet buffer number (0-7)  *  *  Enable flow control according to the current settings.  **/
end_comment

begin_function
name|s32
name|ixgbe_fc_enable_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|s32
name|packetbuf_num
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u32
name|mflcn_reg
decl_stmt|,
name|fccfg_reg
decl_stmt|;
name|u32
name|reg
decl_stmt|;
name|u32
name|rx_pba_size
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_fc_enable_generic"
argument_list|)
expr_stmt|;
comment|/* Negotiate the fc mode to use */
name|ret_val
operator|=
name|ixgbe_fc_autoneg
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* Disable any previous flow control settings */
name|mflcn_reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MFLCN
argument_list|)
expr_stmt|;
name|mflcn_reg
operator|&=
operator|~
operator|(
name|IXGBE_MFLCN_RFCE
operator||
name|IXGBE_MFLCN_RPFCE
operator|)
expr_stmt|;
name|fccfg_reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCCFG
argument_list|)
expr_stmt|;
name|fccfg_reg
operator|&=
operator|~
operator|(
name|IXGBE_FCCFG_TFCE_802_3X
operator||
name|IXGBE_FCCFG_TFCE_PRIORITY
operator|)
expr_stmt|;
comment|/* 	 * The possible values of fc.current_mode are: 	 * 0: Flow control is completely disabled 	 * 1: Rx flow control is enabled (we can receive pause frames, 	 *    but not send pause frames). 	 * 2: Tx flow control is enabled (we can send pause frames but 	 *    we do not support receiving pause frames). 	 * 3: Both Rx and Tx flow control (symmetric) are enabled. 	 * other: Invalid. 	 */
switch|switch
condition|(
name|hw
operator|->
name|fc
operator|.
name|current_mode
condition|)
block|{
case|case
name|ixgbe_fc_none
case|:
comment|/* Flow control is disabled by software override or autoneg. 		 * The code below will actually disable it in the HW. 		 */
break|break;
case|case
name|ixgbe_fc_rx_pause
case|:
comment|/* 		 * Rx Flow control is enabled and Tx Flow control is 		 * disabled by software override. Since there really 		 * isn't a way to advertise that we are capable of RX 		 * Pause ONLY, we will advertise that we support both 		 * symmetric and asymmetric Rx PAUSE.  Later, we will 		 * disable the adapter's ability to send PAUSE frames. 		 */
name|mflcn_reg
operator||=
name|IXGBE_MFLCN_RFCE
expr_stmt|;
break|break;
case|case
name|ixgbe_fc_tx_pause
case|:
comment|/* 		 * Tx Flow control is enabled, and Rx Flow control is 		 * disabled by software override. 		 */
name|fccfg_reg
operator||=
name|IXGBE_FCCFG_TFCE_802_3X
expr_stmt|;
break|break;
case|case
name|ixgbe_fc_full
case|:
comment|/* Flow control (both Rx and Tx) is enabled by SW override. */
name|mflcn_reg
operator||=
name|IXGBE_MFLCN_RFCE
expr_stmt|;
name|fccfg_reg
operator||=
name|IXGBE_FCCFG_TFCE_802_3X
expr_stmt|;
break|break;
default|default:
name|DEBUGOUT
argument_list|(
literal|"Flow control param set incorrectly\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|IXGBE_ERR_CONFIG
expr_stmt|;
goto|goto
name|out
goto|;
break|break;
block|}
comment|/* Set 802.3x based flow control settings. */
name|mflcn_reg
operator||=
name|IXGBE_MFLCN_DPF
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MFLCN
argument_list|,
name|mflcn_reg
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCCFG
argument_list|,
name|fccfg_reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MTQC
argument_list|)
expr_stmt|;
comment|/* Thresholds are different for link flow control when in DCB mode */
if|if
condition|(
name|reg
operator|&
name|IXGBE_MTQC_RT_ENA
condition|)
block|{
name|rx_pba_size
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXPBSIZE
argument_list|(
name|packetbuf_num
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Always disable XON for LFC when in DCB mode */
name|reg
operator|=
operator|(
name|rx_pba_size
operator|>>
literal|5
operator|)
operator|&
literal|0xFFE0
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCRTL_82599
argument_list|(
name|packetbuf_num
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
operator|(
name|rx_pba_size
operator|>>
literal|2
operator|)
operator|&
literal|0xFFE0
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|fc
operator|.
name|current_mode
operator|&
name|ixgbe_fc_tx_pause
condition|)
name|reg
operator||=
name|IXGBE_FCRTH_FCEN
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCRTH_82599
argument_list|(
name|packetbuf_num
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Set up and enable Rx high/low water mark thresholds, 		 * enable XON. */
if|if
condition|(
name|hw
operator|->
name|fc
operator|.
name|current_mode
operator|&
name|ixgbe_fc_tx_pause
condition|)
block|{
if|if
condition|(
name|hw
operator|->
name|fc
operator|.
name|send_xon
condition|)
block|{
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCRTL_82599
argument_list|(
name|packetbuf_num
argument_list|)
argument_list|,
operator|(
name|hw
operator|->
name|fc
operator|.
name|low_water
operator||
name|IXGBE_FCRTL_XONE
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCRTL_82599
argument_list|(
name|packetbuf_num
argument_list|)
argument_list|,
name|hw
operator|->
name|fc
operator|.
name|low_water
argument_list|)
expr_stmt|;
block|}
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCRTH_82599
argument_list|(
name|packetbuf_num
argument_list|)
argument_list|,
operator|(
name|hw
operator|->
name|fc
operator|.
name|high_water
operator||
name|IXGBE_FCRTH_FCEN
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Configure pause time (2 TCs per register) */
name|reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCTTV
argument_list|(
name|packetbuf_num
operator|/
literal|2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|packetbuf_num
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|reg
operator|=
operator|(
name|reg
operator|&
literal|0xFFFF0000
operator|)
operator||
name|hw
operator|->
name|fc
operator|.
name|pause_time
expr_stmt|;
else|else
name|reg
operator|=
operator|(
name|reg
operator|&
literal|0x0000FFFF
operator|)
operator||
operator|(
name|hw
operator|->
name|fc
operator|.
name|pause_time
operator|<<
literal|16
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCTTV
argument_list|(
name|packetbuf_num
operator|/
literal|2
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCRTV
argument_list|,
operator|(
name|hw
operator|->
name|fc
operator|.
name|pause_time
operator|>>
literal|1
operator|)
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_fc_autoneg - Configure flow control  *  @hw: pointer to hardware structure  *  *  Compares our advertised flow control capabilities to those advertised by  *  our link partner, and determines the proper flow control mode to use.  **/
end_comment

begin_function
name|s32
name|ixgbe_fc_autoneg
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|ixgbe_link_speed
name|speed
decl_stmt|;
name|u32
name|pcs_anadv_reg
decl_stmt|,
name|pcs_lpab_reg
decl_stmt|,
name|linkstat
decl_stmt|;
name|u32
name|links2
decl_stmt|,
name|anlp1_reg
decl_stmt|,
name|autoc_reg
decl_stmt|,
name|links
decl_stmt|;
name|bool
name|link_up
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_fc_autoneg"
argument_list|)
expr_stmt|;
comment|/* 	 * AN should have completed when the cable was plugged in. 	 * Look for reasons to bail out.  Bail out if: 	 * - FC autoneg is disabled, or if 	 * - link is not up. 	 * 	 * Since we're being called from an LSC, link is already known to be up. 	 * So use link_up_wait_to_complete=FALSE. 	 */
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|check_link
argument_list|(
name|hw
argument_list|,
operator|&
name|speed
argument_list|,
operator|&
name|link_up
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|fc
operator|.
name|disable_fc_autoneg
operator|||
operator|(
operator|!
name|link_up
operator|)
condition|)
block|{
name|hw
operator|->
name|fc
operator|.
name|fc_was_autonegged
operator|=
name|FALSE
expr_stmt|;
name|hw
operator|->
name|fc
operator|.
name|current_mode
operator|=
name|hw
operator|->
name|fc
operator|.
name|requested_mode
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * On backplane, bail out if 	 * - backplane autoneg was not completed, or if 	 * - we are 82599 and link partner is not AN enabled 	 */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|==
name|ixgbe_media_type_backplane
condition|)
block|{
name|links
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LINKS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|links
operator|&
name|IXGBE_LINKS_KX_AN_COMP
operator|)
operator|==
literal|0
condition|)
block|{
name|hw
operator|->
name|fc
operator|.
name|fc_was_autonegged
operator|=
name|FALSE
expr_stmt|;
name|hw
operator|->
name|fc
operator|.
name|current_mode
operator|=
name|hw
operator|->
name|fc
operator|.
name|requested_mode
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_82599EB
condition|)
block|{
name|links2
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LINKS2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|links2
operator|&
name|IXGBE_LINKS2_AN_SUPPORTED
operator|)
operator|==
literal|0
condition|)
block|{
name|hw
operator|->
name|fc
operator|.
name|fc_was_autonegged
operator|=
name|FALSE
expr_stmt|;
name|hw
operator|->
name|fc
operator|.
name|current_mode
operator|=
name|hw
operator|->
name|fc
operator|.
name|requested_mode
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
block|}
comment|/* 	 * On multispeed fiber at 1g, bail out if 	 * - link is up but AN did not complete, or if 	 * - link is up and AN completed but timed out 	 */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|multispeed_fiber
operator|&&
operator|(
name|speed
operator|==
name|IXGBE_LINK_SPEED_1GB_FULL
operator|)
condition|)
block|{
name|linkstat
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PCS1GLSTA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|linkstat
operator|&
name|IXGBE_PCS1GLSTA_AN_COMPLETE
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|linkstat
operator|&
name|IXGBE_PCS1GLSTA_AN_TIMED_OUT
operator|)
operator|==
literal|1
operator|)
condition|)
block|{
name|hw
operator|->
name|fc
operator|.
name|fc_was_autonegged
operator|=
name|FALSE
expr_stmt|;
name|hw
operator|->
name|fc
operator|.
name|current_mode
operator|=
name|hw
operator|->
name|fc
operator|.
name|requested_mode
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
comment|/* 	 * Bail out on 	 * - copper or CX4 adapters 	 * - fiber adapters running at 10gig 	 */
if|if
condition|(
operator|(
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|==
name|ixgbe_media_type_copper
operator|)
operator|||
operator|(
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|==
name|ixgbe_media_type_cx4
operator|)
operator|||
operator|(
operator|(
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|==
name|ixgbe_media_type_fiber
operator|)
operator|&&
operator|(
name|speed
operator|==
name|IXGBE_LINK_SPEED_10GB_FULL
operator|)
operator|)
condition|)
block|{
name|hw
operator|->
name|fc
operator|.
name|fc_was_autonegged
operator|=
name|FALSE
expr_stmt|;
name|hw
operator|->
name|fc
operator|.
name|current_mode
operator|=
name|hw
operator|->
name|fc
operator|.
name|requested_mode
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Read the AN advertisement and LP ability registers and resolve 	 * local flow control settings accordingly 	 */
if|if
condition|(
operator|(
name|speed
operator|==
name|IXGBE_LINK_SPEED_1GB_FULL
operator|)
operator|&&
operator|(
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|!=
name|ixgbe_media_type_backplane
operator|)
condition|)
block|{
name|pcs_anadv_reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PCS1GANA
argument_list|)
expr_stmt|;
name|pcs_lpab_reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PCS1GANLP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pcs_anadv_reg
operator|&
name|IXGBE_PCS1GANA_SYM_PAUSE
operator|)
operator|&&
operator|(
name|pcs_lpab_reg
operator|&
name|IXGBE_PCS1GANA_SYM_PAUSE
operator|)
condition|)
block|{
comment|/* 			 * Now we need to check if the user selected Rx ONLY 			 * of pause frames.  In this case, we had to advertise 			 * FULL flow control because we could not advertise RX 			 * ONLY. Hence, we must now check to see if we need to 			 * turn OFF the TRANSMISSION of PAUSE frames. 			 */
if|if
condition|(
name|hw
operator|->
name|fc
operator|.
name|requested_mode
operator|==
name|ixgbe_fc_full
condition|)
block|{
name|hw
operator|->
name|fc
operator|.
name|current_mode
operator|=
name|ixgbe_fc_full
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Flow Control = FULL.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hw
operator|->
name|fc
operator|.
name|current_mode
operator|=
name|ixgbe_fc_rx_pause
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Flow Control=RX PAUSE frames only\n"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|pcs_anadv_reg
operator|&
name|IXGBE_PCS1GANA_SYM_PAUSE
operator|)
operator|&&
operator|(
name|pcs_anadv_reg
operator|&
name|IXGBE_PCS1GANA_ASM_PAUSE
operator|)
operator|&&
operator|(
name|pcs_lpab_reg
operator|&
name|IXGBE_PCS1GANA_SYM_PAUSE
operator|)
operator|&&
operator|(
name|pcs_lpab_reg
operator|&
name|IXGBE_PCS1GANA_ASM_PAUSE
operator|)
condition|)
block|{
name|hw
operator|->
name|fc
operator|.
name|current_mode
operator|=
name|ixgbe_fc_tx_pause
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Flow Control = TX PAUSE frames only.\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|pcs_anadv_reg
operator|&
name|IXGBE_PCS1GANA_SYM_PAUSE
operator|)
operator|&&
operator|(
name|pcs_anadv_reg
operator|&
name|IXGBE_PCS1GANA_ASM_PAUSE
operator|)
operator|&&
operator|!
operator|(
name|pcs_lpab_reg
operator|&
name|IXGBE_PCS1GANA_SYM_PAUSE
operator|)
operator|&&
operator|(
name|pcs_lpab_reg
operator|&
name|IXGBE_PCS1GANA_ASM_PAUSE
operator|)
condition|)
block|{
name|hw
operator|->
name|fc
operator|.
name|current_mode
operator|=
name|ixgbe_fc_rx_pause
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Flow Control = RX PAUSE frames only.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hw
operator|->
name|fc
operator|.
name|current_mode
operator|=
name|ixgbe_fc_none
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Flow Control = NONE.\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|==
name|ixgbe_media_type_backplane
condition|)
block|{
comment|/* 		 * Read the 10g AN autoc and LP ability registers and resolve 		 * local flow control settings accordingly 		 */
name|autoc_reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC
argument_list|)
expr_stmt|;
name|anlp1_reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ANLP1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|autoc_reg
operator|&
name|IXGBE_AUTOC_SYM_PAUSE
operator|)
operator|&&
operator|(
name|anlp1_reg
operator|&
name|IXGBE_ANLP1_SYM_PAUSE
operator|)
condition|)
block|{
comment|/* 			 * Now we need to check if the user selected Rx ONLY 			 * of pause frames.  In this case, we had to advertise 			 * FULL flow control because we could not advertise RX 			 * ONLY. Hence, we must now check to see if we need to 			 * turn OFF the TRANSMISSION of PAUSE frames. 			 */
if|if
condition|(
name|hw
operator|->
name|fc
operator|.
name|requested_mode
operator|==
name|ixgbe_fc_full
condition|)
block|{
name|hw
operator|->
name|fc
operator|.
name|current_mode
operator|=
name|ixgbe_fc_full
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Flow Control = FULL.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hw
operator|->
name|fc
operator|.
name|current_mode
operator|=
name|ixgbe_fc_rx_pause
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Flow Control=RX PAUSE frames only\n"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|autoc_reg
operator|&
name|IXGBE_AUTOC_SYM_PAUSE
operator|)
operator|&&
operator|(
name|autoc_reg
operator|&
name|IXGBE_AUTOC_ASM_PAUSE
operator|)
operator|&&
operator|(
name|anlp1_reg
operator|&
name|IXGBE_ANLP1_SYM_PAUSE
operator|)
operator|&&
operator|(
name|anlp1_reg
operator|&
name|IXGBE_ANLP1_ASM_PAUSE
operator|)
condition|)
block|{
name|hw
operator|->
name|fc
operator|.
name|current_mode
operator|=
name|ixgbe_fc_tx_pause
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Flow Control = TX PAUSE frames only.\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|autoc_reg
operator|&
name|IXGBE_AUTOC_SYM_PAUSE
operator|)
operator|&&
operator|(
name|autoc_reg
operator|&
name|IXGBE_AUTOC_ASM_PAUSE
operator|)
operator|&&
operator|!
operator|(
name|anlp1_reg
operator|&
name|IXGBE_ANLP1_SYM_PAUSE
operator|)
operator|&&
operator|(
name|anlp1_reg
operator|&
name|IXGBE_ANLP1_ASM_PAUSE
operator|)
condition|)
block|{
name|hw
operator|->
name|fc
operator|.
name|current_mode
operator|=
name|ixgbe_fc_rx_pause
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Flow Control = RX PAUSE frames only.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hw
operator|->
name|fc
operator|.
name|current_mode
operator|=
name|ixgbe_fc_none
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Flow Control = NONE.\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Record that current_mode is the result of a successful autoneg */
name|hw
operator|->
name|fc
operator|.
name|fc_was_autonegged
operator|=
name|TRUE
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_setup_fc - Set up flow control  *  @hw: pointer to hardware structure  *  *  Called at init time to set up flow control.  **/
end_comment

begin_function
name|s32
name|ixgbe_setup_fc
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|s32
name|packetbuf_num
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u32
name|reg
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_setup_fc"
argument_list|)
expr_stmt|;
comment|/* Validate the packetbuf configuration */
if|if
condition|(
name|packetbuf_num
operator|<
literal|0
operator|||
name|packetbuf_num
operator|>
literal|7
condition|)
block|{
name|DEBUGOUT1
argument_list|(
literal|"Invalid packet buffer number [%d], expected range is"
literal|" 0-7\n"
argument_list|,
name|packetbuf_num
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|IXGBE_ERR_INVALID_LINK_SETTINGS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Validate the water mark configuration.  Zero water marks are invalid 	 * because it causes the controller to just blast out fc packets. 	 */
if|if
condition|(
operator|!
name|hw
operator|->
name|fc
operator|.
name|low_water
operator|||
operator|!
name|hw
operator|->
name|fc
operator|.
name|high_water
operator|||
operator|!
name|hw
operator|->
name|fc
operator|.
name|pause_time
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Invalid water mark configuration\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|IXGBE_ERR_INVALID_LINK_SETTINGS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Validate the requested mode.  Strict IEEE mode does not allow 	 * ixgbe_fc_rx_pause because it will cause us to fail at UNH. 	 */
if|if
condition|(
name|hw
operator|->
name|fc
operator|.
name|strict_ieee
operator|&&
name|hw
operator|->
name|fc
operator|.
name|requested_mode
operator|==
name|ixgbe_fc_rx_pause
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"ixgbe_fc_rx_pause not valid in strict IEEE mode\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|IXGBE_ERR_INVALID_LINK_SETTINGS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * 10gig parts do not have a word in the EEPROM to determine the 	 * default flow control setting, so we explicitly set it to full. 	 */
if|if
condition|(
name|hw
operator|->
name|fc
operator|.
name|requested_mode
operator|==
name|ixgbe_fc_default
condition|)
name|hw
operator|->
name|fc
operator|.
name|requested_mode
operator|=
name|ixgbe_fc_full
expr_stmt|;
comment|/* 	 * Set up the 1G flow control advertisement registers so the HW will be 	 * able to do fc autoneg once the cable is plugged in.  If we end up 	 * using 10g instead, this is harmless. 	 */
name|reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PCS1GANA
argument_list|)
expr_stmt|;
comment|/* 	 * The possible values of fc.requested_mode are: 	 * 0: Flow control is completely disabled 	 * 1: Rx flow control is enabled (we can receive pause frames, 	 *    but not send pause frames). 	 * 2: Tx flow control is enabled (we can send pause frames but 	 *    we do not support receiving pause frames). 	 * 3: Both Rx and Tx flow control (symmetric) are enabled. 	 * other: Invalid. 	 */
switch|switch
condition|(
name|hw
operator|->
name|fc
operator|.
name|requested_mode
condition|)
block|{
case|case
name|ixgbe_fc_none
case|:
comment|/* Flow control completely disabled by software override. */
name|reg
operator|&=
operator|~
operator|(
name|IXGBE_PCS1GANA_SYM_PAUSE
operator||
name|IXGBE_PCS1GANA_ASM_PAUSE
operator|)
expr_stmt|;
break|break;
case|case
name|ixgbe_fc_rx_pause
case|:
comment|/* 		 * Rx Flow control is enabled and Tx Flow control is 		 * disabled by software override. Since there really 		 * isn't a way to advertise that we are capable of RX 		 * Pause ONLY, we will advertise that we support both 		 * symmetric and asymmetric Rx PAUSE.  Later, we will 		 * disable the adapter's ability to send PAUSE frames. 		 */
name|reg
operator||=
operator|(
name|IXGBE_PCS1GANA_SYM_PAUSE
operator||
name|IXGBE_PCS1GANA_ASM_PAUSE
operator|)
expr_stmt|;
break|break;
case|case
name|ixgbe_fc_tx_pause
case|:
comment|/* 		 * Tx Flow control is enabled, and Rx Flow control is 		 * disabled by software override. 		 */
name|reg
operator||=
operator|(
name|IXGBE_PCS1GANA_ASM_PAUSE
operator|)
expr_stmt|;
name|reg
operator|&=
operator|~
operator|(
name|IXGBE_PCS1GANA_SYM_PAUSE
operator|)
expr_stmt|;
break|break;
case|case
name|ixgbe_fc_full
case|:
comment|/* Flow control (both Rx and Tx) is enabled by SW override. */
name|reg
operator||=
operator|(
name|IXGBE_PCS1GANA_SYM_PAUSE
operator||
name|IXGBE_PCS1GANA_ASM_PAUSE
operator|)
expr_stmt|;
break|break;
default|default:
name|DEBUGOUT
argument_list|(
literal|"Flow control param set incorrectly\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|IXGBE_ERR_CONFIG
expr_stmt|;
goto|goto
name|out
goto|;
break|break;
block|}
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PCS1GANA
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PCS1GLCTL
argument_list|)
expr_stmt|;
comment|/* Disable AN timeout */
if|if
condition|(
name|hw
operator|->
name|fc
operator|.
name|strict_ieee
condition|)
name|reg
operator|&=
operator|~
name|IXGBE_PCS1GLCTL_AN_1G_TIMEOUT_EN
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PCS1GLCTL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"Set up FC; PCS1GLCTL = 0x%08X\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* 	 * Set up the 10G flow control advertisement registers so the HW 	 * can do fc autoneg once the cable is plugged in.  If we end up 	 * using 1g instead, this is harmless. 	 */
name|reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC
argument_list|)
expr_stmt|;
comment|/* 	 * The possible values of fc.requested_mode are: 	 * 0: Flow control is completely disabled 	 * 1: Rx flow control is enabled (we can receive pause frames, 	 *    but not send pause frames). 	 * 2: Tx flow control is enabled (we can send pause frames but 	 *    we do not support receiving pause frames). 	 * 3: Both Rx and Tx flow control (symmetric) are enabled. 	 * other: Invalid. 	 */
switch|switch
condition|(
name|hw
operator|->
name|fc
operator|.
name|requested_mode
condition|)
block|{
case|case
name|ixgbe_fc_none
case|:
comment|/* Flow control completely disabled by software override. */
name|reg
operator|&=
operator|~
operator|(
name|IXGBE_AUTOC_SYM_PAUSE
operator||
name|IXGBE_AUTOC_ASM_PAUSE
operator|)
expr_stmt|;
break|break;
case|case
name|ixgbe_fc_rx_pause
case|:
comment|/* 		 * Rx Flow control is enabled and Tx Flow control is 		 * disabled by software override. Since there really 		 * isn't a way to advertise that we are capable of RX 		 * Pause ONLY, we will advertise that we support both 		 * symmetric and asymmetric Rx PAUSE.  Later, we will 		 * disable the adapter's ability to send PAUSE frames. 		 */
name|reg
operator||=
operator|(
name|IXGBE_AUTOC_SYM_PAUSE
operator||
name|IXGBE_AUTOC_ASM_PAUSE
operator|)
expr_stmt|;
break|break;
case|case
name|ixgbe_fc_tx_pause
case|:
comment|/* 		 * Tx Flow control is enabled, and Rx Flow control is 		 * disabled by software override. 		 */
name|reg
operator||=
operator|(
name|IXGBE_AUTOC_ASM_PAUSE
operator|)
expr_stmt|;
name|reg
operator|&=
operator|~
operator|(
name|IXGBE_AUTOC_SYM_PAUSE
operator|)
expr_stmt|;
break|break;
case|case
name|ixgbe_fc_full
case|:
comment|/* Flow control (both Rx and Tx) is enabled by SW override. */
name|reg
operator||=
operator|(
name|IXGBE_AUTOC_SYM_PAUSE
operator||
name|IXGBE_AUTOC_ASM_PAUSE
operator|)
expr_stmt|;
break|break;
default|default:
name|DEBUGOUT
argument_list|(
literal|"Flow control param set incorrectly\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|IXGBE_ERR_CONFIG
expr_stmt|;
goto|goto
name|out
goto|;
break|break;
block|}
comment|/* 	 * AUTOC restart handles negotiation of 1G and 10G. There is 	 * no need to set the PCS1GCTL register. 	 */
name|reg
operator||=
name|IXGBE_AUTOC_AN_RESTART
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"Set up FC; IXGBE_AUTOC = 0x%08X\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_disable_pcie_master - Disable PCI-express master access  *  @hw: pointer to hardware structure  *  *  Disables PCI-Express master access and verifies there are no pending  *  requests. IXGBE_ERR_MASTER_REQUESTS_PENDING is returned if master disable  *  bit hasn't caused the master requests to be disabled, else IXGBE_SUCCESS  *  is returned signifying master requests disabled.  **/
end_comment

begin_function
name|s32
name|ixgbe_disable_pcie_master
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|i
decl_stmt|;
name|u32
name|reg_val
decl_stmt|;
name|u32
name|number_of_queues
decl_stmt|;
name|s32
name|status
init|=
name|IXGBE_ERR_MASTER_REQUESTS_PENDING
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_disable_pcie_master"
argument_list|)
expr_stmt|;
comment|/* Disable the receive unit by stopping each queue */
name|number_of_queues
operator|=
name|hw
operator|->
name|mac
operator|.
name|max_rx_queues
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|number_of_queues
condition|;
name|i
operator|++
control|)
block|{
name|reg_val
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXDCTL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_val
operator|&
name|IXGBE_RXDCTL_ENABLE
condition|)
block|{
name|reg_val
operator|&=
operator|~
name|IXGBE_RXDCTL_ENABLE
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXDCTL
argument_list|(
name|i
argument_list|)
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
block|}
block|}
name|reg_val
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CTRL
argument_list|)
expr_stmt|;
name|reg_val
operator||=
name|IXGBE_CTRL_GIO_DIS
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CTRL
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_PCI_MASTER_DISABLE_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_STATUS
argument_list|)
operator|&
name|IXGBE_STATUS_GIO
operator|)
condition|)
block|{
name|status
operator|=
name|IXGBE_SUCCESS
expr_stmt|;
break|break;
block|}
name|usec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_acquire_swfw_sync - Acquire SWFW semaphore  *  @hw: pointer to hardware structure  *  @mask: Mask to specify which semaphore to acquire  *  *  Acquires the SWFW semaphore thought the GSSR register for the specified  *  function (CSR, PHY0, PHY1, EEPROM, Flash)  **/
end_comment

begin_function
name|s32
name|ixgbe_acquire_swfw_sync
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|mask
parameter_list|)
block|{
name|u32
name|gssr
decl_stmt|;
name|u32
name|swmask
init|=
name|mask
decl_stmt|;
name|u32
name|fwmask
init|=
name|mask
operator|<<
literal|5
decl_stmt|;
name|s32
name|timeout
init|=
literal|200
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_acquire_swfw_sync"
argument_list|)
expr_stmt|;
while|while
condition|(
name|timeout
condition|)
block|{
comment|/* 		 * SW EEPROM semaphore bit is used for access to all 		 * SW_FW_SYNC/GSSR bits (not just EEPROM) 		 */
if|if
condition|(
name|ixgbe_get_eeprom_semaphore
argument_list|(
name|hw
argument_list|)
condition|)
return|return
name|IXGBE_ERR_SWFW_SYNC
return|;
name|gssr
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|gssr
operator|&
operator|(
name|fwmask
operator||
name|swmask
operator|)
operator|)
condition|)
break|break;
comment|/* 		 * Firmware currently using resource (fwmask) or other software 		 * thread currently using resource (swmask) 		 */
name|ixgbe_release_eeprom_semaphore
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|timeout
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|timeout
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Driver can't access resource, SW_FW_SYNC timeout.\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_SWFW_SYNC
return|;
block|}
name|gssr
operator||=
name|swmask
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR
argument_list|,
name|gssr
argument_list|)
expr_stmt|;
name|ixgbe_release_eeprom_semaphore
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_release_swfw_sync - Release SWFW semaphore  *  @hw: pointer to hardware structure  *  @mask: Mask to specify which semaphore to release  *  *  Releases the SWFW semaphore thought the GSSR register for the specified  *  function (CSR, PHY0, PHY1, EEPROM, Flash)  **/
end_comment

begin_function
name|void
name|ixgbe_release_swfw_sync
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|mask
parameter_list|)
block|{
name|u32
name|gssr
decl_stmt|;
name|u32
name|swmask
init|=
name|mask
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_release_swfw_sync"
argument_list|)
expr_stmt|;
name|ixgbe_get_eeprom_semaphore
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|gssr
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR
argument_list|)
expr_stmt|;
name|gssr
operator|&=
operator|~
name|swmask
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR
argument_list|,
name|gssr
argument_list|)
expr_stmt|;
name|ixgbe_release_eeprom_semaphore
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_enable_rx_dma_generic - Enable the Rx DMA unit  *  @hw: pointer to hardware structure  *  @regval: register value to write to RXCTRL  *  *  Enables the Rx DMA unit  **/
end_comment

begin_function
name|s32
name|ixgbe_enable_rx_dma_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|regval
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_enable_rx_dma_generic"
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXCTRL
argument_list|,
name|regval
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_blink_led_start_generic - Blink LED based on index.  *  @hw: pointer to hardware structure  *  @index: led number to blink  **/
end_comment

begin_function
name|s32
name|ixgbe_blink_led_start_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|index
parameter_list|)
block|{
name|ixgbe_link_speed
name|speed
init|=
literal|0
decl_stmt|;
name|bool
name|link_up
init|=
literal|0
decl_stmt|;
name|u32
name|autoc_reg
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC
argument_list|)
decl_stmt|;
name|u32
name|led_reg
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LEDCTL
argument_list|)
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_blink_led_start_generic"
argument_list|)
expr_stmt|;
comment|/* 	 * Link must be up to auto-blink the LEDs; 	 * Force it if link is down. 	 */
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|check_link
argument_list|(
name|hw
argument_list|,
operator|&
name|speed
argument_list|,
operator|&
name|link_up
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|link_up
condition|)
block|{
name|autoc_reg
operator||=
name|IXGBE_AUTOC_AN_RESTART
expr_stmt|;
name|autoc_reg
operator||=
name|IXGBE_AUTOC_FLU
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC
argument_list|,
name|autoc_reg
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
name|led_reg
operator|&=
operator|~
name|IXGBE_LED_MODE_MASK
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|led_reg
operator||=
name|IXGBE_LED_BLINK
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LEDCTL
argument_list|,
name|led_reg
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_blink_led_stop_generic - Stop blinking LED based on index.  *  @hw: pointer to hardware structure  *  @index: led number to stop blinking  **/
end_comment

begin_function
name|s32
name|ixgbe_blink_led_stop_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|index
parameter_list|)
block|{
name|u32
name|autoc_reg
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC
argument_list|)
decl_stmt|;
name|u32
name|led_reg
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LEDCTL
argument_list|)
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_blink_led_stop_generic"
argument_list|)
expr_stmt|;
name|autoc_reg
operator|&=
operator|~
name|IXGBE_AUTOC_FLU
expr_stmt|;
name|autoc_reg
operator||=
name|IXGBE_AUTOC_AN_RESTART
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC
argument_list|,
name|autoc_reg
argument_list|)
expr_stmt|;
name|led_reg
operator|&=
operator|~
name|IXGBE_LED_MODE_MASK
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|led_reg
operator|&=
operator|~
name|IXGBE_LED_BLINK
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|led_reg
operator||=
name|IXGBE_LED_LINK_ACTIVE
operator|<<
name|IXGBE_LED_MODE_SHIFT
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LEDCTL
argument_list|,
name|led_reg
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_san_mac_addr_offset - Get SAN MAC address offset from the EEPROM  *  @hw: pointer to hardware structure  *  @san_mac_offset: SAN MAC address offset  *  *  This function will read the EEPROM location for the SAN MAC address  *  pointer, and returns the value at that location.  This is used in both  *  get and set mac_addr routines.  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_get_san_mac_addr_offset
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|san_mac_offset
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_san_mac_addr_offset"
argument_list|)
expr_stmt|;
comment|/* 	 * First read the EEPROM pointer to see if the MAC addresses are 	 * available. 	 */
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|IXGBE_SAN_MAC_ADDR_PTR
argument_list|,
name|san_mac_offset
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_san_mac_addr_generic - SAN MAC address retrieval from the EEPROM  *  @hw: pointer to hardware structure  *  @san_mac_addr: SAN MAC address  *  *  Reads the SAN MAC address from the EEPROM, if it's available.  This is  *  per-port, so set_lan_id() must be called before reading the addresses.  *  set_lan_id() is called by identify_sfp(), but this cannot be relied  *  upon for non-SFP connections, so we must call it here.  **/
end_comment

begin_function
name|s32
name|ixgbe_get_san_mac_addr_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|san_mac_addr
parameter_list|)
block|{
name|u16
name|san_mac_data
decl_stmt|,
name|san_mac_offset
decl_stmt|;
name|u8
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_san_mac_addr_generic"
argument_list|)
expr_stmt|;
comment|/* 	 * First read the EEPROM pointer to see if the MAC addresses are 	 * available.  If they're not, no point in calling set_lan_id() here. 	 */
name|ixgbe_get_san_mac_addr_offset
argument_list|(
name|hw
argument_list|,
operator|&
name|san_mac_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|san_mac_offset
operator|==
literal|0
operator|)
operator|||
operator|(
name|san_mac_offset
operator|==
literal|0xFFFF
operator|)
condition|)
block|{
comment|/* 		 * No addresses available in this EEPROM.  It's not an 		 * error though, so just wipe the local address and return. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
name|san_mac_addr
index|[
name|i
index|]
operator|=
literal|0xFF
expr_stmt|;
goto|goto
name|san_mac_addr_out
goto|;
block|}
comment|/* make sure we know which port we need to program */
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|set_lan_id
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* apply the port offset to the address offset */
operator|(
name|hw
operator|->
name|bus
operator|.
name|func
operator|)
condition|?
operator|(
name|san_mac_offset
operator|+=
name|IXGBE_SAN_MAC_ADDR_PORT1_OFFSET
operator|)
else|:
operator|(
name|san_mac_offset
operator|+=
name|IXGBE_SAN_MAC_ADDR_PORT0_OFFSET
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|san_mac_offset
argument_list|,
operator|&
name|san_mac_data
argument_list|)
expr_stmt|;
name|san_mac_addr
index|[
name|i
operator|*
literal|2
index|]
operator|=
call|(
name|u8
call|)
argument_list|(
name|san_mac_data
argument_list|)
expr_stmt|;
name|san_mac_addr
index|[
name|i
operator|*
literal|2
operator|+
literal|1
index|]
operator|=
call|(
name|u8
call|)
argument_list|(
name|san_mac_data
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|san_mac_offset
operator|++
expr_stmt|;
block|}
name|san_mac_addr_out
label|:
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_set_san_mac_addr_generic - Write the SAN MAC address to the EEPROM  *  @hw: pointer to hardware structure  *  @san_mac_addr: SAN MAC address  *  *  Write a SAN MAC address to the EEPROM.  **/
end_comment

begin_function
name|s32
name|ixgbe_set_san_mac_addr_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|san_mac_addr
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u16
name|san_mac_data
decl_stmt|,
name|san_mac_offset
decl_stmt|;
name|u8
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_set_san_mac_addr_generic"
argument_list|)
expr_stmt|;
comment|/* Look for SAN mac address pointer.  If not defined, return */
name|ixgbe_get_san_mac_addr_offset
argument_list|(
name|hw
argument_list|,
operator|&
name|san_mac_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|san_mac_offset
operator|==
literal|0
operator|)
operator|||
operator|(
name|san_mac_offset
operator|==
literal|0xFFFF
operator|)
condition|)
block|{
name|status
operator|=
name|IXGBE_ERR_NO_SAN_ADDR_PTR
expr_stmt|;
goto|goto
name|san_mac_addr_out
goto|;
block|}
comment|/* Make sure we know which port we need to write */
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|set_lan_id
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Apply the port offset to the address offset */
operator|(
name|hw
operator|->
name|bus
operator|.
name|func
operator|)
condition|?
operator|(
name|san_mac_offset
operator|+=
name|IXGBE_SAN_MAC_ADDR_PORT1_OFFSET
operator|)
else|:
operator|(
name|san_mac_offset
operator|+=
name|IXGBE_SAN_MAC_ADDR_PORT0_OFFSET
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|san_mac_data
operator|=
call|(
name|u16
call|)
argument_list|(
call|(
name|u16
call|)
argument_list|(
name|san_mac_addr
index|[
name|i
operator|*
literal|2
operator|+
literal|1
index|]
argument_list|)
operator|<<
literal|8
argument_list|)
expr_stmt|;
name|san_mac_data
operator||=
call|(
name|u16
call|)
argument_list|(
name|san_mac_addr
index|[
name|i
operator|*
literal|2
index|]
argument_list|)
expr_stmt|;
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|write
argument_list|(
name|hw
argument_list|,
name|san_mac_offset
argument_list|,
name|san_mac_data
argument_list|)
expr_stmt|;
name|san_mac_offset
operator|++
expr_stmt|;
block|}
name|san_mac_addr_out
label|:
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_pcie_msix_count_generic - Gets MSI-X vector count  *  @hw: pointer to hardware structure  *  *  Read PCIe configuration space, and get the MSI-X vector count from  *  the capabilities table.  **/
end_comment

begin_function
name|u32
name|ixgbe_get_pcie_msix_count_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|msix_count
init|=
literal|64
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_pcie_msix_count_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|msix_vectors_from_pcie
condition|)
block|{
name|msix_count
operator|=
name|IXGBE_READ_PCIE_WORD
argument_list|(
name|hw
argument_list|,
name|IXGBE_PCIE_MSIX_82599_CAPS
argument_list|)
expr_stmt|;
name|msix_count
operator|&=
name|IXGBE_PCIE_MSIX_TBL_SZ_MASK
expr_stmt|;
comment|/* MSI-X count is zero-based in HW, so increment to give 		 * proper value */
name|msix_count
operator|++
expr_stmt|;
block|}
return|return
name|msix_count
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_insert_mac_addr_generic - Find a RAR for this mac address  *  @hw: pointer to hardware structure  *  @addr: Address to put into receive address register  *  @vmdq: VMDq pool to assign  *  *  Puts an ethernet address into a receive address register, or  *  finds the rar that it is aleady in; adds to the pool list  **/
end_comment

begin_function
name|s32
name|ixgbe_insert_mac_addr_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|addr
parameter_list|,
name|u32
name|vmdq
parameter_list|)
block|{
specifier|static
specifier|const
name|u32
name|NO_EMPTY_RAR_FOUND
init|=
literal|0xFFFFFFFF
decl_stmt|;
name|u32
name|first_empty_rar
init|=
name|NO_EMPTY_RAR_FOUND
decl_stmt|;
name|u32
name|rar
decl_stmt|;
name|u32
name|rar_low
decl_stmt|,
name|rar_high
decl_stmt|;
name|u32
name|addr_low
decl_stmt|,
name|addr_high
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_insert_mac_addr_generic"
argument_list|)
expr_stmt|;
comment|/* swap bytes for HW little endian */
name|addr_low
operator|=
name|addr
index|[
literal|0
index|]
operator||
operator|(
name|addr
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|addr
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|addr
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
expr_stmt|;
name|addr_high
operator|=
name|addr
index|[
literal|4
index|]
operator||
operator|(
name|addr
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
comment|/* 	 * Either find the mac_id in rar or find the first empty space. 	 * rar_highwater points to just after the highest currently used 	 * rar in order to shorten the search.  It grows when we add a new 	 * rar to the top. 	 */
for|for
control|(
name|rar
operator|=
literal|0
init|;
name|rar
operator|<
name|hw
operator|->
name|mac
operator|.
name|rar_highwater
condition|;
name|rar
operator|++
control|)
block|{
name|rar_high
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RAH
argument_list|(
name|rar
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|IXGBE_RAH_AV
operator|&
name|rar_high
operator|)
operator|==
literal|0
operator|)
operator|&&
name|first_empty_rar
operator|==
name|NO_EMPTY_RAR_FOUND
condition|)
block|{
name|first_empty_rar
operator|=
name|rar
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|rar_high
operator|&
literal|0xFFFF
operator|)
operator|==
name|addr_high
condition|)
block|{
name|rar_low
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RAL
argument_list|(
name|rar
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rar_low
operator|==
name|addr_low
condition|)
break|break;
comment|/* found it already in the rars */
block|}
block|}
if|if
condition|(
name|rar
operator|<
name|hw
operator|->
name|mac
operator|.
name|rar_highwater
condition|)
block|{
comment|/* already there so just add to the pool bits */
name|ixgbe_set_vmdq
argument_list|(
name|hw
argument_list|,
name|rar
argument_list|,
name|vmdq
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|first_empty_rar
operator|!=
name|NO_EMPTY_RAR_FOUND
condition|)
block|{
comment|/* stick it into first empty RAR slot we found */
name|rar
operator|=
name|first_empty_rar
expr_stmt|;
name|ixgbe_set_rar
argument_list|(
name|hw
argument_list|,
name|rar
argument_list|,
name|addr
argument_list|,
name|vmdq
argument_list|,
name|IXGBE_RAH_AV
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rar
operator|==
name|hw
operator|->
name|mac
operator|.
name|rar_highwater
condition|)
block|{
comment|/* add it to the top of the list and inc the highwater mark */
name|ixgbe_set_rar
argument_list|(
name|hw
argument_list|,
name|rar
argument_list|,
name|addr
argument_list|,
name|vmdq
argument_list|,
name|IXGBE_RAH_AV
argument_list|)
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|rar_highwater
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rar
operator|>=
name|hw
operator|->
name|mac
operator|.
name|num_rar_entries
condition|)
block|{
return|return
name|IXGBE_ERR_INVALID_MAC_ADDR
return|;
block|}
comment|/* 	 * If we found rar[0], make sure the default pool bit (we use pool 0) 	 * remains cleared to be sure default pool packets will get delivered 	 */
if|if
condition|(
name|rar
operator|==
literal|0
condition|)
name|ixgbe_clear_vmdq
argument_list|(
name|hw
argument_list|,
name|rar
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|rar
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_clear_vmdq_generic - Disassociate a VMDq pool index from a rx address  *  @hw: pointer to hardware struct  *  @rar: receive address register index to disassociate  *  @vmdq: VMDq pool index to remove from the rar  **/
end_comment

begin_function
name|s32
name|ixgbe_clear_vmdq_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|rar
parameter_list|,
name|u32
name|vmdq
parameter_list|)
block|{
name|u32
name|mpsar_lo
decl_stmt|,
name|mpsar_hi
decl_stmt|;
name|u32
name|rar_entries
init|=
name|hw
operator|->
name|mac
operator|.
name|num_rar_entries
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_clear_vmdq_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rar
operator|<
name|rar_entries
condition|)
block|{
name|mpsar_lo
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MPSAR_LO
argument_list|(
name|rar
argument_list|)
argument_list|)
expr_stmt|;
name|mpsar_hi
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MPSAR_HI
argument_list|(
name|rar
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mpsar_lo
operator|&&
operator|!
name|mpsar_hi
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|vmdq
operator|==
name|IXGBE_CLEAR_VMDQ_ALL
condition|)
block|{
if|if
condition|(
name|mpsar_lo
condition|)
block|{
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MPSAR_LO
argument_list|(
name|rar
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mpsar_lo
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|mpsar_hi
condition|)
block|{
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MPSAR_HI
argument_list|(
name|rar
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mpsar_hi
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|vmdq
operator|<
literal|32
condition|)
block|{
name|mpsar_lo
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|vmdq
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MPSAR_LO
argument_list|(
name|rar
argument_list|)
argument_list|,
name|mpsar_lo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mpsar_hi
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
name|vmdq
operator|-
literal|32
operator|)
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MPSAR_HI
argument_list|(
name|rar
argument_list|)
argument_list|,
name|mpsar_hi
argument_list|)
expr_stmt|;
block|}
comment|/* was that the last pool using this rar? */
if|if
condition|(
name|mpsar_lo
operator|==
literal|0
operator|&&
name|mpsar_hi
operator|==
literal|0
operator|&&
name|rar
operator|!=
literal|0
condition|)
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|clear_rar
argument_list|(
name|hw
argument_list|,
name|rar
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DEBUGOUT1
argument_list|(
literal|"RAR index %d is out of range.\n"
argument_list|,
name|rar
argument_list|)
expr_stmt|;
block|}
name|done
label|:
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_set_vmdq_generic - Associate a VMDq pool index with a rx address  *  @hw: pointer to hardware struct  *  @rar: receive address register index to associate with a VMDq index  *  @vmdq: VMDq pool index  **/
end_comment

begin_function
name|s32
name|ixgbe_set_vmdq_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|rar
parameter_list|,
name|u32
name|vmdq
parameter_list|)
block|{
name|u32
name|mpsar
decl_stmt|;
name|u32
name|rar_entries
init|=
name|hw
operator|->
name|mac
operator|.
name|num_rar_entries
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_set_vmdq_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rar
operator|<
name|rar_entries
condition|)
block|{
if|if
condition|(
name|vmdq
operator|<
literal|32
condition|)
block|{
name|mpsar
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MPSAR_LO
argument_list|(
name|rar
argument_list|)
argument_list|)
expr_stmt|;
name|mpsar
operator||=
literal|1
operator|<<
name|vmdq
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MPSAR_LO
argument_list|(
name|rar
argument_list|)
argument_list|,
name|mpsar
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mpsar
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MPSAR_HI
argument_list|(
name|rar
argument_list|)
argument_list|)
expr_stmt|;
name|mpsar
operator||=
literal|1
operator|<<
operator|(
name|vmdq
operator|-
literal|32
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MPSAR_HI
argument_list|(
name|rar
argument_list|)
argument_list|,
name|mpsar
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|DEBUGOUT1
argument_list|(
literal|"RAR index %d is out of range.\n"
argument_list|,
name|rar
argument_list|)
expr_stmt|;
block|}
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_init_uta_tables_generic - Initialize the Unicast Table Array  *  @hw: pointer to hardware structure  **/
end_comment

begin_function
name|s32
name|ixgbe_init_uta_tables_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_init_uta_tables_generic"
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|" Clearing UTA\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|128
condition|;
name|i
operator|++
control|)
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_UTA
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_find_vlvf_slot - find the vlanid or the first empty slot  *  @hw: pointer to hardware structure  *  @vlan: VLAN id to write to VLAN filter  *  *  return the VLVF index where this VLAN id should be placed  *  **/
end_comment

begin_function
name|s32
name|ixgbe_find_vlvf_slot
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|vlan
parameter_list|)
block|{
name|u32
name|bits
init|=
literal|0
decl_stmt|;
name|u32
name|first_empty_slot
init|=
literal|0
decl_stmt|;
name|s32
name|regindex
decl_stmt|;
comment|/* 	  * Search for the vlan id in the VLVF entries. Save off the first empty 	  * slot found along the way 	  */
for|for
control|(
name|regindex
operator|=
literal|1
init|;
name|regindex
operator|<
name|IXGBE_VLVF_ENTRIES
condition|;
name|regindex
operator|++
control|)
block|{
name|bits
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VLVF
argument_list|(
name|regindex
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bits
operator|&&
operator|!
operator|(
name|first_empty_slot
operator|)
condition|)
name|first_empty_slot
operator|=
name|regindex
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|bits
operator|&
literal|0x0FFF
operator|)
operator|==
name|vlan
condition|)
break|break;
block|}
comment|/* 	  * If regindex is less than IXGBE_VLVF_ENTRIES, then we found the vlan 	  * in the VLVF. Else use the first empty VLVF register for this 	  * vlan id. 	  */
if|if
condition|(
name|regindex
operator|>=
name|IXGBE_VLVF_ENTRIES
condition|)
block|{
if|if
condition|(
name|first_empty_slot
condition|)
name|regindex
operator|=
name|first_empty_slot
expr_stmt|;
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"No space in VLVF.\n"
argument_list|)
expr_stmt|;
name|regindex
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
return|return
name|regindex
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_set_vfta_generic - Set VLAN filter table  *  @hw: pointer to hardware structure  *  @vlan: VLAN id to write to VLAN filter  *  @vind: VMDq output index that maps queue to VLAN id in VFVFB  *  @vlan_on: boolean flag to turn on/off VLAN in VFVF  *  *  Turn on/off specified VLAN in the VLAN filter table.  **/
end_comment

begin_function
name|s32
name|ixgbe_set_vfta_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|vlan
parameter_list|,
name|u32
name|vind
parameter_list|,
name|bool
name|vlan_on
parameter_list|)
block|{
name|s32
name|regindex
decl_stmt|;
name|u32
name|bitindex
decl_stmt|;
name|u32
name|bits
decl_stmt|;
name|u32
name|vt
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_set_vfta_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vlan
operator|>
literal|4095
condition|)
return|return
name|IXGBE_ERR_PARAM
return|;
comment|/* 	 * this is a 2 part operation - first the VFTA, then the 	 * VLVF and VLVFB if VT Mode is set 	 */
comment|/* Part 1 	 * The VFTA is a bitstring made up of 128 32-bit registers 	 * that enable the particular VLAN id, much like the MTA: 	 *    bits[11-5]: which register 	 *    bits[4-0]:  which bit in the register 	 */
name|regindex
operator|=
operator|(
name|vlan
operator|>>
literal|5
operator|)
operator|&
literal|0x7F
expr_stmt|;
name|bitindex
operator|=
name|vlan
operator|&
literal|0x1F
expr_stmt|;
name|bits
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VFTA
argument_list|(
name|regindex
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vlan_on
condition|)
name|bits
operator||=
operator|(
literal|1
operator|<<
name|bitindex
operator|)
expr_stmt|;
else|else
name|bits
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|bitindex
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VFTA
argument_list|(
name|regindex
argument_list|)
argument_list|,
name|bits
argument_list|)
expr_stmt|;
comment|/* Part 2 	 * If VT Mode is set 	 *   Either vlan_on 	 *     make sure the vlan is in VLVF 	 *     set the vind bit in the matching VLVFB 	 *   Or !vlan_on 	 *     clear the pool bit and possibly the vind 	 */
name|vt
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VT_CTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|vt
operator|&
name|IXGBE_VT_CTL_VT_ENABLE
condition|)
block|{
if|if
condition|(
name|vlan
operator|==
literal|0
condition|)
block|{
name|regindex
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|regindex
operator|=
name|ixgbe_find_vlvf_slot
argument_list|(
name|hw
argument_list|,
name|vlan
argument_list|)
expr_stmt|;
if|if
condition|(
name|regindex
operator|<
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|vlan_on
condition|)
block|{
comment|/* set the pool bit */
if|if
condition|(
name|vind
operator|<
literal|32
condition|)
block|{
name|bits
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VLVFB
argument_list|(
name|regindex
operator|*
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|bits
operator||=
operator|(
literal|1
operator|<<
name|vind
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VLVFB
argument_list|(
name|regindex
operator|*
literal|2
argument_list|)
argument_list|,
name|bits
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bits
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VLVFB
argument_list|(
operator|(
name|regindex
operator|*
literal|2
operator|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|bits
operator||=
operator|(
literal|1
operator|<<
name|vind
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VLVFB
argument_list|(
operator|(
name|regindex
operator|*
literal|2
operator|)
operator|+
literal|1
argument_list|)
argument_list|,
name|bits
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* clear the pool bit */
if|if
condition|(
name|vind
operator|<
literal|32
condition|)
block|{
name|bits
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VLVFB
argument_list|(
name|regindex
operator|*
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|bits
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|vind
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VLVFB
argument_list|(
name|regindex
operator|*
literal|2
argument_list|)
argument_list|,
name|bits
argument_list|)
expr_stmt|;
name|bits
operator||=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VLVFB
argument_list|(
operator|(
name|regindex
operator|*
literal|2
operator|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bits
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VLVFB
argument_list|(
operator|(
name|regindex
operator|*
literal|2
operator|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|bits
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|vind
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VLVFB
argument_list|(
operator|(
name|regindex
operator|*
literal|2
operator|)
operator|+
literal|1
argument_list|)
argument_list|,
name|bits
argument_list|)
expr_stmt|;
name|bits
operator||=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VLVFB
argument_list|(
name|regindex
operator|*
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bits
condition|)
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VLVF
argument_list|(
name|regindex
argument_list|)
argument_list|,
operator|(
name|IXGBE_VLVF_VIEN
operator||
name|vlan
operator|)
argument_list|)
expr_stmt|;
else|else
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VLVF
argument_list|(
name|regindex
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|out
label|:
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_clear_vfta_generic - Clear VLAN filter table  *  @hw: pointer to hardware structure  *  *  Clears the VLAN filer table, and the VMDq index associated with the filter  **/
end_comment

begin_function
name|s32
name|ixgbe_clear_vfta_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|offset
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_clear_vfta_generic"
argument_list|)
expr_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|hw
operator|->
name|mac
operator|.
name|vft_size
condition|;
name|offset
operator|++
control|)
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VFTA
argument_list|(
name|offset
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|IXGBE_VLVF_ENTRIES
condition|;
name|offset
operator|++
control|)
block|{
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VLVF
argument_list|(
name|offset
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VLVFB
argument_list|(
name|offset
operator|*
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VLVFB
argument_list|(
operator|(
name|offset
operator|*
literal|2
operator|)
operator|+
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_check_mac_link_generic - Determine link and speed status  *  @hw: pointer to hardware structure  *  @speed: pointer to link speed  *  @link_up: TRUE when link is up  *  @link_up_wait_to_complete: bool used to wait for link up or not  *  *  Reads the links register to determine if link is up and the current speed  **/
end_comment

begin_function
name|s32
name|ixgbe_check_mac_link_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
modifier|*
name|speed
parameter_list|,
name|bool
modifier|*
name|link_up
parameter_list|,
name|bool
name|link_up_wait_to_complete
parameter_list|)
block|{
name|u32
name|links_reg
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_check_mac_link_generic"
argument_list|)
expr_stmt|;
name|links_reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LINKS
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_up_wait_to_complete
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_LINK_UP_TIME
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|links_reg
operator|&
name|IXGBE_LINKS_UP
condition|)
block|{
operator|*
name|link_up
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
else|else
block|{
operator|*
name|link_up
operator|=
name|FALSE
expr_stmt|;
block|}
name|msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|links_reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LINKS
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|links_reg
operator|&
name|IXGBE_LINKS_UP
condition|)
operator|*
name|link_up
operator|=
name|TRUE
expr_stmt|;
else|else
operator|*
name|link_up
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|links_reg
operator|&
name|IXGBE_LINKS_SPEED_82599
operator|)
operator|==
name|IXGBE_LINKS_SPEED_10G_82599
condition|)
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_10GB_FULL
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|links_reg
operator|&
name|IXGBE_LINKS_SPEED_82599
operator|)
operator|==
name|IXGBE_LINKS_SPEED_1G_82599
condition|)
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
else|else
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_100_FULL
expr_stmt|;
comment|/* if link is down, zero out the current_mode */
if|if
condition|(
operator|*
name|link_up
operator|==
name|FALSE
condition|)
block|{
name|hw
operator|->
name|fc
operator|.
name|current_mode
operator|=
name|ixgbe_fc_none
expr_stmt|;
name|hw
operator|->
name|fc
operator|.
name|fc_was_autonegged
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_wwn_prefix_generic - Get alternative WWNN/WWPN prefix from  *  the EEPROM  *  @hw: pointer to hardware structure  *  @wwnn_prefix: the alternative WWNN prefix  *  @wwpn_prefix: the alternative WWPN prefix  *  *  This function will read the EEPROM from the alternative SAN MAC address  *  block to check the support for the alternative WWNN/WWPN prefix support.  **/
end_comment

begin_function
name|s32
name|ixgbe_get_wwn_prefix_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|wwnn_prefix
parameter_list|,
name|u16
modifier|*
name|wwpn_prefix
parameter_list|)
block|{
name|u16
name|offset
decl_stmt|,
name|caps
decl_stmt|;
name|u16
name|alt_san_mac_blk_offset
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_wwn_prefix_generic"
argument_list|)
expr_stmt|;
comment|/* clear output first */
operator|*
name|wwnn_prefix
operator|=
literal|0xFFFF
expr_stmt|;
operator|*
name|wwpn_prefix
operator|=
literal|0xFFFF
expr_stmt|;
comment|/* check if alternative SAN MAC is supported */
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|IXGBE_ALT_SAN_MAC_ADDR_BLK_PTR
argument_list|,
operator|&
name|alt_san_mac_blk_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|alt_san_mac_blk_offset
operator|==
literal|0
operator|)
operator|||
operator|(
name|alt_san_mac_blk_offset
operator|==
literal|0xFFFF
operator|)
condition|)
goto|goto
name|wwn_prefix_out
goto|;
comment|/* check capability in alternative san mac address block */
name|offset
operator|=
name|alt_san_mac_blk_offset
operator|+
name|IXGBE_ALT_SAN_MAC_ADDR_CAPS_OFFSET
expr_stmt|;
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
operator|&
name|caps
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|caps
operator|&
name|IXGBE_ALT_SAN_MAC_ADDR_CAPS_ALTWWN
operator|)
condition|)
goto|goto
name|wwn_prefix_out
goto|;
comment|/* get the corresponding prefix for WWNN/WWPN */
name|offset
operator|=
name|alt_san_mac_blk_offset
operator|+
name|IXGBE_ALT_SAN_MAC_ADDR_WWNN_OFFSET
expr_stmt|;
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|wwnn_prefix
argument_list|)
expr_stmt|;
name|offset
operator|=
name|alt_san_mac_blk_offset
operator|+
name|IXGBE_ALT_SAN_MAC_ADDR_WWPN_OFFSET
expr_stmt|;
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|wwpn_prefix
argument_list|)
expr_stmt|;
name|wwn_prefix_out
label|:
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

end_unit

