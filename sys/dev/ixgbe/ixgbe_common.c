begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*******************************************************************************    Copyright (c) 2001-2007, Intel Corporation    All rights reserved.      Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are met:       1. Redistributions of source code must retain the above copyright notice,        this list of conditions and the following disclaimer.       2. Redistributions in binary form must reproduce the above copyright        notice, this list of conditions and the following disclaimer in the        documentation and/or other materials provided with the distribution.       3. Neither the name of the Intel Corporation nor the names of its        contributors may be used to endorse or promote products derived from        this software without specific prior written permission.      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  *******************************************************************************/
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_include
include|#
directive|include
file|"ixgbe_common.h"
end_include

begin_include
include|#
directive|include
file|"ixgbe_api.h"
end_include

begin_function_decl
specifier|static
name|s32
name|ixgbe_poll_eeprom_eerd_done
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|ixgbe_acquire_eeprom
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|ixgbe_get_eeprom_semaphore
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_release_eeprom_semaphore
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|ixgbe_ready_eeprom
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_standby_eeprom
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_shift_out_eeprom_bits
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|data
parameter_list|,
name|u16
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u16
name|ixgbe_shift_in_eeprom_bits
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_raise_eeprom_clk
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|eec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_lower_eeprom_clk
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|eec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_release_eeprom
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u16
name|ixgbe_calc_eeprom_checksum
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_enable_rar
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_disable_rar
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|ixgbe_mta_vector
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|mc_addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ixgbe_add_mc_addr
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|mc_addr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  *  ixgbe_assign_func_pointers_generic - Set generic func ptrs  *  @hw: pointer to hardware structure  *  *  Assigns generic function pointers.  Adapter-specific functions can  *  override the assignment of generic function pointers by assigning  *  their own adapter-specific function pointers.  **/
end_comment

begin_function
name|s32
name|ixgbe_assign_func_pointers_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|ixgbe_functions
modifier|*
name|f
init|=
operator|&
name|hw
operator|->
name|func
decl_stmt|;
name|f
operator|->
name|ixgbe_func_init_hw
operator|=
operator|&
name|ixgbe_init_hw_generic
expr_stmt|;
name|f
operator|->
name|ixgbe_func_start_hw
operator|=
operator|&
name|ixgbe_start_hw_generic
expr_stmt|;
name|f
operator|->
name|ixgbe_func_clear_hw_cntrs
operator|=
operator|&
name|ixgbe_clear_hw_cntrs_generic
expr_stmt|;
name|f
operator|->
name|ixgbe_func_get_mac_addr
operator|=
operator|&
name|ixgbe_get_mac_addr_generic
expr_stmt|;
name|f
operator|->
name|ixgbe_func_stop_adapter
operator|=
operator|&
name|ixgbe_stop_adapter_generic
expr_stmt|;
name|f
operator|->
name|ixgbe_func_get_bus_info
operator|=
operator|&
name|ixgbe_get_bus_info_generic
expr_stmt|;
comment|/* LED */
name|f
operator|->
name|ixgbe_func_led_on
operator|=
operator|&
name|ixgbe_led_on_generic
expr_stmt|;
name|f
operator|->
name|ixgbe_func_led_off
operator|=
operator|&
name|ixgbe_led_off_generic
expr_stmt|;
comment|/* EEPROM */
name|f
operator|->
name|ixgbe_func_init_eeprom_params
operator|=
operator|&
name|ixgbe_init_eeprom_params_generic
expr_stmt|;
name|f
operator|->
name|ixgbe_func_read_eeprom
operator|=
operator|&
name|ixgbe_read_eeprom_bit_bang_generic
expr_stmt|;
name|f
operator|->
name|ixgbe_func_write_eeprom
operator|=
operator|&
name|ixgbe_write_eeprom_generic
expr_stmt|;
name|f
operator|->
name|ixgbe_func_validate_eeprom_checksum
operator|=
operator|&
name|ixgbe_validate_eeprom_checksum_generic
expr_stmt|;
name|f
operator|->
name|ixgbe_func_update_eeprom_checksum
operator|=
operator|&
name|ixgbe_update_eeprom_checksum_generic
expr_stmt|;
comment|/* RAR, Multicast, VLAN */
name|f
operator|->
name|ixgbe_func_set_rar
operator|=
operator|&
name|ixgbe_set_rar_generic
expr_stmt|;
name|f
operator|->
name|ixgbe_func_init_rx_addrs
operator|=
operator|&
name|ixgbe_init_rx_addrs_generic
expr_stmt|;
name|f
operator|->
name|ixgbe_func_update_mc_addr_list
operator|=
operator|&
name|ixgbe_update_mc_addr_list_generic
expr_stmt|;
name|f
operator|->
name|ixgbe_func_enable_mc
operator|=
operator|&
name|ixgbe_enable_mc_generic
expr_stmt|;
name|f
operator|->
name|ixgbe_func_disable_mc
operator|=
operator|&
name|ixgbe_disable_mc_generic
expr_stmt|;
name|f
operator|->
name|ixgbe_func_clear_vfta
operator|=
operator|&
name|ixgbe_clear_vfta_generic
expr_stmt|;
name|f
operator|->
name|ixgbe_func_set_vfta
operator|=
operator|&
name|ixgbe_set_vfta_generic
expr_stmt|;
name|f
operator|->
name|ixgbe_func_setup_fc
operator|=
operator|&
name|ixgbe_setup_fc_generic
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_start_hw_generic - Prepare hardware for TX/RX  *  @hw: pointer to hardware structure  *  *  Starts the hardware by filling the bus info structure and media type, clears  *  all on chip counters, initializes receive address registers, multicast  *  table, VLAN filter table, calls routine to set up link and flow control  *  settings, and leaves transmit and receive units disabled and uninitialized  **/
end_comment

begin_function
name|s32
name|ixgbe_start_hw_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|ctrl_ext
decl_stmt|;
comment|/* Set the media type */
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|=
name|ixgbe_get_media_type
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Set bus info */
name|ixgbe_get_bus_info
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Identify the PHY */
name|ixgbe_identify_phy
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* 	 * Store MAC address from RAR0, clear receive address registers, and 	 * clear the multicast table 	 */
name|ixgbe_init_rx_addrs
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Clear the VLAN filter table */
name|ixgbe_clear_vfta
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Set up link */
name|ixgbe_setup_link
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Clear statistics registers */
name|ixgbe_clear_hw_cntrs
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Set No Snoop Disable */
name|ctrl_ext
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CTRL_EXT
argument_list|)
expr_stmt|;
name|ctrl_ext
operator||=
name|IXGBE_CTRL_EXT_NS_DIS
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CTRL_EXT
argument_list|,
name|ctrl_ext
argument_list|)
expr_stmt|;
comment|/* Clear adapter stopped flag */
name|hw
operator|->
name|adapter_stopped
operator|=
name|FALSE
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_init_hw_generic - Generic hardware initialization  *  @hw: pointer to hardware structure  *  *  Initialize the hardware by reseting the hardware, filling the bus info  *  structure and media type, clears all on chip counters, initializes receive  *  address registers, multicast table, VLAN filter table, calls routine to set  *  up link and flow control settings, and leaves transmit and receive units  *  disabled and uninitialized  **/
end_comment

begin_function
name|s32
name|ixgbe_init_hw_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
comment|/* Reset the hardware */
name|ixgbe_reset_hw
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Start the HW */
name|ixgbe_start_hw
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_clear_hw_cntrs_generic - Generic clear hardware counters  *  @hw: pointer to hardware structure  *  *  Clears all hardware statistics counters by reading them from the hardware  *  Statistics counters are clear on read.  **/
end_comment

begin_function
name|s32
name|ixgbe_clear_hw_cntrs_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u16
name|i
init|=
literal|0
decl_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CRCERRS
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ILLERRC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ERRBC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MSPDC
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MPC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MLFC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MRFC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RLEC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LXONTXC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LXONRXC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LXOFFTXC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LXOFFRXC
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PXONTXC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PXONRXC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PXOFFTXC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PXOFFRXC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PRC64
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PRC127
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PRC255
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PRC511
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PRC1023
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PRC1522
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GPRC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_BPRC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MPRC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GPTC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GORCL
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GORCH
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GOTCL
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GOTCH
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RNBC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RUC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RFC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ROC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RJC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MNGPRC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MNGPDC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MNGPTC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_TORL
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_TORH
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_TPR
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_TPT
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PTC64
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PTC127
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PTC255
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PTC511
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PTC1023
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PTC1522
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MPTC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_BPTC
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_QPRC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_QBRC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_QPTC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_QBTC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_mac_addr_generic - Generic get MAC address  *  @hw: pointer to hardware structure  *  @mac_addr: Adapter MAC address  *  *  Reads the adapter's MAC address from first Receive Address Register (RAR0)  *  A reset of the adapter must be performed prior to calling this function  *  in order for the MAC address to have been loaded from the EEPROM into RAR0  **/
end_comment

begin_function
name|s32
name|ixgbe_get_mac_addr_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|mac_addr
parameter_list|)
block|{
name|u32
name|rar_high
decl_stmt|;
name|u32
name|rar_low
decl_stmt|;
name|u16
name|i
decl_stmt|;
name|rar_high
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RAH
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|rar_low
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RAL
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|mac_addr
index|[
name|i
index|]
operator|=
call|(
name|u8
call|)
argument_list|(
name|rar_low
operator|>>
operator|(
name|i
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
name|mac_addr
index|[
name|i
operator|+
literal|4
index|]
operator|=
call|(
name|u8
call|)
argument_list|(
name|rar_high
operator|>>
operator|(
name|i
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_bus_info_generic - Generic set PCI bus info  *  @hw: pointer to hardware structure  *  *  Sets the PCI bus info (speed, width, type) within the ixgbe_hw structure  **/
end_comment

begin_function
name|s32
name|ixgbe_get_bus_info_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u16
name|link_status
decl_stmt|;
name|hw
operator|->
name|bus
operator|.
name|type
operator|=
name|ixgbe_bus_type_pci_express
expr_stmt|;
comment|/* Get the negotiated link width and speed from PCI config space */
name|link_status
operator|=
name|IXGBE_READ_PCIE_WORD
argument_list|(
name|hw
argument_list|,
name|IXGBE_PCI_LINK_STATUS
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|link_status
operator|&
name|IXGBE_PCI_LINK_WIDTH
condition|)
block|{
case|case
name|IXGBE_PCI_LINK_WIDTH_1
case|:
name|hw
operator|->
name|bus
operator|.
name|width
operator|=
name|ixgbe_bus_width_pcie_x1
expr_stmt|;
break|break;
case|case
name|IXGBE_PCI_LINK_WIDTH_2
case|:
name|hw
operator|->
name|bus
operator|.
name|width
operator|=
name|ixgbe_bus_width_pcie_x2
expr_stmt|;
break|break;
case|case
name|IXGBE_PCI_LINK_WIDTH_4
case|:
name|hw
operator|->
name|bus
operator|.
name|width
operator|=
name|ixgbe_bus_width_pcie_x4
expr_stmt|;
break|break;
case|case
name|IXGBE_PCI_LINK_WIDTH_8
case|:
name|hw
operator|->
name|bus
operator|.
name|width
operator|=
name|ixgbe_bus_width_pcie_x8
expr_stmt|;
break|break;
default|default:
name|hw
operator|->
name|bus
operator|.
name|width
operator|=
name|ixgbe_bus_width_unknown
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|link_status
operator|&
name|IXGBE_PCI_LINK_SPEED
condition|)
block|{
case|case
name|IXGBE_PCI_LINK_SPEED_2500
case|:
name|hw
operator|->
name|bus
operator|.
name|speed
operator|=
name|ixgbe_bus_speed_2500
expr_stmt|;
break|break;
case|case
name|IXGBE_PCI_LINK_SPEED_5000
case|:
name|hw
operator|->
name|bus
operator|.
name|speed
operator|=
name|ixgbe_bus_speed_5000
expr_stmt|;
break|break;
default|default:
name|hw
operator|->
name|bus
operator|.
name|speed
operator|=
name|ixgbe_bus_speed_unknown
expr_stmt|;
break|break;
block|}
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_stop_adapter_generic - Generic stop TX/RX units  *  @hw: pointer to hardware structure  *  *  Sets the adapter_stopped flag within ixgbe_hw struct. Clears interrupts,  *  disables transmit and receive units. The adapter_stopped flag is used by  *  the shared code and drivers to determine if the adapter is in a stopped  *  state and should not touch the hardware.  **/
end_comment

begin_function
name|s32
name|ixgbe_stop_adapter_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|number_of_queues
decl_stmt|;
name|u32
name|reg_val
decl_stmt|;
name|u16
name|i
decl_stmt|;
comment|/* 	 * Set the adapter_stopped flag so other driver functions stop touching 	 * the hardware 	 */
name|hw
operator|->
name|adapter_stopped
operator|=
name|TRUE
expr_stmt|;
comment|/* Disable the receive unit */
name|reg_val
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXCTRL
argument_list|)
expr_stmt|;
name|reg_val
operator|&=
operator|~
operator|(
name|IXGBE_RXCTRL_RXEN
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXCTRL
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* Clear interrupt mask to stop from interrupts being generated */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EIMC
argument_list|,
name|IXGBE_IRQ_CLEAR_MASK
argument_list|)
expr_stmt|;
comment|/* Clear any pending interrupts */
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EICR
argument_list|)
expr_stmt|;
comment|/* Disable the transmit unit.  Each queue must be disabled. */
name|number_of_queues
operator|=
name|ixgbe_get_num_of_tx_queues
argument_list|(
name|hw
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|number_of_queues
condition|;
name|i
operator|++
control|)
block|{
name|reg_val
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_TXDCTL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_val
operator|&
name|IXGBE_TXDCTL_ENABLE
condition|)
block|{
name|reg_val
operator|&=
operator|~
name|IXGBE_TXDCTL_ENABLE
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_TXDCTL
argument_list|(
name|i
argument_list|)
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_led_on_generic - Turns on the software controllable LEDs.  *  @hw: pointer to hardware structure  *  @index: led number to turn on  **/
end_comment

begin_function
name|s32
name|ixgbe_led_on_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|index
parameter_list|)
block|{
name|u32
name|led_reg
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LEDCTL
argument_list|)
decl_stmt|;
comment|/* To turn on the LED, set mode to ON. */
name|led_reg
operator|&=
operator|~
name|IXGBE_LED_MODE_MASK
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|led_reg
operator||=
name|IXGBE_LED_ON
operator|<<
name|IXGBE_LED_MODE_SHIFT
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LEDCTL
argument_list|,
name|led_reg
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_led_off_generic - Turns off the software controllable LEDs.  *  @hw: pointer to hardware structure  *  @index: led number to turn off  **/
end_comment

begin_function
name|s32
name|ixgbe_led_off_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|index
parameter_list|)
block|{
name|u32
name|led_reg
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LEDCTL
argument_list|)
decl_stmt|;
comment|/* To turn off the LED, set mode to OFF. */
name|led_reg
operator|&=
operator|~
name|IXGBE_LED_MODE_MASK
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|led_reg
operator||=
name|IXGBE_LED_OFF
operator|<<
name|IXGBE_LED_MODE_SHIFT
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LEDCTL
argument_list|,
name|led_reg
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_blink_led_start_generic - Blink LED based on index.  *  @hw: pointer to hardware structure  *  @index: led number to blink  **/
end_comment

begin_function
name|s32
name|ixgbe_blink_led_start_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|index
parameter_list|)
block|{
name|u32
name|led_reg
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LEDCTL
argument_list|)
decl_stmt|;
name|led_reg
operator||=
name|IXGBE_LED_BLINK
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LEDCTL
argument_list|,
name|led_reg
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_blink_led_stop_generic - Stop blinking LED based on index.  *  @hw: pointer to hardware structure  *  @index: led number to stop blinking  **/
end_comment

begin_function
name|s32
name|ixgbe_blink_led_stop_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|index
parameter_list|)
block|{
name|u32
name|led_reg
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LEDCTL
argument_list|)
decl_stmt|;
name|led_reg
operator|&=
operator|~
name|IXGBE_LED_BLINK
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LEDCTL
argument_list|,
name|led_reg
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_init_eeprom_params_generic - Initialize EEPROM params  *  @hw: pointer to hardware structure  *  *  Initializes the EEPROM parameters ixgbe_eeprom_info within the  *  ixgbe_hw struct in order to set up EEPROM access.  **/
end_comment

begin_function
name|s32
name|ixgbe_init_eeprom_params_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|ixgbe_eeprom_info
modifier|*
name|eeprom
init|=
operator|&
name|hw
operator|->
name|eeprom
decl_stmt|;
name|u32
name|eec
decl_stmt|;
name|u16
name|eeprom_size
decl_stmt|;
if|if
condition|(
name|eeprom
operator|->
name|type
operator|==
name|ixgbe_eeprom_uninitialized
condition|)
block|{
name|eeprom
operator|->
name|type
operator|=
name|ixgbe_eeprom_none
expr_stmt|;
comment|/* 		 * Check for EEPROM present first. 		 * If not present leave as none 		 */
name|eec
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC
argument_list|)
expr_stmt|;
if|if
condition|(
name|eec
operator|&
name|IXGBE_EEC_PRES
condition|)
block|{
name|eeprom
operator|->
name|type
operator|=
name|ixgbe_eeprom_spi
expr_stmt|;
comment|/* 			 * SPI EEPROM is assumed here.  This code would need to 			 * change if a future EEPROM is not SPI. 			 */
name|eeprom_size
operator|=
call|(
name|u16
call|)
argument_list|(
operator|(
name|eec
operator|&
name|IXGBE_EEC_SIZE
operator|)
operator|>>
name|IXGBE_EEC_SIZE_SHIFT
argument_list|)
expr_stmt|;
name|eeprom
operator|->
name|word_size
operator|=
literal|1
operator|<<
operator|(
name|eeprom_size
operator|+
name|IXGBE_EEPROM_WORD_SIZE_SHIFT
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|eec
operator|&
name|IXGBE_EEC_ADDR_SIZE
condition|)
name|eeprom
operator|->
name|address_bits
operator|=
literal|16
expr_stmt|;
else|else
name|eeprom
operator|->
name|address_bits
operator|=
literal|8
expr_stmt|;
name|DEBUGOUT3
argument_list|(
literal|"Eeprom params: type = %d, size = %d, address bits: "
literal|"%d\n"
argument_list|,
name|eeprom
operator|->
name|type
argument_list|,
name|eeprom
operator|->
name|word_size
argument_list|,
name|eeprom
operator|->
name|address_bits
argument_list|)
expr_stmt|;
block|}
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_write_eeprom_generic - Writes 16 bit value to EEPROM  *  @hw: pointer to hardware structure  *  @offset: offset within the EEPROM to be written to  *  @data: 16 bit word to be written to the EEPROM  *  *  If ixgbe_eeprom_update_checksum is not called after this function, the  *  EEPROM will most likely contain an invalid checksum.  **/
end_comment

begin_function
name|s32
name|ixgbe_write_eeprom_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
name|data
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|u8
name|write_opcode
init|=
name|IXGBE_EEPROM_WRITE_OPCODE_SPI
decl_stmt|;
comment|/* Prepare the EEPROM for writing  */
name|status
operator|=
name|ixgbe_acquire_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
condition|)
block|{
if|if
condition|(
name|ixgbe_ready_eeprom
argument_list|(
name|hw
argument_list|)
operator|!=
name|IXGBE_SUCCESS
condition|)
block|{
name|ixgbe_release_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|status
operator|=
name|IXGBE_ERR_EEPROM
expr_stmt|;
block|}
block|}
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
condition|)
block|{
name|ixgbe_standby_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/*  Send the WRITE ENABLE command (8 bit opcode )  */
name|ixgbe_shift_out_eeprom_bits
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEPROM_WREN_OPCODE_SPI
argument_list|,
name|IXGBE_EEPROM_OPCODE_BITS
argument_list|)
expr_stmt|;
name|ixgbe_standby_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* 		 * Some SPI eeproms use the 8th address bit embedded in the 		 * opcode 		 */
if|if
condition|(
operator|(
name|hw
operator|->
name|eeprom
operator|.
name|address_bits
operator|==
literal|8
operator|)
operator|&&
operator|(
name|offset
operator|>=
literal|128
operator|)
condition|)
name|write_opcode
operator||=
name|IXGBE_EEPROM_A8_OPCODE_SPI
expr_stmt|;
comment|/* Send the Write command (8-bit opcode + addr) */
name|ixgbe_shift_out_eeprom_bits
argument_list|(
name|hw
argument_list|,
name|write_opcode
argument_list|,
name|IXGBE_EEPROM_OPCODE_BITS
argument_list|)
expr_stmt|;
name|ixgbe_shift_out_eeprom_bits
argument_list|(
name|hw
argument_list|,
call|(
name|u16
call|)
argument_list|(
name|offset
operator|*
literal|2
argument_list|)
argument_list|,
name|hw
operator|->
name|eeprom
operator|.
name|address_bits
argument_list|)
expr_stmt|;
comment|/* Send the data */
name|data
operator|=
operator|(
name|data
operator|>>
literal|8
operator|)
operator||
operator|(
name|data
operator|<<
literal|8
operator|)
expr_stmt|;
name|ixgbe_shift_out_eeprom_bits
argument_list|(
name|hw
argument_list|,
name|data
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|ixgbe_standby_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* Done with writing - release the EEPROM */
name|ixgbe_release_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_read_eeprom_bit_bang_generic - Read EEPROM word using bit-bang  *  @hw: pointer to hardware structure  *  @offset: offset within the EEPROM to be read  *  @data: read 16 bit value from EEPROM  *  *  Reads 16 bit value from EEPROM through bit-bang method  **/
end_comment

begin_function
name|s32
name|ixgbe_read_eeprom_bit_bang_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|u16
name|word_in
decl_stmt|;
name|u8
name|read_opcode
init|=
name|IXGBE_EEPROM_READ_OPCODE_SPI
decl_stmt|;
comment|/* Prepare the EEPROM for reading  */
name|status
operator|=
name|ixgbe_acquire_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
condition|)
block|{
if|if
condition|(
name|ixgbe_ready_eeprom
argument_list|(
name|hw
argument_list|)
operator|!=
name|IXGBE_SUCCESS
condition|)
block|{
name|ixgbe_release_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|status
operator|=
name|IXGBE_ERR_EEPROM
expr_stmt|;
block|}
block|}
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
condition|)
block|{
name|ixgbe_standby_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* 		 * Some SPI eeproms use the 8th address bit embedded in the 		 * opcode 		 */
if|if
condition|(
operator|(
name|hw
operator|->
name|eeprom
operator|.
name|address_bits
operator|==
literal|8
operator|)
operator|&&
operator|(
name|offset
operator|>=
literal|128
operator|)
condition|)
name|read_opcode
operator||=
name|IXGBE_EEPROM_A8_OPCODE_SPI
expr_stmt|;
comment|/* Send the READ command (opcode + addr) */
name|ixgbe_shift_out_eeprom_bits
argument_list|(
name|hw
argument_list|,
name|read_opcode
argument_list|,
name|IXGBE_EEPROM_OPCODE_BITS
argument_list|)
expr_stmt|;
name|ixgbe_shift_out_eeprom_bits
argument_list|(
name|hw
argument_list|,
call|(
name|u16
call|)
argument_list|(
name|offset
operator|*
literal|2
argument_list|)
argument_list|,
name|hw
operator|->
name|eeprom
operator|.
name|address_bits
argument_list|)
expr_stmt|;
comment|/* Read the data. */
name|word_in
operator|=
name|ixgbe_shift_in_eeprom_bits
argument_list|(
name|hw
argument_list|,
literal|16
argument_list|)
expr_stmt|;
operator|*
name|data
operator|=
operator|(
name|word_in
operator|>>
literal|8
operator|)
operator||
operator|(
name|word_in
operator|<<
literal|8
operator|)
expr_stmt|;
comment|/* End this read operation */
name|ixgbe_release_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_read_eeprom_generic - Read EEPROM word using EERD  *  @hw: pointer to hardware structure  *  @offset: offset of  word in the EEPROM to read  *  @data: word read from the EEPROM  *  *  Reads a 16 bit word from the EEPROM using the EERD register.  **/
end_comment

begin_function
name|s32
name|ixgbe_read_eeprom_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|u32
name|eerd
decl_stmt|;
name|s32
name|status
decl_stmt|;
name|eerd
operator|=
operator|(
name|offset
operator|<<
name|IXGBE_EEPROM_READ_ADDR_SHIFT
operator|)
operator|+
name|IXGBE_EEPROM_READ_REG_START
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EERD
argument_list|,
name|eerd
argument_list|)
expr_stmt|;
name|status
operator|=
name|ixgbe_poll_eeprom_eerd_done
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
condition|)
operator|*
name|data
operator|=
operator|(
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EERD
argument_list|)
operator|>>
name|IXGBE_EEPROM_READ_REG_DATA
operator|)
expr_stmt|;
else|else
name|DEBUGOUT
argument_list|(
literal|"Eeprom read timed out\n"
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_poll_eeprom_eerd_done - Poll EERD status  *  @hw: pointer to hardware structure  *  *  Polls the status bit (bit 1) of the EERD to determine when the read is done.  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_poll_eeprom_eerd_done
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|i
decl_stmt|;
name|u32
name|reg
decl_stmt|;
name|s32
name|status
init|=
name|IXGBE_ERR_EEPROM
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_EERD_ATTEMPTS
condition|;
name|i
operator|++
control|)
block|{
name|reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EERD
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|IXGBE_EEPROM_READ_REG_DONE
condition|)
block|{
name|status
operator|=
name|IXGBE_SUCCESS
expr_stmt|;
break|break;
block|}
name|usec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_acquire_eeprom - Acquire EEPROM using bit-bang  *  @hw: pointer to hardware structure  *  *  Prepares EEPROM for access using bit-bang method. This function should  *  be called before issuing a command to the EEPROM.  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_acquire_eeprom
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u32
name|eec
decl_stmt|;
name|u32
name|i
decl_stmt|;
if|if
condition|(
name|ixgbe_acquire_swfw_sync
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR_EEP_SM
argument_list|)
operator|!=
name|IXGBE_SUCCESS
condition|)
name|status
operator|=
name|IXGBE_ERR_SWFW_SYNC
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
condition|)
block|{
name|eec
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC
argument_list|)
expr_stmt|;
comment|/* Request EEPROM Access */
name|eec
operator||=
name|IXGBE_EEC_REQ
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC
argument_list|,
name|eec
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_EEPROM_GRANT_ATTEMPTS
condition|;
name|i
operator|++
control|)
block|{
name|eec
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC
argument_list|)
expr_stmt|;
if|if
condition|(
name|eec
operator|&
name|IXGBE_EEC_GNT
condition|)
break|break;
name|usec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
comment|/* Release if grant not aquired */
if|if
condition|(
operator|!
operator|(
name|eec
operator|&
name|IXGBE_EEC_GNT
operator|)
condition|)
block|{
name|eec
operator|&=
operator|~
name|IXGBE_EEC_REQ
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC
argument_list|,
name|eec
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Could not acquire EEPROM grant\n"
argument_list|)
expr_stmt|;
name|ixgbe_release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR_EEP_SM
argument_list|)
expr_stmt|;
name|status
operator|=
name|IXGBE_ERR_EEPROM
expr_stmt|;
block|}
block|}
comment|/* Setup EEPROM for Read/Write */
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
condition|)
block|{
comment|/* Clear CS and SK */
name|eec
operator|&=
operator|~
operator|(
name|IXGBE_EEC_CS
operator||
name|IXGBE_EEC_SK
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC
argument_list|,
name|eec
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_eeprom_semaphore - Get hardware semaphore  *  @hw: pointer to hardware structure  *  *  Sets the hardware semaphores so EEPROM access can occur for bit-bang method  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_get_eeprom_semaphore
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_ERR_EEPROM
decl_stmt|;
name|u32
name|timeout
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|u32
name|swsm
decl_stmt|;
comment|/* Set timeout value based on size of EEPROM */
name|timeout
operator|=
name|hw
operator|->
name|eeprom
operator|.
name|word_size
operator|+
literal|1
expr_stmt|;
comment|/* Get SMBI software semaphore between device drivers first */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|timeout
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * If the SMBI bit is 0 when we read it, then the bit will be 		 * set and we have the semaphore 		 */
name|swsm
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SWSM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|swsm
operator|&
name|IXGBE_SWSM_SMBI
operator|)
condition|)
block|{
name|status
operator|=
name|IXGBE_SUCCESS
expr_stmt|;
break|break;
block|}
name|msec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Now get the semaphore between SW/FW through the SWESMBI bit */
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|timeout
condition|;
name|i
operator|++
control|)
block|{
name|swsm
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SWSM
argument_list|)
expr_stmt|;
comment|/* Set the SW EEPROM semaphore bit to request access */
name|swsm
operator||=
name|IXGBE_SWSM_SWESMBI
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SWSM
argument_list|,
name|swsm
argument_list|)
expr_stmt|;
comment|/* 			 * If we set the bit successfully then we got the 			 * semaphore. 			 */
name|swsm
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SWSM
argument_list|)
expr_stmt|;
if|if
condition|(
name|swsm
operator|&
name|IXGBE_SWSM_SWESMBI
condition|)
break|break;
name|usec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Release semaphores and return error if SW EEPROM semaphore 		 * was not granted because we don't have access to the EEPROM 		 */
if|if
condition|(
name|i
operator|>=
name|timeout
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Driver can't access the Eeprom - Semaphore "
literal|"not granted.\n"
argument_list|)
expr_stmt|;
name|ixgbe_release_eeprom_semaphore
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|status
operator|=
name|IXGBE_ERR_EEPROM
expr_stmt|;
block|}
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_release_eeprom_semaphore - Release hardware semaphore  *  @hw: pointer to hardware structure  *  *  This function clears hardware semaphore bits.  **/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_release_eeprom_semaphore
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|swsm
decl_stmt|;
name|swsm
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SWSM
argument_list|)
expr_stmt|;
comment|/* Release both semaphores by writing 0 to the bits SWESMBI and SMBI */
name|swsm
operator|&=
operator|~
operator|(
name|IXGBE_SWSM_SWESMBI
operator||
name|IXGBE_SWSM_SMBI
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SWSM
argument_list|,
name|swsm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_ready_eeprom - Polls for EEPROM ready  *  @hw: pointer to hardware structure  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_ready_eeprom
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u16
name|i
decl_stmt|;
name|u8
name|spi_stat_reg
decl_stmt|;
comment|/* 	 * Read "Status Register" repeatedly until the LSB is cleared.  The 	 * EEPROM will signal that the command has been completed by clearing 	 * bit 0 of the internal status register.  If it's not cleared within 	 * 5 milliseconds, then error out. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_EEPROM_MAX_RETRY_SPI
condition|;
name|i
operator|+=
literal|5
control|)
block|{
name|ixgbe_shift_out_eeprom_bits
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEPROM_RDSR_OPCODE_SPI
argument_list|,
name|IXGBE_EEPROM_OPCODE_BITS
argument_list|)
expr_stmt|;
name|spi_stat_reg
operator|=
operator|(
name|u8
operator|)
name|ixgbe_shift_in_eeprom_bits
argument_list|(
name|hw
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|spi_stat_reg
operator|&
name|IXGBE_EEPROM_STATUS_RDY_SPI
operator|)
condition|)
break|break;
name|usec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|ixgbe_standby_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/* 	 * On some parts, SPI write time could vary from 0-20mSec on 3.3V 	 * devices (and only 0-5mSec on 5V devices) 	 */
if|if
condition|(
name|i
operator|>=
name|IXGBE_EEPROM_MAX_RETRY_SPI
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"SPI EEPROM Status error\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IXGBE_ERR_EEPROM
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_standby_eeprom - Returns EEPROM to a "standby" state  *  @hw: pointer to hardware structure  **/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_standby_eeprom
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|eec
decl_stmt|;
name|eec
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC
argument_list|)
expr_stmt|;
comment|/* Toggle CS to flush commands */
name|eec
operator||=
name|IXGBE_EEC_CS
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC
argument_list|,
name|eec
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|eec
operator|&=
operator|~
name|IXGBE_EEC_CS
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC
argument_list|,
name|eec
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_shift_out_eeprom_bits - Shift data bits out to the EEPROM.  *  @hw: pointer to hardware structure  *  @data: data to send to the EEPROM  *  @count: number of bits to shift out  **/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_shift_out_eeprom_bits
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|data
parameter_list|,
name|u16
name|count
parameter_list|)
block|{
name|u32
name|eec
decl_stmt|;
name|u32
name|mask
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|eec
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC
argument_list|)
expr_stmt|;
comment|/* 	 * Mask is used to shift "count" bits of "data" out to the EEPROM 	 * one bit at a time.  Determine the starting bit based on count 	 */
name|mask
operator|=
literal|0x01
operator|<<
operator|(
name|count
operator|-
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * A "1" is shifted out to the EEPROM by setting bit "DI" to a 		 * "1", and then raising and then lowering the clock (the SK 		 * bit controls the clock input to the EEPROM).  A "0" is 		 * shifted out to the EEPROM by setting "DI" to "0" and then 		 * raising and then lowering the clock. 		 */
if|if
condition|(
name|data
operator|&
name|mask
condition|)
name|eec
operator||=
name|IXGBE_EEC_DI
expr_stmt|;
else|else
name|eec
operator|&=
operator|~
name|IXGBE_EEC_DI
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC
argument_list|,
name|eec
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ixgbe_raise_eeprom_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|eec
argument_list|)
expr_stmt|;
name|ixgbe_lower_eeprom_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|eec
argument_list|)
expr_stmt|;
comment|/* 		 * Shift mask to signify next bit of data to shift in to the 		 * EEPROM 		 */
name|mask
operator|=
name|mask
operator|>>
literal|1
expr_stmt|;
block|}
empty_stmt|;
comment|/* We leave the "DI" bit set to "0" when we leave this routine. */
name|eec
operator|&=
operator|~
name|IXGBE_EEC_DI
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC
argument_list|,
name|eec
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_shift_in_eeprom_bits - Shift data bits in from the EEPROM  *  @hw: pointer to hardware structure  **/
end_comment

begin_function
specifier|static
name|u16
name|ixgbe_shift_in_eeprom_bits
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|count
parameter_list|)
block|{
name|u32
name|eec
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|u16
name|data
init|=
literal|0
decl_stmt|;
comment|/* 	 * In order to read a register from the EEPROM, we need to shift 	 * 'count' bits in from the EEPROM. Bits are "shifted in" by raising 	 * the clock input to the EEPROM (setting the SK bit), and then reading 	 * the value of the "DO" bit.  During this "shifting in" process the 	 * "DI" bit should always be clear. 	 */
name|eec
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC
argument_list|)
expr_stmt|;
name|eec
operator|&=
operator|~
operator|(
name|IXGBE_EEC_DO
operator||
name|IXGBE_EEC_DI
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|data
operator|=
name|data
operator|<<
literal|1
expr_stmt|;
name|ixgbe_raise_eeprom_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|eec
argument_list|)
expr_stmt|;
name|eec
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC
argument_list|)
expr_stmt|;
name|eec
operator|&=
operator|~
operator|(
name|IXGBE_EEC_DI
operator|)
expr_stmt|;
if|if
condition|(
name|eec
operator|&
name|IXGBE_EEC_DO
condition|)
name|data
operator||=
literal|1
expr_stmt|;
name|ixgbe_lower_eeprom_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|eec
argument_list|)
expr_stmt|;
block|}
return|return
name|data
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_raise_eeprom_clk - Raises the EEPROM's clock input.  *  @hw: pointer to hardware structure  *  @eec: EEC register's current value  **/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_raise_eeprom_clk
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|eec
parameter_list|)
block|{
comment|/* 	 * Raise the clock input to the EEPROM 	 * (setting the SK bit), then delay 	 */
operator|*
name|eec
operator|=
operator|*
name|eec
operator||
name|IXGBE_EEC_SK
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC
argument_list|,
operator|*
name|eec
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_lower_eeprom_clk - Lowers the EEPROM's clock input.  *  @hw: pointer to hardware structure  *  @eecd: EECD's current value  **/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_lower_eeprom_clk
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|eec
parameter_list|)
block|{
comment|/* 	 * Lower the clock input to the EEPROM (clearing the SK bit), then 	 * delay 	 */
operator|*
name|eec
operator|=
operator|*
name|eec
operator|&
operator|~
name|IXGBE_EEC_SK
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC
argument_list|,
operator|*
name|eec
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_release_eeprom - Release EEPROM, release semaphores  *  @hw: pointer to hardware structure  **/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_release_eeprom
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|eec
decl_stmt|;
name|eec
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC
argument_list|)
expr_stmt|;
name|eec
operator||=
name|IXGBE_EEC_CS
expr_stmt|;
comment|/* Pull CS high */
name|eec
operator|&=
operator|~
name|IXGBE_EEC_SK
expr_stmt|;
comment|/* Lower SCK */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC
argument_list|,
name|eec
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Stop requesting EEPROM access */
name|eec
operator|&=
operator|~
name|IXGBE_EEC_REQ
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC
argument_list|,
name|eec
argument_list|)
expr_stmt|;
name|ixgbe_release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR_EEP_SM
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_calc_eeprom_checksum - Calculates and returns the checksum  *  @hw: pointer to hardware structure  **/
end_comment

begin_function
specifier|static
name|u16
name|ixgbe_calc_eeprom_checksum
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u16
name|i
decl_stmt|;
name|u16
name|j
decl_stmt|;
name|u16
name|checksum
init|=
literal|0
decl_stmt|;
name|u16
name|length
init|=
literal|0
decl_stmt|;
name|u16
name|pointer
init|=
literal|0
decl_stmt|;
name|u16
name|word
init|=
literal|0
decl_stmt|;
comment|/* Include 0x0-0x3F in the checksum */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_EEPROM_CHECKSUM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ixgbe_read_eeprom
argument_list|(
name|hw
argument_list|,
name|i
argument_list|,
operator|&
name|word
argument_list|)
operator|!=
name|IXGBE_SUCCESS
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM read failed\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|checksum
operator|+=
name|word
expr_stmt|;
block|}
comment|/* Include all data from pointers except for the fw pointer */
for|for
control|(
name|i
operator|=
name|IXGBE_PCIE_ANALOG_PTR
init|;
name|i
operator|<
name|IXGBE_FW_PTR
condition|;
name|i
operator|++
control|)
block|{
name|ixgbe_read_eeprom
argument_list|(
name|hw
argument_list|,
name|i
argument_list|,
operator|&
name|pointer
argument_list|)
expr_stmt|;
comment|/* Make sure the pointer seems valid */
if|if
condition|(
name|pointer
operator|!=
literal|0xFFFF
operator|&&
name|pointer
operator|!=
literal|0
condition|)
block|{
name|ixgbe_read_eeprom
argument_list|(
name|hw
argument_list|,
name|pointer
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|!=
literal|0xFFFF
operator|&&
name|length
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|j
operator|=
name|pointer
operator|+
literal|1
init|;
name|j
operator|<=
name|pointer
operator|+
name|length
condition|;
name|j
operator|++
control|)
block|{
name|ixgbe_read_eeprom
argument_list|(
name|hw
argument_list|,
name|j
argument_list|,
operator|&
name|word
argument_list|)
expr_stmt|;
name|checksum
operator|+=
name|word
expr_stmt|;
block|}
block|}
block|}
block|}
name|checksum
operator|=
operator|(
name|u16
operator|)
name|IXGBE_EEPROM_SUM
operator|-
name|checksum
expr_stmt|;
return|return
name|checksum
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_validate_eeprom_checksum_generic - Validate EEPROM checksum  *  @hw: pointer to hardware structure  *  @checksum_val: calculated checksum  *  *  Performs checksum calculation and validates the EEPROM checksum.  If the  *  caller does not need checksum_val, the value can be NULL.  **/
end_comment

begin_function
name|s32
name|ixgbe_validate_eeprom_checksum_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|checksum_val
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|u16
name|checksum
decl_stmt|;
name|u16
name|read_checksum
init|=
literal|0
decl_stmt|;
comment|/* 	 * Read the first word from the EEPROM. If this times out or fails, do 	 * not continue or we could be in for a very long wait while every 	 * EEPROM read fails 	 */
name|status
operator|=
name|ixgbe_read_eeprom
argument_list|(
name|hw
argument_list|,
literal|0
argument_list|,
operator|&
name|checksum
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
condition|)
block|{
name|checksum
operator|=
name|ixgbe_calc_eeprom_checksum
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|ixgbe_read_eeprom
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEPROM_CHECKSUM
argument_list|,
operator|&
name|read_checksum
argument_list|)
expr_stmt|;
comment|/* 		 * Verify read checksum from EEPROM is the same as 		 * calculated checksum 		 */
if|if
condition|(
name|read_checksum
operator|!=
name|checksum
condition|)
block|{
name|status
operator|=
name|IXGBE_ERR_EEPROM_CHECKSUM
expr_stmt|;
block|}
comment|/* If the user cares, return the calculated checksum */
if|if
condition|(
name|checksum_val
condition|)
block|{
operator|*
name|checksum_val
operator|=
name|checksum
expr_stmt|;
block|}
block|}
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM read failed\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_update_eeprom_checksum_generic - Updates the EEPROM checksm  *  @hw: pointer to hardware structure  **/
end_comment

begin_function
name|s32
name|ixgbe_update_eeprom_checksum_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|u16
name|checksum
decl_stmt|;
comment|/* 	 * Read the first word from the EEPROM. If this times out or fails, do 	 * not continue or we could be in for a very long wait while every 	 * EEPROM read fails 	 */
name|status
operator|=
name|ixgbe_read_eeprom
argument_list|(
name|hw
argument_list|,
literal|0
argument_list|,
operator|&
name|checksum
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
condition|)
block|{
name|checksum
operator|=
name|ixgbe_calc_eeprom_checksum
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|status
operator|=
name|ixgbe_write_eeprom
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEPROM_CHECKSUM
argument_list|,
name|checksum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM read failed\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_validate_mac_addr - Validate MAC address  *  @mac_addr: pointer to MAC address.  *  *  Tests a MAC address to ensure it is a valid Individual Address  **/
end_comment

begin_function
name|s32
name|ixgbe_validate_mac_addr
parameter_list|(
name|u8
modifier|*
name|mac_addr
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
comment|/* Make sure it is not a multicast address */
if|if
condition|(
name|IXGBE_IS_MULTICAST
argument_list|(
name|mac_addr
argument_list|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"MAC address is multicast\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IXGBE_ERR_INVALID_MAC_ADDR
expr_stmt|;
comment|/* Not a broadcast address */
block|}
elseif|else
if|if
condition|(
name|IXGBE_IS_BROADCAST
argument_list|(
name|mac_addr
argument_list|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"MAC address is broadcast\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IXGBE_ERR_INVALID_MAC_ADDR
expr_stmt|;
comment|/* Reject the zero address */
block|}
elseif|else
if|if
condition|(
name|mac_addr
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|mac_addr
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|mac_addr
index|[
literal|2
index|]
operator|==
literal|0
operator|&&
name|mac_addr
index|[
literal|3
index|]
operator|==
literal|0
operator|&&
name|mac_addr
index|[
literal|4
index|]
operator|==
literal|0
operator|&&
name|mac_addr
index|[
literal|5
index|]
operator|==
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"MAC address is all zeros\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IXGBE_ERR_INVALID_MAC_ADDR
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_set_rar_generic - Set RX address register  *  @hw: pointer to hardware structure  *  @addr: Address to put into receive address register  *  @index: Receive address register to write  *  @vind: Vind to set RAR to  *  @enable_addr: set flag that address is active  *  *  Puts an ethernet address into a receive address register.  **/
end_comment

begin_function
name|s32
name|ixgbe_set_rar_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|index
parameter_list|,
name|u8
modifier|*
name|addr
parameter_list|,
name|u32
name|vind
parameter_list|,
name|u32
name|enable_addr
parameter_list|)
block|{
name|u32
name|rar_low
decl_stmt|,
name|rar_high
decl_stmt|;
comment|/* 	 * HW expects these in little endian so we reverse the byte order from 	 * network order (big endian) to little endian 	 */
name|rar_low
operator|=
operator|(
operator|(
name|u32
operator|)
name|addr
index|[
literal|0
index|]
operator||
operator|(
operator|(
name|u32
operator|)
name|addr
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|u32
operator|)
name|addr
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|u32
operator|)
name|addr
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
operator|)
expr_stmt|;
name|rar_high
operator|=
operator|(
operator|(
name|u32
operator|)
name|addr
index|[
literal|4
index|]
operator||
operator|(
operator|(
name|u32
operator|)
name|addr
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|vind
operator|<<
name|IXGBE_RAH_VIND_SHIFT
operator|)
operator|&
name|IXGBE_RAH_VIND_MASK
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|enable_addr
operator|!=
literal|0
condition|)
name|rar_high
operator||=
name|IXGBE_RAH_AV
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RAL
argument_list|(
name|index
argument_list|)
argument_list|,
name|rar_low
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RAH
argument_list|(
name|index
argument_list|)
argument_list|,
name|rar_high
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_enable_rar - Enable RX address register  *  @hw: pointer to hardware structure  *  @index: index into the RAR table  *  *  Enables the select receive address register.  **/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_enable_rar
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|index
parameter_list|)
block|{
name|u32
name|rar_high
decl_stmt|;
name|rar_high
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RAH
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|rar_high
operator||=
name|IXGBE_RAH_AV
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RAH
argument_list|(
name|index
argument_list|)
argument_list|,
name|rar_high
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_disable_rar - Disable RX address register  *  @hw: pointer to hardware structure  *  @index: index into the RAR table  *  *  Disables the select receive address register.  **/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_disable_rar
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|index
parameter_list|)
block|{
name|u32
name|rar_high
decl_stmt|;
name|rar_high
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RAH
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|rar_high
operator|&=
operator|(
operator|~
name|IXGBE_RAH_AV
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RAH
argument_list|(
name|index
argument_list|)
argument_list|,
name|rar_high
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_init_rx_addrs_generic - Initializes receive address filters.  *  @hw: pointer to hardware structure  *  *  Places the MAC address in receive address register 0 and clears the rest  *  of the receive addresss registers. Clears the multicast table. Assumes  *  the receiver is in reset when the routine is called.  **/
end_comment

begin_function
name|s32
name|ixgbe_init_rx_addrs_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|i
decl_stmt|;
name|u32
name|rar_entries
init|=
name|ixgbe_get_num_rx_addrs
argument_list|(
name|hw
argument_list|)
decl_stmt|;
comment|/* 	 * If the current mac address is valid, assume it is a software override 	 * to the permanent address. 	 * Otherwise, use the permanent address from the eeprom. 	 */
if|if
condition|(
name|ixgbe_validate_mac_addr
argument_list|(
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|)
operator|==
name|IXGBE_ERR_INVALID_MAC_ADDR
condition|)
block|{
comment|/* Get the MAC address from the RAR0 for later reference */
name|ixgbe_get_mac_addr
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|)
expr_stmt|;
name|DEBUGOUT3
argument_list|(
literal|" Keeping Current RAR0 Addr =%.2X %.2X %.2X "
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
index|[
literal|0
index|]
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
index|[
literal|1
index|]
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|DEBUGOUT3
argument_list|(
literal|"%.2X %.2X %.2X\n"
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
index|[
literal|3
index|]
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
index|[
literal|4
index|]
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Setup the receive address. */
name|DEBUGOUT
argument_list|(
literal|"Overriding MAC Address in RAR[0]\n"
argument_list|)
expr_stmt|;
name|DEBUGOUT3
argument_list|(
literal|" New MAC Addr =%.2X %.2X %.2X "
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
index|[
literal|0
index|]
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
index|[
literal|1
index|]
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|DEBUGOUT3
argument_list|(
literal|"%.2X %.2X %.2X\n"
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
index|[
literal|3
index|]
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
index|[
literal|4
index|]
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|ixgbe_set_rar
argument_list|(
name|hw
argument_list|,
literal|0
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|,
literal|0
argument_list|,
name|IXGBE_RAH_AV
argument_list|)
expr_stmt|;
block|}
name|hw
operator|->
name|addr_ctrl
operator|.
name|rar_used_count
operator|=
literal|1
expr_stmt|;
comment|/* Zero out the other receive addresses. */
name|DEBUGOUT
argument_list|(
literal|"Clearing RAR[1-15]\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|rar_entries
condition|;
name|i
operator|++
control|)
block|{
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RAL
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RAH
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Clear the MTA */
name|hw
operator|->
name|addr_ctrl
operator|.
name|mc_addr_in_rar_count
operator|=
literal|0
expr_stmt|;
name|hw
operator|->
name|addr_ctrl
operator|.
name|mta_in_use
operator|=
literal|0
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MCSTCTRL
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|mc_filter_type
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|" Clearing MTA\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_MC_TBL_SIZE
condition|;
name|i
operator|++
control|)
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MTA
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_mta_vector - Determines bit-vector in multicast table to set  *  @hw: pointer to hardware structure  *  @mc_addr: the multicast address  *  *  Extracts the 12 bits, from a multicast address, to determine which  *  bit-vector to set in the multicast table. The hardware uses 12 bits, from  *  incoming rx multicast addresses, to determine the bit-vector to check in  *  the MTA. Which of the 4 combination, of 12-bits, the hardware uses is set  *  by the MO field of the MCSTCTRL. The MO field is set during initalization  *  to mc_filter_type.  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_mta_vector
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|mc_addr
parameter_list|)
block|{
name|u32
name|vector
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|mc_filter_type
condition|)
block|{
case|case
literal|0
case|:
comment|/* use bits [47:36] of the address */
name|vector
operator|=
operator|(
operator|(
name|mc_addr
index|[
literal|4
index|]
operator|>>
literal|4
operator|)
operator||
operator|(
operator|(
operator|(
name|u16
operator|)
name|mc_addr
index|[
literal|5
index|]
operator|)
operator|<<
literal|4
operator|)
operator|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* use bits [46:35] of the address */
name|vector
operator|=
operator|(
operator|(
name|mc_addr
index|[
literal|4
index|]
operator|>>
literal|3
operator|)
operator||
operator|(
operator|(
operator|(
name|u16
operator|)
name|mc_addr
index|[
literal|5
index|]
operator|)
operator|<<
literal|5
operator|)
operator|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* use bits [45:34] of the address */
name|vector
operator|=
operator|(
operator|(
name|mc_addr
index|[
literal|4
index|]
operator|>>
literal|2
operator|)
operator||
operator|(
operator|(
operator|(
name|u16
operator|)
name|mc_addr
index|[
literal|5
index|]
operator|)
operator|<<
literal|6
operator|)
operator|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* use bits [43:32] of the address */
name|vector
operator|=
operator|(
operator|(
name|mc_addr
index|[
literal|4
index|]
operator|)
operator||
operator|(
operator|(
operator|(
name|u16
operator|)
name|mc_addr
index|[
literal|5
index|]
operator|)
operator|<<
literal|8
operator|)
operator|)
expr_stmt|;
break|break;
default|default:
comment|/* Invalid mc_filter_type */
name|DEBUGOUT
argument_list|(
literal|"MC filter type param set incorrectly\n"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* vector can only be 12-bits or boundary will be exceeded */
name|vector
operator|&=
literal|0xFFF
expr_stmt|;
return|return
name|vector
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_set_mta - Set bit-vector in multicast table  *  @hw: pointer to hardware structure  *  @hash_value: Multicast address hash value  *  *  Sets the bit-vector in the multicast table.  **/
end_comment

begin_function
name|void
name|ixgbe_set_mta
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|mc_addr
parameter_list|)
block|{
name|u32
name|vector
decl_stmt|;
name|u32
name|vector_bit
decl_stmt|;
name|u32
name|vector_reg
decl_stmt|;
name|u32
name|mta_reg
decl_stmt|;
name|hw
operator|->
name|addr_ctrl
operator|.
name|mta_in_use
operator|++
expr_stmt|;
name|vector
operator|=
name|ixgbe_mta_vector
argument_list|(
name|hw
argument_list|,
name|mc_addr
argument_list|)
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|" bit-vector = 0x%03X\n"
argument_list|,
name|vector
argument_list|)
expr_stmt|;
comment|/* 	 * The MTA is a register array of 128 32-bit registers. It is treated 	 * like an array of 4096 bits.  We want to set bit 	 * BitArray[vector_value]. So we figure out what register the bit is 	 * in, read it, OR in the new bit, then write back the new value.  The 	 * register is determined by the upper 7 bits of the vector value and 	 * the bit within that register are determined by the lower 5 bits of 	 * the value. 	 */
name|vector_reg
operator|=
operator|(
name|vector
operator|>>
literal|5
operator|)
operator|&
literal|0x7F
expr_stmt|;
name|vector_bit
operator|=
name|vector
operator|&
literal|0x1F
expr_stmt|;
name|mta_reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MTA
argument_list|(
name|vector_reg
argument_list|)
argument_list|)
expr_stmt|;
name|mta_reg
operator||=
operator|(
literal|1
operator|<<
name|vector_bit
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MTA
argument_list|(
name|vector_reg
argument_list|)
argument_list|,
name|mta_reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_add_mc_addr - Adds a multicast address.  *  @hw: pointer to hardware structure  *  @mc_addr: new multicast address  *  *  Adds it to unused receive address register or to the multicast table.  **/
end_comment

begin_function
name|void
name|ixgbe_add_mc_addr
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|mc_addr
parameter_list|)
block|{
name|u32
name|rar_entries
init|=
name|ixgbe_get_num_rx_addrs
argument_list|(
name|hw
argument_list|)
decl_stmt|;
name|DEBUGOUT6
argument_list|(
literal|" MC Addr =%.2X %.2X %.2X %.2X %.2X %.2X\n"
argument_list|,
name|mc_addr
index|[
literal|0
index|]
argument_list|,
name|mc_addr
index|[
literal|1
index|]
argument_list|,
name|mc_addr
index|[
literal|2
index|]
argument_list|,
name|mc_addr
index|[
literal|3
index|]
argument_list|,
name|mc_addr
index|[
literal|4
index|]
argument_list|,
name|mc_addr
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Place this multicast address in the RAR if there is room, 	 * else put it in the MTA 	 */
if|if
condition|(
name|hw
operator|->
name|addr_ctrl
operator|.
name|rar_used_count
operator|<
name|rar_entries
condition|)
block|{
name|ixgbe_set_rar
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|addr_ctrl
operator|.
name|rar_used_count
argument_list|,
name|mc_addr
argument_list|,
literal|0
argument_list|,
name|IXGBE_RAH_AV
argument_list|)
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"Added a multicast address to RAR[%d]\n"
argument_list|,
name|hw
operator|->
name|addr_ctrl
operator|.
name|rar_used_count
argument_list|)
expr_stmt|;
name|hw
operator|->
name|addr_ctrl
operator|.
name|rar_used_count
operator|++
expr_stmt|;
name|hw
operator|->
name|addr_ctrl
operator|.
name|mc_addr_in_rar_count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|ixgbe_set_mta
argument_list|(
name|hw
argument_list|,
name|mc_addr
argument_list|)
expr_stmt|;
block|}
name|DEBUGOUT
argument_list|(
literal|"ixgbe_add_mc_addr Complete\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_update_mc_addr_list_generic - Updates MAC list of multicast addresses  *  @hw: pointer to hardware structure  *  @mc_addr_list: the list of new multicast addresses  *  @mc_addr_count: number of addresses  *  @pad: number of bytes between addresses in the list  *  *  The given list replaces any existing list. Clears the MC addrs from receive  *  address registers and the multicast table. Uses unsed receive address  *  registers for the first multicast addresses, and hashes the rest into the  *  multicast table.  **/
end_comment

begin_function
name|s32
name|ixgbe_update_mc_addr_list_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|mc_addr_list
parameter_list|,
name|u32
name|mc_addr_count
parameter_list|,
name|u32
name|pad
parameter_list|)
block|{
name|u32
name|i
decl_stmt|;
name|u32
name|rar_entries
init|=
name|ixgbe_get_num_rx_addrs
argument_list|(
name|hw
argument_list|)
decl_stmt|;
comment|/* 	 * Set the new number of MC addresses that we are being requested to 	 * use. 	 */
name|hw
operator|->
name|addr_ctrl
operator|.
name|num_mc_addrs
operator|=
name|mc_addr_count
expr_stmt|;
name|hw
operator|->
name|addr_ctrl
operator|.
name|rar_used_count
operator|-=
name|hw
operator|->
name|addr_ctrl
operator|.
name|mc_addr_in_rar_count
expr_stmt|;
name|hw
operator|->
name|addr_ctrl
operator|.
name|mc_addr_in_rar_count
operator|=
literal|0
expr_stmt|;
name|hw
operator|->
name|addr_ctrl
operator|.
name|mta_in_use
operator|=
literal|0
expr_stmt|;
comment|/* Zero out the other receive addresses. */
name|DEBUGOUT
argument_list|(
literal|"Clearing RAR[1-15]\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|hw
operator|->
name|addr_ctrl
operator|.
name|rar_used_count
init|;
name|i
operator|<
name|rar_entries
condition|;
name|i
operator|++
control|)
block|{
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RAL
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RAH
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Clear the MTA */
name|DEBUGOUT
argument_list|(
literal|" Clearing MTA\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_MC_TBL_SIZE
condition|;
name|i
operator|++
control|)
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MTA
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Add the new addresses */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mc_addr_count
condition|;
name|i
operator|++
control|)
block|{
name|DEBUGOUT
argument_list|(
literal|" Adding the multicast addresses:\n"
argument_list|)
expr_stmt|;
name|ixgbe_add_mc_addr
argument_list|(
name|hw
argument_list|,
name|mc_addr_list
operator|+
operator|(
name|i
operator|*
operator|(
name|IXGBE_ETH_LENGTH_OF_ADDRESS
operator|+
name|pad
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Enable mta */
if|if
condition|(
name|hw
operator|->
name|addr_ctrl
operator|.
name|mta_in_use
operator|>
literal|0
condition|)
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MCSTCTRL
argument_list|,
name|IXGBE_MCSTCTRL_MFE
operator||
name|hw
operator|->
name|mac
operator|.
name|mc_filter_type
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"ixgbe_update_mc_addr_list_generic Complete\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_enable_mc_generic - Enable multicast address in RAR  *  @hw: pointer to hardware structure  *  *  Enables multicast address in RAR and the use of the multicast hash table.  **/
end_comment

begin_function
name|s32
name|ixgbe_enable_mc_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|i
decl_stmt|;
name|struct
name|ixgbe_addr_filter_info
modifier|*
name|a
init|=
operator|&
name|hw
operator|->
name|addr_ctrl
decl_stmt|;
if|if
condition|(
name|a
operator|->
name|mc_addr_in_rar_count
operator|>
literal|0
condition|)
for|for
control|(
name|i
operator|=
operator|(
name|a
operator|->
name|rar_used_count
operator|-
name|a
operator|->
name|mc_addr_in_rar_count
operator|)
init|;
name|i
operator|<
name|a
operator|->
name|rar_used_count
condition|;
name|i
operator|++
control|)
name|ixgbe_enable_rar
argument_list|(
name|hw
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|mta_in_use
operator|>
literal|0
condition|)
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MCSTCTRL
argument_list|,
name|IXGBE_MCSTCTRL_MFE
operator||
name|hw
operator|->
name|mac
operator|.
name|mc_filter_type
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_disable_mc_generic - Disable mutlicast address in RAR  *  @hw: pointer to hardware structure  *  *  Disables multicast address in RAR and the use of the multicast hash table.  **/
end_comment

begin_function
name|s32
name|ixgbe_disable_mc_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|i
decl_stmt|;
name|struct
name|ixgbe_addr_filter_info
modifier|*
name|a
init|=
operator|&
name|hw
operator|->
name|addr_ctrl
decl_stmt|;
if|if
condition|(
name|a
operator|->
name|mc_addr_in_rar_count
operator|>
literal|0
condition|)
for|for
control|(
name|i
operator|=
operator|(
name|a
operator|->
name|rar_used_count
operator|-
name|a
operator|->
name|mc_addr_in_rar_count
operator|)
init|;
name|i
operator|<
name|a
operator|->
name|rar_used_count
condition|;
name|i
operator|++
control|)
name|ixgbe_disable_rar
argument_list|(
name|hw
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|mta_in_use
operator|>
literal|0
condition|)
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MCSTCTRL
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|mc_filter_type
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_clear_vfta_generic - Clear VLAN filter table  *  @hw: pointer to hardware structure  *  *  Clears the VLAN filer table, and the VMDq index associated with the filter  **/
end_comment

begin_function
name|s32
name|ixgbe_clear_vfta_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|offset
decl_stmt|;
name|u32
name|vlanbyte
decl_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|IXGBE_VLAN_FILTER_TBL_SIZE
condition|;
name|offset
operator|++
control|)
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VFTA
argument_list|(
name|offset
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|vlanbyte
operator|=
literal|0
init|;
name|vlanbyte
operator|<
literal|4
condition|;
name|vlanbyte
operator|++
control|)
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|IXGBE_VLAN_FILTER_TBL_SIZE
condition|;
name|offset
operator|++
control|)
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VFTAVIND
argument_list|(
name|vlanbyte
argument_list|,
name|offset
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_set_vfta_generic - Set VLAN filter table  *  @hw: pointer to hardware structure  *  @vlan: VLAN id to write to VLAN filter  *  @vind: VMDq output index that maps queue to VLAN id in VFTA  *  @vlan_on: boolean flag to turn on/off VLAN in VFTA  *  *  Turn on/off specified VLAN in the VLAN filter table.  **/
end_comment

begin_function
name|s32
name|ixgbe_set_vfta_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|vlan
parameter_list|,
name|u32
name|vind
parameter_list|,
name|bool
name|vlan_on
parameter_list|)
block|{
name|u32
name|VftaIndex
decl_stmt|;
name|u32
name|BitOffset
decl_stmt|;
name|u32
name|VftaReg
decl_stmt|;
name|u32
name|VftaByte
decl_stmt|;
comment|/* Determine 32-bit word position in array */
name|VftaIndex
operator|=
operator|(
name|vlan
operator|>>
literal|5
operator|)
operator|&
literal|0x7F
expr_stmt|;
comment|/* upper seven bits */
comment|/* Determine the location of the (VMD) queue index */
name|VftaByte
operator|=
operator|(
operator|(
name|vlan
operator|>>
literal|3
operator|)
operator|&
literal|0x03
operator|)
expr_stmt|;
comment|/* bits (4:3) indicating byte array */
name|BitOffset
operator|=
operator|(
name|vlan
operator|&
literal|0x7
operator|)
operator|<<
literal|2
expr_stmt|;
comment|/* lower 3 bits indicate nibble */
comment|/* Set the nibble for VMD queue index */
name|VftaReg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VFTAVIND
argument_list|(
name|VftaByte
argument_list|,
name|VftaIndex
argument_list|)
argument_list|)
expr_stmt|;
name|VftaReg
operator|&=
operator|(
operator|~
operator|(
literal|0x0F
operator|<<
name|BitOffset
operator|)
operator|)
expr_stmt|;
name|VftaReg
operator||=
operator|(
name|vind
operator|<<
name|BitOffset
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VFTAVIND
argument_list|(
name|VftaByte
argument_list|,
name|VftaIndex
argument_list|)
argument_list|,
name|VftaReg
argument_list|)
expr_stmt|;
comment|/* Determine the location of the bit for this VLAN id */
name|BitOffset
operator|=
name|vlan
operator|&
literal|0x1F
expr_stmt|;
comment|/* lower five bits */
name|VftaReg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VFTA
argument_list|(
name|VftaIndex
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vlan_on
condition|)
comment|/* Turn on this VLAN id */
name|VftaReg
operator||=
operator|(
literal|1
operator|<<
name|BitOffset
operator|)
expr_stmt|;
else|else
comment|/* Turn off this VLAN id */
name|VftaReg
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|BitOffset
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VFTA
argument_list|(
name|VftaIndex
argument_list|)
argument_list|,
name|VftaReg
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_setup_fc_generic - Configure flow control settings  *  @hw: pointer to hardware structure  *  @packetbuf_num: packet buffer number (0-7)  *  *  Configures the flow control settings based on SW configuration.  *  This function is used for 802.3x flow control configuration only.  **/
end_comment

begin_function
name|s32
name|ixgbe_setup_fc_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|s32
name|packetbuf_num
parameter_list|)
block|{
name|u32
name|frctl_reg
decl_stmt|;
name|u32
name|rmcs_reg
decl_stmt|;
if|if
condition|(
name|packetbuf_num
operator|<
literal|0
operator|||
name|packetbuf_num
operator|>
literal|7
condition|)
block|{
name|DEBUGOUT1
argument_list|(
literal|"Invalid packet buffer number [%d], expected range is"
literal|" 0-7\n"
argument_list|,
name|packetbuf_num
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|frctl_reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCTRL
argument_list|)
expr_stmt|;
name|frctl_reg
operator|&=
operator|~
operator|(
name|IXGBE_FCTRL_RFCE
operator||
name|IXGBE_FCTRL_RPFCE
operator|)
expr_stmt|;
name|rmcs_reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RMCS
argument_list|)
expr_stmt|;
name|rmcs_reg
operator|&=
operator|~
operator|(
name|IXGBE_RMCS_TFCE_PRIORITY
operator||
name|IXGBE_RMCS_TFCE_802_3X
operator|)
expr_stmt|;
comment|/* 	 * We want to save off the original Flow Control configuration just in 	 * case we get disconnected and then reconnected into a different hub 	 * or switch with different Flow Control capabilities. 	 */
name|hw
operator|->
name|fc
operator|.
name|type
operator|=
name|hw
operator|->
name|fc
operator|.
name|original_type
expr_stmt|;
comment|/* 	 * The possible values of the "flow_control" parameter are: 	 * 0: Flow control is completely disabled 	 * 1: Rx flow control is enabled (we can receive pause frames but not 	 *    send pause frames). 	 * 2: Tx flow control is enabled (we can send pause frames but we do not 	 *    support receiving pause frames) 	 * 3: Both Rx and TX flow control (symmetric) are enabled. 	 * other: Invalid. 	 */
switch|switch
condition|(
name|hw
operator|->
name|fc
operator|.
name|type
condition|)
block|{
case|case
name|ixgbe_fc_none
case|:
break|break;
case|case
name|ixgbe_fc_rx_pause
case|:
comment|/* 		 * RX Flow control is enabled, 		 * and TX Flow control is disabled. 		 */
name|frctl_reg
operator||=
name|IXGBE_FCTRL_RFCE
expr_stmt|;
break|break;
case|case
name|ixgbe_fc_tx_pause
case|:
comment|/* 		 * TX Flow control is enabled, and RX Flow control is disabled, 		 * by a software over-ride. 		 */
name|rmcs_reg
operator||=
name|IXGBE_RMCS_TFCE_802_3X
expr_stmt|;
break|break;
case|case
name|ixgbe_fc_full
case|:
comment|/* 		 * Flow control (both RX and TX) is enabled by a software 		 * over-ride. 		 */
name|frctl_reg
operator||=
name|IXGBE_FCTRL_RFCE
expr_stmt|;
name|rmcs_reg
operator||=
name|IXGBE_RMCS_TFCE_802_3X
expr_stmt|;
break|break;
default|default:
comment|/* We should never get here.  The value should be 0-3. */
name|DEBUGOUT
argument_list|(
literal|"Flow control param set incorrectly\n"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Enable 802.3x based flow control settings. */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCTRL
argument_list|,
name|frctl_reg
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RMCS
argument_list|,
name|rmcs_reg
argument_list|)
expr_stmt|;
comment|/* 	 * We need to set up the Receive Threshold high and low water 	 * marks as well as (optionally) enabling the transmission of 	 * XON frames. 	 */
if|if
condition|(
name|hw
operator|->
name|fc
operator|.
name|type
operator|&
name|ixgbe_fc_tx_pause
condition|)
block|{
if|if
condition|(
name|hw
operator|->
name|fc
operator|.
name|send_xon
condition|)
block|{
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCRTL
argument_list|(
name|packetbuf_num
argument_list|)
argument_list|,
operator|(
name|hw
operator|->
name|fc
operator|.
name|low_water
operator||
name|IXGBE_FCRTL_XONE
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCRTL
argument_list|(
name|packetbuf_num
argument_list|)
argument_list|,
name|hw
operator|->
name|fc
operator|.
name|low_water
argument_list|)
expr_stmt|;
block|}
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCRTH
argument_list|(
name|packetbuf_num
argument_list|)
argument_list|,
operator|(
name|hw
operator|->
name|fc
operator|.
name|high_water
operator|)
operator||
name|IXGBE_FCRTH_FCEN
argument_list|)
expr_stmt|;
block|}
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCTTV
argument_list|(
literal|0
argument_list|)
argument_list|,
name|hw
operator|->
name|fc
operator|.
name|pause_time
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCRTV
argument_list|,
operator|(
name|hw
operator|->
name|fc
operator|.
name|pause_time
operator|>>
literal|1
operator|)
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_disable_pcie_master - Disable PCI-express master access  *  @hw: pointer to hardware structure  *  *  Disables PCI-Express master access and verifies there are no pending  *  requests. IXGBE_ERR_MASTER_REQUESTS_PENDING is returned if master disable  *  bit hasn't caused the master requests to be disabled, else IXGBE_SUCCESS  *  is returned signifying master requests disabled.  **/
end_comment

begin_function
name|s32
name|ixgbe_disable_pcie_master
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|ctrl
decl_stmt|;
name|s32
name|i
decl_stmt|;
name|s32
name|status
init|=
name|IXGBE_ERR_MASTER_REQUESTS_PENDING
decl_stmt|;
name|ctrl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CTRL
argument_list|)
expr_stmt|;
name|ctrl
operator||=
name|IXGBE_CTRL_GIO_DIS
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_PCI_MASTER_DISABLE_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_STATUS
argument_list|)
operator|&
name|IXGBE_STATUS_GIO
operator|)
condition|)
block|{
name|status
operator|=
name|IXGBE_SUCCESS
expr_stmt|;
break|break;
block|}
name|usec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_acquire_swfw_sync - Aquire SWFW semaphore  *  @hw: pointer to hardware structure  *  @mask: Mask to specify wich semaphore to acquire  *  *  Aquires the SWFW semaphore throught the GSSR register for the specified  *  function (CSR, PHY0, PHY1, EEPROM, Flash)  **/
end_comment

begin_function
name|s32
name|ixgbe_acquire_swfw_sync
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|mask
parameter_list|)
block|{
name|u32
name|gssr
decl_stmt|;
name|u32
name|swmask
init|=
name|mask
decl_stmt|;
name|u32
name|fwmask
init|=
name|mask
operator|<<
literal|5
decl_stmt|;
name|s32
name|timeout
init|=
literal|200
decl_stmt|;
while|while
condition|(
name|timeout
condition|)
block|{
if|if
condition|(
name|ixgbe_get_eeprom_semaphore
argument_list|(
name|hw
argument_list|)
condition|)
return|return
operator|-
name|IXGBE_ERR_SWFW_SYNC
return|;
name|gssr
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|gssr
operator|&
operator|(
name|fwmask
operator||
name|swmask
operator|)
operator|)
condition|)
break|break;
comment|/* 		 * Firmware currently using resource (fwmask) or other software 		 * thread currently using resource (swmask) 		 */
name|ixgbe_release_eeprom_semaphore
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|timeout
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|timeout
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Driver can't access resource, GSSR timeout.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|IXGBE_ERR_SWFW_SYNC
return|;
block|}
name|gssr
operator||=
name|swmask
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR
argument_list|,
name|gssr
argument_list|)
expr_stmt|;
name|ixgbe_release_eeprom_semaphore
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_release_swfw_sync - Release SWFW semaphore  *  @hw: pointer to hardware structure  *  @mask: Mask to specify wich semaphore to release  *  *  Releases the SWFW semaphore throught the GSSR register for the specified  *  function (CSR, PHY0, PHY1, EEPROM, Flash)  **/
end_comment

begin_function
name|void
name|ixgbe_release_swfw_sync
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|mask
parameter_list|)
block|{
name|u32
name|gssr
decl_stmt|;
name|u32
name|swmask
init|=
name|mask
decl_stmt|;
name|ixgbe_get_eeprom_semaphore
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|gssr
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR
argument_list|)
expr_stmt|;
name|gssr
operator|&=
operator|~
name|swmask
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR
argument_list|,
name|gssr
argument_list|)
expr_stmt|;
name|ixgbe_release_eeprom_semaphore
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

