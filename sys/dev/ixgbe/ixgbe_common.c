begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************    Copyright (c) 2001-2017, Intel Corporation   All rights reserved.    Redistribution and use in source and binary forms, with or without   modification, are permitted provided that the following conditions are met:     1. Redistributions of source code must retain the above copyright notice,       this list of conditions and the following disclaimer.     2. Redistributions in binary form must reproduce the above copyright       notice, this list of conditions and the following disclaimer in the       documentation and/or other materials provided with the distribution.     3. Neither the name of the Intel Corporation nor the names of its       contributors may be used to endorse or promote products derived from       this software without specific prior written permission.    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  ******************************************************************************/
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_include
include|#
directive|include
file|"ixgbe_common.h"
end_include

begin_include
include|#
directive|include
file|"ixgbe_phy.h"
end_include

begin_include
include|#
directive|include
file|"ixgbe_dcb.h"
end_include

begin_include
include|#
directive|include
file|"ixgbe_dcb_82599.h"
end_include

begin_include
include|#
directive|include
file|"ixgbe_api.h"
end_include

begin_function_decl
specifier|static
name|s32
name|ixgbe_acquire_eeprom
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|ixgbe_get_eeprom_semaphore
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_release_eeprom_semaphore
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|ixgbe_ready_eeprom
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_standby_eeprom
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_shift_out_eeprom_bits
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|data
parameter_list|,
name|u16
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u16
name|ixgbe_shift_in_eeprom_bits
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_raise_eeprom_clk
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|eec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_lower_eeprom_clk
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|eec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_release_eeprom
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|ixgbe_mta_vector
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|mc_addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|ixgbe_get_san_mac_addr_offset
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|san_mac_offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|ixgbe_read_eeprom_buffer_bit_bang
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
name|words
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|ixgbe_write_eeprom_buffer_bit_bang
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
name|words
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|ixgbe_detect_eeprom_page_size_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  *  ixgbe_init_ops_generic - Inits function ptrs  *  @hw: pointer to the hardware structure  *  *  Initialize the function pointers.  **/
end_comment

begin_function
name|s32
name|ixgbe_init_ops_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|ixgbe_eeprom_info
modifier|*
name|eeprom
init|=
operator|&
name|hw
operator|->
name|eeprom
decl_stmt|;
name|struct
name|ixgbe_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|u32
name|eec
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC_BY_MAC
argument_list|(
name|hw
argument_list|)
argument_list|)
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_init_ops_generic"
argument_list|)
expr_stmt|;
comment|/* EEPROM */
name|eeprom
operator|->
name|ops
operator|.
name|init_params
operator|=
name|ixgbe_init_eeprom_params_generic
expr_stmt|;
comment|/* If EEPROM is valid (bit 8 = 1), use EERD otherwise use bit bang */
if|if
condition|(
name|eec
operator|&
name|IXGBE_EEC_PRES
condition|)
block|{
name|eeprom
operator|->
name|ops
operator|.
name|read
operator|=
name|ixgbe_read_eerd_generic
expr_stmt|;
name|eeprom
operator|->
name|ops
operator|.
name|read_buffer
operator|=
name|ixgbe_read_eerd_buffer_generic
expr_stmt|;
block|}
else|else
block|{
name|eeprom
operator|->
name|ops
operator|.
name|read
operator|=
name|ixgbe_read_eeprom_bit_bang_generic
expr_stmt|;
name|eeprom
operator|->
name|ops
operator|.
name|read_buffer
operator|=
name|ixgbe_read_eeprom_buffer_bit_bang_generic
expr_stmt|;
block|}
name|eeprom
operator|->
name|ops
operator|.
name|write
operator|=
name|ixgbe_write_eeprom_generic
expr_stmt|;
name|eeprom
operator|->
name|ops
operator|.
name|write_buffer
operator|=
name|ixgbe_write_eeprom_buffer_bit_bang_generic
expr_stmt|;
name|eeprom
operator|->
name|ops
operator|.
name|validate_checksum
operator|=
name|ixgbe_validate_eeprom_checksum_generic
expr_stmt|;
name|eeprom
operator|->
name|ops
operator|.
name|update_checksum
operator|=
name|ixgbe_update_eeprom_checksum_generic
expr_stmt|;
name|eeprom
operator|->
name|ops
operator|.
name|calc_checksum
operator|=
name|ixgbe_calc_eeprom_checksum_generic
expr_stmt|;
comment|/* MAC */
name|mac
operator|->
name|ops
operator|.
name|init_hw
operator|=
name|ixgbe_init_hw_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|reset_hw
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|start_hw
operator|=
name|ixgbe_start_hw_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|clear_hw_cntrs
operator|=
name|ixgbe_clear_hw_cntrs_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_media_type
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_supported_physical_layer
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|enable_rx_dma
operator|=
name|ixgbe_enable_rx_dma_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_mac_addr
operator|=
name|ixgbe_get_mac_addr_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|stop_adapter
operator|=
name|ixgbe_stop_adapter_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_bus_info
operator|=
name|ixgbe_get_bus_info_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|set_lan_id
operator|=
name|ixgbe_set_lan_id_multi_port_pcie
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|acquire_swfw_sync
operator|=
name|ixgbe_acquire_swfw_sync
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|release_swfw_sync
operator|=
name|ixgbe_release_swfw_sync
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|prot_autoc_read
operator|=
name|prot_autoc_read_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|prot_autoc_write
operator|=
name|prot_autoc_write_generic
expr_stmt|;
comment|/* LEDs */
name|mac
operator|->
name|ops
operator|.
name|led_on
operator|=
name|ixgbe_led_on_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|led_off
operator|=
name|ixgbe_led_off_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|blink_led_start
operator|=
name|ixgbe_blink_led_start_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|blink_led_stop
operator|=
name|ixgbe_blink_led_stop_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|init_led_link_act
operator|=
name|ixgbe_init_led_link_act_generic
expr_stmt|;
comment|/* RAR, Multicast, VLAN */
name|mac
operator|->
name|ops
operator|.
name|set_rar
operator|=
name|ixgbe_set_rar_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|clear_rar
operator|=
name|ixgbe_clear_rar_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|insert_mac_addr
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|set_vmdq
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|clear_vmdq
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|init_rx_addrs
operator|=
name|ixgbe_init_rx_addrs_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|update_uc_addr_list
operator|=
name|ixgbe_update_uc_addr_list_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|update_mc_addr_list
operator|=
name|ixgbe_update_mc_addr_list_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|enable_mc
operator|=
name|ixgbe_enable_mc_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|disable_mc
operator|=
name|ixgbe_disable_mc_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|clear_vfta
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|set_vfta
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|set_vlvf
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|init_uta_tables
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|enable_rx
operator|=
name|ixgbe_enable_rx_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|disable_rx
operator|=
name|ixgbe_disable_rx_generic
expr_stmt|;
comment|/* Flow Control */
name|mac
operator|->
name|ops
operator|.
name|fc_enable
operator|=
name|ixgbe_fc_enable_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|setup_fc
operator|=
name|ixgbe_setup_fc_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|fc_autoneg
operator|=
name|ixgbe_fc_autoneg
expr_stmt|;
comment|/* Link */
name|mac
operator|->
name|ops
operator|.
name|get_link_capabilities
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|setup_link
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|check_link
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|dmac_config
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|dmac_update_tcs
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|dmac_config_tcs
operator|=
name|NULL
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_device_supports_autoneg_fc - Check if device supports autonegotiation  * of flow control  * @hw: pointer to hardware structure  *  * This function returns TRUE if the device supports flow control  * autonegotiation, and FALSE if it does not.  *  **/
end_comment

begin_function
name|bool
name|ixgbe_device_supports_autoneg_fc
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|bool
name|supported
init|=
name|FALSE
decl_stmt|;
name|ixgbe_link_speed
name|speed
decl_stmt|;
name|bool
name|link_up
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_device_supports_autoneg_fc"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|phy
operator|.
name|media_type
condition|)
block|{
case|case
name|ixgbe_media_type_fiber_fixed
case|:
case|case
name|ixgbe_media_type_fiber_qsfp
case|:
case|case
name|ixgbe_media_type_fiber
case|:
comment|/* flow control autoneg black list */
switch|switch
condition|(
name|hw
operator|->
name|device_id
condition|)
block|{
case|case
name|IXGBE_DEV_ID_X550EM_A_SFP
case|:
case|case
name|IXGBE_DEV_ID_X550EM_A_SFP_N
case|:
case|case
name|IXGBE_DEV_ID_X550EM_A_QSFP
case|:
case|case
name|IXGBE_DEV_ID_X550EM_A_QSFP_N
case|:
name|supported
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|check_link
argument_list|(
name|hw
argument_list|,
operator|&
name|speed
argument_list|,
operator|&
name|link_up
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* if link is down, assume supported */
if|if
condition|(
name|link_up
condition|)
name|supported
operator|=
name|speed
operator|==
name|IXGBE_LINK_SPEED_1GB_FULL
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
else|else
name|supported
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
name|ixgbe_media_type_backplane
case|:
if|if
condition|(
name|hw
operator|->
name|device_id
operator|==
name|IXGBE_DEV_ID_X550EM_X_XFI
condition|)
name|supported
operator|=
name|FALSE
expr_stmt|;
else|else
name|supported
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|ixgbe_media_type_copper
case|:
comment|/* only some copper devices support flow control autoneg */
switch|switch
condition|(
name|hw
operator|->
name|device_id
condition|)
block|{
case|case
name|IXGBE_DEV_ID_82599_T3_LOM
case|:
case|case
name|IXGBE_DEV_ID_X540T
case|:
case|case
name|IXGBE_DEV_ID_X540T1
case|:
case|case
name|IXGBE_DEV_ID_X540_BYPASS
case|:
case|case
name|IXGBE_DEV_ID_X550T
case|:
case|case
name|IXGBE_DEV_ID_X550T1
case|:
case|case
name|IXGBE_DEV_ID_X550EM_X_10G_T
case|:
case|case
name|IXGBE_DEV_ID_X550EM_A_10G_T
case|:
case|case
name|IXGBE_DEV_ID_X550EM_A_1G_T
case|:
case|case
name|IXGBE_DEV_ID_X550EM_A_1G_T_L
case|:
name|supported
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
name|supported
operator|=
name|FALSE
expr_stmt|;
block|}
default|default:
break|break;
block|}
if|if
condition|(
operator|!
name|supported
condition|)
name|ERROR_REPORT2
argument_list|(
name|IXGBE_ERROR_UNSUPPORTED
argument_list|,
literal|"Device %x does not support flow control autoneg"
argument_list|,
name|hw
operator|->
name|device_id
argument_list|)
expr_stmt|;
return|return
name|supported
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_setup_fc_generic - Set up flow control  *  @hw: pointer to hardware structure  *  *  Called at init time to set up flow control.  **/
end_comment

begin_function
name|s32
name|ixgbe_setup_fc_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u32
name|reg
init|=
literal|0
decl_stmt|,
name|reg_bp
init|=
literal|0
decl_stmt|;
name|u16
name|reg_cu
init|=
literal|0
decl_stmt|;
name|bool
name|locked
init|=
name|FALSE
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_setup_fc_generic"
argument_list|)
expr_stmt|;
comment|/* Validate the requested mode */
if|if
condition|(
name|hw
operator|->
name|fc
operator|.
name|strict_ieee
operator|&&
name|hw
operator|->
name|fc
operator|.
name|requested_mode
operator|==
name|ixgbe_fc_rx_pause
condition|)
block|{
name|ERROR_REPORT1
argument_list|(
name|IXGBE_ERROR_UNSUPPORTED
argument_list|,
literal|"ixgbe_fc_rx_pause not valid in strict IEEE mode\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|IXGBE_ERR_INVALID_LINK_SETTINGS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * 10gig parts do not have a word in the EEPROM to determine the 	 * default flow control setting, so we explicitly set it to full. 	 */
if|if
condition|(
name|hw
operator|->
name|fc
operator|.
name|requested_mode
operator|==
name|ixgbe_fc_default
condition|)
name|hw
operator|->
name|fc
operator|.
name|requested_mode
operator|=
name|ixgbe_fc_full
expr_stmt|;
comment|/* 	 * Set up the 1G and 10G flow control advertisement registers so the 	 * HW will be able to do fc autoneg once the cable is plugged in.  If 	 * we link at 10G, the 1G advertisement is harmless and vice versa. 	 */
switch|switch
condition|(
name|hw
operator|->
name|phy
operator|.
name|media_type
condition|)
block|{
case|case
name|ixgbe_media_type_backplane
case|:
comment|/* some MAC's need RMW protection on AUTOC */
name|ret_val
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|prot_autoc_read
argument_list|(
name|hw
argument_list|,
operator|&
name|locked
argument_list|,
operator|&
name|reg_bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|out
goto|;
comment|/* fall through - only backplane uses autoc */
case|case
name|ixgbe_media_type_fiber_fixed
case|:
case|case
name|ixgbe_media_type_fiber_qsfp
case|:
case|case
name|ixgbe_media_type_fiber
case|:
name|reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PCS1GANA
argument_list|)
expr_stmt|;
break|break;
case|case
name|ixgbe_media_type_copper
case|:
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_ADVT
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
operator|&
name|reg_cu
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* 	 * The possible values of fc.requested_mode are: 	 * 0: Flow control is completely disabled 	 * 1: Rx flow control is enabled (we can receive pause frames, 	 *    but not send pause frames). 	 * 2: Tx flow control is enabled (we can send pause frames but 	 *    we do not support receiving pause frames). 	 * 3: Both Rx and Tx flow control (symmetric) are enabled. 	 * other: Invalid. 	 */
switch|switch
condition|(
name|hw
operator|->
name|fc
operator|.
name|requested_mode
condition|)
block|{
case|case
name|ixgbe_fc_none
case|:
comment|/* Flow control completely disabled by software override. */
name|reg
operator|&=
operator|~
operator|(
name|IXGBE_PCS1GANA_SYM_PAUSE
operator||
name|IXGBE_PCS1GANA_ASM_PAUSE
operator|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|==
name|ixgbe_media_type_backplane
condition|)
name|reg_bp
operator|&=
operator|~
operator|(
name|IXGBE_AUTOC_SYM_PAUSE
operator||
name|IXGBE_AUTOC_ASM_PAUSE
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|==
name|ixgbe_media_type_copper
condition|)
name|reg_cu
operator|&=
operator|~
operator|(
name|IXGBE_TAF_SYM_PAUSE
operator||
name|IXGBE_TAF_ASM_PAUSE
operator|)
expr_stmt|;
break|break;
case|case
name|ixgbe_fc_tx_pause
case|:
comment|/* 		 * Tx Flow control is enabled, and Rx Flow control is 		 * disabled by software override. 		 */
name|reg
operator||=
name|IXGBE_PCS1GANA_ASM_PAUSE
expr_stmt|;
name|reg
operator|&=
operator|~
name|IXGBE_PCS1GANA_SYM_PAUSE
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|==
name|ixgbe_media_type_backplane
condition|)
block|{
name|reg_bp
operator||=
name|IXGBE_AUTOC_ASM_PAUSE
expr_stmt|;
name|reg_bp
operator|&=
operator|~
name|IXGBE_AUTOC_SYM_PAUSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|==
name|ixgbe_media_type_copper
condition|)
block|{
name|reg_cu
operator||=
name|IXGBE_TAF_ASM_PAUSE
expr_stmt|;
name|reg_cu
operator|&=
operator|~
name|IXGBE_TAF_SYM_PAUSE
expr_stmt|;
block|}
break|break;
case|case
name|ixgbe_fc_rx_pause
case|:
comment|/* 		 * Rx Flow control is enabled and Tx Flow control is 		 * disabled by software override. Since there really 		 * isn't a way to advertise that we are capable of RX 		 * Pause ONLY, we will advertise that we support both 		 * symmetric and asymmetric Rx PAUSE, as such we fall 		 * through to the fc_full statement.  Later, we will 		 * disable the adapter's ability to send PAUSE frames. 		 */
case|case
name|ixgbe_fc_full
case|:
comment|/* Flow control (both Rx and Tx) is enabled by SW override. */
name|reg
operator||=
name|IXGBE_PCS1GANA_SYM_PAUSE
operator||
name|IXGBE_PCS1GANA_ASM_PAUSE
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|==
name|ixgbe_media_type_backplane
condition|)
name|reg_bp
operator||=
name|IXGBE_AUTOC_SYM_PAUSE
operator||
name|IXGBE_AUTOC_ASM_PAUSE
expr_stmt|;
elseif|else
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|==
name|ixgbe_media_type_copper
condition|)
name|reg_cu
operator||=
name|IXGBE_TAF_SYM_PAUSE
operator||
name|IXGBE_TAF_ASM_PAUSE
expr_stmt|;
break|break;
default|default:
name|ERROR_REPORT1
argument_list|(
name|IXGBE_ERROR_ARGUMENT
argument_list|,
literal|"Flow control param set incorrectly\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|IXGBE_ERR_CONFIG
expr_stmt|;
goto|goto
name|out
goto|;
break|break;
block|}
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|<
name|ixgbe_mac_X540
condition|)
block|{
comment|/* 		 * Enable auto-negotiation between the MAC& PHY; 		 * the MAC will advertise clause 37 flow control. 		 */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PCS1GANA
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PCS1GLCTL
argument_list|)
expr_stmt|;
comment|/* Disable AN timeout */
if|if
condition|(
name|hw
operator|->
name|fc
operator|.
name|strict_ieee
condition|)
name|reg
operator|&=
operator|~
name|IXGBE_PCS1GLCTL_AN_1G_TIMEOUT_EN
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PCS1GLCTL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"Set up FC; PCS1GLCTL = 0x%08X\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * AUTOC restart handles negotiation of 1G and 10G on backplane 	 * and copper. There is no need to set the PCS1GCTL register. 	 * 	 */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|==
name|ixgbe_media_type_backplane
condition|)
block|{
name|reg_bp
operator||=
name|IXGBE_AUTOC_AN_RESTART
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|prot_autoc_write
argument_list|(
name|hw
argument_list|,
name|reg_bp
argument_list|,
name|locked
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|==
name|ixgbe_media_type_copper
operator|)
operator|&&
operator|(
name|ixgbe_device_supports_autoneg_fc
argument_list|(
name|hw
argument_list|)
operator|)
condition|)
block|{
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_ADVT
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
name|reg_cu
argument_list|)
expr_stmt|;
block|}
name|DEBUGOUT1
argument_list|(
literal|"Set up FC; PCS1GLCTL = 0x%08X\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_start_hw_generic - Prepare hardware for Tx/Rx  *  @hw: pointer to hardware structure  *  *  Starts the hardware by filling the bus info structure and media type, clears  *  all on chip counters, initializes receive address registers, multicast  *  table, VLAN filter table, calls routine to set up link and flow control  *  settings, and leaves transmit and receive units disabled and uninitialized  **/
end_comment

begin_function
name|s32
name|ixgbe_start_hw_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u32
name|ctrl_ext
decl_stmt|;
name|u16
name|device_caps
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_start_hw_generic"
argument_list|)
expr_stmt|;
comment|/* Set the media type */
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|get_media_type
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* PHY ops initialization must be done in reset_hw() */
comment|/* Clear the VLAN filter table */
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|clear_vfta
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Clear statistics registers */
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|clear_hw_cntrs
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Set No Snoop Disable */
name|ctrl_ext
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CTRL_EXT
argument_list|)
expr_stmt|;
name|ctrl_ext
operator||=
name|IXGBE_CTRL_EXT_NS_DIS
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CTRL_EXT
argument_list|,
name|ctrl_ext
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Setup flow control */
name|ret_val
operator|=
name|ixgbe_setup_fc
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|IXGBE_SUCCESS
operator|&&
name|ret_val
operator|!=
name|IXGBE_NOT_IMPLEMENTED
condition|)
block|{
name|DEBUGOUT1
argument_list|(
literal|"Flow control setup failed, returning %d\n"
argument_list|,
name|ret_val
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
comment|/* Cache bit indicating need for crosstalk fix */
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|ixgbe_mac_82599EB
case|:
case|case
name|ixgbe_mac_X550EM_x
case|:
case|case
name|ixgbe_mac_X550EM_a
case|:
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|get_device_caps
argument_list|(
name|hw
argument_list|,
operator|&
name|device_caps
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_caps
operator|&
name|IXGBE_DEVICE_CAPS_NO_CROSSTALK_WR
condition|)
name|hw
operator|->
name|need_crosstalk_fix
operator|=
name|FALSE
expr_stmt|;
else|else
name|hw
operator|->
name|need_crosstalk_fix
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
name|hw
operator|->
name|need_crosstalk_fix
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
comment|/* Clear adapter stopped flag */
name|hw
operator|->
name|adapter_stopped
operator|=
name|FALSE
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_start_hw_gen2 - Init sequence for common device family  *  @hw: pointer to hw structure  *  * Performs the init sequence common to the second generation  * of 10 GbE devices.  * Devices in the second generation:  *     82599  *     X540  **/
end_comment

begin_function
name|s32
name|ixgbe_start_hw_gen2
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|i
decl_stmt|;
name|u32
name|regval
decl_stmt|;
comment|/* Clear the rate limiters */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hw
operator|->
name|mac
operator|.
name|max_tx_queues
condition|;
name|i
operator|++
control|)
block|{
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RTTDQSEL
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RTTBCNRC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Disable relaxed ordering */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hw
operator|->
name|mac
operator|.
name|max_tx_queues
condition|;
name|i
operator|++
control|)
block|{
name|regval
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DCA_TXCTRL_82599
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|regval
operator|&=
operator|~
name|IXGBE_DCA_TXCTRL_DESC_WRO_EN
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DCA_TXCTRL_82599
argument_list|(
name|i
argument_list|)
argument_list|,
name|regval
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hw
operator|->
name|mac
operator|.
name|max_rx_queues
condition|;
name|i
operator|++
control|)
block|{
name|regval
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DCA_RXCTRL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|regval
operator|&=
operator|~
operator|(
name|IXGBE_DCA_RXCTRL_DATA_WRO_EN
operator||
name|IXGBE_DCA_RXCTRL_HEAD_WRO_EN
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DCA_RXCTRL
argument_list|(
name|i
argument_list|)
argument_list|,
name|regval
argument_list|)
expr_stmt|;
block|}
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_init_hw_generic - Generic hardware initialization  *  @hw: pointer to hardware structure  *  *  Initialize the hardware by resetting the hardware, filling the bus info  *  structure and media type, clears all on chip counters, initializes receive  *  address registers, multicast table, VLAN filter table, calls routine to set  *  up link and flow control settings, and leaves transmit and receive units  *  disabled and uninitialized  **/
end_comment

begin_function
name|s32
name|ixgbe_init_hw_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_init_hw_generic"
argument_list|)
expr_stmt|;
comment|/* Reset the hardware */
name|status
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|reset_hw
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
operator|||
name|status
operator|==
name|IXGBE_ERR_SFP_NOT_PRESENT
condition|)
block|{
comment|/* Start the HW */
name|status
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|start_hw
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize the LED link active for LED blink support */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|init_led_link_act
condition|)
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|init_led_link_act
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
name|DEBUGOUT1
argument_list|(
literal|"Failed to initialize HW, STATUS = %d\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_clear_hw_cntrs_generic - Generic clear hardware counters  *  @hw: pointer to hardware structure  *  *  Clears all hardware statistics counters by reading them from the hardware  *  Statistics counters are clear on read.  **/
end_comment

begin_function
name|s32
name|ixgbe_clear_hw_cntrs_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u16
name|i
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_clear_hw_cntrs_generic"
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CRCERRS
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ILLERRC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ERRBC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MSPDC
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MPC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MLFC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MRFC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RLEC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LXONTXC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LXOFFTXC
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|>=
name|ixgbe_mac_82599EB
condition|)
block|{
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LXONRXCNT
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LXOFFRXCNT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LXONRXC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LXOFFRXC
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PXONTXC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PXOFFTXC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|>=
name|ixgbe_mac_82599EB
condition|)
block|{
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PXONRXCNT
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PXOFFRXCNT
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PXONRXC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PXOFFRXC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|>=
name|ixgbe_mac_82599EB
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PXON2OFFCNT
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PRC64
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PRC127
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PRC255
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PRC511
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PRC1023
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PRC1522
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GPRC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_BPRC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MPRC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GPTC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GORCL
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GORCH
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GOTCL
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GOTCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_82598EB
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RNBC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RUC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RFC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ROC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RJC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MNGPRC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MNGPDC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MNGPTC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_TORL
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_TORH
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_TPR
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_TPT
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PTC64
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PTC127
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PTC255
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PTC511
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PTC1023
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PTC1522
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MPTC
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_BPTC
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_QPRC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_QPTC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|>=
name|ixgbe_mac_82599EB
condition|)
block|{
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_QBRC_L
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_QBRC_H
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_QBTC_L
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_QBTC_H
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_QPRDC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_QBRC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_QBTC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_X550
operator|||
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_X540
condition|)
block|{
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|id
operator|==
literal|0
condition|)
name|ixgbe_identify_phy
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_PCRC8ECL
argument_list|,
name|IXGBE_MDIO_PCS_DEV_TYPE
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_PCRC8ECH
argument_list|,
name|IXGBE_MDIO_PCS_DEV_TYPE
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_LDPCECL
argument_list|,
name|IXGBE_MDIO_PCS_DEV_TYPE
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_LDPCECH
argument_list|,
name|IXGBE_MDIO_PCS_DEV_TYPE
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_read_pba_string_generic - Reads part number string from EEPROM  *  @hw: pointer to hardware structure  *  @pba_num: stores the part number string from the EEPROM  *  @pba_num_size: part number string buffer length  *  *  Reads the part number string from the EEPROM.  **/
end_comment

begin_function
name|s32
name|ixgbe_read_pba_string_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|pba_num
parameter_list|,
name|u32
name|pba_num_size
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u16
name|data
decl_stmt|;
name|u16
name|pba_ptr
decl_stmt|;
name|u16
name|offset
decl_stmt|;
name|u16
name|length
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_read_pba_string_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pba_num
operator|==
name|NULL
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PBA string buffer was null\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_INVALID_ARGUMENT
return|;
block|}
name|ret_val
operator|=
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|IXGBE_PBANUM0_PTR
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"NVM Read Error\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
name|ret_val
operator|=
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|IXGBE_PBANUM1_PTR
argument_list|,
operator|&
name|pba_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"NVM Read Error\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
comment|/* 	 * if data is not ptr guard the PBA must be in legacy format which 	 * means pba_ptr is actually our second data word for the PBA number 	 * and we can decode it into an ascii string 	 */
if|if
condition|(
name|data
operator|!=
name|IXGBE_PBANUM_PTR_GUARD
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"NVM PBA number is not stored as string\n"
argument_list|)
expr_stmt|;
comment|/* we will need 11 characters to store the PBA */
if|if
condition|(
name|pba_num_size
operator|<
literal|11
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PBA string buffer too small\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_NO_SPACE
return|;
block|}
comment|/* extract hex string from data and pba_ptr */
name|pba_num
index|[
literal|0
index|]
operator|=
operator|(
name|data
operator|>>
literal|12
operator|)
operator|&
literal|0xF
expr_stmt|;
name|pba_num
index|[
literal|1
index|]
operator|=
operator|(
name|data
operator|>>
literal|8
operator|)
operator|&
literal|0xF
expr_stmt|;
name|pba_num
index|[
literal|2
index|]
operator|=
operator|(
name|data
operator|>>
literal|4
operator|)
operator|&
literal|0xF
expr_stmt|;
name|pba_num
index|[
literal|3
index|]
operator|=
name|data
operator|&
literal|0xF
expr_stmt|;
name|pba_num
index|[
literal|4
index|]
operator|=
operator|(
name|pba_ptr
operator|>>
literal|12
operator|)
operator|&
literal|0xF
expr_stmt|;
name|pba_num
index|[
literal|5
index|]
operator|=
operator|(
name|pba_ptr
operator|>>
literal|8
operator|)
operator|&
literal|0xF
expr_stmt|;
name|pba_num
index|[
literal|6
index|]
operator|=
literal|'-'
expr_stmt|;
name|pba_num
index|[
literal|7
index|]
operator|=
literal|0
expr_stmt|;
name|pba_num
index|[
literal|8
index|]
operator|=
operator|(
name|pba_ptr
operator|>>
literal|4
operator|)
operator|&
literal|0xF
expr_stmt|;
name|pba_num
index|[
literal|9
index|]
operator|=
name|pba_ptr
operator|&
literal|0xF
expr_stmt|;
comment|/* put a null character on the end of our string */
name|pba_num
index|[
literal|10
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* switch all the data but the '-' to hex char */
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
literal|10
condition|;
name|offset
operator|++
control|)
block|{
if|if
condition|(
name|pba_num
index|[
name|offset
index|]
operator|<
literal|0xA
condition|)
name|pba_num
index|[
name|offset
index|]
operator|+=
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|pba_num
index|[
name|offset
index|]
operator|<
literal|0x10
condition|)
name|pba_num
index|[
name|offset
index|]
operator|+=
literal|'A'
operator|-
literal|0xA
expr_stmt|;
block|}
return|return
name|IXGBE_SUCCESS
return|;
block|}
name|ret_val
operator|=
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|pba_ptr
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"NVM Read Error\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
if|if
condition|(
name|length
operator|==
literal|0xFFFF
operator|||
name|length
operator|==
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"NVM PBA number section invalid length\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_PBA_SECTION
return|;
block|}
comment|/* check if pba_num buffer is big enough */
if|if
condition|(
name|pba_num_size
operator|<
operator|(
operator|(
operator|(
name|u32
operator|)
name|length
operator|*
literal|2
operator|)
operator|-
literal|1
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PBA string buffer too small\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_NO_SPACE
return|;
block|}
comment|/* trim pba length from start of string */
name|pba_ptr
operator|++
expr_stmt|;
name|length
operator|--
expr_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|length
condition|;
name|offset
operator|++
control|)
block|{
name|ret_val
operator|=
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|pba_ptr
operator|+
name|offset
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"NVM Read Error\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
name|pba_num
index|[
name|offset
operator|*
literal|2
index|]
operator|=
call|(
name|u8
call|)
argument_list|(
name|data
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|pba_num
index|[
operator|(
name|offset
operator|*
literal|2
operator|)
operator|+
literal|1
index|]
operator|=
call|(
name|u8
call|)
argument_list|(
name|data
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
block|}
name|pba_num
index|[
name|offset
operator|*
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_read_pba_num_generic - Reads part number from EEPROM  *  @hw: pointer to hardware structure  *  @pba_num: stores the part number from the EEPROM  *  *  Reads the part number from the EEPROM.  **/
end_comment

begin_function
name|s32
name|ixgbe_read_pba_num_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|pba_num
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u16
name|data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_read_pba_num_generic"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|IXGBE_PBANUM0_PTR
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"NVM Read Error\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
elseif|else
if|if
condition|(
name|data
operator|==
name|IXGBE_PBANUM_PTR_GUARD
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"NVM Not supported\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_NOT_IMPLEMENTED
return|;
block|}
operator|*
name|pba_num
operator|=
call|(
name|u32
call|)
argument_list|(
name|data
operator|<<
literal|16
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|IXGBE_PBANUM1_PTR
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"NVM Read Error\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
operator|*
name|pba_num
operator||=
name|data
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_read_pba_raw  *  @hw: pointer to the HW structure  *  @eeprom_buf: optional pointer to EEPROM image  *  @eeprom_buf_size: size of EEPROM image in words  *  @max_pba_block_size: PBA block size limit  *  @pba: pointer to output PBA structure  *  *  Reads PBA from EEPROM image when eeprom_buf is not NULL.  *  Reads PBA from physical EEPROM device when eeprom_buf is NULL.  *  **/
end_comment

begin_function
name|s32
name|ixgbe_read_pba_raw
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|eeprom_buf
parameter_list|,
name|u32
name|eeprom_buf_size
parameter_list|,
name|u16
name|max_pba_block_size
parameter_list|,
name|struct
name|ixgbe_pba
modifier|*
name|pba
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u16
name|pba_block_size
decl_stmt|;
if|if
condition|(
name|pba
operator|==
name|NULL
condition|)
return|return
name|IXGBE_ERR_PARAM
return|;
if|if
condition|(
name|eeprom_buf
operator|==
name|NULL
condition|)
block|{
name|ret_val
operator|=
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read_buffer
argument_list|(
name|hw
argument_list|,
name|IXGBE_PBANUM0_PTR
argument_list|,
literal|2
argument_list|,
operator|&
name|pba
operator|->
name|word
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
else|else
block|{
if|if
condition|(
name|eeprom_buf_size
operator|>
name|IXGBE_PBANUM1_PTR
condition|)
block|{
name|pba
operator|->
name|word
index|[
literal|0
index|]
operator|=
name|eeprom_buf
index|[
name|IXGBE_PBANUM0_PTR
index|]
expr_stmt|;
name|pba
operator|->
name|word
index|[
literal|1
index|]
operator|=
name|eeprom_buf
index|[
name|IXGBE_PBANUM1_PTR
index|]
expr_stmt|;
block|}
else|else
block|{
return|return
name|IXGBE_ERR_PARAM
return|;
block|}
block|}
if|if
condition|(
name|pba
operator|->
name|word
index|[
literal|0
index|]
operator|==
name|IXGBE_PBANUM_PTR_GUARD
condition|)
block|{
if|if
condition|(
name|pba
operator|->
name|pba_block
operator|==
name|NULL
condition|)
return|return
name|IXGBE_ERR_PARAM
return|;
name|ret_val
operator|=
name|ixgbe_get_pba_block_size
argument_list|(
name|hw
argument_list|,
name|eeprom_buf
argument_list|,
name|eeprom_buf_size
argument_list|,
operator|&
name|pba_block_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
name|pba_block_size
operator|>
name|max_pba_block_size
condition|)
return|return
name|IXGBE_ERR_PARAM
return|;
if|if
condition|(
name|eeprom_buf
operator|==
name|NULL
condition|)
block|{
name|ret_val
operator|=
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read_buffer
argument_list|(
name|hw
argument_list|,
name|pba
operator|->
name|word
index|[
literal|1
index|]
argument_list|,
name|pba_block_size
argument_list|,
name|pba
operator|->
name|pba_block
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
else|else
block|{
if|if
condition|(
name|eeprom_buf_size
operator|>
call|(
name|u32
call|)
argument_list|(
name|pba
operator|->
name|word
index|[
literal|1
index|]
operator|+
name|pba_block_size
argument_list|)
condition|)
block|{
name|memcpy
argument_list|(
name|pba
operator|->
name|pba_block
argument_list|,
operator|&
name|eeprom_buf
index|[
name|pba
operator|->
name|word
index|[
literal|1
index|]
index|]
argument_list|,
name|pba_block_size
operator|*
sizeof|sizeof
argument_list|(
name|u16
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
name|IXGBE_ERR_PARAM
return|;
block|}
block|}
block|}
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_write_pba_raw  *  @hw: pointer to the HW structure  *  @eeprom_buf: optional pointer to EEPROM image  *  @eeprom_buf_size: size of EEPROM image in words  *  @pba: pointer to PBA structure  *  *  Writes PBA to EEPROM image when eeprom_buf is not NULL.  *  Writes PBA to physical EEPROM device when eeprom_buf is NULL.  *  **/
end_comment

begin_function
name|s32
name|ixgbe_write_pba_raw
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|eeprom_buf
parameter_list|,
name|u32
name|eeprom_buf_size
parameter_list|,
name|struct
name|ixgbe_pba
modifier|*
name|pba
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
if|if
condition|(
name|pba
operator|==
name|NULL
condition|)
return|return
name|IXGBE_ERR_PARAM
return|;
if|if
condition|(
name|eeprom_buf
operator|==
name|NULL
condition|)
block|{
name|ret_val
operator|=
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|write_buffer
argument_list|(
name|hw
argument_list|,
name|IXGBE_PBANUM0_PTR
argument_list|,
literal|2
argument_list|,
operator|&
name|pba
operator|->
name|word
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
else|else
block|{
if|if
condition|(
name|eeprom_buf_size
operator|>
name|IXGBE_PBANUM1_PTR
condition|)
block|{
name|eeprom_buf
index|[
name|IXGBE_PBANUM0_PTR
index|]
operator|=
name|pba
operator|->
name|word
index|[
literal|0
index|]
expr_stmt|;
name|eeprom_buf
index|[
name|IXGBE_PBANUM1_PTR
index|]
operator|=
name|pba
operator|->
name|word
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
return|return
name|IXGBE_ERR_PARAM
return|;
block|}
block|}
if|if
condition|(
name|pba
operator|->
name|word
index|[
literal|0
index|]
operator|==
name|IXGBE_PBANUM_PTR_GUARD
condition|)
block|{
if|if
condition|(
name|pba
operator|->
name|pba_block
operator|==
name|NULL
condition|)
return|return
name|IXGBE_ERR_PARAM
return|;
if|if
condition|(
name|eeprom_buf
operator|==
name|NULL
condition|)
block|{
name|ret_val
operator|=
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|write_buffer
argument_list|(
name|hw
argument_list|,
name|pba
operator|->
name|word
index|[
literal|1
index|]
argument_list|,
name|pba
operator|->
name|pba_block
index|[
literal|0
index|]
argument_list|,
name|pba
operator|->
name|pba_block
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
else|else
block|{
if|if
condition|(
name|eeprom_buf_size
operator|>
call|(
name|u32
call|)
argument_list|(
name|pba
operator|->
name|word
index|[
literal|1
index|]
operator|+
name|pba
operator|->
name|pba_block
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|eeprom_buf
index|[
name|pba
operator|->
name|word
index|[
literal|1
index|]
index|]
argument_list|,
name|pba
operator|->
name|pba_block
argument_list|,
name|pba
operator|->
name|pba_block
index|[
literal|0
index|]
operator|*
sizeof|sizeof
argument_list|(
name|u16
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
name|IXGBE_ERR_PARAM
return|;
block|}
block|}
block|}
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_pba_block_size  *  @hw: pointer to the HW structure  *  @eeprom_buf: optional pointer to EEPROM image  *  @eeprom_buf_size: size of EEPROM image in words  *  @pba_data_size: pointer to output variable  *  *  Returns the size of the PBA block in words. Function operates on EEPROM  *  image if the eeprom_buf pointer is not NULL otherwise it accesses physical  *  EEPROM device.  *  **/
end_comment

begin_function
name|s32
name|ixgbe_get_pba_block_size
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|eeprom_buf
parameter_list|,
name|u32
name|eeprom_buf_size
parameter_list|,
name|u16
modifier|*
name|pba_block_size
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u16
name|pba_word
index|[
literal|2
index|]
decl_stmt|;
name|u16
name|length
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_pba_block_size"
argument_list|)
expr_stmt|;
if|if
condition|(
name|eeprom_buf
operator|==
name|NULL
condition|)
block|{
name|ret_val
operator|=
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read_buffer
argument_list|(
name|hw
argument_list|,
name|IXGBE_PBANUM0_PTR
argument_list|,
literal|2
argument_list|,
operator|&
name|pba_word
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
else|else
block|{
if|if
condition|(
name|eeprom_buf_size
operator|>
name|IXGBE_PBANUM1_PTR
condition|)
block|{
name|pba_word
index|[
literal|0
index|]
operator|=
name|eeprom_buf
index|[
name|IXGBE_PBANUM0_PTR
index|]
expr_stmt|;
name|pba_word
index|[
literal|1
index|]
operator|=
name|eeprom_buf
index|[
name|IXGBE_PBANUM1_PTR
index|]
expr_stmt|;
block|}
else|else
block|{
return|return
name|IXGBE_ERR_PARAM
return|;
block|}
block|}
if|if
condition|(
name|pba_word
index|[
literal|0
index|]
operator|==
name|IXGBE_PBANUM_PTR_GUARD
condition|)
block|{
if|if
condition|(
name|eeprom_buf
operator|==
name|NULL
condition|)
block|{
name|ret_val
operator|=
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|pba_word
index|[
literal|1
index|]
operator|+
literal|0
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
else|else
block|{
if|if
condition|(
name|eeprom_buf_size
operator|>
name|pba_word
index|[
literal|1
index|]
condition|)
name|length
operator|=
name|eeprom_buf
index|[
name|pba_word
index|[
literal|1
index|]
operator|+
literal|0
index|]
expr_stmt|;
else|else
return|return
name|IXGBE_ERR_PARAM
return|;
block|}
if|if
condition|(
name|length
operator|==
literal|0xFFFF
operator|||
name|length
operator|==
literal|0
condition|)
return|return
name|IXGBE_ERR_PBA_SECTION
return|;
block|}
else|else
block|{
comment|/* PBA number in legacy format, there is no PBA Block. */
name|length
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|pba_block_size
operator|!=
name|NULL
condition|)
operator|*
name|pba_block_size
operator|=
name|length
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_mac_addr_generic - Generic get MAC address  *  @hw: pointer to hardware structure  *  @mac_addr: Adapter MAC address  *  *  Reads the adapter's MAC address from first Receive Address Register (RAR0)  *  A reset of the adapter must be performed prior to calling this function  *  in order for the MAC address to have been loaded from the EEPROM into RAR0  **/
end_comment

begin_function
name|s32
name|ixgbe_get_mac_addr_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|mac_addr
parameter_list|)
block|{
name|u32
name|rar_high
decl_stmt|;
name|u32
name|rar_low
decl_stmt|;
name|u16
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_mac_addr_generic"
argument_list|)
expr_stmt|;
name|rar_high
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RAH
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|rar_low
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RAL
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|mac_addr
index|[
name|i
index|]
operator|=
call|(
name|u8
call|)
argument_list|(
name|rar_low
operator|>>
operator|(
name|i
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
name|mac_addr
index|[
name|i
operator|+
literal|4
index|]
operator|=
call|(
name|u8
call|)
argument_list|(
name|rar_high
operator|>>
operator|(
name|i
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_set_pci_config_data_generic - Generic store PCI bus info  *  @hw: pointer to hardware structure  *  @link_status: the link status returned by the PCI config space  *  *  Stores the PCI bus info (speed, width, type) within the ixgbe_hw structure  **/
end_comment

begin_function
name|void
name|ixgbe_set_pci_config_data_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|link_status
parameter_list|)
block|{
name|struct
name|ixgbe_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
if|if
condition|(
name|hw
operator|->
name|bus
operator|.
name|type
operator|==
name|ixgbe_bus_type_unknown
condition|)
name|hw
operator|->
name|bus
operator|.
name|type
operator|=
name|ixgbe_bus_type_pci_express
expr_stmt|;
switch|switch
condition|(
name|link_status
operator|&
name|IXGBE_PCI_LINK_WIDTH
condition|)
block|{
case|case
name|IXGBE_PCI_LINK_WIDTH_1
case|:
name|hw
operator|->
name|bus
operator|.
name|width
operator|=
name|ixgbe_bus_width_pcie_x1
expr_stmt|;
break|break;
case|case
name|IXGBE_PCI_LINK_WIDTH_2
case|:
name|hw
operator|->
name|bus
operator|.
name|width
operator|=
name|ixgbe_bus_width_pcie_x2
expr_stmt|;
break|break;
case|case
name|IXGBE_PCI_LINK_WIDTH_4
case|:
name|hw
operator|->
name|bus
operator|.
name|width
operator|=
name|ixgbe_bus_width_pcie_x4
expr_stmt|;
break|break;
case|case
name|IXGBE_PCI_LINK_WIDTH_8
case|:
name|hw
operator|->
name|bus
operator|.
name|width
operator|=
name|ixgbe_bus_width_pcie_x8
expr_stmt|;
break|break;
default|default:
name|hw
operator|->
name|bus
operator|.
name|width
operator|=
name|ixgbe_bus_width_unknown
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|link_status
operator|&
name|IXGBE_PCI_LINK_SPEED
condition|)
block|{
case|case
name|IXGBE_PCI_LINK_SPEED_2500
case|:
name|hw
operator|->
name|bus
operator|.
name|speed
operator|=
name|ixgbe_bus_speed_2500
expr_stmt|;
break|break;
case|case
name|IXGBE_PCI_LINK_SPEED_5000
case|:
name|hw
operator|->
name|bus
operator|.
name|speed
operator|=
name|ixgbe_bus_speed_5000
expr_stmt|;
break|break;
case|case
name|IXGBE_PCI_LINK_SPEED_8000
case|:
name|hw
operator|->
name|bus
operator|.
name|speed
operator|=
name|ixgbe_bus_speed_8000
expr_stmt|;
break|break;
default|default:
name|hw
operator|->
name|bus
operator|.
name|speed
operator|=
name|ixgbe_bus_speed_unknown
expr_stmt|;
break|break;
block|}
name|mac
operator|->
name|ops
operator|.
name|set_lan_id
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_bus_info_generic - Generic set PCI bus info  *  @hw: pointer to hardware structure  *  *  Gets the PCI bus info (speed, width, type) then calls helper function to  *  store this data within the ixgbe_hw structure.  **/
end_comment

begin_function
name|s32
name|ixgbe_get_bus_info_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u16
name|link_status
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_bus_info_generic"
argument_list|)
expr_stmt|;
comment|/* Get the negotiated link width and speed from PCI config space */
name|link_status
operator|=
name|IXGBE_READ_PCIE_WORD
argument_list|(
name|hw
argument_list|,
name|IXGBE_PCI_LINK_STATUS
argument_list|)
expr_stmt|;
name|ixgbe_set_pci_config_data_generic
argument_list|(
name|hw
argument_list|,
name|link_status
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_set_lan_id_multi_port_pcie - Set LAN id for PCIe multiple port devices  *  @hw: pointer to the HW structure  *  *  Determines the LAN function id by reading memory-mapped registers and swaps  *  the port value if requested, and set MAC instance for devices that share  *  CS4227.  **/
end_comment

begin_function
name|void
name|ixgbe_set_lan_id_multi_port_pcie
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|ixgbe_bus_info
modifier|*
name|bus
init|=
operator|&
name|hw
operator|->
name|bus
decl_stmt|;
name|u32
name|reg
decl_stmt|;
name|u16
name|ee_ctrl_4
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_set_lan_id_multi_port_pcie"
argument_list|)
expr_stmt|;
name|reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_STATUS
argument_list|)
expr_stmt|;
name|bus
operator|->
name|func
operator|=
operator|(
name|reg
operator|&
name|IXGBE_STATUS_LAN_ID
operator|)
operator|>>
name|IXGBE_STATUS_LAN_ID_SHIFT
expr_stmt|;
name|bus
operator|->
name|lan_id
operator|=
operator|(
name|u8
operator|)
name|bus
operator|->
name|func
expr_stmt|;
comment|/* check for a port swap */
name|reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FACTPS_BY_MAC
argument_list|(
name|hw
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|IXGBE_FACTPS_LFS
condition|)
name|bus
operator|->
name|func
operator|^=
literal|0x1
expr_stmt|;
comment|/* Get MAC instance from EEPROM for configuring CS4227 */
if|if
condition|(
name|hw
operator|->
name|device_id
operator|==
name|IXGBE_DEV_ID_X550EM_A_SFP
condition|)
block|{
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEPROM_CTRL_4
argument_list|,
operator|&
name|ee_ctrl_4
argument_list|)
expr_stmt|;
name|bus
operator|->
name|instance_id
operator|=
operator|(
name|ee_ctrl_4
operator|&
name|IXGBE_EE_CTRL_4_INST_ID
operator|)
operator|>>
name|IXGBE_EE_CTRL_4_INST_ID_SHIFT
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *  ixgbe_stop_adapter_generic - Generic stop Tx/Rx units  *  @hw: pointer to hardware structure  *  *  Sets the adapter_stopped flag within ixgbe_hw struct. Clears interrupts,  *  disables transmit and receive units. The adapter_stopped flag is used by  *  the shared code and drivers to determine if the adapter is in a stopped  *  state and should not touch the hardware.  **/
end_comment

begin_function
name|s32
name|ixgbe_stop_adapter_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|reg_val
decl_stmt|;
name|u16
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_stop_adapter_generic"
argument_list|)
expr_stmt|;
comment|/* 	 * Set the adapter_stopped flag so other driver functions stop touching 	 * the hardware 	 */
name|hw
operator|->
name|adapter_stopped
operator|=
name|TRUE
expr_stmt|;
comment|/* Disable the receive unit */
name|ixgbe_disable_rx
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Clear interrupt mask to stop interrupts from being generated */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EIMC
argument_list|,
name|IXGBE_IRQ_CLEAR_MASK
argument_list|)
expr_stmt|;
comment|/* Clear any pending interrupts, flush previous writes */
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EICR
argument_list|)
expr_stmt|;
comment|/* Disable the transmit unit.  Each queue must be disabled. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hw
operator|->
name|mac
operator|.
name|max_tx_queues
condition|;
name|i
operator|++
control|)
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_TXDCTL
argument_list|(
name|i
argument_list|)
argument_list|,
name|IXGBE_TXDCTL_SWFLSH
argument_list|)
expr_stmt|;
comment|/* Disable the receive unit by stopping each queue */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hw
operator|->
name|mac
operator|.
name|max_rx_queues
condition|;
name|i
operator|++
control|)
block|{
name|reg_val
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXDCTL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|reg_val
operator|&=
operator|~
name|IXGBE_RXDCTL_ENABLE
expr_stmt|;
name|reg_val
operator||=
name|IXGBE_RXDCTL_SWFLSH
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXDCTL
argument_list|(
name|i
argument_list|)
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
block|}
comment|/* flush all queues disables */
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* 	 * Prevent the PCI-E bus from hanging by disabling PCI-E master 	 * access and verify no pending requests 	 */
return|return
name|ixgbe_disable_pcie_master
argument_list|(
name|hw
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_init_led_link_act_generic - Store the LED index link/activity.  *  @hw: pointer to hardware structure  *  *  Store the index for the link active LED. This will be used to support  *  blinking the LED.  **/
end_comment

begin_function
name|s32
name|ixgbe_init_led_link_act_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|ixgbe_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|u32
name|led_reg
decl_stmt|,
name|led_mode
decl_stmt|;
name|u8
name|i
decl_stmt|;
name|led_reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LEDCTL
argument_list|)
expr_stmt|;
comment|/* Get LED link active from the LEDCTL register */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|led_mode
operator|=
name|led_reg
operator|>>
name|IXGBE_LED_MODE_SHIFT
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|led_mode
operator|&
name|IXGBE_LED_MODE_MASK_BASE
operator|)
operator|==
name|IXGBE_LED_LINK_ACTIVE
condition|)
block|{
name|mac
operator|->
name|led_link_act
operator|=
name|i
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
block|}
comment|/* 	 * If LEDCTL register does not have the LED link active set, then use 	 * known MAC defaults. 	 */
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|ixgbe_mac_X550EM_a
case|:
case|case
name|ixgbe_mac_X550EM_x
case|:
name|mac
operator|->
name|led_link_act
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|mac
operator|->
name|led_link_act
operator|=
literal|2
expr_stmt|;
block|}
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_led_on_generic - Turns on the software controllable LEDs.  *  @hw: pointer to hardware structure  *  @index: led number to turn on  **/
end_comment

begin_function
name|s32
name|ixgbe_led_on_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|index
parameter_list|)
block|{
name|u32
name|led_reg
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LEDCTL
argument_list|)
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_led_on_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|>
literal|3
condition|)
return|return
name|IXGBE_ERR_PARAM
return|;
comment|/* To turn on the LED, set mode to ON. */
name|led_reg
operator|&=
operator|~
name|IXGBE_LED_MODE_MASK
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|led_reg
operator||=
name|IXGBE_LED_ON
operator|<<
name|IXGBE_LED_MODE_SHIFT
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LEDCTL
argument_list|,
name|led_reg
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_led_off_generic - Turns off the software controllable LEDs.  *  @hw: pointer to hardware structure  *  @index: led number to turn off  **/
end_comment

begin_function
name|s32
name|ixgbe_led_off_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|index
parameter_list|)
block|{
name|u32
name|led_reg
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LEDCTL
argument_list|)
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_led_off_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|>
literal|3
condition|)
return|return
name|IXGBE_ERR_PARAM
return|;
comment|/* To turn off the LED, set mode to OFF. */
name|led_reg
operator|&=
operator|~
name|IXGBE_LED_MODE_MASK
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|led_reg
operator||=
name|IXGBE_LED_OFF
operator|<<
name|IXGBE_LED_MODE_SHIFT
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LEDCTL
argument_list|,
name|led_reg
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_init_eeprom_params_generic - Initialize EEPROM params  *  @hw: pointer to hardware structure  *  *  Initializes the EEPROM parameters ixgbe_eeprom_info within the  *  ixgbe_hw struct in order to set up EEPROM access.  **/
end_comment

begin_function
name|s32
name|ixgbe_init_eeprom_params_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|ixgbe_eeprom_info
modifier|*
name|eeprom
init|=
operator|&
name|hw
operator|->
name|eeprom
decl_stmt|;
name|u32
name|eec
decl_stmt|;
name|u16
name|eeprom_size
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_init_eeprom_params_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|eeprom
operator|->
name|type
operator|==
name|ixgbe_eeprom_uninitialized
condition|)
block|{
name|eeprom
operator|->
name|type
operator|=
name|ixgbe_eeprom_none
expr_stmt|;
comment|/* Set default semaphore delay to 10ms which is a well 		 * tested value */
name|eeprom
operator|->
name|semaphore_delay
operator|=
literal|10
expr_stmt|;
comment|/* Clear EEPROM page size, it will be initialized as needed */
name|eeprom
operator|->
name|word_page_size
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Check for EEPROM present first. 		 * If not present leave as none 		 */
name|eec
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC_BY_MAC
argument_list|(
name|hw
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|eec
operator|&
name|IXGBE_EEC_PRES
condition|)
block|{
name|eeprom
operator|->
name|type
operator|=
name|ixgbe_eeprom_spi
expr_stmt|;
comment|/* 			 * SPI EEPROM is assumed here.  This code would need to 			 * change if a future EEPROM is not SPI. 			 */
name|eeprom_size
operator|=
call|(
name|u16
call|)
argument_list|(
operator|(
name|eec
operator|&
name|IXGBE_EEC_SIZE
operator|)
operator|>>
name|IXGBE_EEC_SIZE_SHIFT
argument_list|)
expr_stmt|;
name|eeprom
operator|->
name|word_size
operator|=
literal|1
operator|<<
operator|(
name|eeprom_size
operator|+
name|IXGBE_EEPROM_WORD_SIZE_SHIFT
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|eec
operator|&
name|IXGBE_EEC_ADDR_SIZE
condition|)
name|eeprom
operator|->
name|address_bits
operator|=
literal|16
expr_stmt|;
else|else
name|eeprom
operator|->
name|address_bits
operator|=
literal|8
expr_stmt|;
name|DEBUGOUT3
argument_list|(
literal|"Eeprom params: type = %d, size = %d, address bits: "
literal|"%d\n"
argument_list|,
name|eeprom
operator|->
name|type
argument_list|,
name|eeprom
operator|->
name|word_size
argument_list|,
name|eeprom
operator|->
name|address_bits
argument_list|)
expr_stmt|;
block|}
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_write_eeprom_buffer_bit_bang_generic - Write EEPROM using bit-bang  *  @hw: pointer to hardware structure  *  @offset: offset within the EEPROM to write  *  @words: number of word(s)  *  @data: 16 bit word(s) to write to EEPROM  *  *  Reads 16 bit word(s) from EEPROM through bit-bang method  **/
end_comment

begin_function
name|s32
name|ixgbe_write_eeprom_buffer_bit_bang_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
name|words
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u16
name|i
decl_stmt|,
name|count
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_write_eeprom_buffer_bit_bang_generic"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|init_params
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|words
operator|==
literal|0
condition|)
block|{
name|status
operator|=
name|IXGBE_ERR_INVALID_ARGUMENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|offset
operator|+
name|words
operator|>
name|hw
operator|->
name|eeprom
operator|.
name|word_size
condition|)
block|{
name|status
operator|=
name|IXGBE_ERR_EEPROM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * The EEPROM page size cannot be queried from the chip. We do lazy 	 * initialization. It is worth to do that when we write large buffer. 	 */
if|if
condition|(
operator|(
name|hw
operator|->
name|eeprom
operator|.
name|word_page_size
operator|==
literal|0
operator|)
operator|&&
operator|(
name|words
operator|>
name|IXGBE_EEPROM_PAGE_SIZE_MAX
operator|)
condition|)
name|ixgbe_detect_eeprom_page_size_generic
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|/* 	 * We cannot hold synchronization semaphores for too long 	 * to avoid other entity starvation. However it is more efficient 	 * to read in bursts than synchronizing access for each word. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|+=
name|IXGBE_EEPROM_RD_BUFFER_MAX_COUNT
control|)
block|{
name|count
operator|=
operator|(
name|words
operator|-
name|i
operator|)
operator|/
name|IXGBE_EEPROM_RD_BUFFER_MAX_COUNT
operator|>
literal|0
condition|?
name|IXGBE_EEPROM_RD_BUFFER_MAX_COUNT
else|:
operator|(
name|words
operator|-
name|i
operator|)
expr_stmt|;
name|status
operator|=
name|ixgbe_write_eeprom_buffer_bit_bang
argument_list|(
name|hw
argument_list|,
name|offset
operator|+
name|i
argument_list|,
name|count
argument_list|,
operator|&
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
break|break;
block|}
name|out
label|:
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_write_eeprom_buffer_bit_bang - Writes 16 bit word(s) to EEPROM  *  @hw: pointer to hardware structure  *  @offset: offset within the EEPROM to be written to  *  @words: number of word(s)  *  @data: 16 bit word(s) to be written to the EEPROM  *  *  If ixgbe_eeprom_update_checksum is not called after this function, the  *  EEPROM will most likely contain an invalid checksum.  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_write_eeprom_buffer_bit_bang
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
name|words
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|u16
name|word
decl_stmt|;
name|u16
name|page_size
decl_stmt|;
name|u16
name|i
decl_stmt|;
name|u8
name|write_opcode
init|=
name|IXGBE_EEPROM_WRITE_OPCODE_SPI
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_write_eeprom_buffer_bit_bang"
argument_list|)
expr_stmt|;
comment|/* Prepare the EEPROM for writing  */
name|status
operator|=
name|ixgbe_acquire_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
condition|)
block|{
if|if
condition|(
name|ixgbe_ready_eeprom
argument_list|(
name|hw
argument_list|)
operator|!=
name|IXGBE_SUCCESS
condition|)
block|{
name|ixgbe_release_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|status
operator|=
name|IXGBE_ERR_EEPROM
expr_stmt|;
block|}
block|}
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|++
control|)
block|{
name|ixgbe_standby_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/*  Send the WRITE ENABLE command (8 bit opcode )  */
name|ixgbe_shift_out_eeprom_bits
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEPROM_WREN_OPCODE_SPI
argument_list|,
name|IXGBE_EEPROM_OPCODE_BITS
argument_list|)
expr_stmt|;
name|ixgbe_standby_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* 			 * Some SPI eeproms use the 8th address bit embedded 			 * in the opcode 			 */
if|if
condition|(
operator|(
name|hw
operator|->
name|eeprom
operator|.
name|address_bits
operator|==
literal|8
operator|)
operator|&&
operator|(
operator|(
name|offset
operator|+
name|i
operator|)
operator|>=
literal|128
operator|)
condition|)
name|write_opcode
operator||=
name|IXGBE_EEPROM_A8_OPCODE_SPI
expr_stmt|;
comment|/* Send the Write command (8-bit opcode + addr) */
name|ixgbe_shift_out_eeprom_bits
argument_list|(
name|hw
argument_list|,
name|write_opcode
argument_list|,
name|IXGBE_EEPROM_OPCODE_BITS
argument_list|)
expr_stmt|;
name|ixgbe_shift_out_eeprom_bits
argument_list|(
name|hw
argument_list|,
call|(
name|u16
call|)
argument_list|(
operator|(
name|offset
operator|+
name|i
operator|)
operator|*
literal|2
argument_list|)
argument_list|,
name|hw
operator|->
name|eeprom
operator|.
name|address_bits
argument_list|)
expr_stmt|;
name|page_size
operator|=
name|hw
operator|->
name|eeprom
operator|.
name|word_page_size
expr_stmt|;
comment|/* Send the data in burst via SPI*/
do|do
block|{
name|word
operator|=
name|data
index|[
name|i
index|]
expr_stmt|;
name|word
operator|=
operator|(
name|word
operator|>>
literal|8
operator|)
operator||
operator|(
name|word
operator|<<
literal|8
operator|)
expr_stmt|;
name|ixgbe_shift_out_eeprom_bits
argument_list|(
name|hw
argument_list|,
name|word
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|page_size
operator|==
literal|0
condition|)
break|break;
comment|/* do not wrap around page */
if|if
condition|(
operator|(
operator|(
name|offset
operator|+
name|i
operator|)
operator|&
operator|(
name|page_size
operator|-
literal|1
operator|)
operator|)
operator|==
operator|(
name|page_size
operator|-
literal|1
operator|)
condition|)
break|break;
block|}
do|while
condition|(
operator|++
name|i
operator|<
name|words
condition|)
do|;
name|ixgbe_standby_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
comment|/* Done with writing - release the EEPROM */
name|ixgbe_release_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_write_eeprom_generic - Writes 16 bit value to EEPROM  *  @hw: pointer to hardware structure  *  @offset: offset within the EEPROM to be written to  *  @data: 16 bit word to be written to the EEPROM  *  *  If ixgbe_eeprom_update_checksum is not called after this function, the  *  EEPROM will most likely contain an invalid checksum.  **/
end_comment

begin_function
name|s32
name|ixgbe_write_eeprom_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
name|data
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_write_eeprom_generic"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|init_params
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
name|hw
operator|->
name|eeprom
operator|.
name|word_size
condition|)
block|{
name|status
operator|=
name|IXGBE_ERR_EEPROM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|status
operator|=
name|ixgbe_write_eeprom_buffer_bit_bang
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
literal|1
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_read_eeprom_buffer_bit_bang_generic - Read EEPROM using bit-bang  *  @hw: pointer to hardware structure  *  @offset: offset within the EEPROM to be read  *  @data: read 16 bit words(s) from EEPROM  *  @words: number of word(s)  *  *  Reads 16 bit word(s) from EEPROM through bit-bang method  **/
end_comment

begin_function
name|s32
name|ixgbe_read_eeprom_buffer_bit_bang_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
name|words
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u16
name|i
decl_stmt|,
name|count
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_read_eeprom_buffer_bit_bang_generic"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|init_params
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|words
operator|==
literal|0
condition|)
block|{
name|status
operator|=
name|IXGBE_ERR_INVALID_ARGUMENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|offset
operator|+
name|words
operator|>
name|hw
operator|->
name|eeprom
operator|.
name|word_size
condition|)
block|{
name|status
operator|=
name|IXGBE_ERR_EEPROM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * We cannot hold synchronization semaphores for too long 	 * to avoid other entity starvation. However it is more efficient 	 * to read in bursts than synchronizing access for each word. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|+=
name|IXGBE_EEPROM_RD_BUFFER_MAX_COUNT
control|)
block|{
name|count
operator|=
operator|(
name|words
operator|-
name|i
operator|)
operator|/
name|IXGBE_EEPROM_RD_BUFFER_MAX_COUNT
operator|>
literal|0
condition|?
name|IXGBE_EEPROM_RD_BUFFER_MAX_COUNT
else|:
operator|(
name|words
operator|-
name|i
operator|)
expr_stmt|;
name|status
operator|=
name|ixgbe_read_eeprom_buffer_bit_bang
argument_list|(
name|hw
argument_list|,
name|offset
operator|+
name|i
argument_list|,
name|count
argument_list|,
operator|&
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
break|break;
block|}
name|out
label|:
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_read_eeprom_buffer_bit_bang - Read EEPROM using bit-bang  *  @hw: pointer to hardware structure  *  @offset: offset within the EEPROM to be read  *  @words: number of word(s)  *  @data: read 16 bit word(s) from EEPROM  *  *  Reads 16 bit word(s) from EEPROM through bit-bang method  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_read_eeprom_buffer_bit_bang
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
name|words
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|u16
name|word_in
decl_stmt|;
name|u8
name|read_opcode
init|=
name|IXGBE_EEPROM_READ_OPCODE_SPI
decl_stmt|;
name|u16
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_read_eeprom_buffer_bit_bang"
argument_list|)
expr_stmt|;
comment|/* Prepare the EEPROM for reading  */
name|status
operator|=
name|ixgbe_acquire_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
condition|)
block|{
if|if
condition|(
name|ixgbe_ready_eeprom
argument_list|(
name|hw
argument_list|)
operator|!=
name|IXGBE_SUCCESS
condition|)
block|{
name|ixgbe_release_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|status
operator|=
name|IXGBE_ERR_EEPROM
expr_stmt|;
block|}
block|}
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|++
control|)
block|{
name|ixgbe_standby_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* 			 * Some SPI eeproms use the 8th address bit embedded 			 * in the opcode 			 */
if|if
condition|(
operator|(
name|hw
operator|->
name|eeprom
operator|.
name|address_bits
operator|==
literal|8
operator|)
operator|&&
operator|(
operator|(
name|offset
operator|+
name|i
operator|)
operator|>=
literal|128
operator|)
condition|)
name|read_opcode
operator||=
name|IXGBE_EEPROM_A8_OPCODE_SPI
expr_stmt|;
comment|/* Send the READ command (opcode + addr) */
name|ixgbe_shift_out_eeprom_bits
argument_list|(
name|hw
argument_list|,
name|read_opcode
argument_list|,
name|IXGBE_EEPROM_OPCODE_BITS
argument_list|)
expr_stmt|;
name|ixgbe_shift_out_eeprom_bits
argument_list|(
name|hw
argument_list|,
call|(
name|u16
call|)
argument_list|(
operator|(
name|offset
operator|+
name|i
operator|)
operator|*
literal|2
argument_list|)
argument_list|,
name|hw
operator|->
name|eeprom
operator|.
name|address_bits
argument_list|)
expr_stmt|;
comment|/* Read the data. */
name|word_in
operator|=
name|ixgbe_shift_in_eeprom_bits
argument_list|(
name|hw
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|data
index|[
name|i
index|]
operator|=
operator|(
name|word_in
operator|>>
literal|8
operator|)
operator||
operator|(
name|word_in
operator|<<
literal|8
operator|)
expr_stmt|;
block|}
comment|/* End this read operation */
name|ixgbe_release_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_read_eeprom_bit_bang_generic - Read EEPROM word using bit-bang  *  @hw: pointer to hardware structure  *  @offset: offset within the EEPROM to be read  *  @data: read 16 bit value from EEPROM  *  *  Reads 16 bit value from EEPROM through bit-bang method  **/
end_comment

begin_function
name|s32
name|ixgbe_read_eeprom_bit_bang_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_read_eeprom_bit_bang_generic"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|init_params
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
name|hw
operator|->
name|eeprom
operator|.
name|word_size
condition|)
block|{
name|status
operator|=
name|IXGBE_ERR_EEPROM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|status
operator|=
name|ixgbe_read_eeprom_buffer_bit_bang
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
literal|1
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_read_eerd_buffer_generic - Read EEPROM word(s) using EERD  *  @hw: pointer to hardware structure  *  @offset: offset of word in the EEPROM to read  *  @words: number of word(s)  *  @data: 16 bit word(s) from the EEPROM  *  *  Reads a 16 bit word(s) from the EEPROM using the EERD register.  **/
end_comment

begin_function
name|s32
name|ixgbe_read_eerd_buffer_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
name|words
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|u32
name|eerd
decl_stmt|;
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_read_eerd_buffer_generic"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|init_params
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|words
operator|==
literal|0
condition|)
block|{
name|status
operator|=
name|IXGBE_ERR_INVALID_ARGUMENT
expr_stmt|;
name|ERROR_REPORT1
argument_list|(
name|IXGBE_ERROR_ARGUMENT
argument_list|,
literal|"Invalid EEPROM words"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|offset
operator|>=
name|hw
operator|->
name|eeprom
operator|.
name|word_size
condition|)
block|{
name|status
operator|=
name|IXGBE_ERR_EEPROM
expr_stmt|;
name|ERROR_REPORT1
argument_list|(
name|IXGBE_ERROR_ARGUMENT
argument_list|,
literal|"Invalid EEPROM offset"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|++
control|)
block|{
name|eerd
operator|=
operator|(
operator|(
name|offset
operator|+
name|i
operator|)
operator|<<
name|IXGBE_EEPROM_RW_ADDR_SHIFT
operator|)
operator||
name|IXGBE_EEPROM_RW_REG_START
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EERD
argument_list|,
name|eerd
argument_list|)
expr_stmt|;
name|status
operator|=
name|ixgbe_poll_eerd_eewr_done
argument_list|(
name|hw
argument_list|,
name|IXGBE_NVM_POLL_READ
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
condition|)
block|{
name|data
index|[
name|i
index|]
operator|=
operator|(
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EERD
argument_list|)
operator|>>
name|IXGBE_EEPROM_RW_REG_DATA
operator|)
expr_stmt|;
block|}
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"Eeprom read timed out\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|out
label|:
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_detect_eeprom_page_size_generic - Detect EEPROM page size  *  @hw: pointer to hardware structure  *  @offset: offset within the EEPROM to be used as a scratch pad  *  *  Discover EEPROM page size by writing marching data at given offset.  *  This function is called only when we are writing a new large buffer  *  at given offset so the data would be overwritten anyway.  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_detect_eeprom_page_size_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|)
block|{
name|u16
name|data
index|[
name|IXGBE_EEPROM_PAGE_SIZE_MAX
index|]
decl_stmt|;
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u16
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_detect_eeprom_page_size_generic"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_EEPROM_PAGE_SIZE_MAX
condition|;
name|i
operator|++
control|)
name|data
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|hw
operator|->
name|eeprom
operator|.
name|word_page_size
operator|=
name|IXGBE_EEPROM_PAGE_SIZE_MAX
expr_stmt|;
name|status
operator|=
name|ixgbe_write_eeprom_buffer_bit_bang
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|IXGBE_EEPROM_PAGE_SIZE_MAX
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|hw
operator|->
name|eeprom
operator|.
name|word_page_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|out
goto|;
name|status
operator|=
name|ixgbe_read_eeprom_buffer_bit_bang
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
literal|1
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * When writing in burst more than the actual page size 	 * EEPROM address wraps around current page. 	 */
name|hw
operator|->
name|eeprom
operator|.
name|word_page_size
operator|=
name|IXGBE_EEPROM_PAGE_SIZE_MAX
operator|-
name|data
index|[
literal|0
index|]
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"Detected EEPROM page size = %d words."
argument_list|,
name|hw
operator|->
name|eeprom
operator|.
name|word_page_size
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_read_eerd_generic - Read EEPROM word using EERD  *  @hw: pointer to hardware structure  *  @offset: offset of  word in the EEPROM to read  *  @data: word read from the EEPROM  *  *  Reads a 16 bit word from the EEPROM using the EERD register.  **/
end_comment

begin_function
name|s32
name|ixgbe_read_eerd_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
return|return
name|ixgbe_read_eerd_buffer_generic
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
literal|1
argument_list|,
name|data
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_write_eewr_buffer_generic - Write EEPROM word(s) using EEWR  *  @hw: pointer to hardware structure  *  @offset: offset of  word in the EEPROM to write  *  @words: number of word(s)  *  @data: word(s) write to the EEPROM  *  *  Write a 16 bit word(s) to the EEPROM using the EEWR register.  **/
end_comment

begin_function
name|s32
name|ixgbe_write_eewr_buffer_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
name|words
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|u32
name|eewr
decl_stmt|;
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u16
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_write_eewr_generic"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|init_params
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|words
operator|==
literal|0
condition|)
block|{
name|status
operator|=
name|IXGBE_ERR_INVALID_ARGUMENT
expr_stmt|;
name|ERROR_REPORT1
argument_list|(
name|IXGBE_ERROR_ARGUMENT
argument_list|,
literal|"Invalid EEPROM words"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|offset
operator|>=
name|hw
operator|->
name|eeprom
operator|.
name|word_size
condition|)
block|{
name|status
operator|=
name|IXGBE_ERR_EEPROM
expr_stmt|;
name|ERROR_REPORT1
argument_list|(
name|IXGBE_ERROR_ARGUMENT
argument_list|,
literal|"Invalid EEPROM offset"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|++
control|)
block|{
name|eewr
operator|=
operator|(
operator|(
name|offset
operator|+
name|i
operator|)
operator|<<
name|IXGBE_EEPROM_RW_ADDR_SHIFT
operator|)
operator||
operator|(
name|data
index|[
name|i
index|]
operator|<<
name|IXGBE_EEPROM_RW_REG_DATA
operator|)
operator||
name|IXGBE_EEPROM_RW_REG_START
expr_stmt|;
name|status
operator|=
name|ixgbe_poll_eerd_eewr_done
argument_list|(
name|hw
argument_list|,
name|IXGBE_NVM_POLL_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Eeprom write EEWR timed out\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEWR
argument_list|,
name|eewr
argument_list|)
expr_stmt|;
name|status
operator|=
name|ixgbe_poll_eerd_eewr_done
argument_list|(
name|hw
argument_list|,
name|IXGBE_NVM_POLL_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Eeprom write EEWR timed out\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|out
label|:
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_write_eewr_generic - Write EEPROM word using EEWR  *  @hw: pointer to hardware structure  *  @offset: offset of  word in the EEPROM to write  *  @data: word write to the EEPROM  *  *  Write a 16 bit word to the EEPROM using the EEWR register.  **/
end_comment

begin_function
name|s32
name|ixgbe_write_eewr_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
name|data
parameter_list|)
block|{
return|return
name|ixgbe_write_eewr_buffer_generic
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
literal|1
argument_list|,
operator|&
name|data
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_poll_eerd_eewr_done - Poll EERD read or EEWR write status  *  @hw: pointer to hardware structure  *  @ee_reg: EEPROM flag for polling  *  *  Polls the status bit (bit 1) of the EERD or EEWR to determine when the  *  read or write is done respectively.  **/
end_comment

begin_function
name|s32
name|ixgbe_poll_eerd_eewr_done
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|ee_reg
parameter_list|)
block|{
name|u32
name|i
decl_stmt|;
name|u32
name|reg
decl_stmt|;
name|s32
name|status
init|=
name|IXGBE_ERR_EEPROM
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_poll_eerd_eewr_done"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_EERD_EEWR_ATTEMPTS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ee_reg
operator|==
name|IXGBE_NVM_POLL_READ
condition|)
name|reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EERD
argument_list|)
expr_stmt|;
else|else
name|reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|IXGBE_EEPROM_RW_REG_DONE
condition|)
block|{
name|status
operator|=
name|IXGBE_SUCCESS
expr_stmt|;
break|break;
block|}
name|usec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|IXGBE_EERD_EEWR_ATTEMPTS
condition|)
name|ERROR_REPORT1
argument_list|(
name|IXGBE_ERROR_POLLING
argument_list|,
literal|"EEPROM read/write done polling timed out"
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_acquire_eeprom - Acquire EEPROM using bit-bang  *  @hw: pointer to hardware structure  *  *  Prepares EEPROM for access using bit-bang method. This function should  *  be called before issuing a command to the EEPROM.  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_acquire_eeprom
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u32
name|eec
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_acquire_eeprom"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|acquire_swfw_sync
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR_EEP_SM
argument_list|)
operator|!=
name|IXGBE_SUCCESS
condition|)
name|status
operator|=
name|IXGBE_ERR_SWFW_SYNC
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
condition|)
block|{
name|eec
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC_BY_MAC
argument_list|(
name|hw
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Request EEPROM Access */
name|eec
operator||=
name|IXGBE_EEC_REQ
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC_BY_MAC
argument_list|(
name|hw
argument_list|)
argument_list|,
name|eec
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_EEPROM_GRANT_ATTEMPTS
condition|;
name|i
operator|++
control|)
block|{
name|eec
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC_BY_MAC
argument_list|(
name|hw
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|eec
operator|&
name|IXGBE_EEC_GNT
condition|)
break|break;
name|usec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
comment|/* Release if grant not acquired */
if|if
condition|(
operator|!
operator|(
name|eec
operator|&
name|IXGBE_EEC_GNT
operator|)
condition|)
block|{
name|eec
operator|&=
operator|~
name|IXGBE_EEC_REQ
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC_BY_MAC
argument_list|(
name|hw
argument_list|)
argument_list|,
name|eec
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Could not acquire EEPROM grant\n"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR_EEP_SM
argument_list|)
expr_stmt|;
name|status
operator|=
name|IXGBE_ERR_EEPROM
expr_stmt|;
block|}
comment|/* Setup EEPROM for Read/Write */
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
condition|)
block|{
comment|/* Clear CS and SK */
name|eec
operator|&=
operator|~
operator|(
name|IXGBE_EEC_CS
operator||
name|IXGBE_EEC_SK
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC_BY_MAC
argument_list|(
name|hw
argument_list|)
argument_list|,
name|eec
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_eeprom_semaphore - Get hardware semaphore  *  @hw: pointer to hardware structure  *  *  Sets the hardware semaphores so EEPROM access can occur for bit-bang method  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_get_eeprom_semaphore
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_ERR_EEPROM
decl_stmt|;
name|u32
name|timeout
init|=
literal|2000
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|u32
name|swsm
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_eeprom_semaphore"
argument_list|)
expr_stmt|;
comment|/* Get SMBI software semaphore between device drivers first */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|timeout
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * If the SMBI bit is 0 when we read it, then the bit will be 		 * set and we have the semaphore 		 */
name|swsm
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SWSM_BY_MAC
argument_list|(
name|hw
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|swsm
operator|&
name|IXGBE_SWSM_SMBI
operator|)
condition|)
block|{
name|status
operator|=
name|IXGBE_SUCCESS
expr_stmt|;
break|break;
block|}
name|usec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|timeout
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Driver can't access the Eeprom - SMBI Semaphore "
literal|"not granted.\n"
argument_list|)
expr_stmt|;
comment|/* 		 * this release is particularly important because our attempts 		 * above to get the semaphore may have succeeded, and if there 		 * was a timeout, we should unconditionally clear the semaphore 		 * bits to free the driver to make progress 		 */
name|ixgbe_release_eeprom_semaphore
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
comment|/* 		 * one last try 		 * If the SMBI bit is 0 when we read it, then the bit will be 		 * set and we have the semaphore 		 */
name|swsm
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SWSM_BY_MAC
argument_list|(
name|hw
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|swsm
operator|&
name|IXGBE_SWSM_SMBI
operator|)
condition|)
name|status
operator|=
name|IXGBE_SUCCESS
expr_stmt|;
block|}
comment|/* Now get the semaphore between SW/FW through the SWESMBI bit */
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|timeout
condition|;
name|i
operator|++
control|)
block|{
name|swsm
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SWSM_BY_MAC
argument_list|(
name|hw
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set the SW EEPROM semaphore bit to request access */
name|swsm
operator||=
name|IXGBE_SWSM_SWESMBI
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SWSM_BY_MAC
argument_list|(
name|hw
argument_list|)
argument_list|,
name|swsm
argument_list|)
expr_stmt|;
comment|/* 			 * If we set the bit successfully then we got the 			 * semaphore. 			 */
name|swsm
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SWSM_BY_MAC
argument_list|(
name|hw
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|swsm
operator|&
name|IXGBE_SWSM_SWESMBI
condition|)
break|break;
name|usec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Release semaphores and return error if SW EEPROM semaphore 		 * was not granted because we don't have access to the EEPROM 		 */
if|if
condition|(
name|i
operator|>=
name|timeout
condition|)
block|{
name|ERROR_REPORT1
argument_list|(
name|IXGBE_ERROR_POLLING
argument_list|,
literal|"SWESMBI Software EEPROM semaphore not granted.\n"
argument_list|)
expr_stmt|;
name|ixgbe_release_eeprom_semaphore
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|status
operator|=
name|IXGBE_ERR_EEPROM
expr_stmt|;
block|}
block|}
else|else
block|{
name|ERROR_REPORT1
argument_list|(
name|IXGBE_ERROR_POLLING
argument_list|,
literal|"Software semaphore SMBI between device drivers "
literal|"not granted.\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_release_eeprom_semaphore - Release hardware semaphore  *  @hw: pointer to hardware structure  *  *  This function clears hardware semaphore bits.  **/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_release_eeprom_semaphore
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|swsm
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_release_eeprom_semaphore"
argument_list|)
expr_stmt|;
name|swsm
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SWSM
argument_list|)
expr_stmt|;
comment|/* Release both semaphores by writing 0 to the bits SWESMBI and SMBI */
name|swsm
operator|&=
operator|~
operator|(
name|IXGBE_SWSM_SWESMBI
operator||
name|IXGBE_SWSM_SMBI
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SWSM
argument_list|,
name|swsm
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_ready_eeprom - Polls for EEPROM ready  *  @hw: pointer to hardware structure  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_ready_eeprom
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u16
name|i
decl_stmt|;
name|u8
name|spi_stat_reg
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_ready_eeprom"
argument_list|)
expr_stmt|;
comment|/* 	 * Read "Status Register" repeatedly until the LSB is cleared.  The 	 * EEPROM will signal that the command has been completed by clearing 	 * bit 0 of the internal status register.  If it's not cleared within 	 * 5 milliseconds, then error out. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_EEPROM_MAX_RETRY_SPI
condition|;
name|i
operator|+=
literal|5
control|)
block|{
name|ixgbe_shift_out_eeprom_bits
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEPROM_RDSR_OPCODE_SPI
argument_list|,
name|IXGBE_EEPROM_OPCODE_BITS
argument_list|)
expr_stmt|;
name|spi_stat_reg
operator|=
operator|(
name|u8
operator|)
name|ixgbe_shift_in_eeprom_bits
argument_list|(
name|hw
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|spi_stat_reg
operator|&
name|IXGBE_EEPROM_STATUS_RDY_SPI
operator|)
condition|)
break|break;
name|usec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|ixgbe_standby_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/* 	 * On some parts, SPI write time could vary from 0-20mSec on 3.3V 	 * devices (and only 0-5mSec on 5V devices) 	 */
if|if
condition|(
name|i
operator|>=
name|IXGBE_EEPROM_MAX_RETRY_SPI
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"SPI EEPROM Status error\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IXGBE_ERR_EEPROM
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_standby_eeprom - Returns EEPROM to a "standby" state  *  @hw: pointer to hardware structure  **/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_standby_eeprom
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|eec
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_standby_eeprom"
argument_list|)
expr_stmt|;
name|eec
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC_BY_MAC
argument_list|(
name|hw
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Toggle CS to flush commands */
name|eec
operator||=
name|IXGBE_EEC_CS
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC_BY_MAC
argument_list|(
name|hw
argument_list|)
argument_list|,
name|eec
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|eec
operator|&=
operator|~
name|IXGBE_EEC_CS
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC_BY_MAC
argument_list|(
name|hw
argument_list|)
argument_list|,
name|eec
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_shift_out_eeprom_bits - Shift data bits out to the EEPROM.  *  @hw: pointer to hardware structure  *  @data: data to send to the EEPROM  *  @count: number of bits to shift out  **/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_shift_out_eeprom_bits
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|data
parameter_list|,
name|u16
name|count
parameter_list|)
block|{
name|u32
name|eec
decl_stmt|;
name|u32
name|mask
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_shift_out_eeprom_bits"
argument_list|)
expr_stmt|;
name|eec
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC_BY_MAC
argument_list|(
name|hw
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Mask is used to shift "count" bits of "data" out to the EEPROM 	 * one bit at a time.  Determine the starting bit based on count 	 */
name|mask
operator|=
literal|0x01
operator|<<
operator|(
name|count
operator|-
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * A "1" is shifted out to the EEPROM by setting bit "DI" to a 		 * "1", and then raising and then lowering the clock (the SK 		 * bit controls the clock input to the EEPROM).  A "0" is 		 * shifted out to the EEPROM by setting "DI" to "0" and then 		 * raising and then lowering the clock. 		 */
if|if
condition|(
name|data
operator|&
name|mask
condition|)
name|eec
operator||=
name|IXGBE_EEC_DI
expr_stmt|;
else|else
name|eec
operator|&=
operator|~
name|IXGBE_EEC_DI
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC_BY_MAC
argument_list|(
name|hw
argument_list|)
argument_list|,
name|eec
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ixgbe_raise_eeprom_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|eec
argument_list|)
expr_stmt|;
name|ixgbe_lower_eeprom_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|eec
argument_list|)
expr_stmt|;
comment|/* 		 * Shift mask to signify next bit of data to shift in to the 		 * EEPROM 		 */
name|mask
operator|=
name|mask
operator|>>
literal|1
expr_stmt|;
block|}
empty_stmt|;
comment|/* We leave the "DI" bit set to "0" when we leave this routine. */
name|eec
operator|&=
operator|~
name|IXGBE_EEC_DI
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC_BY_MAC
argument_list|(
name|hw
argument_list|)
argument_list|,
name|eec
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_shift_in_eeprom_bits - Shift data bits in from the EEPROM  *  @hw: pointer to hardware structure  **/
end_comment

begin_function
specifier|static
name|u16
name|ixgbe_shift_in_eeprom_bits
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|count
parameter_list|)
block|{
name|u32
name|eec
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|u16
name|data
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_shift_in_eeprom_bits"
argument_list|)
expr_stmt|;
comment|/* 	 * In order to read a register from the EEPROM, we need to shift 	 * 'count' bits in from the EEPROM. Bits are "shifted in" by raising 	 * the clock input to the EEPROM (setting the SK bit), and then reading 	 * the value of the "DO" bit.  During this "shifting in" process the 	 * "DI" bit should always be clear. 	 */
name|eec
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC_BY_MAC
argument_list|(
name|hw
argument_list|)
argument_list|)
expr_stmt|;
name|eec
operator|&=
operator|~
operator|(
name|IXGBE_EEC_DO
operator||
name|IXGBE_EEC_DI
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|data
operator|=
name|data
operator|<<
literal|1
expr_stmt|;
name|ixgbe_raise_eeprom_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|eec
argument_list|)
expr_stmt|;
name|eec
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC_BY_MAC
argument_list|(
name|hw
argument_list|)
argument_list|)
expr_stmt|;
name|eec
operator|&=
operator|~
operator|(
name|IXGBE_EEC_DI
operator|)
expr_stmt|;
if|if
condition|(
name|eec
operator|&
name|IXGBE_EEC_DO
condition|)
name|data
operator||=
literal|1
expr_stmt|;
name|ixgbe_lower_eeprom_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|eec
argument_list|)
expr_stmt|;
block|}
return|return
name|data
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_raise_eeprom_clk - Raises the EEPROM's clock input.  *  @hw: pointer to hardware structure  *  @eec: EEC register's current value  **/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_raise_eeprom_clk
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|eec
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_raise_eeprom_clk"
argument_list|)
expr_stmt|;
comment|/* 	 * Raise the clock input to the EEPROM 	 * (setting the SK bit), then delay 	 */
operator|*
name|eec
operator|=
operator|*
name|eec
operator||
name|IXGBE_EEC_SK
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC_BY_MAC
argument_list|(
name|hw
argument_list|)
argument_list|,
operator|*
name|eec
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_lower_eeprom_clk - Lowers the EEPROM's clock input.  *  @hw: pointer to hardware structure  *  @eecd: EECD's current value  **/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_lower_eeprom_clk
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|eec
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_lower_eeprom_clk"
argument_list|)
expr_stmt|;
comment|/* 	 * Lower the clock input to the EEPROM (clearing the SK bit), then 	 * delay 	 */
operator|*
name|eec
operator|=
operator|*
name|eec
operator|&
operator|~
name|IXGBE_EEC_SK
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC_BY_MAC
argument_list|(
name|hw
argument_list|)
argument_list|,
operator|*
name|eec
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_release_eeprom - Release EEPROM, release semaphores  *  @hw: pointer to hardware structure  **/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_release_eeprom
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|eec
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_release_eeprom"
argument_list|)
expr_stmt|;
name|eec
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC_BY_MAC
argument_list|(
name|hw
argument_list|)
argument_list|)
expr_stmt|;
name|eec
operator||=
name|IXGBE_EEC_CS
expr_stmt|;
comment|/* Pull CS high */
name|eec
operator|&=
operator|~
name|IXGBE_EEC_SK
expr_stmt|;
comment|/* Lower SCK */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC_BY_MAC
argument_list|(
name|hw
argument_list|)
argument_list|,
name|eec
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Stop requesting EEPROM access */
name|eec
operator|&=
operator|~
name|IXGBE_EEC_REQ
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC_BY_MAC
argument_list|(
name|hw
argument_list|)
argument_list|,
name|eec
argument_list|)
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR_EEP_SM
argument_list|)
expr_stmt|;
comment|/* Delay before attempt to obtain semaphore again to allow FW access */
name|msec_delay
argument_list|(
name|hw
operator|->
name|eeprom
operator|.
name|semaphore_delay
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_calc_eeprom_checksum_generic - Calculates and returns the checksum  *  @hw: pointer to hardware structure  *  *  Returns a negative error code on error, or the 16-bit checksum  **/
end_comment

begin_function
name|s32
name|ixgbe_calc_eeprom_checksum_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u16
name|i
decl_stmt|;
name|u16
name|j
decl_stmt|;
name|u16
name|checksum
init|=
literal|0
decl_stmt|;
name|u16
name|length
init|=
literal|0
decl_stmt|;
name|u16
name|pointer
init|=
literal|0
decl_stmt|;
name|u16
name|word
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_calc_eeprom_checksum_generic"
argument_list|)
expr_stmt|;
comment|/* Include 0x0-0x3F in the checksum */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_EEPROM_CHECKSUM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|i
argument_list|,
operator|&
name|word
argument_list|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM read failed\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_EEPROM
return|;
block|}
name|checksum
operator|+=
name|word
expr_stmt|;
block|}
comment|/* Include all data from pointers except for the fw pointer */
for|for
control|(
name|i
operator|=
name|IXGBE_PCIE_ANALOG_PTR
init|;
name|i
operator|<
name|IXGBE_FW_PTR
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|i
argument_list|,
operator|&
name|pointer
argument_list|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM read failed\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_EEPROM
return|;
block|}
comment|/* If the pointer seems invalid */
if|if
condition|(
name|pointer
operator|==
literal|0xFFFF
operator|||
name|pointer
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|pointer
argument_list|,
operator|&
name|length
argument_list|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM read failed\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_EEPROM
return|;
block|}
if|if
condition|(
name|length
operator|==
literal|0xFFFF
operator|||
name|length
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
name|pointer
operator|+
literal|1
init|;
name|j
operator|<=
name|pointer
operator|+
name|length
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|j
argument_list|,
operator|&
name|word
argument_list|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM read failed\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_EEPROM
return|;
block|}
name|checksum
operator|+=
name|word
expr_stmt|;
block|}
block|}
name|checksum
operator|=
operator|(
name|u16
operator|)
name|IXGBE_EEPROM_SUM
operator|-
name|checksum
expr_stmt|;
return|return
operator|(
name|s32
operator|)
name|checksum
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_validate_eeprom_checksum_generic - Validate EEPROM checksum  *  @hw: pointer to hardware structure  *  @checksum_val: calculated checksum  *  *  Performs checksum calculation and validates the EEPROM checksum.  If the  *  caller does not need checksum_val, the value can be NULL.  **/
end_comment

begin_function
name|s32
name|ixgbe_validate_eeprom_checksum_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|checksum_val
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|u16
name|checksum
decl_stmt|;
name|u16
name|read_checksum
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_validate_eeprom_checksum_generic"
argument_list|)
expr_stmt|;
comment|/* Read the first word from the EEPROM. If this times out or fails, do 	 * not continue or we could be in for a very long wait while every 	 * EEPROM read fails 	 */
name|status
operator|=
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
literal|0
argument_list|,
operator|&
name|checksum
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM read failed\n"
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
name|status
operator|=
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|calc_checksum
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
condition|)
return|return
name|status
return|;
name|checksum
operator|=
call|(
name|u16
call|)
argument_list|(
name|status
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|status
operator|=
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEPROM_CHECKSUM
argument_list|,
operator|&
name|read_checksum
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM read failed\n"
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
comment|/* Verify read checksum from EEPROM is the same as 	 * calculated checksum 	 */
if|if
condition|(
name|read_checksum
operator|!=
name|checksum
condition|)
name|status
operator|=
name|IXGBE_ERR_EEPROM_CHECKSUM
expr_stmt|;
comment|/* If the user cares, return the calculated checksum */
if|if
condition|(
name|checksum_val
condition|)
operator|*
name|checksum_val
operator|=
name|checksum
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_update_eeprom_checksum_generic - Updates the EEPROM checksum  *  @hw: pointer to hardware structure  **/
end_comment

begin_function
name|s32
name|ixgbe_update_eeprom_checksum_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|u16
name|checksum
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_update_eeprom_checksum_generic"
argument_list|)
expr_stmt|;
comment|/* Read the first word from the EEPROM. If this times out or fails, do 	 * not continue or we could be in for a very long wait while every 	 * EEPROM read fails 	 */
name|status
operator|=
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
literal|0
argument_list|,
operator|&
name|checksum
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM read failed\n"
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
name|status
operator|=
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|calc_checksum
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
condition|)
return|return
name|status
return|;
name|checksum
operator|=
call|(
name|u16
call|)
argument_list|(
name|status
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|status
operator|=
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|write
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEPROM_CHECKSUM
argument_list|,
name|checksum
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_validate_mac_addr - Validate MAC address  *  @mac_addr: pointer to MAC address.  *  *  Tests a MAC address to ensure it is a valid Individual Address.  **/
end_comment

begin_function
name|s32
name|ixgbe_validate_mac_addr
parameter_list|(
name|u8
modifier|*
name|mac_addr
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_validate_mac_addr"
argument_list|)
expr_stmt|;
comment|/* Make sure it is not a multicast address */
if|if
condition|(
name|IXGBE_IS_MULTICAST
argument_list|(
name|mac_addr
argument_list|)
condition|)
block|{
name|status
operator|=
name|IXGBE_ERR_INVALID_MAC_ADDR
expr_stmt|;
comment|/* Not a broadcast address */
block|}
elseif|else
if|if
condition|(
name|IXGBE_IS_BROADCAST
argument_list|(
name|mac_addr
argument_list|)
condition|)
block|{
name|status
operator|=
name|IXGBE_ERR_INVALID_MAC_ADDR
expr_stmt|;
comment|/* Reject the zero address */
block|}
elseif|else
if|if
condition|(
name|mac_addr
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|mac_addr
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|mac_addr
index|[
literal|2
index|]
operator|==
literal|0
operator|&&
name|mac_addr
index|[
literal|3
index|]
operator|==
literal|0
operator|&&
name|mac_addr
index|[
literal|4
index|]
operator|==
literal|0
operator|&&
name|mac_addr
index|[
literal|5
index|]
operator|==
literal|0
condition|)
block|{
name|status
operator|=
name|IXGBE_ERR_INVALID_MAC_ADDR
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_set_rar_generic - Set Rx address register  *  @hw: pointer to hardware structure  *  @index: Receive address register to write  *  @addr: Address to put into receive address register  *  @vmdq: VMDq "set" or "pool" index  *  @enable_addr: set flag that address is active  *  *  Puts an ethernet address into a receive address register.  **/
end_comment

begin_function
name|s32
name|ixgbe_set_rar_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|index
parameter_list|,
name|u8
modifier|*
name|addr
parameter_list|,
name|u32
name|vmdq
parameter_list|,
name|u32
name|enable_addr
parameter_list|)
block|{
name|u32
name|rar_low
decl_stmt|,
name|rar_high
decl_stmt|;
name|u32
name|rar_entries
init|=
name|hw
operator|->
name|mac
operator|.
name|num_rar_entries
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_set_rar_generic"
argument_list|)
expr_stmt|;
comment|/* Make sure we are using a valid rar index range */
if|if
condition|(
name|index
operator|>=
name|rar_entries
condition|)
block|{
name|ERROR_REPORT2
argument_list|(
name|IXGBE_ERROR_ARGUMENT
argument_list|,
literal|"RAR index %d is out of range.\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_INVALID_ARGUMENT
return|;
block|}
comment|/* setup VMDq pool selection before this RAR gets enabled */
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|set_vmdq
argument_list|(
name|hw
argument_list|,
name|index
argument_list|,
name|vmdq
argument_list|)
expr_stmt|;
comment|/* 	 * HW expects these in little endian so we reverse the byte 	 * order from network order (big endian) to little endian 	 */
name|rar_low
operator|=
operator|(
operator|(
name|u32
operator|)
name|addr
index|[
literal|0
index|]
operator||
operator|(
operator|(
name|u32
operator|)
name|addr
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|u32
operator|)
name|addr
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|u32
operator|)
name|addr
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
operator|)
expr_stmt|;
comment|/* 	 * Some parts put the VMDq setting in the extra RAH bits, 	 * so save everything except the lower 16 bits that hold part 	 * of the address and the address valid bit. 	 */
name|rar_high
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RAH
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|rar_high
operator|&=
operator|~
operator|(
literal|0x0000FFFF
operator||
name|IXGBE_RAH_AV
operator|)
expr_stmt|;
name|rar_high
operator||=
operator|(
operator|(
name|u32
operator|)
name|addr
index|[
literal|4
index|]
operator||
operator|(
operator|(
name|u32
operator|)
name|addr
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|enable_addr
operator|!=
literal|0
condition|)
name|rar_high
operator||=
name|IXGBE_RAH_AV
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RAL
argument_list|(
name|index
argument_list|)
argument_list|,
name|rar_low
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RAH
argument_list|(
name|index
argument_list|)
argument_list|,
name|rar_high
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_clear_rar_generic - Remove Rx address register  *  @hw: pointer to hardware structure  *  @index: Receive address register to write  *  *  Clears an ethernet address from a receive address register.  **/
end_comment

begin_function
name|s32
name|ixgbe_clear_rar_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|index
parameter_list|)
block|{
name|u32
name|rar_high
decl_stmt|;
name|u32
name|rar_entries
init|=
name|hw
operator|->
name|mac
operator|.
name|num_rar_entries
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_clear_rar_generic"
argument_list|)
expr_stmt|;
comment|/* Make sure we are using a valid rar index range */
if|if
condition|(
name|index
operator|>=
name|rar_entries
condition|)
block|{
name|ERROR_REPORT2
argument_list|(
name|IXGBE_ERROR_ARGUMENT
argument_list|,
literal|"RAR index %d is out of range.\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_INVALID_ARGUMENT
return|;
block|}
comment|/* 	 * Some parts put the VMDq setting in the extra RAH bits, 	 * so save everything except the lower 16 bits that hold part 	 * of the address and the address valid bit. 	 */
name|rar_high
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RAH
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|rar_high
operator|&=
operator|~
operator|(
literal|0x0000FFFF
operator||
name|IXGBE_RAH_AV
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RAL
argument_list|(
name|index
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RAH
argument_list|(
name|index
argument_list|)
argument_list|,
name|rar_high
argument_list|)
expr_stmt|;
comment|/* clear VMDq pool/queue selection for this RAR */
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|clear_vmdq
argument_list|(
name|hw
argument_list|,
name|index
argument_list|,
name|IXGBE_CLEAR_VMDQ_ALL
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_init_rx_addrs_generic - Initializes receive address filters.  *  @hw: pointer to hardware structure  *  *  Places the MAC address in receive address register 0 and clears the rest  *  of the receive address registers. Clears the multicast table. Assumes  *  the receiver is in reset when the routine is called.  **/
end_comment

begin_function
name|s32
name|ixgbe_init_rx_addrs_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|i
decl_stmt|;
name|u32
name|rar_entries
init|=
name|hw
operator|->
name|mac
operator|.
name|num_rar_entries
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_init_rx_addrs_generic"
argument_list|)
expr_stmt|;
comment|/* 	 * If the current mac address is valid, assume it is a software override 	 * to the permanent address. 	 * Otherwise, use the permanent address from the eeprom. 	 */
if|if
condition|(
name|ixgbe_validate_mac_addr
argument_list|(
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|)
operator|==
name|IXGBE_ERR_INVALID_MAC_ADDR
condition|)
block|{
comment|/* Get the MAC address from the RAR0 for later reference */
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|get_mac_addr
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|)
expr_stmt|;
name|DEBUGOUT3
argument_list|(
literal|" Keeping Current RAR0 Addr =%.2X %.2X %.2X "
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
index|[
literal|0
index|]
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
index|[
literal|1
index|]
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|DEBUGOUT3
argument_list|(
literal|"%.2X %.2X %.2X\n"
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
index|[
literal|3
index|]
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
index|[
literal|4
index|]
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Setup the receive address. */
name|DEBUGOUT
argument_list|(
literal|"Overriding MAC Address in RAR[0]\n"
argument_list|)
expr_stmt|;
name|DEBUGOUT3
argument_list|(
literal|" New MAC Addr =%.2X %.2X %.2X "
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
index|[
literal|0
index|]
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
index|[
literal|1
index|]
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|DEBUGOUT3
argument_list|(
literal|"%.2X %.2X %.2X\n"
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
index|[
literal|3
index|]
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
index|[
literal|4
index|]
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|set_rar
argument_list|(
name|hw
argument_list|,
literal|0
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|,
literal|0
argument_list|,
name|IXGBE_RAH_AV
argument_list|)
expr_stmt|;
block|}
comment|/* clear VMDq pool/queue selection for RAR 0 */
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|clear_vmdq
argument_list|(
name|hw
argument_list|,
literal|0
argument_list|,
name|IXGBE_CLEAR_VMDQ_ALL
argument_list|)
expr_stmt|;
name|hw
operator|->
name|addr_ctrl
operator|.
name|overflow_promisc
operator|=
literal|0
expr_stmt|;
name|hw
operator|->
name|addr_ctrl
operator|.
name|rar_used_count
operator|=
literal|1
expr_stmt|;
comment|/* Zero out the other receive addresses. */
name|DEBUGOUT1
argument_list|(
literal|"Clearing RAR[1-%d]\n"
argument_list|,
name|rar_entries
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|rar_entries
condition|;
name|i
operator|++
control|)
block|{
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RAL
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RAH
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Clear the MTA */
name|hw
operator|->
name|addr_ctrl
operator|.
name|mta_in_use
operator|=
literal|0
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MCSTCTRL
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|mc_filter_type
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|" Clearing MTA\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hw
operator|->
name|mac
operator|.
name|mcft_size
condition|;
name|i
operator|++
control|)
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MTA
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ixgbe_init_uta_tables
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_add_uc_addr - Adds a secondary unicast address.  *  @hw: pointer to hardware structure  *  @addr: new address  *  *  Adds it to unused receive address register or goes into promiscuous mode.  **/
end_comment

begin_function
name|void
name|ixgbe_add_uc_addr
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|addr
parameter_list|,
name|u32
name|vmdq
parameter_list|)
block|{
name|u32
name|rar_entries
init|=
name|hw
operator|->
name|mac
operator|.
name|num_rar_entries
decl_stmt|;
name|u32
name|rar
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_add_uc_addr"
argument_list|)
expr_stmt|;
name|DEBUGOUT6
argument_list|(
literal|" UC Addr = %.2X %.2X %.2X %.2X %.2X %.2X\n"
argument_list|,
name|addr
index|[
literal|0
index|]
argument_list|,
name|addr
index|[
literal|1
index|]
argument_list|,
name|addr
index|[
literal|2
index|]
argument_list|,
name|addr
index|[
literal|3
index|]
argument_list|,
name|addr
index|[
literal|4
index|]
argument_list|,
name|addr
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Place this address in the RAR if there is room, 	 * else put the controller into promiscuous mode 	 */
if|if
condition|(
name|hw
operator|->
name|addr_ctrl
operator|.
name|rar_used_count
operator|<
name|rar_entries
condition|)
block|{
name|rar
operator|=
name|hw
operator|->
name|addr_ctrl
operator|.
name|rar_used_count
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|set_rar
argument_list|(
name|hw
argument_list|,
name|rar
argument_list|,
name|addr
argument_list|,
name|vmdq
argument_list|,
name|IXGBE_RAH_AV
argument_list|)
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"Added a secondary address to RAR[%d]\n"
argument_list|,
name|rar
argument_list|)
expr_stmt|;
name|hw
operator|->
name|addr_ctrl
operator|.
name|rar_used_count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|hw
operator|->
name|addr_ctrl
operator|.
name|overflow_promisc
operator|++
expr_stmt|;
block|}
name|DEBUGOUT
argument_list|(
literal|"ixgbe_add_uc_addr Complete\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_update_uc_addr_list_generic - Updates MAC list of secondary addresses  *  @hw: pointer to hardware structure  *  @addr_list: the list of new addresses  *  @addr_count: number of addresses  *  @next: iterator function to walk the address list  *  *  The given list replaces any existing list.  Clears the secondary addrs from  *  receive address registers.  Uses unused receive address registers for the  *  first secondary addresses, and falls back to promiscuous mode as needed.  *  *  Drivers using secondary unicast addresses must set user_set_promisc when  *  manually putting the device into promiscuous mode.  **/
end_comment

begin_function
name|s32
name|ixgbe_update_uc_addr_list_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|addr_list
parameter_list|,
name|u32
name|addr_count
parameter_list|,
name|ixgbe_mc_addr_itr
name|next
parameter_list|)
block|{
name|u8
modifier|*
name|addr
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|u32
name|old_promisc_setting
init|=
name|hw
operator|->
name|addr_ctrl
operator|.
name|overflow_promisc
decl_stmt|;
name|u32
name|uc_addr_in_use
decl_stmt|;
name|u32
name|fctrl
decl_stmt|;
name|u32
name|vmdq
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_update_uc_addr_list_generic"
argument_list|)
expr_stmt|;
comment|/* 	 * Clear accounting of old secondary address list, 	 * don't count RAR[0] 	 */
name|uc_addr_in_use
operator|=
name|hw
operator|->
name|addr_ctrl
operator|.
name|rar_used_count
operator|-
literal|1
expr_stmt|;
name|hw
operator|->
name|addr_ctrl
operator|.
name|rar_used_count
operator|-=
name|uc_addr_in_use
expr_stmt|;
name|hw
operator|->
name|addr_ctrl
operator|.
name|overflow_promisc
operator|=
literal|0
expr_stmt|;
comment|/* Zero out the other receive addresses */
name|DEBUGOUT1
argument_list|(
literal|"Clearing RAR[1-%d]\n"
argument_list|,
name|uc_addr_in_use
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|uc_addr_in_use
condition|;
name|i
operator|++
control|)
block|{
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RAL
argument_list|(
literal|1
operator|+
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RAH
argument_list|(
literal|1
operator|+
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Add the new addresses */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|addr_count
condition|;
name|i
operator|++
control|)
block|{
name|DEBUGOUT
argument_list|(
literal|" Adding the secondary addresses:\n"
argument_list|)
expr_stmt|;
name|addr
operator|=
name|next
argument_list|(
name|hw
argument_list|,
operator|&
name|addr_list
argument_list|,
operator|&
name|vmdq
argument_list|)
expr_stmt|;
name|ixgbe_add_uc_addr
argument_list|(
name|hw
argument_list|,
name|addr
argument_list|,
name|vmdq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hw
operator|->
name|addr_ctrl
operator|.
name|overflow_promisc
condition|)
block|{
comment|/* enable promisc if not already in overflow or set by user */
if|if
condition|(
operator|!
name|old_promisc_setting
operator|&&
operator|!
name|hw
operator|->
name|addr_ctrl
operator|.
name|user_set_promisc
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|" Entering address overflow promisc mode\n"
argument_list|)
expr_stmt|;
name|fctrl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCTRL
argument_list|)
expr_stmt|;
name|fctrl
operator||=
name|IXGBE_FCTRL_UPE
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCTRL
argument_list|,
name|fctrl
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* only disable if set by overflow, not by user */
if|if
condition|(
name|old_promisc_setting
operator|&&
operator|!
name|hw
operator|->
name|addr_ctrl
operator|.
name|user_set_promisc
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|" Leaving address overflow promisc mode\n"
argument_list|)
expr_stmt|;
name|fctrl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCTRL
argument_list|)
expr_stmt|;
name|fctrl
operator|&=
operator|~
name|IXGBE_FCTRL_UPE
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCTRL
argument_list|,
name|fctrl
argument_list|)
expr_stmt|;
block|}
block|}
name|DEBUGOUT
argument_list|(
literal|"ixgbe_update_uc_addr_list_generic Complete\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_mta_vector - Determines bit-vector in multicast table to set  *  @hw: pointer to hardware structure  *  @mc_addr: the multicast address  *  *  Extracts the 12 bits, from a multicast address, to determine which  *  bit-vector to set in the multicast table. The hardware uses 12 bits, from  *  incoming rx multicast addresses, to determine the bit-vector to check in  *  the MTA. Which of the 4 combination, of 12-bits, the hardware uses is set  *  by the MO field of the MCSTCTRL. The MO field is set during initialization  *  to mc_filter_type.  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_mta_vector
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|mc_addr
parameter_list|)
block|{
name|u32
name|vector
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_mta_vector"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|mc_filter_type
condition|)
block|{
case|case
literal|0
case|:
comment|/* use bits [47:36] of the address */
name|vector
operator|=
operator|(
operator|(
name|mc_addr
index|[
literal|4
index|]
operator|>>
literal|4
operator|)
operator||
operator|(
operator|(
operator|(
name|u16
operator|)
name|mc_addr
index|[
literal|5
index|]
operator|)
operator|<<
literal|4
operator|)
operator|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* use bits [46:35] of the address */
name|vector
operator|=
operator|(
operator|(
name|mc_addr
index|[
literal|4
index|]
operator|>>
literal|3
operator|)
operator||
operator|(
operator|(
operator|(
name|u16
operator|)
name|mc_addr
index|[
literal|5
index|]
operator|)
operator|<<
literal|5
operator|)
operator|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* use bits [45:34] of the address */
name|vector
operator|=
operator|(
operator|(
name|mc_addr
index|[
literal|4
index|]
operator|>>
literal|2
operator|)
operator||
operator|(
operator|(
operator|(
name|u16
operator|)
name|mc_addr
index|[
literal|5
index|]
operator|)
operator|<<
literal|6
operator|)
operator|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* use bits [43:32] of the address */
name|vector
operator|=
operator|(
operator|(
name|mc_addr
index|[
literal|4
index|]
operator|)
operator||
operator|(
operator|(
operator|(
name|u16
operator|)
name|mc_addr
index|[
literal|5
index|]
operator|)
operator|<<
literal|8
operator|)
operator|)
expr_stmt|;
break|break;
default|default:
comment|/* Invalid mc_filter_type */
name|DEBUGOUT
argument_list|(
literal|"MC filter type param set incorrectly\n"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* vector can only be 12-bits or boundary will be exceeded */
name|vector
operator|&=
literal|0xFFF
expr_stmt|;
return|return
name|vector
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_set_mta - Set bit-vector in multicast table  *  @hw: pointer to hardware structure  *  @hash_value: Multicast address hash value  *  *  Sets the bit-vector in the multicast table.  **/
end_comment

begin_function
name|void
name|ixgbe_set_mta
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|mc_addr
parameter_list|)
block|{
name|u32
name|vector
decl_stmt|;
name|u32
name|vector_bit
decl_stmt|;
name|u32
name|vector_reg
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_set_mta"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|addr_ctrl
operator|.
name|mta_in_use
operator|++
expr_stmt|;
name|vector
operator|=
name|ixgbe_mta_vector
argument_list|(
name|hw
argument_list|,
name|mc_addr
argument_list|)
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|" bit-vector = 0x%03X\n"
argument_list|,
name|vector
argument_list|)
expr_stmt|;
comment|/* 	 * The MTA is a register array of 128 32-bit registers. It is treated 	 * like an array of 4096 bits.  We want to set bit 	 * BitArray[vector_value]. So we figure out what register the bit is 	 * in, read it, OR in the new bit, then write back the new value.  The 	 * register is determined by the upper 7 bits of the vector value and 	 * the bit within that register are determined by the lower 5 bits of 	 * the value. 	 */
name|vector_reg
operator|=
operator|(
name|vector
operator|>>
literal|5
operator|)
operator|&
literal|0x7F
expr_stmt|;
name|vector_bit
operator|=
name|vector
operator|&
literal|0x1F
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|mta_shadow
index|[
name|vector_reg
index|]
operator||=
operator|(
literal|1
operator|<<
name|vector_bit
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_update_mc_addr_list_generic - Updates MAC list of multicast addresses  *  @hw: pointer to hardware structure  *  @mc_addr_list: the list of new multicast addresses  *  @mc_addr_count: number of addresses  *  @next: iterator function to walk the multicast address list  *  @clear: flag, when set clears the table beforehand  *  *  When the clear flag is set, the given list replaces any existing list.  *  Hashes the given addresses into the multicast table.  **/
end_comment

begin_function
name|s32
name|ixgbe_update_mc_addr_list_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|mc_addr_list
parameter_list|,
name|u32
name|mc_addr_count
parameter_list|,
name|ixgbe_mc_addr_itr
name|next
parameter_list|,
name|bool
name|clear
parameter_list|)
block|{
name|u32
name|i
decl_stmt|;
name|u32
name|vmdq
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_update_mc_addr_list_generic"
argument_list|)
expr_stmt|;
comment|/* 	 * Set the new number of MC addresses that we are being requested to 	 * use. 	 */
name|hw
operator|->
name|addr_ctrl
operator|.
name|num_mc_addrs
operator|=
name|mc_addr_count
expr_stmt|;
name|hw
operator|->
name|addr_ctrl
operator|.
name|mta_in_use
operator|=
literal|0
expr_stmt|;
comment|/* Clear mta_shadow */
if|if
condition|(
name|clear
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|" Clearing MTA\n"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|hw
operator|->
name|mac
operator|.
name|mta_shadow
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hw
operator|->
name|mac
operator|.
name|mta_shadow
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Update mta_shadow */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mc_addr_count
condition|;
name|i
operator|++
control|)
block|{
name|DEBUGOUT
argument_list|(
literal|" Adding the multicast addresses:\n"
argument_list|)
expr_stmt|;
name|ixgbe_set_mta
argument_list|(
name|hw
argument_list|,
name|next
argument_list|(
name|hw
argument_list|,
operator|&
name|mc_addr_list
argument_list|,
operator|&
name|vmdq
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Enable mta */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hw
operator|->
name|mac
operator|.
name|mcft_size
condition|;
name|i
operator|++
control|)
name|IXGBE_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|IXGBE_MTA
argument_list|(
literal|0
argument_list|)
argument_list|,
name|i
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|mta_shadow
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|addr_ctrl
operator|.
name|mta_in_use
operator|>
literal|0
condition|)
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MCSTCTRL
argument_list|,
name|IXGBE_MCSTCTRL_MFE
operator||
name|hw
operator|->
name|mac
operator|.
name|mc_filter_type
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"ixgbe_update_mc_addr_list_generic Complete\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_enable_mc_generic - Enable multicast address in RAR  *  @hw: pointer to hardware structure  *  *  Enables multicast address in RAR and the use of the multicast hash table.  **/
end_comment

begin_function
name|s32
name|ixgbe_enable_mc_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|ixgbe_addr_filter_info
modifier|*
name|a
init|=
operator|&
name|hw
operator|->
name|addr_ctrl
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_enable_mc_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|mta_in_use
operator|>
literal|0
condition|)
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MCSTCTRL
argument_list|,
name|IXGBE_MCSTCTRL_MFE
operator||
name|hw
operator|->
name|mac
operator|.
name|mc_filter_type
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_disable_mc_generic - Disable multicast address in RAR  *  @hw: pointer to hardware structure  *  *  Disables multicast address in RAR and the use of the multicast hash table.  **/
end_comment

begin_function
name|s32
name|ixgbe_disable_mc_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|ixgbe_addr_filter_info
modifier|*
name|a
init|=
operator|&
name|hw
operator|->
name|addr_ctrl
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_disable_mc_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|mta_in_use
operator|>
literal|0
condition|)
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MCSTCTRL
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|mc_filter_type
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_fc_enable_generic - Enable flow control  *  @hw: pointer to hardware structure  *  *  Enable flow control according to the current settings.  **/
end_comment

begin_function
name|s32
name|ixgbe_fc_enable_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u32
name|mflcn_reg
decl_stmt|,
name|fccfg_reg
decl_stmt|;
name|u32
name|reg
decl_stmt|;
name|u32
name|fcrtl
decl_stmt|,
name|fcrth
decl_stmt|;
name|int
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_fc_enable_generic"
argument_list|)
expr_stmt|;
comment|/* Validate the water mark configuration */
if|if
condition|(
operator|!
name|hw
operator|->
name|fc
operator|.
name|pause_time
condition|)
block|{
name|ret_val
operator|=
name|IXGBE_ERR_INVALID_LINK_SETTINGS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Low water mark of zero causes XOFF floods */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_DCB_MAX_TRAFFIC_CLASS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|hw
operator|->
name|fc
operator|.
name|current_mode
operator|&
name|ixgbe_fc_tx_pause
operator|)
operator|&&
name|hw
operator|->
name|fc
operator|.
name|high_water
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
operator|!
name|hw
operator|->
name|fc
operator|.
name|low_water
index|[
name|i
index|]
operator|||
name|hw
operator|->
name|fc
operator|.
name|low_water
index|[
name|i
index|]
operator|>=
name|hw
operator|->
name|fc
operator|.
name|high_water
index|[
name|i
index|]
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Invalid water mark configuration\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|IXGBE_ERR_INVALID_LINK_SETTINGS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
block|}
comment|/* Negotiate the fc mode to use */
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|fc_autoneg
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Disable any previous flow control settings */
name|mflcn_reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MFLCN
argument_list|)
expr_stmt|;
name|mflcn_reg
operator|&=
operator|~
operator|(
name|IXGBE_MFLCN_RPFCE_MASK
operator||
name|IXGBE_MFLCN_RFCE
operator|)
expr_stmt|;
name|fccfg_reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCCFG
argument_list|)
expr_stmt|;
name|fccfg_reg
operator|&=
operator|~
operator|(
name|IXGBE_FCCFG_TFCE_802_3X
operator||
name|IXGBE_FCCFG_TFCE_PRIORITY
operator|)
expr_stmt|;
comment|/* 	 * The possible values of fc.current_mode are: 	 * 0: Flow control is completely disabled 	 * 1: Rx flow control is enabled (we can receive pause frames, 	 *    but not send pause frames). 	 * 2: Tx flow control is enabled (we can send pause frames but 	 *    we do not support receiving pause frames). 	 * 3: Both Rx and Tx flow control (symmetric) are enabled. 	 * other: Invalid. 	 */
switch|switch
condition|(
name|hw
operator|->
name|fc
operator|.
name|current_mode
condition|)
block|{
case|case
name|ixgbe_fc_none
case|:
comment|/* 		 * Flow control is disabled by software override or autoneg. 		 * The code below will actually disable it in the HW. 		 */
break|break;
case|case
name|ixgbe_fc_rx_pause
case|:
comment|/* 		 * Rx Flow control is enabled and Tx Flow control is 		 * disabled by software override. Since there really 		 * isn't a way to advertise that we are capable of RX 		 * Pause ONLY, we will advertise that we support both 		 * symmetric and asymmetric Rx PAUSE.  Later, we will 		 * disable the adapter's ability to send PAUSE frames. 		 */
name|mflcn_reg
operator||=
name|IXGBE_MFLCN_RFCE
expr_stmt|;
break|break;
case|case
name|ixgbe_fc_tx_pause
case|:
comment|/* 		 * Tx Flow control is enabled, and Rx Flow control is 		 * disabled by software override. 		 */
name|fccfg_reg
operator||=
name|IXGBE_FCCFG_TFCE_802_3X
expr_stmt|;
break|break;
case|case
name|ixgbe_fc_full
case|:
comment|/* Flow control (both Rx and Tx) is enabled by SW override. */
name|mflcn_reg
operator||=
name|IXGBE_MFLCN_RFCE
expr_stmt|;
name|fccfg_reg
operator||=
name|IXGBE_FCCFG_TFCE_802_3X
expr_stmt|;
break|break;
default|default:
name|ERROR_REPORT1
argument_list|(
name|IXGBE_ERROR_ARGUMENT
argument_list|,
literal|"Flow control param set incorrectly\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|IXGBE_ERR_CONFIG
expr_stmt|;
goto|goto
name|out
goto|;
break|break;
block|}
comment|/* Set 802.3x based flow control settings. */
name|mflcn_reg
operator||=
name|IXGBE_MFLCN_DPF
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MFLCN
argument_list|,
name|mflcn_reg
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCCFG
argument_list|,
name|fccfg_reg
argument_list|)
expr_stmt|;
comment|/* Set up and enable Rx high/low water mark thresholds, enable XON. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_DCB_MAX_TRAFFIC_CLASS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|hw
operator|->
name|fc
operator|.
name|current_mode
operator|&
name|ixgbe_fc_tx_pause
operator|)
operator|&&
name|hw
operator|->
name|fc
operator|.
name|high_water
index|[
name|i
index|]
condition|)
block|{
name|fcrtl
operator|=
operator|(
name|hw
operator|->
name|fc
operator|.
name|low_water
index|[
name|i
index|]
operator|<<
literal|10
operator|)
operator||
name|IXGBE_FCRTL_XONE
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCRTL_82599
argument_list|(
name|i
argument_list|)
argument_list|,
name|fcrtl
argument_list|)
expr_stmt|;
name|fcrth
operator|=
operator|(
name|hw
operator|->
name|fc
operator|.
name|high_water
index|[
name|i
index|]
operator|<<
literal|10
operator|)
operator||
name|IXGBE_FCRTH_FCEN
expr_stmt|;
block|}
else|else
block|{
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCRTL_82599
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 			 * In order to prevent Tx hangs when the internal Tx 			 * switch is enabled we must set the high water mark 			 * to the Rx packet buffer size - 24KB.  This allows 			 * the Tx switch to function even under heavy Rx 			 * workloads. 			 */
name|fcrth
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXPBSIZE
argument_list|(
name|i
argument_list|)
argument_list|)
operator|-
literal|24576
expr_stmt|;
block|}
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCRTH_82599
argument_list|(
name|i
argument_list|)
argument_list|,
name|fcrth
argument_list|)
expr_stmt|;
block|}
comment|/* Configure pause time (2 TCs per register) */
name|reg
operator|=
name|hw
operator|->
name|fc
operator|.
name|pause_time
operator|*
literal|0x00010001
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|IXGBE_DCB_MAX_TRAFFIC_CLASS
operator|/
literal|2
operator|)
condition|;
name|i
operator|++
control|)
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCTTV
argument_list|(
name|i
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Configure flow control refresh threshold value */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCRTV
argument_list|,
name|hw
operator|->
name|fc
operator|.
name|pause_time
operator|/
literal|2
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_negotiate_fc - Negotiate flow control  *  @hw: pointer to hardware structure  *  @adv_reg: flow control advertised settings  *  @lp_reg: link partner's flow control settings  *  @adv_sym: symmetric pause bit in advertisement  *  @adv_asm: asymmetric pause bit in advertisement  *  @lp_sym: symmetric pause bit in link partner advertisement  *  @lp_asm: asymmetric pause bit in link partner advertisement  *  *  Find the intersection between advertised settings and link partner's  *  advertised settings  **/
end_comment

begin_function
name|s32
name|ixgbe_negotiate_fc
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|adv_reg
parameter_list|,
name|u32
name|lp_reg
parameter_list|,
name|u32
name|adv_sym
parameter_list|,
name|u32
name|adv_asm
parameter_list|,
name|u32
name|lp_sym
parameter_list|,
name|u32
name|lp_asm
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|!
operator|(
name|adv_reg
operator|)
operator|)
operator|||
operator|(
operator|!
operator|(
name|lp_reg
operator|)
operator|)
condition|)
block|{
name|ERROR_REPORT3
argument_list|(
name|IXGBE_ERROR_UNSUPPORTED
argument_list|,
literal|"Local or link partner's advertised flow control "
literal|"settings are NULL. Local: %x, link partner: %x\n"
argument_list|,
name|adv_reg
argument_list|,
name|lp_reg
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_FC_NOT_NEGOTIATED
return|;
block|}
if|if
condition|(
operator|(
name|adv_reg
operator|&
name|adv_sym
operator|)
operator|&&
operator|(
name|lp_reg
operator|&
name|lp_sym
operator|)
condition|)
block|{
comment|/* 		 * Now we need to check if the user selected Rx ONLY 		 * of pause frames.  In this case, we had to advertise 		 * FULL flow control because we could not advertise RX 		 * ONLY. Hence, we must now check to see if we need to 		 * turn OFF the TRANSMISSION of PAUSE frames. 		 */
if|if
condition|(
name|hw
operator|->
name|fc
operator|.
name|requested_mode
operator|==
name|ixgbe_fc_full
condition|)
block|{
name|hw
operator|->
name|fc
operator|.
name|current_mode
operator|=
name|ixgbe_fc_full
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Flow Control = FULL.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hw
operator|->
name|fc
operator|.
name|current_mode
operator|=
name|ixgbe_fc_rx_pause
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Flow Control=RX PAUSE frames only\n"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|adv_reg
operator|&
name|adv_sym
operator|)
operator|&&
operator|(
name|adv_reg
operator|&
name|adv_asm
operator|)
operator|&&
operator|(
name|lp_reg
operator|&
name|lp_sym
operator|)
operator|&&
operator|(
name|lp_reg
operator|&
name|lp_asm
operator|)
condition|)
block|{
name|hw
operator|->
name|fc
operator|.
name|current_mode
operator|=
name|ixgbe_fc_tx_pause
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Flow Control = TX PAUSE frames only.\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|adv_reg
operator|&
name|adv_sym
operator|)
operator|&&
operator|(
name|adv_reg
operator|&
name|adv_asm
operator|)
operator|&&
operator|!
operator|(
name|lp_reg
operator|&
name|lp_sym
operator|)
operator|&&
operator|(
name|lp_reg
operator|&
name|lp_asm
operator|)
condition|)
block|{
name|hw
operator|->
name|fc
operator|.
name|current_mode
operator|=
name|ixgbe_fc_rx_pause
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Flow Control = RX PAUSE frames only.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hw
operator|->
name|fc
operator|.
name|current_mode
operator|=
name|ixgbe_fc_none
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Flow Control = NONE.\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_fc_autoneg_fiber - Enable flow control on 1 gig fiber  *  @hw: pointer to hardware structure  *  *  Enable flow control according on 1 gig fiber.  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_fc_autoneg_fiber
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|pcs_anadv_reg
decl_stmt|,
name|pcs_lpab_reg
decl_stmt|,
name|linkstat
decl_stmt|;
name|s32
name|ret_val
init|=
name|IXGBE_ERR_FC_NOT_NEGOTIATED
decl_stmt|;
comment|/* 	 * On multispeed fiber at 1g, bail out if 	 * - link is up but AN did not complete, or if 	 * - link is up and AN completed but timed out 	 */
name|linkstat
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PCS1GLSTA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
operator|!
operator|(
name|linkstat
operator|&
name|IXGBE_PCS1GLSTA_AN_COMPLETE
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|!
operator|!
operator|(
name|linkstat
operator|&
name|IXGBE_PCS1GLSTA_AN_TIMED_OUT
operator|)
operator|==
literal|1
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Auto-Negotiation did not complete or timed out\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|pcs_anadv_reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PCS1GANA
argument_list|)
expr_stmt|;
name|pcs_lpab_reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PCS1GANLP
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|ixgbe_negotiate_fc
argument_list|(
name|hw
argument_list|,
name|pcs_anadv_reg
argument_list|,
name|pcs_lpab_reg
argument_list|,
name|IXGBE_PCS1GANA_SYM_PAUSE
argument_list|,
name|IXGBE_PCS1GANA_ASM_PAUSE
argument_list|,
name|IXGBE_PCS1GANA_SYM_PAUSE
argument_list|,
name|IXGBE_PCS1GANA_ASM_PAUSE
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_fc_autoneg_backplane - Enable flow control IEEE clause 37  *  @hw: pointer to hardware structure  *  *  Enable flow control according to IEEE clause 37.  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_fc_autoneg_backplane
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|links2
decl_stmt|,
name|anlp1_reg
decl_stmt|,
name|autoc_reg
decl_stmt|,
name|links
decl_stmt|;
name|s32
name|ret_val
init|=
name|IXGBE_ERR_FC_NOT_NEGOTIATED
decl_stmt|;
comment|/* 	 * On backplane, bail out if 	 * - backplane autoneg was not completed, or if 	 * - we are 82599 and link partner is not AN enabled 	 */
name|links
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LINKS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|links
operator|&
name|IXGBE_LINKS_KX_AN_COMP
operator|)
operator|==
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Auto-Negotiation did not complete\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_82599EB
condition|)
block|{
name|links2
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LINKS2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|links2
operator|&
name|IXGBE_LINKS2_AN_SUPPORTED
operator|)
operator|==
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Link partner is not AN enabled\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
comment|/* 	 * Read the 10g AN autoc and LP ability registers and resolve 	 * local flow control settings accordingly 	 */
name|autoc_reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC
argument_list|)
expr_stmt|;
name|anlp1_reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ANLP1
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|ixgbe_negotiate_fc
argument_list|(
name|hw
argument_list|,
name|autoc_reg
argument_list|,
name|anlp1_reg
argument_list|,
name|IXGBE_AUTOC_SYM_PAUSE
argument_list|,
name|IXGBE_AUTOC_ASM_PAUSE
argument_list|,
name|IXGBE_ANLP1_SYM_PAUSE
argument_list|,
name|IXGBE_ANLP1_ASM_PAUSE
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_fc_autoneg_copper - Enable flow control IEEE clause 37  *  @hw: pointer to hardware structure  *  *  Enable flow control according to IEEE clause 37.  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_fc_autoneg_copper
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u16
name|technology_ability_reg
init|=
literal|0
decl_stmt|;
name|u16
name|lp_technology_ability_reg
init|=
literal|0
decl_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_ADVT
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
operator|&
name|technology_ability_reg
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_LP
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
operator|&
name|lp_technology_ability_reg
argument_list|)
expr_stmt|;
return|return
name|ixgbe_negotiate_fc
argument_list|(
name|hw
argument_list|,
operator|(
name|u32
operator|)
name|technology_ability_reg
argument_list|,
operator|(
name|u32
operator|)
name|lp_technology_ability_reg
argument_list|,
name|IXGBE_TAF_SYM_PAUSE
argument_list|,
name|IXGBE_TAF_ASM_PAUSE
argument_list|,
name|IXGBE_TAF_SYM_PAUSE
argument_list|,
name|IXGBE_TAF_ASM_PAUSE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_fc_autoneg - Configure flow control  *  @hw: pointer to hardware structure  *  *  Compares our advertised flow control capabilities to those advertised by  *  our link partner, and determines the proper flow control mode to use.  **/
end_comment

begin_function
name|void
name|ixgbe_fc_autoneg
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|IXGBE_ERR_FC_NOT_NEGOTIATED
decl_stmt|;
name|ixgbe_link_speed
name|speed
decl_stmt|;
name|bool
name|link_up
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_fc_autoneg"
argument_list|)
expr_stmt|;
comment|/* 	 * AN should have completed when the cable was plugged in. 	 * Look for reasons to bail out.  Bail out if: 	 * - FC autoneg is disabled, or if 	 * - link is not up. 	 */
if|if
condition|(
name|hw
operator|->
name|fc
operator|.
name|disable_fc_autoneg
condition|)
block|{
name|ERROR_REPORT1
argument_list|(
name|IXGBE_ERROR_UNSUPPORTED
argument_list|,
literal|"Flow control autoneg is disabled"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|check_link
argument_list|(
name|hw
argument_list|,
operator|&
name|speed
argument_list|,
operator|&
name|link_up
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|link_up
condition|)
block|{
name|ERROR_REPORT1
argument_list|(
name|IXGBE_ERROR_SOFTWARE
argument_list|,
literal|"The link is down"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
switch|switch
condition|(
name|hw
operator|->
name|phy
operator|.
name|media_type
condition|)
block|{
comment|/* Autoneg flow control on fiber adapters */
case|case
name|ixgbe_media_type_fiber_fixed
case|:
case|case
name|ixgbe_media_type_fiber_qsfp
case|:
case|case
name|ixgbe_media_type_fiber
case|:
if|if
condition|(
name|speed
operator|==
name|IXGBE_LINK_SPEED_1GB_FULL
condition|)
name|ret_val
operator|=
name|ixgbe_fc_autoneg_fiber
argument_list|(
name|hw
argument_list|)
expr_stmt|;
break|break;
comment|/* Autoneg flow control on backplane adapters */
case|case
name|ixgbe_media_type_backplane
case|:
name|ret_val
operator|=
name|ixgbe_fc_autoneg_backplane
argument_list|(
name|hw
argument_list|)
expr_stmt|;
break|break;
comment|/* Autoneg flow control on copper adapters */
case|case
name|ixgbe_media_type_copper
case|:
if|if
condition|(
name|ixgbe_device_supports_autoneg_fc
argument_list|(
name|hw
argument_list|)
condition|)
name|ret_val
operator|=
name|ixgbe_fc_autoneg_copper
argument_list|(
name|hw
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|out
label|:
if|if
condition|(
name|ret_val
operator|==
name|IXGBE_SUCCESS
condition|)
block|{
name|hw
operator|->
name|fc
operator|.
name|fc_was_autonegged
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|hw
operator|->
name|fc
operator|.
name|fc_was_autonegged
operator|=
name|FALSE
expr_stmt|;
name|hw
operator|->
name|fc
operator|.
name|current_mode
operator|=
name|hw
operator|->
name|fc
operator|.
name|requested_mode
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * ixgbe_pcie_timeout_poll - Return number of times to poll for completion  * @hw: pointer to hardware structure  *  * System-wide timeout range is encoded in PCIe Device Control2 register.  *  * Add 10% to specified maximum and return the number of times to poll for  * completion timeout, in units of 100 microsec.  Never return less than  * 800 = 80 millisec.  */
end_comment

begin_function
specifier|static
name|u32
name|ixgbe_pcie_timeout_poll
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s16
name|devctl2
decl_stmt|;
name|u32
name|pollcnt
decl_stmt|;
name|devctl2
operator|=
name|IXGBE_READ_PCIE_WORD
argument_list|(
name|hw
argument_list|,
name|IXGBE_PCI_DEVICE_CONTROL2
argument_list|)
expr_stmt|;
name|devctl2
operator|&=
name|IXGBE_PCIDEVCTRL2_TIMEO_MASK
expr_stmt|;
switch|switch
condition|(
name|devctl2
condition|)
block|{
case|case
name|IXGBE_PCIDEVCTRL2_65_130ms
case|:
name|pollcnt
operator|=
literal|1300
expr_stmt|;
comment|/* 130 millisec */
break|break;
case|case
name|IXGBE_PCIDEVCTRL2_260_520ms
case|:
name|pollcnt
operator|=
literal|5200
expr_stmt|;
comment|/* 520 millisec */
break|break;
case|case
name|IXGBE_PCIDEVCTRL2_1_2s
case|:
name|pollcnt
operator|=
literal|20000
expr_stmt|;
comment|/* 2 sec */
break|break;
case|case
name|IXGBE_PCIDEVCTRL2_4_8s
case|:
name|pollcnt
operator|=
literal|80000
expr_stmt|;
comment|/* 8 sec */
break|break;
case|case
name|IXGBE_PCIDEVCTRL2_17_34s
case|:
name|pollcnt
operator|=
literal|34000
expr_stmt|;
comment|/* 34 sec */
break|break;
case|case
name|IXGBE_PCIDEVCTRL2_50_100us
case|:
comment|/* 100 microsecs */
case|case
name|IXGBE_PCIDEVCTRL2_1_2ms
case|:
comment|/* 2 millisecs */
case|case
name|IXGBE_PCIDEVCTRL2_16_32ms
case|:
comment|/* 32 millisec */
case|case
name|IXGBE_PCIDEVCTRL2_16_32ms_def
case|:
comment|/* 32 millisec default */
default|default:
name|pollcnt
operator|=
literal|800
expr_stmt|;
comment|/* 80 millisec minimum */
break|break;
block|}
comment|/* add 10% to spec maximum */
return|return
operator|(
name|pollcnt
operator|*
literal|11
operator|)
operator|/
literal|10
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_disable_pcie_master - Disable PCI-express master access  *  @hw: pointer to hardware structure  *  *  Disables PCI-Express master access and verifies there are no pending  *  requests. IXGBE_ERR_MASTER_REQUESTS_PENDING is returned if master disable  *  bit hasn't caused the master requests to be disabled, else IXGBE_SUCCESS  *  is returned signifying master requests disabled.  **/
end_comment

begin_function
name|s32
name|ixgbe_disable_pcie_master
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u32
name|i
decl_stmt|,
name|poll
decl_stmt|;
name|u16
name|value
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_disable_pcie_master"
argument_list|)
expr_stmt|;
comment|/* Always set this bit to ensure any future transactions are blocked */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CTRL
argument_list|,
name|IXGBE_CTRL_GIO_DIS
argument_list|)
expr_stmt|;
comment|/* Exit if master requests are blocked */
if|if
condition|(
operator|!
operator|(
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_STATUS
argument_list|)
operator|&
name|IXGBE_STATUS_GIO
operator|)
operator|||
name|IXGBE_REMOVED
argument_list|(
name|hw
operator|->
name|hw_addr
argument_list|)
condition|)
goto|goto
name|out
goto|;
comment|/* Poll for master request bit to clear */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_PCI_MASTER_DISABLE_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_STATUS
argument_list|)
operator|&
name|IXGBE_STATUS_GIO
operator|)
condition|)
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Two consecutive resets are required via CTRL.RST per datasheet 	 * 5.2.5.3.2 Master Disable.  We set a flag to inform the reset routine 	 * of this need.  The first reset prevents new master requests from 	 * being issued by our device.  We then must wait 1usec or more for any 	 * remaining completions from the PCIe bus to trickle in, and then reset 	 * again to clear out any effects they may have had on our device. 	 */
name|DEBUGOUT
argument_list|(
literal|"GIO Master Disable bit didn't clear - requesting resets\n"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|flags
operator||=
name|IXGBE_FLAGS_DOUBLE_RESET_REQUIRED
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|>=
name|ixgbe_mac_X550
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Before proceeding, make sure that the PCIe block does not have 	 * transactions pending. 	 */
name|poll
operator|=
name|ixgbe_pcie_timeout_poll
argument_list|(
name|hw
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|poll
condition|;
name|i
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|value
operator|=
name|IXGBE_READ_PCIE_WORD
argument_list|(
name|hw
argument_list|,
name|IXGBE_PCI_DEVICE_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|IXGBE_REMOVED
argument_list|(
name|hw
operator|->
name|hw_addr
argument_list|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
operator|(
name|value
operator|&
name|IXGBE_PCI_DEVICE_STATUS_TRANSACTION_PENDING
operator|)
condition|)
goto|goto
name|out
goto|;
block|}
name|ERROR_REPORT1
argument_list|(
name|IXGBE_ERROR_POLLING
argument_list|,
literal|"PCIe transaction pending bit also did not clear.\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IXGBE_ERR_MASTER_REQUESTS_PENDING
expr_stmt|;
name|out
label|:
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_acquire_swfw_sync - Acquire SWFW semaphore  *  @hw: pointer to hardware structure  *  @mask: Mask to specify which semaphore to acquire  *  *  Acquires the SWFW semaphore through the GSSR register for the specified  *  function (CSR, PHY0, PHY1, EEPROM, Flash)  **/
end_comment

begin_function
name|s32
name|ixgbe_acquire_swfw_sync
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|mask
parameter_list|)
block|{
name|u32
name|gssr
init|=
literal|0
decl_stmt|;
name|u32
name|swmask
init|=
name|mask
decl_stmt|;
name|u32
name|fwmask
init|=
name|mask
operator|<<
literal|5
decl_stmt|;
name|u32
name|timeout
init|=
literal|200
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_acquire_swfw_sync"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|timeout
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * SW NVM semaphore bit is used for access to all 		 * SW_FW_SYNC bits (not just NVM) 		 */
if|if
condition|(
name|ixgbe_get_eeprom_semaphore
argument_list|(
name|hw
argument_list|)
condition|)
return|return
name|IXGBE_ERR_SWFW_SYNC
return|;
name|gssr
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|gssr
operator|&
operator|(
name|fwmask
operator||
name|swmask
operator|)
operator|)
condition|)
block|{
name|gssr
operator||=
name|swmask
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR
argument_list|,
name|gssr
argument_list|)
expr_stmt|;
name|ixgbe_release_eeprom_semaphore
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
else|else
block|{
comment|/* Resource is currently in use by FW or SW */
name|ixgbe_release_eeprom_semaphore
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If time expired clear the bits holding the lock and retry */
if|if
condition|(
name|gssr
operator|&
operator|(
name|fwmask
operator||
name|swmask
operator|)
condition|)
name|ixgbe_release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|gssr
operator|&
operator|(
name|fwmask
operator||
name|swmask
operator|)
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_SWFW_SYNC
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_release_swfw_sync - Release SWFW semaphore  *  @hw: pointer to hardware structure  *  @mask: Mask to specify which semaphore to release  *  *  Releases the SWFW semaphore through the GSSR register for the specified  *  function (CSR, PHY0, PHY1, EEPROM, Flash)  **/
end_comment

begin_function
name|void
name|ixgbe_release_swfw_sync
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|mask
parameter_list|)
block|{
name|u32
name|gssr
decl_stmt|;
name|u32
name|swmask
init|=
name|mask
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_release_swfw_sync"
argument_list|)
expr_stmt|;
name|ixgbe_get_eeprom_semaphore
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|gssr
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR
argument_list|)
expr_stmt|;
name|gssr
operator|&=
operator|~
name|swmask
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR
argument_list|,
name|gssr
argument_list|)
expr_stmt|;
name|ixgbe_release_eeprom_semaphore
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_disable_sec_rx_path_generic - Stops the receive data path  *  @hw: pointer to hardware structure  *  *  Stops the receive data path and waits for the HW to internally empty  *  the Rx security block  **/
end_comment

begin_function
name|s32
name|ixgbe_disable_sec_rx_path_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
define|#
directive|define
name|IXGBE_MAX_SECRX_POLL
value|40
name|int
name|i
decl_stmt|;
name|int
name|secrxreg
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_disable_sec_rx_path_generic"
argument_list|)
expr_stmt|;
name|secrxreg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SECRXCTRL
argument_list|)
expr_stmt|;
name|secrxreg
operator||=
name|IXGBE_SECRXCTRL_RX_DIS
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SECRXCTRL
argument_list|,
name|secrxreg
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_MAX_SECRX_POLL
condition|;
name|i
operator|++
control|)
block|{
name|secrxreg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SECRXSTAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|secrxreg
operator|&
name|IXGBE_SECRXSTAT_SECRX_RDY
condition|)
break|break;
else|else
comment|/* Use interrupt-safe sleep just in case */
name|usec_delay
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
comment|/* For informational purposes only */
if|if
condition|(
name|i
operator|>=
name|IXGBE_MAX_SECRX_POLL
condition|)
name|DEBUGOUT
argument_list|(
literal|"Rx unit being enabled before security "
literal|"path fully disabled.  Continuing with init.\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  prot_autoc_read_generic - Hides MAC differences needed for AUTOC read  *  @hw: pointer to hardware structure  *  @reg_val: Value we read from AUTOC  *  *  The default case requires no protection so just to the register read.  */
end_comment

begin_function
name|s32
name|prot_autoc_read_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|bool
modifier|*
name|locked
parameter_list|,
name|u32
modifier|*
name|reg_val
parameter_list|)
block|{
operator|*
name|locked
operator|=
name|FALSE
expr_stmt|;
operator|*
name|reg_val
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * prot_autoc_write_generic - Hides MAC differences needed for AUTOC write  * @hw: pointer to hardware structure  * @reg_val: value to write to AUTOC  * @locked: bool to indicate whether the SW/FW lock was already taken by  *           previous read.  *  * The default case requires no protection so just to the register write.  */
end_comment

begin_function
name|s32
name|prot_autoc_write_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|reg_val
parameter_list|,
name|bool
name|locked
parameter_list|)
block|{
name|UNREFERENCED_1PARAMETER
argument_list|(
name|locked
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_enable_sec_rx_path_generic - Enables the receive data path  *  @hw: pointer to hardware structure  *  *  Enables the receive data path.  **/
end_comment

begin_function
name|s32
name|ixgbe_enable_sec_rx_path_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|secrxreg
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_enable_sec_rx_path_generic"
argument_list|)
expr_stmt|;
name|secrxreg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SECRXCTRL
argument_list|)
expr_stmt|;
name|secrxreg
operator|&=
operator|~
name|IXGBE_SECRXCTRL_RX_DIS
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SECRXCTRL
argument_list|,
name|secrxreg
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_enable_rx_dma_generic - Enable the Rx DMA unit  *  @hw: pointer to hardware structure  *  @regval: register value to write to RXCTRL  *  *  Enables the Rx DMA unit  **/
end_comment

begin_function
name|s32
name|ixgbe_enable_rx_dma_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|regval
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_enable_rx_dma_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|regval
operator|&
name|IXGBE_RXCTRL_RXEN
condition|)
name|ixgbe_enable_rx
argument_list|(
name|hw
argument_list|)
expr_stmt|;
else|else
name|ixgbe_disable_rx
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_blink_led_start_generic - Blink LED based on index.  *  @hw: pointer to hardware structure  *  @index: led number to blink  **/
end_comment

begin_function
name|s32
name|ixgbe_blink_led_start_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|index
parameter_list|)
block|{
name|ixgbe_link_speed
name|speed
init|=
literal|0
decl_stmt|;
name|bool
name|link_up
init|=
literal|0
decl_stmt|;
name|u32
name|autoc_reg
init|=
literal|0
decl_stmt|;
name|u32
name|led_reg
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LEDCTL
argument_list|)
decl_stmt|;
name|s32
name|ret_val
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|bool
name|locked
init|=
name|FALSE
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_blink_led_start_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|>
literal|3
condition|)
return|return
name|IXGBE_ERR_PARAM
return|;
comment|/* 	 * Link must be up to auto-blink the LEDs; 	 * Force it if link is down. 	 */
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|check_link
argument_list|(
name|hw
argument_list|,
operator|&
name|speed
argument_list|,
operator|&
name|link_up
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|link_up
condition|)
block|{
name|ret_val
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|prot_autoc_read
argument_list|(
name|hw
argument_list|,
operator|&
name|locked
argument_list|,
operator|&
name|autoc_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|out
goto|;
name|autoc_reg
operator||=
name|IXGBE_AUTOC_AN_RESTART
expr_stmt|;
name|autoc_reg
operator||=
name|IXGBE_AUTOC_FLU
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|prot_autoc_write
argument_list|(
name|hw
argument_list|,
name|autoc_reg
argument_list|,
name|locked
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|out
goto|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
name|led_reg
operator|&=
operator|~
name|IXGBE_LED_MODE_MASK
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|led_reg
operator||=
name|IXGBE_LED_BLINK
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LEDCTL
argument_list|,
name|led_reg
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_blink_led_stop_generic - Stop blinking LED based on index.  *  @hw: pointer to hardware structure  *  @index: led number to stop blinking  **/
end_comment

begin_function
name|s32
name|ixgbe_blink_led_stop_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|index
parameter_list|)
block|{
name|u32
name|autoc_reg
init|=
literal|0
decl_stmt|;
name|u32
name|led_reg
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LEDCTL
argument_list|)
decl_stmt|;
name|s32
name|ret_val
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|bool
name|locked
init|=
name|FALSE
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_blink_led_stop_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|>
literal|3
condition|)
return|return
name|IXGBE_ERR_PARAM
return|;
name|ret_val
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|prot_autoc_read
argument_list|(
name|hw
argument_list|,
operator|&
name|locked
argument_list|,
operator|&
name|autoc_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|out
goto|;
name|autoc_reg
operator|&=
operator|~
name|IXGBE_AUTOC_FLU
expr_stmt|;
name|autoc_reg
operator||=
name|IXGBE_AUTOC_AN_RESTART
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|prot_autoc_write
argument_list|(
name|hw
argument_list|,
name|autoc_reg
argument_list|,
name|locked
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|out
goto|;
name|led_reg
operator|&=
operator|~
name|IXGBE_LED_MODE_MASK
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|led_reg
operator|&=
operator|~
name|IXGBE_LED_BLINK
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|led_reg
operator||=
name|IXGBE_LED_LINK_ACTIVE
operator|<<
name|IXGBE_LED_MODE_SHIFT
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LEDCTL
argument_list|,
name|led_reg
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_san_mac_addr_offset - Get SAN MAC address offset from the EEPROM  *  @hw: pointer to hardware structure  *  @san_mac_offset: SAN MAC address offset  *  *  This function will read the EEPROM location for the SAN MAC address  *  pointer, and returns the value at that location.  This is used in both  *  get and set mac_addr routines.  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_get_san_mac_addr_offset
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|san_mac_offset
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_san_mac_addr_offset"
argument_list|)
expr_stmt|;
comment|/* 	 * First read the EEPROM pointer to see if the MAC addresses are 	 * available. 	 */
name|ret_val
operator|=
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|IXGBE_SAN_MAC_ADDR_PTR
argument_list|,
name|san_mac_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|ERROR_REPORT2
argument_list|(
name|IXGBE_ERROR_INVALID_STATE
argument_list|,
literal|"eeprom at offset %d failed"
argument_list|,
name|IXGBE_SAN_MAC_ADDR_PTR
argument_list|)
expr_stmt|;
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_san_mac_addr_generic - SAN MAC address retrieval from the EEPROM  *  @hw: pointer to hardware structure  *  @san_mac_addr: SAN MAC address  *  *  Reads the SAN MAC address from the EEPROM, if it's available.  This is  *  per-port, so set_lan_id() must be called before reading the addresses.  *  set_lan_id() is called by identify_sfp(), but this cannot be relied  *  upon for non-SFP connections, so we must call it here.  **/
end_comment

begin_function
name|s32
name|ixgbe_get_san_mac_addr_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|san_mac_addr
parameter_list|)
block|{
name|u16
name|san_mac_data
decl_stmt|,
name|san_mac_offset
decl_stmt|;
name|u8
name|i
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_san_mac_addr_generic"
argument_list|)
expr_stmt|;
comment|/* 	 * First read the EEPROM pointer to see if the MAC addresses are 	 * available.  If they're not, no point in calling set_lan_id() here. 	 */
name|ret_val
operator|=
name|ixgbe_get_san_mac_addr_offset
argument_list|(
name|hw
argument_list|,
operator|&
name|san_mac_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|||
name|san_mac_offset
operator|==
literal|0
operator|||
name|san_mac_offset
operator|==
literal|0xFFFF
condition|)
goto|goto
name|san_mac_addr_out
goto|;
comment|/* make sure we know which port we need to program */
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|set_lan_id
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* apply the port offset to the address offset */
operator|(
name|hw
operator|->
name|bus
operator|.
name|func
operator|)
condition|?
operator|(
name|san_mac_offset
operator|+=
name|IXGBE_SAN_MAC_ADDR_PORT1_OFFSET
operator|)
else|:
operator|(
name|san_mac_offset
operator|+=
name|IXGBE_SAN_MAC_ADDR_PORT0_OFFSET
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|ret_val
operator|=
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|san_mac_offset
argument_list|,
operator|&
name|san_mac_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|ERROR_REPORT2
argument_list|(
name|IXGBE_ERROR_INVALID_STATE
argument_list|,
literal|"eeprom read at offset %d failed"
argument_list|,
name|san_mac_offset
argument_list|)
expr_stmt|;
goto|goto
name|san_mac_addr_out
goto|;
block|}
name|san_mac_addr
index|[
name|i
operator|*
literal|2
index|]
operator|=
call|(
name|u8
call|)
argument_list|(
name|san_mac_data
argument_list|)
expr_stmt|;
name|san_mac_addr
index|[
name|i
operator|*
literal|2
operator|+
literal|1
index|]
operator|=
call|(
name|u8
call|)
argument_list|(
name|san_mac_data
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|san_mac_offset
operator|++
expr_stmt|;
block|}
return|return
name|IXGBE_SUCCESS
return|;
name|san_mac_addr_out
label|:
comment|/* 	 * No addresses available in this EEPROM.  It's not an 	 * error though, so just wipe the local address and return. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
name|san_mac_addr
index|[
name|i
index|]
operator|=
literal|0xFF
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_set_san_mac_addr_generic - Write the SAN MAC address to the EEPROM  *  @hw: pointer to hardware structure  *  @san_mac_addr: SAN MAC address  *  *  Write a SAN MAC address to the EEPROM.  **/
end_comment

begin_function
name|s32
name|ixgbe_set_san_mac_addr_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|san_mac_addr
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u16
name|san_mac_data
decl_stmt|,
name|san_mac_offset
decl_stmt|;
name|u8
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_set_san_mac_addr_generic"
argument_list|)
expr_stmt|;
comment|/* Look for SAN mac address pointer.  If not defined, return */
name|ret_val
operator|=
name|ixgbe_get_san_mac_addr_offset
argument_list|(
name|hw
argument_list|,
operator|&
name|san_mac_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|||
name|san_mac_offset
operator|==
literal|0
operator|||
name|san_mac_offset
operator|==
literal|0xFFFF
condition|)
return|return
name|IXGBE_ERR_NO_SAN_ADDR_PTR
return|;
comment|/* Make sure we know which port we need to write */
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|set_lan_id
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Apply the port offset to the address offset */
operator|(
name|hw
operator|->
name|bus
operator|.
name|func
operator|)
condition|?
operator|(
name|san_mac_offset
operator|+=
name|IXGBE_SAN_MAC_ADDR_PORT1_OFFSET
operator|)
else|:
operator|(
name|san_mac_offset
operator|+=
name|IXGBE_SAN_MAC_ADDR_PORT0_OFFSET
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|san_mac_data
operator|=
call|(
name|u16
call|)
argument_list|(
call|(
name|u16
call|)
argument_list|(
name|san_mac_addr
index|[
name|i
operator|*
literal|2
operator|+
literal|1
index|]
argument_list|)
operator|<<
literal|8
argument_list|)
expr_stmt|;
name|san_mac_data
operator||=
call|(
name|u16
call|)
argument_list|(
name|san_mac_addr
index|[
name|i
operator|*
literal|2
index|]
argument_list|)
expr_stmt|;
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|write
argument_list|(
name|hw
argument_list|,
name|san_mac_offset
argument_list|,
name|san_mac_data
argument_list|)
expr_stmt|;
name|san_mac_offset
operator|++
expr_stmt|;
block|}
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_pcie_msix_count_generic - Gets MSI-X vector count  *  @hw: pointer to hardware structure  *  *  Read PCIe configuration space, and get the MSI-X vector count from  *  the capabilities table.  **/
end_comment

begin_function
name|u16
name|ixgbe_get_pcie_msix_count_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u16
name|msix_count
init|=
literal|1
decl_stmt|;
name|u16
name|max_msix_count
decl_stmt|;
name|u16
name|pcie_offset
decl_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|ixgbe_mac_82598EB
case|:
name|pcie_offset
operator|=
name|IXGBE_PCIE_MSIX_82598_CAPS
expr_stmt|;
name|max_msix_count
operator|=
name|IXGBE_MAX_MSIX_VECTORS_82598
expr_stmt|;
break|break;
case|case
name|ixgbe_mac_82599EB
case|:
case|case
name|ixgbe_mac_X540
case|:
case|case
name|ixgbe_mac_X550
case|:
case|case
name|ixgbe_mac_X550EM_x
case|:
case|case
name|ixgbe_mac_X550EM_a
case|:
name|pcie_offset
operator|=
name|IXGBE_PCIE_MSIX_82599_CAPS
expr_stmt|;
name|max_msix_count
operator|=
name|IXGBE_MAX_MSIX_VECTORS_82599
expr_stmt|;
break|break;
default|default:
return|return
name|msix_count
return|;
block|}
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_pcie_msix_count_generic"
argument_list|)
expr_stmt|;
name|msix_count
operator|=
name|IXGBE_READ_PCIE_WORD
argument_list|(
name|hw
argument_list|,
name|pcie_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|IXGBE_REMOVED
argument_list|(
name|hw
operator|->
name|hw_addr
argument_list|)
condition|)
name|msix_count
operator|=
literal|0
expr_stmt|;
name|msix_count
operator|&=
name|IXGBE_PCIE_MSIX_TBL_SZ_MASK
expr_stmt|;
comment|/* MSI-X count is zero-based in HW */
name|msix_count
operator|++
expr_stmt|;
if|if
condition|(
name|msix_count
operator|>
name|max_msix_count
condition|)
name|msix_count
operator|=
name|max_msix_count
expr_stmt|;
return|return
name|msix_count
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_insert_mac_addr_generic - Find a RAR for this mac address  *  @hw: pointer to hardware structure  *  @addr: Address to put into receive address register  *  @vmdq: VMDq pool to assign  *  *  Puts an ethernet address into a receive address register, or  *  finds the rar that it is aleady in; adds to the pool list  **/
end_comment

begin_function
name|s32
name|ixgbe_insert_mac_addr_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|addr
parameter_list|,
name|u32
name|vmdq
parameter_list|)
block|{
specifier|static
specifier|const
name|u32
name|NO_EMPTY_RAR_FOUND
init|=
literal|0xFFFFFFFF
decl_stmt|;
name|u32
name|first_empty_rar
init|=
name|NO_EMPTY_RAR_FOUND
decl_stmt|;
name|u32
name|rar
decl_stmt|;
name|u32
name|rar_low
decl_stmt|,
name|rar_high
decl_stmt|;
name|u32
name|addr_low
decl_stmt|,
name|addr_high
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_insert_mac_addr_generic"
argument_list|)
expr_stmt|;
comment|/* swap bytes for HW little endian */
name|addr_low
operator|=
name|addr
index|[
literal|0
index|]
operator||
operator|(
name|addr
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|addr
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|addr
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
expr_stmt|;
name|addr_high
operator|=
name|addr
index|[
literal|4
index|]
operator||
operator|(
name|addr
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
comment|/* 	 * Either find the mac_id in rar or find the first empty space. 	 * rar_highwater points to just after the highest currently used 	 * rar in order to shorten the search.  It grows when we add a new 	 * rar to the top. 	 */
for|for
control|(
name|rar
operator|=
literal|0
init|;
name|rar
operator|<
name|hw
operator|->
name|mac
operator|.
name|rar_highwater
condition|;
name|rar
operator|++
control|)
block|{
name|rar_high
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RAH
argument_list|(
name|rar
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|IXGBE_RAH_AV
operator|&
name|rar_high
operator|)
operator|==
literal|0
operator|)
operator|&&
name|first_empty_rar
operator|==
name|NO_EMPTY_RAR_FOUND
condition|)
block|{
name|first_empty_rar
operator|=
name|rar
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|rar_high
operator|&
literal|0xFFFF
operator|)
operator|==
name|addr_high
condition|)
block|{
name|rar_low
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RAL
argument_list|(
name|rar
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rar_low
operator|==
name|addr_low
condition|)
break|break;
comment|/* found it already in the rars */
block|}
block|}
if|if
condition|(
name|rar
operator|<
name|hw
operator|->
name|mac
operator|.
name|rar_highwater
condition|)
block|{
comment|/* already there so just add to the pool bits */
name|ixgbe_set_vmdq
argument_list|(
name|hw
argument_list|,
name|rar
argument_list|,
name|vmdq
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|first_empty_rar
operator|!=
name|NO_EMPTY_RAR_FOUND
condition|)
block|{
comment|/* stick it into first empty RAR slot we found */
name|rar
operator|=
name|first_empty_rar
expr_stmt|;
name|ixgbe_set_rar
argument_list|(
name|hw
argument_list|,
name|rar
argument_list|,
name|addr
argument_list|,
name|vmdq
argument_list|,
name|IXGBE_RAH_AV
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rar
operator|==
name|hw
operator|->
name|mac
operator|.
name|rar_highwater
condition|)
block|{
comment|/* add it to the top of the list and inc the highwater mark */
name|ixgbe_set_rar
argument_list|(
name|hw
argument_list|,
name|rar
argument_list|,
name|addr
argument_list|,
name|vmdq
argument_list|,
name|IXGBE_RAH_AV
argument_list|)
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|rar_highwater
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rar
operator|>=
name|hw
operator|->
name|mac
operator|.
name|num_rar_entries
condition|)
block|{
return|return
name|IXGBE_ERR_INVALID_MAC_ADDR
return|;
block|}
comment|/* 	 * If we found rar[0], make sure the default pool bit (we use pool 0) 	 * remains cleared to be sure default pool packets will get delivered 	 */
if|if
condition|(
name|rar
operator|==
literal|0
condition|)
name|ixgbe_clear_vmdq
argument_list|(
name|hw
argument_list|,
name|rar
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|rar
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_clear_vmdq_generic - Disassociate a VMDq pool index from a rx address  *  @hw: pointer to hardware struct  *  @rar: receive address register index to disassociate  *  @vmdq: VMDq pool index to remove from the rar  **/
end_comment

begin_function
name|s32
name|ixgbe_clear_vmdq_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|rar
parameter_list|,
name|u32
name|vmdq
parameter_list|)
block|{
name|u32
name|mpsar_lo
decl_stmt|,
name|mpsar_hi
decl_stmt|;
name|u32
name|rar_entries
init|=
name|hw
operator|->
name|mac
operator|.
name|num_rar_entries
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_clear_vmdq_generic"
argument_list|)
expr_stmt|;
comment|/* Make sure we are using a valid rar index range */
if|if
condition|(
name|rar
operator|>=
name|rar_entries
condition|)
block|{
name|ERROR_REPORT2
argument_list|(
name|IXGBE_ERROR_ARGUMENT
argument_list|,
literal|"RAR index %d is out of range.\n"
argument_list|,
name|rar
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_INVALID_ARGUMENT
return|;
block|}
name|mpsar_lo
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MPSAR_LO
argument_list|(
name|rar
argument_list|)
argument_list|)
expr_stmt|;
name|mpsar_hi
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MPSAR_HI
argument_list|(
name|rar
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IXGBE_REMOVED
argument_list|(
name|hw
operator|->
name|hw_addr
argument_list|)
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
operator|!
name|mpsar_lo
operator|&&
operator|!
name|mpsar_hi
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|vmdq
operator|==
name|IXGBE_CLEAR_VMDQ_ALL
condition|)
block|{
if|if
condition|(
name|mpsar_lo
condition|)
block|{
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MPSAR_LO
argument_list|(
name|rar
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mpsar_lo
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|mpsar_hi
condition|)
block|{
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MPSAR_HI
argument_list|(
name|rar
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mpsar_hi
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|vmdq
operator|<
literal|32
condition|)
block|{
name|mpsar_lo
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|vmdq
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MPSAR_LO
argument_list|(
name|rar
argument_list|)
argument_list|,
name|mpsar_lo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mpsar_hi
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
name|vmdq
operator|-
literal|32
operator|)
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MPSAR_HI
argument_list|(
name|rar
argument_list|)
argument_list|,
name|mpsar_hi
argument_list|)
expr_stmt|;
block|}
comment|/* was that the last pool using this rar? */
if|if
condition|(
name|mpsar_lo
operator|==
literal|0
operator|&&
name|mpsar_hi
operator|==
literal|0
operator|&&
name|rar
operator|!=
literal|0
operator|&&
name|rar
operator|!=
name|hw
operator|->
name|mac
operator|.
name|san_mac_rar_index
condition|)
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|clear_rar
argument_list|(
name|hw
argument_list|,
name|rar
argument_list|)
expr_stmt|;
name|done
label|:
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_set_vmdq_generic - Associate a VMDq pool index with a rx address  *  @hw: pointer to hardware struct  *  @rar: receive address register index to associate with a VMDq index  *  @vmdq: VMDq pool index  **/
end_comment

begin_function
name|s32
name|ixgbe_set_vmdq_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|rar
parameter_list|,
name|u32
name|vmdq
parameter_list|)
block|{
name|u32
name|mpsar
decl_stmt|;
name|u32
name|rar_entries
init|=
name|hw
operator|->
name|mac
operator|.
name|num_rar_entries
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_set_vmdq_generic"
argument_list|)
expr_stmt|;
comment|/* Make sure we are using a valid rar index range */
if|if
condition|(
name|rar
operator|>=
name|rar_entries
condition|)
block|{
name|ERROR_REPORT2
argument_list|(
name|IXGBE_ERROR_ARGUMENT
argument_list|,
literal|"RAR index %d is out of range.\n"
argument_list|,
name|rar
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_INVALID_ARGUMENT
return|;
block|}
if|if
condition|(
name|vmdq
operator|<
literal|32
condition|)
block|{
name|mpsar
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MPSAR_LO
argument_list|(
name|rar
argument_list|)
argument_list|)
expr_stmt|;
name|mpsar
operator||=
literal|1
operator|<<
name|vmdq
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MPSAR_LO
argument_list|(
name|rar
argument_list|)
argument_list|,
name|mpsar
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mpsar
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MPSAR_HI
argument_list|(
name|rar
argument_list|)
argument_list|)
expr_stmt|;
name|mpsar
operator||=
literal|1
operator|<<
operator|(
name|vmdq
operator|-
literal|32
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MPSAR_HI
argument_list|(
name|rar
argument_list|)
argument_list|,
name|mpsar
argument_list|)
expr_stmt|;
block|}
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  This function should only be involved in the IOV mode.  *  In IOV mode, Default pool is next pool after the number of  *  VFs advertized and not 0.  *  MPSAR table needs to be updated for SAN_MAC RAR [hw->mac.san_mac_rar_index]  *  *  ixgbe_set_vmdq_san_mac - Associate default VMDq pool index with a rx address  *  @hw: pointer to hardware struct  *  @vmdq: VMDq pool index  **/
end_comment

begin_function
name|s32
name|ixgbe_set_vmdq_san_mac_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|vmdq
parameter_list|)
block|{
name|u32
name|rar
init|=
name|hw
operator|->
name|mac
operator|.
name|san_mac_rar_index
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_set_vmdq_san_mac"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vmdq
operator|<
literal|32
condition|)
block|{
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MPSAR_LO
argument_list|(
name|rar
argument_list|)
argument_list|,
literal|1
operator|<<
name|vmdq
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MPSAR_HI
argument_list|(
name|rar
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MPSAR_LO
argument_list|(
name|rar
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MPSAR_HI
argument_list|(
name|rar
argument_list|)
argument_list|,
literal|1
operator|<<
operator|(
name|vmdq
operator|-
literal|32
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_init_uta_tables_generic - Initialize the Unicast Table Array  *  @hw: pointer to hardware structure  **/
end_comment

begin_function
name|s32
name|ixgbe_init_uta_tables_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_init_uta_tables_generic"
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|" Clearing UTA\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|128
condition|;
name|i
operator|++
control|)
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_UTA
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_find_vlvf_slot - find the vlanid or the first empty slot  *  @hw: pointer to hardware structure  *  @vlan: VLAN id to write to VLAN filter  *  *  return the VLVF index where this VLAN id should be placed  *  **/
end_comment

begin_function
name|s32
name|ixgbe_find_vlvf_slot
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|vlan
parameter_list|,
name|bool
name|vlvf_bypass
parameter_list|)
block|{
name|s32
name|regindex
decl_stmt|,
name|first_empty_slot
decl_stmt|;
name|u32
name|bits
decl_stmt|;
comment|/* short cut the special case */
if|if
condition|(
name|vlan
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* if vlvf_bypass is set we don't want to use an empty slot, we 	 * will simply bypass the VLVF if there are no entries present in the 	 * VLVF that contain our VLAN 	 */
name|first_empty_slot
operator|=
name|vlvf_bypass
condition|?
name|IXGBE_ERR_NO_SPACE
else|:
literal|0
expr_stmt|;
comment|/* add VLAN enable bit for comparison */
name|vlan
operator||=
name|IXGBE_VLVF_VIEN
expr_stmt|;
comment|/* Search for the vlan id in the VLVF entries. Save off the first empty 	 * slot found along the way. 	 * 	 * pre-decrement loop covering (IXGBE_VLVF_ENTRIES - 1) .. 1 	 */
for|for
control|(
name|regindex
operator|=
name|IXGBE_VLVF_ENTRIES
init|;
operator|--
name|regindex
condition|;
control|)
block|{
name|bits
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VLVF
argument_list|(
name|regindex
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bits
operator|==
name|vlan
condition|)
return|return
name|regindex
return|;
if|if
condition|(
operator|!
name|first_empty_slot
operator|&&
operator|!
name|bits
condition|)
name|first_empty_slot
operator|=
name|regindex
expr_stmt|;
block|}
comment|/* If we are here then we didn't find the VLAN.  Return first empty 	 * slot we found during our search, else error. 	 */
if|if
condition|(
operator|!
name|first_empty_slot
condition|)
name|ERROR_REPORT1
argument_list|(
name|IXGBE_ERROR_SOFTWARE
argument_list|,
literal|"No space in VLVF.\n"
argument_list|)
expr_stmt|;
return|return
name|first_empty_slot
condition|?
name|first_empty_slot
else|:
name|IXGBE_ERR_NO_SPACE
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_set_vfta_generic - Set VLAN filter table  *  @hw: pointer to hardware structure  *  @vlan: VLAN id to write to VLAN filter  *  @vind: VMDq output index that maps queue to VLAN id in VLVFB  *  @vlan_on: boolean flag to turn on/off VLAN  *  @vlvf_bypass: boolean flag indicating updating default pool is okay  *  *  Turn on/off specified VLAN in the VLAN filter table.  **/
end_comment

begin_function
name|s32
name|ixgbe_set_vfta_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|vlan
parameter_list|,
name|u32
name|vind
parameter_list|,
name|bool
name|vlan_on
parameter_list|,
name|bool
name|vlvf_bypass
parameter_list|)
block|{
name|u32
name|regidx
decl_stmt|,
name|vfta_delta
decl_stmt|,
name|vfta
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_set_vfta_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vlan
operator|>
literal|4095
operator|||
name|vind
operator|>
literal|63
condition|)
return|return
name|IXGBE_ERR_PARAM
return|;
comment|/* 	 * this is a 2 part operation - first the VFTA, then the 	 * VLVF and VLVFB if VT Mode is set 	 * We don't write the VFTA until we know the VLVF part succeeded. 	 */
comment|/* Part 1 	 * The VFTA is a bitstring made up of 128 32-bit registers 	 * that enable the particular VLAN id, much like the MTA: 	 *    bits[11-5]: which register 	 *    bits[4-0]:  which bit in the register 	 */
name|regidx
operator|=
name|vlan
operator|/
literal|32
expr_stmt|;
name|vfta_delta
operator|=
literal|1
operator|<<
operator|(
name|vlan
operator|%
literal|32
operator|)
expr_stmt|;
name|vfta
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VFTA
argument_list|(
name|regidx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * vfta_delta represents the difference between the current value 	 * of vfta and the value we want in the register.  Since the diff 	 * is an XOR mask we can just update the vfta using an XOR 	 */
name|vfta_delta
operator|&=
name|vlan_on
condition|?
operator|~
name|vfta
else|:
name|vfta
expr_stmt|;
name|vfta
operator|^=
name|vfta_delta
expr_stmt|;
comment|/* Part 2 	 * Call ixgbe_set_vlvf_generic to set VLVFB and VLVF 	 */
name|ret_val
operator|=
name|ixgbe_set_vlvf_generic
argument_list|(
name|hw
argument_list|,
name|vlan
argument_list|,
name|vind
argument_list|,
name|vlan_on
argument_list|,
operator|&
name|vfta_delta
argument_list|,
name|vfta
argument_list|,
name|vlvf_bypass
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|IXGBE_SUCCESS
condition|)
block|{
if|if
condition|(
name|vlvf_bypass
condition|)
goto|goto
name|vfta_update
goto|;
return|return
name|ret_val
return|;
block|}
name|vfta_update
label|:
comment|/* Update VFTA now that we are ready for traffic */
if|if
condition|(
name|vfta_delta
condition|)
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VFTA
argument_list|(
name|regidx
argument_list|)
argument_list|,
name|vfta
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_set_vlvf_generic - Set VLAN Pool Filter  *  @hw: pointer to hardware structure  *  @vlan: VLAN id to write to VLAN filter  *  @vind: VMDq output index that maps queue to VLAN id in VLVFB  *  @vlan_on: boolean flag to turn on/off VLAN in VLVF  *  @vfta_delta: pointer to the difference between the current value of VFTA  *		 and the desired value  *  @vfta: the desired value of the VFTA  *  @vlvf_bypass: boolean flag indicating updating default pool is okay  *  *  Turn on/off specified bit in VLVF table.  **/
end_comment

begin_function
name|s32
name|ixgbe_set_vlvf_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|vlan
parameter_list|,
name|u32
name|vind
parameter_list|,
name|bool
name|vlan_on
parameter_list|,
name|u32
modifier|*
name|vfta_delta
parameter_list|,
name|u32
name|vfta
parameter_list|,
name|bool
name|vlvf_bypass
parameter_list|)
block|{
name|u32
name|bits
decl_stmt|;
name|s32
name|vlvf_index
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_set_vlvf_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vlan
operator|>
literal|4095
operator|||
name|vind
operator|>
literal|63
condition|)
return|return
name|IXGBE_ERR_PARAM
return|;
comment|/* If VT Mode is set 	 *   Either vlan_on 	 *     make sure the vlan is in VLVF 	 *     set the vind bit in the matching VLVFB 	 *   Or !vlan_on 	 *     clear the pool bit and possibly the vind 	 */
if|if
condition|(
operator|!
operator|(
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VT_CTL
argument_list|)
operator|&
name|IXGBE_VT_CTL_VT_ENABLE
operator|)
condition|)
return|return
name|IXGBE_SUCCESS
return|;
name|vlvf_index
operator|=
name|ixgbe_find_vlvf_slot
argument_list|(
name|hw
argument_list|,
name|vlan
argument_list|,
name|vlvf_bypass
argument_list|)
expr_stmt|;
if|if
condition|(
name|vlvf_index
operator|<
literal|0
condition|)
return|return
name|vlvf_index
return|;
name|bits
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VLVFB
argument_list|(
name|vlvf_index
operator|*
literal|2
operator|+
name|vind
operator|/
literal|32
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set the pool bit */
name|bits
operator||=
literal|1
operator|<<
operator|(
name|vind
operator|%
literal|32
operator|)
expr_stmt|;
if|if
condition|(
name|vlan_on
condition|)
goto|goto
name|vlvf_update
goto|;
comment|/* clear the pool bit */
name|bits
operator|^=
literal|1
operator|<<
operator|(
name|vind
operator|%
literal|32
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|bits
operator|&&
operator|!
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VLVFB
argument_list|(
name|vlvf_index
operator|*
literal|2
operator|+
literal|1
operator|-
name|vind
operator|/
literal|32
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Clear VFTA first, then disable VLVF.  Otherwise 		 * we run the risk of stray packets leaking into 		 * the PF via the default pool 		 */
if|if
condition|(
operator|*
name|vfta_delta
condition|)
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VFTA
argument_list|(
name|vlan
operator|/
literal|32
argument_list|)
argument_list|,
name|vfta
argument_list|)
expr_stmt|;
comment|/* disable VLVF and clear remaining bit from pool */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VLVF
argument_list|(
name|vlvf_index
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VLVFB
argument_list|(
name|vlvf_index
operator|*
literal|2
operator|+
name|vind
operator|/
literal|32
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
comment|/* If there are still bits set in the VLVFB registers 	 * for the VLAN ID indicated we need to see if the 	 * caller is requesting that we clear the VFTA entry bit. 	 * If the caller has requested that we clear the VFTA 	 * entry bit but there are still pools/VFs using this VLAN 	 * ID entry then ignore the request.  We're not worried 	 * about the case where we're turning the VFTA VLAN ID 	 * entry bit on, only when requested to turn it off as 	 * there may be multiple pools and/or VFs using the 	 * VLAN ID entry.  In that case we cannot clear the 	 * VFTA bit until all pools/VFs using that VLAN ID have also 	 * been cleared.  This will be indicated by "bits" being 	 * zero. 	 */
operator|*
name|vfta_delta
operator|=
literal|0
expr_stmt|;
name|vlvf_update
label|:
comment|/* record pool change and enable VLAN ID if not already enabled */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VLVFB
argument_list|(
name|vlvf_index
operator|*
literal|2
operator|+
name|vind
operator|/
literal|32
argument_list|)
argument_list|,
name|bits
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VLVF
argument_list|(
name|vlvf_index
argument_list|)
argument_list|,
name|IXGBE_VLVF_VIEN
operator||
name|vlan
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_clear_vfta_generic - Clear VLAN filter table  *  @hw: pointer to hardware structure  *  *  Clears the VLAN filer table, and the VMDq index associated with the filter  **/
end_comment

begin_function
name|s32
name|ixgbe_clear_vfta_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|offset
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_clear_vfta_generic"
argument_list|)
expr_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|hw
operator|->
name|mac
operator|.
name|vft_size
condition|;
name|offset
operator|++
control|)
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VFTA
argument_list|(
name|offset
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|IXGBE_VLVF_ENTRIES
condition|;
name|offset
operator|++
control|)
block|{
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VLVF
argument_list|(
name|offset
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VLVFB
argument_list|(
name|offset
operator|*
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VLVFB
argument_list|(
name|offset
operator|*
literal|2
operator|+
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_need_crosstalk_fix - Determine if we need to do cross talk fix  *  @hw: pointer to hardware structure  *  *  Contains the logic to identify if we need to verify link for the  *  crosstalk fix  **/
end_comment

begin_function
specifier|static
name|bool
name|ixgbe_need_crosstalk_fix
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
comment|/* Does FW say we need the fix */
if|if
condition|(
operator|!
name|hw
operator|->
name|need_crosstalk_fix
condition|)
return|return
name|FALSE
return|;
comment|/* Only consider SFP+ PHYs i.e. media type fiber */
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|get_media_type
argument_list|(
name|hw
argument_list|)
condition|)
block|{
case|case
name|ixgbe_media_type_fiber
case|:
case|case
name|ixgbe_media_type_fiber_qsfp
case|:
break|break;
default|default:
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_check_mac_link_generic - Determine link and speed status  *  @hw: pointer to hardware structure  *  @speed: pointer to link speed  *  @link_up: TRUE when link is up  *  @link_up_wait_to_complete: bool used to wait for link up or not  *  *  Reads the links register to determine if link is up and the current speed  **/
end_comment

begin_function
name|s32
name|ixgbe_check_mac_link_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
modifier|*
name|speed
parameter_list|,
name|bool
modifier|*
name|link_up
parameter_list|,
name|bool
name|link_up_wait_to_complete
parameter_list|)
block|{
name|u32
name|links_reg
decl_stmt|,
name|links_orig
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_check_mac_link_generic"
argument_list|)
expr_stmt|;
comment|/* If Crosstalk fix enabled do the sanity check of making sure 	 * the SFP+ cage is full. 	 */
if|if
condition|(
name|ixgbe_need_crosstalk_fix
argument_list|(
name|hw
argument_list|)
condition|)
block|{
name|u32
name|sfp_cage_full
decl_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|ixgbe_mac_82599EB
case|:
name|sfp_cage_full
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|)
operator|&
name|IXGBE_ESDP_SDP2
expr_stmt|;
break|break;
case|case
name|ixgbe_mac_X550EM_x
case|:
case|case
name|ixgbe_mac_X550EM_a
case|:
name|sfp_cage_full
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|)
operator|&
name|IXGBE_ESDP_SDP0
expr_stmt|;
break|break;
default|default:
comment|/* sanity check - No SFP+ devices here */
name|sfp_cage_full
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|sfp_cage_full
condition|)
block|{
operator|*
name|link_up
operator|=
name|FALSE
expr_stmt|;
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_UNKNOWN
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
block|}
comment|/* clear the old state */
name|links_orig
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LINKS
argument_list|)
expr_stmt|;
name|links_reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LINKS
argument_list|)
expr_stmt|;
if|if
condition|(
name|links_orig
operator|!=
name|links_reg
condition|)
block|{
name|DEBUGOUT2
argument_list|(
literal|"LINKS changed from %08X to %08X\n"
argument_list|,
name|links_orig
argument_list|,
name|links_reg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|link_up_wait_to_complete
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hw
operator|->
name|mac
operator|.
name|max_link_up_time
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|links_reg
operator|&
name|IXGBE_LINKS_UP
condition|)
block|{
operator|*
name|link_up
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
else|else
block|{
operator|*
name|link_up
operator|=
name|FALSE
expr_stmt|;
block|}
name|msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|links_reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LINKS
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|links_reg
operator|&
name|IXGBE_LINKS_UP
condition|)
operator|*
name|link_up
operator|=
name|TRUE
expr_stmt|;
else|else
operator|*
name|link_up
operator|=
name|FALSE
expr_stmt|;
block|}
switch|switch
condition|(
name|links_reg
operator|&
name|IXGBE_LINKS_SPEED_82599
condition|)
block|{
case|case
name|IXGBE_LINKS_SPEED_10G_82599
case|:
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_10GB_FULL
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|>=
name|ixgbe_mac_X550
condition|)
block|{
if|if
condition|(
name|links_reg
operator|&
name|IXGBE_LINKS_SPEED_NON_STD
condition|)
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_2_5GB_FULL
expr_stmt|;
block|}
break|break;
case|case
name|IXGBE_LINKS_SPEED_1G_82599
case|:
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
break|break;
case|case
name|IXGBE_LINKS_SPEED_100_82599
case|:
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_100_FULL
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_X550
condition|)
block|{
if|if
condition|(
name|links_reg
operator|&
name|IXGBE_LINKS_SPEED_NON_STD
condition|)
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_5GB_FULL
expr_stmt|;
block|}
break|break;
case|case
name|IXGBE_LINKS_SPEED_10_X550EM_A
case|:
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_UNKNOWN
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|device_id
operator|==
name|IXGBE_DEV_ID_X550EM_A_1G_T
operator|||
name|hw
operator|->
name|device_id
operator|==
name|IXGBE_DEV_ID_X550EM_A_1G_T_L
condition|)
block|{
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_10_FULL
expr_stmt|;
block|}
break|break;
default|default:
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_UNKNOWN
expr_stmt|;
block|}
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_wwn_prefix_generic - Get alternative WWNN/WWPN prefix from  *  the EEPROM  *  @hw: pointer to hardware structure  *  @wwnn_prefix: the alternative WWNN prefix  *  @wwpn_prefix: the alternative WWPN prefix  *  *  This function will read the EEPROM from the alternative SAN MAC address  *  block to check the support for the alternative WWNN/WWPN prefix support.  **/
end_comment

begin_function
name|s32
name|ixgbe_get_wwn_prefix_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|wwnn_prefix
parameter_list|,
name|u16
modifier|*
name|wwpn_prefix
parameter_list|)
block|{
name|u16
name|offset
decl_stmt|,
name|caps
decl_stmt|;
name|u16
name|alt_san_mac_blk_offset
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_wwn_prefix_generic"
argument_list|)
expr_stmt|;
comment|/* clear output first */
operator|*
name|wwnn_prefix
operator|=
literal|0xFFFF
expr_stmt|;
operator|*
name|wwpn_prefix
operator|=
literal|0xFFFF
expr_stmt|;
comment|/* check if alternative SAN MAC is supported */
name|offset
operator|=
name|IXGBE_ALT_SAN_MAC_ADDR_BLK_PTR
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
operator|&
name|alt_san_mac_blk_offset
argument_list|)
condition|)
goto|goto
name|wwn_prefix_err
goto|;
if|if
condition|(
operator|(
name|alt_san_mac_blk_offset
operator|==
literal|0
operator|)
operator|||
operator|(
name|alt_san_mac_blk_offset
operator|==
literal|0xFFFF
operator|)
condition|)
goto|goto
name|wwn_prefix_out
goto|;
comment|/* check capability in alternative san mac address block */
name|offset
operator|=
name|alt_san_mac_blk_offset
operator|+
name|IXGBE_ALT_SAN_MAC_ADDR_CAPS_OFFSET
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
operator|&
name|caps
argument_list|)
condition|)
goto|goto
name|wwn_prefix_err
goto|;
if|if
condition|(
operator|!
operator|(
name|caps
operator|&
name|IXGBE_ALT_SAN_MAC_ADDR_CAPS_ALTWWN
operator|)
condition|)
goto|goto
name|wwn_prefix_out
goto|;
comment|/* get the corresponding prefix for WWNN/WWPN */
name|offset
operator|=
name|alt_san_mac_blk_offset
operator|+
name|IXGBE_ALT_SAN_MAC_ADDR_WWNN_OFFSET
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|wwnn_prefix
argument_list|)
condition|)
block|{
name|ERROR_REPORT2
argument_list|(
name|IXGBE_ERROR_INVALID_STATE
argument_list|,
literal|"eeprom read at offset %d failed"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
name|offset
operator|=
name|alt_san_mac_blk_offset
operator|+
name|IXGBE_ALT_SAN_MAC_ADDR_WWPN_OFFSET
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|wwpn_prefix
argument_list|)
condition|)
goto|goto
name|wwn_prefix_err
goto|;
name|wwn_prefix_out
label|:
return|return
name|IXGBE_SUCCESS
return|;
name|wwn_prefix_err
label|:
name|ERROR_REPORT2
argument_list|(
name|IXGBE_ERROR_INVALID_STATE
argument_list|,
literal|"eeprom read at offset %d failed"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_fcoe_boot_status_generic - Get FCOE boot status from EEPROM  *  @hw: pointer to hardware structure  *  @bs: the fcoe boot status  *  *  This function will read the FCOE boot status from the iSCSI FCOE block  **/
end_comment

begin_function
name|s32
name|ixgbe_get_fcoe_boot_status_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|bs
parameter_list|)
block|{
name|u16
name|offset
decl_stmt|,
name|caps
decl_stmt|,
name|flags
decl_stmt|;
name|s32
name|status
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_fcoe_boot_status_generic"
argument_list|)
expr_stmt|;
comment|/* clear output first */
operator|*
name|bs
operator|=
name|ixgbe_fcoe_bootstatus_unavailable
expr_stmt|;
comment|/* check if FCOE IBA block is present */
name|offset
operator|=
name|IXGBE_FCOE_IBA_CAPS_BLK_PTR
expr_stmt|;
name|status
operator|=
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
operator|&
name|caps
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
operator|(
name|caps
operator|&
name|IXGBE_FCOE_IBA_CAPS_FCOE
operator|)
condition|)
goto|goto
name|out
goto|;
comment|/* check if iSCSI FCOE block is populated */
name|status
operator|=
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|IXGBE_ISCSI_FCOE_BLK_PTR
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|||
operator|(
name|offset
operator|==
literal|0xFFFF
operator|)
condition|)
goto|goto
name|out
goto|;
comment|/* read fcoe flags in iSCSI FCOE block */
name|offset
operator|=
name|offset
operator|+
name|IXGBE_ISCSI_FCOE_FLAGS_OFFSET
expr_stmt|;
name|status
operator|=
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|flags
operator|&
name|IXGBE_ISCSI_FCOE_FLAGS_ENABLE
condition|)
operator|*
name|bs
operator|=
name|ixgbe_fcoe_bootstatus_enabled
expr_stmt|;
else|else
operator|*
name|bs
operator|=
name|ixgbe_fcoe_bootstatus_disabled
expr_stmt|;
name|out
label|:
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_set_mac_anti_spoofing - Enable/Disable MAC anti-spoofing  *  @hw: pointer to hardware structure  *  @enable: enable or disable switch for MAC anti-spoofing  *  @vf: Virtual Function pool - VF Pool to set for MAC anti-spoofing  *  **/
end_comment

begin_function
name|void
name|ixgbe_set_mac_anti_spoofing
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|enable
parameter_list|,
name|int
name|vf
parameter_list|)
block|{
name|int
name|vf_target_reg
init|=
name|vf
operator|>>
literal|3
decl_stmt|;
name|int
name|vf_target_shift
init|=
name|vf
operator|%
literal|8
decl_stmt|;
name|u32
name|pfvfspoof
decl_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_82598EB
condition|)
return|return;
name|pfvfspoof
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PFVFSPOOF
argument_list|(
name|vf_target_reg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
name|pfvfspoof
operator||=
operator|(
literal|1
operator|<<
name|vf_target_shift
operator|)
expr_stmt|;
else|else
name|pfvfspoof
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|vf_target_shift
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PFVFSPOOF
argument_list|(
name|vf_target_reg
argument_list|)
argument_list|,
name|pfvfspoof
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_set_vlan_anti_spoofing - Enable/Disable VLAN anti-spoofing  *  @hw: pointer to hardware structure  *  @enable: enable or disable switch for VLAN anti-spoofing  *  @vf: Virtual Function pool - VF Pool to set for VLAN anti-spoofing  *  **/
end_comment

begin_function
name|void
name|ixgbe_set_vlan_anti_spoofing
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|enable
parameter_list|,
name|int
name|vf
parameter_list|)
block|{
name|int
name|vf_target_reg
init|=
name|vf
operator|>>
literal|3
decl_stmt|;
name|int
name|vf_target_shift
init|=
name|vf
operator|%
literal|8
operator|+
name|IXGBE_SPOOF_VLANAS_SHIFT
decl_stmt|;
name|u32
name|pfvfspoof
decl_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_82598EB
condition|)
return|return;
name|pfvfspoof
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PFVFSPOOF
argument_list|(
name|vf_target_reg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
name|pfvfspoof
operator||=
operator|(
literal|1
operator|<<
name|vf_target_shift
operator|)
expr_stmt|;
else|else
name|pfvfspoof
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|vf_target_shift
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PFVFSPOOF
argument_list|(
name|vf_target_reg
argument_list|)
argument_list|,
name|pfvfspoof
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_device_caps_generic - Get additional device capabilities  *  @hw: pointer to hardware structure  *  @device_caps: the EEPROM word with the extra device capabilities  *  *  This function will read the EEPROM location for the device capabilities,  *  and return the word through device_caps.  **/
end_comment

begin_function
name|s32
name|ixgbe_get_device_caps_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|device_caps
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_device_caps_generic"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|IXGBE_DEVICE_CAPS
argument_list|,
name|device_caps
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_enable_relaxed_ordering_gen2 - Enable relaxed ordering  *  @hw: pointer to hardware structure  *  **/
end_comment

begin_function
name|void
name|ixgbe_enable_relaxed_ordering_gen2
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|regval
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_enable_relaxed_ordering_gen2"
argument_list|)
expr_stmt|;
comment|/* Enable relaxed ordering */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hw
operator|->
name|mac
operator|.
name|max_tx_queues
condition|;
name|i
operator|++
control|)
block|{
name|regval
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DCA_TXCTRL_82599
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|regval
operator||=
name|IXGBE_DCA_TXCTRL_DESC_WRO_EN
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DCA_TXCTRL_82599
argument_list|(
name|i
argument_list|)
argument_list|,
name|regval
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hw
operator|->
name|mac
operator|.
name|max_rx_queues
condition|;
name|i
operator|++
control|)
block|{
name|regval
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DCA_RXCTRL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|regval
operator||=
name|IXGBE_DCA_RXCTRL_DATA_WRO_EN
operator||
name|IXGBE_DCA_RXCTRL_HEAD_WRO_EN
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DCA_RXCTRL
argument_list|(
name|i
argument_list|)
argument_list|,
name|regval
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *  ixgbe_calculate_checksum - Calculate checksum for buffer  *  @buffer: pointer to EEPROM  *  @length: size of EEPROM to calculate a checksum for  *  Calculates the checksum for some buffer on a specified length.  The  *  checksum calculated is returned.  **/
end_comment

begin_function
name|u8
name|ixgbe_calculate_checksum
parameter_list|(
name|u8
modifier|*
name|buffer
parameter_list|,
name|u32
name|length
parameter_list|)
block|{
name|u32
name|i
decl_stmt|;
name|u8
name|sum
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_calculate_checksum"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buffer
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
name|sum
operator|+=
name|buffer
index|[
name|i
index|]
expr_stmt|;
return|return
call|(
name|u8
call|)
argument_list|(
literal|0
operator|-
name|sum
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_hic_unlocked - Issue command to manageability block unlocked  *  @hw: pointer to the HW structure  *  @buffer: command to write and where the return status will be placed  *  @length: length of buffer, must be multiple of 4 bytes  *  @timeout: time in ms to wait for command completion  *  *  Communicates with the manageability block. On success return IXGBE_SUCCESS  *  else returns semaphore error when encountering an error acquiring  *  semaphore or IXGBE_ERR_HOST_INTERFACE_COMMAND when command fails.  *  *  This function assumes that the IXGBE_GSSR_SW_MNG_SM semaphore is held  *  by the caller.  **/
end_comment

begin_function
name|s32
name|ixgbe_hic_unlocked
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|buffer
parameter_list|,
name|u32
name|length
parameter_list|,
name|u32
name|timeout
parameter_list|)
block|{
name|u32
name|hicr
decl_stmt|,
name|i
decl_stmt|,
name|fwsts
decl_stmt|;
name|u16
name|dword_len
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_hic_unlocked"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|length
operator|||
name|length
operator|>
name|IXGBE_HI_MAX_BLOCK_BYTE_LENGTH
condition|)
block|{
name|DEBUGOUT1
argument_list|(
literal|"Buffer length failure buffersize=%d.\n"
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_HOST_INTERFACE_COMMAND
return|;
block|}
comment|/* Set bit 9 of FWSTS clearing FW reset indication */
name|fwsts
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FWSTS
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FWSTS
argument_list|,
name|fwsts
operator||
name|IXGBE_FWSTS_FWRI
argument_list|)
expr_stmt|;
comment|/* Check that the host interface is enabled. */
name|hicr
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_HICR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|hicr
operator|&
name|IXGBE_HICR_EN
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"IXGBE_HOST_EN bit disabled.\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_HOST_INTERFACE_COMMAND
return|;
block|}
comment|/* Calculate length in DWORDs. We must be DWORD aligned */
if|if
condition|(
name|length
operator|%
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Buffer length failure, not aligned to dword"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_INVALID_ARGUMENT
return|;
block|}
name|dword_len
operator|=
name|length
operator|>>
literal|2
expr_stmt|;
comment|/* The device driver writes the relevant command block 	 * into the ram area. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dword_len
condition|;
name|i
operator|++
control|)
name|IXGBE_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|IXGBE_FLEX_MNG
argument_list|,
name|i
argument_list|,
name|IXGBE_CPU_TO_LE32
argument_list|(
name|buffer
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Setting this bit tells the ARC that a new command is pending. */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_HICR
argument_list|,
name|hicr
operator||
name|IXGBE_HICR_C
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|timeout
condition|;
name|i
operator|++
control|)
block|{
name|hicr
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_HICR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|hicr
operator|&
name|IXGBE_HICR_C
operator|)
condition|)
break|break;
name|msec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Check command completion */
if|if
condition|(
operator|(
name|timeout
operator|&&
name|i
operator|==
name|timeout
operator|)
operator|||
operator|!
operator|(
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_HICR
argument_list|)
operator|&
name|IXGBE_HICR_SV
operator|)
condition|)
block|{
name|ERROR_REPORT1
argument_list|(
name|IXGBE_ERROR_CAUTION
argument_list|,
literal|"Command has failed with no status valid.\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_HOST_INTERFACE_COMMAND
return|;
block|}
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_host_interface_command - Issue command to manageability block  *  @hw: pointer to the HW structure  *  @buffer: contains the command to write and where the return status will  *   be placed  *  @length: length of buffer, must be multiple of 4 bytes  *  @timeout: time in ms to wait for command completion  *  @return_data: read and return data from the buffer (TRUE) or not (FALSE)  *   Needed because FW structures are big endian and decoding of  *   these fields can be 8 bit or 16 bit based on command. Decoding  *   is not easily understood without making a table of commands.  *   So we will leave this up to the caller to read back the data  *   in these cases.  *  *  Communicates with the manageability block. On success return IXGBE_SUCCESS  *  else returns semaphore error when encountering an error acquiring  *  semaphore or IXGBE_ERR_HOST_INTERFACE_COMMAND when command fails.  **/
end_comment

begin_function
name|s32
name|ixgbe_host_interface_command
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|buffer
parameter_list|,
name|u32
name|length
parameter_list|,
name|u32
name|timeout
parameter_list|,
name|bool
name|return_data
parameter_list|)
block|{
name|u32
name|hdr_size
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|ixgbe_hic_hdr
argument_list|)
decl_stmt|;
name|u16
name|dword_len
decl_stmt|;
name|u16
name|buf_len
decl_stmt|;
name|s32
name|status
decl_stmt|;
name|u32
name|bi
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_host_interface_command"
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
operator|||
name|length
operator|>
name|IXGBE_HI_MAX_BLOCK_BYTE_LENGTH
condition|)
block|{
name|DEBUGOUT1
argument_list|(
literal|"Buffer length failure buffersize=%d.\n"
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_HOST_INTERFACE_COMMAND
return|;
block|}
comment|/* Take management host interface semaphore */
name|status
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|acquire_swfw_sync
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR_SW_MNG_SM
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|status
return|;
name|status
operator|=
name|ixgbe_hic_unlocked
argument_list|(
name|hw
argument_list|,
name|buffer
argument_list|,
name|length
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
goto|goto
name|rel_out
goto|;
if|if
condition|(
operator|!
name|return_data
condition|)
goto|goto
name|rel_out
goto|;
comment|/* Calculate length in DWORDs */
name|dword_len
operator|=
name|hdr_size
operator|>>
literal|2
expr_stmt|;
comment|/* first pull in the header so we know the buffer length */
for|for
control|(
name|bi
operator|=
literal|0
init|;
name|bi
operator|<
name|dword_len
condition|;
name|bi
operator|++
control|)
block|{
name|buffer
index|[
name|bi
index|]
operator|=
name|IXGBE_READ_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|IXGBE_FLEX_MNG
argument_list|,
name|bi
argument_list|)
expr_stmt|;
name|IXGBE_LE32_TO_CPUS
argument_list|(
operator|&
name|buffer
index|[
name|bi
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* If there is any thing in data position pull it in */
name|buf_len
operator|=
operator|(
operator|(
expr|struct
name|ixgbe_hic_hdr
operator|*
operator|)
name|buffer
operator|)
operator|->
name|buf_len
expr_stmt|;
if|if
condition|(
operator|!
name|buf_len
condition|)
goto|goto
name|rel_out
goto|;
if|if
condition|(
name|length
operator|<
name|buf_len
operator|+
name|hdr_size
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Buffer not large enough for reply message.\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IXGBE_ERR_HOST_INTERFACE_COMMAND
expr_stmt|;
goto|goto
name|rel_out
goto|;
block|}
comment|/* Calculate length in DWORDs, add 3 for odd lengths */
name|dword_len
operator|=
operator|(
name|buf_len
operator|+
literal|3
operator|)
operator|>>
literal|2
expr_stmt|;
comment|/* Pull in the rest of the buffer (bi is where we left off) */
for|for
control|(
init|;
name|bi
operator|<=
name|dword_len
condition|;
name|bi
operator|++
control|)
block|{
name|buffer
index|[
name|bi
index|]
operator|=
name|IXGBE_READ_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|IXGBE_FLEX_MNG
argument_list|,
name|bi
argument_list|)
expr_stmt|;
name|IXGBE_LE32_TO_CPUS
argument_list|(
operator|&
name|buffer
index|[
name|bi
index|]
argument_list|)
expr_stmt|;
block|}
name|rel_out
label|:
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR_SW_MNG_SM
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_set_fw_drv_ver_generic - Sends driver version to firmware  *  @hw: pointer to the HW structure  *  @maj: driver version major number  *  @min: driver version minor number  *  @build: driver version build number  *  @sub: driver version sub build number  *  *  Sends driver version number to firmware through the manageability  *  block.  On success return IXGBE_SUCCESS  *  else returns IXGBE_ERR_SWFW_SYNC when encountering an error acquiring  *  semaphore or IXGBE_ERR_HOST_INTERFACE_COMMAND when command fails.  **/
end_comment

begin_function
name|s32
name|ixgbe_set_fw_drv_ver_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|maj
parameter_list|,
name|u8
name|min
parameter_list|,
name|u8
name|build
parameter_list|,
name|u8
name|sub
parameter_list|,
name|u16
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|driver_ver
parameter_list|)
block|{
name|struct
name|ixgbe_hic_drv_info
name|fw_cmd
decl_stmt|;
name|int
name|i
decl_stmt|;
name|s32
name|ret_val
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_set_fw_drv_ver_generic"
argument_list|)
expr_stmt|;
name|UNREFERENCED_2PARAMETER
argument_list|(
name|len
argument_list|,
name|driver_ver
argument_list|)
expr_stmt|;
name|fw_cmd
operator|.
name|hdr
operator|.
name|cmd
operator|=
name|FW_CEM_CMD_DRIVER_INFO
expr_stmt|;
name|fw_cmd
operator|.
name|hdr
operator|.
name|buf_len
operator|=
name|FW_CEM_CMD_DRIVER_INFO_LEN
expr_stmt|;
name|fw_cmd
operator|.
name|hdr
operator|.
name|cmd_or_resp
operator|.
name|cmd_resv
operator|=
name|FW_CEM_CMD_RESERVED
expr_stmt|;
name|fw_cmd
operator|.
name|port_num
operator|=
operator|(
name|u8
operator|)
name|hw
operator|->
name|bus
operator|.
name|func
expr_stmt|;
name|fw_cmd
operator|.
name|ver_maj
operator|=
name|maj
expr_stmt|;
name|fw_cmd
operator|.
name|ver_min
operator|=
name|min
expr_stmt|;
name|fw_cmd
operator|.
name|ver_build
operator|=
name|build
expr_stmt|;
name|fw_cmd
operator|.
name|ver_sub
operator|=
name|sub
expr_stmt|;
name|fw_cmd
operator|.
name|hdr
operator|.
name|checksum
operator|=
literal|0
expr_stmt|;
name|fw_cmd
operator|.
name|hdr
operator|.
name|checksum
operator|=
name|ixgbe_calculate_checksum
argument_list|(
operator|(
name|u8
operator|*
operator|)
operator|&
name|fw_cmd
argument_list|,
operator|(
name|FW_CEM_HDR_LEN
operator|+
name|fw_cmd
operator|.
name|hdr
operator|.
name|buf_len
operator|)
argument_list|)
expr_stmt|;
name|fw_cmd
operator|.
name|pad
operator|=
literal|0
expr_stmt|;
name|fw_cmd
operator|.
name|pad2
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|FW_CEM_MAX_RETRIES
condition|;
name|i
operator|++
control|)
block|{
name|ret_val
operator|=
name|ixgbe_host_interface_command
argument_list|(
name|hw
argument_list|,
operator|(
name|u32
operator|*
operator|)
operator|&
name|fw_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|fw_cmd
argument_list|)
argument_list|,
name|IXGBE_HI_COMMAND_TIMEOUT
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|IXGBE_SUCCESS
condition|)
continue|continue;
if|if
condition|(
name|fw_cmd
operator|.
name|hdr
operator|.
name|cmd_or_resp
operator|.
name|ret_status
operator|==
name|FW_CEM_RESP_STATUS_SUCCESS
condition|)
name|ret_val
operator|=
name|IXGBE_SUCCESS
expr_stmt|;
else|else
name|ret_val
operator|=
name|IXGBE_ERR_HOST_INTERFACE_COMMAND
expr_stmt|;
break|break;
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_set_rxpba_generic - Initialize Rx packet buffer  * @hw: pointer to hardware structure  * @num_pb: number of packet buffers to allocate  * @headroom: reserve n KB of headroom  * @strategy: packet buffer allocation strategy  **/
end_comment

begin_function
name|void
name|ixgbe_set_rxpba_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|int
name|num_pb
parameter_list|,
name|u32
name|headroom
parameter_list|,
name|int
name|strategy
parameter_list|)
block|{
name|u32
name|pbsize
init|=
name|hw
operator|->
name|mac
operator|.
name|rx_pb_size
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|u32
name|rxpktsize
decl_stmt|,
name|txpktsize
decl_stmt|,
name|txpbthresh
decl_stmt|;
comment|/* Reserve headroom */
name|pbsize
operator|-=
name|headroom
expr_stmt|;
if|if
condition|(
operator|!
name|num_pb
condition|)
name|num_pb
operator|=
literal|1
expr_stmt|;
comment|/* Divide remaining packet buffer space amongst the number of packet 	 * buffers requested using supplied strategy. 	 */
switch|switch
condition|(
name|strategy
condition|)
block|{
case|case
name|PBA_STRATEGY_WEIGHTED
case|:
comment|/* ixgbe_dcb_pba_80_48 strategy weight first half of packet 		 * buffer with 5/8 of the packet buffer space. 		 */
name|rxpktsize
operator|=
operator|(
name|pbsize
operator|*
literal|5
operator|)
operator|/
operator|(
name|num_pb
operator|*
literal|4
operator|)
expr_stmt|;
name|pbsize
operator|-=
name|rxpktsize
operator|*
operator|(
name|num_pb
operator|/
literal|2
operator|)
expr_stmt|;
name|rxpktsize
operator|<<=
name|IXGBE_RXPBSIZE_SHIFT
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
operator|(
name|num_pb
operator|/
literal|2
operator|)
condition|;
name|i
operator|++
control|)
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXPBSIZE
argument_list|(
name|i
argument_list|)
argument_list|,
name|rxpktsize
argument_list|)
expr_stmt|;
comment|/* fall through - configure remaining packet buffers */
case|case
name|PBA_STRATEGY_EQUAL
case|:
name|rxpktsize
operator|=
operator|(
name|pbsize
operator|/
operator|(
name|num_pb
operator|-
name|i
operator|)
operator|)
operator|<<
name|IXGBE_RXPBSIZE_SHIFT
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|num_pb
condition|;
name|i
operator|++
control|)
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXPBSIZE
argument_list|(
name|i
argument_list|)
argument_list|,
name|rxpktsize
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Only support an equally distributed Tx packet buffer strategy. */
name|txpktsize
operator|=
name|IXGBE_TXPBSIZE_MAX
operator|/
name|num_pb
expr_stmt|;
name|txpbthresh
operator|=
operator|(
name|txpktsize
operator|/
literal|1024
operator|)
operator|-
name|IXGBE_TXPKT_SIZE_MAX
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_pb
condition|;
name|i
operator|++
control|)
block|{
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_TXPBSIZE
argument_list|(
name|i
argument_list|)
argument_list|,
name|txpktsize
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_TXPBTHRESH
argument_list|(
name|i
argument_list|)
argument_list|,
name|txpbthresh
argument_list|)
expr_stmt|;
block|}
comment|/* Clear unused TCs, if any, to zero buffer size*/
for|for
control|(
init|;
name|i
operator|<
name|IXGBE_MAX_PB
condition|;
name|i
operator|++
control|)
block|{
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXPBSIZE
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_TXPBSIZE
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_TXPBTHRESH
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * ixgbe_clear_tx_pending - Clear pending TX work from the PCIe fifo  * @hw: pointer to the hardware structure  *  * The 82599 and x540 MACs can experience issues if TX work is still pending  * when a reset occurs.  This function prevents this by flushing the PCIe  * buffers on the system.  **/
end_comment

begin_function
name|void
name|ixgbe_clear_tx_pending
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|gcr_ext
decl_stmt|,
name|hlreg0
decl_stmt|,
name|i
decl_stmt|,
name|poll
decl_stmt|;
name|u16
name|value
decl_stmt|;
comment|/* 	 * If double reset is not requested then all transactions should 	 * already be clear and as such there is no work to do 	 */
if|if
condition|(
operator|!
operator|(
name|hw
operator|->
name|mac
operator|.
name|flags
operator|&
name|IXGBE_FLAGS_DOUBLE_RESET_REQUIRED
operator|)
condition|)
return|return;
comment|/* 	 * Set loopback enable to prevent any transmits from being sent 	 * should the link come up.  This assumes that the RXCTRL.RXEN bit 	 * has already been cleared. 	 */
name|hlreg0
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_HLREG0
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_HLREG0
argument_list|,
name|hlreg0
operator||
name|IXGBE_HLREG0_LPBK
argument_list|)
expr_stmt|;
comment|/* Wait for a last completion before clearing buffers */
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|3
argument_list|)
expr_stmt|;
comment|/* 	 * Before proceeding, make sure that the PCIe block does not have 	 * transactions pending. 	 */
name|poll
operator|=
name|ixgbe_pcie_timeout_poll
argument_list|(
name|hw
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|poll
condition|;
name|i
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|value
operator|=
name|IXGBE_READ_PCIE_WORD
argument_list|(
name|hw
argument_list|,
name|IXGBE_PCI_DEVICE_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|IXGBE_REMOVED
argument_list|(
name|hw
operator|->
name|hw_addr
argument_list|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
operator|(
name|value
operator|&
name|IXGBE_PCI_DEVICE_STATUS_TRANSACTION_PENDING
operator|)
condition|)
goto|goto
name|out
goto|;
block|}
name|out
label|:
comment|/* initiate cleaning flow for buffers in the PCIe transaction layer */
name|gcr_ext
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GCR_EXT
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GCR_EXT
argument_list|,
name|gcr_ext
operator||
name|IXGBE_GCR_EXT_BUFFERS_CLEAR
argument_list|)
expr_stmt|;
comment|/* Flush all writes and allow 20usec for all transactions to clear */
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|20
argument_list|)
expr_stmt|;
comment|/* restore previous register values */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GCR_EXT
argument_list|,
name|gcr_ext
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_HLREG0
argument_list|,
name|hlreg0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_bypass_rw_generic - Bit bang data into by_pass FW  *  *  @hw: pointer to hardware structure  *  @cmd: Command we send to the FW  *  @status: The reply from the FW  *  *  Bit-bangs the cmd to the by_pass FW status points to what is returned.  **/
end_comment

begin_define
define|#
directive|define
name|IXGBE_BYPASS_BB_WAIT
value|1
end_define

begin_function
name|s32
name|ixgbe_bypass_rw_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|cmd
parameter_list|,
name|u32
modifier|*
name|status
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u32
name|sck
decl_stmt|,
name|sdi
decl_stmt|,
name|sdo
decl_stmt|,
name|dir_sck
decl_stmt|,
name|dir_sdi
decl_stmt|,
name|dir_sdo
decl_stmt|;
name|u32
name|esdp
decl_stmt|;
if|if
condition|(
operator|!
name|status
condition|)
return|return
name|IXGBE_ERR_PARAM
return|;
operator|*
name|status
operator|=
literal|0
expr_stmt|;
comment|/* SDP vary by MAC type */
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|ixgbe_mac_82599EB
case|:
name|sck
operator|=
name|IXGBE_ESDP_SDP7
expr_stmt|;
name|sdi
operator|=
name|IXGBE_ESDP_SDP0
expr_stmt|;
name|sdo
operator|=
name|IXGBE_ESDP_SDP6
expr_stmt|;
name|dir_sck
operator|=
name|IXGBE_ESDP_SDP7_DIR
expr_stmt|;
name|dir_sdi
operator|=
name|IXGBE_ESDP_SDP0_DIR
expr_stmt|;
name|dir_sdo
operator|=
name|IXGBE_ESDP_SDP6_DIR
expr_stmt|;
break|break;
case|case
name|ixgbe_mac_X540
case|:
name|sck
operator|=
name|IXGBE_ESDP_SDP2
expr_stmt|;
name|sdi
operator|=
name|IXGBE_ESDP_SDP0
expr_stmt|;
name|sdo
operator|=
name|IXGBE_ESDP_SDP1
expr_stmt|;
name|dir_sck
operator|=
name|IXGBE_ESDP_SDP2_DIR
expr_stmt|;
name|dir_sdi
operator|=
name|IXGBE_ESDP_SDP0_DIR
expr_stmt|;
name|dir_sdo
operator|=
name|IXGBE_ESDP_SDP1_DIR
expr_stmt|;
break|break;
default|default:
return|return
name|IXGBE_ERR_DEVICE_NOT_SUPPORTED
return|;
block|}
comment|/* Set SDP pins direction */
name|esdp
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|)
expr_stmt|;
name|esdp
operator||=
name|dir_sck
expr_stmt|;
comment|/* SCK as output */
name|esdp
operator||=
name|dir_sdi
expr_stmt|;
comment|/* SDI as output */
name|esdp
operator|&=
operator|~
name|dir_sdo
expr_stmt|;
comment|/* SDO as input */
name|esdp
operator||=
name|sck
expr_stmt|;
name|esdp
operator||=
name|sdi
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|,
name|esdp
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
name|IXGBE_BYPASS_BB_WAIT
argument_list|)
expr_stmt|;
comment|/* Generate start condition */
name|esdp
operator|&=
operator|~
name|sdi
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|,
name|esdp
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
name|IXGBE_BYPASS_BB_WAIT
argument_list|)
expr_stmt|;
name|esdp
operator|&=
operator|~
name|sck
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|,
name|esdp
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
name|IXGBE_BYPASS_BB_WAIT
argument_list|)
expr_stmt|;
comment|/* Clock out the new control word and clock in the status */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|cmd
operator|>>
operator|(
literal|31
operator|-
name|i
operator|)
operator|)
operator|&
literal|0x01
condition|)
block|{
name|esdp
operator||=
name|sdi
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|,
name|esdp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|esdp
operator|&=
operator|~
name|sdi
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|,
name|esdp
argument_list|)
expr_stmt|;
block|}
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
name|IXGBE_BYPASS_BB_WAIT
argument_list|)
expr_stmt|;
name|esdp
operator||=
name|sck
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|,
name|esdp
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
name|IXGBE_BYPASS_BB_WAIT
argument_list|)
expr_stmt|;
name|esdp
operator|&=
operator|~
name|sck
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|,
name|esdp
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
name|IXGBE_BYPASS_BB_WAIT
argument_list|)
expr_stmt|;
name|esdp
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|)
expr_stmt|;
if|if
condition|(
name|esdp
operator|&
name|sdo
condition|)
operator|*
name|status
operator|=
operator|(
operator|*
name|status
operator|<<
literal|1
operator|)
operator||
literal|0x01
expr_stmt|;
else|else
operator|*
name|status
operator|=
operator|(
operator|*
name|status
operator|<<
literal|1
operator|)
operator||
literal|0x00
expr_stmt|;
name|msec_delay
argument_list|(
name|IXGBE_BYPASS_BB_WAIT
argument_list|)
expr_stmt|;
block|}
comment|/* stop condition */
name|esdp
operator||=
name|sck
expr_stmt|;
name|esdp
operator|&=
operator|~
name|sdi
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|,
name|esdp
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
name|IXGBE_BYPASS_BB_WAIT
argument_list|)
expr_stmt|;
name|esdp
operator||=
name|sdi
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|,
name|esdp
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* set the page bits to match the cmd that the status it belongs to */
operator|*
name|status
operator|=
operator|(
operator|*
name|status
operator|&
literal|0x3fffffff
operator|)
operator||
operator|(
name|cmd
operator|&
literal|0xc0000000
operator|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_bypass_valid_rd_generic - Verify valid return from bit-bang.  *  * If we send a write we can't be sure it took until we can read back  * that same register.  It can be a problem as some of the feilds may  * for valid reasons change inbetween the time wrote the register and  * we read it again to verify.  So this function check everything we  * can check and then assumes it worked.  *  * @u32 in_reg - The register cmd for the bit-bang read.  * @u32 out_reg - The register returned from a bit-bang read.  **/
end_comment

begin_function
name|bool
name|ixgbe_bypass_valid_rd_generic
parameter_list|(
name|u32
name|in_reg
parameter_list|,
name|u32
name|out_reg
parameter_list|)
block|{
name|u32
name|mask
decl_stmt|;
comment|/* Page must match for all control pages */
if|if
condition|(
operator|(
name|in_reg
operator|&
name|BYPASS_PAGE_M
operator|)
operator|!=
operator|(
name|out_reg
operator|&
name|BYPASS_PAGE_M
operator|)
condition|)
return|return
name|FALSE
return|;
switch|switch
condition|(
name|in_reg
operator|&
name|BYPASS_PAGE_M
condition|)
block|{
case|case
name|BYPASS_PAGE_CTL0
case|:
comment|/* All the following can't change since the last write 		 *  - All the event actions 		 *  - The timeout value 		 */
name|mask
operator|=
name|BYPASS_AUX_ON_M
operator||
name|BYPASS_MAIN_ON_M
operator||
name|BYPASS_MAIN_OFF_M
operator||
name|BYPASS_AUX_OFF_M
operator||
name|BYPASS_WDTIMEOUT_M
operator||
name|BYPASS_WDT_VALUE_M
expr_stmt|;
if|if
condition|(
operator|(
name|out_reg
operator|&
name|mask
operator|)
operator|!=
operator|(
name|in_reg
operator|&
name|mask
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* 0x0 is never a valid value for bypass status */
if|if
condition|(
operator|!
operator|(
name|out_reg
operator|&
name|BYPASS_STATUS_OFF_M
operator|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|BYPASS_PAGE_CTL1
case|:
comment|/* All the following can't change since the last write 		 *  - time valid bit 		 *  - time we last sent 		 */
name|mask
operator|=
name|BYPASS_CTL1_VALID_M
operator||
name|BYPASS_CTL1_TIME_M
expr_stmt|;
if|if
condition|(
operator|(
name|out_reg
operator|&
name|mask
operator|)
operator|!=
operator|(
name|in_reg
operator|&
name|mask
operator|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|BYPASS_PAGE_CTL2
case|:
comment|/* All we can check in this page is control number 		 * which is already done above. 		 */
break|break;
block|}
comment|/* We are as sure as we can be return TRUE */
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_bypass_set_generic - Set a bypass field in the FW CTRL Regiter.  *  *  @hw: pointer to hardware structure  *  @cmd: The control word we are setting.  *  @event: The event we are setting in the FW.  This also happens to  *	    be the mask for the event we are setting (handy)  *  @action: The action we set the event to in the FW. This is in a  *	     bit field that happens to be what we want to put in  *	     the event spot (also handy)  **/
end_comment

begin_function
name|s32
name|ixgbe_bypass_set_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|ctrl
parameter_list|,
name|u32
name|event
parameter_list|,
name|u32
name|action
parameter_list|)
block|{
name|u32
name|by_ctl
init|=
literal|0
decl_stmt|;
name|u32
name|cmd
decl_stmt|,
name|verify
decl_stmt|;
name|u32
name|count
init|=
literal|0
decl_stmt|;
comment|/* Get current values */
name|cmd
operator|=
name|ctrl
expr_stmt|;
comment|/* just reading only need control number */
if|if
condition|(
name|ixgbe_bypass_rw_generic
argument_list|(
name|hw
argument_list|,
name|cmd
argument_list|,
operator|&
name|by_ctl
argument_list|)
condition|)
return|return
name|IXGBE_ERR_INVALID_ARGUMENT
return|;
comment|/* Set to new action */
name|cmd
operator|=
operator|(
name|by_ctl
operator|&
operator|~
name|event
operator|)
operator||
name|BYPASS_WE
operator||
name|action
expr_stmt|;
if|if
condition|(
name|ixgbe_bypass_rw_generic
argument_list|(
name|hw
argument_list|,
name|cmd
argument_list|,
operator|&
name|by_ctl
argument_list|)
condition|)
return|return
name|IXGBE_ERR_INVALID_ARGUMENT
return|;
comment|/* Page 0 force a FW eeprom write which is slow so verify */
if|if
condition|(
operator|(
name|cmd
operator|&
name|BYPASS_PAGE_M
operator|)
operator|==
name|BYPASS_PAGE_CTL0
condition|)
block|{
name|verify
operator|=
name|BYPASS_PAGE_CTL0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|count
operator|++
operator|>
literal|5
condition|)
return|return
name|IXGBE_BYPASS_FW_WRITE_FAILURE
return|;
if|if
condition|(
name|ixgbe_bypass_rw_generic
argument_list|(
name|hw
argument_list|,
name|verify
argument_list|,
operator|&
name|by_ctl
argument_list|)
condition|)
return|return
name|IXGBE_ERR_INVALID_ARGUMENT
return|;
block|}
do|while
condition|(
operator|!
name|ixgbe_bypass_valid_rd_generic
argument_list|(
name|cmd
argument_list|,
name|by_ctl
argument_list|)
condition|)
do|;
block|}
else|else
block|{
comment|/* We have give the FW time for the write to stick */
name|msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_bypass_rd_eep_generic - Read the bypass FW eeprom addres.  *  *  @hw: pointer to hardware structure  *  @addr: The bypass eeprom address to read.  *  @value: The 8b of data at the address above.  **/
end_comment

begin_function
name|s32
name|ixgbe_bypass_rd_eep_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|addr
parameter_list|,
name|u8
modifier|*
name|value
parameter_list|)
block|{
name|u32
name|cmd
decl_stmt|;
name|u32
name|status
decl_stmt|;
comment|/* send the request */
name|cmd
operator|=
name|BYPASS_PAGE_CTL2
operator||
name|BYPASS_WE
expr_stmt|;
name|cmd
operator||=
operator|(
name|addr
operator|<<
name|BYPASS_CTL2_OFFSET_SHIFT
operator|)
operator|&
name|BYPASS_CTL2_OFFSET_M
expr_stmt|;
if|if
condition|(
name|ixgbe_bypass_rw_generic
argument_list|(
name|hw
argument_list|,
name|cmd
argument_list|,
operator|&
name|status
argument_list|)
condition|)
return|return
name|IXGBE_ERR_INVALID_ARGUMENT
return|;
comment|/* We have give the FW time for the write to stick */
name|msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* now read the results */
name|cmd
operator|&=
operator|~
name|BYPASS_WE
expr_stmt|;
if|if
condition|(
name|ixgbe_bypass_rw_generic
argument_list|(
name|hw
argument_list|,
name|cmd
argument_list|,
operator|&
name|status
argument_list|)
condition|)
return|return
name|IXGBE_ERR_INVALID_ARGUMENT
return|;
operator|*
name|value
operator|=
name|status
operator|&
name|BYPASS_CTL2_DATA_M
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_dcb_get_rtrup2tc_generic - read rtrup2tc reg  * @hw: pointer to hardware structure  * @map: pointer to u8 arr for returning map  *  * Read the rtrup2tc HW register and resolve its content into map  **/
end_comment

begin_function
name|void
name|ixgbe_dcb_get_rtrup2tc_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|map
parameter_list|)
block|{
name|u32
name|reg
decl_stmt|,
name|i
decl_stmt|;
name|reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RTRUP2TC
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_DCB_MAX_USER_PRIORITY
condition|;
name|i
operator|++
control|)
name|map
index|[
name|i
index|]
operator|=
name|IXGBE_RTRUP2TC_UP_MASK
operator|&
operator|(
name|reg
operator|>>
operator|(
name|i
operator|*
name|IXGBE_RTRUP2TC_UP_SHIFT
operator|)
operator|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|ixgbe_disable_rx_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|pfdtxgswc
decl_stmt|;
name|u32
name|rxctrl
decl_stmt|;
name|rxctrl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXCTRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rxctrl
operator|&
name|IXGBE_RXCTRL_RXEN
condition|)
block|{
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|!=
name|ixgbe_mac_82598EB
condition|)
block|{
name|pfdtxgswc
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PFDTXGSWC
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfdtxgswc
operator|&
name|IXGBE_PFDTXGSWC_VT_LBEN
condition|)
block|{
name|pfdtxgswc
operator|&=
operator|~
name|IXGBE_PFDTXGSWC_VT_LBEN
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PFDTXGSWC
argument_list|,
name|pfdtxgswc
argument_list|)
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|set_lben
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|hw
operator|->
name|mac
operator|.
name|set_lben
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
name|rxctrl
operator|&=
operator|~
name|IXGBE_RXCTRL_RXEN
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXCTRL
argument_list|,
name|rxctrl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ixgbe_enable_rx_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|pfdtxgswc
decl_stmt|;
name|u32
name|rxctrl
decl_stmt|;
name|rxctrl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXCTRL
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXCTRL
argument_list|,
operator|(
name|rxctrl
operator||
name|IXGBE_RXCTRL_RXEN
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|!=
name|ixgbe_mac_82598EB
condition|)
block|{
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|set_lben
condition|)
block|{
name|pfdtxgswc
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PFDTXGSWC
argument_list|)
expr_stmt|;
name|pfdtxgswc
operator||=
name|IXGBE_PFDTXGSWC_VT_LBEN
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PFDTXGSWC
argument_list|,
name|pfdtxgswc
argument_list|)
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|set_lben
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * ixgbe_mng_present - returns TRUE when management capability is present  * @hw: pointer to hardware structure  */
end_comment

begin_function
name|bool
name|ixgbe_mng_present
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|fwsm
decl_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|<
name|ixgbe_mac_82599EB
condition|)
return|return
name|FALSE
return|;
name|fwsm
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FWSM_BY_MAC
argument_list|(
name|hw
argument_list|)
argument_list|)
expr_stmt|;
name|fwsm
operator|&=
name|IXGBE_FWSM_MODE_MASK
expr_stmt|;
return|return
name|fwsm
operator|==
name|IXGBE_FWSM_FW_MODE_PT
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_mng_enabled - Is the manageability engine enabled?  * @hw: pointer to hardware structure  *  * Returns TRUE if the manageability engine is enabled.  **/
end_comment

begin_function
name|bool
name|ixgbe_mng_enabled
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|fwsm
decl_stmt|,
name|manc
decl_stmt|,
name|factps
decl_stmt|;
name|fwsm
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FWSM_BY_MAC
argument_list|(
name|hw
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fwsm
operator|&
name|IXGBE_FWSM_MODE_MASK
operator|)
operator|!=
name|IXGBE_FWSM_FW_MODE_PT
condition|)
return|return
name|FALSE
return|;
name|manc
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MANC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|manc
operator|&
name|IXGBE_MANC_RCV_TCO_EN
operator|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|<=
name|ixgbe_mac_X540
condition|)
block|{
name|factps
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FACTPS_BY_MAC
argument_list|(
name|hw
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|factps
operator|&
name|IXGBE_FACTPS_MNGCG
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_setup_mac_link_multispeed_fiber - Set MAC link speed  *  @hw: pointer to hardware structure  *  @speed: new link speed  *  @autoneg_wait_to_complete: TRUE when waiting for completion is needed  *  *  Set the link speed in the MAC and/or PHY register and restarts link.  **/
end_comment

begin_function
name|s32
name|ixgbe_setup_mac_link_multispeed_fiber
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
name|speed
parameter_list|,
name|bool
name|autoneg_wait_to_complete
parameter_list|)
block|{
name|ixgbe_link_speed
name|link_speed
init|=
name|IXGBE_LINK_SPEED_UNKNOWN
decl_stmt|;
name|ixgbe_link_speed
name|highest_link_speed
init|=
name|IXGBE_LINK_SPEED_UNKNOWN
decl_stmt|;
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u32
name|speedcnt
init|=
literal|0
decl_stmt|;
name|u32
name|i
init|=
literal|0
decl_stmt|;
name|bool
name|autoneg
decl_stmt|,
name|link_up
init|=
name|FALSE
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_setup_mac_link_multispeed_fiber"
argument_list|)
expr_stmt|;
comment|/* Mask off requested but non-supported speeds */
name|status
operator|=
name|ixgbe_get_link_capabilities
argument_list|(
name|hw
argument_list|,
operator|&
name|link_speed
argument_list|,
operator|&
name|autoneg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|speed
operator|&=
name|link_speed
expr_stmt|;
comment|/* Try each speed one by one, highest priority first.  We do this in 	 * software because 10Gb fiber doesn't support speed autonegotiation. 	 */
if|if
condition|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_10GB_FULL
condition|)
block|{
name|speedcnt
operator|++
expr_stmt|;
name|highest_link_speed
operator|=
name|IXGBE_LINK_SPEED_10GB_FULL
expr_stmt|;
comment|/* Set the module link speed */
switch|switch
condition|(
name|hw
operator|->
name|phy
operator|.
name|media_type
condition|)
block|{
case|case
name|ixgbe_media_type_fiber_fixed
case|:
case|case
name|ixgbe_media_type_fiber
case|:
name|ixgbe_set_rate_select_speed
argument_list|(
name|hw
argument_list|,
name|IXGBE_LINK_SPEED_10GB_FULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|ixgbe_media_type_fiber_qsfp
case|:
comment|/* QSFP module automatically detects MAC link speed */
break|break;
default|default:
name|DEBUGOUT
argument_list|(
literal|"Unexpected media type.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Allow module to change analog characteristics (1G->10G) */
name|msec_delay
argument_list|(
literal|40
argument_list|)
expr_stmt|;
name|status
operator|=
name|ixgbe_setup_mac_link
argument_list|(
name|hw
argument_list|,
name|IXGBE_LINK_SPEED_10GB_FULL
argument_list|,
name|autoneg_wait_to_complete
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* Flap the Tx laser if it has not already been done */
name|ixgbe_flap_tx_laser
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Wait for the controller to acquire link.  Per IEEE 802.3ap, 		 * Section 73.10.2, we may have to wait up to 500ms if KR is 		 * attempted.  82599 uses the same timing for 10g SFI. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
comment|/* Wait for the link partner to also set speed */
name|msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* If we have link, just jump out */
name|status
operator|=
name|ixgbe_check_link
argument_list|(
name|hw
argument_list|,
operator|&
name|link_speed
argument_list|,
operator|&
name|link_up
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
if|if
condition|(
name|link_up
condition|)
goto|goto
name|out
goto|;
block|}
block|}
if|if
condition|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_1GB_FULL
condition|)
block|{
name|speedcnt
operator|++
expr_stmt|;
if|if
condition|(
name|highest_link_speed
operator|==
name|IXGBE_LINK_SPEED_UNKNOWN
condition|)
name|highest_link_speed
operator|=
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
comment|/* Set the module link speed */
switch|switch
condition|(
name|hw
operator|->
name|phy
operator|.
name|media_type
condition|)
block|{
case|case
name|ixgbe_media_type_fiber_fixed
case|:
case|case
name|ixgbe_media_type_fiber
case|:
name|ixgbe_set_rate_select_speed
argument_list|(
name|hw
argument_list|,
name|IXGBE_LINK_SPEED_1GB_FULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|ixgbe_media_type_fiber_qsfp
case|:
comment|/* QSFP module automatically detects link speed */
break|break;
default|default:
name|DEBUGOUT
argument_list|(
literal|"Unexpected media type.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Allow module to change analog characteristics (10G->1G) */
name|msec_delay
argument_list|(
literal|40
argument_list|)
expr_stmt|;
name|status
operator|=
name|ixgbe_setup_mac_link
argument_list|(
name|hw
argument_list|,
name|IXGBE_LINK_SPEED_1GB_FULL
argument_list|,
name|autoneg_wait_to_complete
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* Flap the Tx laser if it has not already been done */
name|ixgbe_flap_tx_laser
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Wait for the link partner to also set speed */
name|msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* If we have link, just jump out */
name|status
operator|=
name|ixgbe_check_link
argument_list|(
name|hw
argument_list|,
operator|&
name|link_speed
argument_list|,
operator|&
name|link_up
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
if|if
condition|(
name|link_up
condition|)
goto|goto
name|out
goto|;
block|}
comment|/* We didn't get link.  Configure back to the highest speed we tried, 	 * (if there was more than one).  We call ourselves back with just the 	 * single highest speed that the user requested. 	 */
if|if
condition|(
name|speedcnt
operator|>
literal|1
condition|)
name|status
operator|=
name|ixgbe_setup_mac_link_multispeed_fiber
argument_list|(
name|hw
argument_list|,
name|highest_link_speed
argument_list|,
name|autoneg_wait_to_complete
argument_list|)
expr_stmt|;
name|out
label|:
comment|/* Set autoneg_advertised value based on input link speed */
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_10GB_FULL
condition|)
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator||=
name|IXGBE_LINK_SPEED_10GB_FULL
expr_stmt|;
if|if
condition|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_1GB_FULL
condition|)
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator||=
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_set_soft_rate_select_speed - Set module link speed  *  @hw: pointer to hardware structure  *  @speed: link speed to set  *  *  Set module link speed via the soft rate select.  */
end_comment

begin_function
name|void
name|ixgbe_set_soft_rate_select_speed
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
name|speed
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|u8
name|rs
decl_stmt|,
name|eeprom_data
decl_stmt|;
switch|switch
condition|(
name|speed
condition|)
block|{
case|case
name|IXGBE_LINK_SPEED_10GB_FULL
case|:
comment|/* one bit mask same as setting on */
name|rs
operator|=
name|IXGBE_SFF_SOFT_RS_SELECT_10G
expr_stmt|;
break|break;
case|case
name|IXGBE_LINK_SPEED_1GB_FULL
case|:
name|rs
operator|=
name|IXGBE_SFF_SOFT_RS_SELECT_1G
expr_stmt|;
break|break;
default|default:
name|DEBUGOUT
argument_list|(
literal|"Invalid fixed module speed\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Set RS0 */
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_i2c_byte
argument_list|(
name|hw
argument_list|,
name|IXGBE_SFF_SFF_8472_OSCB
argument_list|,
name|IXGBE_I2C_EEPROM_DEV_ADDR2
argument_list|,
operator|&
name|eeprom_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Failed to read Rx Rate Select RS0\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|eeprom_data
operator|=
operator|(
name|eeprom_data
operator|&
operator|~
name|IXGBE_SFF_SOFT_RS_SELECT_MASK
operator|)
operator||
name|rs
expr_stmt|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_i2c_byte
argument_list|(
name|hw
argument_list|,
name|IXGBE_SFF_SFF_8472_OSCB
argument_list|,
name|IXGBE_I2C_EEPROM_DEV_ADDR2
argument_list|,
name|eeprom_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Failed to write Rx Rate Select RS0\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Set RS1 */
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_i2c_byte
argument_list|(
name|hw
argument_list|,
name|IXGBE_SFF_SFF_8472_ESCB
argument_list|,
name|IXGBE_I2C_EEPROM_DEV_ADDR2
argument_list|,
operator|&
name|eeprom_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Failed to read Rx Rate Select RS1\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|eeprom_data
operator|=
operator|(
name|eeprom_data
operator|&
operator|~
name|IXGBE_SFF_SOFT_RS_SELECT_MASK
operator|)
operator||
name|rs
expr_stmt|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_i2c_byte
argument_list|(
name|hw
argument_list|,
name|IXGBE_SFF_SFF_8472_ESCB
argument_list|,
name|IXGBE_I2C_EEPROM_DEV_ADDR2
argument_list|,
name|eeprom_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Failed to write Rx Rate Select RS1\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|out
label|:
return|return;
block|}
end_function

end_unit

