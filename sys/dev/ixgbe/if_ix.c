begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************    Copyright (c) 2001-2017, Intel Corporation   All rights reserved.    Redistribution and use in source and binary forms, with or without   modification, are permitted provided that the following conditions are met:     1. Redistributions of source code must retain the above copyright notice,       this list of conditions and the following disclaimer.     2. Redistributions in binary form must reproduce the above copyright       notice, this list of conditions and the following disclaimer in the       documentation and/or other materials provided with the distribution.     3. Neither the name of the Intel Corporation nor the names of its       contributors may be used to endorse or promote products derived from       this software without specific prior written permission.    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  ******************************************************************************/
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|IXGBE_STANDALONE_BUILD
end_ifndef

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|"opt_rss.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ixgbe.h"
end_include

begin_comment
comment|/************************************************************************  * Driver version  ************************************************************************/
end_comment

begin_decl_stmt
name|char
name|ixgbe_driver_version
index|[]
init|=
literal|"3.2.12-k"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/************************************************************************  * PCI Device ID Table  *  *   Used by probe to select devices to load on  *   Last field stores an index into ixgbe_strings  *   Last entry must be all 0s  *  *   { Vendor ID, Device ID, SubVendor ID, SubDevice ID, String Index }  ************************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|ixgbe_vendor_info_t
name|ixgbe_vendor_info_array
index|[]
init|=
block|{
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_82598AF_DUAL_PORT
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_82598AF_SINGLE_PORT
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_82598EB_CX4
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_82598AT
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_82598AT2
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_82598
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_82598_DA_DUAL_PORT
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_82598_CX4_DUAL_PORT
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_82598EB_XF_LR
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_82598_SR_DUAL_PORT_EM
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_82598EB_SFP_LOM
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_82599_KX4
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_82599_KX4_MEZZ
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_82599_SFP
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_82599_XAUI_LOM
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_82599_CX4
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_82599_T3_LOM
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_82599_COMBO_BACKPLANE
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_82599_BACKPLANE_FCOE
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_82599_SFP_SF2
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_82599_SFP_FCOE
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_82599EN_SFP
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_82599_SFP_SF_QP
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_82599_QSFP_SF_QP
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_X540T
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_X540T1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_X550T
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_X550T1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_X550EM_X_KR
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_X550EM_X_KX4
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_X550EM_X_10G_T
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_X550EM_X_1G_T
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_X550EM_X_SFP
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_X550EM_A_KR
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_X550EM_A_KR_L
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_X550EM_A_SFP
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_X550EM_A_SFP_N
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_X550EM_A_SGMII
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_X550EM_A_SGMII_L
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_X550EM_A_10G_T
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_X550EM_A_1G_T
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_X550EM_A_1G_T_L
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_X540_BYPASS
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_82599_BYPASS
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* required last entry */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/************************************************************************  * Table of branding strings  ************************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ixgbe_strings
index|[]
init|=
block|{
literal|"Intel(R) PRO/10GbE PCI-Express Network Driver"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/************************************************************************  * Function prototypes  ************************************************************************/
end_comment

begin_function_decl
specifier|static
name|int
name|ixgbe_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_shutdown
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_suspend
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_resume
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_init_locked
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_stop
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|1100036
end_if

begin_function_decl
specifier|static
name|uint64_t
name|ixgbe_get_counter
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|ift_counter
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|ixgbe_init_device_features
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_check_fan_failure
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|u32
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_add_media_types
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|ifmediareq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_allocate_pci_resources
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_get_slot_info
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_allocate_msix
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_allocate_legacy
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_configure_interrupts
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_free_pci_resources
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_local_timer
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_setup_interface
parameter_list|(
name|device_t
parameter_list|,
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_config_gpie
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_config_dmac
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_config_delay_values
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_config_link
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_check_wol_support
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_setup_low_power_mode
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_rearm_queues
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|u64
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_initialize_transmit_units
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_initialize_receive_units
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_enable_rx_drop
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_disable_rx_drop
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_initialize_rss_mapping
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_enable_intr
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_disable_intr
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_update_stats_counters
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_set_promisc
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_set_multi
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_update_link_status
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_set_ivar
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|u8
parameter_list|,
name|u8
parameter_list|,
name|s8
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_configure_ivars
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u8
modifier|*
name|ixgbe_mc_array_itr
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
parameter_list|,
name|u8
modifier|*
modifier|*
parameter_list|,
name|u32
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_setup_vlan_hw_support
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_register_vlan
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u16
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_unregister_vlan
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u16
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_add_device_sysctls
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_add_hw_stats
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_set_flowcntl
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_set_advertise
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_get_advertise
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Sysctl handlers */
end_comment

begin_function_decl
specifier|static
name|void
name|ixgbe_set_sysctl_value
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_sysctl_flowcntl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_sysctl_advertise
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_sysctl_interrupt_rate_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_sysctl_dmac
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_sysctl_phy_temp
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_sysctl_phy_overtemp_occurred
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|IXGBE_DEBUG
end_ifdef

begin_function_decl
specifier|static
name|int
name|ixgbe_sysctl_power_state
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_sysctl_print_rss_config
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|ixgbe_sysctl_rdh_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_sysctl_rdt_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_sysctl_tdt_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_sysctl_tdh_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_sysctl_eee_state
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_sysctl_wol_enable
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_sysctl_wufc
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Support for pluggable optic modules */
end_comment

begin_function_decl
specifier|static
name|bool
name|ixgbe_sfp_probe
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Legacy (single vector) interrupt handler */
end_comment

begin_function_decl
specifier|static
name|void
name|ixgbe_legacy_irq
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The MSI/MSI-X Interrupt handlers */
end_comment

begin_function_decl
specifier|static
name|void
name|ixgbe_msix_que
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_msix_link
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Deferred interrupt tasklets */
end_comment

begin_function_decl
specifier|static
name|void
name|ixgbe_handle_que
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_handle_link
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_handle_msf
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_handle_mod
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_handle_phy
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/************************************************************************  *  FreeBSD Device Interface Entry Points  ************************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|device_method_t
name|ix_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ixgbe_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ixgbe_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|ixgbe_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|ixgbe_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|ixgbe_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|ixgbe_resume
argument_list|)
block|,
ifdef|#
directive|ifdef
name|PCI_IOV
name|DEVMETHOD
argument_list|(
name|pci_iov_init
argument_list|,
name|ixgbe_init_iov
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_iov_uninit
argument_list|,
name|ixgbe_uninit_iov
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_iov_add_vf
argument_list|,
name|ixgbe_add_vf
argument_list|)
block|,
endif|#
directive|endif
comment|/* PCI_IOV */
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|ix_driver
init|=
block|{
literal|"ix"
block|,
name|ix_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|adapter
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|devclass_t
name|ix_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|ix
argument_list|,
name|pci
argument_list|,
name|ix_driver
argument_list|,
name|ix_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ix
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ix
argument_list|,
name|ether
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ix
argument_list|,
name|netmap
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * TUNEABLE PARAMETERS:  */
end_comment

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|ix
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"IXGBE driver parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * AIM: Adaptive Interrupt Moderation  * which means that the interrupt rate  * is varied over time based on the  * traffic for that interrupt vector  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ixgbe_enable_aim
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ix
argument_list|,
name|OID_AUTO
argument_list|,
name|enable_aim
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixgbe_enable_aim
argument_list|,
literal|0
argument_list|,
literal|"Enable adaptive interrupt moderation"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ixgbe_max_interrupt_rate
init|=
operator|(
literal|4000000
operator|/
name|IXGBE_LOW_LATENCY
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ix
argument_list|,
name|OID_AUTO
argument_list|,
name|max_interrupt_rate
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixgbe_max_interrupt_rate
argument_list|,
literal|0
argument_list|,
literal|"Maximum interrupts per second"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* How many packets rxeof tries to clean at a time */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ixgbe_rx_process_limit
init|=
literal|256
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ix
argument_list|,
name|OID_AUTO
argument_list|,
name|rx_process_limit
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixgbe_rx_process_limit
argument_list|,
literal|0
argument_list|,
literal|"Maximum number of received packets to process at a time, -1 means unlimited"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* How many packets txeof tries to clean at a time */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ixgbe_tx_process_limit
init|=
literal|256
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ix
argument_list|,
name|OID_AUTO
argument_list|,
name|tx_process_limit
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixgbe_tx_process_limit
argument_list|,
literal|0
argument_list|,
literal|"Maximum number of sent packets to process at a time, -1 means unlimited"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Flow control setting, default to full */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ixgbe_flow_control
init|=
name|ixgbe_fc_full
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ix
argument_list|,
name|OID_AUTO
argument_list|,
name|flow_control
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixgbe_flow_control
argument_list|,
literal|0
argument_list|,
literal|"Default flow control used for all adapters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Advertise Speed, default to 0 (auto) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ixgbe_advertise_speed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ix
argument_list|,
name|OID_AUTO
argument_list|,
name|advertise_speed
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixgbe_advertise_speed
argument_list|,
literal|0
argument_list|,
literal|"Default advertised speed for all adapters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Smart speed setting, default to on  * this only works as a compile option  * right now as its during attach, set  * this to 'ixgbe_smart_speed_off' to  * disable.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ixgbe_smart_speed
init|=
name|ixgbe_smart_speed_on
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * MSI-X should be the default for best performance,  * but this allows it to be forced off for testing.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ixgbe_enable_msix
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ix
argument_list|,
name|OID_AUTO
argument_list|,
name|enable_msix
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixgbe_enable_msix
argument_list|,
literal|0
argument_list|,
literal|"Enable MSI-X interrupts"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Number of Queues, can be set to 0,  * it then autoconfigures based on the  * number of cpus with a max of 8. This  * can be overriden manually here.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ixgbe_num_queues
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ix
argument_list|,
name|OID_AUTO
argument_list|,
name|num_queues
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixgbe_num_queues
argument_list|,
literal|0
argument_list|,
literal|"Number of queues to configure, 0 indicates autoconfigure"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Number of TX descriptors per ring,  * setting higher than RX as this seems  * the better performing choice.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ixgbe_txd
init|=
name|PERFORM_TXD
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ix
argument_list|,
name|OID_AUTO
argument_list|,
name|txd
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixgbe_txd
argument_list|,
literal|0
argument_list|,
literal|"Number of transmit descriptors per queue"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Number of RX descriptors per ring */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ixgbe_rxd
init|=
name|PERFORM_RXD
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ix
argument_list|,
name|OID_AUTO
argument_list|,
name|rxd
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixgbe_rxd
argument_list|,
literal|0
argument_list|,
literal|"Number of receive descriptors per queue"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Defining this on will allow the use  * of unsupported SFP+ modules, note that  * doing so you are on your own :)  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|allow_unsupported_sfp
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ix
argument_list|,
name|OID_AUTO
argument_list|,
name|unsupported_sfp
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|allow_unsupported_sfp
argument_list|,
literal|0
argument_list|,
literal|"Allow unsupported SFP modules...use at your own risk"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Not sure if Flow Director is fully baked,  * so we'll default to turning it off.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ixgbe_enable_fdir
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ix
argument_list|,
name|OID_AUTO
argument_list|,
name|enable_fdir
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixgbe_enable_fdir
argument_list|,
literal|0
argument_list|,
literal|"Enable Flow Director"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Legacy Transmit (single queue) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ixgbe_enable_legacy_tx
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ix
argument_list|,
name|OID_AUTO
argument_list|,
name|enable_legacy_tx
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixgbe_enable_legacy_tx
argument_list|,
literal|0
argument_list|,
literal|"Enable Legacy TX flow"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Receive-Side Scaling */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ixgbe_enable_rss
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ix
argument_list|,
name|OID_AUTO
argument_list|,
name|enable_rss
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixgbe_enable_rss
argument_list|,
literal|0
argument_list|,
literal|"Enable Receive-Side Scaling (RSS)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Keep running tab on them for sanity check */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ixgbe_total_ports
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
function_decl|(
modifier|*
name|ixgbe_start_locked
function_decl|)
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|tx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
function_decl|(
modifier|*
name|ixgbe_ring_empty
function_decl|)
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|buf_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_IXGBE
argument_list|,
literal|"ix"
argument_list|,
literal|"ix driver allocations"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/************************************************************************  * ixgbe_initialize_rss_mapping  ************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_initialize_rss_mapping
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|u32
name|reta
init|=
literal|0
decl_stmt|,
name|mrqc
decl_stmt|,
name|rss_key
index|[
literal|10
index|]
decl_stmt|;
name|int
name|queue_id
decl_stmt|,
name|table_size
decl_stmt|,
name|index_mult
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|u32
name|rss_hash_config
decl_stmt|;
if|if
condition|(
name|adapter
operator|->
name|feat_en
operator|&
name|IXGBE_FEATURE_RSS
condition|)
block|{
comment|/* Fetch the configured RSS key */
name|rss_getkey
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|rss_key
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* set up random bits */
name|arc4rand
argument_list|(
operator|&
name|rss_key
argument_list|,
sizeof|sizeof
argument_list|(
name|rss_key
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Set multiplier for RETA setup and table size based on MAC */
name|index_mult
operator|=
literal|0x1
expr_stmt|;
name|table_size
operator|=
literal|128
expr_stmt|;
switch|switch
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|ixgbe_mac_82598EB
case|:
name|index_mult
operator|=
literal|0x11
expr_stmt|;
break|break;
case|case
name|ixgbe_mac_X550
case|:
case|case
name|ixgbe_mac_X550EM_x
case|:
case|case
name|ixgbe_mac_X550EM_a
case|:
name|table_size
operator|=
literal|512
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Set up the redirection table */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|table_size
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|==
name|adapter
operator|->
name|num_queues
condition|)
name|j
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|feat_en
operator|&
name|IXGBE_FEATURE_RSS
condition|)
block|{
comment|/* 			 * Fetch the RSS bucket id for the given indirection 			 * entry. Cap it at the number of configured buckets 			 * (which is num_queues.) 			 */
name|queue_id
operator|=
name|rss_get_indirection_to_bucket
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|queue_id
operator|=
name|queue_id
operator|%
name|adapter
operator|->
name|num_queues
expr_stmt|;
block|}
else|else
name|queue_id
operator|=
operator|(
name|j
operator|*
name|index_mult
operator|)
expr_stmt|;
comment|/* 		 * The low 8 bits are for hash value (n+0); 		 * The next 8 bits are for hash value (n+1), etc. 		 */
name|reta
operator|=
name|reta
operator|>>
literal|8
expr_stmt|;
name|reta
operator|=
name|reta
operator||
operator|(
operator|(
operator|(
name|uint32_t
operator|)
name|queue_id
operator|)
operator|<<
literal|24
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|&
literal|3
operator|)
operator|==
literal|3
condition|)
block|{
if|if
condition|(
name|i
operator|<
literal|128
condition|)
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RETA
argument_list|(
name|i
operator|>>
literal|2
argument_list|)
argument_list|,
name|reta
argument_list|)
expr_stmt|;
else|else
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ERETA
argument_list|(
operator|(
name|i
operator|>>
literal|2
operator|)
operator|-
literal|32
argument_list|)
argument_list|,
name|reta
argument_list|)
expr_stmt|;
name|reta
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Now fill our hash function seeds */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RSSRK
argument_list|(
name|i
argument_list|)
argument_list|,
name|rss_key
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Perform hash on these packet types */
if|if
condition|(
name|adapter
operator|->
name|feat_en
operator|&
name|IXGBE_FEATURE_RSS
condition|)
name|rss_hash_config
operator|=
name|rss_gethashconfig
argument_list|()
expr_stmt|;
else|else
block|{
comment|/* 		 * Disable UDP - IP fragments aren't currently being handled 		 * and so we end up with a mix of 2-tuple and 4-tuple 		 * traffic. 		 */
name|rss_hash_config
operator|=
name|RSS_HASHTYPE_RSS_IPV4
operator||
name|RSS_HASHTYPE_RSS_TCP_IPV4
operator||
name|RSS_HASHTYPE_RSS_IPV6
operator||
name|RSS_HASHTYPE_RSS_TCP_IPV6
operator||
name|RSS_HASHTYPE_RSS_IPV6_EX
operator||
name|RSS_HASHTYPE_RSS_TCP_IPV6_EX
expr_stmt|;
block|}
name|mrqc
operator|=
name|IXGBE_MRQC_RSSEN
expr_stmt|;
if|if
condition|(
name|rss_hash_config
operator|&
name|RSS_HASHTYPE_RSS_IPV4
condition|)
name|mrqc
operator||=
name|IXGBE_MRQC_RSS_FIELD_IPV4
expr_stmt|;
if|if
condition|(
name|rss_hash_config
operator|&
name|RSS_HASHTYPE_RSS_TCP_IPV4
condition|)
name|mrqc
operator||=
name|IXGBE_MRQC_RSS_FIELD_IPV4_TCP
expr_stmt|;
if|if
condition|(
name|rss_hash_config
operator|&
name|RSS_HASHTYPE_RSS_IPV6
condition|)
name|mrqc
operator||=
name|IXGBE_MRQC_RSS_FIELD_IPV6
expr_stmt|;
if|if
condition|(
name|rss_hash_config
operator|&
name|RSS_HASHTYPE_RSS_TCP_IPV6
condition|)
name|mrqc
operator||=
name|IXGBE_MRQC_RSS_FIELD_IPV6_TCP
expr_stmt|;
if|if
condition|(
name|rss_hash_config
operator|&
name|RSS_HASHTYPE_RSS_IPV6_EX
condition|)
name|mrqc
operator||=
name|IXGBE_MRQC_RSS_FIELD_IPV6_EX
expr_stmt|;
if|if
condition|(
name|rss_hash_config
operator|&
name|RSS_HASHTYPE_RSS_TCP_IPV6_EX
condition|)
name|mrqc
operator||=
name|IXGBE_MRQC_RSS_FIELD_IPV6_EX_TCP
expr_stmt|;
if|if
condition|(
name|rss_hash_config
operator|&
name|RSS_HASHTYPE_RSS_UDP_IPV4
condition|)
name|mrqc
operator||=
name|IXGBE_MRQC_RSS_FIELD_IPV4_UDP
expr_stmt|;
if|if
condition|(
name|rss_hash_config
operator|&
name|RSS_HASHTYPE_RSS_UDP_IPV4_EX
condition|)
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"%s: RSS_HASHTYPE_RSS_UDP_IPV4_EX defined, but not supported\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|rss_hash_config
operator|&
name|RSS_HASHTYPE_RSS_UDP_IPV6
condition|)
name|mrqc
operator||=
name|IXGBE_MRQC_RSS_FIELD_IPV6_UDP
expr_stmt|;
if|if
condition|(
name|rss_hash_config
operator|&
name|RSS_HASHTYPE_RSS_UDP_IPV6_EX
condition|)
name|mrqc
operator||=
name|IXGBE_MRQC_RSS_FIELD_IPV6_EX_UDP
expr_stmt|;
name|mrqc
operator||=
name|ixgbe_get_mrqc
argument_list|(
name|adapter
operator|->
name|iov_mode
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MRQC
argument_list|,
name|mrqc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ixgbe_initialize_rss_mapping */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_initialize_receive_units - Setup receive registers and features.  ************************************************************************/
end_comment

begin_define
define|#
directive|define
name|BSIZEPKT_ROUNDUP
value|((1<<IXGBE_SRRCTL_BSIZEPKT_SHIFT)-1)
end_define

begin_function
specifier|static
name|void
name|ixgbe_initialize_receive_units
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
name|adapter
operator|->
name|rx_rings
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|u32
name|bufsz
decl_stmt|,
name|fctrl
decl_stmt|,
name|srrctl
decl_stmt|,
name|rxcsum
decl_stmt|;
name|u32
name|hlreg
decl_stmt|;
comment|/* 	 * Make sure receives are disabled while 	 * setting up the descriptor ring 	 */
name|ixgbe_disable_rx
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Enable broadcasts */
name|fctrl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCTRL
argument_list|)
expr_stmt|;
name|fctrl
operator||=
name|IXGBE_FCTRL_BAM
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_82598EB
condition|)
block|{
name|fctrl
operator||=
name|IXGBE_FCTRL_DPF
expr_stmt|;
name|fctrl
operator||=
name|IXGBE_FCTRL_PMCF
expr_stmt|;
block|}
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCTRL
argument_list|,
name|fctrl
argument_list|)
expr_stmt|;
comment|/* Set for Jumbo Frames? */
name|hlreg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_HLREG0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_mtu
operator|>
name|ETHERMTU
condition|)
name|hlreg
operator||=
name|IXGBE_HLREG0_JUMBOEN
expr_stmt|;
else|else
name|hlreg
operator|&=
operator|~
name|IXGBE_HLREG0_JUMBOEN
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
comment|/* CRC stripping is conditional in Netmap */
if|if
condition|(
operator|(
name|adapter
operator|->
name|feat_en
operator|&
name|IXGBE_FEATURE_NETMAP
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_NETMAP
operator|)
operator|&&
operator|!
name|ix_crcstrip
condition|)
name|hlreg
operator|&=
operator|~
name|IXGBE_HLREG0_RXCRCSTRP
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* DEV_NETMAP */
name|hlreg
operator||=
name|IXGBE_HLREG0_RXCRCSTRP
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_HLREG0
argument_list|,
name|hlreg
argument_list|)
expr_stmt|;
name|bufsz
operator|=
operator|(
name|adapter
operator|->
name|rx_mbuf_sz
operator|+
name|BSIZEPKT_ROUNDUP
operator|)
operator|>>
name|IXGBE_SRRCTL_BSIZEPKT_SHIFT
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|rxr
operator|++
control|)
block|{
name|u64
name|rdba
init|=
name|rxr
operator|->
name|rxdma
operator|.
name|dma_paddr
decl_stmt|;
name|j
operator|=
name|rxr
operator|->
name|me
expr_stmt|;
comment|/* Setup the Base and Length of the Rx Descriptor Ring */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RDBAL
argument_list|(
name|j
argument_list|)
argument_list|,
operator|(
name|rdba
operator|&
literal|0x00000000ffffffffULL
operator|)
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RDBAH
argument_list|(
name|j
argument_list|)
argument_list|,
operator|(
name|rdba
operator|>>
literal|32
operator|)
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RDLEN
argument_list|(
name|j
argument_list|)
argument_list|,
name|adapter
operator|->
name|num_rx_desc
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|ixgbe_adv_rx_desc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set up the SRRCTL register */
name|srrctl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SRRCTL
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
name|srrctl
operator|&=
operator|~
name|IXGBE_SRRCTL_BSIZEHDR_MASK
expr_stmt|;
name|srrctl
operator|&=
operator|~
name|IXGBE_SRRCTL_BSIZEPKT_MASK
expr_stmt|;
name|srrctl
operator||=
name|bufsz
expr_stmt|;
name|srrctl
operator||=
name|IXGBE_SRRCTL_DESCTYPE_ADV_ONEBUF
expr_stmt|;
comment|/* 		 * Set DROP_EN iff we have no flow control and>1 queue. 		 * Note that srrctl was cleared shortly before during reset, 		 * so we do not need to clear the bit, but do it just in case 		 * this code is moved elsewhere. 		 */
if|if
condition|(
name|adapter
operator|->
name|num_queues
operator|>
literal|1
operator|&&
name|adapter
operator|->
name|hw
operator|.
name|fc
operator|.
name|requested_mode
operator|==
name|ixgbe_fc_none
condition|)
block|{
name|srrctl
operator||=
name|IXGBE_SRRCTL_DROP_EN
expr_stmt|;
block|}
else|else
block|{
name|srrctl
operator|&=
operator|~
name|IXGBE_SRRCTL_DROP_EN
expr_stmt|;
block|}
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SRRCTL
argument_list|(
name|j
argument_list|)
argument_list|,
name|srrctl
argument_list|)
expr_stmt|;
comment|/* Setup the HW Rx Head and Tail Descriptor Pointers */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RDH
argument_list|(
name|j
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RDT
argument_list|(
name|j
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set the driver rx tail address */
name|rxr
operator|->
name|tail
operator|=
name|IXGBE_RDT
argument_list|(
name|rxr
operator|->
name|me
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|!=
name|ixgbe_mac_82598EB
condition|)
block|{
name|u32
name|psrtype
init|=
name|IXGBE_PSRTYPE_TCPHDR
operator||
name|IXGBE_PSRTYPE_UDPHDR
operator||
name|IXGBE_PSRTYPE_IPV4HDR
operator||
name|IXGBE_PSRTYPE_IPV6HDR
decl_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PSRTYPE
argument_list|(
literal|0
argument_list|)
argument_list|,
name|psrtype
argument_list|)
expr_stmt|;
block|}
name|rxcsum
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXCSUM
argument_list|)
expr_stmt|;
name|ixgbe_initialize_rss_mapping
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|num_queues
operator|>
literal|1
condition|)
block|{
comment|/* RSS and RX IPP Checksum are mutually exclusive */
name|rxcsum
operator||=
name|IXGBE_RXCSUM_PCSD
expr_stmt|;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_RXCSUM
condition|)
name|rxcsum
operator||=
name|IXGBE_RXCSUM_PCSD
expr_stmt|;
comment|/* This is useful for calculating UDP/IP fragment checksums */
if|if
condition|(
operator|!
operator|(
name|rxcsum
operator|&
name|IXGBE_RXCSUM_PCSD
operator|)
condition|)
name|rxcsum
operator||=
name|IXGBE_RXCSUM_IPPCSE
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXCSUM
argument_list|,
name|rxcsum
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ixgbe_initialize_receive_units */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_initialize_transmit_units - Enable transmit units.  ************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_initialize_transmit_units
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
comment|/* Setup the Base and Length of the Tx Descriptor Ring */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|txr
operator|++
control|)
block|{
name|u64
name|tdba
init|=
name|txr
operator|->
name|txdma
operator|.
name|dma_paddr
decl_stmt|;
name|u32
name|txctrl
init|=
literal|0
decl_stmt|;
name|int
name|j
init|=
name|txr
operator|->
name|me
decl_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_TDBAL
argument_list|(
name|j
argument_list|)
argument_list|,
operator|(
name|tdba
operator|&
literal|0x00000000ffffffffULL
operator|)
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_TDBAH
argument_list|(
name|j
argument_list|)
argument_list|,
operator|(
name|tdba
operator|>>
literal|32
operator|)
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_TDLEN
argument_list|(
name|j
argument_list|)
argument_list|,
name|adapter
operator|->
name|num_tx_desc
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|ixgbe_adv_tx_desc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Setup the HW Tx Head and Tail descriptor pointers */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_TDH
argument_list|(
name|j
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_TDT
argument_list|(
name|j
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Cache the tail address */
name|txr
operator|->
name|tail
operator|=
name|IXGBE_TDT
argument_list|(
name|j
argument_list|)
expr_stmt|;
comment|/* Disable Head Writeback */
comment|/* 		 * Note: for X550 series devices, these registers are actually 		 * prefixed with TPH_ isntead of DCA_, but the addresses and 		 * fields remain the same. 		 */
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|ixgbe_mac_82598EB
case|:
name|txctrl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DCA_TXCTRL
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|txctrl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DCA_TXCTRL_82599
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|txctrl
operator|&=
operator|~
name|IXGBE_DCA_TXCTRL_DESC_WRO_EN
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|ixgbe_mac_82598EB
case|:
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DCA_TXCTRL
argument_list|(
name|j
argument_list|)
argument_list|,
name|txctrl
argument_list|)
expr_stmt|;
break|break;
default|default:
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DCA_TXCTRL_82599
argument_list|(
name|j
argument_list|)
argument_list|,
name|txctrl
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|!=
name|ixgbe_mac_82598EB
condition|)
block|{
name|u32
name|dmatxctl
decl_stmt|,
name|rttdcs
decl_stmt|;
name|dmatxctl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DMATXCTL
argument_list|)
expr_stmt|;
name|dmatxctl
operator||=
name|IXGBE_DMATXCTL_TE
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DMATXCTL
argument_list|,
name|dmatxctl
argument_list|)
expr_stmt|;
comment|/* Disable arbiter to set MTQC */
name|rttdcs
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RTTDCS
argument_list|)
expr_stmt|;
name|rttdcs
operator||=
name|IXGBE_RTTDCS_ARBDIS
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RTTDCS
argument_list|,
name|rttdcs
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MTQC
argument_list|,
name|ixgbe_get_mtqc
argument_list|(
name|adapter
operator|->
name|iov_mode
argument_list|)
argument_list|)
expr_stmt|;
name|rttdcs
operator|&=
operator|~
name|IXGBE_RTTDCS_ARBDIS
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RTTDCS
argument_list|,
name|rttdcs
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ixgbe_initialize_transmit_units */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_attach - Device initialization routine  *  *   Called when the driver is being loaded.  *   Identifies the type of hardware, allocates all resources  *   and initializes the hardware.  *  *   return 0 on success, positive on failure  ************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|u32
name|ctrl_ext
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixgbe_attach: begin"
argument_list|)
expr_stmt|;
comment|/* Allocate, clear, and link in our adapter structure */
name|adapter
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|back
operator|=
name|adapter
expr_stmt|;
name|adapter
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|hw
operator|=
operator|&
name|adapter
operator|->
name|hw
expr_stmt|;
comment|/* Core Lock Init*/
name|IXGBE_CORE_LOCK_INIT
argument_list|(
name|adapter
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set up the timer callout */
name|callout_init_mtx
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|,
operator|&
name|adapter
operator|->
name|core_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Determine hardware revision */
name|hw
operator|->
name|vendor_id
operator|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|hw
operator|->
name|device_id
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|hw
operator|->
name|revision_id
operator|=
name|pci_get_revid
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|hw
operator|->
name|subsystem_vendor_id
operator|=
name|pci_get_subvendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|hw
operator|->
name|subsystem_device_id
operator|=
name|pci_get_subdevice
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure BUSMASTER is set 	 */
name|pci_enable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Do base PCI setup - map BAR0 */
if|if
condition|(
name|ixgbe_allocate_pci_resources
argument_list|(
name|adapter
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Allocation of PCI resources failed\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
comment|/* let hardware know driver is loaded */
name|ctrl_ext
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CTRL_EXT
argument_list|)
expr_stmt|;
name|ctrl_ext
operator||=
name|IXGBE_CTRL_EXT_DRV_LOAD
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CTRL_EXT
argument_list|,
name|ctrl_ext
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the shared code 	 */
if|if
condition|(
name|ixgbe_init_shared_code
argument_list|(
name|hw
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to initialize the shared code\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
if|if
condition|(
name|hw
operator|->
name|mbx
operator|.
name|ops
operator|.
name|init_params
condition|)
name|hw
operator|->
name|mbx
operator|.
name|ops
operator|.
name|init_params
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|hw
operator|->
name|allow_unsupported_sfp
operator|=
name|allow_unsupported_sfp
expr_stmt|;
comment|/* Pick up the 82599 settings */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|!=
name|ixgbe_mac_82598EB
condition|)
block|{
name|hw
operator|->
name|phy
operator|.
name|smart_speed
operator|=
name|ixgbe_smart_speed
expr_stmt|;
name|adapter
operator|->
name|num_segs
operator|=
name|IXGBE_82599_SCATTER
expr_stmt|;
block|}
else|else
name|adapter
operator|->
name|num_segs
operator|=
name|IXGBE_82598_SCATTER
expr_stmt|;
name|ixgbe_init_device_features
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|ixgbe_configure_interrupts
argument_list|(
name|adapter
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
comment|/* Allocate multicast array memory. */
name|adapter
operator|->
name|mta
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|adapter
operator|->
name|mta
argument_list|)
operator|*
name|MAX_NUM_MULTICAST_ADDRESSES
argument_list|,
name|M_IXGBE
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|mta
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Can not allocate multicast setup array\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
comment|/* Enable WoL (if supported) */
name|ixgbe_check_wol_support
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Register for VLAN events */
name|adapter
operator|->
name|vlan_attach
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|vlan_config
argument_list|,
name|ixgbe_register_vlan
argument_list|,
name|adapter
argument_list|,
name|EVENTHANDLER_PRI_FIRST
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|vlan_detach
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|vlan_unconfig
argument_list|,
name|ixgbe_unregister_vlan
argument_list|,
name|adapter
argument_list|,
name|EVENTHANDLER_PRI_FIRST
argument_list|)
expr_stmt|;
comment|/* Verify adapter fan is still functional (if applicable) */
if|if
condition|(
name|adapter
operator|->
name|feat_en
operator|&
name|IXGBE_FEATURE_FAN_FAIL
condition|)
block|{
name|u32
name|esdp
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|)
decl_stmt|;
name|ixgbe_check_fan_failure
argument_list|(
name|adapter
argument_list|,
name|esdp
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* Ensure SW/FW semaphore is free */
name|ixgbe_init_swfw_semaphore
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Enable EEE power saving */
if|if
condition|(
name|adapter
operator|->
name|feat_en
operator|&
name|IXGBE_FEATURE_EEE
condition|)
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|setup_eee
argument_list|(
name|hw
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Set an initial default flow control value */
name|hw
operator|->
name|fc
operator|.
name|requested_mode
operator|=
name|ixgbe_flow_control
expr_stmt|;
comment|/* Sysctls for limiting the amount of work done in the taskqueues */
name|ixgbe_set_sysctl_value
argument_list|(
name|adapter
argument_list|,
literal|"rx_processing_limit"
argument_list|,
literal|"max number of rx packets to process"
argument_list|,
operator|&
name|adapter
operator|->
name|rx_process_limit
argument_list|,
name|ixgbe_rx_process_limit
argument_list|)
expr_stmt|;
name|ixgbe_set_sysctl_value
argument_list|(
name|adapter
argument_list|,
literal|"tx_processing_limit"
argument_list|,
literal|"max number of tx packets to process"
argument_list|,
operator|&
name|adapter
operator|->
name|tx_process_limit
argument_list|,
name|ixgbe_tx_process_limit
argument_list|)
expr_stmt|;
comment|/* Do descriptor calc and sanity checks */
if|if
condition|(
operator|(
operator|(
name|ixgbe_txd
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|ixgbe_adv_tx_desc
argument_list|)
operator|)
operator|%
name|DBA_ALIGN
operator|)
operator|!=
literal|0
operator|||
name|ixgbe_txd
operator|<
name|MIN_TXD
operator|||
name|ixgbe_txd
operator|>
name|MAX_TXD
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"TXD config issue, using default!\n"
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|num_tx_desc
operator|=
name|DEFAULT_TXD
expr_stmt|;
block|}
else|else
name|adapter
operator|->
name|num_tx_desc
operator|=
name|ixgbe_txd
expr_stmt|;
comment|/* 	 * With many RX rings it is easy to exceed the 	 * system mbuf allocation. Tuning nmbclusters 	 * can alleviate this. 	 */
if|if
condition|(
name|nmbclusters
operator|>
literal|0
condition|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
operator|(
name|ixgbe_rxd
operator|*
name|adapter
operator|->
name|num_queues
operator|)
operator|*
name|ixgbe_total_ports
expr_stmt|;
if|if
condition|(
name|s
operator|>
name|nmbclusters
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"RX Descriptors exceed system mbuf max, using default instead!\n"
argument_list|)
expr_stmt|;
name|ixgbe_rxd
operator|=
name|DEFAULT_RXD
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
operator|(
name|ixgbe_rxd
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|ixgbe_adv_rx_desc
argument_list|)
operator|)
operator|%
name|DBA_ALIGN
operator|)
operator|!=
literal|0
operator|||
name|ixgbe_rxd
operator|<
name|MIN_RXD
operator|||
name|ixgbe_rxd
operator|>
name|MAX_RXD
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"RXD config issue, using default!\n"
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|num_rx_desc
operator|=
name|DEFAULT_RXD
expr_stmt|;
block|}
else|else
name|adapter
operator|->
name|num_rx_desc
operator|=
name|ixgbe_rxd
expr_stmt|;
comment|/* Allocate our TX/RX Queues */
if|if
condition|(
name|ixgbe_allocate_queues
argument_list|(
name|adapter
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
name|hw
operator|->
name|phy
operator|.
name|reset_if_overtemp
operator|=
name|TRUE
expr_stmt|;
name|error
operator|=
name|ixgbe_reset_hw
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|reset_if_overtemp
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|IXGBE_ERR_SFP_NOT_PRESENT
condition|)
block|{
comment|/* 		 * No optics in this port, set up 		 * so the timer routine will probe 		 * for later insertion. 		 */
name|adapter
operator|->
name|sfp_probe
operator|=
name|TRUE
expr_stmt|;
name|error
operator|=
name|IXGBE_SUCCESS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|==
name|IXGBE_ERR_SFP_NOT_SUPPORTED
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unsupported SFP+ module detected!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|err_late
goto|;
block|}
elseif|else
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Hardware initialization failed\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|err_late
goto|;
block|}
comment|/* Make sure we have a good EEPROM before we read from it */
if|if
condition|(
name|ixgbe_validate_eeprom_checksum
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"The EEPROM Checksum Is Not Valid\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|err_late
goto|;
block|}
comment|/* Setup OS specific network interface */
if|if
condition|(
name|ixgbe_setup_interface
argument_list|(
name|dev
argument_list|,
name|adapter
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|err_late
goto|;
if|if
condition|(
name|adapter
operator|->
name|feat_en
operator|&
name|IXGBE_FEATURE_MSIX
condition|)
name|error
operator|=
name|ixgbe_allocate_msix
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|ixgbe_allocate_legacy
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|err_late
goto|;
name|error
operator|=
name|ixgbe_start_hw
argument_list|(
name|hw
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|error
condition|)
block|{
case|case
name|IXGBE_ERR_EEPROM_VERSION
case|:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"This device is a pre-production adapter/LOM.  Please be aware there may be issues associated with your hardware.\nIf you are experiencing problems please contact your Intel or hardware representative who provided you with this hardware.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|IXGBE_ERR_SFP_NOT_SUPPORTED
case|:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unsupported SFP+ Module\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|err_late
goto|;
case|case
name|IXGBE_ERR_SFP_NOT_PRESENT
case|:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"No SFP+ Module found\n"
argument_list|)
expr_stmt|;
comment|/* falls thru */
default|default:
break|break;
block|}
comment|/* Enable the optics for 82599 SFP+ fiber */
name|ixgbe_enable_tx_laser
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Enable power to the phy. */
name|ixgbe_set_phy_power
argument_list|(
name|hw
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Initialize statistics */
name|ixgbe_update_stats_counters
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Check PCIE slot type/speed/width */
name|ixgbe_get_slot_info
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* 	 * Do time init and sysctl init here, but 	 * only on the first port of a bypass adapter. 	 */
name|ixgbe_bypass_init
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Set an initial dmac value */
name|adapter
operator|->
name|dmac
operator|=
literal|0
expr_stmt|;
comment|/* Set initial advertised speeds (if applicable) */
name|adapter
operator|->
name|advertise
operator|=
name|ixgbe_get_advertise
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|feat_cap
operator|&
name|IXGBE_FEATURE_SRIOV
condition|)
name|ixgbe_define_iov_schemas
argument_list|(
name|dev
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
comment|/* Add sysctls */
name|ixgbe_add_device_sysctls
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixgbe_add_hw_stats
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* For Netmap */
name|adapter
operator|->
name|init_locked
operator|=
name|ixgbe_init_locked
expr_stmt|;
name|adapter
operator|->
name|stop_locked
operator|=
name|ixgbe_stop
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|feat_en
operator|&
name|IXGBE_FEATURE_NETMAP
condition|)
name|ixgbe_netmap_attach
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixgbe_attach: end"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|err_late
label|:
name|ixgbe_free_transmit_structures
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixgbe_free_receive_structures
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|adapter
operator|->
name|queues
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|err_out
label|:
if|if
condition|(
name|adapter
operator|->
name|ifp
operator|!=
name|NULL
condition|)
name|if_free
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|ctrl_ext
operator|=
name|IXGBE_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_CTRL_EXT
argument_list|)
expr_stmt|;
name|ctrl_ext
operator|&=
operator|~
name|IXGBE_CTRL_EXT_DRV_LOAD
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_CTRL_EXT
argument_list|,
name|ctrl_ext
argument_list|)
expr_stmt|;
name|ixgbe_free_pci_resources
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|adapter
operator|->
name|mta
argument_list|,
name|M_IXGBE
argument_list|)
expr_stmt|;
name|IXGBE_CORE_LOCK_DESTROY
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ixgbe_attach */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_check_wol_support  *  *   Checks whether the adapter's ports are capable of  *   Wake On LAN by reading the adapter's NVM.  *  *   Sets each port's hw->wol_enabled value depending  *   on the value read here.  ************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_check_wol_support
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|u16
name|dev_caps
init|=
literal|0
decl_stmt|;
comment|/* Find out WoL support for port */
name|adapter
operator|->
name|wol_support
operator|=
name|hw
operator|->
name|wol_enabled
operator|=
literal|0
expr_stmt|;
name|ixgbe_get_device_caps
argument_list|(
name|hw
argument_list|,
operator|&
name|dev_caps
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dev_caps
operator|&
name|IXGBE_DEVICE_CAPS_WOL_PORT0_1
operator|)
operator|||
operator|(
operator|(
name|dev_caps
operator|&
name|IXGBE_DEVICE_CAPS_WOL_PORT0
operator|)
operator|&&
name|hw
operator|->
name|bus
operator|.
name|func
operator|==
literal|0
operator|)
condition|)
name|adapter
operator|->
name|wol_support
operator|=
name|hw
operator|->
name|wol_enabled
operator|=
literal|1
expr_stmt|;
comment|/* Save initial wake up filter configuration */
name|adapter
operator|->
name|wufc
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_WUFC
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ixgbe_check_wol_support */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_setup_interface  *  *   Setup networking device structure and register an interface.  ************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_setup_interface
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixgbe_setup_interface: begin"
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|adapter
operator|->
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can not allocate ifnet structure\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_baudrate
operator|=
name|IF_Gbps
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|ixgbe_init
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|adapter
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|ixgbe_ioctl
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|1100036
name|if_setgetcounterfn
argument_list|(
name|ifp
argument_list|,
name|ixgbe_get_counter
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|1100045
comment|/* TSO parameters */
name|ifp
operator|->
name|if_hw_tsomax
operator|=
literal|65518
expr_stmt|;
name|ifp
operator|->
name|if_hw_tsomaxsegcount
operator|=
name|IXGBE_82599_SCATTER
expr_stmt|;
name|ifp
operator|->
name|if_hw_tsomaxsegsize
operator|=
literal|2048
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|adapter
operator|->
name|feat_en
operator|&
name|IXGBE_FEATURE_LEGACY_TX
condition|)
block|{
name|ifp
operator|->
name|if_start
operator|=
name|ixgbe_legacy_start
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|adapter
operator|->
name|num_tx_desc
operator|-
literal|2
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
operator|=
name|adapter
operator|->
name|num_tx_desc
operator|-
literal|2
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
name|ixgbe_start_locked
operator|=
name|ixgbe_legacy_start_locked
expr_stmt|;
name|ixgbe_ring_empty
operator|=
name|ixgbe_legacy_ring_empty
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|if_transmit
operator|=
name|ixgbe_mq_start
expr_stmt|;
name|ifp
operator|->
name|if_qflush
operator|=
name|ixgbe_qflush
expr_stmt|;
name|ixgbe_start_locked
operator|=
name|ixgbe_mq_start_locked
expr_stmt|;
name|ixgbe_ring_empty
operator|=
name|drbr_empty
expr_stmt|;
block|}
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|addr
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|max_frame_size
operator|=
name|ifp
operator|->
name|if_mtu
operator|+
name|ETHER_HDR_LEN
operator|+
name|ETHER_CRC_LEN
expr_stmt|;
comment|/* 	 * Tell the upper layer(s) we support long frames. 	 */
name|ifp
operator|->
name|if_hdrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_vlan_header
argument_list|)
expr_stmt|;
comment|/* Set capability flags */
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_HWCSUM
operator||
name|IFCAP_HWCSUM_IPV6
operator||
name|IFCAP_TSO
operator||
name|IFCAP_LRO
operator||
name|IFCAP_VLAN_HWTAGGING
operator||
name|IFCAP_VLAN_HWTSO
operator||
name|IFCAP_VLAN_HWCSUM
operator||
name|IFCAP_JUMBO_MTU
operator||
name|IFCAP_VLAN_MTU
operator||
name|IFCAP_HWSTATS
expr_stmt|;
comment|/* Enable the above capabilities by default */
name|ifp
operator|->
name|if_capenable
operator|=
name|ifp
operator|->
name|if_capabilities
expr_stmt|;
comment|/* 	 * Don't turn this on by default, if vlans are 	 * created on another pseudo device (eg. lagg) 	 * then vlan events are not passed thru, breaking 	 * operation, but with HW FILTER off it works. If 	 * using vlans directly on the ixgbe driver you can 	 * enable this and get full hardware tag filtering. 	 */
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_VLAN_HWFILTER
expr_stmt|;
comment|/* 	 * Specify the media types supported by this adapter and register 	 * callbacks to update media and link information 	 */
name|ifmedia_init
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_IMASK
argument_list|,
name|ixgbe_media_change
argument_list|,
name|ixgbe_media_status
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|phy_layer
operator|=
name|ixgbe_get_supported_physical_layer
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
name|ixgbe_add_media_types
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Set autoselect media by default */
name|ifmedia_set
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ixgbe_setup_interface */
end_comment

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|1100036
end_if

begin_comment
comment|/************************************************************************  * ixgbe_get_counter  ************************************************************************/
end_comment

begin_function
specifier|static
name|uint64_t
name|ixgbe_get_counter
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|ift_counter
name|cnt
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
decl_stmt|;
name|uint64_t
name|rv
decl_stmt|;
name|adapter
operator|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cnt
condition|)
block|{
case|case
name|IFCOUNTER_IPACKETS
case|:
return|return
operator|(
name|adapter
operator|->
name|ipackets
operator|)
return|;
case|case
name|IFCOUNTER_OPACKETS
case|:
return|return
operator|(
name|adapter
operator|->
name|opackets
operator|)
return|;
case|case
name|IFCOUNTER_IBYTES
case|:
return|return
operator|(
name|adapter
operator|->
name|ibytes
operator|)
return|;
case|case
name|IFCOUNTER_OBYTES
case|:
return|return
operator|(
name|adapter
operator|->
name|obytes
operator|)
return|;
case|case
name|IFCOUNTER_IMCASTS
case|:
return|return
operator|(
name|adapter
operator|->
name|imcasts
operator|)
return|;
case|case
name|IFCOUNTER_OMCASTS
case|:
return|return
operator|(
name|adapter
operator|->
name|omcasts
operator|)
return|;
case|case
name|IFCOUNTER_COLLISIONS
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|IFCOUNTER_IQDROPS
case|:
return|return
operator|(
name|adapter
operator|->
name|iqdrops
operator|)
return|;
case|case
name|IFCOUNTER_OQDROPS
case|:
name|rv
operator|=
literal|0
expr_stmt|;
name|txr
operator|=
name|adapter
operator|->
name|tx_rings
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|txr
operator|++
control|)
name|rv
operator|+=
name|txr
operator|->
name|br
operator|->
name|br_drops
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
case|case
name|IFCOUNTER_IERRORS
case|:
return|return
operator|(
name|adapter
operator|->
name|ierrors
operator|)
return|;
default|default:
return|return
operator|(
name|if_get_counter_default
argument_list|(
name|ifp
argument_list|,
name|cnt
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ixgbe_get_counter */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/************************************************************************  * ixgbe_add_media_types  ************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_add_media_types
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|u64
name|layer
decl_stmt|;
name|layer
operator|=
name|adapter
operator|->
name|phy_layer
expr_stmt|;
comment|/* Media types with matching FreeBSD media defines */
if|if
condition|(
name|layer
operator|&
name|IXGBE_PHYSICAL_LAYER_10GBASE_T
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10G_T
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|layer
operator|&
name|IXGBE_PHYSICAL_LAYER_1000BASE_T
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_1000_T
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|layer
operator|&
name|IXGBE_PHYSICAL_LAYER_100BASE_TX
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_100_TX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|layer
operator|&
name|IXGBE_PHYSICAL_LAYER_10BASE_T
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10_T
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|layer
operator|&
name|IXGBE_PHYSICAL_LAYER_SFP_PLUS_CU
operator|||
name|layer
operator|&
name|IXGBE_PHYSICAL_LAYER_SFP_ACTIVE_DA
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10G_TWINAX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|layer
operator|&
name|IXGBE_PHYSICAL_LAYER_10GBASE_LR
condition|)
block|{
name|ifmedia_add
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10G_LR
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|multispeed_fiber
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_1000_LX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|layer
operator|&
name|IXGBE_PHYSICAL_LAYER_10GBASE_SR
condition|)
block|{
name|ifmedia_add
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10G_SR
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|multispeed_fiber
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_1000_SX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|layer
operator|&
name|IXGBE_PHYSICAL_LAYER_1000BASE_SX
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_1000_SX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|layer
operator|&
name|IXGBE_PHYSICAL_LAYER_10GBASE_CX4
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10G_CX4
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IFM_ETH_XTYPE
if|if
condition|(
name|layer
operator|&
name|IXGBE_PHYSICAL_LAYER_10GBASE_KR
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10G_KR
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|layer
operator|&
name|IXGBE_PHYSICAL_LAYER_10GBASE_KX4
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10G_KX4
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|layer
operator|&
name|IXGBE_PHYSICAL_LAYER_1000BASE_KX
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_1000_KX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|layer
operator|&
name|IXGBE_PHYSICAL_LAYER_2500BASE_KX
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_2500_KX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|layer
operator|&
name|IXGBE_PHYSICAL_LAYER_10GBASE_KR
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Media supported: 10GbaseKR\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"10GbaseKR mapped to 10GbaseSR\n"
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10G_SR
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|layer
operator|&
name|IXGBE_PHYSICAL_LAYER_10GBASE_KX4
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Media supported: 10GbaseKX4\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"10GbaseKX4 mapped to 10GbaseCX4\n"
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10G_CX4
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|layer
operator|&
name|IXGBE_PHYSICAL_LAYER_1000BASE_KX
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Media supported: 1000baseKX\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"1000baseKX mapped to 1000baseCX\n"
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_1000_CX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|layer
operator|&
name|IXGBE_PHYSICAL_LAYER_2500BASE_KX
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Media supported: 2500baseKX\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"2500baseKX mapped to 2500baseSX\n"
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_2500_SX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|layer
operator|&
name|IXGBE_PHYSICAL_LAYER_1000BASE_BX
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Media supported: 1000baseBX\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|device_id
operator|==
name|IXGBE_DEV_ID_82598AT
condition|)
block|{
name|ifmedia_add
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_1000_T
operator||
name|IFM_FDX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_1000_T
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|ifmedia_add
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ixgbe_add_media_types */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_is_sfp  ************************************************************************/
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|ixgbe_is_sfp
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|ixgbe_mac_82598EB
case|:
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|ixgbe_phy_nl
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
case|case
name|ixgbe_mac_82599EB
case|:
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|get_media_type
argument_list|(
name|hw
argument_list|)
condition|)
block|{
case|case
name|ixgbe_media_type_fiber
case|:
case|case
name|ixgbe_media_type_fiber_qsfp
case|:
return|return
name|TRUE
return|;
default|default:
return|return
name|FALSE
return|;
block|}
case|case
name|ixgbe_mac_X550EM_x
case|:
case|case
name|ixgbe_mac_X550EM_a
case|:
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|get_media_type
argument_list|(
name|hw
argument_list|)
operator|==
name|ixgbe_media_type_fiber
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
default|default:
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_comment
comment|/* ixgbe_is_sfp */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_config_link  ************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_config_link
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|u32
name|autoneg
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
name|bool
name|sfp
decl_stmt|,
name|negotiate
decl_stmt|;
name|sfp
operator|=
name|ixgbe_is_sfp
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|sfp
condition|)
block|{
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|multispeed_fiber
condition|)
block|{
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|setup_sfp
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|ixgbe_enable_tx_laser
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|adapter
operator|->
name|tq
argument_list|,
operator|&
name|adapter
operator|->
name|msf_task
argument_list|)
expr_stmt|;
block|}
else|else
name|taskqueue_enqueue
argument_list|(
name|adapter
operator|->
name|tq
argument_list|,
operator|&
name|adapter
operator|->
name|mod_task
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|check_link
condition|)
name|err
operator|=
name|ixgbe_check_link
argument_list|(
name|hw
argument_list|,
operator|&
name|adapter
operator|->
name|link_speed
argument_list|,
operator|&
name|adapter
operator|->
name|link_up
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|autoneg
operator|=
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|autoneg
operator|)
operator|&&
operator|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|get_link_capabilities
operator|)
condition|)
name|err
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|get_link_capabilities
argument_list|(
name|hw
argument_list|,
operator|&
name|autoneg
argument_list|,
operator|&
name|negotiate
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|setup_link
condition|)
name|err
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|setup_link
argument_list|(
name|hw
argument_list|,
name|autoneg
argument_list|,
name|adapter
operator|->
name|link_up
argument_list|)
expr_stmt|;
block|}
name|out
label|:
return|return;
block|}
end_function

begin_comment
comment|/* ixgbe_config_link */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_update_stats_counters - Update board statistics counters.  ************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_update_stats_counters
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|struct
name|ixgbe_hw_stats
modifier|*
name|stats
init|=
operator|&
name|adapter
operator|->
name|stats
operator|.
name|pf
decl_stmt|;
name|u32
name|missed_rx
init|=
literal|0
decl_stmt|,
name|bprc
decl_stmt|,
name|lxon
decl_stmt|,
name|lxoff
decl_stmt|,
name|total
decl_stmt|;
name|u64
name|total_missed_rx
init|=
literal|0
decl_stmt|;
name|stats
operator|->
name|crcerrs
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CRCERRS
argument_list|)
expr_stmt|;
name|stats
operator|->
name|illerrc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ILLERRC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|errbc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ERRBC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|mspdc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MSPDC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|mpc
index|[
literal|0
index|]
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MPC
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|stats
operator|->
name|qprc
index|[
name|i
index|]
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_QPRC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|stats
operator|->
name|qptc
index|[
name|i
index|]
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_QPTC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|stats
operator|->
name|qprdc
index|[
name|i
index|]
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_QPRDC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|stats
operator|->
name|mlfc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MLFC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|mrfc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MRFC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rlec
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RLEC
argument_list|)
expr_stmt|;
comment|/* Hardware workaround, gprc counts missed packets */
name|stats
operator|->
name|gprc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GPRC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|gprc
operator|-=
name|missed_rx
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|!=
name|ixgbe_mac_82598EB
condition|)
block|{
name|stats
operator|->
name|gorc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GORCL
argument_list|)
operator|+
operator|(
operator|(
name|u64
operator|)
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GORCH
argument_list|)
operator|<<
literal|32
operator|)
expr_stmt|;
name|stats
operator|->
name|gotc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GOTCL
argument_list|)
operator|+
operator|(
operator|(
name|u64
operator|)
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GOTCH
argument_list|)
operator|<<
literal|32
operator|)
expr_stmt|;
name|stats
operator|->
name|tor
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_TORL
argument_list|)
operator|+
operator|(
operator|(
name|u64
operator|)
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_TORH
argument_list|)
operator|<<
literal|32
operator|)
expr_stmt|;
name|stats
operator|->
name|lxonrxc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LXONRXCNT
argument_list|)
expr_stmt|;
name|stats
operator|->
name|lxoffrxc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LXOFFRXCNT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stats
operator|->
name|lxonrxc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LXONRXC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|lxoffrxc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LXOFFRXC
argument_list|)
expr_stmt|;
comment|/* 82598 only has a counter in the high register */
name|stats
operator|->
name|gorc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GORCH
argument_list|)
expr_stmt|;
name|stats
operator|->
name|gotc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GOTCH
argument_list|)
expr_stmt|;
name|stats
operator|->
name|tor
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_TORH
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Workaround: mprc hardware is incorrectly counting 	 * broadcasts, so for now we subtract those. 	 */
name|bprc
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_BPRC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|bprc
operator|+=
name|bprc
expr_stmt|;
name|stats
operator|->
name|mprc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MPRC
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_82598EB
condition|)
name|stats
operator|->
name|mprc
operator|-=
name|bprc
expr_stmt|;
name|stats
operator|->
name|prc64
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PRC64
argument_list|)
expr_stmt|;
name|stats
operator|->
name|prc127
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PRC127
argument_list|)
expr_stmt|;
name|stats
operator|->
name|prc255
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PRC255
argument_list|)
expr_stmt|;
name|stats
operator|->
name|prc511
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PRC511
argument_list|)
expr_stmt|;
name|stats
operator|->
name|prc1023
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PRC1023
argument_list|)
expr_stmt|;
name|stats
operator|->
name|prc1522
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PRC1522
argument_list|)
expr_stmt|;
name|lxon
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LXONTXC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|lxontxc
operator|+=
name|lxon
expr_stmt|;
name|lxoff
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LXOFFTXC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|lxofftxc
operator|+=
name|lxoff
expr_stmt|;
name|total
operator|=
name|lxon
operator|+
name|lxoff
expr_stmt|;
name|stats
operator|->
name|gptc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GPTC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|mptc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MPTC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|ptc64
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PTC64
argument_list|)
expr_stmt|;
name|stats
operator|->
name|gptc
operator|-=
name|total
expr_stmt|;
name|stats
operator|->
name|mptc
operator|-=
name|total
expr_stmt|;
name|stats
operator|->
name|ptc64
operator|-=
name|total
expr_stmt|;
name|stats
operator|->
name|gotc
operator|-=
name|total
operator|*
name|ETHER_MIN_LEN
expr_stmt|;
name|stats
operator|->
name|ruc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RUC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rfc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RFC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|roc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ROC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rjc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RJC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|mngprc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MNGPRC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|mngpdc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MNGPDC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|mngptc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MNGPTC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|tpr
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_TPR
argument_list|)
expr_stmt|;
name|stats
operator|->
name|tpt
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_TPT
argument_list|)
expr_stmt|;
name|stats
operator|->
name|ptc127
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PTC127
argument_list|)
expr_stmt|;
name|stats
operator|->
name|ptc255
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PTC255
argument_list|)
expr_stmt|;
name|stats
operator|->
name|ptc511
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PTC511
argument_list|)
expr_stmt|;
name|stats
operator|->
name|ptc1023
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PTC1023
argument_list|)
expr_stmt|;
name|stats
operator|->
name|ptc1522
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PTC1522
argument_list|)
expr_stmt|;
name|stats
operator|->
name|bptc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_BPTC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|xec
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_XEC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|fccrc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCCRC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|fclast
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCLAST
argument_list|)
expr_stmt|;
comment|/* Only read FCOE on 82599 */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|!=
name|ixgbe_mac_82598EB
condition|)
block|{
name|stats
operator|->
name|fcoerpdc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCOERPDC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|fcoeprc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCOEPRC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|fcoeptc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCOEPTC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|fcoedwrc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCOEDWRC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|fcoedwtc
operator|+=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCOEDWTC
argument_list|)
expr_stmt|;
block|}
comment|/* Fill out the OS statistics structure */
name|IXGBE_SET_IPACKETS
argument_list|(
name|adapter
argument_list|,
name|stats
operator|->
name|gprc
argument_list|)
expr_stmt|;
name|IXGBE_SET_OPACKETS
argument_list|(
name|adapter
argument_list|,
name|stats
operator|->
name|gptc
argument_list|)
expr_stmt|;
name|IXGBE_SET_IBYTES
argument_list|(
name|adapter
argument_list|,
name|stats
operator|->
name|gorc
argument_list|)
expr_stmt|;
name|IXGBE_SET_OBYTES
argument_list|(
name|adapter
argument_list|,
name|stats
operator|->
name|gotc
argument_list|)
expr_stmt|;
name|IXGBE_SET_IMCASTS
argument_list|(
name|adapter
argument_list|,
name|stats
operator|->
name|mprc
argument_list|)
expr_stmt|;
name|IXGBE_SET_OMCASTS
argument_list|(
name|adapter
argument_list|,
name|stats
operator|->
name|mptc
argument_list|)
expr_stmt|;
name|IXGBE_SET_COLLISIONS
argument_list|(
name|adapter
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IXGBE_SET_IQDROPS
argument_list|(
name|adapter
argument_list|,
name|total_missed_rx
argument_list|)
expr_stmt|;
name|IXGBE_SET_IERRORS
argument_list|(
name|adapter
argument_list|,
name|stats
operator|->
name|crcerrs
operator|+
name|stats
operator|->
name|rlec
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ixgbe_update_stats_counters */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_add_hw_stats  *  *   Add sysctl variables, one per statistic, to the system.  ************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_add_hw_stats
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
name|adapter
operator|->
name|rx_rings
decl_stmt|;
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
init|=
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|tree
init|=
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|child
init|=
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
decl_stmt|;
name|struct
name|ixgbe_hw_stats
modifier|*
name|stats
init|=
operator|&
name|adapter
operator|->
name|stats
operator|.
name|pf
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|stat_node
decl_stmt|,
modifier|*
name|queue_node
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|stat_list
decl_stmt|,
modifier|*
name|queue_list
decl_stmt|;
define|#
directive|define
name|QUEUE_NAME_LEN
value|32
name|char
name|namebuf
index|[
name|QUEUE_NAME_LEN
index|]
decl_stmt|;
comment|/* Driver Statistics */
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dropped"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|dropped_pkts
argument_list|,
literal|"Driver dropped packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mbuf_defrag_failed"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|mbuf_defrag_failed
argument_list|,
literal|"m_defrag() failed"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"watchdog_events"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|watchdog_events
argument_list|,
literal|"Watchdog timeouts"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"link_irq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|link_irq
argument_list|,
literal|"Link MSI-X IRQ Handled"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|txr
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|namebuf
argument_list|,
name|QUEUE_NAME_LEN
argument_list|,
literal|"queue%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|queue_node
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
name|namebuf
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"Queue Name"
argument_list|)
expr_stmt|;
name|queue_list
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|queue_node
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"interrupt_rate"
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|adapter
operator|->
name|queues
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
operator|&
name|adapter
operator|->
name|queues
index|[
name|i
index|]
argument_list|)
argument_list|,
name|ixgbe_sysctl_interrupt_rate_handler
argument_list|,
literal|"IU"
argument_list|,
literal|"Interrupt Rate"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"irqs"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|adapter
operator|->
name|queues
index|[
name|i
index|]
operator|.
name|irqs
operator|)
argument_list|,
literal|"irqs on this queue"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"txd_head"
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RD
argument_list|,
name|txr
argument_list|,
sizeof|sizeof
argument_list|(
name|txr
argument_list|)
argument_list|,
name|ixgbe_sysctl_tdh_handler
argument_list|,
literal|"IU"
argument_list|,
literal|"Transmit Descriptor Head"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"txd_tail"
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RD
argument_list|,
name|txr
argument_list|,
sizeof|sizeof
argument_list|(
name|txr
argument_list|)
argument_list|,
name|ixgbe_sysctl_tdt_handler
argument_list|,
literal|"IU"
argument_list|,
literal|"Transmit Descriptor Tail"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tso_tx"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txr
operator|->
name|tso_tx
argument_list|,
literal|"TSO"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"no_tx_dma_setup"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txr
operator|->
name|no_tx_dma_setup
argument_list|,
literal|"Driver tx dma failure in xmit"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"no_desc_avail"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txr
operator|->
name|no_desc_avail
argument_list|,
literal|"Queue No Descriptor Available"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_packets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txr
operator|->
name|total_packets
argument_list|,
literal|"Queue Packets Transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"br_drops"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txr
operator|->
name|br
operator|->
name|br_drops
argument_list|,
literal|"Packets dropped in buf_ring"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|rxr
operator|++
control|)
block|{
name|struct
name|lro_ctrl
modifier|*
name|lro
init|=
operator|&
name|rxr
operator|->
name|lro
decl_stmt|;
name|snprintf
argument_list|(
name|namebuf
argument_list|,
name|QUEUE_NAME_LEN
argument_list|,
literal|"queue%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|queue_node
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
name|namebuf
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"Queue Name"
argument_list|)
expr_stmt|;
name|queue_list
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|queue_node
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rxd_head"
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RD
argument_list|,
name|rxr
argument_list|,
sizeof|sizeof
argument_list|(
name|rxr
argument_list|)
argument_list|,
name|ixgbe_sysctl_rdh_handler
argument_list|,
literal|"IU"
argument_list|,
literal|"Receive Descriptor Head"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rxd_tail"
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RD
argument_list|,
name|rxr
argument_list|,
sizeof|sizeof
argument_list|(
name|rxr
argument_list|)
argument_list|,
name|ixgbe_sysctl_rdt_handler
argument_list|,
literal|"IU"
argument_list|,
literal|"Receive Descriptor Tail"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_packets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|rxr
operator|->
name|rx_packets
argument_list|,
literal|"Queue Packets Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_bytes"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|rxr
operator|->
name|rx_bytes
argument_list|,
literal|"Queue Bytes Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_copies"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|rxr
operator|->
name|rx_copies
argument_list|,
literal|"Copied RX Frames"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_discarded"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|rxr
operator|->
name|rx_discarded
argument_list|,
literal|"Discarded RX packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_U64
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"lro_queued"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|lro
operator|->
name|lro_queued
argument_list|,
literal|0
argument_list|,
literal|"LRO Queued"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_U64
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"lro_flushed"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|lro
operator|->
name|lro_flushed
argument_list|,
literal|0
argument_list|,
literal|"LRO Flushed"
argument_list|)
expr_stmt|;
block|}
comment|/* MAC stats get their own sub node */
name|stat_node
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mac_stats"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"MAC Statistics"
argument_list|)
expr_stmt|;
name|stat_list
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|stat_node
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"crc_errs"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|crcerrs
argument_list|,
literal|"CRC Errors"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ill_errs"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|illerrc
argument_list|,
literal|"Illegal Byte Errors"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"byte_errs"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|errbc
argument_list|,
literal|"Byte Errors"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"short_discards"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|mspdc
argument_list|,
literal|"MAC Short Packets Discarded"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"local_faults"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|mlfc
argument_list|,
literal|"MAC Local Faults"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"remote_faults"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|mrfc
argument_list|,
literal|"MAC Remote Faults"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rec_len_errs"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|rlec
argument_list|,
literal|"Receive Length Errors"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_missed_packets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|mpc
index|[
literal|0
index|]
argument_list|,
literal|"RX Missed Packet Count"
argument_list|)
expr_stmt|;
comment|/* Flow Control stats */
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"xon_txd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|lxontxc
argument_list|,
literal|"Link XON Transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"xon_recvd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|lxonrxc
argument_list|,
literal|"Link XON Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"xoff_txd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|lxofftxc
argument_list|,
literal|"Link XOFF Transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"xoff_recvd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|lxoffrxc
argument_list|,
literal|"Link XOFF Received"
argument_list|)
expr_stmt|;
comment|/* Packet Reception Stats */
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"total_octets_rcvd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|tor
argument_list|,
literal|"Total Octets Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"good_octets_rcvd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|gorc
argument_list|,
literal|"Good Octets Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"total_pkts_rcvd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|tpr
argument_list|,
literal|"Total Packets Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"good_pkts_rcvd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|gprc
argument_list|,
literal|"Good Packets Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mcast_pkts_rcvd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|mprc
argument_list|,
literal|"Multicast Packets Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"bcast_pkts_rcvd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|bprc
argument_list|,
literal|"Broadcast Packets Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_frames_64"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|prc64
argument_list|,
literal|"64 byte frames received "
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_frames_65_127"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|prc127
argument_list|,
literal|"65-127 byte frames received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_frames_128_255"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|prc255
argument_list|,
literal|"128-255 byte frames received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_frames_256_511"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|prc511
argument_list|,
literal|"256-511 byte frames received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_frames_512_1023"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|prc1023
argument_list|,
literal|"512-1023 byte frames received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_frames_1024_1522"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|prc1522
argument_list|,
literal|"1023-1522 byte frames received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"recv_undersized"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|ruc
argument_list|,
literal|"Receive Undersized"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"recv_fragmented"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|rfc
argument_list|,
literal|"Fragmented Packets Received "
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"recv_oversized"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|roc
argument_list|,
literal|"Oversized Packets Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"recv_jabberd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|rjc
argument_list|,
literal|"Received Jabber"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"management_pkts_rcvd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|mngprc
argument_list|,
literal|"Management Packets Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"management_pkts_drpd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|mngptc
argument_list|,
literal|"Management Packets Dropped"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"checksum_errs"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|xec
argument_list|,
literal|"Checksum Errors"
argument_list|)
expr_stmt|;
comment|/* Packet Transmission Stats */
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"good_octets_txd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|gotc
argument_list|,
literal|"Good Octets Transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"total_pkts_txd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|tpt
argument_list|,
literal|"Total Packets Transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"good_pkts_txd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|gptc
argument_list|,
literal|"Good Packets Transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"bcast_pkts_txd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|bptc
argument_list|,
literal|"Broadcast Packets Transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mcast_pkts_txd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|mptc
argument_list|,
literal|"Multicast Packets Transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"management_pkts_txd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|mngptc
argument_list|,
literal|"Management Packets Transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_frames_64"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|ptc64
argument_list|,
literal|"64 byte frames transmitted "
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_frames_65_127"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|ptc127
argument_list|,
literal|"65-127 byte frames transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_frames_128_255"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|ptc255
argument_list|,
literal|"128-255 byte frames transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_frames_256_511"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|ptc511
argument_list|,
literal|"256-511 byte frames transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_frames_512_1023"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|ptc1023
argument_list|,
literal|"512-1023 byte frames transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_frames_1024_1522"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|ptc1522
argument_list|,
literal|"1024-1522 byte frames transmitted"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ixgbe_add_hw_stats */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_sysctl_tdh_handler - Transmit Descriptor Head handler function  *  *   Retrieves the TDH value from the hardware  ************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_sysctl_tdh_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|(
operator|(
expr|struct
name|tx_ring
operator|*
operator|)
name|oidp
operator|->
name|oid_arg1
operator|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|unsigned
name|int
name|val
decl_stmt|;
if|if
condition|(
operator|!
name|txr
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|val
operator|=
name|IXGBE_READ_REG
argument_list|(
operator|&
name|txr
operator|->
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_TDH
argument_list|(
name|txr
operator|->
name|me
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
name|error
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ixgbe_sysctl_tdh_handler */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_sysctl_tdt_handler - Transmit Descriptor Tail handler function  *  *   Retrieves the TDT value from the hardware  ************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_sysctl_tdt_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|(
operator|(
expr|struct
name|tx_ring
operator|*
operator|)
name|oidp
operator|->
name|oid_arg1
operator|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|unsigned
name|int
name|val
decl_stmt|;
if|if
condition|(
operator|!
name|txr
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|val
operator|=
name|IXGBE_READ_REG
argument_list|(
operator|&
name|txr
operator|->
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_TDT
argument_list|(
name|txr
operator|->
name|me
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
name|error
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ixgbe_sysctl_tdt_handler */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_sysctl_rdh_handler - Receive Descriptor Head handler function  *  *   Retrieves the RDH value from the hardware  ************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_sysctl_rdh_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
operator|(
operator|(
expr|struct
name|rx_ring
operator|*
operator|)
name|oidp
operator|->
name|oid_arg1
operator|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|unsigned
name|int
name|val
decl_stmt|;
if|if
condition|(
operator|!
name|rxr
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|val
operator|=
name|IXGBE_READ_REG
argument_list|(
operator|&
name|rxr
operator|->
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_RDH
argument_list|(
name|rxr
operator|->
name|me
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
name|error
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ixgbe_sysctl_rdh_handler */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_sysctl_rdt_handler - Receive Descriptor Tail handler function  *  *   Retrieves the RDT value from the hardware  ************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_sysctl_rdt_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
operator|(
operator|(
expr|struct
name|rx_ring
operator|*
operator|)
name|oidp
operator|->
name|oid_arg1
operator|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|unsigned
name|int
name|val
decl_stmt|;
if|if
condition|(
operator|!
name|rxr
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|val
operator|=
name|IXGBE_READ_REG
argument_list|(
operator|&
name|rxr
operator|->
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_RDT
argument_list|(
name|rxr
operator|->
name|me
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
name|error
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ixgbe_sysctl_rdt_handler */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_register_vlan  *  *   Run via vlan config EVENT, it enables us to use the  *   HW Filter table since we can get the vlan id. This  *   just creates the entry in the soft version of the  *   VFTA, init will repopulate the real table.  ************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_register_vlan
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u16
name|vtag
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|u16
name|index
decl_stmt|,
name|bit
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_softc
operator|!=
name|arg
condition|)
comment|/* Not our event */
return|return;
if|if
condition|(
operator|(
name|vtag
operator|==
literal|0
operator|)
operator|||
operator|(
name|vtag
operator|>
literal|4095
operator|)
condition|)
comment|/* Invalid */
return|return;
name|IXGBE_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|index
operator|=
operator|(
name|vtag
operator|>>
literal|5
operator|)
operator|&
literal|0x7F
expr_stmt|;
name|bit
operator|=
name|vtag
operator|&
literal|0x1F
expr_stmt|;
name|adapter
operator|->
name|shadow_vfta
index|[
name|index
index|]
operator||=
operator|(
literal|1
operator|<<
name|bit
operator|)
expr_stmt|;
operator|++
name|adapter
operator|->
name|num_vlans
expr_stmt|;
name|ixgbe_setup_vlan_hw_support
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|IXGBE_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ixgbe_register_vlan */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_unregister_vlan  *  *   Run via vlan unconfig EVENT, remove our entry in the soft vfta.  ************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_unregister_vlan
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u16
name|vtag
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|u16
name|index
decl_stmt|,
name|bit
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_softc
operator|!=
name|arg
condition|)
return|return;
if|if
condition|(
operator|(
name|vtag
operator|==
literal|0
operator|)
operator|||
operator|(
name|vtag
operator|>
literal|4095
operator|)
condition|)
comment|/* Invalid */
return|return;
name|IXGBE_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|index
operator|=
operator|(
name|vtag
operator|>>
literal|5
operator|)
operator|&
literal|0x7F
expr_stmt|;
name|bit
operator|=
name|vtag
operator|&
literal|0x1F
expr_stmt|;
name|adapter
operator|->
name|shadow_vfta
index|[
name|index
index|]
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|bit
operator|)
expr_stmt|;
operator|--
name|adapter
operator|->
name|num_vlans
expr_stmt|;
comment|/* Re-init to load the changes */
name|ixgbe_setup_vlan_hw_support
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|IXGBE_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ixgbe_unregister_vlan */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_setup_vlan_hw_support  ************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_setup_vlan_hw_support
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u32
name|ctrl
decl_stmt|;
comment|/* 	 * We get here thru init_locked, meaning 	 * a soft reset, this has already cleared 	 * the VFTA and other state, so if there 	 * have been no vlan's registered do nothing. 	 */
if|if
condition|(
name|adapter
operator|->
name|num_vlans
operator|==
literal|0
condition|)
return|return;
comment|/* Setup the queues for vlans */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|rxr
operator|=
operator|&
name|adapter
operator|->
name|rx_rings
index|[
name|i
index|]
expr_stmt|;
comment|/* On 82599 the VLAN enable is per/queue in RXDCTL */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|!=
name|ixgbe_mac_82598EB
condition|)
block|{
name|ctrl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXDCTL
argument_list|(
name|rxr
operator|->
name|me
argument_list|)
argument_list|)
expr_stmt|;
name|ctrl
operator||=
name|IXGBE_RXDCTL_VME
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXDCTL
argument_list|(
name|rxr
operator|->
name|me
argument_list|)
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
block|}
name|rxr
operator|->
name|vtag_strip
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWFILTER
operator|)
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * A soft reset zero's out the VFTA, so 	 * we need to repopulate it now. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_VFTA_SIZE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|adapter
operator|->
name|shadow_vfta
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VFTA
argument_list|(
name|i
argument_list|)
argument_list|,
name|adapter
operator|->
name|shadow_vfta
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VLNCTRL
argument_list|)
expr_stmt|;
comment|/* Enable the Filter Table if enabled */
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWFILTER
condition|)
block|{
name|ctrl
operator|&=
operator|~
name|IXGBE_VLNCTRL_CFIEN
expr_stmt|;
name|ctrl
operator||=
name|IXGBE_VLNCTRL_VFE
expr_stmt|;
block|}
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_82598EB
condition|)
name|ctrl
operator||=
name|IXGBE_VLNCTRL_VME
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VLNCTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ixgbe_setup_vlan_hw_support */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_get_slot_info  *  *   Get the width and transaction speed of  *   the slot this adapter is plugged into.  ************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_get_slot_info
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|u32
name|offset
decl_stmt|;
name|u16
name|link
decl_stmt|;
name|int
name|bus_info_valid
init|=
name|TRUE
decl_stmt|;
comment|/* Some devices are behind an internal bridge */
switch|switch
condition|(
name|hw
operator|->
name|device_id
condition|)
block|{
case|case
name|IXGBE_DEV_ID_82599_SFP_SF_QP
case|:
case|case
name|IXGBE_DEV_ID_82599_QSFP_SF_QP
case|:
goto|goto
name|get_parent_info
goto|;
default|default:
break|break;
block|}
name|ixgbe_get_bus_info
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* 	 * Some devices don't use PCI-E, but there is no need 	 * to display "Unknown" for bus speed and width. 	 */
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|ixgbe_mac_X550EM_x
case|:
case|case
name|ixgbe_mac_X550EM_a
case|:
return|return;
default|default:
goto|goto
name|display
goto|;
block|}
name|get_parent_info
label|:
comment|/* 	 * For the Quad port adapter we need to parse back 	 * up the PCI tree to find the speed of the expansion 	 * slot into which this adapter is plugged. A bit more work. 	 */
name|dev
operator|=
name|device_get_parent
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IXGBE_DEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"parent pcib = %x,%x,%x\n"
argument_list|,
name|pci_get_bus
argument_list|(
name|dev
argument_list|)
argument_list|,
name|pci_get_slot
argument_list|(
name|dev
argument_list|)
argument_list|,
name|pci_get_function
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dev
operator|=
name|device_get_parent
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IXGBE_DEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"slot pcib = %x,%x,%x\n"
argument_list|,
name|pci_get_bus
argument_list|(
name|dev
argument_list|)
argument_list|,
name|pci_get_slot
argument_list|(
name|dev
argument_list|)
argument_list|,
name|pci_get_function
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Now get the PCI Express Capabilities offset */
if|if
condition|(
name|pci_find_cap
argument_list|(
name|dev
argument_list|,
name|PCIY_EXPRESS
argument_list|,
operator|&
name|offset
argument_list|)
condition|)
block|{
comment|/* 		 * Hmm...can't get PCI-Express capabilities. 		 * Falling back to default method. 		 */
name|bus_info_valid
operator|=
name|FALSE
expr_stmt|;
name|ixgbe_get_bus_info
argument_list|(
name|hw
argument_list|)
expr_stmt|;
goto|goto
name|display
goto|;
block|}
comment|/* ...and read the Link Status Register */
name|link
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|offset
operator|+
name|PCIER_LINK_STA
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ixgbe_set_pci_config_data_generic
argument_list|(
name|hw
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|display
label|:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"PCI Express Bus: Speed %s %s\n"
argument_list|,
operator|(
operator|(
name|hw
operator|->
name|bus
operator|.
name|speed
operator|==
name|ixgbe_bus_speed_8000
operator|)
condition|?
literal|"8.0GT/s"
else|:
operator|(
name|hw
operator|->
name|bus
operator|.
name|speed
operator|==
name|ixgbe_bus_speed_5000
operator|)
condition|?
literal|"5.0GT/s"
else|:
operator|(
name|hw
operator|->
name|bus
operator|.
name|speed
operator|==
name|ixgbe_bus_speed_2500
operator|)
condition|?
literal|"2.5GT/s"
else|:
literal|"Unknown"
operator|)
argument_list|,
operator|(
operator|(
name|hw
operator|->
name|bus
operator|.
name|width
operator|==
name|ixgbe_bus_width_pcie_x8
operator|)
condition|?
literal|"Width x8"
else|:
operator|(
name|hw
operator|->
name|bus
operator|.
name|width
operator|==
name|ixgbe_bus_width_pcie_x4
operator|)
condition|?
literal|"Width x4"
else|:
operator|(
name|hw
operator|->
name|bus
operator|.
name|width
operator|==
name|ixgbe_bus_width_pcie_x1
operator|)
condition|?
literal|"Width x1"
else|:
literal|"Unknown"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_info_valid
condition|)
block|{
if|if
condition|(
operator|(
name|hw
operator|->
name|device_id
operator|!=
name|IXGBE_DEV_ID_82599_SFP_SF_QP
operator|)
operator|&&
operator|(
operator|(
name|hw
operator|->
name|bus
operator|.
name|width
operator|<=
name|ixgbe_bus_width_pcie_x4
operator|)
operator|&&
operator|(
name|hw
operator|->
name|bus
operator|.
name|speed
operator|==
name|ixgbe_bus_speed_2500
operator|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"PCI-Express bandwidth available for this card\n     is not sufficient for optimal performance.\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"For optimal performance a x8 PCIE, or x4 PCIE Gen2 slot is required.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|hw
operator|->
name|device_id
operator|==
name|IXGBE_DEV_ID_82599_SFP_SF_QP
operator|)
operator|&&
operator|(
operator|(
name|hw
operator|->
name|bus
operator|.
name|width
operator|<=
name|ixgbe_bus_width_pcie_x8
operator|)
operator|&&
operator|(
name|hw
operator|->
name|bus
operator|.
name|speed
operator|<
name|ixgbe_bus_speed_8000
operator|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"PCI-Express bandwidth available for this card\n     is not sufficient for optimal performance.\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"For optimal performance a x8 PCIE Gen3 slot is required.\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to determine slot speed/width. The speed/width reported are that of the internal switch.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ixgbe_get_slot_info */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_enable_queue - MSI-X Interrupt Handlers and Tasklets  ************************************************************************/
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ixgbe_enable_queue
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|u32
name|vector
parameter_list|)
block|{
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|u64
name|queue
init|=
call|(
name|u64
call|)
argument_list|(
literal|1
operator|<<
name|vector
argument_list|)
decl_stmt|;
name|u32
name|mask
decl_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_82598EB
condition|)
block|{
name|mask
operator|=
operator|(
name|IXGBE_EIMS_RTX_QUEUE
operator|&
name|queue
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EIMS
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mask
operator|=
operator|(
name|queue
operator|&
literal|0xFFFFFFFF
operator|)
expr_stmt|;
if|if
condition|(
name|mask
condition|)
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EIMS_EX
argument_list|(
literal|0
argument_list|)
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|mask
operator|=
operator|(
name|queue
operator|>>
literal|32
operator|)
expr_stmt|;
if|if
condition|(
name|mask
condition|)
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EIMS_EX
argument_list|(
literal|1
argument_list|)
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ixgbe_enable_queue */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_disable_queue  ************************************************************************/
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ixgbe_disable_queue
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|u32
name|vector
parameter_list|)
block|{
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|u64
name|queue
init|=
call|(
name|u64
call|)
argument_list|(
literal|1
operator|<<
name|vector
argument_list|)
decl_stmt|;
name|u32
name|mask
decl_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_82598EB
condition|)
block|{
name|mask
operator|=
operator|(
name|IXGBE_EIMS_RTX_QUEUE
operator|&
name|queue
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EIMC
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mask
operator|=
operator|(
name|queue
operator|&
literal|0xFFFFFFFF
operator|)
expr_stmt|;
if|if
condition|(
name|mask
condition|)
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EIMC_EX
argument_list|(
literal|0
argument_list|)
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|mask
operator|=
operator|(
name|queue
operator|>>
literal|32
operator|)
expr_stmt|;
if|if
condition|(
name|mask
condition|)
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EIMC_EX
argument_list|(
literal|1
argument_list|)
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ixgbe_disable_queue */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_msix_que - MSI-X Queue Interrupt Service routine  ************************************************************************/
end_comment

begin_function
name|void
name|ixgbe_msix_que
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ix_queue
modifier|*
name|que
init|=
name|arg
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|que
operator|->
name|adapter
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|que
operator|->
name|txr
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
name|que
operator|->
name|rxr
decl_stmt|;
name|bool
name|more
decl_stmt|;
name|u32
name|newitr
init|=
literal|0
decl_stmt|;
comment|/* Protect against spurious interrupts */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return;
name|ixgbe_disable_queue
argument_list|(
name|adapter
argument_list|,
name|que
operator|->
name|msix
argument_list|)
expr_stmt|;
operator|++
name|que
operator|->
name|irqs
expr_stmt|;
name|more
operator|=
name|ixgbe_rxeof
argument_list|(
name|que
argument_list|)
expr_stmt|;
name|IXGBE_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|ixgbe_txeof
argument_list|(
name|txr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ixgbe_ring_empty
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|)
condition|)
name|ixgbe_start_locked
argument_list|(
name|ifp
argument_list|,
name|txr
argument_list|)
expr_stmt|;
name|IXGBE_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
comment|/* Do AIM now? */
if|if
condition|(
name|adapter
operator|->
name|enable_aim
operator|==
name|FALSE
condition|)
goto|goto
name|no_calc
goto|;
comment|/* 	 * Do Adaptive Interrupt Moderation: 	 *  - Write out last calculated setting 	 *  - Calculate based on average size over 	 *    the last interval. 	 */
if|if
condition|(
name|que
operator|->
name|eitr_setting
condition|)
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_EITR
argument_list|(
name|que
operator|->
name|msix
argument_list|)
argument_list|,
name|que
operator|->
name|eitr_setting
argument_list|)
expr_stmt|;
name|que
operator|->
name|eitr_setting
operator|=
literal|0
expr_stmt|;
comment|/* Idle, do nothing */
if|if
condition|(
operator|(
name|txr
operator|->
name|bytes
operator|==
literal|0
operator|)
operator|&&
operator|(
name|rxr
operator|->
name|bytes
operator|==
literal|0
operator|)
condition|)
goto|goto
name|no_calc
goto|;
if|if
condition|(
operator|(
name|txr
operator|->
name|bytes
operator|)
operator|&&
operator|(
name|txr
operator|->
name|packets
operator|)
condition|)
name|newitr
operator|=
name|txr
operator|->
name|bytes
operator|/
name|txr
operator|->
name|packets
expr_stmt|;
if|if
condition|(
operator|(
name|rxr
operator|->
name|bytes
operator|)
operator|&&
operator|(
name|rxr
operator|->
name|packets
operator|)
condition|)
name|newitr
operator|=
name|max
argument_list|(
name|newitr
argument_list|,
operator|(
name|rxr
operator|->
name|bytes
operator|/
name|rxr
operator|->
name|packets
operator|)
argument_list|)
expr_stmt|;
name|newitr
operator|+=
literal|24
expr_stmt|;
comment|/* account for hardware frame, crc */
comment|/* set an upper boundary */
name|newitr
operator|=
name|min
argument_list|(
name|newitr
argument_list|,
literal|3000
argument_list|)
expr_stmt|;
comment|/* Be nice to the mid range */
if|if
condition|(
operator|(
name|newitr
operator|>
literal|300
operator|)
operator|&&
operator|(
name|newitr
operator|<
literal|1200
operator|)
condition|)
name|newitr
operator|=
operator|(
name|newitr
operator|/
literal|3
operator|)
expr_stmt|;
else|else
name|newitr
operator|=
operator|(
name|newitr
operator|/
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_82598EB
condition|)
name|newitr
operator||=
name|newitr
operator|<<
literal|16
expr_stmt|;
else|else
name|newitr
operator||=
name|IXGBE_EITR_CNT_WDIS
expr_stmt|;
comment|/* save for next interrupt */
name|que
operator|->
name|eitr_setting
operator|=
name|newitr
expr_stmt|;
comment|/* Reset state */
name|txr
operator|->
name|bytes
operator|=
literal|0
expr_stmt|;
name|txr
operator|->
name|packets
operator|=
literal|0
expr_stmt|;
name|rxr
operator|->
name|bytes
operator|=
literal|0
expr_stmt|;
name|rxr
operator|->
name|packets
operator|=
literal|0
expr_stmt|;
name|no_calc
label|:
if|if
condition|(
name|more
condition|)
name|taskqueue_enqueue
argument_list|(
name|que
operator|->
name|tq
argument_list|,
operator|&
name|que
operator|->
name|que_task
argument_list|)
expr_stmt|;
else|else
name|ixgbe_enable_queue
argument_list|(
name|adapter
argument_list|,
name|que
operator|->
name|msix
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ixgbe_msix_que */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_media_status - Media Ioctl callback  *  *   Called whenever the user queries the status of  *   the interface using ifconfig.  ************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|int
name|layer
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixgbe_media_status: begin"
argument_list|)
expr_stmt|;
name|IXGBE_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixgbe_update_link_status
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
expr_stmt|;
if|if
condition|(
operator|!
name|adapter
operator|->
name|link_active
condition|)
block|{
name|IXGBE_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return;
block|}
name|ifmr
operator|->
name|ifm_status
operator||=
name|IFM_ACTIVE
expr_stmt|;
name|layer
operator|=
name|adapter
operator|->
name|phy_layer
expr_stmt|;
if|if
condition|(
name|layer
operator|&
name|IXGBE_PHYSICAL_LAYER_10GBASE_T
operator|||
name|layer
operator|&
name|IXGBE_PHYSICAL_LAYER_1000BASE_T
operator|||
name|layer
operator|&
name|IXGBE_PHYSICAL_LAYER_100BASE_TX
operator|||
name|layer
operator|&
name|IXGBE_PHYSICAL_LAYER_10BASE_T
condition|)
switch|switch
condition|(
name|adapter
operator|->
name|link_speed
condition|)
block|{
case|case
name|IXGBE_LINK_SPEED_10GB_FULL
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10G_T
operator||
name|IFM_FDX
expr_stmt|;
break|break;
case|case
name|IXGBE_LINK_SPEED_1GB_FULL
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_1000_T
operator||
name|IFM_FDX
expr_stmt|;
break|break;
case|case
name|IXGBE_LINK_SPEED_100_FULL
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_100_TX
operator||
name|IFM_FDX
expr_stmt|;
break|break;
case|case
name|IXGBE_LINK_SPEED_10_FULL
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10_T
operator||
name|IFM_FDX
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|layer
operator|&
name|IXGBE_PHYSICAL_LAYER_SFP_PLUS_CU
operator|||
name|layer
operator|&
name|IXGBE_PHYSICAL_LAYER_SFP_ACTIVE_DA
condition|)
switch|switch
condition|(
name|adapter
operator|->
name|link_speed
condition|)
block|{
case|case
name|IXGBE_LINK_SPEED_10GB_FULL
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10G_TWINAX
operator||
name|IFM_FDX
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|layer
operator|&
name|IXGBE_PHYSICAL_LAYER_10GBASE_LR
condition|)
switch|switch
condition|(
name|adapter
operator|->
name|link_speed
condition|)
block|{
case|case
name|IXGBE_LINK_SPEED_10GB_FULL
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10G_LR
operator||
name|IFM_FDX
expr_stmt|;
break|break;
case|case
name|IXGBE_LINK_SPEED_1GB_FULL
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_1000_LX
operator||
name|IFM_FDX
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|layer
operator|&
name|IXGBE_PHYSICAL_LAYER_10GBASE_LRM
condition|)
switch|switch
condition|(
name|adapter
operator|->
name|link_speed
condition|)
block|{
case|case
name|IXGBE_LINK_SPEED_10GB_FULL
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10G_LRM
operator||
name|IFM_FDX
expr_stmt|;
break|break;
case|case
name|IXGBE_LINK_SPEED_1GB_FULL
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_1000_LX
operator||
name|IFM_FDX
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|layer
operator|&
name|IXGBE_PHYSICAL_LAYER_10GBASE_SR
operator|||
name|layer
operator|&
name|IXGBE_PHYSICAL_LAYER_1000BASE_SX
condition|)
switch|switch
condition|(
name|adapter
operator|->
name|link_speed
condition|)
block|{
case|case
name|IXGBE_LINK_SPEED_10GB_FULL
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10G_SR
operator||
name|IFM_FDX
expr_stmt|;
break|break;
case|case
name|IXGBE_LINK_SPEED_1GB_FULL
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_1000_SX
operator||
name|IFM_FDX
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|layer
operator|&
name|IXGBE_PHYSICAL_LAYER_10GBASE_CX4
condition|)
switch|switch
condition|(
name|adapter
operator|->
name|link_speed
condition|)
block|{
case|case
name|IXGBE_LINK_SPEED_10GB_FULL
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10G_CX4
operator||
name|IFM_FDX
expr_stmt|;
break|break;
block|}
comment|/* 	 * XXX: These need to use the proper media types once 	 * they're added. 	 */
ifndef|#
directive|ifndef
name|IFM_ETH_XTYPE
if|if
condition|(
name|layer
operator|&
name|IXGBE_PHYSICAL_LAYER_10GBASE_KR
condition|)
switch|switch
condition|(
name|adapter
operator|->
name|link_speed
condition|)
block|{
case|case
name|IXGBE_LINK_SPEED_10GB_FULL
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10G_SR
operator||
name|IFM_FDX
expr_stmt|;
break|break;
case|case
name|IXGBE_LINK_SPEED_2_5GB_FULL
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_2500_SX
operator||
name|IFM_FDX
expr_stmt|;
break|break;
case|case
name|IXGBE_LINK_SPEED_1GB_FULL
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_1000_CX
operator||
name|IFM_FDX
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|layer
operator|&
name|IXGBE_PHYSICAL_LAYER_10GBASE_KX4
operator|||
name|layer
operator|&
name|IXGBE_PHYSICAL_LAYER_2500BASE_KX
operator|||
name|layer
operator|&
name|IXGBE_PHYSICAL_LAYER_1000BASE_KX
condition|)
switch|switch
condition|(
name|adapter
operator|->
name|link_speed
condition|)
block|{
case|case
name|IXGBE_LINK_SPEED_10GB_FULL
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10G_CX4
operator||
name|IFM_FDX
expr_stmt|;
break|break;
case|case
name|IXGBE_LINK_SPEED_2_5GB_FULL
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_2500_SX
operator||
name|IFM_FDX
expr_stmt|;
break|break;
case|case
name|IXGBE_LINK_SPEED_1GB_FULL
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_1000_CX
operator||
name|IFM_FDX
expr_stmt|;
break|break;
block|}
else|#
directive|else
if|if
condition|(
name|layer
operator|&
name|IXGBE_PHYSICAL_LAYER_10GBASE_KR
condition|)
switch|switch
condition|(
name|adapter
operator|->
name|link_speed
condition|)
block|{
case|case
name|IXGBE_LINK_SPEED_10GB_FULL
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10G_KR
operator||
name|IFM_FDX
expr_stmt|;
break|break;
case|case
name|IXGBE_LINK_SPEED_2_5GB_FULL
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_2500_KX
operator||
name|IFM_FDX
expr_stmt|;
break|break;
case|case
name|IXGBE_LINK_SPEED_1GB_FULL
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_1000_KX
operator||
name|IFM_FDX
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|layer
operator|&
name|IXGBE_PHYSICAL_LAYER_10GBASE_KX4
operator|||
name|layer
operator|&
name|IXGBE_PHYSICAL_LAYER_2500BASE_KX
operator|||
name|layer
operator|&
name|IXGBE_PHYSICAL_LAYER_1000BASE_KX
condition|)
switch|switch
condition|(
name|adapter
operator|->
name|link_speed
condition|)
block|{
case|case
name|IXGBE_LINK_SPEED_10GB_FULL
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10G_KX4
operator||
name|IFM_FDX
expr_stmt|;
break|break;
case|case
name|IXGBE_LINK_SPEED_2_5GB_FULL
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_2500_KX
operator||
name|IFM_FDX
expr_stmt|;
break|break;
case|case
name|IXGBE_LINK_SPEED_1GB_FULL
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_1000_KX
operator||
name|IFM_FDX
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* If nothing is recognized... */
if|if
condition|(
name|IFM_SUBTYPE
argument_list|(
name|ifmr
operator|->
name|ifm_active
argument_list|)
operator|==
literal|0
condition|)
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_UNKNOWN
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|900025
comment|/* Display current flow control setting used on link */
if|if
condition|(
name|hw
operator|->
name|fc
operator|.
name|current_mode
operator|==
name|ixgbe_fc_rx_pause
operator|||
name|hw
operator|->
name|fc
operator|.
name|current_mode
operator|==
name|ixgbe_fc_full
condition|)
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_ETH_RXPAUSE
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|fc
operator|.
name|current_mode
operator|==
name|ixgbe_fc_tx_pause
operator|||
name|hw
operator|->
name|fc
operator|.
name|current_mode
operator|==
name|ixgbe_fc_full
condition|)
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_ETH_TXPAUSE
expr_stmt|;
endif|#
directive|endif
name|IXGBE_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ixgbe_media_status */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_media_change - Media Ioctl callback  *  *   Called when the user changes speed/duplex using  *   media/mediopt option with ifconfig.  ************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifmedia
modifier|*
name|ifm
init|=
operator|&
name|adapter
operator|->
name|media
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|ixgbe_link_speed
name|speed
init|=
literal|0
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixgbe_media_change: begin"
argument_list|)
expr_stmt|;
if|if
condition|(
name|IFM_TYPE
argument_list|(
name|ifm
operator|->
name|ifm_media
argument_list|)
operator|!=
name|IFM_ETHER
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|==
name|ixgbe_media_type_backplane
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
comment|/* 	 * We don't actually need to check against the supported 	 * media types of the adapter; ifmedia will take care of 	 * that for us. 	 */
switch|switch
condition|(
name|IFM_SUBTYPE
argument_list|(
name|ifm
operator|->
name|ifm_media
argument_list|)
condition|)
block|{
case|case
name|IFM_AUTO
case|:
case|case
name|IFM_10G_T
case|:
name|speed
operator||=
name|IXGBE_LINK_SPEED_100_FULL
expr_stmt|;
name|speed
operator||=
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
name|speed
operator||=
name|IXGBE_LINK_SPEED_10GB_FULL
expr_stmt|;
break|break;
case|case
name|IFM_10G_LRM
case|:
case|case
name|IFM_10G_LR
case|:
ifndef|#
directive|ifndef
name|IFM_ETH_XTYPE
case|case
name|IFM_10G_SR
case|:
comment|/* KR, too */
case|case
name|IFM_10G_CX4
case|:
comment|/* KX4 */
else|#
directive|else
case|case
name|IFM_10G_KR
case|:
case|case
name|IFM_10G_KX4
case|:
endif|#
directive|endif
name|speed
operator||=
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
name|speed
operator||=
name|IXGBE_LINK_SPEED_10GB_FULL
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|IFM_ETH_XTYPE
case|case
name|IFM_1000_CX
case|:
comment|/* KX */
else|#
directive|else
case|case
name|IFM_1000_KX
case|:
endif|#
directive|endif
case|case
name|IFM_1000_LX
case|:
case|case
name|IFM_1000_SX
case|:
name|speed
operator||=
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
break|break;
case|case
name|IFM_1000_T
case|:
name|speed
operator||=
name|IXGBE_LINK_SPEED_100_FULL
expr_stmt|;
name|speed
operator||=
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
break|break;
case|case
name|IFM_10G_TWINAX
case|:
name|speed
operator||=
name|IXGBE_LINK_SPEED_10GB_FULL
expr_stmt|;
break|break;
case|case
name|IFM_100_TX
case|:
name|speed
operator||=
name|IXGBE_LINK_SPEED_100_FULL
expr_stmt|;
break|break;
case|case
name|IFM_10_T
case|:
name|speed
operator||=
name|IXGBE_LINK_SPEED_10_FULL
expr_stmt|;
break|break;
default|default:
goto|goto
name|invalid
goto|;
block|}
name|hw
operator|->
name|mac
operator|.
name|autotry_restart
operator|=
name|TRUE
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|setup_link
argument_list|(
name|hw
argument_list|,
name|speed
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|advertise
operator|=
operator|(
operator|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_10GB_FULL
operator|)
condition|?
literal|4
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_1GB_FULL
operator|)
condition|?
literal|2
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_100_FULL
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_10_FULL
operator|)
condition|?
literal|8
else|:
literal|0
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|invalid
label|:
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"Invalid media type!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ixgbe_media_change */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_set_promisc  ************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_set_promisc
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|int
name|mcnt
init|=
literal|0
decl_stmt|;
name|u32
name|rctl
decl_stmt|;
name|rctl
operator|=
name|IXGBE_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_FCTRL
argument_list|)
expr_stmt|;
name|rctl
operator|&=
operator|(
operator|~
name|IXGBE_FCTRL_UPE
operator|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
condition|)
name|mcnt
operator|=
name|MAX_NUM_MULTICAST_ADDRESSES
expr_stmt|;
else|else
block|{
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|800000
name|IF_ADDR_LOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
else|#
directive|else
name|if_maddr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
if|if
condition|(
name|mcnt
operator|==
name|MAX_NUM_MULTICAST_ADDRESSES
condition|)
break|break;
name|mcnt
operator|++
expr_stmt|;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|800000
name|IF_ADDR_UNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
else|#
directive|else
name|if_maddr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|mcnt
operator|<
name|MAX_NUM_MULTICAST_ADDRESSES
condition|)
name|rctl
operator|&=
operator|(
operator|~
name|IXGBE_FCTRL_MPE
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_FCTRL
argument_list|,
name|rctl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
name|rctl
operator||=
operator|(
name|IXGBE_FCTRL_UPE
operator||
name|IXGBE_FCTRL_MPE
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_FCTRL
argument_list|,
name|rctl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
condition|)
block|{
name|rctl
operator||=
name|IXGBE_FCTRL_MPE
expr_stmt|;
name|rctl
operator|&=
operator|~
name|IXGBE_FCTRL_UPE
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_FCTRL
argument_list|,
name|rctl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ixgbe_set_promisc */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_msix_link - Link status change ISR (MSI/MSI-X)  ************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_msix_link
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|arg
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|u32
name|eicr
decl_stmt|,
name|eicr_mask
decl_stmt|;
name|s32
name|retval
decl_stmt|;
operator|++
name|adapter
operator|->
name|link_irq
expr_stmt|;
comment|/* Pause other interrupts */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EIMC
argument_list|,
name|IXGBE_EIMC_OTHER
argument_list|)
expr_stmt|;
comment|/* First get the cause */
name|eicr
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EICS
argument_list|)
expr_stmt|;
comment|/* Be sure the queue bits are not cleared */
name|eicr
operator|&=
operator|~
name|IXGBE_EICR_RTX_QUEUE
expr_stmt|;
comment|/* Clear interrupt with write */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EICR
argument_list|,
name|eicr
argument_list|)
expr_stmt|;
comment|/* Link status change */
if|if
condition|(
name|eicr
operator|&
name|IXGBE_EICR_LSC
condition|)
block|{
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EIMC
argument_list|,
name|IXGBE_EIMC_LSC
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|adapter
operator|->
name|tq
argument_list|,
operator|&
name|adapter
operator|->
name|link_task
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|!=
name|ixgbe_mac_82598EB
condition|)
block|{
if|if
condition|(
operator|(
name|adapter
operator|->
name|feat_en
operator|&
name|IXGBE_FEATURE_FDIR
operator|)
operator|&&
operator|(
name|eicr
operator|&
name|IXGBE_EICR_FLOW_DIR
operator|)
condition|)
block|{
comment|/* This is probably overkill :) */
if|if
condition|(
operator|!
name|atomic_cmpset_int
argument_list|(
operator|&
name|adapter
operator|->
name|fdir_reinit
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
return|return;
comment|/* Disable the interrupt */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EIMC
argument_list|,
name|IXGBE_EIMC_FLOW_DIR
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|adapter
operator|->
name|tq
argument_list|,
operator|&
name|adapter
operator|->
name|fdir_task
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|eicr
operator|&
name|IXGBE_EICR_ECC
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"CRITICAL: ECC ERROR!!  Please Reboot!!\n"
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EICR
argument_list|,
name|IXGBE_EICR_ECC
argument_list|)
expr_stmt|;
block|}
comment|/* Check for over temp condition */
if|if
condition|(
name|adapter
operator|->
name|feat_en
operator|&
name|IXGBE_FEATURE_TEMP_SENSOR
condition|)
block|{
switch|switch
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|ixgbe_mac_X550EM_a
case|:
if|if
condition|(
operator|!
operator|(
name|eicr
operator|&
name|IXGBE_EICR_GPI_SDP0_X550EM_a
operator|)
condition|)
break|break;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EIMC
argument_list|,
name|IXGBE_EICR_GPI_SDP0_X550EM_a
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EICR
argument_list|,
name|IXGBE_EICR_GPI_SDP0_X550EM_a
argument_list|)
expr_stmt|;
name|retval
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|check_overtemp
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|IXGBE_ERR_OVERTEMP
condition|)
break|break;
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"CRITICAL: OVER TEMP!! PHY IS SHUT DOWN!!\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"System shutdown required!\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|!
operator|(
name|eicr
operator|&
name|IXGBE_EICR_TS
operator|)
condition|)
break|break;
name|retval
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|check_overtemp
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|IXGBE_ERR_OVERTEMP
condition|)
break|break;
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"CRITICAL: OVER TEMP!! PHY IS SHUT DOWN!!\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"System shutdown required!\n"
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EICR
argument_list|,
name|IXGBE_EICR_TS
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Check for VF message */
if|if
condition|(
operator|(
name|adapter
operator|->
name|feat_en
operator|&
name|IXGBE_FEATURE_SRIOV
operator|)
operator|&&
operator|(
name|eicr
operator|&
name|IXGBE_EICR_MAILBOX
operator|)
condition|)
name|taskqueue_enqueue
argument_list|(
name|adapter
operator|->
name|tq
argument_list|,
operator|&
name|adapter
operator|->
name|mbx_task
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ixgbe_is_sfp
argument_list|(
name|hw
argument_list|)
condition|)
block|{
comment|/* Pluggable optics-related interrupt */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|>=
name|ixgbe_mac_X540
condition|)
name|eicr_mask
operator|=
name|IXGBE_EICR_GPI_SDP0_X540
expr_stmt|;
else|else
name|eicr_mask
operator|=
name|IXGBE_EICR_GPI_SDP2_BY_MAC
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|eicr
operator|&
name|eicr_mask
condition|)
block|{
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EICR
argument_list|,
name|eicr_mask
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|adapter
operator|->
name|tq
argument_list|,
operator|&
name|adapter
operator|->
name|mod_task
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_82599EB
operator|)
operator|&&
operator|(
name|eicr
operator|&
name|IXGBE_EICR_GPI_SDP1_BY_MAC
argument_list|(
name|hw
argument_list|)
operator|)
condition|)
block|{
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EICR
argument_list|,
name|IXGBE_EICR_GPI_SDP1_BY_MAC
argument_list|(
name|hw
argument_list|)
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|adapter
operator|->
name|tq
argument_list|,
operator|&
name|adapter
operator|->
name|msf_task
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Check for fan failure */
if|if
condition|(
name|adapter
operator|->
name|feat_en
operator|&
name|IXGBE_FEATURE_FAN_FAIL
condition|)
block|{
name|ixgbe_check_fan_failure
argument_list|(
name|adapter
argument_list|,
name|eicr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EICR
argument_list|,
name|IXGBE_EICR_GPI_SDP1_BY_MAC
argument_list|(
name|hw
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* External PHY interrupt */
if|if
condition|(
operator|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|ixgbe_phy_x550em_ext_t
operator|)
operator|&&
operator|(
name|eicr
operator|&
name|IXGBE_EICR_GPI_SDP0_X540
operator|)
condition|)
block|{
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EICR
argument_list|,
name|IXGBE_EICR_GPI_SDP0_X540
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|adapter
operator|->
name|tq
argument_list|,
operator|&
name|adapter
operator|->
name|phy_task
argument_list|)
expr_stmt|;
block|}
comment|/* Re-enable other interrupts */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EIMS
argument_list|,
name|IXGBE_EIMS_OTHER
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ixgbe_msix_link */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_sysctl_interrupt_rate_handler  ************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_sysctl_interrupt_rate_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ix_queue
modifier|*
name|que
init|=
operator|(
operator|(
expr|struct
name|ix_queue
operator|*
operator|)
name|oidp
operator|->
name|oid_arg1
operator|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|unsigned
name|int
name|reg
decl_stmt|,
name|usec
decl_stmt|,
name|rate
decl_stmt|;
name|reg
operator|=
name|IXGBE_READ_REG
argument_list|(
operator|&
name|que
operator|->
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_EITR
argument_list|(
name|que
operator|->
name|msix
argument_list|)
argument_list|)
expr_stmt|;
name|usec
operator|=
operator|(
operator|(
name|reg
operator|&
literal|0x0FF8
operator|)
operator|>>
literal|3
operator|)
expr_stmt|;
if|if
condition|(
name|usec
operator|>
literal|0
condition|)
name|rate
operator|=
literal|500000
operator|/
name|usec
expr_stmt|;
else|else
name|rate
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|rate
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
name|error
return|;
name|reg
operator|&=
operator|~
literal|0xfff
expr_stmt|;
comment|/* default, no limitation */
name|ixgbe_max_interrupt_rate
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rate
operator|>
literal|0
operator|&&
name|rate
operator|<
literal|500000
condition|)
block|{
if|if
condition|(
name|rate
operator|<
literal|1000
condition|)
name|rate
operator|=
literal|1000
expr_stmt|;
name|ixgbe_max_interrupt_rate
operator|=
name|rate
expr_stmt|;
name|reg
operator||=
operator|(
operator|(
literal|4000000
operator|/
name|rate
operator|)
operator|&
literal|0xff8
operator|)
expr_stmt|;
block|}
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|que
operator|->
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_EITR
argument_list|(
name|que
operator|->
name|msix
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ixgbe_sysctl_interrupt_rate_handler */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_add_device_sysctls  ************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_add_device_sysctls
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|child
decl_stmt|;
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
decl_stmt|;
name|ctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|child
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Sysctls for all devices */
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"fc"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|adapter
argument_list|,
literal|0
argument_list|,
name|ixgbe_sysctl_flowcntl
argument_list|,
literal|"I"
argument_list|,
name|IXGBE_SYSCTL_DESC_SET_FC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|enable_aim
operator|=
name|ixgbe_enable_aim
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"enable_aim"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|adapter
operator|->
name|enable_aim
argument_list|,
literal|1
argument_list|,
literal|"Interrupt Moderation"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"advertise_speed"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|adapter
argument_list|,
literal|0
argument_list|,
name|ixgbe_sysctl_advertise
argument_list|,
literal|"I"
argument_list|,
name|IXGBE_SYSCTL_DESC_ADV_SPEED
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IXGBE_DEBUG
comment|/* testing sysctls (for all devices) */
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"power_state"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|adapter
argument_list|,
literal|0
argument_list|,
name|ixgbe_sysctl_power_state
argument_list|,
literal|"I"
argument_list|,
literal|"PCI Power State"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"print_rss_config"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|adapter
argument_list|,
literal|0
argument_list|,
name|ixgbe_sysctl_print_rss_config
argument_list|,
literal|"A"
argument_list|,
literal|"Prints RSS Configuration"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* for X550 series devices */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|>=
name|ixgbe_mac_X550
condition|)
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dmac"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|adapter
argument_list|,
literal|0
argument_list|,
name|ixgbe_sysctl_dmac
argument_list|,
literal|"I"
argument_list|,
literal|"DMA Coalesce"
argument_list|)
expr_stmt|;
comment|/* for WoL-capable devices */
if|if
condition|(
name|hw
operator|->
name|device_id
operator|==
name|IXGBE_DEV_ID_X550EM_X_10G_T
condition|)
block|{
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"wol_enable"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|adapter
argument_list|,
literal|0
argument_list|,
name|ixgbe_sysctl_wol_enable
argument_list|,
literal|"I"
argument_list|,
literal|"Enable/Disable Wake on LAN"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"wufc"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|adapter
argument_list|,
literal|0
argument_list|,
name|ixgbe_sysctl_wufc
argument_list|,
literal|"I"
argument_list|,
literal|"Enable/Disable Wake Up Filters"
argument_list|)
expr_stmt|;
block|}
comment|/* for X552/X557-AT devices */
if|if
condition|(
name|hw
operator|->
name|device_id
operator|==
name|IXGBE_DEV_ID_X550EM_X_10G_T
condition|)
block|{
name|struct
name|sysctl_oid
modifier|*
name|phy_node
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|phy_list
decl_stmt|;
name|phy_node
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"phy"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"External PHY sysctls"
argument_list|)
expr_stmt|;
name|phy_list
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|phy_node
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|phy_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"temp"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
name|adapter
argument_list|,
literal|0
argument_list|,
name|ixgbe_sysctl_phy_temp
argument_list|,
literal|"I"
argument_list|,
literal|"Current External PHY Temperature (Celsius)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|phy_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"overtemp_occurred"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
name|adapter
argument_list|,
literal|0
argument_list|,
name|ixgbe_sysctl_phy_overtemp_occurred
argument_list|,
literal|"I"
argument_list|,
literal|"External PHY High Temperature Event Occurred"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|adapter
operator|->
name|feat_cap
operator|&
name|IXGBE_FEATURE_EEE
condition|)
block|{
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"eee_state"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|adapter
argument_list|,
literal|0
argument_list|,
name|ixgbe_sysctl_eee_state
argument_list|,
literal|"I"
argument_list|,
literal|"EEE Power Save State"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ixgbe_add_device_sysctls */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_allocate_pci_resources  ************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_allocate_pci_resources
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|rid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|pci_mem
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|adapter
operator|->
name|pci_mem
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate bus resource: memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Save bus_space values for READ/WRITE_REG macros */
name|adapter
operator|->
name|osdep
operator|.
name|mem_bus_space_tag
operator|=
name|rman_get_bustag
argument_list|(
name|adapter
operator|->
name|pci_mem
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|osdep
operator|.
name|mem_bus_space_handle
operator|=
name|rman_get_bushandle
argument_list|(
name|adapter
operator|->
name|pci_mem
argument_list|)
expr_stmt|;
comment|/* Set hw values for shared code */
name|adapter
operator|->
name|hw
operator|.
name|hw_addr
operator|=
operator|(
name|u8
operator|*
operator|)
operator|&
name|adapter
operator|->
name|osdep
operator|.
name|mem_bus_space_handle
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ixgbe_allocate_pci_resources */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_detach - Device removal routine  *  *   Called when the driver is being removed.  *   Stops the adapter and deallocates all the resources  *   that were allocated for driver operation.  *  *   return 0 on success, positive on failure  ************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ix_queue
modifier|*
name|que
init|=
name|adapter
operator|->
name|queues
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
name|u32
name|ctrl_ext
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixgbe_detach: begin"
argument_list|)
expr_stmt|;
comment|/* Make sure VLANS are not using driver */
if|if
condition|(
name|adapter
operator|->
name|ifp
operator|->
name|if_vlantrunk
operator|!=
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Vlan in use, detach first\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
if|if
condition|(
name|ixgbe_pci_iov_detach
argument_list|(
name|dev
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"SR-IOV in use; detach first.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|ether_ifdetach
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|)
expr_stmt|;
comment|/* Stop the adapter */
name|IXGBE_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixgbe_setup_low_power_mode
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|IXGBE_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
operator|,
name|txr
operator|++
control|)
block|{
if|if
condition|(
name|que
operator|->
name|tq
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|adapter
operator|->
name|feat_en
operator|&
name|IXGBE_FEATURE_LEGACY_TX
operator|)
condition|)
name|taskqueue_drain
argument_list|(
name|que
operator|->
name|tq
argument_list|,
operator|&
name|txr
operator|->
name|txq_task
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|que
operator|->
name|tq
argument_list|,
operator|&
name|que
operator|->
name|que_task
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|que
operator|->
name|tq
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Drain the Link queue */
if|if
condition|(
name|adapter
operator|->
name|tq
condition|)
block|{
name|taskqueue_drain
argument_list|(
name|adapter
operator|->
name|tq
argument_list|,
operator|&
name|adapter
operator|->
name|link_task
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|adapter
operator|->
name|tq
argument_list|,
operator|&
name|adapter
operator|->
name|mod_task
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|adapter
operator|->
name|tq
argument_list|,
operator|&
name|adapter
operator|->
name|msf_task
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|feat_cap
operator|&
name|IXGBE_FEATURE_SRIOV
condition|)
name|taskqueue_drain
argument_list|(
name|adapter
operator|->
name|tq
argument_list|,
operator|&
name|adapter
operator|->
name|mbx_task
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|adapter
operator|->
name|tq
argument_list|,
operator|&
name|adapter
operator|->
name|phy_task
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|feat_en
operator|&
name|IXGBE_FEATURE_FDIR
condition|)
name|taskqueue_drain
argument_list|(
name|adapter
operator|->
name|tq
argument_list|,
operator|&
name|adapter
operator|->
name|fdir_task
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|adapter
operator|->
name|tq
argument_list|)
expr_stmt|;
block|}
comment|/* let hardware know driver is unloading */
name|ctrl_ext
operator|=
name|IXGBE_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_CTRL_EXT
argument_list|)
expr_stmt|;
name|ctrl_ext
operator|&=
operator|~
name|IXGBE_CTRL_EXT_DRV_LOAD
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_CTRL_EXT
argument_list|,
name|ctrl_ext
argument_list|)
expr_stmt|;
comment|/* Unregister VLAN events */
if|if
condition|(
name|adapter
operator|->
name|vlan_attach
operator|!=
name|NULL
condition|)
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|vlan_config
argument_list|,
name|adapter
operator|->
name|vlan_attach
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|vlan_detach
operator|!=
name|NULL
condition|)
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|vlan_unconfig
argument_list|,
name|adapter
operator|->
name|vlan_detach
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|feat_en
operator|&
name|IXGBE_FEATURE_NETMAP
condition|)
name|netmap_detach
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|ixgbe_free_pci_resources
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|bus_generic_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|ixgbe_free_transmit_structures
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixgbe_free_receive_structures
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|adapter
operator|->
name|queues
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|adapter
operator|->
name|mta
argument_list|,
name|M_IXGBE
argument_list|)
expr_stmt|;
name|IXGBE_CORE_LOCK_DESTROY
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ixgbe_detach */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_setup_low_power_mode - LPLU/WoL preparation  *  *   Prepare the adapter/port for LPLU and/or WoL  ************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_setup_low_power_mode
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|s32
name|error
init|=
literal|0
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|adapter
operator|->
name|core_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* Limit power management flow to X550EM baseT */
if|if
condition|(
name|hw
operator|->
name|device_id
operator|==
name|IXGBE_DEV_ID_X550EM_X_10G_T
operator|&&
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|enter_lplu
condition|)
block|{
comment|/* Turn off support for APM wakeup. (Using ACPI instead) */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GRC
argument_list|,
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GRC
argument_list|)
operator|&
operator|~
operator|(
name|u32
operator|)
literal|2
argument_list|)
expr_stmt|;
comment|/* 		 * Clear Wake Up Status register to prevent any previous wakeup 		 * events from waking us up immediately after we suspend. 		 */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_WUS
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
comment|/* 		 * Program the Wakeup Filter Control register with user filter 		 * settings 		 */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_WUFC
argument_list|,
name|adapter
operator|->
name|wufc
argument_list|)
expr_stmt|;
comment|/* Enable wakeups and power management in Wakeup Control */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_WUC
argument_list|,
name|IXGBE_WUC_WKEN
operator||
name|IXGBE_WUC_PME_EN
argument_list|)
expr_stmt|;
comment|/* X550EM baseT adapters need a special LPLU flow */
name|hw
operator|->
name|phy
operator|.
name|reset_disable
operator|=
name|true
expr_stmt|;
name|ixgbe_stop
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|error
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|enter_lplu
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Error entering LPLU: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|reset_disable
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
comment|/* Just stop for other adapters */
name|ixgbe_stop
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* ixgbe_setup_low_power_mode */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_shutdown - Shutdown entry point  ************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixgbe_shutdown: begin"
argument_list|)
expr_stmt|;
name|IXGBE_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|error
operator|=
name|ixgbe_setup_low_power_mode
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|IXGBE_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ixgbe_shutdown */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_suspend  *  *   From D0 to D3  ************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixgbe_suspend: begin"
argument_list|)
expr_stmt|;
name|IXGBE_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|error
operator|=
name|ixgbe_setup_low_power_mode
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|IXGBE_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ixgbe_suspend */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_resume  *  *   From D3 to D0  ************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|u32
name|wus
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixgbe_resume: begin"
argument_list|)
expr_stmt|;
name|IXGBE_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Read& clear WUS register */
name|wus
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_WUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|wus
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Woken up by (WUS): %#010x\n"
argument_list|,
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_WUS
argument_list|)
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_WUS
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
comment|/* And clear WUFC until next low-power transition */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_WUFC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Required after D3->D0 transition; 	 * will re-advertise all previous advertised speeds 	 */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
name|ixgbe_init_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|IXGBE_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ixgbe_resume */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_set_if_hwassist - Set the various hardware offload abilities.  *  *   Takes the ifnet's if_capenable flags (e.g. set by the user using  *   ifconfig) and indicates to the OS via the ifnet's if_hwassist  *   field what mbuf offload flags the driver will understand.  ************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_set_if_hwassist
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|1000000
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO4
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
name|CSUM_IP_TSO
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO6
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
name|CSUM_IP6_TSO
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM
condition|)
block|{
name|ifp
operator|->
name|if_hwassist
operator||=
operator|(
name|CSUM_IP
operator||
name|CSUM_IP_UDP
operator||
name|CSUM_IP_TCP
operator|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|!=
name|ixgbe_mac_82598EB
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
name|CSUM_IP_SCTP
expr_stmt|;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM_IPV6
condition|)
block|{
name|ifp
operator|->
name|if_hwassist
operator||=
operator|(
name|CSUM_IP6_UDP
operator||
name|CSUM_IP6_TCP
operator|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|!=
name|ixgbe_mac_82598EB
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
name|CSUM_IP6_SCTP
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
name|CSUM_TSO
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM
condition|)
block|{
name|ifp
operator|->
name|if_hwassist
operator||=
operator|(
name|CSUM_TCP
operator||
name|CSUM_UDP
operator|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|!=
name|ixgbe_mac_82598EB
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
name|CSUM_SCTP
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ixgbe_set_if_hwassist */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_init_locked - Init entry point  *  *   Used in two ways: It is used by the stack as an init  *   entry point in network interface structure. It is also  *   used by the driver as a hw/sw initialization routine to  *   get to a consistent state.  *  *   return 0 on success, positive on failure  ************************************************************************/
end_comment

begin_function
name|void
name|ixgbe_init_locked
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
decl_stmt|;
name|u32
name|txdctl
decl_stmt|,
name|mhadd
decl_stmt|;
name|u32
name|rxdctl
decl_stmt|,
name|rxctrl
decl_stmt|;
name|u32
name|ctrl_ext
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|adapter
operator|->
name|core_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixgbe_init_locked: begin"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|adapter_stopped
operator|=
name|FALSE
expr_stmt|;
name|ixgbe_stop_adapter
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|)
expr_stmt|;
comment|/* Queue indices may change with IOV mode */
name|ixgbe_align_all_queue_indices
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* reprogram the RAR[0] in case user changed it. */
name|ixgbe_set_rar
argument_list|(
name|hw
argument_list|,
literal|0
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|,
name|adapter
operator|->
name|pool
argument_list|,
name|IXGBE_RAH_AV
argument_list|)
expr_stmt|;
comment|/* Get the latest mac address, User can use a LAA */
name|bcopy
argument_list|(
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|,
name|IXGBE_ETH_LENGTH_OF_ADDRESS
argument_list|)
expr_stmt|;
name|ixgbe_set_rar
argument_list|(
name|hw
argument_list|,
literal|0
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|,
name|adapter
operator|->
name|pool
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hw
operator|->
name|addr_ctrl
operator|.
name|rar_used_count
operator|=
literal|1
expr_stmt|;
comment|/* Set hardware offload abilities from ifnet flags */
name|ixgbe_set_if_hwassist
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Prepare transmit descriptors and buffers */
if|if
condition|(
name|ixgbe_setup_transmit_structures
argument_list|(
name|adapter
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not setup transmit structures\n"
argument_list|)
expr_stmt|;
name|ixgbe_stop
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return;
block|}
name|ixgbe_init_hw
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|ixgbe_initialize_iov
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixgbe_initialize_transmit_units
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Setup Multicast table */
name|ixgbe_set_multi
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Determine the correct mbuf pool, based on frame size */
if|if
condition|(
name|adapter
operator|->
name|max_frame_size
operator|<=
name|MCLBYTES
condition|)
name|adapter
operator|->
name|rx_mbuf_sz
operator|=
name|MCLBYTES
expr_stmt|;
else|else
name|adapter
operator|->
name|rx_mbuf_sz
operator|=
name|MJUMPAGESIZE
expr_stmt|;
comment|/* Prepare receive descriptors and buffers */
if|if
condition|(
name|ixgbe_setup_receive_structures
argument_list|(
name|adapter
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not setup receive structures\n"
argument_list|)
expr_stmt|;
name|ixgbe_stop
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Configure RX settings */
name|ixgbe_initialize_receive_units
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Enable SDP& MSI-X interrupts based on adapter */
name|ixgbe_config_gpie
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Set MTU size */
if|if
condition|(
name|ifp
operator|->
name|if_mtu
operator|>
name|ETHERMTU
condition|)
block|{
comment|/* aka IXGBE_MAXFRS on 82599 and newer */
name|mhadd
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MHADD
argument_list|)
expr_stmt|;
name|mhadd
operator|&=
operator|~
name|IXGBE_MHADD_MFS_MASK
expr_stmt|;
name|mhadd
operator||=
name|adapter
operator|->
name|max_frame_size
operator|<<
name|IXGBE_MHADD_MFS_SHIFT
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MHADD
argument_list|,
name|mhadd
argument_list|)
expr_stmt|;
block|}
comment|/* Now enable all the queues */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|txr
operator|=
operator|&
name|adapter
operator|->
name|tx_rings
index|[
name|i
index|]
expr_stmt|;
name|txdctl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_TXDCTL
argument_list|(
name|txr
operator|->
name|me
argument_list|)
argument_list|)
expr_stmt|;
name|txdctl
operator||=
name|IXGBE_TXDCTL_ENABLE
expr_stmt|;
comment|/* Set WTHRESH to 8, burst writeback */
name|txdctl
operator||=
operator|(
literal|8
operator|<<
literal|16
operator|)
expr_stmt|;
comment|/* 		 * When the internal queue falls below PTHRESH (32), 		 * start prefetching as long as there are at least 		 * HTHRESH (1) buffers ready. The values are taken 		 * from the Intel linux driver 3.8.21. 		 * Prefetching enables tx line rate even with 1 queue. 		 */
name|txdctl
operator||=
operator|(
literal|32
operator|<<
literal|0
operator|)
operator||
operator|(
literal|1
operator|<<
literal|8
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_TXDCTL
argument_list|(
name|txr
operator|->
name|me
argument_list|)
argument_list|,
name|txdctl
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|j
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|rxr
operator|=
operator|&
name|adapter
operator|->
name|rx_rings
index|[
name|i
index|]
expr_stmt|;
name|rxdctl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXDCTL
argument_list|(
name|rxr
operator|->
name|me
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_82598EB
condition|)
block|{
comment|/* 			 * PTHRESH = 21 			 * HTHRESH = 4 			 * WTHRESH = 8 			 */
name|rxdctl
operator|&=
operator|~
literal|0x3FFFFF
expr_stmt|;
name|rxdctl
operator||=
literal|0x080420
expr_stmt|;
block|}
name|rxdctl
operator||=
name|IXGBE_RXDCTL_ENABLE
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXDCTL
argument_list|(
name|rxr
operator|->
name|me
argument_list|)
argument_list|,
name|rxdctl
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|j
operator|<
literal|10
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXDCTL
argument_list|(
name|rxr
operator|->
name|me
argument_list|)
argument_list|)
operator|&
name|IXGBE_RXDCTL_ENABLE
condition|)
break|break;
else|else
name|msec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|wmb
argument_list|()
expr_stmt|;
comment|/* 		 * In netmap mode, we must preserve the buffers made 		 * available to userspace before the if_init() 		 * (this is true by default on the TX side, because 		 * init makes all buffers available to userspace). 		 * 		 * netmap_reset() and the device specific routines 		 * (e.g. ixgbe_setup_receive_rings()) map these 		 * buffers at the end of the NIC ring, so here we 		 * must set the RDT (tail) register to make sure 		 * they are not overwritten. 		 * 		 * In this driver the NIC ring starts at RDH = 0, 		 * RDT points to the last slot available for reception (?), 		 * so RDT = num_rx_desc - 1 means the whole ring is available. 		 */
ifdef|#
directive|ifdef
name|DEV_NETMAP
if|if
condition|(
operator|(
name|adapter
operator|->
name|feat_en
operator|&
name|IXGBE_FEATURE_NETMAP
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_NETMAP
operator|)
condition|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
decl_stmt|;
name|int
name|t
init|=
name|na
operator|->
name|num_rx_desc
operator|-
literal|1
operator|-
name|nm_kr_rxspace
argument_list|(
name|kring
argument_list|)
decl_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RDT
argument_list|(
name|rxr
operator|->
name|me
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* DEV_NETMAP */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RDT
argument_list|(
name|rxr
operator|->
name|me
argument_list|)
argument_list|,
name|adapter
operator|->
name|num_rx_desc
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Enable Receive engine */
name|rxctrl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXCTRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_82598EB
condition|)
name|rxctrl
operator||=
name|IXGBE_RXCTRL_DMBYPS
expr_stmt|;
name|rxctrl
operator||=
name|IXGBE_RXCTRL_RXEN
expr_stmt|;
name|ixgbe_enable_rx_dma
argument_list|(
name|hw
argument_list|,
name|rxctrl
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|,
name|hz
argument_list|,
name|ixgbe_local_timer
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
comment|/* Set up MSI-X routing */
if|if
condition|(
name|adapter
operator|->
name|feat_en
operator|&
name|IXGBE_FEATURE_MSIX
condition|)
block|{
name|ixgbe_configure_ivars
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Set up auto-mask */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_82598EB
condition|)
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EIAM
argument_list|,
name|IXGBE_EICS_RTX_QUEUE
argument_list|)
expr_stmt|;
else|else
block|{
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EIAM_EX
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EIAM_EX
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Simple settings for Legacy/MSI */
name|ixgbe_set_ivar
argument_list|(
name|adapter
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ixgbe_set_ivar
argument_list|(
name|adapter
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EIAM
argument_list|,
name|IXGBE_EICS_RTX_QUEUE
argument_list|)
expr_stmt|;
block|}
name|ixgbe_init_fdir
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* 	 * Check on any SFP devices that 	 * need to be kick-started 	 */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|ixgbe_phy_none
condition|)
block|{
name|err
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|identify
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|IXGBE_ERR_SFP_NOT_SUPPORTED
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unsupported SFP+ module type was detected.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Set moderation on the Link interrupt */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EITR
argument_list|(
name|adapter
operator|->
name|vector
argument_list|)
argument_list|,
name|IXGBE_LINK_ITR
argument_list|)
expr_stmt|;
comment|/* Config/Enable Link */
name|ixgbe_config_link
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Hardware Packet Buffer& Flow Control setup */
name|ixgbe_config_delay_values
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Initialize the FC settings */
name|ixgbe_start_hw
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Set up VLAN support and filter */
name|ixgbe_setup_vlan_hw_support
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Setup DMA Coalescing */
name|ixgbe_config_dmac
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* And now turn on interrupts */
name|ixgbe_enable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Enable the use of the MBX by the VF's */
if|if
condition|(
name|adapter
operator|->
name|feat_en
operator|&
name|IXGBE_FEATURE_SRIOV
condition|)
block|{
name|ctrl_ext
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CTRL_EXT
argument_list|)
expr_stmt|;
name|ctrl_ext
operator||=
name|IXGBE_CTRL_EXT_PFRSTD
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CTRL_EXT
argument_list|,
name|ctrl_ext
argument_list|)
expr_stmt|;
block|}
comment|/* Now inform the stack we're ready */
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ixgbe_init_locked */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_init  ************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|arg
decl_stmt|;
name|IXGBE_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixgbe_init_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|IXGBE_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ixgbe_init */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_set_ivar  *  *   Setup the correct IVAR register for a particular MSI-X interrupt  *     (yes this is all very magic and confusing :)  *    - entry is the register array entry  *    - vector is the MSI-X vector for this queue  *    - type is RX/TX/MISC  ************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_set_ivar
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|u8
name|entry
parameter_list|,
name|u8
name|vector
parameter_list|,
name|s8
name|type
parameter_list|)
block|{
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|u32
name|ivar
decl_stmt|,
name|index
decl_stmt|;
name|vector
operator||=
name|IXGBE_IVAR_ALLOC_VAL
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|ixgbe_mac_82598EB
case|:
if|if
condition|(
name|type
operator|==
operator|-
literal|1
condition|)
name|entry
operator|=
name|IXGBE_IVAR_OTHER_CAUSES_INDEX
expr_stmt|;
else|else
name|entry
operator|+=
operator|(
name|type
operator|*
literal|64
operator|)
expr_stmt|;
name|index
operator|=
operator|(
name|entry
operator|>>
literal|2
operator|)
operator|&
literal|0x1F
expr_stmt|;
name|ivar
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_IVAR
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|ivar
operator|&=
operator|~
operator|(
literal|0xFF
operator|<<
operator|(
literal|8
operator|*
operator|(
name|entry
operator|&
literal|0x3
operator|)
operator|)
operator|)
expr_stmt|;
name|ivar
operator||=
operator|(
name|vector
operator|<<
operator|(
literal|8
operator|*
operator|(
name|entry
operator|&
literal|0x3
operator|)
operator|)
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_IVAR
argument_list|(
name|index
argument_list|)
argument_list|,
name|ivar
argument_list|)
expr_stmt|;
break|break;
case|case
name|ixgbe_mac_82599EB
case|:
case|case
name|ixgbe_mac_X540
case|:
case|case
name|ixgbe_mac_X550
case|:
case|case
name|ixgbe_mac_X550EM_x
case|:
case|case
name|ixgbe_mac_X550EM_a
case|:
if|if
condition|(
name|type
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* MISC IVAR */
name|index
operator|=
operator|(
name|entry
operator|&
literal|1
operator|)
operator|*
literal|8
expr_stmt|;
name|ivar
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_IVAR_MISC
argument_list|)
expr_stmt|;
name|ivar
operator|&=
operator|~
operator|(
literal|0xFF
operator|<<
name|index
operator|)
expr_stmt|;
name|ivar
operator||=
operator|(
name|vector
operator|<<
name|index
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_IVAR_MISC
argument_list|,
name|ivar
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* RX/TX IVARS */
name|index
operator|=
operator|(
literal|16
operator|*
operator|(
name|entry
operator|&
literal|1
operator|)
operator|)
operator|+
operator|(
literal|8
operator|*
name|type
operator|)
expr_stmt|;
name|ivar
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_IVAR
argument_list|(
name|entry
operator|>>
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ivar
operator|&=
operator|~
operator|(
literal|0xFF
operator|<<
name|index
operator|)
expr_stmt|;
name|ivar
operator||=
operator|(
name|vector
operator|<<
name|index
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_IVAR
argument_list|(
name|entry
operator|>>
literal|1
argument_list|)
argument_list|,
name|ivar
argument_list|)
expr_stmt|;
block|}
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* ixgbe_set_ivar */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_configure_ivars  ************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_configure_ivars
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ix_queue
modifier|*
name|que
init|=
name|adapter
operator|->
name|queues
decl_stmt|;
name|u32
name|newitr
decl_stmt|;
if|if
condition|(
name|ixgbe_max_interrupt_rate
operator|>
literal|0
condition|)
name|newitr
operator|=
operator|(
literal|4000000
operator|/
name|ixgbe_max_interrupt_rate
operator|)
operator|&
literal|0x0FF8
expr_stmt|;
else|else
block|{
comment|/* 		 * Disable DMA coalescing if interrupt moderation is 		 * disabled. 		 */
name|adapter
operator|->
name|dmac
operator|=
literal|0
expr_stmt|;
name|newitr
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
block|{
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
operator|&
name|adapter
operator|->
name|rx_rings
index|[
name|i
index|]
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|adapter
operator|->
name|tx_rings
index|[
name|i
index|]
decl_stmt|;
comment|/* First the RX queue entry */
name|ixgbe_set_ivar
argument_list|(
name|adapter
argument_list|,
name|rxr
operator|->
name|me
argument_list|,
name|que
operator|->
name|msix
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ... and the TX */
name|ixgbe_set_ivar
argument_list|(
name|adapter
argument_list|,
name|txr
operator|->
name|me
argument_list|,
name|que
operator|->
name|msix
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Set an Initial EITR value */
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_EITR
argument_list|(
name|que
operator|->
name|msix
argument_list|)
argument_list|,
name|newitr
argument_list|)
expr_stmt|;
block|}
comment|/* For the Link interrupt */
name|ixgbe_set_ivar
argument_list|(
name|adapter
argument_list|,
literal|1
argument_list|,
name|adapter
operator|->
name|vector
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ixgbe_configure_ivars */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_config_gpie  ************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_config_gpie
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|u32
name|gpie
decl_stmt|;
name|gpie
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GPIE
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|feat_en
operator|&
name|IXGBE_FEATURE_MSIX
condition|)
block|{
comment|/* Enable Enhanced MSI-X mode */
name|gpie
operator||=
name|IXGBE_GPIE_MSIX_MODE
operator||
name|IXGBE_GPIE_EIAME
operator||
name|IXGBE_GPIE_PBA_SUPPORT
operator||
name|IXGBE_GPIE_OCD
expr_stmt|;
block|}
comment|/* Fan Failure Interrupt */
if|if
condition|(
name|adapter
operator|->
name|feat_en
operator|&
name|IXGBE_FEATURE_FAN_FAIL
condition|)
name|gpie
operator||=
name|IXGBE_SDP1_GPIEN
expr_stmt|;
comment|/* Thermal Sensor Interrupt */
if|if
condition|(
name|adapter
operator|->
name|feat_en
operator|&
name|IXGBE_FEATURE_TEMP_SENSOR
condition|)
name|gpie
operator||=
name|IXGBE_SDP0_GPIEN_X540
expr_stmt|;
comment|/* Link detection */
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|ixgbe_mac_82599EB
case|:
name|gpie
operator||=
name|IXGBE_SDP1_GPIEN
operator||
name|IXGBE_SDP2_GPIEN
expr_stmt|;
break|break;
case|case
name|ixgbe_mac_X550EM_x
case|:
case|case
name|ixgbe_mac_X550EM_a
case|:
name|gpie
operator||=
name|IXGBE_SDP0_GPIEN_X540
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GPIE
argument_list|,
name|gpie
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ixgbe_config_gpie */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_config_delay_values  *  *   Requires adapter->max_frame_size to be set.  ************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_config_delay_values
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|u32
name|rxpb
decl_stmt|,
name|frame
decl_stmt|,
name|size
decl_stmt|,
name|tmp
decl_stmt|;
name|frame
operator|=
name|adapter
operator|->
name|max_frame_size
expr_stmt|;
comment|/* Calculate High Water */
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|ixgbe_mac_X540
case|:
case|case
name|ixgbe_mac_X550
case|:
case|case
name|ixgbe_mac_X550EM_x
case|:
case|case
name|ixgbe_mac_X550EM_a
case|:
name|tmp
operator|=
name|IXGBE_DV_X540
argument_list|(
name|frame
argument_list|,
name|frame
argument_list|)
expr_stmt|;
break|break;
default|default:
name|tmp
operator|=
name|IXGBE_DV
argument_list|(
name|frame
argument_list|,
name|frame
argument_list|)
expr_stmt|;
break|break;
block|}
name|size
operator|=
name|IXGBE_BT2KB
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|rxpb
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXPBSIZE
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|>>
literal|10
expr_stmt|;
name|hw
operator|->
name|fc
operator|.
name|high_water
index|[
literal|0
index|]
operator|=
name|rxpb
operator|-
name|size
expr_stmt|;
comment|/* Now calculate Low Water */
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|ixgbe_mac_X540
case|:
case|case
name|ixgbe_mac_X550
case|:
case|case
name|ixgbe_mac_X550EM_x
case|:
case|case
name|ixgbe_mac_X550EM_a
case|:
name|tmp
operator|=
name|IXGBE_LOW_DV_X540
argument_list|(
name|frame
argument_list|)
expr_stmt|;
break|break;
default|default:
name|tmp
operator|=
name|IXGBE_LOW_DV
argument_list|(
name|frame
argument_list|)
expr_stmt|;
break|break;
block|}
name|hw
operator|->
name|fc
operator|.
name|low_water
index|[
literal|0
index|]
operator|=
name|IXGBE_BT2KB
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|hw
operator|->
name|fc
operator|.
name|pause_time
operator|=
name|IXGBE_FC_PAUSE
expr_stmt|;
name|hw
operator|->
name|fc
operator|.
name|send_xon
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ixgbe_config_delay_values */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_set_multi - Multicast Update  *  *   Called whenever multicast address list is updated.  ************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_set_multi
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|struct
name|ixgbe_mc_addr
modifier|*
name|mta
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|u8
modifier|*
name|update_ptr
decl_stmt|;
name|int
name|mcnt
init|=
literal|0
decl_stmt|;
name|u32
name|fctrl
decl_stmt|;
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ixgbe_set_multi: begin"
argument_list|)
expr_stmt|;
name|mta
operator|=
name|adapter
operator|->
name|mta
expr_stmt|;
name|bzero
argument_list|(
name|mta
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mta
argument_list|)
operator|*
name|MAX_NUM_MULTICAST_ADDRESSES
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|800000
name|IF_ADDR_LOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
else|#
directive|else
name|if_maddr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
if|if
condition|(
name|mcnt
operator|==
name|MAX_NUM_MULTICAST_ADDRESSES
condition|)
break|break;
name|bcopy
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|,
name|mta
index|[
name|mcnt
index|]
operator|.
name|addr
argument_list|,
name|IXGBE_ETH_LENGTH_OF_ADDRESS
argument_list|)
expr_stmt|;
name|mta
index|[
name|mcnt
index|]
operator|.
name|vmdq
operator|=
name|adapter
operator|->
name|pool
expr_stmt|;
name|mcnt
operator|++
expr_stmt|;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|800000
name|IF_ADDR_UNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
else|#
directive|else
name|if_maddr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fctrl
operator|=
name|IXGBE_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_FCTRL
argument_list|)
expr_stmt|;
name|fctrl
operator||=
operator|(
name|IXGBE_FCTRL_UPE
operator||
name|IXGBE_FCTRL_MPE
operator|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
name|fctrl
operator||=
operator|(
name|IXGBE_FCTRL_UPE
operator||
name|IXGBE_FCTRL_MPE
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mcnt
operator|>=
name|MAX_NUM_MULTICAST_ADDRESSES
operator|||
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
condition|)
block|{
name|fctrl
operator||=
name|IXGBE_FCTRL_MPE
expr_stmt|;
name|fctrl
operator|&=
operator|~
name|IXGBE_FCTRL_UPE
expr_stmt|;
block|}
else|else
name|fctrl
operator|&=
operator|~
operator|(
name|IXGBE_FCTRL_UPE
operator||
name|IXGBE_FCTRL_MPE
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_FCTRL
argument_list|,
name|fctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcnt
operator|<
name|MAX_NUM_MULTICAST_ADDRESSES
condition|)
block|{
name|update_ptr
operator|=
operator|(
name|u8
operator|*
operator|)
name|mta
expr_stmt|;
name|ixgbe_update_mc_addr_list
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|update_ptr
argument_list|,
name|mcnt
argument_list|,
name|ixgbe_mc_array_itr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ixgbe_set_multi */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_mc_array_itr  *  *   An iterator function needed by the multicast shared code.  *   It feeds the shared code routine the addresses in the  *   array of ixgbe_set_multi() one by one.  ************************************************************************/
end_comment

begin_function
specifier|static
name|u8
modifier|*
name|ixgbe_mc_array_itr
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
modifier|*
name|update_ptr
parameter_list|,
name|u32
modifier|*
name|vmdq
parameter_list|)
block|{
name|struct
name|ixgbe_mc_addr
modifier|*
name|mta
decl_stmt|;
name|mta
operator|=
operator|(
expr|struct
name|ixgbe_mc_addr
operator|*
operator|)
operator|*
name|update_ptr
expr_stmt|;
operator|*
name|vmdq
operator|=
name|mta
operator|->
name|vmdq
expr_stmt|;
operator|*
name|update_ptr
operator|=
operator|(
name|u8
operator|*
operator|)
operator|(
name|mta
operator|+
literal|1
operator|)
expr_stmt|;
return|return
operator|(
name|mta
operator|->
name|addr
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ixgbe_mc_array_itr */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_local_timer - Timer routine  *  *   Checks for link status, updates statistics,  *   and runs the watchdog check.  ************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_local_timer
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|arg
decl_stmt|;
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|struct
name|ix_queue
modifier|*
name|que
init|=
name|adapter
operator|->
name|queues
decl_stmt|;
name|u64
name|queues
init|=
literal|0
decl_stmt|;
name|int
name|hung
init|=
literal|0
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|adapter
operator|->
name|core_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* Check for pluggable optics */
if|if
condition|(
name|adapter
operator|->
name|sfp_probe
condition|)
if|if
condition|(
operator|!
name|ixgbe_sfp_probe
argument_list|(
name|adapter
argument_list|)
condition|)
goto|goto
name|out
goto|;
comment|/* Nothing to do */
name|ixgbe_update_link_status
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixgbe_update_stats_counters
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* 	 * Check the TX queues status 	 *      - mark hung queues so we don't schedule on them 	 *      - watchdog only if all queues show hung 	 */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
block|{
comment|/* Keep track of queues with work for soft irq */
if|if
condition|(
name|que
operator|->
name|txr
operator|->
name|busy
condition|)
name|queues
operator||=
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|que
operator|->
name|me
operator|)
expr_stmt|;
comment|/* 		 * Each time txeof runs without cleaning, but there 		 * are uncleaned descriptors it increments busy. If 		 * we get to the MAX we declare it hung. 		 */
if|if
condition|(
name|que
operator|->
name|busy
operator|==
name|IXGBE_QUEUE_HUNG
condition|)
block|{
operator|++
name|hung
expr_stmt|;
comment|/* Mark the queue as inactive */
name|adapter
operator|->
name|active_queues
operator|&=
operator|~
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|que
operator|->
name|me
operator|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
comment|/* Check if we've come back from hung */
if|if
condition|(
operator|(
name|adapter
operator|->
name|active_queues
operator|&
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|que
operator|->
name|me
operator|)
operator|)
operator|==
literal|0
condition|)
name|adapter
operator|->
name|active_queues
operator||=
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|que
operator|->
name|me
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|que
operator|->
name|busy
operator|>=
name|IXGBE_MAX_TX_BUSY
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Warning queue %d appears to be hung!\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|que
operator|->
name|txr
operator|->
name|busy
operator|=
name|IXGBE_QUEUE_HUNG
expr_stmt|;
operator|++
name|hung
expr_stmt|;
block|}
block|}
comment|/* Only truly watchdog if all queues show hung */
if|if
condition|(
name|hung
operator|==
name|adapter
operator|->
name|num_queues
condition|)
goto|goto
name|watchdog
goto|;
elseif|else
if|if
condition|(
name|queues
operator|!=
literal|0
condition|)
block|{
comment|/* Force an IRQ on queues with work */
name|ixgbe_rearm_queues
argument_list|(
name|adapter
argument_list|,
name|queues
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|callout_reset
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|,
name|hz
argument_list|,
name|ixgbe_local_timer
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
return|return;
name|watchdog
label|:
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"Watchdog timeout -- resetting\n"
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|adapter
operator|->
name|watchdog_events
operator|++
expr_stmt|;
name|ixgbe_init_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ixgbe_local_timer */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_sfp_probe  *  *   Determine if a port had optics inserted.  ************************************************************************/
end_comment

begin_function
specifier|static
name|bool
name|ixgbe_sfp_probe
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|bool
name|result
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|ixgbe_phy_nl
operator|)
operator|&&
operator|(
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|==
name|ixgbe_sfp_type_not_present
operator|)
condition|)
block|{
name|s32
name|ret
init|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|identify_sfp
argument_list|(
name|hw
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
name|ret
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|reset
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|sfp_probe
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|IXGBE_ERR_SFP_NOT_SUPPORTED
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unsupported SFP+ module detected!"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Reload driver with supported module.\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
else|else
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"SFP+ module detected!\n"
argument_list|)
expr_stmt|;
comment|/* We now have supported optics */
name|result
operator|=
name|TRUE
expr_stmt|;
block|}
name|out
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ixgbe_sfp_probe */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_handle_mod - Tasklet for SFP module interrupts  ************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_handle_mod
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|context
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|u32
name|err
decl_stmt|,
name|cage_full
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|need_crosstalk_fix
condition|)
block|{
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|ixgbe_mac_82599EB
case|:
name|cage_full
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|)
operator|&
name|IXGBE_ESDP_SDP2
expr_stmt|;
break|break;
case|case
name|ixgbe_mac_X550EM_x
case|:
case|case
name|ixgbe_mac_X550EM_a
case|:
name|cage_full
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|)
operator|&
name|IXGBE_ESDP_SDP0
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
operator|!
name|cage_full
condition|)
return|return;
block|}
name|err
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|identify_sfp
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|IXGBE_ERR_SFP_NOT_SUPPORTED
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unsupported SFP+ module type was detected.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|err
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|setup_sfp
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|IXGBE_ERR_SFP_NOT_SUPPORTED
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Setup failure - unsupported SFP+ module type.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|taskqueue_enqueue
argument_list|(
name|adapter
operator|->
name|tq
argument_list|,
operator|&
name|adapter
operator|->
name|msf_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ixgbe_handle_mod */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_handle_msf - Tasklet for MSF (multispeed fiber) interrupts  ************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_handle_msf
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|context
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|u32
name|autoneg
decl_stmt|;
name|bool
name|negotiate
decl_stmt|;
comment|/* get_supported_phy_layer will call hw->phy.ops.identify_sfp() */
name|adapter
operator|->
name|phy_layer
operator|=
name|ixgbe_get_supported_physical_layer
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|autoneg
operator|=
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|autoneg
operator|)
operator|&&
operator|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|get_link_capabilities
operator|)
condition|)
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|get_link_capabilities
argument_list|(
name|hw
argument_list|,
operator|&
name|autoneg
argument_list|,
operator|&
name|negotiate
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|setup_link
condition|)
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|setup_link
argument_list|(
name|hw
argument_list|,
name|autoneg
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Adjust media types shown in ifconfig */
name|ifmedia_removeall
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|)
expr_stmt|;
name|ixgbe_add_media_types
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ixgbe_handle_msf */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_handle_phy - Tasklet for external PHY interrupts  ************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_handle_phy
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|context
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|handle_lasi
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|IXGBE_ERR_OVERTEMP
condition|)
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"CRITICAL: EXTERNAL PHY OVER TEMP!!  PHY will downshift to lower power state!\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|error
condition|)
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"Error handling LASI interrupt: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ixgbe_handle_phy */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_stop - Stop the hardware  *  *   Disables all traffic on the adapter by issuing a  *   global reset on the MAC and deallocates TX/RX buffers.  ************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_stop
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|arg
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|ifp
operator|=
name|adapter
operator|->
name|ifp
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|adapter
operator|->
name|core_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixgbe_stop: begin\n"
argument_list|)
expr_stmt|;
name|ixgbe_disable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|)
expr_stmt|;
comment|/* Let the stack know...*/
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|ixgbe_reset_hw
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|hw
operator|->
name|adapter_stopped
operator|=
name|FALSE
expr_stmt|;
name|ixgbe_stop_adapter
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_82599EB
condition|)
name|ixgbe_stop_mac_link_on_d3_82599
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Turn off the laser - noop with no optics */
name|ixgbe_disable_tx_laser
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Update the stack */
name|adapter
operator|->
name|link_up
operator|=
name|FALSE
expr_stmt|;
name|ixgbe_update_link_status
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* reprogram the RAR[0] in case user changed it. */
name|ixgbe_set_rar
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
literal|0
argument_list|,
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|addr
argument_list|,
literal|0
argument_list|,
name|IXGBE_RAH_AV
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ixgbe_stop */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_update_link_status - Update OS on link state  *  * Note: Only updates the OS on the cached link state.  *       The real check of the hardware only happens with  *       a link interrupt.  ************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_update_link_status
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
if|if
condition|(
name|adapter
operator|->
name|link_up
condition|)
block|{
if|if
condition|(
name|adapter
operator|->
name|link_active
operator|==
name|FALSE
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Link is up %d Gbps %s \n"
argument_list|,
operator|(
operator|(
name|adapter
operator|->
name|link_speed
operator|==
literal|128
operator|)
condition|?
literal|10
else|:
literal|1
operator|)
argument_list|,
literal|"Full Duplex"
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|link_active
operator|=
name|TRUE
expr_stmt|;
comment|/* Update any Flow Control changes */
name|ixgbe_fc_enable
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
comment|/* Update DMA coalescing config */
name|ixgbe_config_dmac
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_UP
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|feat_en
operator|&
name|IXGBE_FEATURE_SRIOV
condition|)
name|ixgbe_ping_all_vfs
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Link down */
if|if
condition|(
name|adapter
operator|->
name|link_active
operator|==
name|TRUE
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Link is Down\n"
argument_list|)
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_DOWN
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|link_active
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|feat_en
operator|&
name|IXGBE_FEATURE_SRIOV
condition|)
name|ixgbe_ping_all_vfs
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ixgbe_update_link_status */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_config_dmac - Configure DMA Coalescing  ************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_config_dmac
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|struct
name|ixgbe_dmac_config
modifier|*
name|dcfg
init|=
operator|&
name|hw
operator|->
name|mac
operator|.
name|dmac_config
decl_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|<
name|ixgbe_mac_X550
operator|||
operator|!
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|dmac_config
condition|)
return|return;
if|if
condition|(
name|dcfg
operator|->
name|watchdog_timer
operator|^
name|adapter
operator|->
name|dmac
operator|||
name|dcfg
operator|->
name|link_speed
operator|^
name|adapter
operator|->
name|link_speed
condition|)
block|{
name|dcfg
operator|->
name|watchdog_timer
operator|=
name|adapter
operator|->
name|dmac
expr_stmt|;
name|dcfg
operator|->
name|fcoe_en
operator|=
name|false
expr_stmt|;
name|dcfg
operator|->
name|link_speed
operator|=
name|adapter
operator|->
name|link_speed
expr_stmt|;
name|dcfg
operator|->
name|num_tcs
operator|=
literal|1
expr_stmt|;
name|INIT_DEBUGOUT2
argument_list|(
literal|"dmac settings: watchdog %d, link speed %d\n"
argument_list|,
name|dcfg
operator|->
name|watchdog_timer
argument_list|,
name|dcfg
operator|->
name|link_speed
argument_list|)
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|dmac_config
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ixgbe_config_dmac */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_enable_intr  ************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_enable_intr
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|struct
name|ix_queue
modifier|*
name|que
init|=
name|adapter
operator|->
name|queues
decl_stmt|;
name|u32
name|mask
decl_stmt|,
name|fwsm
decl_stmt|;
name|mask
operator|=
operator|(
name|IXGBE_EIMS_ENABLE_MASK
operator|&
operator|~
name|IXGBE_EIMS_RTX_QUEUE
operator|)
expr_stmt|;
switch|switch
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|ixgbe_mac_82599EB
case|:
name|mask
operator||=
name|IXGBE_EIMS_ECC
expr_stmt|;
comment|/* Temperature sensor on some adapters */
name|mask
operator||=
name|IXGBE_EIMS_GPI_SDP0
expr_stmt|;
comment|/* SFP+ (RX_LOS_N& MOD_ABS_N) */
name|mask
operator||=
name|IXGBE_EIMS_GPI_SDP1
expr_stmt|;
name|mask
operator||=
name|IXGBE_EIMS_GPI_SDP2
expr_stmt|;
break|break;
case|case
name|ixgbe_mac_X540
case|:
comment|/* Detect if Thermal Sensor is enabled */
name|fwsm
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FWSM
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwsm
operator|&
name|IXGBE_FWSM_TS_ENABLED
condition|)
name|mask
operator||=
name|IXGBE_EIMS_TS
expr_stmt|;
name|mask
operator||=
name|IXGBE_EIMS_ECC
expr_stmt|;
break|break;
case|case
name|ixgbe_mac_X550
case|:
comment|/* MAC thermal sensor is automatically enabled */
name|mask
operator||=
name|IXGBE_EIMS_TS
expr_stmt|;
name|mask
operator||=
name|IXGBE_EIMS_ECC
expr_stmt|;
break|break;
case|case
name|ixgbe_mac_X550EM_x
case|:
case|case
name|ixgbe_mac_X550EM_a
case|:
comment|/* Some devices use SDP0 for important information */
if|if
condition|(
name|hw
operator|->
name|device_id
operator|==
name|IXGBE_DEV_ID_X550EM_X_SFP
operator|||
name|hw
operator|->
name|device_id
operator|==
name|IXGBE_DEV_ID_X550EM_A_SFP
operator|||
name|hw
operator|->
name|device_id
operator|==
name|IXGBE_DEV_ID_X550EM_A_SFP_N
operator|||
name|hw
operator|->
name|device_id
operator|==
name|IXGBE_DEV_ID_X550EM_X_10G_T
condition|)
name|mask
operator||=
name|IXGBE_EIMS_GPI_SDP0_BY_MAC
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|ixgbe_phy_x550em_ext_t
condition|)
name|mask
operator||=
name|IXGBE_EICR_GPI_SDP0_X540
expr_stmt|;
name|mask
operator||=
name|IXGBE_EIMS_ECC
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Enable Fan Failure detection */
if|if
condition|(
name|adapter
operator|->
name|feat_en
operator|&
name|IXGBE_FEATURE_FAN_FAIL
condition|)
name|mask
operator||=
name|IXGBE_EIMS_GPI_SDP1
expr_stmt|;
comment|/* Enable SR-IOV */
if|if
condition|(
name|adapter
operator|->
name|feat_en
operator|&
name|IXGBE_FEATURE_SRIOV
condition|)
name|mask
operator||=
name|IXGBE_EIMS_MAILBOX
expr_stmt|;
comment|/* Enable Flow Director */
if|if
condition|(
name|adapter
operator|->
name|feat_en
operator|&
name|IXGBE_FEATURE_FDIR
condition|)
name|mask
operator||=
name|IXGBE_EIMS_FLOW_DIR
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EIMS
argument_list|,
name|mask
argument_list|)
expr_stmt|;
comment|/* With MSI-X we use auto clear */
if|if
condition|(
name|adapter
operator|->
name|msix_mem
condition|)
block|{
name|mask
operator|=
name|IXGBE_EIMS_ENABLE_MASK
expr_stmt|;
comment|/* Don't autoclear Link */
name|mask
operator|&=
operator|~
name|IXGBE_EIMS_OTHER
expr_stmt|;
name|mask
operator|&=
operator|~
name|IXGBE_EIMS_LSC
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|feat_cap
operator|&
name|IXGBE_FEATURE_SRIOV
condition|)
name|mask
operator|&=
operator|~
name|IXGBE_EIMS_MAILBOX
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EIAC
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now enable all queues, this is done separately to 	 * allow for handling the extended (beyond 32) MSI-X 	 * vectors that can be used by 82599 	 */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
name|ixgbe_enable_queue
argument_list|(
name|adapter
argument_list|,
name|que
operator|->
name|msix
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ixgbe_enable_intr */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_disable_intr  ************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_disable_intr
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
if|if
condition|(
name|adapter
operator|->
name|msix_mem
condition|)
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_EIAC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_82598EB
condition|)
block|{
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_EIMC
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_EIMC
argument_list|,
literal|0xFFFF0000
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_EIMC_EX
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_EIMC_EX
argument_list|(
literal|1
argument_list|)
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
block|}
name|IXGBE_WRITE_FLUSH
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ixgbe_disable_intr */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_legacy_irq - Legacy Interrupt Service routine  ************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_legacy_irq
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ix_queue
modifier|*
name|que
init|=
name|arg
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|que
operator|->
name|adapter
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
name|bool
name|more
init|=
name|false
decl_stmt|;
name|u32
name|eicr
decl_stmt|,
name|eicr_mask
decl_stmt|;
comment|/* Silicon errata #26 on 82598 */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EIMC
argument_list|,
name|IXGBE_IRQ_CLEAR_MASK
argument_list|)
expr_stmt|;
name|eicr
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EICR
argument_list|)
expr_stmt|;
operator|++
name|que
operator|->
name|irqs
expr_stmt|;
if|if
condition|(
name|eicr
operator|==
literal|0
condition|)
block|{
name|ixgbe_enable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|more
operator|=
name|ixgbe_rxeof
argument_list|(
name|que
argument_list|)
expr_stmt|;
name|IXGBE_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|ixgbe_txeof
argument_list|(
name|txr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ixgbe_ring_empty
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|)
condition|)
name|ixgbe_start_locked
argument_list|(
name|ifp
argument_list|,
name|txr
argument_list|)
expr_stmt|;
name|IXGBE_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
block|}
comment|/* Check for fan failure */
if|if
condition|(
name|adapter
operator|->
name|feat_en
operator|&
name|IXGBE_FEATURE_FAN_FAIL
condition|)
block|{
name|ixgbe_check_fan_failure
argument_list|(
name|adapter
argument_list|,
name|eicr
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EIMS
argument_list|,
name|IXGBE_EICR_GPI_SDP1_BY_MAC
argument_list|(
name|hw
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Link status change */
if|if
condition|(
name|eicr
operator|&
name|IXGBE_EICR_LSC
condition|)
name|taskqueue_enqueue
argument_list|(
name|adapter
operator|->
name|tq
argument_list|,
operator|&
name|adapter
operator|->
name|link_task
argument_list|)
expr_stmt|;
if|if
condition|(
name|ixgbe_is_sfp
argument_list|(
name|hw
argument_list|)
condition|)
block|{
comment|/* Pluggable optics-related interrupt */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|>=
name|ixgbe_mac_X540
condition|)
name|eicr_mask
operator|=
name|IXGBE_EICR_GPI_SDP0_X540
expr_stmt|;
else|else
name|eicr_mask
operator|=
name|IXGBE_EICR_GPI_SDP2_BY_MAC
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|eicr
operator|&
name|eicr_mask
condition|)
block|{
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EICR
argument_list|,
name|eicr_mask
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|adapter
operator|->
name|tq
argument_list|,
operator|&
name|adapter
operator|->
name|mod_task
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_82599EB
operator|)
operator|&&
operator|(
name|eicr
operator|&
name|IXGBE_EICR_GPI_SDP1_BY_MAC
argument_list|(
name|hw
argument_list|)
operator|)
condition|)
block|{
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EICR
argument_list|,
name|IXGBE_EICR_GPI_SDP1_BY_MAC
argument_list|(
name|hw
argument_list|)
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|adapter
operator|->
name|tq
argument_list|,
operator|&
name|adapter
operator|->
name|msf_task
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* External PHY interrupt */
if|if
condition|(
operator|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|ixgbe_phy_x550em_ext_t
operator|)
operator|&&
operator|(
name|eicr
operator|&
name|IXGBE_EICR_GPI_SDP0_X540
operator|)
condition|)
name|taskqueue_enqueue
argument_list|(
name|adapter
operator|->
name|tq
argument_list|,
operator|&
name|adapter
operator|->
name|phy_task
argument_list|)
expr_stmt|;
if|if
condition|(
name|more
condition|)
name|taskqueue_enqueue
argument_list|(
name|que
operator|->
name|tq
argument_list|,
operator|&
name|que
operator|->
name|que_task
argument_list|)
expr_stmt|;
else|else
name|ixgbe_enable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ixgbe_legacy_irq */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_free_pci_resources  ************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_free_pci_resources
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ix_queue
modifier|*
name|que
init|=
name|adapter
operator|->
name|queues
decl_stmt|;
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|int
name|rid
decl_stmt|,
name|memrid
decl_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_82598EB
condition|)
name|memrid
operator|=
name|PCIR_BAR
argument_list|(
name|MSIX_82598_BAR
argument_list|)
expr_stmt|;
else|else
name|memrid
operator|=
name|PCIR_BAR
argument_list|(
name|MSIX_82599_BAR
argument_list|)
expr_stmt|;
comment|/* 	 * There is a slight possibility of a failure mode 	 * in attach that will result in entering this function 	 * before interrupt resources have been initialized, and 	 * in that case we do not want to execute the loops below 	 * We can detect this reliably by the state of the adapter 	 * res pointer. 	 */
if|if
condition|(
name|adapter
operator|->
name|res
operator|==
name|NULL
condition|)
goto|goto
name|mem
goto|;
comment|/* 	 * Release all msix queue resources: 	 */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
block|{
name|rid
operator|=
name|que
operator|->
name|msix
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|que
operator|->
name|tag
operator|!=
name|NULL
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|que
operator|->
name|res
argument_list|,
name|que
operator|->
name|tag
argument_list|)
expr_stmt|;
name|que
operator|->
name|tag
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|que
operator|->
name|res
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rid
argument_list|,
name|que
operator|->
name|res
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|adapter
operator|->
name|tag
operator|!=
name|NULL
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|adapter
operator|->
name|res
argument_list|,
name|adapter
operator|->
name|tag
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|tag
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Clean the Legacy or Link interrupt last */
if|if
condition|(
name|adapter
operator|->
name|res
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|adapter
operator|->
name|link_rid
argument_list|,
name|adapter
operator|->
name|res
argument_list|)
expr_stmt|;
name|mem
label|:
if|if
condition|(
operator|(
name|adapter
operator|->
name|feat_en
operator|&
name|IXGBE_FEATURE_MSI
operator|)
operator|||
operator|(
name|adapter
operator|->
name|feat_en
operator|&
name|IXGBE_FEATURE_MSIX
operator|)
condition|)
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|msix_mem
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|memrid
argument_list|,
name|adapter
operator|->
name|msix_mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|pci_mem
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|adapter
operator|->
name|pci_mem
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ixgbe_free_pci_resources */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_set_sysctl_value  ************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_set_sysctl_value
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|description
parameter_list|,
name|int
modifier|*
name|limit
parameter_list|,
name|int
name|value
parameter_list|)
block|{
operator|*
name|limit
operator|=
name|value
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|adapter
operator|->
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|adapter
operator|->
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|name
argument_list|,
name|CTLFLAG_RW
argument_list|,
name|limit
argument_list|,
name|value
argument_list|,
name|description
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ixgbe_set_sysctl_value */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_sysctl_flowcntl  *  *   SYSCTL wrapper around setting Flow Control  ************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_sysctl_flowcntl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
decl_stmt|;
name|int
name|error
decl_stmt|,
name|fc
decl_stmt|;
name|adapter
operator|=
operator|(
expr|struct
name|adapter
operator|*
operator|)
name|arg1
expr_stmt|;
name|fc
operator|=
name|adapter
operator|->
name|hw
operator|.
name|fc
operator|.
name|current_mode
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|fc
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|)
operator|||
operator|(
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Don't bother if it's not changed */
if|if
condition|(
name|fc
operator|==
name|adapter
operator|->
name|hw
operator|.
name|fc
operator|.
name|current_mode
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
name|ixgbe_set_flowcntl
argument_list|(
name|adapter
argument_list|,
name|fc
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ixgbe_sysctl_flowcntl */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_set_flowcntl - Set flow control  *  *   Flow control values:  *     0 - off  *     1 - rx pause  *     2 - tx pause  *     3 - full  ************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_set_flowcntl
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|int
name|fc
parameter_list|)
block|{
switch|switch
condition|(
name|fc
condition|)
block|{
case|case
name|ixgbe_fc_rx_pause
case|:
case|case
name|ixgbe_fc_tx_pause
case|:
case|case
name|ixgbe_fc_full
case|:
name|adapter
operator|->
name|hw
operator|.
name|fc
operator|.
name|requested_mode
operator|=
name|fc
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|num_queues
operator|>
literal|1
condition|)
name|ixgbe_disable_rx_drop
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
break|break;
case|case
name|ixgbe_fc_none
case|:
name|adapter
operator|->
name|hw
operator|.
name|fc
operator|.
name|requested_mode
operator|=
name|ixgbe_fc_none
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|num_queues
operator|>
literal|1
condition|)
name|ixgbe_enable_rx_drop
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Don't autoneg if forcing a value */
name|adapter
operator|->
name|hw
operator|.
name|fc
operator|.
name|disable_fc_autoneg
operator|=
name|TRUE
expr_stmt|;
name|ixgbe_fc_enable
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ixgbe_set_flowcntl */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_enable_rx_drop  *  *   Enable the hardware to drop packets when the buffer is  *   full. This is useful with multiqueue, so that no single  *   queue being full stalls the entire RX engine. We only  *   enable this when Multiqueue is enabled AND Flow Control  *   is disabled.  ************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_enable_rx_drop
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
decl_stmt|;
name|u32
name|srrctl
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|rxr
operator|=
operator|&
name|adapter
operator|->
name|rx_rings
index|[
name|i
index|]
expr_stmt|;
name|srrctl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SRRCTL
argument_list|(
name|rxr
operator|->
name|me
argument_list|)
argument_list|)
expr_stmt|;
name|srrctl
operator||=
name|IXGBE_SRRCTL_DROP_EN
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SRRCTL
argument_list|(
name|rxr
operator|->
name|me
argument_list|)
argument_list|,
name|srrctl
argument_list|)
expr_stmt|;
block|}
comment|/* enable drop for each vf */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_vfs
condition|;
name|i
operator|++
control|)
block|{
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_QDE
argument_list|,
operator|(
name|IXGBE_QDE_WRITE
operator||
operator|(
name|i
operator|<<
name|IXGBE_QDE_IDX_SHIFT
operator|)
operator||
name|IXGBE_QDE_ENABLE
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ixgbe_enable_rx_drop */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_disable_rx_drop  ************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_disable_rx_drop
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
decl_stmt|;
name|u32
name|srrctl
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|rxr
operator|=
operator|&
name|adapter
operator|->
name|rx_rings
index|[
name|i
index|]
expr_stmt|;
name|srrctl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SRRCTL
argument_list|(
name|rxr
operator|->
name|me
argument_list|)
argument_list|)
expr_stmt|;
name|srrctl
operator|&=
operator|~
name|IXGBE_SRRCTL_DROP_EN
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SRRCTL
argument_list|(
name|rxr
operator|->
name|me
argument_list|)
argument_list|,
name|srrctl
argument_list|)
expr_stmt|;
block|}
comment|/* disable drop for each vf */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_vfs
condition|;
name|i
operator|++
control|)
block|{
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_QDE
argument_list|,
operator|(
name|IXGBE_QDE_WRITE
operator||
operator|(
name|i
operator|<<
name|IXGBE_QDE_IDX_SHIFT
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ixgbe_disable_rx_drop */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_sysctl_advertise  *  *   SYSCTL wrapper around setting advertised speed  ************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_sysctl_advertise
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
decl_stmt|;
name|int
name|error
decl_stmt|,
name|advertise
decl_stmt|;
name|adapter
operator|=
operator|(
expr|struct
name|adapter
operator|*
operator|)
name|arg1
expr_stmt|;
name|advertise
operator|=
name|adapter
operator|->
name|advertise
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|advertise
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|)
operator|||
operator|(
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
name|ixgbe_set_advertise
argument_list|(
name|adapter
argument_list|,
name|advertise
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ixgbe_sysctl_advertise */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_set_advertise - Control advertised link speed  *  *   Flags:  *     0x1 - advertise 100 Mb  *     0x2 - advertise 1G  *     0x4 - advertise 10G  *     0x8 - advertise 10 Mb (yes, Mb)  ************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_set_advertise
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|int
name|advertise
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
decl_stmt|;
name|ixgbe_link_speed
name|speed
init|=
literal|0
decl_stmt|;
name|ixgbe_link_speed
name|link_caps
init|=
literal|0
decl_stmt|;
name|s32
name|err
init|=
name|IXGBE_NOT_IMPLEMENTED
decl_stmt|;
name|bool
name|negotiate
init|=
name|FALSE
decl_stmt|;
comment|/* Checks to validate new value */
if|if
condition|(
name|adapter
operator|->
name|advertise
operator|==
name|advertise
condition|)
comment|/* no change */
return|return
operator|(
literal|0
operator|)
return|;
name|dev
operator|=
name|adapter
operator|->
name|dev
expr_stmt|;
name|hw
operator|=
operator|&
name|adapter
operator|->
name|hw
expr_stmt|;
comment|/* No speed changes for backplane media */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|==
name|ixgbe_media_type_backplane
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
if|if
condition|(
operator|!
operator|(
operator|(
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|==
name|ixgbe_media_type_copper
operator|)
operator|||
operator|(
name|hw
operator|->
name|phy
operator|.
name|multispeed_fiber
operator|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Advertised speed can only be set on copper or multispeed fiber media types.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|advertise
operator|<
literal|0x1
operator|||
name|advertise
operator|>
literal|0xF
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Invalid advertised speed; valid modes are 0x1 through 0xF\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|get_link_capabilities
condition|)
block|{
name|err
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|get_link_capabilities
argument_list|(
name|hw
argument_list|,
operator|&
name|link_caps
argument_list|,
operator|&
name|negotiate
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|IXGBE_SUCCESS
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to determine supported advertise speeds\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
block|}
comment|/* Set new value and report new advertised mode */
if|if
condition|(
name|advertise
operator|&
literal|0x1
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|link_caps
operator|&
name|IXGBE_LINK_SPEED_100_FULL
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Interface does not support 100Mb advertised speed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|speed
operator||=
name|IXGBE_LINK_SPEED_100_FULL
expr_stmt|;
block|}
if|if
condition|(
name|advertise
operator|&
literal|0x2
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|link_caps
operator|&
name|IXGBE_LINK_SPEED_1GB_FULL
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Interface does not support 1Gb advertised speed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|speed
operator||=
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
block|}
if|if
condition|(
name|advertise
operator|&
literal|0x4
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|link_caps
operator|&
name|IXGBE_LINK_SPEED_10GB_FULL
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Interface does not support 10Gb advertised speed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|speed
operator||=
name|IXGBE_LINK_SPEED_10GB_FULL
expr_stmt|;
block|}
if|if
condition|(
name|advertise
operator|&
literal|0x8
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|link_caps
operator|&
name|IXGBE_LINK_SPEED_10_FULL
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Interface does not support 10Mb advertised speed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|speed
operator||=
name|IXGBE_LINK_SPEED_10_FULL
expr_stmt|;
block|}
name|hw
operator|->
name|mac
operator|.
name|autotry_restart
operator|=
name|TRUE
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|setup_link
argument_list|(
name|hw
argument_list|,
name|speed
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|advertise
operator|=
name|advertise
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ixgbe_set_advertise */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_get_advertise - Get current advertised speed settings  *  *   Formatted for sysctl usage.  *   Flags:  *     0x1 - advertise 100 Mb  *     0x2 - advertise 1G  *     0x4 - advertise 10G  *     0x8 - advertise 10 Mb (yes, Mb)  ************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_get_advertise
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|int
name|speed
decl_stmt|;
name|ixgbe_link_speed
name|link_caps
init|=
literal|0
decl_stmt|;
name|s32
name|err
decl_stmt|;
name|bool
name|negotiate
init|=
name|FALSE
decl_stmt|;
comment|/* 	 * Advertised speed means nothing unless it's copper or 	 * multi-speed fiber 	 */
if|if
condition|(
operator|!
operator|(
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|==
name|ixgbe_media_type_copper
operator|)
operator|&&
operator|!
operator|(
name|hw
operator|->
name|phy
operator|.
name|multispeed_fiber
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|err
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|get_link_capabilities
argument_list|(
name|hw
argument_list|,
operator|&
name|link_caps
argument_list|,
operator|&
name|negotiate
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|speed
operator|=
operator|(
operator|(
name|link_caps
operator|&
name|IXGBE_LINK_SPEED_10GB_FULL
operator|)
condition|?
literal|4
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|link_caps
operator|&
name|IXGBE_LINK_SPEED_1GB_FULL
operator|)
condition|?
literal|2
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|link_caps
operator|&
name|IXGBE_LINK_SPEED_100_FULL
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|link_caps
operator|&
name|IXGBE_LINK_SPEED_10_FULL
operator|)
condition|?
literal|8
else|:
literal|0
operator|)
expr_stmt|;
return|return
name|speed
return|;
block|}
end_function

begin_comment
comment|/* ixgbe_get_advertise */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_sysctl_dmac - Manage DMA Coalescing  *  *   Control values:  *     0/1 - off / on (use default value of 1000)  *  *     Legal timer values are:  *     50,100,250,500,1000,2000,5000,10000  *  *     Turning off interrupt moderation will also turn this off.  ************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_sysctl_dmac
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
operator|(
expr|struct
name|adapter
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u32
name|newval
decl_stmt|;
name|newval
operator|=
name|adapter
operator|->
name|dmac
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|newval
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|)
operator|||
operator|(
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
switch|switch
condition|(
name|newval
condition|)
block|{
case|case
literal|0
case|:
comment|/* Disabled */
name|adapter
operator|->
name|dmac
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* Enable and use default */
name|adapter
operator|->
name|dmac
operator|=
literal|1000
expr_stmt|;
break|break;
case|case
literal|50
case|:
case|case
literal|100
case|:
case|case
literal|250
case|:
case|case
literal|500
case|:
case|case
literal|1000
case|:
case|case
literal|2000
case|:
case|case
literal|5000
case|:
case|case
literal|10000
case|:
comment|/* Legal values - allow */
name|adapter
operator|->
name|dmac
operator|=
name|newval
expr_stmt|;
break|break;
default|default:
comment|/* Do nothing, illegal value */
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Re-initialize hardware if it's already running */
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|ixgbe_init
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ixgbe_sysctl_dmac */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|IXGBE_DEBUG
end_ifdef

begin_comment
comment|/************************************************************************  * ixgbe_sysctl_power_state  *  *   Sysctl to test power states  *   Values:  *     0      - set device to D0  *     3      - set device to D3  *     (none) - get current device power state  ************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_sysctl_power_state
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
operator|(
expr|struct
name|adapter
operator|*
operator|)
name|arg1
decl_stmt|;
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|int
name|curr_ps
decl_stmt|,
name|new_ps
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|curr_ps
operator|=
name|new_ps
operator|=
name|pci_get_powerstate
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|new_ps
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|)
operator|||
operator|(
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|new_ps
operator|==
name|curr_ps
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|new_ps
operator|==
literal|3
operator|&&
name|curr_ps
operator|==
literal|0
condition|)
name|error
operator|=
name|DEVICE_SUSPEND
argument_list|(
name|dev
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|new_ps
operator|==
literal|0
operator|&&
name|curr_ps
operator|==
literal|3
condition|)
name|error
operator|=
name|DEVICE_RESUME
argument_list|(
name|dev
argument_list|)
expr_stmt|;
else|else
return|return
operator|(
name|EINVAL
operator|)
return|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"New state: %d\n"
argument_list|,
name|pci_get_powerstate
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ixgbe_sysctl_power_state */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/************************************************************************  * ixgbe_sysctl_wol_enable  *  *   Sysctl to enable/disable the WoL capability,  *   if supported by the adapter.  *  *   Values:  *     0 - disabled  *     1 - enabled  ************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_sysctl_wol_enable
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
operator|(
expr|struct
name|adapter
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|int
name|new_wol_enabled
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|new_wol_enabled
operator|=
name|hw
operator|->
name|wol_enabled
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|new_wol_enabled
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|)
operator|||
operator|(
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|new_wol_enabled
operator|=
operator|!
operator|!
operator|(
name|new_wol_enabled
operator|)
expr_stmt|;
if|if
condition|(
name|new_wol_enabled
operator|==
name|hw
operator|->
name|wol_enabled
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|new_wol_enabled
operator|>
literal|0
operator|&&
operator|!
name|adapter
operator|->
name|wol_support
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
else|else
name|hw
operator|->
name|wol_enabled
operator|=
name|new_wol_enabled
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ixgbe_sysctl_wol_enable */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_sysctl_wufc - Wake Up Filter Control  *  *   Sysctl to enable/disable the types of packets that the  *   adapter will wake up on upon receipt.  *   Flags:  *     0x1  - Link Status Change  *     0x2  - Magic Packet  *     0x4  - Direct Exact  *     0x8  - Directed Multicast  *     0x10 - Broadcast  *     0x20 - ARP/IPv4 Request Packet  *     0x40 - Direct IPv4 Packet  *     0x80 - Direct IPv6 Packet  *  *   Settings not listed above will cause the sysctl to return an error.  ************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_sysctl_wufc
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
operator|(
expr|struct
name|adapter
operator|*
operator|)
name|arg1
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|u32
name|new_wufc
decl_stmt|;
name|new_wufc
operator|=
name|adapter
operator|->
name|wufc
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|new_wufc
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|)
operator|||
operator|(
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|new_wufc
operator|==
name|adapter
operator|->
name|wufc
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|new_wufc
operator|&
literal|0xffffff00
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|new_wufc
operator|&=
literal|0xff
expr_stmt|;
name|new_wufc
operator||=
operator|(
literal|0xffffff
operator|&
name|adapter
operator|->
name|wufc
operator|)
expr_stmt|;
name|adapter
operator|->
name|wufc
operator|=
name|new_wufc
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ixgbe_sysctl_wufc */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|IXGBE_DEBUG
end_ifdef

begin_comment
comment|/************************************************************************  * ixgbe_sysctl_print_rss_config  ************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_sysctl_print_rss_config
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
operator|(
expr|struct
name|adapter
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|buf
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|reta_size
decl_stmt|;
name|u32
name|reg
decl_stmt|;
name|buf
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|128
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not allocate sbuf for output.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|// TODO: use sbufs to make a string to print out
comment|/* Set multiplier for RETA setup and table size based on MAC */
switch|switch
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|ixgbe_mac_X550
case|:
case|case
name|ixgbe_mac_X550EM_x
case|:
case|case
name|ixgbe_mac_X550EM_a
case|:
name|reta_size
operator|=
literal|128
expr_stmt|;
break|break;
default|default:
name|reta_size
operator|=
literal|32
expr_stmt|;
break|break;
block|}
comment|/* Print out the redirection table */
name|sbuf_cat
argument_list|(
name|buf
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|reta_size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|<
literal|32
condition|)
block|{
name|reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RETA
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|buf
argument_list|,
literal|"RETA(%2d): 0x%08x\n"
argument_list|,
name|i
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ERETA
argument_list|(
name|i
operator|-
literal|32
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|buf
argument_list|,
literal|"ERETA(%2d): 0x%08x\n"
argument_list|,
name|i
operator|-
literal|32
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
block|}
comment|// TODO: print more config
name|error
operator|=
name|sbuf_finish
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Error finishing sbuf: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ixgbe_sysctl_print_rss_config */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IXGBE_DEBUG */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_sysctl_phy_temp - Retrieve temperature of PHY  *  *   For X552/X557-AT devices using an external PHY  ************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_sysctl_phy_temp
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
operator|(
expr|struct
name|adapter
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|u16
name|reg
decl_stmt|;
if|if
condition|(
name|hw
operator|->
name|device_id
operator|!=
name|IXGBE_DEV_ID_X550EM_X_10G_T
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"Device has no supported external thermal sensor.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_PHY_CURRENT_TEMP
argument_list|,
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE
argument_list|,
operator|&
name|reg
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"Error reading from PHY's current temperature register\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAGAIN
operator|)
return|;
block|}
comment|/* Shift temp for output */
name|reg
operator|=
name|reg
operator|>>
literal|8
expr_stmt|;
return|return
operator|(
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
name|NULL
argument_list|,
name|reg
argument_list|,
name|req
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ixgbe_sysctl_phy_temp */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_sysctl_phy_overtemp_occurred  *  *   Reports (directly from the PHY) whether the current PHY  *   temperature is over the overtemp threshold.  ************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_sysctl_phy_overtemp_occurred
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
operator|(
expr|struct
name|adapter
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|u16
name|reg
decl_stmt|;
if|if
condition|(
name|hw
operator|->
name|device_id
operator|!=
name|IXGBE_DEV_ID_X550EM_X_10G_T
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"Device has no supported external thermal sensor.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_PHY_OVERTEMP_STATUS
argument_list|,
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE
argument_list|,
operator|&
name|reg
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"Error reading from PHY's temperature status register\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAGAIN
operator|)
return|;
block|}
comment|/* Get occurrence bit */
name|reg
operator|=
operator|!
operator|!
operator|(
name|reg
operator|&
literal|0x4000
operator|)
expr_stmt|;
return|return
operator|(
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
literal|0
argument_list|,
name|reg
argument_list|,
name|req
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ixgbe_sysctl_phy_overtemp_occurred */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_sysctl_eee_state  *  *   Sysctl to set EEE power saving feature  *   Values:  *     0      - disable EEE  *     1      - enable EEE  *     (none) - get current device EEE state  ************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_sysctl_eee_state
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
operator|(
expr|struct
name|adapter
operator|*
operator|)
name|arg1
decl_stmt|;
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|int
name|curr_eee
decl_stmt|,
name|new_eee
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|s32
name|retval
decl_stmt|;
name|curr_eee
operator|=
name|new_eee
operator|=
operator|!
operator|!
operator|(
name|adapter
operator|->
name|feat_en
operator|&
name|IXGBE_FEATURE_EEE
operator|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|new_eee
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|)
operator|||
operator|(
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Nothing to do */
if|if
condition|(
name|new_eee
operator|==
name|curr_eee
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Not supported */
if|if
condition|(
operator|!
operator|(
name|adapter
operator|->
name|feat_cap
operator|&
name|IXGBE_FEATURE_EEE
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Bounds checking */
if|if
condition|(
operator|(
name|new_eee
operator|<
literal|0
operator|)
operator|||
operator|(
name|new_eee
operator|>
literal|1
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|retval
operator|=
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|ops
operator|.
name|setup_eee
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|new_eee
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Error in EEE setup: 0x%08X\n"
argument_list|,
name|retval
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Restart auto-neg */
name|ixgbe_init
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"New EEE state: %d\n"
argument_list|,
name|new_eee
argument_list|)
expr_stmt|;
comment|/* Cache new value */
if|if
condition|(
name|new_eee
condition|)
name|adapter
operator|->
name|feat_en
operator||=
name|IXGBE_FEATURE_EEE
expr_stmt|;
else|else
name|adapter
operator|->
name|feat_en
operator|&=
operator|~
name|IXGBE_FEATURE_EEE
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ixgbe_sysctl_eee_state */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_init_device_features  ************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_init_device_features
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|adapter
operator|->
name|feat_cap
operator|=
name|IXGBE_FEATURE_NETMAP
operator||
name|IXGBE_FEATURE_RSS
operator||
name|IXGBE_FEATURE_MSI
operator||
name|IXGBE_FEATURE_MSIX
operator||
name|IXGBE_FEATURE_LEGACY_IRQ
operator||
name|IXGBE_FEATURE_LEGACY_TX
expr_stmt|;
comment|/* Set capabilities first... */
switch|switch
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|ixgbe_mac_82598EB
case|:
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|device_id
operator|==
name|IXGBE_DEV_ID_82598AT
condition|)
name|adapter
operator|->
name|feat_cap
operator||=
name|IXGBE_FEATURE_FAN_FAIL
expr_stmt|;
break|break;
case|case
name|ixgbe_mac_X540
case|:
name|adapter
operator|->
name|feat_cap
operator||=
name|IXGBE_FEATURE_SRIOV
expr_stmt|;
name|adapter
operator|->
name|feat_cap
operator||=
name|IXGBE_FEATURE_FDIR
expr_stmt|;
if|if
condition|(
operator|(
name|adapter
operator|->
name|hw
operator|.
name|device_id
operator|==
name|IXGBE_DEV_ID_X540_BYPASS
operator|)
operator|&&
operator|(
name|adapter
operator|->
name|hw
operator|.
name|bus
operator|.
name|func
operator|==
literal|0
operator|)
condition|)
name|adapter
operator|->
name|feat_cap
operator||=
name|IXGBE_FEATURE_BYPASS
expr_stmt|;
break|break;
case|case
name|ixgbe_mac_X550
case|:
name|adapter
operator|->
name|feat_cap
operator||=
name|IXGBE_FEATURE_TEMP_SENSOR
expr_stmt|;
name|adapter
operator|->
name|feat_cap
operator||=
name|IXGBE_FEATURE_SRIOV
expr_stmt|;
name|adapter
operator|->
name|feat_cap
operator||=
name|IXGBE_FEATURE_FDIR
expr_stmt|;
break|break;
case|case
name|ixgbe_mac_X550EM_x
case|:
name|adapter
operator|->
name|feat_cap
operator||=
name|IXGBE_FEATURE_SRIOV
expr_stmt|;
name|adapter
operator|->
name|feat_cap
operator||=
name|IXGBE_FEATURE_FDIR
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|device_id
operator|==
name|IXGBE_DEV_ID_X550EM_X_KR
condition|)
name|adapter
operator|->
name|feat_cap
operator||=
name|IXGBE_FEATURE_EEE
expr_stmt|;
break|break;
case|case
name|ixgbe_mac_X550EM_a
case|:
name|adapter
operator|->
name|feat_cap
operator||=
name|IXGBE_FEATURE_SRIOV
expr_stmt|;
name|adapter
operator|->
name|feat_cap
operator||=
name|IXGBE_FEATURE_FDIR
expr_stmt|;
name|adapter
operator|->
name|feat_cap
operator|&=
operator|~
name|IXGBE_FEATURE_LEGACY_IRQ
expr_stmt|;
if|if
condition|(
operator|(
name|adapter
operator|->
name|hw
operator|.
name|device_id
operator|==
name|IXGBE_DEV_ID_X550EM_A_1G_T
operator|)
operator|||
operator|(
name|adapter
operator|->
name|hw
operator|.
name|device_id
operator|==
name|IXGBE_DEV_ID_X550EM_A_1G_T_L
operator|)
condition|)
block|{
name|adapter
operator|->
name|feat_cap
operator||=
name|IXGBE_FEATURE_TEMP_SENSOR
expr_stmt|;
name|adapter
operator|->
name|feat_cap
operator||=
name|IXGBE_FEATURE_EEE
expr_stmt|;
block|}
break|break;
case|case
name|ixgbe_mac_82599EB
case|:
name|adapter
operator|->
name|feat_cap
operator||=
name|IXGBE_FEATURE_SRIOV
expr_stmt|;
name|adapter
operator|->
name|feat_cap
operator||=
name|IXGBE_FEATURE_FDIR
expr_stmt|;
if|if
condition|(
operator|(
name|adapter
operator|->
name|hw
operator|.
name|device_id
operator|==
name|IXGBE_DEV_ID_82599_BYPASS
operator|)
operator|&&
operator|(
name|adapter
operator|->
name|hw
operator|.
name|bus
operator|.
name|func
operator|==
literal|0
operator|)
condition|)
name|adapter
operator|->
name|feat_cap
operator||=
name|IXGBE_FEATURE_BYPASS
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|device_id
operator|==
name|IXGBE_DEV_ID_82599_QSFP_SF_QP
condition|)
name|adapter
operator|->
name|feat_cap
operator|&=
operator|~
name|IXGBE_FEATURE_LEGACY_IRQ
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Enabled by default... */
comment|/* Fan failure detection */
if|if
condition|(
name|adapter
operator|->
name|feat_cap
operator|&
name|IXGBE_FEATURE_FAN_FAIL
condition|)
name|adapter
operator|->
name|feat_en
operator||=
name|IXGBE_FEATURE_FAN_FAIL
expr_stmt|;
comment|/* Netmap */
if|if
condition|(
name|adapter
operator|->
name|feat_cap
operator|&
name|IXGBE_FEATURE_NETMAP
condition|)
name|adapter
operator|->
name|feat_en
operator||=
name|IXGBE_FEATURE_NETMAP
expr_stmt|;
comment|/* EEE */
if|if
condition|(
name|adapter
operator|->
name|feat_cap
operator|&
name|IXGBE_FEATURE_EEE
condition|)
name|adapter
operator|->
name|feat_en
operator||=
name|IXGBE_FEATURE_EEE
expr_stmt|;
comment|/* Thermal Sensor */
if|if
condition|(
name|adapter
operator|->
name|feat_cap
operator|&
name|IXGBE_FEATURE_TEMP_SENSOR
condition|)
name|adapter
operator|->
name|feat_en
operator||=
name|IXGBE_FEATURE_TEMP_SENSOR
expr_stmt|;
comment|/* Enabled via global sysctl... */
comment|/* Flow Director */
if|if
condition|(
name|ixgbe_enable_fdir
condition|)
block|{
if|if
condition|(
name|adapter
operator|->
name|feat_cap
operator|&
name|IXGBE_FEATURE_FDIR
condition|)
name|adapter
operator|->
name|feat_en
operator||=
name|IXGBE_FEATURE_FDIR
expr_stmt|;
else|else
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"Device does not support Flow Director. Leaving disabled."
argument_list|)
expr_stmt|;
block|}
comment|/* Legacy (single queue) transmit */
if|if
condition|(
operator|(
name|adapter
operator|->
name|feat_cap
operator|&
name|IXGBE_FEATURE_LEGACY_TX
operator|)
operator|&&
name|ixgbe_enable_legacy_tx
condition|)
name|adapter
operator|->
name|feat_en
operator||=
name|IXGBE_FEATURE_LEGACY_TX
expr_stmt|;
comment|/* 	 * Message Signal Interrupts - Extended (MSI-X) 	 * Normal MSI is only enabled if MSI-X calls fail. 	 */
if|if
condition|(
operator|!
name|ixgbe_enable_msix
condition|)
name|adapter
operator|->
name|feat_cap
operator|&=
operator|~
name|IXGBE_FEATURE_MSIX
expr_stmt|;
comment|/* Receive-Side Scaling (RSS) */
if|if
condition|(
operator|(
name|adapter
operator|->
name|feat_cap
operator|&
name|IXGBE_FEATURE_RSS
operator|)
operator|&&
name|ixgbe_enable_rss
condition|)
name|adapter
operator|->
name|feat_en
operator||=
name|IXGBE_FEATURE_RSS
expr_stmt|;
comment|/* Disable features with unmet dependencies... */
comment|/* No MSI-X */
if|if
condition|(
operator|!
operator|(
name|adapter
operator|->
name|feat_cap
operator|&
name|IXGBE_FEATURE_MSIX
operator|)
condition|)
block|{
name|adapter
operator|->
name|feat_cap
operator|&=
operator|~
name|IXGBE_FEATURE_RSS
expr_stmt|;
name|adapter
operator|->
name|feat_cap
operator|&=
operator|~
name|IXGBE_FEATURE_SRIOV
expr_stmt|;
name|adapter
operator|->
name|feat_en
operator|&=
operator|~
name|IXGBE_FEATURE_RSS
expr_stmt|;
name|adapter
operator|->
name|feat_en
operator|&=
operator|~
name|IXGBE_FEATURE_SRIOV
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ixgbe_init_device_features */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_probe - Device identification routine  *  *   Determines if the driver should be loaded on  *   adapter based on its PCI vendor/device ID.  *  *   return BUS_PROBE_DEFAULT on success, positive on failure  ************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|ixgbe_vendor_info_t
modifier|*
name|ent
decl_stmt|;
name|u16
name|pci_vendor_id
init|=
literal|0
decl_stmt|;
name|u16
name|pci_device_id
init|=
literal|0
decl_stmt|;
name|u16
name|pci_subvendor_id
init|=
literal|0
decl_stmt|;
name|u16
name|pci_subdevice_id
init|=
literal|0
decl_stmt|;
name|char
name|adapter_name
index|[
literal|256
index|]
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixgbe_probe: begin"
argument_list|)
expr_stmt|;
name|pci_vendor_id
operator|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_vendor_id
operator|!=
name|IXGBE_INTEL_VENDOR_ID
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|pci_device_id
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_subvendor_id
operator|=
name|pci_get_subvendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_subdevice_id
operator|=
name|pci_get_subdevice
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ent
operator|=
name|ixgbe_vendor_info_array
expr_stmt|;
while|while
condition|(
name|ent
operator|->
name|vendor_id
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|pci_vendor_id
operator|==
name|ent
operator|->
name|vendor_id
operator|)
operator|&&
operator|(
name|pci_device_id
operator|==
name|ent
operator|->
name|device_id
operator|)
operator|&&
operator|(
operator|(
name|pci_subvendor_id
operator|==
name|ent
operator|->
name|subvendor_id
operator|)
operator|||
operator|(
name|ent
operator|->
name|subvendor_id
operator|==
literal|0
operator|)
operator|)
operator|&&
operator|(
operator|(
name|pci_subdevice_id
operator|==
name|ent
operator|->
name|subdevice_id
operator|)
operator|||
operator|(
name|ent
operator|->
name|subdevice_id
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|adapter_name
argument_list|,
literal|"%s, Version - %s"
argument_list|,
name|ixgbe_strings
index|[
name|ent
operator|->
name|index
index|]
argument_list|,
name|ixgbe_driver_version
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|adapter_name
argument_list|)
expr_stmt|;
operator|++
name|ixgbe_total_ports
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
name|ent
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ixgbe_probe */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_ioctl - Ioctl entry point  *  *   Called when the user wants to configure the interface.  *  *   return 0 on success, positive on failure  ************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
endif|#
directive|endif
name|int
name|error
init|=
literal|0
decl_stmt|;
name|bool
name|avoid_reset
init|=
name|FALSE
decl_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
name|avoid_reset
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
name|avoid_reset
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * Calling init results in link renegotiation, 		 * so we avoid doing it when possible. 		 */
if|if
condition|(
name|avoid_reset
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
name|ixgbe_init
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_NOARP
operator|)
condition|)
name|arp_ifinit
argument_list|(
name|ifp
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFMTU
case|:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl: SIOCSIFMTU (Set Interface MTU)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|>
name|IXGBE_MAX_MTU
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|IXGBE_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
name|adapter
operator|->
name|max_frame_size
operator|=
name|ifp
operator|->
name|if_mtu
operator|+
name|IXGBE_MTU_HDR
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|ixgbe_init_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixgbe_recalculate_max_frame
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|IXGBE_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFFLAGS
case|:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl: SIOCSIFFLAGS (Set Interface Flags)"
argument_list|)
expr_stmt|;
name|IXGBE_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|^
name|adapter
operator|->
name|if_flags
operator|)
operator|&
operator|(
name|IFF_PROMISC
operator||
name|IFF_ALLMULTI
operator|)
condition|)
block|{
name|ixgbe_set_promisc
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|ixgbe_init_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|ixgbe_stop
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|if_flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
name|IXGBE_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl: SIOC(ADD|DEL)MULTI"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|IXGBE_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixgbe_disable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixgbe_set_multi
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixgbe_enable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|IXGBE_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl: SIOCxIFMEDIA (Get/Set Interface Media)"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
block|{
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl: SIOCSIFCAP (Set Capabilities)"
argument_list|)
expr_stmt|;
name|int
name|mask
init|=
name|ifr
operator|->
name|ifr_reqcap
operator|^
name|ifp
operator|->
name|if_capenable
decl_stmt|;
if|if
condition|(
operator|!
name|mask
condition|)
break|break;
comment|/* HW cannot turn these on/off separately */
if|if
condition|(
name|mask
operator|&
operator|(
name|IFCAP_RXCSUM
operator||
name|IFCAP_RXCSUM_IPV6
operator|)
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_RXCSUM
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_RXCSUM_IPV6
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TXCSUM
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM_IPV6
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TXCSUM_IPV6
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO4
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TSO4
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO6
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TSO6
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_LRO
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_LRO
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWTAGGING
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWTAGGING
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWFILTER
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWFILTER
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWTSO
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWTSO
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|IXGBE_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixgbe_init_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|IXGBE_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
name|VLAN_CAPABILITIES
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
break|break;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|1100036
case|case
name|SIOCGI2C
case|:
block|{
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|struct
name|ifi2creq
name|i2c
decl_stmt|;
name|int
name|i
decl_stmt|;
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl: SIOCGI2C (Get I2C Data)"
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|ifr
operator|->
name|ifr_data
argument_list|,
operator|&
name|i2c
argument_list|,
sizeof|sizeof
argument_list|(
name|i2c
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|i2c
operator|.
name|dev_addr
operator|!=
literal|0xA0
operator|&&
name|i2c
operator|.
name|dev_addr
operator|!=
literal|0xA2
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i2c
operator|.
name|len
operator|>
sizeof|sizeof
argument_list|(
name|i2c
operator|.
name|data
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|i2c
operator|.
name|len
condition|;
name|i
operator|++
control|)
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_i2c_byte
argument_list|(
name|hw
argument_list|,
name|i2c
operator|.
name|offset
operator|+
name|i
argument_list|,
name|i2c
operator|.
name|dev_addr
argument_list|,
operator|&
name|i2c
operator|.
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|i2c
argument_list|,
name|ifr
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|i2c
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
default|default:
name|IOCTL_DEBUGOUT1
argument_list|(
literal|"ioctl: UNKNOWN (0x%X)\n"
argument_list|,
operator|(
name|int
operator|)
name|command
argument_list|)
expr_stmt|;
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ixgbe_ioctl */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_check_fan_failure  ************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_check_fan_failure
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|u32
name|reg
parameter_list|,
name|bool
name|in_interrupt
parameter_list|)
block|{
name|u32
name|mask
decl_stmt|;
name|mask
operator|=
operator|(
name|in_interrupt
operator|)
condition|?
name|IXGBE_EICR_GPI_SDP1_BY_MAC
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
else|:
name|IXGBE_ESDP_SDP1
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|mask
condition|)
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"\nCRITICAL: FAN FAILURE!! REPLACE IMMEDIATELY!!\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ixgbe_check_fan_failure */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_handle_que  ************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_handle_que
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|ix_queue
modifier|*
name|que
init|=
name|context
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|que
operator|->
name|adapter
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|que
operator|->
name|txr
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|ixgbe_rxeof
argument_list|(
name|que
argument_list|)
expr_stmt|;
name|IXGBE_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|ixgbe_txeof
argument_list|(
name|txr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ixgbe_ring_empty
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|)
condition|)
name|ixgbe_start_locked
argument_list|(
name|ifp
argument_list|,
name|txr
argument_list|)
expr_stmt|;
name|IXGBE_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
block|}
comment|/* Re-enable this interrupt */
if|if
condition|(
name|que
operator|->
name|res
operator|!=
name|NULL
condition|)
name|ixgbe_enable_queue
argument_list|(
name|adapter
argument_list|,
name|que
operator|->
name|msix
argument_list|)
expr_stmt|;
else|else
name|ixgbe_enable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ixgbe_handle_que */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_allocate_legacy - Setup the Legacy or MSI Interrupt handler  ************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_allocate_legacy
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|struct
name|ix_queue
modifier|*
name|que
init|=
name|adapter
operator|->
name|queues
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* We allocate a single interrupt resource */
name|adapter
operator|->
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|adapter
operator|->
name|link_rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate bus resource: interrupt\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * Try allocating a fast interrupt and the associated deferred 	 * processing contexts. 	 */
if|if
condition|(
operator|!
operator|(
name|adapter
operator|->
name|feat_en
operator|&
name|IXGBE_FEATURE_LEGACY_TX
operator|)
condition|)
name|TASK_INIT
argument_list|(
operator|&
name|txr
operator|->
name|txq_task
argument_list|,
literal|0
argument_list|,
name|ixgbe_deferred_mq_start
argument_list|,
name|txr
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|que
operator|->
name|que_task
argument_list|,
literal|0
argument_list|,
name|ixgbe_handle_que
argument_list|,
name|que
argument_list|)
expr_stmt|;
name|que
operator|->
name|tq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"ixgbe_que"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|que
operator|->
name|tq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|que
operator|->
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s ixq"
argument_list|,
name|device_get_nameunit
argument_list|(
name|adapter
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Tasklets for Link, SFP and Multispeed Fiber */
name|TASK_INIT
argument_list|(
operator|&
name|adapter
operator|->
name|link_task
argument_list|,
literal|0
argument_list|,
name|ixgbe_handle_link
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|adapter
operator|->
name|mod_task
argument_list|,
literal|0
argument_list|,
name|ixgbe_handle_mod
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|adapter
operator|->
name|msf_task
argument_list|,
literal|0
argument_list|,
name|ixgbe_handle_msf
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|adapter
operator|->
name|phy_task
argument_list|,
literal|0
argument_list|,
name|ixgbe_handle_phy
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|feat_en
operator|&
name|IXGBE_FEATURE_FDIR
condition|)
name|TASK_INIT
argument_list|(
operator|&
name|adapter
operator|->
name|fdir_task
argument_list|,
literal|0
argument_list|,
name|ixgbe_reinit_fdir
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|tq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"ixgbe_link"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|adapter
operator|->
name|tq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|adapter
operator|->
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s linkq"
argument_list|,
name|device_get_nameunit
argument_list|(
name|adapter
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|adapter
operator|->
name|res
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|ixgbe_legacy_irq
argument_list|,
name|que
argument_list|,
operator|&
name|adapter
operator|->
name|tag
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to register fast interrupt handler: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|que
operator|->
name|tq
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|adapter
operator|->
name|tq
argument_list|)
expr_stmt|;
name|que
operator|->
name|tq
operator|=
name|NULL
expr_stmt|;
name|adapter
operator|->
name|tq
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* For simplicity in the handlers */
name|adapter
operator|->
name|active_queues
operator|=
name|IXGBE_EIMS_ENABLE_MASK
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ixgbe_allocate_legacy */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_allocate_msix - Setup MSI-X Interrupt resources and handlers  ************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_allocate_msix
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|struct
name|ix_queue
modifier|*
name|que
init|=
name|adapter
operator|->
name|queues
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
name|int
name|error
decl_stmt|,
name|rid
decl_stmt|,
name|vector
init|=
literal|0
decl_stmt|;
name|int
name|cpu_id
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|rss_buckets
init|=
literal|0
decl_stmt|;
name|cpuset_t
name|cpu_mask
decl_stmt|;
comment|/* 	 * If we're doing RSS, the number of queues needs to 	 * match the number of RSS buckets that are configured. 	 * 	 * + If there's more queues than RSS buckets, we'll end 	 *   up with queues that get no traffic. 	 * 	 * + If there's more RSS buckets than queues, we'll end 	 *   up having multiple RSS buckets map to the same queue, 	 *   so there'll be some contention. 	 */
name|rss_buckets
operator|=
name|rss_getnumbuckets
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|adapter
operator|->
name|feat_en
operator|&
name|IXGBE_FEATURE_RSS
operator|)
operator|&&
operator|(
name|adapter
operator|->
name|num_queues
operator|!=
name|rss_buckets
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: number of queues (%d) != number of RSS buckets (%d); performance will be impacted.\n"
argument_list|,
name|__func__
argument_list|,
name|adapter
operator|->
name|num_queues
argument_list|,
name|rss_buckets
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|vector
operator|++
operator|,
name|que
operator|++
operator|,
name|txr
operator|++
control|)
block|{
name|rid
operator|=
name|vector
operator|+
literal|1
expr_stmt|;
name|que
operator|->
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|que
operator|->
name|res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate bus resource: que interrupt [%d]\n"
argument_list|,
name|vector
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Set the handler function */
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|que
operator|->
name|res
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|ixgbe_msix_que
argument_list|,
name|que
argument_list|,
operator|&
name|que
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|que
operator|->
name|res
operator|=
name|NULL
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to register QUE handler"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800504
name|bus_describe_intr
argument_list|(
name|dev
argument_list|,
name|que
operator|->
name|res
argument_list|,
name|que
operator|->
name|tag
argument_list|,
literal|"q%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|que
operator|->
name|msix
operator|=
name|vector
expr_stmt|;
name|adapter
operator|->
name|active_queues
operator||=
call|(
name|u64
call|)
argument_list|(
literal|1
operator|<<
name|que
operator|->
name|msix
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|feat_en
operator|&
name|IXGBE_FEATURE_RSS
condition|)
block|{
comment|/* 			 * The queue ID is used as the RSS layer bucket ID. 			 * We look up the queue ID -> RSS CPU ID and select 			 * that. 			 */
name|cpu_id
operator|=
name|rss_getcpu
argument_list|(
name|i
operator|%
name|rss_buckets
argument_list|)
expr_stmt|;
name|CPU_SETOF
argument_list|(
name|cpu_id
argument_list|,
operator|&
name|cpu_mask
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Bind the MSI-X vector, and thus the 			 * rings to the corresponding CPU. 			 * 			 * This just happens to match the default RSS 			 * round-robin bucket -> queue -> CPU allocation. 			 */
if|if
condition|(
name|adapter
operator|->
name|num_queues
operator|>
literal|1
condition|)
name|cpu_id
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|adapter
operator|->
name|num_queues
operator|>
literal|1
condition|)
name|bus_bind_intr
argument_list|(
name|dev
argument_list|,
name|que
operator|->
name|res
argument_list|,
name|cpu_id
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IXGBE_DEBUG
if|if
condition|(
name|adapter
operator|->
name|feat_en
operator|&
name|IXGBE_FEATURE_RSS
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Bound RSS bucket %d to CPU %d\n"
argument_list|,
name|i
argument_list|,
name|cpu_id
argument_list|)
expr_stmt|;
else|else
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Bound queue %d to cpu %d\n"
argument_list|,
name|i
argument_list|,
name|cpu_id
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* IXGBE_DEBUG */
if|if
condition|(
operator|!
operator|(
name|adapter
operator|->
name|feat_en
operator|&
name|IXGBE_FEATURE_LEGACY_TX
operator|)
condition|)
name|TASK_INIT
argument_list|(
operator|&
name|txr
operator|->
name|txq_task
argument_list|,
literal|0
argument_list|,
name|ixgbe_deferred_mq_start
argument_list|,
name|txr
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|que
operator|->
name|que_task
argument_list|,
literal|0
argument_list|,
name|ixgbe_handle_que
argument_list|,
name|que
argument_list|)
expr_stmt|;
name|que
operator|->
name|tq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"ixgbe_que"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|que
operator|->
name|tq
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|1100000
name|taskqueue_start_threads
argument_list|(
operator|&
name|que
operator|->
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s:q%d"
argument_list|,
name|device_get_nameunit
argument_list|(
name|adapter
operator|->
name|dev
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|adapter
operator|->
name|feat_en
operator|&
name|IXGBE_FEATURE_RSS
condition|)
name|taskqueue_start_threads_cpuset
argument_list|(
operator|&
name|que
operator|->
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
operator|&
name|cpu_mask
argument_list|,
literal|"%s (bucket %d)"
argument_list|,
name|device_get_nameunit
argument_list|(
name|adapter
operator|->
name|dev
argument_list|)
argument_list|,
name|cpu_id
argument_list|)
expr_stmt|;
else|else
name|taskqueue_start_threads_cpuset
argument_list|(
operator|&
name|que
operator|->
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
name|NULL
argument_list|,
literal|"%s:q%d"
argument_list|,
name|device_get_nameunit
argument_list|(
name|adapter
operator|->
name|dev
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* and Link */
name|adapter
operator|->
name|link_rid
operator|=
name|vector
operator|+
literal|1
expr_stmt|;
name|adapter
operator|->
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|adapter
operator|->
name|link_rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|adapter
operator|->
name|res
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate bus resource: Link interrupt [%d]\n"
argument_list|,
name|adapter
operator|->
name|link_rid
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Set the link handler function */
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|adapter
operator|->
name|res
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|ixgbe_msix_link
argument_list|,
name|adapter
argument_list|,
operator|&
name|adapter
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|adapter
operator|->
name|res
operator|=
name|NULL
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to register LINK handler"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800504
name|bus_describe_intr
argument_list|(
name|dev
argument_list|,
name|adapter
operator|->
name|res
argument_list|,
name|adapter
operator|->
name|tag
argument_list|,
literal|"link"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|adapter
operator|->
name|vector
operator|=
name|vector
expr_stmt|;
comment|/* Tasklets for Link, SFP and Multispeed Fiber */
name|TASK_INIT
argument_list|(
operator|&
name|adapter
operator|->
name|link_task
argument_list|,
literal|0
argument_list|,
name|ixgbe_handle_link
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|adapter
operator|->
name|mod_task
argument_list|,
literal|0
argument_list|,
name|ixgbe_handle_mod
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|adapter
operator|->
name|msf_task
argument_list|,
literal|0
argument_list|,
name|ixgbe_handle_msf
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|feat_cap
operator|&
name|IXGBE_FEATURE_SRIOV
condition|)
name|TASK_INIT
argument_list|(
operator|&
name|adapter
operator|->
name|mbx_task
argument_list|,
literal|0
argument_list|,
name|ixgbe_handle_mbx
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|adapter
operator|->
name|phy_task
argument_list|,
literal|0
argument_list|,
name|ixgbe_handle_phy
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|feat_en
operator|&
name|IXGBE_FEATURE_FDIR
condition|)
name|TASK_INIT
argument_list|(
operator|&
name|adapter
operator|->
name|fdir_task
argument_list|,
literal|0
argument_list|,
name|ixgbe_reinit_fdir
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|tq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"ixgbe_link"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|adapter
operator|->
name|tq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|adapter
operator|->
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s linkq"
argument_list|,
name|device_get_nameunit
argument_list|(
name|adapter
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ixgbe_allocate_msix */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_configure_interrupts  *  *   Setup MSI-X, MSI, or legacy interrupts (in that order).  *   This will also depend on user settings.  ************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_configure_interrupts
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|int
name|rid
decl_stmt|,
name|want
decl_stmt|,
name|queues
decl_stmt|,
name|msgs
decl_stmt|;
comment|/* Default to 1 queue if MSI-X setup fails */
name|adapter
operator|->
name|num_queues
operator|=
literal|1
expr_stmt|;
comment|/* Override by tuneable */
if|if
condition|(
operator|!
operator|(
name|adapter
operator|->
name|feat_cap
operator|&
name|IXGBE_FEATURE_MSIX
operator|)
condition|)
goto|goto
name|msi
goto|;
comment|/* First try MSI-X */
name|msgs
operator|=
name|pci_msix_count
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|msgs
operator|==
literal|0
condition|)
goto|goto
name|msi
goto|;
name|rid
operator|=
name|PCIR_BAR
argument_list|(
name|MSIX_82598_BAR
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|msix_mem
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|msix_mem
operator|==
name|NULL
condition|)
block|{
name|rid
operator|+=
literal|4
expr_stmt|;
comment|/* 82599 maps in higher BAR */
name|adapter
operator|->
name|msix_mem
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|adapter
operator|->
name|msix_mem
operator|==
name|NULL
condition|)
block|{
comment|/* May not be enabled */
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"Unable to map MSI-X table.\n"
argument_list|)
expr_stmt|;
goto|goto
name|msi
goto|;
block|}
comment|/* Figure out a reasonable auto config value */
name|queues
operator|=
name|min
argument_list|(
name|mp_ncpus
argument_list|,
name|msgs
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* If we're doing RSS, clamp at the number of RSS buckets */
if|if
condition|(
name|adapter
operator|->
name|feat_en
operator|&
name|IXGBE_FEATURE_RSS
condition|)
name|queues
operator|=
name|min
argument_list|(
name|queues
argument_list|,
name|rss_getnumbuckets
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|ixgbe_num_queues
operator|>
name|queues
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"ixgbe_num_queues (%d) is too large, using reduced amount (%d).\n"
argument_list|,
name|ixgbe_num_queues
argument_list|,
name|queues
argument_list|)
expr_stmt|;
name|ixgbe_num_queues
operator|=
name|queues
expr_stmt|;
block|}
if|if
condition|(
name|ixgbe_num_queues
operator|!=
literal|0
condition|)
name|queues
operator|=
name|ixgbe_num_queues
expr_stmt|;
comment|/* Set max queues to 8 when autoconfiguring */
else|else
name|queues
operator|=
name|min
argument_list|(
name|queues
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* reflect correct sysctl value */
name|ixgbe_num_queues
operator|=
name|queues
expr_stmt|;
comment|/* 	 * Want one vector (RX/TX pair) per queue 	 * plus an additional for Link. 	 */
name|want
operator|=
name|queues
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|msgs
operator|>=
name|want
condition|)
name|msgs
operator|=
name|want
expr_stmt|;
else|else
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"MSI-X Configuration Problem, %d vectors but %d queues wanted!\n"
argument_list|,
name|msgs
argument_list|,
name|want
argument_list|)
expr_stmt|;
goto|goto
name|msi
goto|;
block|}
if|if
condition|(
operator|(
name|pci_alloc_msix
argument_list|(
name|dev
argument_list|,
operator|&
name|msgs
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|msgs
operator|==
name|want
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"Using MSI-X interrupts with %d vectors\n"
argument_list|,
name|msgs
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|num_queues
operator|=
name|queues
expr_stmt|;
name|adapter
operator|->
name|feat_en
operator||=
name|IXGBE_FEATURE_MSIX
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * MSI-X allocation failed or provided us with 	 * less vectors than needed. Free MSI-X resources 	 * and we'll try enabling MSI. 	 */
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|msi
label|:
comment|/* Without MSI-X, some features are no longer supported */
name|adapter
operator|->
name|feat_cap
operator|&=
operator|~
name|IXGBE_FEATURE_RSS
expr_stmt|;
name|adapter
operator|->
name|feat_en
operator|&=
operator|~
name|IXGBE_FEATURE_RSS
expr_stmt|;
name|adapter
operator|->
name|feat_cap
operator|&=
operator|~
name|IXGBE_FEATURE_SRIOV
expr_stmt|;
name|adapter
operator|->
name|feat_en
operator|&=
operator|~
name|IXGBE_FEATURE_SRIOV
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|msix_mem
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|rid
argument_list|,
name|adapter
operator|->
name|msix_mem
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|msix_mem
operator|=
name|NULL
expr_stmt|;
block|}
name|msgs
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pci_alloc_msi
argument_list|(
name|dev
argument_list|,
operator|&
name|msgs
argument_list|)
operator|==
literal|0
condition|)
block|{
name|adapter
operator|->
name|feat_en
operator||=
name|IXGBE_FEATURE_MSI
expr_stmt|;
name|adapter
operator|->
name|link_rid
operator|=
literal|1
expr_stmt|;
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"Using an MSI interrupt\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|adapter
operator|->
name|feat_cap
operator|&
name|IXGBE_FEATURE_LEGACY_IRQ
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"Device does not support legacy interrupts.\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|adapter
operator|->
name|feat_en
operator||=
name|IXGBE_FEATURE_LEGACY_IRQ
expr_stmt|;
name|adapter
operator|->
name|link_rid
operator|=
literal|0
expr_stmt|;
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"Using a Legacy interrupt\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ixgbe_configure_interrupts */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_handle_link - Tasklet for MSI-X Link interrupts  *  *   Done outside of interrupt context since the driver might sleep  ************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_handle_link
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|context
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|ixgbe_check_link
argument_list|(
name|hw
argument_list|,
operator|&
name|adapter
operator|->
name|link_speed
argument_list|,
operator|&
name|adapter
operator|->
name|link_up
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ixgbe_update_link_status
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Re-enable link interrupts */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EIMS
argument_list|,
name|IXGBE_EIMS_LSC
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ixgbe_handle_link */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_rearm_queues  ************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_rearm_queues
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|u64
name|queues
parameter_list|)
block|{
name|u32
name|mask
decl_stmt|;
switch|switch
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|ixgbe_mac_82598EB
case|:
name|mask
operator|=
operator|(
name|IXGBE_EIMS_RTX_QUEUE
operator|&
name|queues
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_EICS
argument_list|,
name|mask
argument_list|)
expr_stmt|;
break|break;
case|case
name|ixgbe_mac_82599EB
case|:
case|case
name|ixgbe_mac_X540
case|:
case|case
name|ixgbe_mac_X550
case|:
case|case
name|ixgbe_mac_X550EM_x
case|:
case|case
name|ixgbe_mac_X550EM_a
case|:
name|mask
operator|=
operator|(
name|queues
operator|&
literal|0xFFFFFFFF
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_EICS_EX
argument_list|(
literal|0
argument_list|)
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|mask
operator|=
operator|(
name|queues
operator|>>
literal|32
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_EICS_EX
argument_list|(
literal|1
argument_list|)
argument_list|,
name|mask
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* ixgbe_rearm_queues */
end_comment

end_unit

