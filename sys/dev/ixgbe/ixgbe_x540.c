begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************    Copyright (c) 2001-2012, Intel Corporation    All rights reserved.      Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are met:       1. Redistributions of source code must retain the above copyright notice,        this list of conditions and the following disclaimer.       2. Redistributions in binary form must reproduce the above copyright        notice, this list of conditions and the following disclaimer in the        documentation and/or other materials provided with the distribution.       3. Neither the name of the Intel Corporation nor the names of its        contributors may be used to endorse or promote products derived from        this software without specific prior written permission.      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  ******************************************************************************/
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_include
include|#
directive|include
file|"ixgbe_x540.h"
end_include

begin_include
include|#
directive|include
file|"ixgbe_type.h"
end_include

begin_include
include|#
directive|include
file|"ixgbe_api.h"
end_include

begin_include
include|#
directive|include
file|"ixgbe_common.h"
end_include

begin_include
include|#
directive|include
file|"ixgbe_phy.h"
end_include

begin_function_decl
specifier|static
name|s32
name|ixgbe_update_flash_X540
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|ixgbe_poll_flash_update_done_X540
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|ixgbe_get_swfw_sync_semaphore
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_release_swfw_sync_semaphore
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  *  ixgbe_init_ops_X540 - Inits func ptrs and MAC type  *  @hw: pointer to hardware structure  *  *  Initialize the function pointers and assign the MAC type for X540.  *  Does not touch the hardware.  **/
end_comment

begin_function
name|s32
name|ixgbe_init_ops_X540
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|ixgbe_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|struct
name|ixgbe_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|struct
name|ixgbe_eeprom_info
modifier|*
name|eeprom
init|=
operator|&
name|hw
operator|->
name|eeprom
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_init_ops_X540"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|ixgbe_init_phy_ops_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|ixgbe_init_ops_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* EEPROM */
name|eeprom
operator|->
name|ops
operator|.
name|init_params
operator|=
operator|&
name|ixgbe_init_eeprom_params_X540
expr_stmt|;
name|eeprom
operator|->
name|ops
operator|.
name|read
operator|=
operator|&
name|ixgbe_read_eerd_X540
expr_stmt|;
name|eeprom
operator|->
name|ops
operator|.
name|read_buffer
operator|=
operator|&
name|ixgbe_read_eerd_buffer_X540
expr_stmt|;
name|eeprom
operator|->
name|ops
operator|.
name|write
operator|=
operator|&
name|ixgbe_write_eewr_X540
expr_stmt|;
name|eeprom
operator|->
name|ops
operator|.
name|write_buffer
operator|=
operator|&
name|ixgbe_write_eewr_buffer_X540
expr_stmt|;
name|eeprom
operator|->
name|ops
operator|.
name|update_checksum
operator|=
operator|&
name|ixgbe_update_eeprom_checksum_X540
expr_stmt|;
name|eeprom
operator|->
name|ops
operator|.
name|validate_checksum
operator|=
operator|&
name|ixgbe_validate_eeprom_checksum_X540
expr_stmt|;
name|eeprom
operator|->
name|ops
operator|.
name|calc_checksum
operator|=
operator|&
name|ixgbe_calc_eeprom_checksum_X540
expr_stmt|;
comment|/* PHY */
name|phy
operator|->
name|ops
operator|.
name|init
operator|=
operator|&
name|ixgbe_init_phy_ops_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|reset
operator|=
name|NULL
expr_stmt|;
comment|/* MAC */
name|mac
operator|->
name|ops
operator|.
name|reset_hw
operator|=
operator|&
name|ixgbe_reset_hw_X540
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|enable_relaxed_ordering
operator|=
operator|&
name|ixgbe_enable_relaxed_ordering_gen2
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_media_type
operator|=
operator|&
name|ixgbe_get_media_type_X540
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_supported_physical_layer
operator|=
operator|&
name|ixgbe_get_supported_physical_layer_X540
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|read_analog_reg8
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|write_analog_reg8
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|start_hw
operator|=
operator|&
name|ixgbe_start_hw_X540
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_san_mac_addr
operator|=
operator|&
name|ixgbe_get_san_mac_addr_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|set_san_mac_addr
operator|=
operator|&
name|ixgbe_set_san_mac_addr_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_device_caps
operator|=
operator|&
name|ixgbe_get_device_caps_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_wwn_prefix
operator|=
operator|&
name|ixgbe_get_wwn_prefix_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_fcoe_boot_status
operator|=
operator|&
name|ixgbe_get_fcoe_boot_status_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|acquire_swfw_sync
operator|=
operator|&
name|ixgbe_acquire_swfw_sync_X540
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|release_swfw_sync
operator|=
operator|&
name|ixgbe_release_swfw_sync_X540
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|disable_sec_rx_path
operator|=
operator|&
name|ixgbe_disable_sec_rx_path_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|enable_sec_rx_path
operator|=
operator|&
name|ixgbe_enable_sec_rx_path_generic
expr_stmt|;
comment|/* RAR, Multicast, VLAN */
name|mac
operator|->
name|ops
operator|.
name|set_vmdq
operator|=
operator|&
name|ixgbe_set_vmdq_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|clear_vmdq
operator|=
operator|&
name|ixgbe_clear_vmdq_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|insert_mac_addr
operator|=
operator|&
name|ixgbe_insert_mac_addr_generic
expr_stmt|;
name|mac
operator|->
name|rar_highwater
operator|=
literal|1
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|set_vfta
operator|=
operator|&
name|ixgbe_set_vfta_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|set_vlvf
operator|=
operator|&
name|ixgbe_set_vlvf_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|clear_vfta
operator|=
operator|&
name|ixgbe_clear_vfta_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|init_uta_tables
operator|=
operator|&
name|ixgbe_init_uta_tables_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|set_mac_anti_spoofing
operator|=
operator|&
name|ixgbe_set_mac_anti_spoofing
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|set_vlan_anti_spoofing
operator|=
operator|&
name|ixgbe_set_vlan_anti_spoofing
expr_stmt|;
comment|/* Link */
name|mac
operator|->
name|ops
operator|.
name|get_link_capabilities
operator|=
operator|&
name|ixgbe_get_copper_link_capabilities_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|setup_link
operator|=
operator|&
name|ixgbe_setup_mac_link_X540
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|setup_rxpba
operator|=
operator|&
name|ixgbe_set_rxpba_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|check_link
operator|=
operator|&
name|ixgbe_check_mac_link_generic
expr_stmt|;
name|mac
operator|->
name|mcft_size
operator|=
literal|128
expr_stmt|;
name|mac
operator|->
name|vft_size
operator|=
literal|128
expr_stmt|;
name|mac
operator|->
name|num_rar_entries
operator|=
literal|128
expr_stmt|;
name|mac
operator|->
name|rx_pb_size
operator|=
literal|384
expr_stmt|;
name|mac
operator|->
name|max_tx_queues
operator|=
literal|128
expr_stmt|;
name|mac
operator|->
name|max_rx_queues
operator|=
literal|128
expr_stmt|;
name|mac
operator|->
name|max_msix_vectors
operator|=
name|ixgbe_get_pcie_msix_count_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* 	 * FWSM register 	 * ARC supported; valid only if manageability features are 	 * enabled. 	 */
name|mac
operator|->
name|arc_subsystem_valid
operator|=
operator|(
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FWSM
argument_list|)
operator|&
name|IXGBE_FWSM_MODE_MASK
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|hw
operator|->
name|mbx
operator|.
name|ops
operator|.
name|init_params
operator|=
name|ixgbe_init_mbx_params_pf
expr_stmt|;
comment|/* LEDs */
name|mac
operator|->
name|ops
operator|.
name|blink_led_start
operator|=
name|ixgbe_blink_led_start_X540
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|blink_led_stop
operator|=
name|ixgbe_blink_led_stop_X540
expr_stmt|;
comment|/* Manageability interface */
name|mac
operator|->
name|ops
operator|.
name|set_fw_drv_ver
operator|=
operator|&
name|ixgbe_set_fw_drv_ver_generic
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_link_capabilities_X540 - Determines link capabilities  *  @hw: pointer to hardware structure  *  @speed: pointer to link speed  *  @autoneg: TRUE when autoneg or autotry is enabled  *  *  Determines the link capabilities by reading the AUTOC register.  **/
end_comment

begin_function
name|s32
name|ixgbe_get_link_capabilities_X540
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
modifier|*
name|speed
parameter_list|,
name|bool
modifier|*
name|autoneg
parameter_list|)
block|{
name|ixgbe_get_copper_link_capabilities_generic
argument_list|(
name|hw
argument_list|,
name|speed
argument_list|,
name|autoneg
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_media_type_X540 - Get media type  *  @hw: pointer to hardware structure  *  *  Returns the media type (fiber, copper, backplane)  **/
end_comment

begin_function
name|enum
name|ixgbe_media_type
name|ixgbe_get_media_type_X540
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|UNREFERENCED_1PARAMETER
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|ixgbe_media_type_copper
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_setup_mac_link_X540 - Sets the auto advertised capabilities  *  @hw: pointer to hardware structure  *  @speed: new link speed  *  @autoneg: TRUE if autonegotiation enabled  *  @autoneg_wait_to_complete: TRUE when waiting for completion is needed  **/
end_comment

begin_function
name|s32
name|ixgbe_setup_mac_link_X540
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
name|speed
parameter_list|,
name|bool
name|autoneg
parameter_list|,
name|bool
name|autoneg_wait_to_complete
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_setup_mac_link_X540"
argument_list|)
expr_stmt|;
return|return
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|setup_link_speed
argument_list|(
name|hw
argument_list|,
name|speed
argument_list|,
name|autoneg
argument_list|,
name|autoneg_wait_to_complete
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_reset_hw_X540 - Perform hardware reset  *  @hw: pointer to hardware structure  *  *  Resets the hardware by resetting the transmit and receive units, masks  *  and clears all interrupts, and perform a reset.  **/
end_comment

begin_function
name|s32
name|ixgbe_reset_hw_X540
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|u32
name|ctrl
decl_stmt|,
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_reset_hw_X540"
argument_list|)
expr_stmt|;
comment|/* Call adapter stop to disable tx/rx and clear interrupts */
name|status
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|stop_adapter
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|reset_hw_out
goto|;
comment|/* flush pending Tx transactions */
name|ixgbe_clear_tx_pending
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|mac_reset_top
label|:
name|ctrl
operator|=
name|IXGBE_CTRL_RST
expr_stmt|;
name|ctrl
operator||=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CTRL
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Poll for reset bit to self-clear indicating reset is complete */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ctrl
operator|&
name|IXGBE_CTRL_RST_MASK
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|ctrl
operator|&
name|IXGBE_CTRL_RST_MASK
condition|)
block|{
name|status
operator|=
name|IXGBE_ERR_RESET_FAILED
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Reset polling failed to complete.\n"
argument_list|)
expr_stmt|;
block|}
name|msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* 	 * Double resets are required for recovery from certain error 	 * conditions.  Between resets, it is necessary to stall to allow time 	 * for any pending HW events to complete. 	 */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|flags
operator|&
name|IXGBE_FLAGS_DOUBLE_RESET_REQUIRED
condition|)
block|{
name|hw
operator|->
name|mac
operator|.
name|flags
operator|&=
operator|~
name|IXGBE_FLAGS_DOUBLE_RESET_REQUIRED
expr_stmt|;
goto|goto
name|mac_reset_top
goto|;
block|}
comment|/* Set the Rx packet buffer size. */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXPBSIZE
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|384
operator|<<
name|IXGBE_RXPBSIZE_SHIFT
argument_list|)
expr_stmt|;
comment|/* Store the permanent mac address */
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|get_mac_addr
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|perm_addr
argument_list|)
expr_stmt|;
comment|/* 	 * Store MAC address from RAR0, clear receive address registers, and 	 * clear the multicast table.  Also reset num_rar_entries to 128, 	 * since we modify this value when programming the SAN MAC address. 	 */
name|hw
operator|->
name|mac
operator|.
name|num_rar_entries
operator|=
literal|128
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|init_rx_addrs
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Store the permanent SAN mac address */
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|get_san_mac_addr
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|san_addr
argument_list|)
expr_stmt|;
comment|/* Add the SAN MAC address to the RAR only if it's a valid address */
if|if
condition|(
name|ixgbe_validate_mac_addr
argument_list|(
name|hw
operator|->
name|mac
operator|.
name|san_addr
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|set_rar
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|num_rar_entries
operator|-
literal|1
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|san_addr
argument_list|,
literal|0
argument_list|,
name|IXGBE_RAH_AV
argument_list|)
expr_stmt|;
comment|/* Reserve the last RAR for the SAN MAC address */
name|hw
operator|->
name|mac
operator|.
name|num_rar_entries
operator|--
expr_stmt|;
block|}
comment|/* Store the alternative WWNN/WWPN prefix */
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|get_wwn_prefix
argument_list|(
name|hw
argument_list|,
operator|&
name|hw
operator|->
name|mac
operator|.
name|wwnn_prefix
argument_list|,
operator|&
name|hw
operator|->
name|mac
operator|.
name|wwpn_prefix
argument_list|)
expr_stmt|;
name|reset_hw_out
label|:
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_start_hw_X540 - Prepare hardware for Tx/Rx  *  @hw: pointer to hardware structure  *  *  Starts the hardware using the generic start_hw function  *  and the generation start_hw function.  *  Then performs revision-specific operations, if any.  **/
end_comment

begin_function
name|s32
name|ixgbe_start_hw_X540
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_start_hw_X540"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|ixgbe_start_hw_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|ixgbe_start_hw_gen2
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_supported_physical_layer_X540 - Returns physical layer type  *  @hw: pointer to hardware structure  *  *  Determines physical layer capabilities of the current configuration.  **/
end_comment

begin_function
name|u32
name|ixgbe_get_supported_physical_layer_X540
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|physical_layer
init|=
name|IXGBE_PHYSICAL_LAYER_UNKNOWN
decl_stmt|;
name|u16
name|ext_ability
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_supported_physical_layer_X540"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_PHY_EXT_ABILITY
argument_list|,
name|IXGBE_MDIO_PMA_PMD_DEV_TYPE
argument_list|,
operator|&
name|ext_ability
argument_list|)
expr_stmt|;
if|if
condition|(
name|ext_ability
operator|&
name|IXGBE_MDIO_PHY_10GBASET_ABILITY
condition|)
name|physical_layer
operator||=
name|IXGBE_PHYSICAL_LAYER_10GBASE_T
expr_stmt|;
if|if
condition|(
name|ext_ability
operator|&
name|IXGBE_MDIO_PHY_1000BASET_ABILITY
condition|)
name|physical_layer
operator||=
name|IXGBE_PHYSICAL_LAYER_1000BASE_T
expr_stmt|;
if|if
condition|(
name|ext_ability
operator|&
name|IXGBE_MDIO_PHY_100BASETX_ABILITY
condition|)
name|physical_layer
operator||=
name|IXGBE_PHYSICAL_LAYER_100BASE_TX
expr_stmt|;
return|return
name|physical_layer
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_init_eeprom_params_X540 - Initialize EEPROM params  *  @hw: pointer to hardware structure  *  *  Initializes the EEPROM parameters ixgbe_eeprom_info within the  *  ixgbe_hw struct in order to set up EEPROM access.  **/
end_comment

begin_function
name|s32
name|ixgbe_init_eeprom_params_X540
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|ixgbe_eeprom_info
modifier|*
name|eeprom
init|=
operator|&
name|hw
operator|->
name|eeprom
decl_stmt|;
name|u32
name|eec
decl_stmt|;
name|u16
name|eeprom_size
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_init_eeprom_params_X540"
argument_list|)
expr_stmt|;
if|if
condition|(
name|eeprom
operator|->
name|type
operator|==
name|ixgbe_eeprom_uninitialized
condition|)
block|{
name|eeprom
operator|->
name|semaphore_delay
operator|=
literal|10
expr_stmt|;
name|eeprom
operator|->
name|type
operator|=
name|ixgbe_flash
expr_stmt|;
name|eec
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC
argument_list|)
expr_stmt|;
name|eeprom_size
operator|=
call|(
name|u16
call|)
argument_list|(
operator|(
name|eec
operator|&
name|IXGBE_EEC_SIZE
operator|)
operator|>>
name|IXGBE_EEC_SIZE_SHIFT
argument_list|)
expr_stmt|;
name|eeprom
operator|->
name|word_size
operator|=
literal|1
operator|<<
operator|(
name|eeprom_size
operator|+
name|IXGBE_EEPROM_WORD_SIZE_SHIFT
operator|)
expr_stmt|;
name|DEBUGOUT2
argument_list|(
literal|"Eeprom params: type = %d, size = %d\n"
argument_list|,
name|eeprom
operator|->
name|type
argument_list|,
name|eeprom
operator|->
name|word_size
argument_list|)
expr_stmt|;
block|}
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_read_eerd_X540- Read EEPROM word using EERD  *  @hw: pointer to hardware structure  *  @offset: offset of  word in the EEPROM to read  *  @data: word read from the EEPROM  *  *  Reads a 16 bit word from the EEPROM using the EERD register.  **/
end_comment

begin_function
name|s32
name|ixgbe_read_eerd_X540
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_read_eerd_X540"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|acquire_swfw_sync
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR_EEP_SM
argument_list|)
operator|==
name|IXGBE_SUCCESS
condition|)
name|status
operator|=
name|ixgbe_read_eerd_generic
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
else|else
name|status
operator|=
name|IXGBE_ERR_SWFW_SYNC
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR_EEP_SM
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_read_eerd_buffer_X540- Read EEPROM word(s) using EERD  *  @hw: pointer to hardware structure  *  @offset: offset of  word in the EEPROM to read  *  @words: number of words  *  @data: word(s) read from the EEPROM  *  *  Reads a 16 bit word(s) from the EEPROM using the EERD register.  **/
end_comment

begin_function
name|s32
name|ixgbe_read_eerd_buffer_X540
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
name|words
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_read_eerd_buffer_X540"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|acquire_swfw_sync
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR_EEP_SM
argument_list|)
operator|==
name|IXGBE_SUCCESS
condition|)
name|status
operator|=
name|ixgbe_read_eerd_buffer_generic
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|words
argument_list|,
name|data
argument_list|)
expr_stmt|;
else|else
name|status
operator|=
name|IXGBE_ERR_SWFW_SYNC
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR_EEP_SM
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_write_eewr_X540 - Write EEPROM word using EEWR  *  @hw: pointer to hardware structure  *  @offset: offset of  word in the EEPROM to write  *  @data: word write to the EEPROM  *  *  Write a 16 bit word to the EEPROM using the EEWR register.  **/
end_comment

begin_function
name|s32
name|ixgbe_write_eewr_X540
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
name|data
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_write_eewr_X540"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|acquire_swfw_sync
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR_EEP_SM
argument_list|)
operator|==
name|IXGBE_SUCCESS
condition|)
name|status
operator|=
name|ixgbe_write_eewr_generic
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
else|else
name|status
operator|=
name|IXGBE_ERR_SWFW_SYNC
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR_EEP_SM
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_write_eewr_buffer_X540 - Write EEPROM word(s) using EEWR  *  @hw: pointer to hardware structure  *  @offset: offset of  word in the EEPROM to write  *  @words: number of words  *  @data: word(s) write to the EEPROM  *  *  Write a 16 bit word(s) to the EEPROM using the EEWR register.  **/
end_comment

begin_function
name|s32
name|ixgbe_write_eewr_buffer_X540
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
name|words
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_write_eewr_buffer_X540"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|acquire_swfw_sync
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR_EEP_SM
argument_list|)
operator|==
name|IXGBE_SUCCESS
condition|)
name|status
operator|=
name|ixgbe_write_eewr_buffer_generic
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|words
argument_list|,
name|data
argument_list|)
expr_stmt|;
else|else
name|status
operator|=
name|IXGBE_ERR_SWFW_SYNC
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR_EEP_SM
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_calc_eeprom_checksum_X540 - Calculates and returns the checksum  *  *  This function does not use synchronization for EERD and EEWR. It can  *  be used internally by function which utilize ixgbe_acquire_swfw_sync_X540.  *  *  @hw: pointer to hardware structure  **/
end_comment

begin_function
name|u16
name|ixgbe_calc_eeprom_checksum_X540
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u16
name|i
decl_stmt|;
name|u16
name|j
decl_stmt|;
name|u16
name|checksum
init|=
literal|0
decl_stmt|;
name|u16
name|length
init|=
literal|0
decl_stmt|;
name|u16
name|pointer
init|=
literal|0
decl_stmt|;
name|u16
name|word
init|=
literal|0
decl_stmt|;
comment|/* 	 * Do not use hw->eeprom.ops.read because we do not want to take 	 * the synchronization semaphores here. Instead use 	 * ixgbe_read_eerd_generic 	 */
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_calc_eeprom_checksum_X540"
argument_list|)
expr_stmt|;
comment|/* Include 0x0-0x3F in the checksum */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_EEPROM_CHECKSUM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ixgbe_read_eerd_generic
argument_list|(
name|hw
argument_list|,
name|i
argument_list|,
operator|&
name|word
argument_list|)
operator|!=
name|IXGBE_SUCCESS
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM read failed\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|checksum
operator|+=
name|word
expr_stmt|;
block|}
comment|/* 	 * Include all data from pointers 0x3, 0x6-0xE.  This excludes the 	 * FW, PHY module, and PCIe Expansion/Option ROM pointers. 	 */
for|for
control|(
name|i
operator|=
name|IXGBE_PCIE_ANALOG_PTR
init|;
name|i
operator|<
name|IXGBE_FW_PTR
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|IXGBE_PHY_PTR
operator|||
name|i
operator|==
name|IXGBE_OPTION_ROM_PTR
condition|)
continue|continue;
if|if
condition|(
name|ixgbe_read_eerd_generic
argument_list|(
name|hw
argument_list|,
name|i
argument_list|,
operator|&
name|pointer
argument_list|)
operator|!=
name|IXGBE_SUCCESS
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM read failed\n"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Skip pointer section if the pointer is invalid. */
if|if
condition|(
name|pointer
operator|==
literal|0xFFFF
operator|||
name|pointer
operator|==
literal|0
operator|||
name|pointer
operator|>=
name|hw
operator|->
name|eeprom
operator|.
name|word_size
condition|)
continue|continue;
if|if
condition|(
name|ixgbe_read_eerd_generic
argument_list|(
name|hw
argument_list|,
name|pointer
argument_list|,
operator|&
name|length
argument_list|)
operator|!=
name|IXGBE_SUCCESS
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM read failed\n"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Skip pointer section if length is invalid. */
if|if
condition|(
name|length
operator|==
literal|0xFFFF
operator|||
name|length
operator|==
literal|0
operator|||
operator|(
name|pointer
operator|+
name|length
operator|)
operator|>=
name|hw
operator|->
name|eeprom
operator|.
name|word_size
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
name|pointer
operator|+
literal|1
init|;
name|j
operator|<=
name|pointer
operator|+
name|length
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|ixgbe_read_eerd_generic
argument_list|(
name|hw
argument_list|,
name|j
argument_list|,
operator|&
name|word
argument_list|)
operator|!=
name|IXGBE_SUCCESS
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM read failed\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|checksum
operator|+=
name|word
expr_stmt|;
block|}
block|}
name|checksum
operator|=
operator|(
name|u16
operator|)
name|IXGBE_EEPROM_SUM
operator|-
name|checksum
expr_stmt|;
return|return
name|checksum
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_validate_eeprom_checksum_X540 - Validate EEPROM checksum  *  @hw: pointer to hardware structure  *  @checksum_val: calculated checksum  *  *  Performs checksum calculation and validates the EEPROM checksum.  If the  *  caller does not need checksum_val, the value can be NULL.  **/
end_comment

begin_function
name|s32
name|ixgbe_validate_eeprom_checksum_X540
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|checksum_val
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|u16
name|checksum
decl_stmt|;
name|u16
name|read_checksum
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_validate_eeprom_checksum_X540"
argument_list|)
expr_stmt|;
comment|/* 	 * Read the first word from the EEPROM. If this times out or fails, do 	 * not continue or we could be in for a very long wait while every 	 * EEPROM read fails 	 */
name|status
operator|=
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
literal|0
argument_list|,
operator|&
name|checksum
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM read failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|acquire_swfw_sync
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR_EEP_SM
argument_list|)
operator|==
name|IXGBE_SUCCESS
condition|)
block|{
name|checksum
operator|=
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|calc_checksum
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* 		 * Do not use hw->eeprom.ops.read because we do not want to take 		 * the synchronization semaphores twice here. 		*/
name|ixgbe_read_eerd_generic
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEPROM_CHECKSUM
argument_list|,
operator|&
name|read_checksum
argument_list|)
expr_stmt|;
comment|/* 		 * Verify read checksum from EEPROM is the same as 		 * calculated checksum 		 */
if|if
condition|(
name|read_checksum
operator|!=
name|checksum
condition|)
name|status
operator|=
name|IXGBE_ERR_EEPROM_CHECKSUM
expr_stmt|;
comment|/* If the user cares, return the calculated checksum */
if|if
condition|(
name|checksum_val
condition|)
operator|*
name|checksum_val
operator|=
name|checksum
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|IXGBE_ERR_SWFW_SYNC
expr_stmt|;
block|}
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR_EEP_SM
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_update_eeprom_checksum_X540 - Updates the EEPROM checksum and flash  * @hw: pointer to hardware structure  *  * After writing EEPROM to shadow RAM using EEWR register, software calculates  * checksum and updates the EEPROM and instructs the hardware to update  * the flash.  **/
end_comment

begin_function
name|s32
name|ixgbe_update_eeprom_checksum_X540
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|u16
name|checksum
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_update_eeprom_checksum_X540"
argument_list|)
expr_stmt|;
comment|/* 	 * Read the first word from the EEPROM. If this times out or fails, do 	 * not continue or we could be in for a very long wait while every 	 * EEPROM read fails 	 */
name|status
operator|=
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
literal|0
argument_list|,
operator|&
name|checksum
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
name|DEBUGOUT
argument_list|(
literal|"EEPROM read failed\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|acquire_swfw_sync
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR_EEP_SM
argument_list|)
operator|==
name|IXGBE_SUCCESS
condition|)
block|{
name|checksum
operator|=
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|calc_checksum
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* 		 * Do not use hw->eeprom.ops.write because we do not want to 		 * take the synchronization semaphores twice here. 		*/
name|status
operator|=
name|ixgbe_write_eewr_generic
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEPROM_CHECKSUM
argument_list|,
name|checksum
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
condition|)
name|status
operator|=
name|ixgbe_update_flash_X540
argument_list|(
name|hw
argument_list|)
expr_stmt|;
else|else
name|status
operator|=
name|IXGBE_ERR_SWFW_SYNC
expr_stmt|;
block|}
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR_EEP_SM
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_update_flash_X540 - Instruct HW to copy EEPROM to Flash device  *  @hw: pointer to hardware structure  *  *  Set FLUP (bit 23) of the EEC register to instruct Hardware to copy  *  EEPROM from shadow RAM to the flash device.  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_update_flash_X540
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|flup
decl_stmt|;
name|s32
name|status
init|=
name|IXGBE_ERR_EEPROM
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_update_flash_X540"
argument_list|)
expr_stmt|;
name|status
operator|=
name|ixgbe_poll_flash_update_done_X540
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|IXGBE_ERR_EEPROM
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Flash update time out\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|flup
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC
argument_list|)
operator||
name|IXGBE_EEC_FLUP
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC
argument_list|,
name|flup
argument_list|)
expr_stmt|;
name|status
operator|=
name|ixgbe_poll_flash_update_done_X540
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
condition|)
name|DEBUGOUT
argument_list|(
literal|"Flash update complete\n"
argument_list|)
expr_stmt|;
else|else
name|DEBUGOUT
argument_list|(
literal|"Flash update time out\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|revision_id
operator|==
literal|0
condition|)
block|{
name|flup
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC
argument_list|)
expr_stmt|;
if|if
condition|(
name|flup
operator|&
name|IXGBE_EEC_SEC1VAL
condition|)
block|{
name|flup
operator||=
name|IXGBE_EEC_FLUP
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC
argument_list|,
name|flup
argument_list|)
expr_stmt|;
block|}
name|status
operator|=
name|ixgbe_poll_flash_update_done_X540
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
condition|)
name|DEBUGOUT
argument_list|(
literal|"Flash update complete\n"
argument_list|)
expr_stmt|;
else|else
name|DEBUGOUT
argument_list|(
literal|"Flash update time out\n"
argument_list|)
expr_stmt|;
block|}
name|out
label|:
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_poll_flash_update_done_X540 - Poll flash update status  *  @hw: pointer to hardware structure  *  *  Polls the FLUDONE (bit 26) of the EEC Register to determine when the  *  flash update is done.  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_poll_flash_update_done_X540
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|i
decl_stmt|;
name|u32
name|reg
decl_stmt|;
name|s32
name|status
init|=
name|IXGBE_ERR_EEPROM
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_poll_flash_update_done_X540"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_FLUDONE_ATTEMPTS
condition|;
name|i
operator|++
control|)
block|{
name|reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|IXGBE_EEC_FLUDONE
condition|)
block|{
name|status
operator|=
name|IXGBE_SUCCESS
expr_stmt|;
break|break;
block|}
name|usec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_acquire_swfw_sync_X540 - Acquire SWFW semaphore  *  @hw: pointer to hardware structure  *  @mask: Mask to specify which semaphore to acquire  *  *  Acquires the SWFW semaphore thought the SW_FW_SYNC register for  *  the specified function (CSR, PHY0, PHY1, NVM, Flash)  **/
end_comment

begin_function
name|s32
name|ixgbe_acquire_swfw_sync_X540
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|mask
parameter_list|)
block|{
name|u32
name|swfw_sync
decl_stmt|;
name|u32
name|swmask
init|=
name|mask
decl_stmt|;
name|u32
name|fwmask
init|=
name|mask
operator|<<
literal|5
decl_stmt|;
name|u32
name|hwmask
init|=
literal|0
decl_stmt|;
name|u32
name|timeout
init|=
literal|200
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|s32
name|ret_val
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_acquire_swfw_sync_X540"
argument_list|)
expr_stmt|;
if|if
condition|(
name|swmask
operator|==
name|IXGBE_GSSR_EEP_SM
condition|)
name|hwmask
operator|=
name|IXGBE_GSSR_FLASH_SM
expr_stmt|;
comment|/* SW only mask doesn't have FW bit pair */
if|if
condition|(
name|swmask
operator|==
name|IXGBE_GSSR_SW_MNG_SM
condition|)
name|fwmask
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|timeout
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * SW NVM semaphore bit is used for access to all 		 * SW_FW_SYNC bits (not just NVM) 		 */
if|if
condition|(
name|ixgbe_get_swfw_sync_semaphore
argument_list|(
name|hw
argument_list|)
condition|)
block|{
name|ret_val
operator|=
name|IXGBE_ERR_SWFW_SYNC
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|swfw_sync
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SWFW_SYNC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|swfw_sync
operator|&
operator|(
name|fwmask
operator||
name|swmask
operator||
name|hwmask
operator|)
operator|)
condition|)
block|{
name|swfw_sync
operator||=
name|swmask
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SWFW_SYNC
argument_list|,
name|swfw_sync
argument_list|)
expr_stmt|;
name|ixgbe_release_swfw_sync_semaphore
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
else|else
block|{
comment|/* 			 * Firmware currently using resource (fwmask), hardware 			 * currently using resource (hwmask), or other software 			 * thread currently using resource (swmask) 			 */
name|ixgbe_release_swfw_sync_semaphore
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Failed to get SW only semaphore */
if|if
condition|(
name|swmask
operator|==
name|IXGBE_GSSR_SW_MNG_SM
condition|)
block|{
name|ret_val
operator|=
name|IXGBE_ERR_SWFW_SYNC
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* If the resource is not released by the FW/HW the SW can assume that 	 * the FW/HW malfunctions. In that case the SW should sets the SW bit(s) 	 * of the requested resource(s) while ignoring the corresponding FW/HW 	 * bits in the SW_FW_SYNC register. 	 */
name|swfw_sync
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SWFW_SYNC
argument_list|)
expr_stmt|;
if|if
condition|(
name|swfw_sync
operator|&
operator|(
name|fwmask
operator||
name|hwmask
operator|)
condition|)
block|{
if|if
condition|(
name|ixgbe_get_swfw_sync_semaphore
argument_list|(
name|hw
argument_list|)
condition|)
block|{
name|ret_val
operator|=
name|IXGBE_ERR_SWFW_SYNC
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|swfw_sync
operator||=
name|swmask
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SWFW_SYNC
argument_list|,
name|swfw_sync
argument_list|)
expr_stmt|;
name|ixgbe_release_swfw_sync_semaphore
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_release_swfw_sync_X540 - Release SWFW semaphore  *  @hw: pointer to hardware structure  *  @mask: Mask to specify which semaphore to release  *  *  Releases the SWFW semaphore throught the SW_FW_SYNC register  *  for the specified function (CSR, PHY0, PHY1, EVM, Flash)  **/
end_comment

begin_function
name|void
name|ixgbe_release_swfw_sync_X540
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|mask
parameter_list|)
block|{
name|u32
name|swfw_sync
decl_stmt|;
name|u32
name|swmask
init|=
name|mask
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_release_swfw_sync_X540"
argument_list|)
expr_stmt|;
name|ixgbe_get_swfw_sync_semaphore
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|swfw_sync
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SWFW_SYNC
argument_list|)
expr_stmt|;
name|swfw_sync
operator|&=
operator|~
name|swmask
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SWFW_SYNC
argument_list|,
name|swfw_sync
argument_list|)
expr_stmt|;
name|ixgbe_release_swfw_sync_semaphore
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_nvm_semaphore - Get hardware semaphore  *  @hw: pointer to hardware structure  *  *  Sets the hardware semaphores so SW/FW can gain control of shared resources  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_get_swfw_sync_semaphore
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_ERR_EEPROM
decl_stmt|;
name|u32
name|timeout
init|=
literal|2000
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|u32
name|swsm
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_swfw_sync_semaphore"
argument_list|)
expr_stmt|;
comment|/* Get SMBI software semaphore between device drivers first */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|timeout
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * If the SMBI bit is 0 when we read it, then the bit will be 		 * set and we have the semaphore 		 */
name|swsm
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SWSM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|swsm
operator|&
name|IXGBE_SWSM_SMBI
operator|)
condition|)
block|{
name|status
operator|=
name|IXGBE_SUCCESS
expr_stmt|;
break|break;
block|}
name|usec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
comment|/* Now get the semaphore between SW/FW through the REGSMP bit */
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|timeout
condition|;
name|i
operator|++
control|)
block|{
name|swsm
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SWFW_SYNC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|swsm
operator|&
name|IXGBE_SWFW_REGSMP
operator|)
condition|)
break|break;
name|usec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Release semaphores and return error if SW NVM semaphore 		 * was not granted because we don't have access to the EEPROM 		 */
if|if
condition|(
name|i
operator|>=
name|timeout
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"REGSMP Software NVM semaphore not "
literal|"granted.\n"
argument_list|)
expr_stmt|;
name|ixgbe_release_swfw_sync_semaphore
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|status
operator|=
name|IXGBE_ERR_EEPROM
expr_stmt|;
block|}
block|}
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"Software semaphore SMBI between device drivers "
literal|"not granted.\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_release_nvm_semaphore - Release hardware semaphore  *  @hw: pointer to hardware structure  *  *  This function clears hardware semaphore bits.  **/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_release_swfw_sync_semaphore
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|swsm
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_release_swfw_sync_semaphore"
argument_list|)
expr_stmt|;
comment|/* Release both semaphores by writing 0 to the bits REGSMP and SMBI */
name|swsm
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SWSM
argument_list|)
expr_stmt|;
name|swsm
operator|&=
operator|~
name|IXGBE_SWSM_SMBI
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SWSM
argument_list|,
name|swsm
argument_list|)
expr_stmt|;
name|swsm
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SWFW_SYNC
argument_list|)
expr_stmt|;
name|swsm
operator|&=
operator|~
name|IXGBE_SWFW_REGSMP
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SWFW_SYNC
argument_list|,
name|swsm
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_blink_led_start_X540 - Blink LED based on index.  * @hw: pointer to hardware structure  * @index: led number to blink  *  * Devices that implement the version 2 interface:  *   X540  **/
end_comment

begin_function
name|s32
name|ixgbe_blink_led_start_X540
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|index
parameter_list|)
block|{
name|u32
name|macc_reg
decl_stmt|;
name|u32
name|ledctl_reg
decl_stmt|;
name|ixgbe_link_speed
name|speed
decl_stmt|;
name|bool
name|link_up
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_blink_led_start_X540"
argument_list|)
expr_stmt|;
comment|/* 	 * Link should be up in order for the blink bit in the LED control 	 * register to work. Force link and speed in the MAC if link is down. 	 * This will be reversed when we stop the blinking. 	 */
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|check_link
argument_list|(
name|hw
argument_list|,
operator|&
name|speed
argument_list|,
operator|&
name|link_up
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_up
operator|==
name|FALSE
condition|)
block|{
name|macc_reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MACC
argument_list|)
expr_stmt|;
name|macc_reg
operator||=
name|IXGBE_MACC_FLU
operator||
name|IXGBE_MACC_FSV_10G
operator||
name|IXGBE_MACC_FS
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MACC
argument_list|,
name|macc_reg
argument_list|)
expr_stmt|;
block|}
comment|/* Set the LED to LINK_UP + BLINK. */
name|ledctl_reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LEDCTL
argument_list|)
expr_stmt|;
name|ledctl_reg
operator|&=
operator|~
name|IXGBE_LED_MODE_MASK
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|ledctl_reg
operator||=
name|IXGBE_LED_BLINK
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LEDCTL
argument_list|,
name|ledctl_reg
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_blink_led_stop_X540 - Stop blinking LED based on index.  * @hw: pointer to hardware structure  * @index: led number to stop blinking  *  * Devices that implement the version 2 interface:  *   X540  **/
end_comment

begin_function
name|s32
name|ixgbe_blink_led_stop_X540
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|index
parameter_list|)
block|{
name|u32
name|macc_reg
decl_stmt|;
name|u32
name|ledctl_reg
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_blink_led_stop_X540"
argument_list|)
expr_stmt|;
comment|/* Restore the LED to its default value. */
name|ledctl_reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LEDCTL
argument_list|)
expr_stmt|;
name|ledctl_reg
operator|&=
operator|~
name|IXGBE_LED_MODE_MASK
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|ledctl_reg
operator||=
name|IXGBE_LED_LINK_ACTIVE
operator|<<
name|IXGBE_LED_MODE_SHIFT
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|ledctl_reg
operator|&=
operator|~
name|IXGBE_LED_BLINK
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LEDCTL
argument_list|,
name|ledctl_reg
argument_list|)
expr_stmt|;
comment|/* Unforce link and speed in the MAC. */
name|macc_reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MACC
argument_list|)
expr_stmt|;
name|macc_reg
operator|&=
operator|~
operator|(
name|IXGBE_MACC_FLU
operator||
name|IXGBE_MACC_FSV_10G
operator||
name|IXGBE_MACC_FS
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MACC
argument_list|,
name|macc_reg
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

end_unit

