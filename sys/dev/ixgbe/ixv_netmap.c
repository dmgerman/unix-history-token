begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************    Copyright (c) 2001-2017, Intel Corporation   All rights reserved.    Redistribution and use in source and binary forms, with or without   modification, are permitted provided that the following conditions are met:     1. Redistributions of source code must retain the above copyright notice,       this list of conditions and the following disclaimer.     2. Redistributions in binary form must reproduce the above copyright       notice, this list of conditions and the following disclaimer in the       documentation and/or other materials provided with the distribution.     3. Neither the name of the Intel Corporation nor the names of its       contributors may be used to endorse or promote products derived from       this software without specific prior written permission.    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  ******************************************************************************/
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_comment
comment|/*  * Copyright (C) 2011-2014 Matteo Landi, Luigi Rizzo. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * $FreeBSD$  *  * netmap support for: ixgbe  *  * This file is meant to be a reference on how to implement  * netmap support for a network driver.  * This file contains code but only static or inline functions used  * by a single driver. To avoid replication of code we just #include  * it near the beginning of the standard driver.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEV_NETMAP
end_ifdef

begin_comment
comment|/*  * Some drivers may need the following headers. Others  * already include them by default  #include<vm/vm.h> #include<vm/pmap.h>   */
end_comment

begin_include
include|#
directive|include
file|"ixv.h"
end_include

begin_comment
comment|/*  * device-specific sysctl variables:  *  * ixv_crcstrip: 0: keep CRC in rx frames (default), 1: strip it.  *	During regular operations the CRC is stripped, but on some  *	hardware reception of frames not multiple of 64 is slower,  *	so using crcstrip=0 helps in benchmarks.  *  * ixv_rx_miss, ixv_rx_miss_bufs:  *	count packets that might be missed due to lost interrupts.  */
end_comment

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_dev_netmap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ixv_rx_miss
decl_stmt|,
name|ixv_rx_miss_bufs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ixv_crcstrip
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|ixv_crcstrip
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ixv_crcstrip
argument_list|,
literal|0
argument_list|,
literal|"strip CRC on rx frames"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|ixv_rx_miss
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ixv_rx_miss
argument_list|,
literal|0
argument_list|,
literal|"potentially missed rx intr"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|ixv_rx_miss_bufs
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ixv_rx_miss_bufs
argument_list|,
literal|0
argument_list|,
literal|"potentially missed rx intr bufs"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|set_crcstrip
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|int
name|onoff
parameter_list|)
block|{
comment|/* crc stripping is set in two places: 	 * IXGBE_HLREG0 (modified on init_locked and hw reset) 	 * IXGBE_RDRXCTL (set by the original driver in 	 *	ixgbe_setup_hw_rsc() called in init_locked. 	 *	We disable the setting when netmap is compiled in). 	 * We update the values here, but also in ixgbe.c because 	 * init_locked sometimes is called outside our control. 	 */
name|uint32_t
name|hl
decl_stmt|,
name|rxc
decl_stmt|;
name|hl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_HLREG0
argument_list|)
expr_stmt|;
name|rxc
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RDRXCTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|netmap_verbose
condition|)
name|D
argument_list|(
literal|"%s read  HLREG 0x%x rxc 0x%x"
argument_list|,
name|onoff
condition|?
literal|"enter"
else|:
literal|"exit"
argument_list|,
name|hl
argument_list|,
name|rxc
argument_list|)
expr_stmt|;
comment|/* hw requirements ... */
name|rxc
operator|&=
operator|~
name|IXGBE_RDRXCTL_RSCFRSTSIZE
expr_stmt|;
name|rxc
operator||=
name|IXGBE_RDRXCTL_RSCACKC
expr_stmt|;
if|if
condition|(
name|onoff
operator|&&
operator|!
name|ixv_crcstrip
condition|)
block|{
comment|/* keep the crc. Fast rx */
name|hl
operator|&=
operator|~
name|IXGBE_HLREG0_RXCRCSTRP
expr_stmt|;
name|rxc
operator|&=
operator|~
name|IXGBE_RDRXCTL_CRCSTRIP
expr_stmt|;
block|}
else|else
block|{
comment|/* reset default mode */
name|hl
operator||=
name|IXGBE_HLREG0_RXCRCSTRP
expr_stmt|;
name|rxc
operator||=
name|IXGBE_RDRXCTL_CRCSTRIP
expr_stmt|;
block|}
if|if
condition|(
name|netmap_verbose
condition|)
name|D
argument_list|(
literal|"%s write HLREG 0x%x rxc 0x%x"
argument_list|,
name|onoff
condition|?
literal|"enter"
else|:
literal|"exit"
argument_list|,
name|hl
argument_list|,
name|rxc
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_HLREG0
argument_list|,
name|hl
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RDRXCTL
argument_list|,
name|rxc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Register/unregister. We are already under netmap lock.  * Only called on the first register or the last unregister.  */
end_comment

begin_function
specifier|static
name|int
name|ixv_netmap_reg
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|int
name|onoff
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|na
operator|->
name|ifp
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|IXGBE_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stop_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|set_crcstrip
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|onoff
argument_list|)
expr_stmt|;
comment|/* enable or disable flags and callbacks in na and ifp */
if|if
condition|(
name|onoff
condition|)
block|{
name|nm_set_native_flags
argument_list|(
name|na
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nm_clear_native_flags
argument_list|(
name|na
argument_list|)
expr_stmt|;
block|}
name|adapter
operator|->
name|init_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* also enables intr */
name|set_crcstrip
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|onoff
argument_list|)
expr_stmt|;
comment|// XXX why twice ?
name|IXGBE_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|?
literal|0
else|:
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reconcile kernel and user view of the transmit ring.  *  * All information is in the kring.  * Userspace wants to send packets up to the one before kring->rhead,  * kernel knows kring->nr_hwcur is the first unsent packet.  *  * Here we push packets out (as many as possible), and possibly  * reclaim buffers from previously completed transmission.  *  * The caller (netmap) guarantees that there is only one instance  * running at any time. Any interference with other driver  * methods should be handled by the individual drivers.  */
end_comment

begin_function
specifier|static
name|int
name|ixv_netmap_txsync
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|kring
operator|->
name|na
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|na
operator|->
name|ifp
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|u_int
name|nm_i
decl_stmt|;
comment|/* index into the netmap ring */
name|u_int
name|nic_i
decl_stmt|;
comment|/* index into the NIC ring */
name|u_int
name|n
decl_stmt|;
name|u_int
specifier|const
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|u_int
specifier|const
name|head
init|=
name|kring
operator|->
name|rhead
decl_stmt|;
comment|/* 	 * interrupts on every tx packet are expensive so request 	 * them every half ring, or where NS_REPORT is set 	 */
name|u_int
name|report_frequency
init|=
name|kring
operator|->
name|nkr_num_slots
operator|>>
literal|1
decl_stmt|;
comment|/* device-specific */
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|adapter
operator|->
name|tx_rings
index|[
name|kring
operator|->
name|ring_id
index|]
decl_stmt|;
name|int
name|reclaim_tx
decl_stmt|;
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|txdma
operator|.
name|dma_tag
argument_list|,
name|txr
operator|->
name|txdma
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
comment|/* 	 * First part: process new packets to send. 	 * nm_i is the current index in the netmap ring, 	 * nic_i is the corresponding index in the NIC ring. 	 * The two numbers differ because upon a *_init() we reset 	 * the NIC ring but leave the netmap ring unchanged. 	 * For the transmit ring, we have 	 * 	 *		nm_i = kring->nr_hwcur 	 *		nic_i = IXGBE_TDT (not tracked in the driver) 	 * and 	 * 		nm_i == (nic_i + kring->nkr_hwofs) % ring_size 	 * 	 * In this driver kring->nkr_hwofs>= 0, but for other 	 * drivers it might be negative as well. 	 */
comment|/* 	 * If we have packets to send (kring->nr_hwcur != kring->rhead) 	 * iterate over the netmap ring, fetch length and update 	 * the corresponding slot in the NIC ring. Some drivers also 	 * need to update the buffer's physical address in the NIC slot 	 * even NS_BUF_CHANGED is not set (PNMB computes the addresses). 	 * 	 * The netmap_reload_map() calls is especially expensive, 	 * even when (as in this case) the tag is 0, so do only 	 * when the buffer has actually changed. 	 * 	 * If possible do not set the report/intr bit on all slots, 	 * but only a few times per ring or when NS_REPORT is set. 	 * 	 * Finally, on 10G and faster drivers, it might be useful 	 * to prefetch the next slot and txr entry. 	 */
name|nm_i
operator|=
name|kring
operator|->
name|nr_hwcur
expr_stmt|;
if|if
condition|(
name|nm_i
operator|!=
name|head
condition|)
block|{
comment|/* we have new packets to send */
name|nic_i
operator|=
name|netmap_idx_k2n
argument_list|(
name|kring
argument_list|,
name|nm_i
argument_list|)
expr_stmt|;
name|__builtin_prefetch
argument_list|(
operator|&
name|ring
operator|->
name|slot
index|[
name|nm_i
index|]
argument_list|)
expr_stmt|;
name|__builtin_prefetch
argument_list|(
operator|&
name|txr
operator|->
name|tx_buffers
index|[
name|nic_i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|nm_i
operator|!=
name|head
condition|;
name|n
operator|++
control|)
block|{
name|struct
name|netmap_slot
modifier|*
name|slot
init|=
operator|&
name|ring
operator|->
name|slot
index|[
name|nm_i
index|]
decl_stmt|;
name|u_int
name|len
init|=
name|slot
operator|->
name|len
decl_stmt|;
name|uint64_t
name|paddr
decl_stmt|;
name|void
modifier|*
name|addr
init|=
name|PNMB
argument_list|(
name|na
argument_list|,
name|slot
argument_list|,
operator|&
name|paddr
argument_list|)
decl_stmt|;
comment|/* device-specific */
name|union
name|ixgbe_adv_tx_desc
modifier|*
name|curr
init|=
operator|&
name|txr
operator|->
name|tx_base
index|[
name|nic_i
index|]
decl_stmt|;
name|struct
name|ixgbe_tx_buf
modifier|*
name|txbuf
init|=
operator|&
name|txr
operator|->
name|tx_buffers
index|[
name|nic_i
index|]
decl_stmt|;
name|int
name|flags
init|=
operator|(
name|slot
operator|->
name|flags
operator|&
name|NS_REPORT
operator|||
name|nic_i
operator|==
literal|0
operator|||
name|nic_i
operator|==
name|report_frequency
operator|)
condition|?
name|IXGBE_TXD_CMD_RS
else|:
literal|0
decl_stmt|;
comment|/* prefetch for next round */
name|__builtin_prefetch
argument_list|(
operator|&
name|ring
operator|->
name|slot
index|[
name|nm_i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|__builtin_prefetch
argument_list|(
operator|&
name|txr
operator|->
name|tx_buffers
index|[
name|nic_i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|NM_CHECK_ADDR_LEN
argument_list|(
name|na
argument_list|,
name|addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|flags
operator|&
name|NS_BUF_CHANGED
condition|)
block|{
comment|/* buffer has changed, reload map */
name|netmap_reload_map
argument_list|(
name|na
argument_list|,
name|txr
operator|->
name|txtag
argument_list|,
name|txbuf
operator|->
name|map
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
name|slot
operator|->
name|flags
operator|&=
operator|~
operator|(
name|NS_REPORT
operator||
name|NS_BUF_CHANGED
operator|)
expr_stmt|;
comment|/* Fill the slot in the NIC ring. */
comment|/* Use legacy descriptor, they are faster? */
name|curr
operator|->
name|read
operator|.
name|buffer_addr
operator|=
name|htole64
argument_list|(
name|paddr
argument_list|)
expr_stmt|;
name|curr
operator|->
name|read
operator|.
name|olinfo_status
operator|=
literal|0
expr_stmt|;
name|curr
operator|->
name|read
operator|.
name|cmd_type_len
operator|=
name|htole32
argument_list|(
name|len
operator||
name|flags
operator||
name|IXGBE_ADVTXD_DCMD_IFCS
operator||
name|IXGBE_TXD_CMD_EOP
argument_list|)
expr_stmt|;
comment|/* make sure changes to the buffer are synced */
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|txbuf
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|nm_i
operator|=
name|nm_next
argument_list|(
name|nm_i
argument_list|,
name|lim
argument_list|)
expr_stmt|;
name|nic_i
operator|=
name|nm_next
argument_list|(
name|nic_i
argument_list|,
name|lim
argument_list|)
expr_stmt|;
block|}
name|kring
operator|->
name|nr_hwcur
operator|=
name|head
expr_stmt|;
comment|/* synchronize the NIC ring */
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|txdma
operator|.
name|dma_tag
argument_list|,
name|txr
operator|->
name|txdma
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* (re)start the tx unit up to slot nic_i (excluded) */
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|txr
operator|->
name|tail
argument_list|,
name|nic_i
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Second part: reclaim buffers for completed transmissions. 	 * Because this is expensive (we read a NIC register etc.) 	 * we only do it in specific cases (see below). 	 */
if|if
condition|(
name|flags
operator|&
name|NAF_FORCE_RECLAIM
condition|)
block|{
name|reclaim_tx
operator|=
literal|1
expr_stmt|;
comment|/* forced reclaim */
block|}
elseif|else
if|if
condition|(
operator|!
name|nm_kr_txempty
argument_list|(
name|kring
argument_list|)
condition|)
block|{
name|reclaim_tx
operator|=
literal|0
expr_stmt|;
comment|/* have buffers, no reclaim */
block|}
else|else
block|{
comment|/* 		 * No buffers available. Locate previous slot with 		 * REPORT_STATUS set. 		 * If the slot has DD set, we can reclaim space, 		 * otherwise wait for the next interrupt. 		 * This enables interrupt moderation on the tx 		 * side though it might reduce throughput. 		 */
name|struct
name|ixgbe_legacy_tx_desc
modifier|*
name|txd
init|=
operator|(
expr|struct
name|ixgbe_legacy_tx_desc
operator|*
operator|)
name|txr
operator|->
name|tx_base
decl_stmt|;
name|nic_i
operator|=
name|txr
operator|->
name|next_to_clean
operator|+
name|report_frequency
expr_stmt|;
if|if
condition|(
name|nic_i
operator|>
name|lim
condition|)
name|nic_i
operator|-=
name|lim
operator|+
literal|1
expr_stmt|;
comment|// round to the closest with dd set
name|nic_i
operator|=
operator|(
name|nic_i
operator|<
name|kring
operator|->
name|nkr_num_slots
operator|/
literal|4
operator|||
name|nic_i
operator|>=
name|kring
operator|->
name|nkr_num_slots
operator|*
literal|3
operator|/
literal|4
operator|)
condition|?
literal|0
else|:
name|report_frequency
expr_stmt|;
name|reclaim_tx
operator|=
name|txd
index|[
name|nic_i
index|]
operator|.
name|upper
operator|.
name|fields
operator|.
name|status
operator|&
name|IXGBE_TXD_STAT_DD
expr_stmt|;
comment|// XXX cpu_to_le32 ?
block|}
if|if
condition|(
name|reclaim_tx
condition|)
block|{
comment|/* 		 * Record completed transmissions. 		 * We (re)use the driver's txr->next_to_clean to keep 		 * track of the most recently completed transmission. 		 * 		 * The datasheet discourages the use of TDH to find 		 * out the number of sent packets, but we only set 		 * REPORT_STATUS in a few slots so TDH is the only 		 * good way. 		 */
name|nic_i
operator|=
name|IXGBE_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_TDH
argument_list|(
name|kring
operator|->
name|ring_id
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nic_i
operator|>=
name|kring
operator|->
name|nkr_num_slots
condition|)
block|{
comment|/* XXX can it happen ? */
name|D
argument_list|(
literal|"TDH wrap %d"
argument_list|,
name|nic_i
argument_list|)
expr_stmt|;
name|nic_i
operator|-=
name|kring
operator|->
name|nkr_num_slots
expr_stmt|;
block|}
if|if
condition|(
name|nic_i
operator|!=
name|txr
operator|->
name|next_to_clean
condition|)
block|{
comment|/* some tx completed, increment avail */
name|txr
operator|->
name|next_to_clean
operator|=
name|nic_i
expr_stmt|;
name|kring
operator|->
name|nr_hwtail
operator|=
name|nm_prev
argument_list|(
name|netmap_idx_n2k
argument_list|(
name|kring
argument_list|,
name|nic_i
argument_list|)
argument_list|,
name|lim
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Reconcile kernel and user view of the receive ring.  * Same as for the txsync, this routine must be efficient.  * The caller guarantees a single invocations, but races against  * the rest of the driver should be handled here.  *  * On call, kring->rhead is the first packet that userspace wants  * to keep, and kring->rcur is the wakeup point.  * The kernel has previously reported packets up to kring->rtail.  *  * If (flags& NAF_FORCE_READ) also check for incoming packets irrespective  * of whether or not we received an interrupt.  */
end_comment

begin_function
specifier|static
name|int
name|ixv_netmap_rxsync
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|kring
operator|->
name|na
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|na
operator|->
name|ifp
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|u_int
name|nm_i
decl_stmt|;
comment|/* index into the netmap ring */
name|u_int
name|nic_i
decl_stmt|;
comment|/* index into the NIC ring */
name|u_int
name|n
decl_stmt|;
name|u_int
specifier|const
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|u_int
specifier|const
name|head
init|=
name|kring
operator|->
name|rhead
decl_stmt|;
name|int
name|force_update
init|=
operator|(
name|flags
operator|&
name|NAF_FORCE_READ
operator|)
operator|||
name|kring
operator|->
name|nr_kflags
operator|&
name|NKR_PENDINTR
decl_stmt|;
comment|/* device-specific */
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
operator|&
name|adapter
operator|->
name|rx_rings
index|[
name|kring
operator|->
name|ring_id
index|]
decl_stmt|;
if|if
condition|(
name|head
operator|>
name|lim
condition|)
return|return
name|netmap_ring_reinit
argument_list|(
name|kring
argument_list|)
return|;
comment|/* XXX check sync modes */
name|bus_dmamap_sync
argument_list|(
name|rxr
operator|->
name|rxdma
operator|.
name|dma_tag
argument_list|,
name|rxr
operator|->
name|rxdma
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
comment|/* 	 * First part: import newly received packets. 	 * 	 * nm_i is the index of the next free slot in the netmap ring, 	 * nic_i is the index of the next received packet in the NIC ring, 	 * and they may differ in case if_init() has been called while 	 * in netmap mode. For the receive ring we have 	 * 	 *	nic_i = rxr->next_to_check; 	 *	nm_i = kring->nr_hwtail (previous) 	 * and 	 *	nm_i == (nic_i + kring->nkr_hwofs) % ring_size 	 * 	 * rxr->next_to_check is set to 0 on a ring reinit 	 */
if|if
condition|(
name|netmap_no_pendintr
operator|||
name|force_update
condition|)
block|{
name|int
name|crclen
init|=
operator|(
name|ixv_crcstrip
operator|)
condition|?
literal|0
else|:
literal|4
decl_stmt|;
name|uint16_t
name|slot_flags
init|=
name|kring
operator|->
name|nkr_slot_flags
decl_stmt|;
name|nic_i
operator|=
name|rxr
operator|->
name|next_to_check
expr_stmt|;
comment|// or also k2n(kring->nr_hwtail)
name|nm_i
operator|=
name|netmap_idx_n2k
argument_list|(
name|kring
argument_list|,
name|nic_i
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
condition|;
name|n
operator|++
control|)
block|{
name|union
name|ixgbe_adv_rx_desc
modifier|*
name|curr
init|=
operator|&
name|rxr
operator|->
name|rx_base
index|[
name|nic_i
index|]
decl_stmt|;
name|uint32_t
name|staterr
init|=
name|le32toh
argument_list|(
name|curr
operator|->
name|wb
operator|.
name|upper
operator|.
name|status_error
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|staterr
operator|&
name|IXGBE_RXD_STAT_DD
operator|)
operator|==
literal|0
condition|)
break|break;
name|ring
operator|->
name|slot
index|[
name|nm_i
index|]
operator|.
name|len
operator|=
name|le16toh
argument_list|(
name|curr
operator|->
name|wb
operator|.
name|upper
operator|.
name|length
argument_list|)
operator|-
name|crclen
expr_stmt|;
name|ring
operator|->
name|slot
index|[
name|nm_i
index|]
operator|.
name|flags
operator|=
name|slot_flags
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|rxr
operator|->
name|ptag
argument_list|,
name|rxr
operator|->
name|rx_buffers
index|[
name|nic_i
index|]
operator|.
name|pmap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|nm_i
operator|=
name|nm_next
argument_list|(
name|nm_i
argument_list|,
name|lim
argument_list|)
expr_stmt|;
name|nic_i
operator|=
name|nm_next
argument_list|(
name|nic_i
argument_list|,
name|lim
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
condition|)
block|{
comment|/* update the state variables */
if|if
condition|(
name|netmap_no_pendintr
operator|&&
operator|!
name|force_update
condition|)
block|{
comment|/* diagnostics */
name|ixv_rx_miss
operator|++
expr_stmt|;
name|ixv_rx_miss_bufs
operator|+=
name|n
expr_stmt|;
block|}
name|rxr
operator|->
name|next_to_check
operator|=
name|nic_i
expr_stmt|;
name|kring
operator|->
name|nr_hwtail
operator|=
name|nm_i
expr_stmt|;
block|}
name|kring
operator|->
name|nr_kflags
operator|&=
operator|~
name|NKR_PENDINTR
expr_stmt|;
block|}
comment|/* 	 * Second part: skip past packets that userspace has released. 	 * (kring->nr_hwcur to kring->rhead excluded), 	 * and make the buffers available for reception. 	 * As usual nm_i is the index in the netmap ring, 	 * nic_i is the index in the NIC ring, and 	 * nm_i == (nic_i + kring->nkr_hwofs) % ring_size 	 */
name|nm_i
operator|=
name|kring
operator|->
name|nr_hwcur
expr_stmt|;
if|if
condition|(
name|nm_i
operator|!=
name|head
condition|)
block|{
name|nic_i
operator|=
name|netmap_idx_k2n
argument_list|(
name|kring
argument_list|,
name|nm_i
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|nm_i
operator|!=
name|head
condition|;
name|n
operator|++
control|)
block|{
name|struct
name|netmap_slot
modifier|*
name|slot
init|=
operator|&
name|ring
operator|->
name|slot
index|[
name|nm_i
index|]
decl_stmt|;
name|uint64_t
name|paddr
decl_stmt|;
name|void
modifier|*
name|addr
init|=
name|PNMB
argument_list|(
name|na
argument_list|,
name|slot
argument_list|,
operator|&
name|paddr
argument_list|)
decl_stmt|;
name|union
name|ixgbe_adv_rx_desc
modifier|*
name|curr
init|=
operator|&
name|rxr
operator|->
name|rx_base
index|[
name|nic_i
index|]
decl_stmt|;
name|struct
name|ixgbe_rx_buf
modifier|*
name|rxbuf
init|=
operator|&
name|rxr
operator|->
name|rx_buffers
index|[
name|nic_i
index|]
decl_stmt|;
if|if
condition|(
name|addr
operator|==
name|NETMAP_BUF_BASE
argument_list|(
name|na
argument_list|)
condition|)
comment|/* bad buf */
goto|goto
name|ring_reset
goto|;
if|if
condition|(
name|slot
operator|->
name|flags
operator|&
name|NS_BUF_CHANGED
condition|)
block|{
comment|/* buffer has changed, reload map */
name|netmap_reload_map
argument_list|(
name|na
argument_list|,
name|rxr
operator|->
name|ptag
argument_list|,
name|rxbuf
operator|->
name|pmap
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|slot
operator|->
name|flags
operator|&=
operator|~
name|NS_BUF_CHANGED
expr_stmt|;
block|}
name|curr
operator|->
name|wb
operator|.
name|upper
operator|.
name|status_error
operator|=
literal|0
expr_stmt|;
name|curr
operator|->
name|read
operator|.
name|pkt_addr
operator|=
name|htole64
argument_list|(
name|paddr
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|rxr
operator|->
name|ptag
argument_list|,
name|rxbuf
operator|->
name|pmap
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|nm_i
operator|=
name|nm_next
argument_list|(
name|nm_i
argument_list|,
name|lim
argument_list|)
expr_stmt|;
name|nic_i
operator|=
name|nm_next
argument_list|(
name|nic_i
argument_list|,
name|lim
argument_list|)
expr_stmt|;
block|}
name|kring
operator|->
name|nr_hwcur
operator|=
name|head
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|rxr
operator|->
name|rxdma
operator|.
name|dma_tag
argument_list|,
name|rxr
operator|->
name|rxdma
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* 		 * IMPORTANT: we must leave one free slot in the ring, 		 * so move nic_i back by one unit 		 */
name|nic_i
operator|=
name|nm_prev
argument_list|(
name|nic_i
argument_list|,
name|lim
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|rxr
operator|->
name|tail
argument_list|,
name|nic_i
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
name|ring_reset
label|:
return|return
name|netmap_ring_reinit
argument_list|(
name|kring
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * The attach routine, called near the end of ixgbe_attach(),  * fills the parameters for netmap_attach() and calls it.  * It cannot fail, in the worst case (such as no memory)  * netmap mode will be disabled and the driver will only  * operate in standard mode.  */
end_comment

begin_function
name|void
name|ixv_netmap_attach
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|netmap_adapter
name|na
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|na
argument_list|,
sizeof|sizeof
argument_list|(
name|na
argument_list|)
argument_list|)
expr_stmt|;
name|na
operator|.
name|ifp
operator|=
name|adapter
operator|->
name|ifp
expr_stmt|;
name|na
operator|.
name|na_flags
operator|=
name|NAF_BDG_MAYSLEEP
expr_stmt|;
name|na
operator|.
name|num_tx_desc
operator|=
name|adapter
operator|->
name|num_tx_desc
expr_stmt|;
name|na
operator|.
name|num_rx_desc
operator|=
name|adapter
operator|->
name|num_rx_desc
expr_stmt|;
name|na
operator|.
name|nm_txsync
operator|=
name|ixv_netmap_txsync
expr_stmt|;
name|na
operator|.
name|nm_rxsync
operator|=
name|ixv_netmap_rxsync
expr_stmt|;
name|na
operator|.
name|nm_register
operator|=
name|ixv_netmap_reg
expr_stmt|;
name|na
operator|.
name|num_tx_rings
operator|=
name|na
operator|.
name|num_rx_rings
operator|=
name|adapter
operator|->
name|num_queues
expr_stmt|;
name|netmap_attach
argument_list|(
operator|&
name|na
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEV_NETMAP */
end_comment

begin_comment
comment|/* end of file */
end_comment

end_unit

