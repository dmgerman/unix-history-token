begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************    Copyright (c) 2001-2017, Intel Corporation   All rights reserved.    Redistribution and use in source and binary forms, with or without   modification, are permitted provided that the following conditions are met:     1. Redistributions of source code must retain the above copyright notice,       this list of conditions and the following disclaimer.     2. Redistributions in binary form must reproduce the above copyright       notice, this list of conditions and the following disclaimer in the       documentation and/or other materials provided with the distribution.     3. Neither the name of the Intel Corporation nor the names of its       contributors may be used to endorse or promote products derived from       this software without specific prior written permission.    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  ******************************************************************************/
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_include
include|#
directive|include
file|"ixgbe_type.h"
end_include

begin_include
include|#
directive|include
file|"ixgbe_82599.h"
end_include

begin_include
include|#
directive|include
file|"ixgbe_api.h"
end_include

begin_include
include|#
directive|include
file|"ixgbe_common.h"
end_include

begin_include
include|#
directive|include
file|"ixgbe_phy.h"
end_include

begin_define
define|#
directive|define
name|IXGBE_82599_MAX_TX_QUEUES
value|128
end_define

begin_define
define|#
directive|define
name|IXGBE_82599_MAX_RX_QUEUES
value|128
end_define

begin_define
define|#
directive|define
name|IXGBE_82599_RAR_ENTRIES
value|128
end_define

begin_define
define|#
directive|define
name|IXGBE_82599_MC_TBL_SIZE
value|128
end_define

begin_define
define|#
directive|define
name|IXGBE_82599_VFT_TBL_SIZE
value|128
end_define

begin_define
define|#
directive|define
name|IXGBE_82599_RX_PB_SIZE
value|512
end_define

begin_function_decl
specifier|static
name|s32
name|ixgbe_setup_copper_link_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
name|speed
parameter_list|,
name|bool
name|autoneg_wait_to_complete
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|ixgbe_verify_fw_version_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|ixgbe_read_eeprom_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|ixgbe_read_eeprom_buffer_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
name|words
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|ixgbe_read_i2c_byte_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|byte_offset
parameter_list|,
name|u8
name|dev_addr
parameter_list|,
name|u8
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|ixgbe_write_i2c_byte_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|byte_offset
parameter_list|,
name|u8
name|dev_addr
parameter_list|,
name|u8
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|ixgbe_init_mac_link_ops_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|ixgbe_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_init_mac_link_ops_82599"
argument_list|)
expr_stmt|;
comment|/* 	 * enable the laser control functions for SFP+ fiber 	 * and MNG not enabled 	 */
if|if
condition|(
operator|(
name|mac
operator|->
name|ops
operator|.
name|get_media_type
argument_list|(
name|hw
argument_list|)
operator|==
name|ixgbe_media_type_fiber
operator|)
operator|&&
operator|!
name|ixgbe_mng_enabled
argument_list|(
name|hw
argument_list|)
condition|)
block|{
name|mac
operator|->
name|ops
operator|.
name|disable_tx_laser
operator|=
name|ixgbe_disable_tx_laser_multispeed_fiber
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|enable_tx_laser
operator|=
name|ixgbe_enable_tx_laser_multispeed_fiber
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|flap_tx_laser
operator|=
name|ixgbe_flap_tx_laser_multispeed_fiber
expr_stmt|;
block|}
else|else
block|{
name|mac
operator|->
name|ops
operator|.
name|disable_tx_laser
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|enable_tx_laser
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|flap_tx_laser
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|multispeed_fiber
condition|)
block|{
comment|/* Set up dual speed SFP+ support */
name|mac
operator|->
name|ops
operator|.
name|setup_link
operator|=
name|ixgbe_setup_mac_link_multispeed_fiber
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|setup_mac_link
operator|=
name|ixgbe_setup_mac_link_82599
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|set_rate_select_speed
operator|=
name|ixgbe_set_hard_rate_select_speed
expr_stmt|;
if|if
condition|(
name|ixgbe_get_media_type
argument_list|(
name|hw
argument_list|)
operator|==
name|ixgbe_media_type_fiber_fixed
condition|)
name|mac
operator|->
name|ops
operator|.
name|set_rate_select_speed
operator|=
name|ixgbe_set_soft_rate_select_speed
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ixgbe_get_media_type
argument_list|(
name|hw
argument_list|)
operator|==
name|ixgbe_media_type_backplane
operator|)
operator|&&
operator|(
name|hw
operator|->
name|phy
operator|.
name|smart_speed
operator|==
name|ixgbe_smart_speed_auto
operator|||
name|hw
operator|->
name|phy
operator|.
name|smart_speed
operator|==
name|ixgbe_smart_speed_on
operator|)
operator|&&
operator|!
name|ixgbe_verify_lesm_fw_enabled_82599
argument_list|(
name|hw
argument_list|)
condition|)
block|{
name|mac
operator|->
name|ops
operator|.
name|setup_link
operator|=
name|ixgbe_setup_mac_link_smartspeed
expr_stmt|;
block|}
else|else
block|{
name|mac
operator|->
name|ops
operator|.
name|setup_link
operator|=
name|ixgbe_setup_mac_link_82599
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  *  ixgbe_init_phy_ops_82599 - PHY/SFP specific init  *  @hw: pointer to hardware structure  *  *  Initialize any function pointers that were not able to be  *  set during init_shared_code because the PHY/SFP type was  *  not known.  Perform the SFP init if necessary.  *  **/
end_comment

begin_function
name|s32
name|ixgbe_init_phy_ops_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|ixgbe_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|struct
name|ixgbe_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u32
name|esdp
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_init_phy_ops_82599"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|device_id
operator|==
name|IXGBE_DEV_ID_82599_QSFP_SF_QP
condition|)
block|{
comment|/* Store flag indicating I2C bus access control unit. */
name|hw
operator|->
name|phy
operator|.
name|qsfp_shared_i2c_bus
operator|=
name|TRUE
expr_stmt|;
comment|/* Initialize access to QSFP+ I2C bus */
name|esdp
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|)
expr_stmt|;
name|esdp
operator||=
name|IXGBE_ESDP_SDP0_DIR
expr_stmt|;
name|esdp
operator|&=
operator|~
name|IXGBE_ESDP_SDP1_DIR
expr_stmt|;
name|esdp
operator|&=
operator|~
name|IXGBE_ESDP_SDP0
expr_stmt|;
name|esdp
operator|&=
operator|~
name|IXGBE_ESDP_SDP0_NATIVE
expr_stmt|;
name|esdp
operator|&=
operator|~
name|IXGBE_ESDP_SDP1_NATIVE
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|,
name|esdp
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|read_i2c_byte
operator|=
name|ixgbe_read_i2c_byte_82599
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|write_i2c_byte
operator|=
name|ixgbe_write_i2c_byte_82599
expr_stmt|;
block|}
comment|/* Identify the PHY or SFP module */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|identify
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|==
name|IXGBE_ERR_SFP_NOT_SUPPORTED
condition|)
goto|goto
name|init_phy_ops_out
goto|;
comment|/* Setup function pointers based on detected SFP module and speeds */
name|ixgbe_init_mac_link_ops_82599
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|!=
name|ixgbe_sfp_type_unknown
condition|)
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|reset
operator|=
name|NULL
expr_stmt|;
comment|/* If copper media, overwrite with copper function pointers */
if|if
condition|(
name|mac
operator|->
name|ops
operator|.
name|get_media_type
argument_list|(
name|hw
argument_list|)
operator|==
name|ixgbe_media_type_copper
condition|)
block|{
name|mac
operator|->
name|ops
operator|.
name|setup_link
operator|=
name|ixgbe_setup_copper_link_82599
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_link_capabilities
operator|=
name|ixgbe_get_copper_link_capabilities_generic
expr_stmt|;
block|}
comment|/* Set necessary function pointers based on PHY type */
switch|switch
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
condition|)
block|{
case|case
name|ixgbe_phy_tn
case|:
name|phy
operator|->
name|ops
operator|.
name|setup_link
operator|=
name|ixgbe_setup_phy_link_tnx
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|check_link
operator|=
name|ixgbe_check_phy_link_tnx
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|get_firmware_version
operator|=
name|ixgbe_get_phy_firmware_version_tnx
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|init_phy_ops_out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_function
name|s32
name|ixgbe_setup_sfp_modules_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u16
name|list_offset
decl_stmt|,
name|data_offset
decl_stmt|,
name|data_value
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_setup_sfp_modules_82599"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|!=
name|ixgbe_sfp_type_unknown
condition|)
block|{
name|ixgbe_init_mac_link_ops_82599
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|reset
operator|=
name|NULL
expr_stmt|;
name|ret_val
operator|=
name|ixgbe_get_sfp_init_sequence_offsets
argument_list|(
name|hw
argument_list|,
operator|&
name|list_offset
argument_list|,
operator|&
name|data_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|setup_sfp_out
goto|;
comment|/* PHY config will finish before releasing the semaphore */
name|ret_val
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|acquire_swfw_sync
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR_MAC_CSR_SM
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|IXGBE_SUCCESS
condition|)
block|{
name|ret_val
operator|=
name|IXGBE_ERR_SWFW_SYNC
expr_stmt|;
goto|goto
name|setup_sfp_out
goto|;
block|}
if|if
condition|(
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
operator|++
name|data_offset
argument_list|,
operator|&
name|data_value
argument_list|)
condition|)
goto|goto
name|setup_sfp_err
goto|;
while|while
condition|(
name|data_value
operator|!=
literal|0xffff
condition|)
block|{
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CORECTL
argument_list|,
name|data_value
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
operator|++
name|data_offset
argument_list|,
operator|&
name|data_value
argument_list|)
condition|)
goto|goto
name|setup_sfp_err
goto|;
block|}
comment|/* Release the semaphore */
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR_MAC_CSR_SM
argument_list|)
expr_stmt|;
comment|/* Delay obtaining semaphore again to allow FW access 		 * prot_autoc_write uses the semaphore too. 		 */
name|msec_delay
argument_list|(
name|hw
operator|->
name|eeprom
operator|.
name|semaphore_delay
argument_list|)
expr_stmt|;
comment|/* Restart DSP and set SFI mode */
name|ret_val
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|prot_autoc_write
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|orig_autoc
operator||
name|IXGBE_AUTOC_LMS_10G_SERIAL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"sfp module setup not complete\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|IXGBE_ERR_SFP_SETUP_NOT_COMPLETE
expr_stmt|;
goto|goto
name|setup_sfp_out
goto|;
block|}
block|}
name|setup_sfp_out
label|:
return|return
name|ret_val
return|;
name|setup_sfp_err
label|:
comment|/* Release the semaphore */
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR_MAC_CSR_SM
argument_list|)
expr_stmt|;
comment|/* Delay obtaining semaphore again to allow FW access */
name|msec_delay
argument_list|(
name|hw
operator|->
name|eeprom
operator|.
name|semaphore_delay
argument_list|)
expr_stmt|;
name|ERROR_REPORT2
argument_list|(
name|IXGBE_ERROR_INVALID_STATE
argument_list|,
literal|"eeprom read at offset %d failed"
argument_list|,
name|data_offset
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_PHY
return|;
block|}
end_function

begin_comment
comment|/**  *  prot_autoc_read_82599 - Hides MAC differences needed for AUTOC read  *  @hw: pointer to hardware structure  *  @locked: Return the if we locked for this read.  *  @reg_val: Value we read from AUTOC  *  *  For this part (82599) we need to wrap read-modify-writes with a possible  *  FW/SW lock.  It is assumed this lock will be freed with the next  *  prot_autoc_write_82599().  */
end_comment

begin_function
name|s32
name|prot_autoc_read_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|bool
modifier|*
name|locked
parameter_list|,
name|u32
modifier|*
name|reg_val
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
operator|*
name|locked
operator|=
name|FALSE
expr_stmt|;
comment|/* If LESM is on then we need to hold the SW/FW semaphore. */
if|if
condition|(
name|ixgbe_verify_lesm_fw_enabled_82599
argument_list|(
name|hw
argument_list|)
condition|)
block|{
name|ret_val
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|acquire_swfw_sync
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR_MAC_CSR_SM
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|IXGBE_ERR_SWFW_SYNC
return|;
operator|*
name|locked
operator|=
name|TRUE
expr_stmt|;
block|}
operator|*
name|reg_val
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * prot_autoc_write_82599 - Hides MAC differences needed for AUTOC write  * @hw: pointer to hardware structure  * @reg_val: value to write to AUTOC  * @locked: bool to indicate whether the SW/FW lock was already taken by  *           previous proc_autoc_read_82599.  *  * This part (82599) may need to hold the SW/FW lock around all writes to  * AUTOC. Likewise after a write we need to do a pipeline reset.  */
end_comment

begin_function
name|s32
name|prot_autoc_write_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|autoc
parameter_list|,
name|bool
name|locked
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|IXGBE_SUCCESS
decl_stmt|;
comment|/* Blocked by MNG FW so bail */
if|if
condition|(
name|ixgbe_check_reset_blocked
argument_list|(
name|hw
argument_list|)
condition|)
goto|goto
name|out
goto|;
comment|/* We only need to get the lock if: 	 *  - We didn't do it already (in the read part of a read-modify-write) 	 *  - LESM is enabled. 	 */
if|if
condition|(
operator|!
name|locked
operator|&&
name|ixgbe_verify_lesm_fw_enabled_82599
argument_list|(
name|hw
argument_list|)
condition|)
block|{
name|ret_val
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|acquire_swfw_sync
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR_MAC_CSR_SM
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|IXGBE_ERR_SWFW_SYNC
return|;
name|locked
operator|=
name|TRUE
expr_stmt|;
block|}
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC
argument_list|,
name|autoc
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|ixgbe_reset_pipeline_82599
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
comment|/* Free the SW/FW semaphore as we either grabbed it here or 	 * already had it when this function was called. 	 */
if|if
condition|(
name|locked
condition|)
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR_MAC_CSR_SM
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_init_ops_82599 - Inits func ptrs and MAC type  *  @hw: pointer to hardware structure  *  *  Initialize the function pointers and assign the MAC type for 82599.  *  Does not touch the hardware.  **/
end_comment

begin_function
name|s32
name|ixgbe_init_ops_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|ixgbe_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|struct
name|ixgbe_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|struct
name|ixgbe_eeprom_info
modifier|*
name|eeprom
init|=
operator|&
name|hw
operator|->
name|eeprom
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_init_ops_82599"
argument_list|)
expr_stmt|;
name|ixgbe_init_phy_ops_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|ixgbe_init_ops_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* PHY */
name|phy
operator|->
name|ops
operator|.
name|identify
operator|=
name|ixgbe_identify_phy_82599
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|init
operator|=
name|ixgbe_init_phy_ops_82599
expr_stmt|;
comment|/* MAC */
name|mac
operator|->
name|ops
operator|.
name|reset_hw
operator|=
name|ixgbe_reset_hw_82599
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|enable_relaxed_ordering
operator|=
name|ixgbe_enable_relaxed_ordering_gen2
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_media_type
operator|=
name|ixgbe_get_media_type_82599
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_supported_physical_layer
operator|=
name|ixgbe_get_supported_physical_layer_82599
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|disable_sec_rx_path
operator|=
name|ixgbe_disable_sec_rx_path_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|enable_sec_rx_path
operator|=
name|ixgbe_enable_sec_rx_path_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|enable_rx_dma
operator|=
name|ixgbe_enable_rx_dma_82599
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|read_analog_reg8
operator|=
name|ixgbe_read_analog_reg8_82599
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|write_analog_reg8
operator|=
name|ixgbe_write_analog_reg8_82599
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|start_hw
operator|=
name|ixgbe_start_hw_82599
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_san_mac_addr
operator|=
name|ixgbe_get_san_mac_addr_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|set_san_mac_addr
operator|=
name|ixgbe_set_san_mac_addr_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_device_caps
operator|=
name|ixgbe_get_device_caps_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_wwn_prefix
operator|=
name|ixgbe_get_wwn_prefix_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_fcoe_boot_status
operator|=
name|ixgbe_get_fcoe_boot_status_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|prot_autoc_read
operator|=
name|prot_autoc_read_82599
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|prot_autoc_write
operator|=
name|prot_autoc_write_82599
expr_stmt|;
comment|/* RAR, Multicast, VLAN */
name|mac
operator|->
name|ops
operator|.
name|set_vmdq
operator|=
name|ixgbe_set_vmdq_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|set_vmdq_san_mac
operator|=
name|ixgbe_set_vmdq_san_mac_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|clear_vmdq
operator|=
name|ixgbe_clear_vmdq_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|insert_mac_addr
operator|=
name|ixgbe_insert_mac_addr_generic
expr_stmt|;
name|mac
operator|->
name|rar_highwater
operator|=
literal|1
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|set_vfta
operator|=
name|ixgbe_set_vfta_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|set_vlvf
operator|=
name|ixgbe_set_vlvf_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|clear_vfta
operator|=
name|ixgbe_clear_vfta_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|init_uta_tables
operator|=
name|ixgbe_init_uta_tables_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|setup_sfp
operator|=
name|ixgbe_setup_sfp_modules_82599
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|set_mac_anti_spoofing
operator|=
name|ixgbe_set_mac_anti_spoofing
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|set_vlan_anti_spoofing
operator|=
name|ixgbe_set_vlan_anti_spoofing
expr_stmt|;
comment|/* Link */
name|mac
operator|->
name|ops
operator|.
name|get_link_capabilities
operator|=
name|ixgbe_get_link_capabilities_82599
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|check_link
operator|=
name|ixgbe_check_mac_link_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|setup_rxpba
operator|=
name|ixgbe_set_rxpba_generic
expr_stmt|;
name|ixgbe_init_mac_link_ops_82599
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|mac
operator|->
name|mcft_size
operator|=
name|IXGBE_82599_MC_TBL_SIZE
expr_stmt|;
name|mac
operator|->
name|vft_size
operator|=
name|IXGBE_82599_VFT_TBL_SIZE
expr_stmt|;
name|mac
operator|->
name|num_rar_entries
operator|=
name|IXGBE_82599_RAR_ENTRIES
expr_stmt|;
name|mac
operator|->
name|rx_pb_size
operator|=
name|IXGBE_82599_RX_PB_SIZE
expr_stmt|;
name|mac
operator|->
name|max_rx_queues
operator|=
name|IXGBE_82599_MAX_RX_QUEUES
expr_stmt|;
name|mac
operator|->
name|max_tx_queues
operator|=
name|IXGBE_82599_MAX_TX_QUEUES
expr_stmt|;
name|mac
operator|->
name|max_msix_vectors
operator|=
name|ixgbe_get_pcie_msix_count_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|mac
operator|->
name|arc_subsystem_valid
operator|=
operator|!
operator|!
operator|(
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FWSM_BY_MAC
argument_list|(
name|hw
argument_list|)
argument_list|)
operator|&
name|IXGBE_FWSM_MODE_MASK
operator|)
expr_stmt|;
name|hw
operator|->
name|mbx
operator|.
name|ops
operator|.
name|init_params
operator|=
name|ixgbe_init_mbx_params_pf
expr_stmt|;
comment|/* EEPROM */
name|eeprom
operator|->
name|ops
operator|.
name|read
operator|=
name|ixgbe_read_eeprom_82599
expr_stmt|;
name|eeprom
operator|->
name|ops
operator|.
name|read_buffer
operator|=
name|ixgbe_read_eeprom_buffer_82599
expr_stmt|;
comment|/* Manageability interface */
name|mac
operator|->
name|ops
operator|.
name|set_fw_drv_ver
operator|=
name|ixgbe_set_fw_drv_ver_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|bypass_rw
operator|=
name|ixgbe_bypass_rw_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|bypass_valid_rd
operator|=
name|ixgbe_bypass_valid_rd_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|bypass_set
operator|=
name|ixgbe_bypass_set_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|bypass_rd_eep
operator|=
name|ixgbe_bypass_rd_eep_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_rtrup2tc
operator|=
name|ixgbe_dcb_get_rtrup2tc_generic
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_link_capabilities_82599 - Determines link capabilities  *  @hw: pointer to hardware structure  *  @speed: pointer to link speed  *  @autoneg: TRUE when autoneg or autotry is enabled  *  *  Determines the link capabilities by reading the AUTOC register.  **/
end_comment

begin_function
name|s32
name|ixgbe_get_link_capabilities_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
modifier|*
name|speed
parameter_list|,
name|bool
modifier|*
name|autoneg
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u32
name|autoc
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_link_capabilities_82599"
argument_list|)
expr_stmt|;
comment|/* Check if 1G SFP module. */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|==
name|ixgbe_sfp_type_1g_cu_core0
operator|||
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|==
name|ixgbe_sfp_type_1g_cu_core1
operator|||
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|==
name|ixgbe_sfp_type_1g_lx_core0
operator|||
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|==
name|ixgbe_sfp_type_1g_lx_core1
operator|||
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|==
name|ixgbe_sfp_type_1g_sx_core0
operator|||
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|==
name|ixgbe_sfp_type_1g_sx_core1
condition|)
block|{
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
operator|*
name|autoneg
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Determine link capabilities based on the stored value of AUTOC, 	 * which represents EEPROM defaults.  If AUTOC value has not 	 * been stored, use the current register values. 	 */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|orig_link_settings_stored
condition|)
name|autoc
operator|=
name|hw
operator|->
name|mac
operator|.
name|orig_autoc
expr_stmt|;
else|else
name|autoc
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|autoc
operator|&
name|IXGBE_AUTOC_LMS_MASK
condition|)
block|{
case|case
name|IXGBE_AUTOC_LMS_1G_LINK_NO_AN
case|:
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
operator|*
name|autoneg
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|IXGBE_AUTOC_LMS_10G_LINK_NO_AN
case|:
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_10GB_FULL
expr_stmt|;
operator|*
name|autoneg
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|IXGBE_AUTOC_LMS_1G_AN
case|:
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
operator|*
name|autoneg
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|IXGBE_AUTOC_LMS_10G_SERIAL
case|:
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_10GB_FULL
expr_stmt|;
operator|*
name|autoneg
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|IXGBE_AUTOC_LMS_KX4_KX_KR
case|:
case|case
name|IXGBE_AUTOC_LMS_KX4_KX_KR_1G_AN
case|:
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_UNKNOWN
expr_stmt|;
if|if
condition|(
name|autoc
operator|&
name|IXGBE_AUTOC_KR_SUPP
condition|)
operator|*
name|speed
operator||=
name|IXGBE_LINK_SPEED_10GB_FULL
expr_stmt|;
if|if
condition|(
name|autoc
operator|&
name|IXGBE_AUTOC_KX4_SUPP
condition|)
operator|*
name|speed
operator||=
name|IXGBE_LINK_SPEED_10GB_FULL
expr_stmt|;
if|if
condition|(
name|autoc
operator|&
name|IXGBE_AUTOC_KX_SUPP
condition|)
operator|*
name|speed
operator||=
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
operator|*
name|autoneg
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|IXGBE_AUTOC_LMS_KX4_KX_KR_SGMII
case|:
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_100_FULL
expr_stmt|;
if|if
condition|(
name|autoc
operator|&
name|IXGBE_AUTOC_KR_SUPP
condition|)
operator|*
name|speed
operator||=
name|IXGBE_LINK_SPEED_10GB_FULL
expr_stmt|;
if|if
condition|(
name|autoc
operator|&
name|IXGBE_AUTOC_KX4_SUPP
condition|)
operator|*
name|speed
operator||=
name|IXGBE_LINK_SPEED_10GB_FULL
expr_stmt|;
if|if
condition|(
name|autoc
operator|&
name|IXGBE_AUTOC_KX_SUPP
condition|)
operator|*
name|speed
operator||=
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
operator|*
name|autoneg
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|IXGBE_AUTOC_LMS_SGMII_1G_100M
case|:
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_1GB_FULL
operator||
name|IXGBE_LINK_SPEED_100_FULL
expr_stmt|;
operator|*
name|autoneg
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
name|status
operator|=
name|IXGBE_ERR_LINK_SETUP
expr_stmt|;
goto|goto
name|out
goto|;
break|break;
block|}
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|multispeed_fiber
condition|)
block|{
operator|*
name|speed
operator||=
name|IXGBE_LINK_SPEED_10GB_FULL
operator||
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
comment|/* QSFP must not enable full auto-negotiation 		 * Limited autoneg is enabled at 1G 		 */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|==
name|ixgbe_media_type_fiber_qsfp
condition|)
operator|*
name|autoneg
operator|=
name|FALSE
expr_stmt|;
else|else
operator|*
name|autoneg
operator|=
name|TRUE
expr_stmt|;
block|}
name|out
label|:
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_media_type_82599 - Get media type  *  @hw: pointer to hardware structure  *  *  Returns the media type (fiber, copper, backplane)  **/
end_comment

begin_function
name|enum
name|ixgbe_media_type
name|ixgbe_get_media_type_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|enum
name|ixgbe_media_type
name|media_type
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_media_type_82599"
argument_list|)
expr_stmt|;
comment|/* Detect if there is a copper PHY attached. */
switch|switch
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
condition|)
block|{
case|case
name|ixgbe_phy_cu_unknown
case|:
case|case
name|ixgbe_phy_tn
case|:
name|media_type
operator|=
name|ixgbe_media_type_copper
expr_stmt|;
goto|goto
name|out
goto|;
default|default:
break|break;
block|}
switch|switch
condition|(
name|hw
operator|->
name|device_id
condition|)
block|{
case|case
name|IXGBE_DEV_ID_82599_KX4
case|:
case|case
name|IXGBE_DEV_ID_82599_KX4_MEZZ
case|:
case|case
name|IXGBE_DEV_ID_82599_COMBO_BACKPLANE
case|:
case|case
name|IXGBE_DEV_ID_82599_KR
case|:
case|case
name|IXGBE_DEV_ID_82599_BACKPLANE_FCOE
case|:
case|case
name|IXGBE_DEV_ID_82599_XAUI_LOM
case|:
comment|/* Default device ID is mezzanine card KX/KX4 */
name|media_type
operator|=
name|ixgbe_media_type_backplane
expr_stmt|;
break|break;
case|case
name|IXGBE_DEV_ID_82599_SFP
case|:
case|case
name|IXGBE_DEV_ID_82599_SFP_FCOE
case|:
case|case
name|IXGBE_DEV_ID_82599_SFP_EM
case|:
case|case
name|IXGBE_DEV_ID_82599_SFP_SF2
case|:
case|case
name|IXGBE_DEV_ID_82599_SFP_SF_QP
case|:
case|case
name|IXGBE_DEV_ID_82599EN_SFP
case|:
name|media_type
operator|=
name|ixgbe_media_type_fiber
expr_stmt|;
break|break;
case|case
name|IXGBE_DEV_ID_82599_CX4
case|:
name|media_type
operator|=
name|ixgbe_media_type_cx4
expr_stmt|;
break|break;
case|case
name|IXGBE_DEV_ID_82599_T3_LOM
case|:
name|media_type
operator|=
name|ixgbe_media_type_copper
expr_stmt|;
break|break;
case|case
name|IXGBE_DEV_ID_82599_QSFP_SF_QP
case|:
name|media_type
operator|=
name|ixgbe_media_type_fiber_qsfp
expr_stmt|;
break|break;
case|case
name|IXGBE_DEV_ID_82599_BYPASS
case|:
name|media_type
operator|=
name|ixgbe_media_type_fiber_fixed
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|multispeed_fiber
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
name|media_type
operator|=
name|ixgbe_media_type_unknown
expr_stmt|;
break|break;
block|}
name|out
label|:
return|return
name|media_type
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_stop_mac_link_on_d3_82599 - Disables link on D3  *  @hw: pointer to hardware structure  *  *  Disables link during D3 power down sequence.  *  **/
end_comment

begin_function
name|void
name|ixgbe_stop_mac_link_on_d3_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|autoc2_reg
decl_stmt|;
name|u16
name|ee_ctrl_2
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_stop_mac_link_on_d3_82599"
argument_list|)
expr_stmt|;
name|ixgbe_read_eeprom
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEPROM_CTRL_2
argument_list|,
operator|&
name|ee_ctrl_2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ixgbe_mng_present
argument_list|(
name|hw
argument_list|)
operator|&&
operator|!
name|hw
operator|->
name|wol_enabled
operator|&&
name|ee_ctrl_2
operator|&
name|IXGBE_EEPROM_CCD_BIT
condition|)
block|{
name|autoc2_reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC2
argument_list|)
expr_stmt|;
name|autoc2_reg
operator||=
name|IXGBE_AUTOC2_LINK_DISABLE_ON_D3_MASK
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC2
argument_list|,
name|autoc2_reg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *  ixgbe_start_mac_link_82599 - Setup MAC link settings  *  @hw: pointer to hardware structure  *  @autoneg_wait_to_complete: TRUE when waiting for completion is needed  *  *  Configures link settings based on values in the ixgbe_hw struct.  *  Restarts the link.  Performs autonegotiation if needed.  **/
end_comment

begin_function
name|s32
name|ixgbe_start_mac_link_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|autoneg_wait_to_complete
parameter_list|)
block|{
name|u32
name|autoc_reg
decl_stmt|;
name|u32
name|links_reg
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|bool
name|got_lock
init|=
name|FALSE
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_start_mac_link_82599"
argument_list|)
expr_stmt|;
comment|/*  reset_pipeline requires us to hold this lock as it writes to 	 *  AUTOC. 	 */
if|if
condition|(
name|ixgbe_verify_lesm_fw_enabled_82599
argument_list|(
name|hw
argument_list|)
condition|)
block|{
name|status
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|acquire_swfw_sync
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR_MAC_CSR_SM
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|out
goto|;
name|got_lock
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Restart link */
name|ixgbe_reset_pipeline_82599
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|got_lock
condition|)
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR_MAC_CSR_SM
argument_list|)
expr_stmt|;
comment|/* Only poll for autoneg to complete if specified to do so */
if|if
condition|(
name|autoneg_wait_to_complete
condition|)
block|{
name|autoc_reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|autoc_reg
operator|&
name|IXGBE_AUTOC_LMS_MASK
operator|)
operator|==
name|IXGBE_AUTOC_LMS_KX4_KX_KR
operator|||
operator|(
name|autoc_reg
operator|&
name|IXGBE_AUTOC_LMS_MASK
operator|)
operator|==
name|IXGBE_AUTOC_LMS_KX4_KX_KR_1G_AN
operator|||
operator|(
name|autoc_reg
operator|&
name|IXGBE_AUTOC_LMS_MASK
operator|)
operator|==
name|IXGBE_AUTOC_LMS_KX4_KX_KR_SGMII
condition|)
block|{
name|links_reg
operator|=
literal|0
expr_stmt|;
comment|/* Just in case Autoneg time = 0 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_AUTO_NEG_TIME
condition|;
name|i
operator|++
control|)
block|{
name|links_reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LINKS
argument_list|)
expr_stmt|;
if|if
condition|(
name|links_reg
operator|&
name|IXGBE_LINKS_KX_AN_COMP
condition|)
break|break;
name|msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|links_reg
operator|&
name|IXGBE_LINKS_KX_AN_COMP
operator|)
condition|)
block|{
name|status
operator|=
name|IXGBE_ERR_AUTONEG_NOT_COMPLETE
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Autoneg did not complete.\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Add delay to filter out noises during initial link setup */
name|msec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_disable_tx_laser_multispeed_fiber - Disable Tx laser  *  @hw: pointer to hardware structure  *  *  The base drivers may require better control over SFP+ module  *  PHY states.  This includes selectively shutting down the Tx  *  laser on the PHY, effectively halting physical link.  **/
end_comment

begin_function
name|void
name|ixgbe_disable_tx_laser_multispeed_fiber
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|esdp_reg
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|)
decl_stmt|;
comment|/* Blocked by MNG FW so bail */
if|if
condition|(
name|ixgbe_check_reset_blocked
argument_list|(
name|hw
argument_list|)
condition|)
return|return;
comment|/* Disable Tx laser; allow 100us to go dark per spec */
name|esdp_reg
operator||=
name|IXGBE_ESDP_SDP3
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|,
name|esdp_reg
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_enable_tx_laser_multispeed_fiber - Enable Tx laser  *  @hw: pointer to hardware structure  *  *  The base drivers may require better control over SFP+ module  *  PHY states.  This includes selectively turning on the Tx  *  laser on the PHY, effectively starting physical link.  **/
end_comment

begin_function
name|void
name|ixgbe_enable_tx_laser_multispeed_fiber
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|esdp_reg
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|)
decl_stmt|;
comment|/* Enable Tx laser; allow 100ms to light up */
name|esdp_reg
operator|&=
operator|~
name|IXGBE_ESDP_SDP3
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|,
name|esdp_reg
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_flap_tx_laser_multispeed_fiber - Flap Tx laser  *  @hw: pointer to hardware structure  *  *  When the driver changes the link speeds that it can support,  *  it sets autotry_restart to TRUE to indicate that we need to  *  initiate a new autotry session with the link partner.  To do  *  so, we set the speed then disable and re-enable the Tx laser, to  *  alert the link partner that it also needs to restart autotry on its  *  end.  This is consistent with TRUE clause 37 autoneg, which also  *  involves a loss of signal.  **/
end_comment

begin_function
name|void
name|ixgbe_flap_tx_laser_multispeed_fiber
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_flap_tx_laser_multispeed_fiber"
argument_list|)
expr_stmt|;
comment|/* Blocked by MNG FW so bail */
if|if
condition|(
name|ixgbe_check_reset_blocked
argument_list|(
name|hw
argument_list|)
condition|)
return|return;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|autotry_restart
condition|)
block|{
name|ixgbe_disable_tx_laser_multispeed_fiber
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|ixgbe_enable_tx_laser_multispeed_fiber
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|autotry_restart
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *  ixgbe_set_hard_rate_select_speed - Set module link speed  *  @hw: pointer to hardware structure  *  @speed: link speed to set  *  *  Set module link speed via RS0/RS1 rate select pins.  */
end_comment

begin_function
name|void
name|ixgbe_set_hard_rate_select_speed
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
name|speed
parameter_list|)
block|{
name|u32
name|esdp_reg
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|speed
condition|)
block|{
case|case
name|IXGBE_LINK_SPEED_10GB_FULL
case|:
name|esdp_reg
operator||=
operator|(
name|IXGBE_ESDP_SDP5_DIR
operator||
name|IXGBE_ESDP_SDP5
operator|)
expr_stmt|;
break|break;
case|case
name|IXGBE_LINK_SPEED_1GB_FULL
case|:
name|esdp_reg
operator|&=
operator|~
name|IXGBE_ESDP_SDP5
expr_stmt|;
name|esdp_reg
operator||=
name|IXGBE_ESDP_SDP5_DIR
expr_stmt|;
break|break;
default|default:
name|DEBUGOUT
argument_list|(
literal|"Invalid fixed module speed\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|,
name|esdp_reg
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_setup_mac_link_smartspeed - Set MAC link speed using SmartSpeed  *  @hw: pointer to hardware structure  *  @speed: new link speed  *  @autoneg_wait_to_complete: TRUE when waiting for completion is needed  *  *  Implements the Intel SmartSpeed algorithm.  **/
end_comment

begin_function
name|s32
name|ixgbe_setup_mac_link_smartspeed
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
name|speed
parameter_list|,
name|bool
name|autoneg_wait_to_complete
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|ixgbe_link_speed
name|link_speed
init|=
name|IXGBE_LINK_SPEED_UNKNOWN
decl_stmt|;
name|s32
name|i
decl_stmt|,
name|j
decl_stmt|;
name|bool
name|link_up
init|=
name|FALSE
decl_stmt|;
name|u32
name|autoc_reg
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC
argument_list|)
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_setup_mac_link_smartspeed"
argument_list|)
expr_stmt|;
comment|/* Set autoneg_advertised value based on input link speed */
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_10GB_FULL
condition|)
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator||=
name|IXGBE_LINK_SPEED_10GB_FULL
expr_stmt|;
if|if
condition|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_1GB_FULL
condition|)
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator||=
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
if|if
condition|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_100_FULL
condition|)
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator||=
name|IXGBE_LINK_SPEED_100_FULL
expr_stmt|;
comment|/* 	 * Implement Intel SmartSpeed algorithm.  SmartSpeed will reduce the 	 * autoneg advertisement if link is unable to be established at the 	 * highest negotiated rate.  This can sometimes happen due to integrity 	 * issues with the physical media connection. 	 */
comment|/* First, try to get link with full advertisement */
name|hw
operator|->
name|phy
operator|.
name|smart_speed_active
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|IXGBE_SMARTSPEED_MAX_RETRIES
condition|;
name|j
operator|++
control|)
block|{
name|status
operator|=
name|ixgbe_setup_mac_link_82599
argument_list|(
name|hw
argument_list|,
name|speed
argument_list|,
name|autoneg_wait_to_complete
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|out
goto|;
comment|/* 		 * Wait for the controller to acquire link.  Per IEEE 802.3ap, 		 * Section 73.10.2, we may have to wait up to 500ms if KR is 		 * attempted, or 200ms if KX/KX4/BX/BX4 is attempted, per 		 * Table 9 in the AN MAS. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* If we have link, just jump out */
name|status
operator|=
name|ixgbe_check_link
argument_list|(
name|hw
argument_list|,
operator|&
name|link_speed
argument_list|,
operator|&
name|link_up
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|link_up
condition|)
goto|goto
name|out
goto|;
block|}
block|}
comment|/* 	 * We didn't get link.  If we advertised KR plus one of KX4/KX 	 * (or BX4/BX), then disable KR and try again. 	 */
if|if
condition|(
operator|(
operator|(
name|autoc_reg
operator|&
name|IXGBE_AUTOC_KR_SUPP
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|autoc_reg
operator|&
name|IXGBE_AUTOC_KX4_KX_SUPP_MASK
operator|)
operator|==
literal|0
operator|)
condition|)
goto|goto
name|out
goto|;
comment|/* Turn SmartSpeed on to disable KR support */
name|hw
operator|->
name|phy
operator|.
name|smart_speed_active
operator|=
name|TRUE
expr_stmt|;
name|status
operator|=
name|ixgbe_setup_mac_link_82599
argument_list|(
name|hw
argument_list|,
name|speed
argument_list|,
name|autoneg_wait_to_complete
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Wait for the controller to acquire link.  600ms will allow for 	 * the AN link_fail_inhibit_timer as well for multiple cycles of 	 * parallel detect, both 10g and 1g. This allows for the maximum 	 * connect attempts as defined in the AN MAS table 73-7. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
name|msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* If we have link, just jump out */
name|status
operator|=
name|ixgbe_check_link
argument_list|(
name|hw
argument_list|,
operator|&
name|link_speed
argument_list|,
operator|&
name|link_up
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|link_up
condition|)
goto|goto
name|out
goto|;
block|}
comment|/* We didn't get link.  Turn SmartSpeed back off. */
name|hw
operator|->
name|phy
operator|.
name|smart_speed_active
operator|=
name|FALSE
expr_stmt|;
name|status
operator|=
name|ixgbe_setup_mac_link_82599
argument_list|(
name|hw
argument_list|,
name|speed
argument_list|,
name|autoneg_wait_to_complete
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|link_up
operator|&&
operator|(
name|link_speed
operator|==
name|IXGBE_LINK_SPEED_1GB_FULL
operator|)
condition|)
name|DEBUGOUT
argument_list|(
literal|"Smartspeed has downgraded the link speed "
literal|"from the maximum advertised\n"
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_setup_mac_link_82599 - Set MAC link speed  *  @hw: pointer to hardware structure  *  @speed: new link speed  *  @autoneg_wait_to_complete: TRUE when waiting for completion is needed  *  *  Set the link speed in the AUTOC register and restarts link.  **/
end_comment

begin_function
name|s32
name|ixgbe_setup_mac_link_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
name|speed
parameter_list|,
name|bool
name|autoneg_wait_to_complete
parameter_list|)
block|{
name|bool
name|autoneg
init|=
name|FALSE
decl_stmt|;
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u32
name|pma_pmd_1g
decl_stmt|,
name|link_mode
decl_stmt|;
name|u32
name|current_autoc
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC
argument_list|)
decl_stmt|;
comment|/* holds the value of AUTOC register at this current point in time */
name|u32
name|orig_autoc
init|=
literal|0
decl_stmt|;
comment|/* holds the cached value of AUTOC register */
name|u32
name|autoc
init|=
name|current_autoc
decl_stmt|;
comment|/* Temporary variable used for comparison purposes */
name|u32
name|autoc2
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC2
argument_list|)
decl_stmt|;
name|u32
name|pma_pmd_10g_serial
init|=
name|autoc2
operator|&
name|IXGBE_AUTOC2_10G_SERIAL_PMA_PMD_MASK
decl_stmt|;
name|u32
name|links_reg
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|ixgbe_link_speed
name|link_capabilities
init|=
name|IXGBE_LINK_SPEED_UNKNOWN
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_setup_mac_link_82599"
argument_list|)
expr_stmt|;
comment|/* Check to see if speed passed in is supported. */
name|status
operator|=
name|ixgbe_get_link_capabilities
argument_list|(
name|hw
argument_list|,
operator|&
name|link_capabilities
argument_list|,
operator|&
name|autoneg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
goto|goto
name|out
goto|;
name|speed
operator|&=
name|link_capabilities
expr_stmt|;
if|if
condition|(
name|speed
operator|==
name|IXGBE_LINK_SPEED_UNKNOWN
condition|)
block|{
name|status
operator|=
name|IXGBE_ERR_LINK_SETUP
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Use stored value (EEPROM defaults) of AUTOC to find KR/KX4 support*/
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|orig_link_settings_stored
condition|)
name|orig_autoc
operator|=
name|hw
operator|->
name|mac
operator|.
name|orig_autoc
expr_stmt|;
else|else
name|orig_autoc
operator|=
name|autoc
expr_stmt|;
name|link_mode
operator|=
name|autoc
operator|&
name|IXGBE_AUTOC_LMS_MASK
expr_stmt|;
name|pma_pmd_1g
operator|=
name|autoc
operator|&
name|IXGBE_AUTOC_1G_PMA_PMD_MASK
expr_stmt|;
if|if
condition|(
name|link_mode
operator|==
name|IXGBE_AUTOC_LMS_KX4_KX_KR
operator|||
name|link_mode
operator|==
name|IXGBE_AUTOC_LMS_KX4_KX_KR_1G_AN
operator|||
name|link_mode
operator|==
name|IXGBE_AUTOC_LMS_KX4_KX_KR_SGMII
condition|)
block|{
comment|/* Set KX4/KX/KR support according to speed requested */
name|autoc
operator|&=
operator|~
operator|(
name|IXGBE_AUTOC_KX4_KX_SUPP_MASK
operator||
name|IXGBE_AUTOC_KR_SUPP
operator|)
expr_stmt|;
if|if
condition|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_10GB_FULL
condition|)
block|{
if|if
condition|(
name|orig_autoc
operator|&
name|IXGBE_AUTOC_KX4_SUPP
condition|)
name|autoc
operator||=
name|IXGBE_AUTOC_KX4_SUPP
expr_stmt|;
if|if
condition|(
operator|(
name|orig_autoc
operator|&
name|IXGBE_AUTOC_KR_SUPP
operator|)
operator|&&
operator|(
name|hw
operator|->
name|phy
operator|.
name|smart_speed_active
operator|==
name|FALSE
operator|)
condition|)
name|autoc
operator||=
name|IXGBE_AUTOC_KR_SUPP
expr_stmt|;
block|}
if|if
condition|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_1GB_FULL
condition|)
name|autoc
operator||=
name|IXGBE_AUTOC_KX_SUPP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|pma_pmd_1g
operator|==
name|IXGBE_AUTOC_1G_SFI
operator|)
operator|&&
operator|(
name|link_mode
operator|==
name|IXGBE_AUTOC_LMS_1G_LINK_NO_AN
operator|||
name|link_mode
operator|==
name|IXGBE_AUTOC_LMS_1G_AN
operator|)
condition|)
block|{
comment|/* Switch from 1G SFI to 10G SFI if requested */
if|if
condition|(
operator|(
name|speed
operator|==
name|IXGBE_LINK_SPEED_10GB_FULL
operator|)
operator|&&
operator|(
name|pma_pmd_10g_serial
operator|==
name|IXGBE_AUTOC2_10G_SFI
operator|)
condition|)
block|{
name|autoc
operator|&=
operator|~
name|IXGBE_AUTOC_LMS_MASK
expr_stmt|;
name|autoc
operator||=
name|IXGBE_AUTOC_LMS_10G_SERIAL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|pma_pmd_10g_serial
operator|==
name|IXGBE_AUTOC2_10G_SFI
operator|)
operator|&&
operator|(
name|link_mode
operator|==
name|IXGBE_AUTOC_LMS_10G_SERIAL
operator|)
condition|)
block|{
comment|/* Switch from 10G SFI to 1G SFI if requested */
if|if
condition|(
operator|(
name|speed
operator|==
name|IXGBE_LINK_SPEED_1GB_FULL
operator|)
operator|&&
operator|(
name|pma_pmd_1g
operator|==
name|IXGBE_AUTOC_1G_SFI
operator|)
condition|)
block|{
name|autoc
operator|&=
operator|~
name|IXGBE_AUTOC_LMS_MASK
expr_stmt|;
if|if
condition|(
name|autoneg
operator|||
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|ixgbe_phy_qsfp_intel
condition|)
name|autoc
operator||=
name|IXGBE_AUTOC_LMS_1G_AN
expr_stmt|;
else|else
name|autoc
operator||=
name|IXGBE_AUTOC_LMS_1G_LINK_NO_AN
expr_stmt|;
block|}
block|}
if|if
condition|(
name|autoc
operator|!=
name|current_autoc
condition|)
block|{
comment|/* Restart link */
name|status
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|prot_autoc_write
argument_list|(
name|hw
argument_list|,
name|autoc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|out
goto|;
comment|/* Only poll for autoneg to complete if specified to do so */
if|if
condition|(
name|autoneg_wait_to_complete
condition|)
block|{
if|if
condition|(
name|link_mode
operator|==
name|IXGBE_AUTOC_LMS_KX4_KX_KR
operator|||
name|link_mode
operator|==
name|IXGBE_AUTOC_LMS_KX4_KX_KR_1G_AN
operator|||
name|link_mode
operator|==
name|IXGBE_AUTOC_LMS_KX4_KX_KR_SGMII
condition|)
block|{
name|links_reg
operator|=
literal|0
expr_stmt|;
comment|/*Just in case Autoneg time=0*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_AUTO_NEG_TIME
condition|;
name|i
operator|++
control|)
block|{
name|links_reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LINKS
argument_list|)
expr_stmt|;
if|if
condition|(
name|links_reg
operator|&
name|IXGBE_LINKS_KX_AN_COMP
condition|)
break|break;
name|msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|links_reg
operator|&
name|IXGBE_LINKS_KX_AN_COMP
operator|)
condition|)
block|{
name|status
operator|=
name|IXGBE_ERR_AUTONEG_NOT_COMPLETE
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Autoneg did not complete.\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Add delay to filter out noises during initial link setup */
name|msec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
name|out
label|:
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_setup_copper_link_82599 - Set the PHY autoneg advertised field  *  @hw: pointer to hardware structure  *  @speed: new link speed  *  @autoneg_wait_to_complete: TRUE if waiting is needed to complete  *  *  Restarts link on PHY and MAC based on settings passed in.  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_setup_copper_link_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
name|speed
parameter_list|,
name|bool
name|autoneg_wait_to_complete
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_setup_copper_link_82599"
argument_list|)
expr_stmt|;
comment|/* Setup the PHY according to input speed */
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|setup_link_speed
argument_list|(
name|hw
argument_list|,
name|speed
argument_list|,
name|autoneg_wait_to_complete
argument_list|)
expr_stmt|;
comment|/* Set up MAC */
name|ixgbe_start_mac_link_82599
argument_list|(
name|hw
argument_list|,
name|autoneg_wait_to_complete
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_reset_hw_82599 - Perform hardware reset  *  @hw: pointer to hardware structure  *  *  Resets the hardware by resetting the transmit and receive units, masks  *  and clears all interrupts, perform a PHY reset, and perform a link (MAC)  *  reset.  **/
end_comment

begin_function
name|s32
name|ixgbe_reset_hw_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|ixgbe_link_speed
name|link_speed
decl_stmt|;
name|s32
name|status
decl_stmt|;
name|u32
name|ctrl
init|=
literal|0
decl_stmt|;
name|u32
name|i
decl_stmt|,
name|autoc
decl_stmt|,
name|autoc2
decl_stmt|;
name|u32
name|curr_lms
decl_stmt|;
name|bool
name|link_up
init|=
name|FALSE
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_reset_hw_82599"
argument_list|)
expr_stmt|;
comment|/* Call adapter stop to disable tx/rx and clear interrupts */
name|status
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|stop_adapter
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|reset_hw_out
goto|;
comment|/* flush pending Tx transactions */
name|ixgbe_clear_tx_pending
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* PHY ops must be identified and initialized prior to reset */
comment|/* Identify PHY and related function pointers */
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|init
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|IXGBE_ERR_SFP_NOT_SUPPORTED
condition|)
goto|goto
name|reset_hw_out
goto|;
comment|/* Setup SFP module if there is one present. */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|sfp_setup_needed
condition|)
block|{
name|status
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|setup_sfp
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|sfp_setup_needed
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|==
name|IXGBE_ERR_SFP_NOT_SUPPORTED
condition|)
goto|goto
name|reset_hw_out
goto|;
comment|/* Reset PHY */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|reset_disable
operator|==
name|FALSE
operator|&&
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|reset
operator|!=
name|NULL
condition|)
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|reset
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* remember AUTOC from before we reset */
name|curr_lms
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC
argument_list|)
operator|&
name|IXGBE_AUTOC_LMS_MASK
expr_stmt|;
name|mac_reset_top
label|:
comment|/* 	 * Issue global reset to the MAC.  Needs to be SW reset if link is up. 	 * If link reset is used when link is up, it might reset the PHY when 	 * mng is using it.  If link is down or the flag to force full link 	 * reset is set, then perform link reset. 	 */
name|ctrl
operator|=
name|IXGBE_CTRL_LNK_RST
expr_stmt|;
if|if
condition|(
operator|!
name|hw
operator|->
name|force_full_reset
condition|)
block|{
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|check_link
argument_list|(
name|hw
argument_list|,
operator|&
name|link_speed
argument_list|,
operator|&
name|link_up
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_up
condition|)
name|ctrl
operator|=
name|IXGBE_CTRL_RST
expr_stmt|;
block|}
name|ctrl
operator||=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CTRL
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Poll for reset bit to self-clear meaning reset is complete */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ctrl
operator|&
name|IXGBE_CTRL_RST_MASK
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|ctrl
operator|&
name|IXGBE_CTRL_RST_MASK
condition|)
block|{
name|status
operator|=
name|IXGBE_ERR_RESET_FAILED
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Reset polling failed to complete.\n"
argument_list|)
expr_stmt|;
block|}
name|msec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
comment|/* 	 * Double resets are required for recovery from certain error 	 * conditions.  Between resets, it is necessary to stall to 	 * allow time for any pending HW events to complete. 	 */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|flags
operator|&
name|IXGBE_FLAGS_DOUBLE_RESET_REQUIRED
condition|)
block|{
name|hw
operator|->
name|mac
operator|.
name|flags
operator|&=
operator|~
name|IXGBE_FLAGS_DOUBLE_RESET_REQUIRED
expr_stmt|;
goto|goto
name|mac_reset_top
goto|;
block|}
comment|/* 	 * Store the original AUTOC/AUTOC2 values if they have not been 	 * stored off yet.  Otherwise restore the stored original 	 * values since the reset operation sets back to defaults. 	 */
name|autoc
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC
argument_list|)
expr_stmt|;
name|autoc2
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC2
argument_list|)
expr_stmt|;
comment|/* Enable link if disabled in NVM */
if|if
condition|(
name|autoc2
operator|&
name|IXGBE_AUTOC2_LINK_DISABLE_MASK
condition|)
block|{
name|autoc2
operator|&=
operator|~
name|IXGBE_AUTOC2_LINK_DISABLE_MASK
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC2
argument_list|,
name|autoc2
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|orig_link_settings_stored
operator|==
name|FALSE
condition|)
block|{
name|hw
operator|->
name|mac
operator|.
name|orig_autoc
operator|=
name|autoc
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|orig_autoc2
operator|=
name|autoc2
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|orig_link_settings_stored
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* If MNG FW is running on a multi-speed device that 		 * doesn't autoneg with out driver support we need to 		 * leave LMS in the state it was before we MAC reset. 		 * Likewise if we support WoL we don't want change the 		 * LMS state. 		 */
if|if
condition|(
operator|(
name|hw
operator|->
name|phy
operator|.
name|multispeed_fiber
operator|&&
name|ixgbe_mng_enabled
argument_list|(
name|hw
argument_list|)
operator|)
operator|||
name|hw
operator|->
name|wol_enabled
condition|)
name|hw
operator|->
name|mac
operator|.
name|orig_autoc
operator|=
operator|(
name|hw
operator|->
name|mac
operator|.
name|orig_autoc
operator|&
operator|~
name|IXGBE_AUTOC_LMS_MASK
operator|)
operator||
name|curr_lms
expr_stmt|;
if|if
condition|(
name|autoc
operator|!=
name|hw
operator|->
name|mac
operator|.
name|orig_autoc
condition|)
block|{
name|status
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|prot_autoc_write
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|orig_autoc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|reset_hw_out
goto|;
block|}
if|if
condition|(
operator|(
name|autoc2
operator|&
name|IXGBE_AUTOC2_UPPER_MASK
operator|)
operator|!=
operator|(
name|hw
operator|->
name|mac
operator|.
name|orig_autoc2
operator|&
name|IXGBE_AUTOC2_UPPER_MASK
operator|)
condition|)
block|{
name|autoc2
operator|&=
operator|~
name|IXGBE_AUTOC2_UPPER_MASK
expr_stmt|;
name|autoc2
operator||=
operator|(
name|hw
operator|->
name|mac
operator|.
name|orig_autoc2
operator|&
name|IXGBE_AUTOC2_UPPER_MASK
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC2
argument_list|,
name|autoc2
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Store the permanent mac address */
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|get_mac_addr
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|perm_addr
argument_list|)
expr_stmt|;
comment|/* 	 * Store MAC address from RAR0, clear receive address registers, and 	 * clear the multicast table.  Also reset num_rar_entries to 128, 	 * since we modify this value when programming the SAN MAC address. 	 */
name|hw
operator|->
name|mac
operator|.
name|num_rar_entries
operator|=
literal|128
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|init_rx_addrs
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Store the permanent SAN mac address */
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|get_san_mac_addr
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|san_addr
argument_list|)
expr_stmt|;
comment|/* Add the SAN MAC address to the RAR only if it's a valid address */
if|if
condition|(
name|ixgbe_validate_mac_addr
argument_list|(
name|hw
operator|->
name|mac
operator|.
name|san_addr
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Save the SAN MAC RAR index */
name|hw
operator|->
name|mac
operator|.
name|san_mac_rar_index
operator|=
name|hw
operator|->
name|mac
operator|.
name|num_rar_entries
operator|-
literal|1
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|set_rar
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|san_mac_rar_index
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|san_addr
argument_list|,
literal|0
argument_list|,
name|IXGBE_RAH_AV
argument_list|)
expr_stmt|;
comment|/* clear VMDq pool/queue selection for this RAR */
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|clear_vmdq
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|san_mac_rar_index
argument_list|,
name|IXGBE_CLEAR_VMDQ_ALL
argument_list|)
expr_stmt|;
comment|/* Reserve the last RAR for the SAN MAC address */
name|hw
operator|->
name|mac
operator|.
name|num_rar_entries
operator|--
expr_stmt|;
block|}
comment|/* Store the alternative WWNN/WWPN prefix */
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|get_wwn_prefix
argument_list|(
name|hw
argument_list|,
operator|&
name|hw
operator|->
name|mac
operator|.
name|wwnn_prefix
argument_list|,
operator|&
name|hw
operator|->
name|mac
operator|.
name|wwpn_prefix
argument_list|)
expr_stmt|;
name|reset_hw_out
label|:
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_fdir_check_cmd_complete - poll to check whether FDIRCMD is complete  * @hw: pointer to hardware structure  * @fdircmd: current value of FDIRCMD register  */
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_fdir_check_cmd_complete
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|fdircmd
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_FDIRCMD_CMD_POLL
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|fdircmd
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRCMD
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|fdircmd
operator|&
name|IXGBE_FDIRCMD_CMD_MASK
operator|)
condition|)
return|return
name|IXGBE_SUCCESS
return|;
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
return|return
name|IXGBE_ERR_FDIR_CMD_INCOMPLETE
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_reinit_fdir_tables_82599 - Reinitialize Flow Director tables.  *  @hw: pointer to hardware structure  **/
end_comment

begin_function
name|s32
name|ixgbe_reinit_fdir_tables_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|err
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u32
name|fdirctrl
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRCTRL
argument_list|)
decl_stmt|;
name|u32
name|fdircmd
decl_stmt|;
name|fdirctrl
operator|&=
operator|~
name|IXGBE_FDIRCTRL_INIT_DONE
expr_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_reinit_fdir_tables_82599"
argument_list|)
expr_stmt|;
comment|/* 	 * Before starting reinitialization process, 	 * FDIRCMD.CMD must be zero. 	 */
name|err
operator|=
name|ixgbe_fdir_check_cmd_complete
argument_list|(
name|hw
argument_list|,
operator|&
name|fdircmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Flow Director previous command did not complete, aborting table re-initialization.\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRFREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* 	 * 82599 adapters flow director init flow cannot be restarted, 	 * Workaround 82599 silicon errata by performing the following steps 	 * before re-writing the FDIRCTRL control register with the same value. 	 * - write 1 to bit 8 of FDIRCMD register& 	 * - write 0 to bit 8 of FDIRCMD register 	 */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRCMD
argument_list|,
operator|(
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRCMD
argument_list|)
operator||
name|IXGBE_FDIRCMD_CLEARHT
operator|)
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRCMD
argument_list|,
operator|(
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRCMD
argument_list|)
operator|&
operator|~
name|IXGBE_FDIRCMD_CLEARHT
operator|)
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* 	 * Clear FDIR Hash register to clear any leftover hashes 	 * waiting to be programmed. 	 */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRHASH
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRCTRL
argument_list|,
name|fdirctrl
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Poll init-done after we write FDIRCTRL register */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_FDIR_INIT_DONE_POLL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRCTRL
argument_list|)
operator|&
name|IXGBE_FDIRCTRL_INIT_DONE
condition|)
break|break;
name|msec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>=
name|IXGBE_FDIR_INIT_DONE_POLL
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Flow Director Signature poll time exceeded!\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_FDIR_REINIT_FAILED
return|;
block|}
comment|/* Clear FDIR statistics registers (read to clear) */
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRUSTAT
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRFSTAT
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRMATCH
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRMISS
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRLEN
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_fdir_enable_82599 - Initialize Flow Director control registers  *  @hw: pointer to hardware structure  *  @fdirctrl: value to write to flow director control register  **/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_fdir_enable_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|fdirctrl
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_fdir_enable_82599"
argument_list|)
expr_stmt|;
comment|/* Prime the keys for hashing */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRHKEY
argument_list|,
name|IXGBE_ATR_BUCKET_HASH_KEY
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRSKEY
argument_list|,
name|IXGBE_ATR_SIGNATURE_HASH_KEY
argument_list|)
expr_stmt|;
comment|/* 	 * Poll init-done after we write the register.  Estimated times: 	 *      10G: PBALLOC = 11b, timing is 60us 	 *       1G: PBALLOC = 11b, timing is 600us 	 *     100M: PBALLOC = 11b, timing is 6ms 	 * 	 *     Multiple these timings by 4 if under full Rx load 	 * 	 * So we'll poll for IXGBE_FDIR_INIT_DONE_POLL times, sleeping for 	 * 1 msec per poll time.  If we're at line rate and drop to 100M, then 	 * this might not finish in our poll time, but we can live with that 	 * for now. 	 */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRCTRL
argument_list|,
name|fdirctrl
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_FDIR_INIT_DONE_POLL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRCTRL
argument_list|)
operator|&
name|IXGBE_FDIRCTRL_INIT_DONE
condition|)
break|break;
name|msec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>=
name|IXGBE_FDIR_INIT_DONE_POLL
condition|)
name|DEBUGOUT
argument_list|(
literal|"Flow Director poll time exceeded!\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_init_fdir_signature_82599 - Initialize Flow Director signature filters  *  @hw: pointer to hardware structure  *  @fdirctrl: value to write to flow director control register, initially  *	     contains just the value of the Rx packet buffer allocation  **/
end_comment

begin_function
name|s32
name|ixgbe_init_fdir_signature_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|fdirctrl
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_init_fdir_signature_82599"
argument_list|)
expr_stmt|;
comment|/* 	 * Continue setup of fdirctrl register bits: 	 *  Move the flexible bytes to use the ethertype - shift 6 words 	 *  Set the maximum length per hash bucket to 0xA filters 	 *  Send interrupt when 64 filters are left 	 */
name|fdirctrl
operator||=
operator|(
literal|0x6
operator|<<
name|IXGBE_FDIRCTRL_FLEX_SHIFT
operator|)
operator||
operator|(
literal|0xA
operator|<<
name|IXGBE_FDIRCTRL_MAX_LENGTH_SHIFT
operator|)
operator||
operator|(
literal|4
operator|<<
name|IXGBE_FDIRCTRL_FULL_THRESH_SHIFT
operator|)
expr_stmt|;
comment|/* write hashes and fdirctrl register, poll for completion */
name|ixgbe_fdir_enable_82599
argument_list|(
name|hw
argument_list|,
name|fdirctrl
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_init_fdir_perfect_82599 - Initialize Flow Director perfect filters  *  @hw: pointer to hardware structure  *  @fdirctrl: value to write to flow director control register, initially  *	     contains just the value of the Rx packet buffer allocation  *  @cloud_mode: TRUE - cloud mode, FALSE - other mode  **/
end_comment

begin_function
name|s32
name|ixgbe_init_fdir_perfect_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|fdirctrl
parameter_list|,
name|bool
name|cloud_mode
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_init_fdir_perfect_82599"
argument_list|)
expr_stmt|;
comment|/* 	 * Continue setup of fdirctrl register bits: 	 *  Turn perfect match filtering on 	 *  Report hash in RSS field of Rx wb descriptor 	 *  Initialize the drop queue to queue 127 	 *  Move the flexible bytes to use the ethertype - shift 6 words 	 *  Set the maximum length per hash bucket to 0xA filters 	 *  Send interrupt when 64 (0x4 * 16) filters are left 	 */
name|fdirctrl
operator||=
name|IXGBE_FDIRCTRL_PERFECT_MATCH
operator||
name|IXGBE_FDIRCTRL_REPORT_STATUS
operator||
operator|(
name|IXGBE_FDIR_DROP_QUEUE
operator|<<
name|IXGBE_FDIRCTRL_DROP_Q_SHIFT
operator|)
operator||
operator|(
literal|0x6
operator|<<
name|IXGBE_FDIRCTRL_FLEX_SHIFT
operator|)
operator||
operator|(
literal|0xA
operator|<<
name|IXGBE_FDIRCTRL_MAX_LENGTH_SHIFT
operator|)
operator||
operator|(
literal|4
operator|<<
name|IXGBE_FDIRCTRL_FULL_THRESH_SHIFT
operator|)
expr_stmt|;
if|if
condition|(
name|cloud_mode
condition|)
name|fdirctrl
operator||=
operator|(
name|IXGBE_FDIRCTRL_FILTERMODE_CLOUD
operator|<<
name|IXGBE_FDIRCTRL_FILTERMODE_SHIFT
operator|)
expr_stmt|;
comment|/* write hashes and fdirctrl register, poll for completion */
name|ixgbe_fdir_enable_82599
argument_list|(
name|hw
argument_list|,
name|fdirctrl
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_set_fdir_drop_queue_82599 - Set Flow Director drop queue  *  @hw: pointer to hardware structure  *  @dropqueue: Rx queue index used for the dropped packets  **/
end_comment

begin_function
name|void
name|ixgbe_set_fdir_drop_queue_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|dropqueue
parameter_list|)
block|{
name|u32
name|fdirctrl
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_set_fdir_drop_queue_82599"
argument_list|)
expr_stmt|;
comment|/* Clear init done bit and drop queue field */
name|fdirctrl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRCTRL
argument_list|)
expr_stmt|;
name|fdirctrl
operator|&=
operator|~
operator|(
name|IXGBE_FDIRCTRL_DROP_Q_MASK
operator||
name|IXGBE_FDIRCTRL_INIT_DONE
operator|)
expr_stmt|;
comment|/* Set drop queue */
name|fdirctrl
operator||=
operator|(
name|dropqueue
operator|<<
name|IXGBE_FDIRCTRL_DROP_Q_SHIFT
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_X550
operator|)
operator|||
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_X550EM_x
operator|)
operator|||
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_X550EM_a
operator|)
condition|)
name|fdirctrl
operator||=
name|IXGBE_FDIRCTRL_DROP_NO_MATCH
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRCMD
argument_list|,
operator|(
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRCMD
argument_list|)
operator||
name|IXGBE_FDIRCMD_CLEARHT
operator|)
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRCMD
argument_list|,
operator|(
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRCMD
argument_list|)
operator|&
operator|~
name|IXGBE_FDIRCMD_CLEARHT
operator|)
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* write hashes and fdirctrl register, poll for completion */
name|ixgbe_fdir_enable_82599
argument_list|(
name|hw
argument_list|,
name|fdirctrl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * These defines allow us to quickly generate all of the necessary instructions  * in the function below by simply calling out IXGBE_COMPUTE_SIG_HASH_ITERATION  * for values 0 through 15  */
end_comment

begin_define
define|#
directive|define
name|IXGBE_ATR_COMMON_HASH_KEY
define|\
value|(IXGBE_ATR_BUCKET_HASH_KEY& IXGBE_ATR_SIGNATURE_HASH_KEY)
end_define

begin_define
define|#
directive|define
name|IXGBE_COMPUTE_SIG_HASH_ITERATION
parameter_list|(
name|_n
parameter_list|)
define|\
value|do { \ 	u32 n = (_n); \ 	if (IXGBE_ATR_COMMON_HASH_KEY& (0x01<< n)) \ 		common_hash ^= lo_hash_dword>> n; \ 	else if (IXGBE_ATR_BUCKET_HASH_KEY& (0x01<< n)) \ 		bucket_hash ^= lo_hash_dword>> n; \ 	else if (IXGBE_ATR_SIGNATURE_HASH_KEY& (0x01<< n)) \ 		sig_hash ^= lo_hash_dword<< (16 - n); \ 	if (IXGBE_ATR_COMMON_HASH_KEY& (0x01<< (n + 16))) \ 		common_hash ^= hi_hash_dword>> n; \ 	else if (IXGBE_ATR_BUCKET_HASH_KEY& (0x01<< (n + 16))) \ 		bucket_hash ^= hi_hash_dword>> n; \ 	else if (IXGBE_ATR_SIGNATURE_HASH_KEY& (0x01<< (n + 16))) \ 		sig_hash ^= hi_hash_dword<< (16 - n); \ } while (0)
end_define

begin_comment
comment|/**  *  ixgbe_atr_compute_sig_hash_82599 - Compute the signature hash  *  @stream: input bitstream to compute the hash on  *  *  This function is almost identical to the function above but contains  *  several optimizations such as unwinding all of the loops, letting the  *  compiler work out all of the conditional ifs since the keys are static  *  defines, and computing two keys at once since the hashed dword stream  *  will be the same for both keys.  **/
end_comment

begin_function
name|u32
name|ixgbe_atr_compute_sig_hash_82599
parameter_list|(
name|union
name|ixgbe_atr_hash_dword
name|input
parameter_list|,
name|union
name|ixgbe_atr_hash_dword
name|common
parameter_list|)
block|{
name|u32
name|hi_hash_dword
decl_stmt|,
name|lo_hash_dword
decl_stmt|,
name|flow_vm_vlan
decl_stmt|;
name|u32
name|sig_hash
init|=
literal|0
decl_stmt|,
name|bucket_hash
init|=
literal|0
decl_stmt|,
name|common_hash
init|=
literal|0
decl_stmt|;
comment|/* record the flow_vm_vlan bits as they are a key part to the hash */
name|flow_vm_vlan
operator|=
name|IXGBE_NTOHL
argument_list|(
name|input
operator|.
name|dword
argument_list|)
expr_stmt|;
comment|/* generate common hash dword */
name|hi_hash_dword
operator|=
name|IXGBE_NTOHL
argument_list|(
name|common
operator|.
name|dword
argument_list|)
expr_stmt|;
comment|/* low dword is word swapped version of common */
name|lo_hash_dword
operator|=
operator|(
name|hi_hash_dword
operator|>>
literal|16
operator|)
operator||
operator|(
name|hi_hash_dword
operator|<<
literal|16
operator|)
expr_stmt|;
comment|/* apply flow ID/VM pool/VLAN ID bits to hash words */
name|hi_hash_dword
operator|^=
name|flow_vm_vlan
operator|^
operator|(
name|flow_vm_vlan
operator|>>
literal|16
operator|)
expr_stmt|;
comment|/* Process bits 0 and 16 */
name|IXGBE_COMPUTE_SIG_HASH_ITERATION
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * apply flow ID/VM pool/VLAN ID bits to lo hash dword, we had to 	 * delay this because bit 0 of the stream should not be processed 	 * so we do not add the VLAN until after bit 0 was processed 	 */
name|lo_hash_dword
operator|^=
name|flow_vm_vlan
operator|^
operator|(
name|flow_vm_vlan
operator|<<
literal|16
operator|)
expr_stmt|;
comment|/* Process remaining 30 bit of the key */
name|IXGBE_COMPUTE_SIG_HASH_ITERATION
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|IXGBE_COMPUTE_SIG_HASH_ITERATION
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|IXGBE_COMPUTE_SIG_HASH_ITERATION
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|IXGBE_COMPUTE_SIG_HASH_ITERATION
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|IXGBE_COMPUTE_SIG_HASH_ITERATION
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|IXGBE_COMPUTE_SIG_HASH_ITERATION
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|IXGBE_COMPUTE_SIG_HASH_ITERATION
argument_list|(
literal|7
argument_list|)
expr_stmt|;
name|IXGBE_COMPUTE_SIG_HASH_ITERATION
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|IXGBE_COMPUTE_SIG_HASH_ITERATION
argument_list|(
literal|9
argument_list|)
expr_stmt|;
name|IXGBE_COMPUTE_SIG_HASH_ITERATION
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|IXGBE_COMPUTE_SIG_HASH_ITERATION
argument_list|(
literal|11
argument_list|)
expr_stmt|;
name|IXGBE_COMPUTE_SIG_HASH_ITERATION
argument_list|(
literal|12
argument_list|)
expr_stmt|;
name|IXGBE_COMPUTE_SIG_HASH_ITERATION
argument_list|(
literal|13
argument_list|)
expr_stmt|;
name|IXGBE_COMPUTE_SIG_HASH_ITERATION
argument_list|(
literal|14
argument_list|)
expr_stmt|;
name|IXGBE_COMPUTE_SIG_HASH_ITERATION
argument_list|(
literal|15
argument_list|)
expr_stmt|;
comment|/* combine common_hash result with signature and bucket hashes */
name|bucket_hash
operator|^=
name|common_hash
expr_stmt|;
name|bucket_hash
operator|&=
name|IXGBE_ATR_HASH_MASK
expr_stmt|;
name|sig_hash
operator|^=
name|common_hash
operator|<<
literal|16
expr_stmt|;
name|sig_hash
operator|&=
name|IXGBE_ATR_HASH_MASK
operator|<<
literal|16
expr_stmt|;
comment|/* return completed signature hash */
return|return
name|sig_hash
operator|^
name|bucket_hash
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_atr_add_signature_filter_82599 - Adds a signature hash filter  *  @hw: pointer to hardware structure  *  @input: unique input dword  *  @common: compressed common input dword  *  @queue: queue index to direct traffic to  *  * Note that the tunnel bit in input must not be set when the hardware  * tunneling support does not exist.  **/
end_comment

begin_function
name|void
name|ixgbe_fdir_add_signature_filter_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|union
name|ixgbe_atr_hash_dword
name|input
parameter_list|,
name|union
name|ixgbe_atr_hash_dword
name|common
parameter_list|,
name|u8
name|queue
parameter_list|)
block|{
name|u64
name|fdirhashcmd
decl_stmt|;
name|u8
name|flow_type
decl_stmt|;
name|bool
name|tunnel
decl_stmt|;
name|u32
name|fdircmd
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_fdir_add_signature_filter_82599"
argument_list|)
expr_stmt|;
comment|/* 	 * Get the flow_type in order to program FDIRCMD properly 	 * lowest 2 bits are FDIRCMD.L4TYPE, third lowest bit is FDIRCMD.IPV6 	 * fifth is FDIRCMD.TUNNEL_FILTER 	 */
name|tunnel
operator|=
operator|!
operator|!
operator|(
name|input
operator|.
name|formatted
operator|.
name|flow_type
operator|&
name|IXGBE_ATR_L4TYPE_TUNNEL_MASK
operator|)
expr_stmt|;
name|flow_type
operator|=
name|input
operator|.
name|formatted
operator|.
name|flow_type
operator|&
operator|(
name|IXGBE_ATR_L4TYPE_TUNNEL_MASK
operator|-
literal|1
operator|)
expr_stmt|;
switch|switch
condition|(
name|flow_type
condition|)
block|{
case|case
name|IXGBE_ATR_FLOW_TYPE_TCPV4
case|:
case|case
name|IXGBE_ATR_FLOW_TYPE_UDPV4
case|:
case|case
name|IXGBE_ATR_FLOW_TYPE_SCTPV4
case|:
case|case
name|IXGBE_ATR_FLOW_TYPE_TCPV6
case|:
case|case
name|IXGBE_ATR_FLOW_TYPE_UDPV6
case|:
case|case
name|IXGBE_ATR_FLOW_TYPE_SCTPV6
case|:
break|break;
default|default:
name|DEBUGOUT
argument_list|(
literal|" Error on flow type input\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* configure FDIRCMD register */
name|fdircmd
operator|=
name|IXGBE_FDIRCMD_CMD_ADD_FLOW
operator||
name|IXGBE_FDIRCMD_FILTER_UPDATE
operator||
name|IXGBE_FDIRCMD_LAST
operator||
name|IXGBE_FDIRCMD_QUEUE_EN
expr_stmt|;
name|fdircmd
operator||=
operator|(
name|u32
operator|)
name|flow_type
operator|<<
name|IXGBE_FDIRCMD_FLOW_TYPE_SHIFT
expr_stmt|;
name|fdircmd
operator||=
operator|(
name|u32
operator|)
name|queue
operator|<<
name|IXGBE_FDIRCMD_RX_QUEUE_SHIFT
expr_stmt|;
if|if
condition|(
name|tunnel
condition|)
name|fdircmd
operator||=
name|IXGBE_FDIRCMD_TUNNEL_FILTER
expr_stmt|;
comment|/* 	 * The lower 32-bits of fdirhashcmd is for FDIRHASH, the upper 32-bits 	 * is for FDIRCMD.  Then do a 64-bit register write from FDIRHASH. 	 */
name|fdirhashcmd
operator|=
operator|(
name|u64
operator|)
name|fdircmd
operator|<<
literal|32
expr_stmt|;
name|fdirhashcmd
operator||=
name|ixgbe_atr_compute_sig_hash_82599
argument_list|(
name|input
argument_list|,
name|common
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG64
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRHASH
argument_list|,
name|fdirhashcmd
argument_list|)
expr_stmt|;
name|DEBUGOUT2
argument_list|(
literal|"Tx Queue=%x hash=%x\n"
argument_list|,
name|queue
argument_list|,
operator|(
name|u32
operator|)
name|fdirhashcmd
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_define
define|#
directive|define
name|IXGBE_COMPUTE_BKT_HASH_ITERATION
parameter_list|(
name|_n
parameter_list|)
define|\
value|do { \ 	u32 n = (_n); \ 	if (IXGBE_ATR_BUCKET_HASH_KEY& (0x01<< n)) \ 		bucket_hash ^= lo_hash_dword>> n; \ 	if (IXGBE_ATR_BUCKET_HASH_KEY& (0x01<< (n + 16))) \ 		bucket_hash ^= hi_hash_dword>> n; \ } while (0)
end_define

begin_comment
comment|/**  *  ixgbe_atr_compute_perfect_hash_82599 - Compute the perfect filter hash  *  @atr_input: input bitstream to compute the hash on  *  @input_mask: mask for the input bitstream  *  *  This function serves two main purposes.  First it applies the input_mask  *  to the atr_input resulting in a cleaned up atr_input data stream.  *  Secondly it computes the hash and stores it in the bkt_hash field at  *  the end of the input byte stream.  This way it will be available for  *  future use without needing to recompute the hash.  **/
end_comment

begin_function
name|void
name|ixgbe_atr_compute_perfect_hash_82599
parameter_list|(
name|union
name|ixgbe_atr_input
modifier|*
name|input
parameter_list|,
name|union
name|ixgbe_atr_input
modifier|*
name|input_mask
parameter_list|)
block|{
name|u32
name|hi_hash_dword
decl_stmt|,
name|lo_hash_dword
decl_stmt|,
name|flow_vm_vlan
decl_stmt|;
name|u32
name|bucket_hash
init|=
literal|0
decl_stmt|;
name|u32
name|hi_dword
init|=
literal|0
decl_stmt|;
name|u32
name|i
init|=
literal|0
decl_stmt|;
comment|/* Apply masks to input data */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|14
condition|;
name|i
operator|++
control|)
name|input
operator|->
name|dword_stream
index|[
name|i
index|]
operator|&=
name|input_mask
operator|->
name|dword_stream
index|[
name|i
index|]
expr_stmt|;
comment|/* record the flow_vm_vlan bits as they are a key part to the hash */
name|flow_vm_vlan
operator|=
name|IXGBE_NTOHL
argument_list|(
name|input
operator|->
name|dword_stream
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* generate common hash dword */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|13
condition|;
name|i
operator|++
control|)
name|hi_dword
operator|^=
name|input
operator|->
name|dword_stream
index|[
name|i
index|]
expr_stmt|;
name|hi_hash_dword
operator|=
name|IXGBE_NTOHL
argument_list|(
name|hi_dword
argument_list|)
expr_stmt|;
comment|/* low dword is word swapped version of common */
name|lo_hash_dword
operator|=
operator|(
name|hi_hash_dword
operator|>>
literal|16
operator|)
operator||
operator|(
name|hi_hash_dword
operator|<<
literal|16
operator|)
expr_stmt|;
comment|/* apply flow ID/VM pool/VLAN ID bits to hash words */
name|hi_hash_dword
operator|^=
name|flow_vm_vlan
operator|^
operator|(
name|flow_vm_vlan
operator|>>
literal|16
operator|)
expr_stmt|;
comment|/* Process bits 0 and 16 */
name|IXGBE_COMPUTE_BKT_HASH_ITERATION
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * apply flow ID/VM pool/VLAN ID bits to lo hash dword, we had to 	 * delay this because bit 0 of the stream should not be processed 	 * so we do not add the VLAN until after bit 0 was processed 	 */
name|lo_hash_dword
operator|^=
name|flow_vm_vlan
operator|^
operator|(
name|flow_vm_vlan
operator|<<
literal|16
operator|)
expr_stmt|;
comment|/* Process remaining 30 bit of the key */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|15
condition|;
name|i
operator|++
control|)
name|IXGBE_COMPUTE_BKT_HASH_ITERATION
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* 	 * Limit hash to 13 bits since max bucket count is 8K. 	 * Store result at the end of the input stream. 	 */
name|input
operator|->
name|formatted
operator|.
name|bkt_hash
operator|=
name|bucket_hash
operator|&
literal|0x1FFF
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_fdirtcpm_82599 - generate a TCP port from atr_input_masks  *  @input_mask: mask to be bit swapped  *  *  The source and destination port masks for flow director are bit swapped  *  in that bit 15 effects bit 0, 14 effects 1, 13, 2 etc.  In order to  *  generate a correctly swapped value we need to bit swap the mask and that  *  is what is accomplished by this function.  **/
end_comment

begin_function
specifier|static
name|u32
name|ixgbe_get_fdirtcpm_82599
parameter_list|(
name|union
name|ixgbe_atr_input
modifier|*
name|input_mask
parameter_list|)
block|{
name|u32
name|mask
init|=
name|IXGBE_NTOHS
argument_list|(
name|input_mask
operator|->
name|formatted
operator|.
name|dst_port
argument_list|)
decl_stmt|;
name|mask
operator|<<=
name|IXGBE_FDIRTCPM_DPORTM_SHIFT
expr_stmt|;
name|mask
operator||=
name|IXGBE_NTOHS
argument_list|(
name|input_mask
operator|->
name|formatted
operator|.
name|src_port
argument_list|)
expr_stmt|;
name|mask
operator|=
operator|(
operator|(
name|mask
operator|&
literal|0x55555555
operator|)
operator|<<
literal|1
operator|)
operator||
operator|(
operator|(
name|mask
operator|&
literal|0xAAAAAAAA
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
name|mask
operator|=
operator|(
operator|(
name|mask
operator|&
literal|0x33333333
operator|)
operator|<<
literal|2
operator|)
operator||
operator|(
operator|(
name|mask
operator|&
literal|0xCCCCCCCC
operator|)
operator|>>
literal|2
operator|)
expr_stmt|;
name|mask
operator|=
operator|(
operator|(
name|mask
operator|&
literal|0x0F0F0F0F
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
name|mask
operator|&
literal|0xF0F0F0F0
operator|)
operator|>>
literal|4
operator|)
expr_stmt|;
return|return
operator|(
operator|(
name|mask
operator|&
literal|0x00FF00FF
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|mask
operator|&
literal|0xFF00FF00
operator|)
operator|>>
literal|8
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * These two macros are meant to address the fact that we have registers  * that are either all or in part big-endian.  As a result on big-endian  * systems we will end up byte swapping the value to little-endian before  * it is byte swapped again and written to the hardware in the original  * big-endian format.  */
end_comment

begin_define
define|#
directive|define
name|IXGBE_STORE_AS_BE32
parameter_list|(
name|_value
parameter_list|)
define|\
value|(((u32)(_value)>> 24) | (((u32)(_value)& 0x00FF0000)>> 8) | \ 	 (((u32)(_value)& 0x0000FF00)<< 8) | ((u32)(_value)<< 24))
end_define

begin_define
define|#
directive|define
name|IXGBE_WRITE_REG_BE32
parameter_list|(
name|a
parameter_list|,
name|reg
parameter_list|,
name|value
parameter_list|)
define|\
value|IXGBE_WRITE_REG((a), (reg), IXGBE_STORE_AS_BE32(IXGBE_NTOHL(value)))
end_define

begin_define
define|#
directive|define
name|IXGBE_STORE_AS_BE16
parameter_list|(
name|_value
parameter_list|)
define|\
value|IXGBE_NTOHS(((u16)(_value)>> 8) | ((u16)(_value)<< 8))
end_define

begin_function
name|s32
name|ixgbe_fdir_set_input_mask_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|union
name|ixgbe_atr_input
modifier|*
name|input_mask
parameter_list|,
name|bool
name|cloud_mode
parameter_list|)
block|{
comment|/* mask IPv6 since it is currently not supported */
name|u32
name|fdirm
init|=
name|IXGBE_FDIRM_DIPv6
decl_stmt|;
name|u32
name|fdirtcpm
decl_stmt|;
name|u32
name|fdirip6m
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_fdir_set_atr_input_mask_82599"
argument_list|)
expr_stmt|;
comment|/* 	 * Program the relevant mask registers.  If src/dst_port or src/dst_addr 	 * are zero, then assume a full mask for that field.  Also assume that 	 * a VLAN of 0 is unspecified, so mask that out as well.  L4type 	 * cannot be masked out in this implementation. 	 * 	 * This also assumes IPv4 only.  IPv6 masking isn't supported at this 	 * point in time. 	 */
comment|/* verify bucket hash is cleared on hash generation */
if|if
condition|(
name|input_mask
operator|->
name|formatted
operator|.
name|bkt_hash
condition|)
name|DEBUGOUT
argument_list|(
literal|" bucket hash should always be 0 in mask\n"
argument_list|)
expr_stmt|;
comment|/* Program FDIRM and verify partial masks */
switch|switch
condition|(
name|input_mask
operator|->
name|formatted
operator|.
name|vm_pool
operator|&
literal|0x7F
condition|)
block|{
case|case
literal|0x0
case|:
name|fdirm
operator||=
name|IXGBE_FDIRM_POOL
expr_stmt|;
case|case
literal|0x7F
case|:
break|break;
default|default:
name|DEBUGOUT
argument_list|(
literal|" Error on vm pool mask\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_CONFIG
return|;
block|}
switch|switch
condition|(
name|input_mask
operator|->
name|formatted
operator|.
name|flow_type
operator|&
name|IXGBE_ATR_L4TYPE_MASK
condition|)
block|{
case|case
literal|0x0
case|:
name|fdirm
operator||=
name|IXGBE_FDIRM_L4P
expr_stmt|;
if|if
condition|(
name|input_mask
operator|->
name|formatted
operator|.
name|dst_port
operator|||
name|input_mask
operator|->
name|formatted
operator|.
name|src_port
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|" Error on src/dst port mask\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_CONFIG
return|;
block|}
case|case
name|IXGBE_ATR_L4TYPE_MASK
case|:
break|break;
default|default:
name|DEBUGOUT
argument_list|(
literal|" Error on flow type mask\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_CONFIG
return|;
block|}
switch|switch
condition|(
name|IXGBE_NTOHS
argument_list|(
name|input_mask
operator|->
name|formatted
operator|.
name|vlan_id
argument_list|)
operator|&
literal|0xEFFF
condition|)
block|{
case|case
literal|0x0000
case|:
comment|/* mask VLAN ID */
name|fdirm
operator||=
name|IXGBE_FDIRM_VLANID
expr_stmt|;
comment|/* fall through */
case|case
literal|0x0FFF
case|:
comment|/* mask VLAN priority */
name|fdirm
operator||=
name|IXGBE_FDIRM_VLANP
expr_stmt|;
break|break;
case|case
literal|0xE000
case|:
comment|/* mask VLAN ID only */
name|fdirm
operator||=
name|IXGBE_FDIRM_VLANID
expr_stmt|;
comment|/* fall through */
case|case
literal|0xEFFF
case|:
comment|/* no VLAN fields masked */
break|break;
default|default:
name|DEBUGOUT
argument_list|(
literal|" Error on VLAN mask\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_CONFIG
return|;
block|}
switch|switch
condition|(
name|input_mask
operator|->
name|formatted
operator|.
name|flex_bytes
operator|&
literal|0xFFFF
condition|)
block|{
case|case
literal|0x0000
case|:
comment|/* Mask Flex Bytes */
name|fdirm
operator||=
name|IXGBE_FDIRM_FLEX
expr_stmt|;
comment|/* fall through */
case|case
literal|0xFFFF
case|:
break|break;
default|default:
name|DEBUGOUT
argument_list|(
literal|" Error on flexible byte mask\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_CONFIG
return|;
block|}
if|if
condition|(
name|cloud_mode
condition|)
block|{
name|fdirm
operator||=
name|IXGBE_FDIRM_L3P
expr_stmt|;
name|fdirip6m
operator|=
operator|(
operator|(
name|u32
operator|)
literal|0xFFFFU
operator|<<
name|IXGBE_FDIRIP6M_DIPM_SHIFT
operator|)
expr_stmt|;
name|fdirip6m
operator||=
name|IXGBE_FDIRIP6M_ALWAYS_MASK
expr_stmt|;
switch|switch
condition|(
name|input_mask
operator|->
name|formatted
operator|.
name|inner_mac
index|[
literal|0
index|]
operator|&
literal|0xFF
condition|)
block|{
case|case
literal|0x00
case|:
comment|/* Mask inner MAC, fall through */
name|fdirip6m
operator||=
name|IXGBE_FDIRIP6M_INNER_MAC
expr_stmt|;
case|case
literal|0xFF
case|:
break|break;
default|default:
name|DEBUGOUT
argument_list|(
literal|" Error on inner_mac byte mask\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_CONFIG
return|;
block|}
switch|switch
condition|(
name|input_mask
operator|->
name|formatted
operator|.
name|tni_vni
operator|&
literal|0xFFFFFFFF
condition|)
block|{
case|case
literal|0x0
case|:
comment|/* Mask vxlan id */
name|fdirip6m
operator||=
name|IXGBE_FDIRIP6M_TNI_VNI
expr_stmt|;
break|break;
case|case
literal|0x00FFFFFF
case|:
name|fdirip6m
operator||=
name|IXGBE_FDIRIP6M_TNI_VNI_24
expr_stmt|;
break|break;
case|case
literal|0xFFFFFFFF
case|:
break|break;
default|default:
name|DEBUGOUT
argument_list|(
literal|" Error on TNI/VNI byte mask\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_CONFIG
return|;
block|}
switch|switch
condition|(
name|input_mask
operator|->
name|formatted
operator|.
name|tunnel_type
operator|&
literal|0xFFFF
condition|)
block|{
case|case
literal|0x0
case|:
comment|/* Mask turnnel type, fall through */
name|fdirip6m
operator||=
name|IXGBE_FDIRIP6M_TUNNEL_TYPE
expr_stmt|;
case|case
literal|0xFFFF
case|:
break|break;
default|default:
name|DEBUGOUT
argument_list|(
literal|" Error on tunnel type byte mask\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_CONFIG
return|;
block|}
name|IXGBE_WRITE_REG_BE32
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRIP6M
argument_list|,
name|fdirip6m
argument_list|)
expr_stmt|;
comment|/* Set all bits in FDIRTCPM, FDIRUDPM, FDIRSCTPM, 		 * FDIRSIP4M and FDIRDIP4M in cloud mode to allow 		 * L3/L3 packets to tunnel. 		 */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRTCPM
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRUDPM
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG_BE32
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRDIP4M
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG_BE32
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRSIP4M
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|ixgbe_mac_X550
case|:
case|case
name|ixgbe_mac_X550EM_x
case|:
case|case
name|ixgbe_mac_X550EM_a
case|:
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRSCTPM
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* Now mask VM pool and destination IPv6 - bits 5 and 2 */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRM
argument_list|,
name|fdirm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cloud_mode
condition|)
block|{
comment|/* store the TCP/UDP port masks, bit reversed from port 		 * layout */
name|fdirtcpm
operator|=
name|ixgbe_get_fdirtcpm_82599
argument_list|(
name|input_mask
argument_list|)
expr_stmt|;
comment|/* write both the same so that UDP and TCP use the same mask */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRTCPM
argument_list|,
operator|~
name|fdirtcpm
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRUDPM
argument_list|,
operator|~
name|fdirtcpm
argument_list|)
expr_stmt|;
comment|/* also use it for SCTP */
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|ixgbe_mac_X550
case|:
case|case
name|ixgbe_mac_X550EM_x
case|:
case|case
name|ixgbe_mac_X550EM_a
case|:
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRSCTPM
argument_list|,
operator|~
name|fdirtcpm
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* store source and destination IP masks (big-enian) */
name|IXGBE_WRITE_REG_BE32
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRSIP4M
argument_list|,
operator|~
name|input_mask
operator|->
name|formatted
operator|.
name|src_ip
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG_BE32
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRDIP4M
argument_list|,
operator|~
name|input_mask
operator|->
name|formatted
operator|.
name|dst_ip
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_function
name|s32
name|ixgbe_fdir_write_perfect_filter_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|union
name|ixgbe_atr_input
modifier|*
name|input
parameter_list|,
name|u16
name|soft_id
parameter_list|,
name|u8
name|queue
parameter_list|,
name|bool
name|cloud_mode
parameter_list|)
block|{
name|u32
name|fdirport
decl_stmt|,
name|fdirvlan
decl_stmt|,
name|fdirhash
decl_stmt|,
name|fdircmd
decl_stmt|;
name|u32
name|addr_low
decl_stmt|,
name|addr_high
decl_stmt|;
name|u32
name|cloud_type
init|=
literal|0
decl_stmt|;
name|s32
name|err
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_fdir_write_perfect_filter_82599"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cloud_mode
condition|)
block|{
comment|/* currently IPv6 is not supported, must be programmed with 0 */
name|IXGBE_WRITE_REG_BE32
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRSIPv6
argument_list|(
literal|0
argument_list|)
argument_list|,
name|input
operator|->
name|formatted
operator|.
name|src_ip
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG_BE32
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRSIPv6
argument_list|(
literal|1
argument_list|)
argument_list|,
name|input
operator|->
name|formatted
operator|.
name|src_ip
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG_BE32
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRSIPv6
argument_list|(
literal|2
argument_list|)
argument_list|,
name|input
operator|->
name|formatted
operator|.
name|src_ip
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* record the source address (big-endian) */
name|IXGBE_WRITE_REG_BE32
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRIPSA
argument_list|,
name|input
operator|->
name|formatted
operator|.
name|src_ip
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* record the first 32 bits of the destination address 		 * (big-endian) */
name|IXGBE_WRITE_REG_BE32
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRIPDA
argument_list|,
name|input
operator|->
name|formatted
operator|.
name|dst_ip
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* record source and destination port (little-endian)*/
name|fdirport
operator|=
name|IXGBE_NTOHS
argument_list|(
name|input
operator|->
name|formatted
operator|.
name|dst_port
argument_list|)
expr_stmt|;
name|fdirport
operator|<<=
name|IXGBE_FDIRPORT_DESTINATION_SHIFT
expr_stmt|;
name|fdirport
operator||=
name|IXGBE_NTOHS
argument_list|(
name|input
operator|->
name|formatted
operator|.
name|src_port
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRPORT
argument_list|,
name|fdirport
argument_list|)
expr_stmt|;
block|}
comment|/* record VLAN (little-endian) and flex_bytes(big-endian) */
name|fdirvlan
operator|=
name|IXGBE_STORE_AS_BE16
argument_list|(
name|input
operator|->
name|formatted
operator|.
name|flex_bytes
argument_list|)
expr_stmt|;
name|fdirvlan
operator|<<=
name|IXGBE_FDIRVLAN_FLEX_SHIFT
expr_stmt|;
name|fdirvlan
operator||=
name|IXGBE_NTOHS
argument_list|(
name|input
operator|->
name|formatted
operator|.
name|vlan_id
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRVLAN
argument_list|,
name|fdirvlan
argument_list|)
expr_stmt|;
if|if
condition|(
name|cloud_mode
condition|)
block|{
if|if
condition|(
name|input
operator|->
name|formatted
operator|.
name|tunnel_type
operator|!=
literal|0
condition|)
name|cloud_type
operator|=
literal|0x80000000
expr_stmt|;
name|addr_low
operator|=
operator|(
operator|(
name|u32
operator|)
name|input
operator|->
name|formatted
operator|.
name|inner_mac
index|[
literal|0
index|]
operator||
operator|(
operator|(
name|u32
operator|)
name|input
operator|->
name|formatted
operator|.
name|inner_mac
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|u32
operator|)
name|input
operator|->
name|formatted
operator|.
name|inner_mac
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|u32
operator|)
name|input
operator|->
name|formatted
operator|.
name|inner_mac
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
operator|)
expr_stmt|;
name|addr_high
operator|=
operator|(
operator|(
name|u32
operator|)
name|input
operator|->
name|formatted
operator|.
name|inner_mac
index|[
literal|4
index|]
operator||
operator|(
operator|(
name|u32
operator|)
name|input
operator|->
name|formatted
operator|.
name|inner_mac
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator|)
expr_stmt|;
name|cloud_type
operator||=
name|addr_high
expr_stmt|;
name|IXGBE_WRITE_REG_BE32
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRSIPv6
argument_list|(
literal|0
argument_list|)
argument_list|,
name|addr_low
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG_BE32
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRSIPv6
argument_list|(
literal|1
argument_list|)
argument_list|,
name|cloud_type
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG_BE32
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRSIPv6
argument_list|(
literal|2
argument_list|)
argument_list|,
name|input
operator|->
name|formatted
operator|.
name|tni_vni
argument_list|)
expr_stmt|;
block|}
comment|/* configure FDIRHASH register */
name|fdirhash
operator|=
name|input
operator|->
name|formatted
operator|.
name|bkt_hash
expr_stmt|;
name|fdirhash
operator||=
name|soft_id
operator|<<
name|IXGBE_FDIRHASH_SIG_SW_INDEX_SHIFT
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRHASH
argument_list|,
name|fdirhash
argument_list|)
expr_stmt|;
comment|/* 	 * flush all previous writes to make certain registers are 	 * programmed prior to issuing the command 	 */
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* configure FDIRCMD register */
name|fdircmd
operator|=
name|IXGBE_FDIRCMD_CMD_ADD_FLOW
operator||
name|IXGBE_FDIRCMD_FILTER_UPDATE
operator||
name|IXGBE_FDIRCMD_LAST
operator||
name|IXGBE_FDIRCMD_QUEUE_EN
expr_stmt|;
if|if
condition|(
name|queue
operator|==
name|IXGBE_FDIR_DROP_QUEUE
condition|)
name|fdircmd
operator||=
name|IXGBE_FDIRCMD_DROP
expr_stmt|;
if|if
condition|(
name|input
operator|->
name|formatted
operator|.
name|flow_type
operator|&
name|IXGBE_ATR_L4TYPE_TUNNEL_MASK
condition|)
name|fdircmd
operator||=
name|IXGBE_FDIRCMD_TUNNEL_FILTER
expr_stmt|;
name|fdircmd
operator||=
name|input
operator|->
name|formatted
operator|.
name|flow_type
operator|<<
name|IXGBE_FDIRCMD_FLOW_TYPE_SHIFT
expr_stmt|;
name|fdircmd
operator||=
operator|(
name|u32
operator|)
name|queue
operator|<<
name|IXGBE_FDIRCMD_RX_QUEUE_SHIFT
expr_stmt|;
name|fdircmd
operator||=
operator|(
name|u32
operator|)
name|input
operator|->
name|formatted
operator|.
name|vm_pool
operator|<<
name|IXGBE_FDIRCMD_VT_POOL_SHIFT
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRCMD
argument_list|,
name|fdircmd
argument_list|)
expr_stmt|;
name|err
operator|=
name|ixgbe_fdir_check_cmd_complete
argument_list|(
name|hw
argument_list|,
operator|&
name|fdircmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Flow Director command did not complete!\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_function
name|s32
name|ixgbe_fdir_erase_perfect_filter_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|union
name|ixgbe_atr_input
modifier|*
name|input
parameter_list|,
name|u16
name|soft_id
parameter_list|)
block|{
name|u32
name|fdirhash
decl_stmt|;
name|u32
name|fdircmd
decl_stmt|;
name|s32
name|err
decl_stmt|;
comment|/* configure FDIRHASH register */
name|fdirhash
operator|=
name|input
operator|->
name|formatted
operator|.
name|bkt_hash
expr_stmt|;
name|fdirhash
operator||=
name|soft_id
operator|<<
name|IXGBE_FDIRHASH_SIG_SW_INDEX_SHIFT
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRHASH
argument_list|,
name|fdirhash
argument_list|)
expr_stmt|;
comment|/* flush hash to HW */
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Query if filter is present */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRCMD
argument_list|,
name|IXGBE_FDIRCMD_CMD_QUERY_REM_FILT
argument_list|)
expr_stmt|;
name|err
operator|=
name|ixgbe_fdir_check_cmd_complete
argument_list|(
name|hw
argument_list|,
operator|&
name|fdircmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Flow Director command did not complete!\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
comment|/* if filter exists in hardware then remove it */
if|if
condition|(
name|fdircmd
operator|&
name|IXGBE_FDIRCMD_FILTER_VALID
condition|)
block|{
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRHASH
argument_list|,
name|fdirhash
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRCMD
argument_list|,
name|IXGBE_FDIRCMD_CMD_REMOVE_FLOW
argument_list|)
expr_stmt|;
block|}
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_fdir_add_perfect_filter_82599 - Adds a perfect filter  *  @hw: pointer to hardware structure  *  @input: input bitstream  *  @input_mask: mask for the input bitstream  *  @soft_id: software index for the filters  *  @queue: queue index to direct traffic to  *  *  Note that the caller to this function must lock before calling, since the  *  hardware writes must be protected from one another.  **/
end_comment

begin_function
name|s32
name|ixgbe_fdir_add_perfect_filter_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|union
name|ixgbe_atr_input
modifier|*
name|input
parameter_list|,
name|union
name|ixgbe_atr_input
modifier|*
name|input_mask
parameter_list|,
name|u16
name|soft_id
parameter_list|,
name|u8
name|queue
parameter_list|,
name|bool
name|cloud_mode
parameter_list|)
block|{
name|s32
name|err
init|=
name|IXGBE_ERR_CONFIG
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_fdir_add_perfect_filter_82599"
argument_list|)
expr_stmt|;
comment|/* 	 * Check flow_type formatting, and bail out before we touch the hardware 	 * if there's a configuration issue 	 */
switch|switch
condition|(
name|input
operator|->
name|formatted
operator|.
name|flow_type
condition|)
block|{
case|case
name|IXGBE_ATR_FLOW_TYPE_IPV4
case|:
case|case
name|IXGBE_ATR_FLOW_TYPE_TUNNELED_IPV4
case|:
name|input_mask
operator|->
name|formatted
operator|.
name|flow_type
operator|=
name|IXGBE_ATR_L4TYPE_IPV6_MASK
expr_stmt|;
if|if
condition|(
name|input
operator|->
name|formatted
operator|.
name|dst_port
operator|||
name|input
operator|->
name|formatted
operator|.
name|src_port
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|" Error on src/dst port\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_CONFIG
return|;
block|}
break|break;
case|case
name|IXGBE_ATR_FLOW_TYPE_SCTPV4
case|:
case|case
name|IXGBE_ATR_FLOW_TYPE_TUNNELED_SCTPV4
case|:
if|if
condition|(
name|input
operator|->
name|formatted
operator|.
name|dst_port
operator|||
name|input
operator|->
name|formatted
operator|.
name|src_port
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|" Error on src/dst port\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_CONFIG
return|;
block|}
comment|/* fall through */
case|case
name|IXGBE_ATR_FLOW_TYPE_TCPV4
case|:
case|case
name|IXGBE_ATR_FLOW_TYPE_TUNNELED_TCPV4
case|:
case|case
name|IXGBE_ATR_FLOW_TYPE_UDPV4
case|:
case|case
name|IXGBE_ATR_FLOW_TYPE_TUNNELED_UDPV4
case|:
name|input_mask
operator|->
name|formatted
operator|.
name|flow_type
operator|=
name|IXGBE_ATR_L4TYPE_IPV6_MASK
operator||
name|IXGBE_ATR_L4TYPE_MASK
expr_stmt|;
break|break;
default|default:
name|DEBUGOUT
argument_list|(
literal|" Error on flow type input\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
comment|/* program input mask into the HW */
name|err
operator|=
name|ixgbe_fdir_set_input_mask_82599
argument_list|(
name|hw
argument_list|,
name|input_mask
argument_list|,
name|cloud_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
comment|/* apply mask and compute/store hash */
name|ixgbe_atr_compute_perfect_hash_82599
argument_list|(
name|input
argument_list|,
name|input_mask
argument_list|)
expr_stmt|;
comment|/* program filters to filter memory */
return|return
name|ixgbe_fdir_write_perfect_filter_82599
argument_list|(
name|hw
argument_list|,
name|input
argument_list|,
name|soft_id
argument_list|,
name|queue
argument_list|,
name|cloud_mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_read_analog_reg8_82599 - Reads 8 bit Omer analog register  *  @hw: pointer to hardware structure  *  @reg: analog register to read  *  @val: read value  *  *  Performs read operation to Omer analog register specified.  **/
end_comment

begin_function
name|s32
name|ixgbe_read_analog_reg8_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|reg
parameter_list|,
name|u8
modifier|*
name|val
parameter_list|)
block|{
name|u32
name|core_ctl
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_read_analog_reg8_82599"
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CORECTL
argument_list|,
name|IXGBE_CORECTL_WRITE_CMD
operator||
operator|(
name|reg
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|core_ctl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CORECTL
argument_list|)
expr_stmt|;
operator|*
name|val
operator|=
operator|(
name|u8
operator|)
name|core_ctl
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_write_analog_reg8_82599 - Writes 8 bit Omer analog register  *  @hw: pointer to hardware structure  *  @reg: atlas register to write  *  @val: value to write  *  *  Performs write operation to Omer analog register specified.  **/
end_comment

begin_function
name|s32
name|ixgbe_write_analog_reg8_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|reg
parameter_list|,
name|u8
name|val
parameter_list|)
block|{
name|u32
name|core_ctl
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_write_analog_reg8_82599"
argument_list|)
expr_stmt|;
name|core_ctl
operator|=
operator|(
name|reg
operator|<<
literal|8
operator|)
operator||
name|val
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CORECTL
argument_list|,
name|core_ctl
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_start_hw_82599 - Prepare hardware for Tx/Rx  *  @hw: pointer to hardware structure  *  *  Starts the hardware using the generic start_hw function  *  and the generation start_hw function.  *  Then performs revision-specific operations, if any.  **/
end_comment

begin_function
name|s32
name|ixgbe_start_hw_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_start_hw_82599"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|ixgbe_start_hw_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|ixgbe_start_hw_gen2
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|out
goto|;
comment|/* We need to run link autotry after the driver loads */
name|hw
operator|->
name|mac
operator|.
name|autotry_restart
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|ret_val
operator|==
name|IXGBE_SUCCESS
condition|)
name|ret_val
operator|=
name|ixgbe_verify_fw_version_82599
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_identify_phy_82599 - Get physical layer module  *  @hw: pointer to hardware structure  *  *  Determines the physical layer module found on the current adapter.  *  If PHY already detected, maintains current PHY type in hw struct,  *  otherwise executes the PHY detection routine.  **/
end_comment

begin_function
name|s32
name|ixgbe_identify_phy_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_identify_phy_82599"
argument_list|)
expr_stmt|;
comment|/* Detect PHY if not unknown - returns success if already detected. */
name|status
operator|=
name|ixgbe_identify_phy_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
block|{
comment|/* 82599 10GBASE-T requires an external PHY */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|get_media_type
argument_list|(
name|hw
argument_list|)
operator|==
name|ixgbe_media_type_copper
condition|)
return|return
name|status
return|;
else|else
name|status
operator|=
name|ixgbe_identify_module_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
comment|/* Set PHY type none if no PHY detected */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|ixgbe_phy_unknown
condition|)
block|{
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|ixgbe_phy_none
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
comment|/* Return error if SFP module has been detected but is not supported */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|ixgbe_phy_sfp_unsupported
condition|)
return|return
name|IXGBE_ERR_SFP_NOT_SUPPORTED
return|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_supported_physical_layer_82599 - Returns physical layer type  *  @hw: pointer to hardware structure  *  *  Determines physical layer capabilities of the current configuration.  **/
end_comment

begin_function
name|u64
name|ixgbe_get_supported_physical_layer_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u64
name|physical_layer
init|=
name|IXGBE_PHYSICAL_LAYER_UNKNOWN
decl_stmt|;
name|u32
name|autoc
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC
argument_list|)
decl_stmt|;
name|u32
name|autoc2
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC2
argument_list|)
decl_stmt|;
name|u32
name|pma_pmd_10g_serial
init|=
name|autoc2
operator|&
name|IXGBE_AUTOC2_10G_SERIAL_PMA_PMD_MASK
decl_stmt|;
name|u32
name|pma_pmd_10g_parallel
init|=
name|autoc
operator|&
name|IXGBE_AUTOC_10G_PMA_PMD_MASK
decl_stmt|;
name|u32
name|pma_pmd_1g
init|=
name|autoc
operator|&
name|IXGBE_AUTOC_1G_PMA_PMD_MASK
decl_stmt|;
name|u16
name|ext_ability
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_support_physical_layer_82599"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|identify
argument_list|(
name|hw
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
condition|)
block|{
case|case
name|ixgbe_phy_tn
case|:
case|case
name|ixgbe_phy_cu_unknown
case|:
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_PHY_EXT_ABILITY
argument_list|,
name|IXGBE_MDIO_PMA_PMD_DEV_TYPE
argument_list|,
operator|&
name|ext_ability
argument_list|)
expr_stmt|;
if|if
condition|(
name|ext_ability
operator|&
name|IXGBE_MDIO_PHY_10GBASET_ABILITY
condition|)
name|physical_layer
operator||=
name|IXGBE_PHYSICAL_LAYER_10GBASE_T
expr_stmt|;
if|if
condition|(
name|ext_ability
operator|&
name|IXGBE_MDIO_PHY_1000BASET_ABILITY
condition|)
name|physical_layer
operator||=
name|IXGBE_PHYSICAL_LAYER_1000BASE_T
expr_stmt|;
if|if
condition|(
name|ext_ability
operator|&
name|IXGBE_MDIO_PHY_100BASETX_ABILITY
condition|)
name|physical_layer
operator||=
name|IXGBE_PHYSICAL_LAYER_100BASE_TX
expr_stmt|;
goto|goto
name|out
goto|;
default|default:
break|break;
block|}
switch|switch
condition|(
name|autoc
operator|&
name|IXGBE_AUTOC_LMS_MASK
condition|)
block|{
case|case
name|IXGBE_AUTOC_LMS_1G_AN
case|:
case|case
name|IXGBE_AUTOC_LMS_1G_LINK_NO_AN
case|:
if|if
condition|(
name|pma_pmd_1g
operator|==
name|IXGBE_AUTOC_1G_KX_BX
condition|)
block|{
name|physical_layer
operator|=
name|IXGBE_PHYSICAL_LAYER_1000BASE_KX
operator||
name|IXGBE_PHYSICAL_LAYER_1000BASE_BX
expr_stmt|;
goto|goto
name|out
goto|;
block|}
else|else
comment|/* SFI mode so read SFP module */
goto|goto
name|sfp_check
goto|;
break|break;
case|case
name|IXGBE_AUTOC_LMS_10G_LINK_NO_AN
case|:
if|if
condition|(
name|pma_pmd_10g_parallel
operator|==
name|IXGBE_AUTOC_10G_CX4
condition|)
name|physical_layer
operator|=
name|IXGBE_PHYSICAL_LAYER_10GBASE_CX4
expr_stmt|;
elseif|else
if|if
condition|(
name|pma_pmd_10g_parallel
operator|==
name|IXGBE_AUTOC_10G_KX4
condition|)
name|physical_layer
operator|=
name|IXGBE_PHYSICAL_LAYER_10GBASE_KX4
expr_stmt|;
elseif|else
if|if
condition|(
name|pma_pmd_10g_parallel
operator|==
name|IXGBE_AUTOC_10G_XAUI
condition|)
name|physical_layer
operator|=
name|IXGBE_PHYSICAL_LAYER_10GBASE_XAUI
expr_stmt|;
goto|goto
name|out
goto|;
break|break;
case|case
name|IXGBE_AUTOC_LMS_10G_SERIAL
case|:
if|if
condition|(
name|pma_pmd_10g_serial
operator|==
name|IXGBE_AUTOC2_10G_KR
condition|)
block|{
name|physical_layer
operator|=
name|IXGBE_PHYSICAL_LAYER_10GBASE_KR
expr_stmt|;
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
name|pma_pmd_10g_serial
operator|==
name|IXGBE_AUTOC2_10G_SFI
condition|)
goto|goto
name|sfp_check
goto|;
break|break;
case|case
name|IXGBE_AUTOC_LMS_KX4_KX_KR
case|:
case|case
name|IXGBE_AUTOC_LMS_KX4_KX_KR_1G_AN
case|:
if|if
condition|(
name|autoc
operator|&
name|IXGBE_AUTOC_KX_SUPP
condition|)
name|physical_layer
operator||=
name|IXGBE_PHYSICAL_LAYER_1000BASE_KX
expr_stmt|;
if|if
condition|(
name|autoc
operator|&
name|IXGBE_AUTOC_KX4_SUPP
condition|)
name|physical_layer
operator||=
name|IXGBE_PHYSICAL_LAYER_10GBASE_KX4
expr_stmt|;
if|if
condition|(
name|autoc
operator|&
name|IXGBE_AUTOC_KR_SUPP
condition|)
name|physical_layer
operator||=
name|IXGBE_PHYSICAL_LAYER_10GBASE_KR
expr_stmt|;
goto|goto
name|out
goto|;
break|break;
default|default:
goto|goto
name|out
goto|;
break|break;
block|}
name|sfp_check
label|:
comment|/* SFP check must be done last since DA modules are sometimes used to 	 * test KR mode -  we need to id KR mode correctly before SFP module. 	 * Call identify_sfp because the pluggable module may have changed */
name|physical_layer
operator|=
name|ixgbe_get_supported_phy_sfp_layer_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|physical_layer
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_enable_rx_dma_82599 - Enable the Rx DMA unit on 82599  *  @hw: pointer to hardware structure  *  @regval: register value to write to RXCTRL  *  *  Enables the Rx DMA unit for 82599  **/
end_comment

begin_function
name|s32
name|ixgbe_enable_rx_dma_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|regval
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_enable_rx_dma_82599"
argument_list|)
expr_stmt|;
comment|/* 	 * Workaround for 82599 silicon errata when enabling the Rx datapath. 	 * If traffic is incoming before we enable the Rx unit, it could hang 	 * the Rx DMA unit.  Therefore, make sure the security engine is 	 * completely disabled prior to enabling the Rx unit. 	 */
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|disable_sec_rx_path
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|regval
operator|&
name|IXGBE_RXCTRL_RXEN
condition|)
name|ixgbe_enable_rx
argument_list|(
name|hw
argument_list|)
expr_stmt|;
else|else
name|ixgbe_disable_rx
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|enable_sec_rx_path
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_verify_fw_version_82599 - verify FW version for 82599  *  @hw: pointer to hardware structure  *  *  Verifies that installed the firmware version is 0.6 or higher  *  for SFI devices. All 82599 SFI devices should have version 0.6 or higher.  *  *  Returns IXGBE_ERR_EEPROM_VERSION if the FW is not present or  *  if the FW version is not supported.  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_verify_fw_version_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_ERR_EEPROM_VERSION
decl_stmt|;
name|u16
name|fw_offset
decl_stmt|,
name|fw_ptp_cfg_offset
decl_stmt|;
name|u16
name|fw_version
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_verify_fw_version_82599"
argument_list|)
expr_stmt|;
comment|/* firmware check is only necessary for SFI devices */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|!=
name|ixgbe_media_type_fiber
condition|)
block|{
name|status
operator|=
name|IXGBE_SUCCESS
expr_stmt|;
goto|goto
name|fw_version_out
goto|;
block|}
comment|/* get the offset to the Firmware Module block */
if|if
condition|(
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|IXGBE_FW_PTR
argument_list|,
operator|&
name|fw_offset
argument_list|)
condition|)
block|{
name|ERROR_REPORT2
argument_list|(
name|IXGBE_ERROR_INVALID_STATE
argument_list|,
literal|"eeprom read at offset %d failed"
argument_list|,
name|IXGBE_FW_PTR
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_EEPROM_VERSION
return|;
block|}
if|if
condition|(
operator|(
name|fw_offset
operator|==
literal|0
operator|)
operator|||
operator|(
name|fw_offset
operator|==
literal|0xFFFF
operator|)
condition|)
goto|goto
name|fw_version_out
goto|;
comment|/* get the offset to the Pass Through Patch Configuration block */
if|if
condition|(
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
operator|(
name|fw_offset
operator|+
name|IXGBE_FW_PASSTHROUGH_PATCH_CONFIG_PTR
operator|)
argument_list|,
operator|&
name|fw_ptp_cfg_offset
argument_list|)
condition|)
block|{
name|ERROR_REPORT2
argument_list|(
name|IXGBE_ERROR_INVALID_STATE
argument_list|,
literal|"eeprom read at offset %d failed"
argument_list|,
name|fw_offset
operator|+
name|IXGBE_FW_PASSTHROUGH_PATCH_CONFIG_PTR
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_EEPROM_VERSION
return|;
block|}
if|if
condition|(
operator|(
name|fw_ptp_cfg_offset
operator|==
literal|0
operator|)
operator|||
operator|(
name|fw_ptp_cfg_offset
operator|==
literal|0xFFFF
operator|)
condition|)
goto|goto
name|fw_version_out
goto|;
comment|/* get the firmware version */
if|if
condition|(
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
operator|(
name|fw_ptp_cfg_offset
operator|+
name|IXGBE_FW_PATCH_VERSION_4
operator|)
argument_list|,
operator|&
name|fw_version
argument_list|)
condition|)
block|{
name|ERROR_REPORT2
argument_list|(
name|IXGBE_ERROR_INVALID_STATE
argument_list|,
literal|"eeprom read at offset %d failed"
argument_list|,
name|fw_ptp_cfg_offset
operator|+
name|IXGBE_FW_PATCH_VERSION_4
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_EEPROM_VERSION
return|;
block|}
if|if
condition|(
name|fw_version
operator|>
literal|0x5
condition|)
name|status
operator|=
name|IXGBE_SUCCESS
expr_stmt|;
name|fw_version_out
label|:
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_verify_lesm_fw_enabled_82599 - Checks LESM FW module state.  *  @hw: pointer to hardware structure  *  *  Returns TRUE if the LESM FW module is present and enabled. Otherwise  *  returns FALSE. Smart Speed must be disabled if LESM FW module is enabled.  **/
end_comment

begin_function
name|bool
name|ixgbe_verify_lesm_fw_enabled_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|bool
name|lesm_enabled
init|=
name|FALSE
decl_stmt|;
name|u16
name|fw_offset
decl_stmt|,
name|fw_lesm_param_offset
decl_stmt|,
name|fw_lesm_state
decl_stmt|;
name|s32
name|status
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_verify_lesm_fw_enabled_82599"
argument_list|)
expr_stmt|;
comment|/* get the offset to the Firmware Module block */
name|status
operator|=
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|IXGBE_FW_PTR
argument_list|,
operator|&
name|fw_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|!=
name|IXGBE_SUCCESS
operator|)
operator|||
operator|(
name|fw_offset
operator|==
literal|0
operator|)
operator|||
operator|(
name|fw_offset
operator|==
literal|0xFFFF
operator|)
condition|)
goto|goto
name|out
goto|;
comment|/* get the offset to the LESM Parameters block */
name|status
operator|=
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
operator|(
name|fw_offset
operator|+
name|IXGBE_FW_LESM_PARAMETERS_PTR
operator|)
argument_list|,
operator|&
name|fw_lesm_param_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|!=
name|IXGBE_SUCCESS
operator|)
operator|||
operator|(
name|fw_lesm_param_offset
operator|==
literal|0
operator|)
operator|||
operator|(
name|fw_lesm_param_offset
operator|==
literal|0xFFFF
operator|)
condition|)
goto|goto
name|out
goto|;
comment|/* get the LESM state word */
name|status
operator|=
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
operator|(
name|fw_lesm_param_offset
operator|+
name|IXGBE_FW_LESM_STATE_1
operator|)
argument_list|,
operator|&
name|fw_lesm_state
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|==
name|IXGBE_SUCCESS
operator|)
operator|&&
operator|(
name|fw_lesm_state
operator|&
name|IXGBE_FW_LESM_STATE_ENABLED
operator|)
condition|)
name|lesm_enabled
operator|=
name|TRUE
expr_stmt|;
name|out
label|:
return|return
name|lesm_enabled
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_read_eeprom_buffer_82599 - Read EEPROM word(s) using  *  fastest available method  *  *  @hw: pointer to hardware structure  *  @offset: offset of  word in EEPROM to read  *  @words: number of words  *  @data: word(s) read from the EEPROM  *  *  Retrieves 16 bit word(s) read from EEPROM  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_read_eeprom_buffer_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
name|words
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ixgbe_eeprom_info
modifier|*
name|eeprom
init|=
operator|&
name|hw
operator|->
name|eeprom
decl_stmt|;
name|s32
name|ret_val
init|=
name|IXGBE_ERR_CONFIG
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_read_eeprom_buffer_82599"
argument_list|)
expr_stmt|;
comment|/* 	 * If EEPROM is detected and can be addressed using 14 bits, 	 * use EERD otherwise use bit bang 	 */
if|if
condition|(
operator|(
name|eeprom
operator|->
name|type
operator|==
name|ixgbe_eeprom_spi
operator|)
operator|&&
operator|(
name|offset
operator|+
operator|(
name|words
operator|-
literal|1
operator|)
operator|<=
name|IXGBE_EERD_MAX_ADDR
operator|)
condition|)
name|ret_val
operator|=
name|ixgbe_read_eerd_buffer_generic
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|words
argument_list|,
name|data
argument_list|)
expr_stmt|;
else|else
name|ret_val
operator|=
name|ixgbe_read_eeprom_buffer_bit_bang_generic
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|words
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_read_eeprom_82599 - Read EEPROM word using  *  fastest available method  *  *  @hw: pointer to hardware structure  *  @offset: offset of  word in the EEPROM to read  *  @data: word read from the EEPROM  *  *  Reads a 16 bit word from the EEPROM  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_read_eeprom_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ixgbe_eeprom_info
modifier|*
name|eeprom
init|=
operator|&
name|hw
operator|->
name|eeprom
decl_stmt|;
name|s32
name|ret_val
init|=
name|IXGBE_ERR_CONFIG
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_read_eeprom_82599"
argument_list|)
expr_stmt|;
comment|/* 	 * If EEPROM is detected and can be addressed using 14 bits, 	 * use EERD otherwise use bit bang 	 */
if|if
condition|(
operator|(
name|eeprom
operator|->
name|type
operator|==
name|ixgbe_eeprom_spi
operator|)
operator|&&
operator|(
name|offset
operator|<=
name|IXGBE_EERD_MAX_ADDR
operator|)
condition|)
name|ret_val
operator|=
name|ixgbe_read_eerd_generic
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
else|else
name|ret_val
operator|=
name|ixgbe_read_eeprom_bit_bang_generic
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_reset_pipeline_82599 - perform pipeline reset  *  *  @hw: pointer to hardware structure  *  * Reset pipeline by asserting Restart_AN together with LMS change to ensure  * full pipeline reset.  This function assumes the SW/FW lock is held.  **/
end_comment

begin_function
name|s32
name|ixgbe_reset_pipeline_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u32
name|anlp1_reg
init|=
literal|0
decl_stmt|;
name|u32
name|i
decl_stmt|,
name|autoc_reg
decl_stmt|,
name|autoc2_reg
decl_stmt|;
comment|/* Enable link if disabled in NVM */
name|autoc2_reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC2
argument_list|)
expr_stmt|;
if|if
condition|(
name|autoc2_reg
operator|&
name|IXGBE_AUTOC2_LINK_DISABLE_MASK
condition|)
block|{
name|autoc2_reg
operator|&=
operator|~
name|IXGBE_AUTOC2_LINK_DISABLE_MASK
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC2
argument_list|,
name|autoc2_reg
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
name|autoc_reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC
argument_list|)
expr_stmt|;
name|autoc_reg
operator||=
name|IXGBE_AUTOC_AN_RESTART
expr_stmt|;
comment|/* Write AUTOC register with toggled LMS[2] bit and Restart_AN */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC
argument_list|,
name|autoc_reg
operator|^
operator|(
literal|0x4
operator|<<
name|IXGBE_AUTOC_LMS_SHIFT
operator|)
argument_list|)
expr_stmt|;
comment|/* Wait for AN to leave state 0 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|msec_delay
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|anlp1_reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ANLP1
argument_list|)
expr_stmt|;
if|if
condition|(
name|anlp1_reg
operator|&
name|IXGBE_ANLP1_AN_STATE_MASK
condition|)
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|anlp1_reg
operator|&
name|IXGBE_ANLP1_AN_STATE_MASK
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"auto negotiation not completed\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|IXGBE_ERR_RESET_FAILED
expr_stmt|;
goto|goto
name|reset_pipeline_out
goto|;
block|}
name|ret_val
operator|=
name|IXGBE_SUCCESS
expr_stmt|;
name|reset_pipeline_out
label|:
comment|/* Write AUTOC register with original LMS field and Restart_AN */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC
argument_list|,
name|autoc_reg
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_read_i2c_byte_82599 - Reads 8 bit word over I2C  *  @hw: pointer to hardware structure  *  @byte_offset: byte offset to read  *  @data: value read  *  *  Performs byte read operation to SFP module's EEPROM over I2C interface at  *  a specified device address.  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_read_i2c_byte_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|byte_offset
parameter_list|,
name|u8
name|dev_addr
parameter_list|,
name|u8
modifier|*
name|data
parameter_list|)
block|{
name|u32
name|esdp
decl_stmt|;
name|s32
name|status
decl_stmt|;
name|s32
name|timeout
init|=
literal|200
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_read_i2c_byte_82599"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|qsfp_shared_i2c_bus
operator|==
name|TRUE
condition|)
block|{
comment|/* Acquire I2C bus ownership. */
name|esdp
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|)
expr_stmt|;
name|esdp
operator||=
name|IXGBE_ESDP_SDP0
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|,
name|esdp
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
while|while
condition|(
name|timeout
condition|)
block|{
name|esdp
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|)
expr_stmt|;
if|if
condition|(
name|esdp
operator|&
name|IXGBE_ESDP_SDP1
condition|)
break|break;
name|msec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|timeout
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|timeout
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Driver can't access resource,"
literal|" acquiring I2C bus timeout.\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IXGBE_ERR_I2C
expr_stmt|;
goto|goto
name|release_i2c_access
goto|;
block|}
block|}
name|status
operator|=
name|ixgbe_read_i2c_byte_generic
argument_list|(
name|hw
argument_list|,
name|byte_offset
argument_list|,
name|dev_addr
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|release_i2c_access
label|:
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|qsfp_shared_i2c_bus
operator|==
name|TRUE
condition|)
block|{
comment|/* Release I2C bus ownership. */
name|esdp
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|)
expr_stmt|;
name|esdp
operator|&=
operator|~
name|IXGBE_ESDP_SDP0
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|,
name|esdp
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_write_i2c_byte_82599 - Writes 8 bit word over I2C  *  @hw: pointer to hardware structure  *  @byte_offset: byte offset to write  *  @data: value to write  *  *  Performs byte write operation to SFP module's EEPROM over I2C interface at  *  a specified device address.  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_write_i2c_byte_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|byte_offset
parameter_list|,
name|u8
name|dev_addr
parameter_list|,
name|u8
name|data
parameter_list|)
block|{
name|u32
name|esdp
decl_stmt|;
name|s32
name|status
decl_stmt|;
name|s32
name|timeout
init|=
literal|200
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_write_i2c_byte_82599"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|qsfp_shared_i2c_bus
operator|==
name|TRUE
condition|)
block|{
comment|/* Acquire I2C bus ownership. */
name|esdp
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|)
expr_stmt|;
name|esdp
operator||=
name|IXGBE_ESDP_SDP0
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|,
name|esdp
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
while|while
condition|(
name|timeout
condition|)
block|{
name|esdp
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|)
expr_stmt|;
if|if
condition|(
name|esdp
operator|&
name|IXGBE_ESDP_SDP1
condition|)
break|break;
name|msec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|timeout
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|timeout
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Driver can't access resource,"
literal|" acquiring I2C bus timeout.\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IXGBE_ERR_I2C
expr_stmt|;
goto|goto
name|release_i2c_access
goto|;
block|}
block|}
name|status
operator|=
name|ixgbe_write_i2c_byte_generic
argument_list|(
name|hw
argument_list|,
name|byte_offset
argument_list|,
name|dev_addr
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|release_i2c_access
label|:
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|qsfp_shared_i2c_bus
operator|==
name|TRUE
condition|)
block|{
comment|/* Release I2C bus ownership. */
name|esdp
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|)
expr_stmt|;
name|esdp
operator|&=
operator|~
name|IXGBE_ESDP_SDP0
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|,
name|esdp
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

end_unit

