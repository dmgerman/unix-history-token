begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************    Copyright (c) 2001-2012, Intel Corporation    All rights reserved.      Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are met:       1. Redistributions of source code must retain the above copyright notice,        this list of conditions and the following disclaimer.       2. Redistributions in binary form must reproduce the above copyright        notice, this list of conditions and the following disclaimer in the        documentation and/or other materials provided with the distribution.       3. Neither the name of the Intel Corporation nor the names of its        contributors may be used to endorse or promote products derived from        this software without specific prior written permission.      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  ******************************************************************************/
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_include
include|#
directive|include
file|"ixgbe_type.h"
end_include

begin_include
include|#
directive|include
file|"ixgbe_82599.h"
end_include

begin_include
include|#
directive|include
file|"ixgbe_api.h"
end_include

begin_include
include|#
directive|include
file|"ixgbe_common.h"
end_include

begin_include
include|#
directive|include
file|"ixgbe_phy.h"
end_include

begin_function_decl
specifier|static
name|s32
name|ixgbe_setup_copper_link_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
name|speed
parameter_list|,
name|bool
name|autoneg
parameter_list|,
name|bool
name|autoneg_wait_to_complete
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|ixgbe_verify_fw_version_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|ixgbe_read_eeprom_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|ixgbe_read_eeprom_buffer_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
name|words
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|ixgbe_init_mac_link_ops_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|ixgbe_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_init_mac_link_ops_82599"
argument_list|)
expr_stmt|;
comment|/* enable the laser control functions for SFP+ fiber */
if|if
condition|(
name|mac
operator|->
name|ops
operator|.
name|get_media_type
argument_list|(
name|hw
argument_list|)
operator|==
name|ixgbe_media_type_fiber
condition|)
block|{
name|mac
operator|->
name|ops
operator|.
name|disable_tx_laser
operator|=
operator|&
name|ixgbe_disable_tx_laser_multispeed_fiber
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|enable_tx_laser
operator|=
operator|&
name|ixgbe_enable_tx_laser_multispeed_fiber
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|flap_tx_laser
operator|=
operator|&
name|ixgbe_flap_tx_laser_multispeed_fiber
expr_stmt|;
block|}
else|else
block|{
name|mac
operator|->
name|ops
operator|.
name|disable_tx_laser
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|enable_tx_laser
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|flap_tx_laser
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|multispeed_fiber
condition|)
block|{
comment|/* Set up dual speed SFP+ support */
name|mac
operator|->
name|ops
operator|.
name|setup_link
operator|=
operator|&
name|ixgbe_setup_mac_link_multispeed_fiber
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ixgbe_get_media_type
argument_list|(
name|hw
argument_list|)
operator|==
name|ixgbe_media_type_backplane
operator|)
operator|&&
operator|(
name|hw
operator|->
name|phy
operator|.
name|smart_speed
operator|==
name|ixgbe_smart_speed_auto
operator|||
name|hw
operator|->
name|phy
operator|.
name|smart_speed
operator|==
name|ixgbe_smart_speed_on
operator|)
operator|&&
operator|!
name|ixgbe_verify_lesm_fw_enabled_82599
argument_list|(
name|hw
argument_list|)
condition|)
block|{
name|mac
operator|->
name|ops
operator|.
name|setup_link
operator|=
operator|&
name|ixgbe_setup_mac_link_smartspeed
expr_stmt|;
block|}
else|else
block|{
name|mac
operator|->
name|ops
operator|.
name|setup_link
operator|=
operator|&
name|ixgbe_setup_mac_link_82599
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  *  ixgbe_init_phy_ops_82599 - PHY/SFP specific init  *  @hw: pointer to hardware structure  *  *  Initialize any function pointers that were not able to be  *  set during init_shared_code because the PHY/SFP type was  *  not known.  Perform the SFP init if necessary.  *  **/
end_comment

begin_function
name|s32
name|ixgbe_init_phy_ops_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|ixgbe_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|struct
name|ixgbe_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_init_phy_ops_82599"
argument_list|)
expr_stmt|;
comment|/* Identify the PHY or SFP module */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|identify
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|==
name|IXGBE_ERR_SFP_NOT_SUPPORTED
condition|)
goto|goto
name|init_phy_ops_out
goto|;
comment|/* Setup function pointers based on detected SFP module and speeds */
name|ixgbe_init_mac_link_ops_82599
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|!=
name|ixgbe_sfp_type_unknown
condition|)
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|reset
operator|=
name|NULL
expr_stmt|;
comment|/* If copper media, overwrite with copper function pointers */
if|if
condition|(
name|mac
operator|->
name|ops
operator|.
name|get_media_type
argument_list|(
name|hw
argument_list|)
operator|==
name|ixgbe_media_type_copper
condition|)
block|{
name|mac
operator|->
name|ops
operator|.
name|setup_link
operator|=
operator|&
name|ixgbe_setup_copper_link_82599
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_link_capabilities
operator|=
operator|&
name|ixgbe_get_copper_link_capabilities_generic
expr_stmt|;
block|}
comment|/* Set necessary function pointers based on phy type */
switch|switch
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
condition|)
block|{
case|case
name|ixgbe_phy_tn
case|:
name|phy
operator|->
name|ops
operator|.
name|setup_link
operator|=
operator|&
name|ixgbe_setup_phy_link_tnx
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|check_link
operator|=
operator|&
name|ixgbe_check_phy_link_tnx
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|get_firmware_version
operator|=
operator|&
name|ixgbe_get_phy_firmware_version_tnx
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|init_phy_ops_out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_function
name|s32
name|ixgbe_setup_sfp_modules_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u32
name|reg_anlp1
init|=
literal|0
decl_stmt|;
name|u32
name|i
init|=
literal|0
decl_stmt|;
name|u16
name|list_offset
decl_stmt|,
name|data_offset
decl_stmt|,
name|data_value
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_setup_sfp_modules_82599"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|!=
name|ixgbe_sfp_type_unknown
condition|)
block|{
name|ixgbe_init_mac_link_ops_82599
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|reset
operator|=
name|NULL
expr_stmt|;
name|ret_val
operator|=
name|ixgbe_get_sfp_init_sequence_offsets
argument_list|(
name|hw
argument_list|,
operator|&
name|list_offset
argument_list|,
operator|&
name|data_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|setup_sfp_out
goto|;
comment|/* PHY config will finish before releasing the semaphore */
name|ret_val
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|acquire_swfw_sync
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR_MAC_CSR_SM
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|IXGBE_SUCCESS
condition|)
block|{
name|ret_val
operator|=
name|IXGBE_ERR_SWFW_SYNC
expr_stmt|;
goto|goto
name|setup_sfp_out
goto|;
block|}
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
operator|++
name|data_offset
argument_list|,
operator|&
name|data_value
argument_list|)
expr_stmt|;
while|while
condition|(
name|data_value
operator|!=
literal|0xffff
condition|)
block|{
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CORECTL
argument_list|,
name|data_value
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
operator|++
name|data_offset
argument_list|,
operator|&
name|data_value
argument_list|)
expr_stmt|;
block|}
comment|/* Release the semaphore */
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR_MAC_CSR_SM
argument_list|)
expr_stmt|;
comment|/* Delay obtaining semaphore again to allow FW access */
name|msec_delay
argument_list|(
name|hw
operator|->
name|eeprom
operator|.
name|semaphore_delay
argument_list|)
expr_stmt|;
comment|/* Now restart DSP by setting Restart_AN and clearing LMS */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC
argument_list|,
operator|(
operator|(
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC
argument_list|)
operator|&
operator|~
name|IXGBE_AUTOC_LMS_MASK
operator|)
operator||
name|IXGBE_AUTOC_AN_RESTART
operator|)
argument_list|)
expr_stmt|;
comment|/* Wait for AN to leave state 0 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|msec_delay
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|reg_anlp1
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ANLP1
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_anlp1
operator|&
name|IXGBE_ANLP1_AN_STATE_MASK
condition|)
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|reg_anlp1
operator|&
name|IXGBE_ANLP1_AN_STATE_MASK
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"sfp module setup not complete\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|IXGBE_ERR_SFP_SETUP_NOT_COMPLETE
expr_stmt|;
goto|goto
name|setup_sfp_out
goto|;
block|}
comment|/* Restart DSP by setting Restart_AN and return to SFI mode */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC
argument_list|,
operator|(
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC
argument_list|)
operator||
name|IXGBE_AUTOC_LMS_10G_SERIAL
operator||
name|IXGBE_AUTOC_AN_RESTART
operator|)
argument_list|)
expr_stmt|;
block|}
name|setup_sfp_out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_init_ops_82599 - Inits func ptrs and MAC type  *  @hw: pointer to hardware structure  *  *  Initialize the function pointers and assign the MAC type for 82599.  *  Does not touch the hardware.  **/
end_comment

begin_function
name|s32
name|ixgbe_init_ops_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|ixgbe_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|struct
name|ixgbe_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|struct
name|ixgbe_eeprom_info
modifier|*
name|eeprom
init|=
operator|&
name|hw
operator|->
name|eeprom
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_init_ops_82599"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|ixgbe_init_phy_ops_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|ixgbe_init_ops_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* PHY */
name|phy
operator|->
name|ops
operator|.
name|identify
operator|=
operator|&
name|ixgbe_identify_phy_82599
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|init
operator|=
operator|&
name|ixgbe_init_phy_ops_82599
expr_stmt|;
comment|/* MAC */
name|mac
operator|->
name|ops
operator|.
name|reset_hw
operator|=
operator|&
name|ixgbe_reset_hw_82599
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|enable_relaxed_ordering
operator|=
operator|&
name|ixgbe_enable_relaxed_ordering_gen2
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_media_type
operator|=
operator|&
name|ixgbe_get_media_type_82599
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_supported_physical_layer
operator|=
operator|&
name|ixgbe_get_supported_physical_layer_82599
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|disable_sec_rx_path
operator|=
operator|&
name|ixgbe_disable_sec_rx_path_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|enable_sec_rx_path
operator|=
operator|&
name|ixgbe_enable_sec_rx_path_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|enable_rx_dma
operator|=
operator|&
name|ixgbe_enable_rx_dma_82599
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|read_analog_reg8
operator|=
operator|&
name|ixgbe_read_analog_reg8_82599
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|write_analog_reg8
operator|=
operator|&
name|ixgbe_write_analog_reg8_82599
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|start_hw
operator|=
operator|&
name|ixgbe_start_hw_82599
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_san_mac_addr
operator|=
operator|&
name|ixgbe_get_san_mac_addr_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|set_san_mac_addr
operator|=
operator|&
name|ixgbe_set_san_mac_addr_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_device_caps
operator|=
operator|&
name|ixgbe_get_device_caps_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_wwn_prefix
operator|=
operator|&
name|ixgbe_get_wwn_prefix_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_fcoe_boot_status
operator|=
operator|&
name|ixgbe_get_fcoe_boot_status_generic
expr_stmt|;
comment|/* RAR, Multicast, VLAN */
name|mac
operator|->
name|ops
operator|.
name|set_vmdq
operator|=
operator|&
name|ixgbe_set_vmdq_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|set_vmdq_san_mac
operator|=
operator|&
name|ixgbe_set_vmdq_san_mac_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|clear_vmdq
operator|=
operator|&
name|ixgbe_clear_vmdq_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|insert_mac_addr
operator|=
operator|&
name|ixgbe_insert_mac_addr_generic
expr_stmt|;
name|mac
operator|->
name|rar_highwater
operator|=
literal|1
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|set_vfta
operator|=
operator|&
name|ixgbe_set_vfta_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|set_vlvf
operator|=
operator|&
name|ixgbe_set_vlvf_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|clear_vfta
operator|=
operator|&
name|ixgbe_clear_vfta_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|init_uta_tables
operator|=
operator|&
name|ixgbe_init_uta_tables_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|setup_sfp
operator|=
operator|&
name|ixgbe_setup_sfp_modules_82599
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|set_mac_anti_spoofing
operator|=
operator|&
name|ixgbe_set_mac_anti_spoofing
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|set_vlan_anti_spoofing
operator|=
operator|&
name|ixgbe_set_vlan_anti_spoofing
expr_stmt|;
comment|/* Link */
name|mac
operator|->
name|ops
operator|.
name|get_link_capabilities
operator|=
operator|&
name|ixgbe_get_link_capabilities_82599
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|check_link
operator|=
operator|&
name|ixgbe_check_mac_link_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|setup_rxpba
operator|=
operator|&
name|ixgbe_set_rxpba_generic
expr_stmt|;
name|ixgbe_init_mac_link_ops_82599
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|mac
operator|->
name|mcft_size
operator|=
literal|128
expr_stmt|;
name|mac
operator|->
name|vft_size
operator|=
literal|128
expr_stmt|;
name|mac
operator|->
name|num_rar_entries
operator|=
literal|128
expr_stmt|;
name|mac
operator|->
name|rx_pb_size
operator|=
literal|512
expr_stmt|;
name|mac
operator|->
name|max_tx_queues
operator|=
literal|128
expr_stmt|;
name|mac
operator|->
name|max_rx_queues
operator|=
literal|128
expr_stmt|;
name|mac
operator|->
name|max_msix_vectors
operator|=
name|ixgbe_get_pcie_msix_count_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|mac
operator|->
name|arc_subsystem_valid
operator|=
operator|(
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FWSM
argument_list|)
operator|&
name|IXGBE_FWSM_MODE_MASK
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|hw
operator|->
name|mbx
operator|.
name|ops
operator|.
name|init_params
operator|=
name|ixgbe_init_mbx_params_pf
expr_stmt|;
comment|/* EEPROM */
name|eeprom
operator|->
name|ops
operator|.
name|read
operator|=
operator|&
name|ixgbe_read_eeprom_82599
expr_stmt|;
name|eeprom
operator|->
name|ops
operator|.
name|read_buffer
operator|=
operator|&
name|ixgbe_read_eeprom_buffer_82599
expr_stmt|;
comment|/* Manageability interface */
name|mac
operator|->
name|ops
operator|.
name|set_fw_drv_ver
operator|=
operator|&
name|ixgbe_set_fw_drv_ver_generic
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_link_capabilities_82599 - Determines link capabilities  *  @hw: pointer to hardware structure  *  @speed: pointer to link speed  *  @negotiation: TRUE when autoneg or autotry is enabled  *  *  Determines the link capabilities by reading the AUTOC register.  **/
end_comment

begin_function
name|s32
name|ixgbe_get_link_capabilities_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
modifier|*
name|speed
parameter_list|,
name|bool
modifier|*
name|negotiation
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u32
name|autoc
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_link_capabilities_82599"
argument_list|)
expr_stmt|;
comment|/* Check if 1G SFP module. */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|==
name|ixgbe_sfp_type_1g_cu_core0
operator|||
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|==
name|ixgbe_sfp_type_1g_cu_core1
operator|||
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|==
name|ixgbe_sfp_type_1g_sx_core0
operator|||
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|==
name|ixgbe_sfp_type_1g_sx_core1
condition|)
block|{
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
operator|*
name|negotiation
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Determine link capabilities based on the stored value of AUTOC, 	 * which represents EEPROM defaults.  If AUTOC value has not 	 * been stored, use the current register values. 	 */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|orig_link_settings_stored
condition|)
name|autoc
operator|=
name|hw
operator|->
name|mac
operator|.
name|orig_autoc
expr_stmt|;
else|else
name|autoc
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|autoc
operator|&
name|IXGBE_AUTOC_LMS_MASK
condition|)
block|{
case|case
name|IXGBE_AUTOC_LMS_1G_LINK_NO_AN
case|:
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
operator|*
name|negotiation
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|IXGBE_AUTOC_LMS_10G_LINK_NO_AN
case|:
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_10GB_FULL
expr_stmt|;
operator|*
name|negotiation
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|IXGBE_AUTOC_LMS_1G_AN
case|:
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
operator|*
name|negotiation
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|IXGBE_AUTOC_LMS_10G_SERIAL
case|:
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_10GB_FULL
expr_stmt|;
operator|*
name|negotiation
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|IXGBE_AUTOC_LMS_KX4_KX_KR
case|:
case|case
name|IXGBE_AUTOC_LMS_KX4_KX_KR_1G_AN
case|:
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_UNKNOWN
expr_stmt|;
if|if
condition|(
name|autoc
operator|&
name|IXGBE_AUTOC_KR_SUPP
condition|)
operator|*
name|speed
operator||=
name|IXGBE_LINK_SPEED_10GB_FULL
expr_stmt|;
if|if
condition|(
name|autoc
operator|&
name|IXGBE_AUTOC_KX4_SUPP
condition|)
operator|*
name|speed
operator||=
name|IXGBE_LINK_SPEED_10GB_FULL
expr_stmt|;
if|if
condition|(
name|autoc
operator|&
name|IXGBE_AUTOC_KX_SUPP
condition|)
operator|*
name|speed
operator||=
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
operator|*
name|negotiation
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|IXGBE_AUTOC_LMS_KX4_KX_KR_SGMII
case|:
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_100_FULL
expr_stmt|;
if|if
condition|(
name|autoc
operator|&
name|IXGBE_AUTOC_KR_SUPP
condition|)
operator|*
name|speed
operator||=
name|IXGBE_LINK_SPEED_10GB_FULL
expr_stmt|;
if|if
condition|(
name|autoc
operator|&
name|IXGBE_AUTOC_KX4_SUPP
condition|)
operator|*
name|speed
operator||=
name|IXGBE_LINK_SPEED_10GB_FULL
expr_stmt|;
if|if
condition|(
name|autoc
operator|&
name|IXGBE_AUTOC_KX_SUPP
condition|)
operator|*
name|speed
operator||=
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
operator|*
name|negotiation
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|IXGBE_AUTOC_LMS_SGMII_1G_100M
case|:
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_1GB_FULL
operator||
name|IXGBE_LINK_SPEED_100_FULL
expr_stmt|;
operator|*
name|negotiation
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
name|status
operator|=
name|IXGBE_ERR_LINK_SETUP
expr_stmt|;
goto|goto
name|out
goto|;
break|break;
block|}
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|multispeed_fiber
condition|)
block|{
operator|*
name|speed
operator||=
name|IXGBE_LINK_SPEED_10GB_FULL
operator||
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
operator|*
name|negotiation
operator|=
name|TRUE
expr_stmt|;
block|}
name|out
label|:
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_media_type_82599 - Get media type  *  @hw: pointer to hardware structure  *  *  Returns the media type (fiber, copper, backplane)  **/
end_comment

begin_function
name|enum
name|ixgbe_media_type
name|ixgbe_get_media_type_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|enum
name|ixgbe_media_type
name|media_type
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_media_type_82599"
argument_list|)
expr_stmt|;
comment|/* Detect if there is a copper PHY attached. */
switch|switch
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
condition|)
block|{
case|case
name|ixgbe_phy_cu_unknown
case|:
case|case
name|ixgbe_phy_tn
case|:
name|media_type
operator|=
name|ixgbe_media_type_copper
expr_stmt|;
goto|goto
name|out
goto|;
default|default:
break|break;
block|}
switch|switch
condition|(
name|hw
operator|->
name|device_id
condition|)
block|{
case|case
name|IXGBE_DEV_ID_82599_KX4
case|:
case|case
name|IXGBE_DEV_ID_82599_KX4_MEZZ
case|:
case|case
name|IXGBE_DEV_ID_82599_COMBO_BACKPLANE
case|:
case|case
name|IXGBE_DEV_ID_82599_KR
case|:
case|case
name|IXGBE_DEV_ID_82599_BACKPLANE_FCOE
case|:
case|case
name|IXGBE_DEV_ID_82599_XAUI_LOM
case|:
comment|/* Default device ID is mezzanine card KX/KX4 */
name|media_type
operator|=
name|ixgbe_media_type_backplane
expr_stmt|;
break|break;
case|case
name|IXGBE_DEV_ID_82599_SFP
case|:
case|case
name|IXGBE_DEV_ID_82599_SFP_FCOE
case|:
case|case
name|IXGBE_DEV_ID_82599_SFP_EM
case|:
case|case
name|IXGBE_DEV_ID_82599_SFP_SF2
case|:
case|case
name|IXGBE_DEV_ID_82599EN_SFP
case|:
name|media_type
operator|=
name|ixgbe_media_type_fiber
expr_stmt|;
break|break;
case|case
name|IXGBE_DEV_ID_82599_CX4
case|:
name|media_type
operator|=
name|ixgbe_media_type_cx4
expr_stmt|;
break|break;
case|case
name|IXGBE_DEV_ID_82599_T3_LOM
case|:
name|media_type
operator|=
name|ixgbe_media_type_copper
expr_stmt|;
break|break;
default|default:
name|media_type
operator|=
name|ixgbe_media_type_unknown
expr_stmt|;
break|break;
block|}
name|out
label|:
return|return
name|media_type
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_start_mac_link_82599 - Setup MAC link settings  *  @hw: pointer to hardware structure  *  @autoneg_wait_to_complete: TRUE when waiting for completion is needed  *  *  Configures link settings based on values in the ixgbe_hw struct.  *  Restarts the link.  Performs autonegotiation if needed.  **/
end_comment

begin_function
name|s32
name|ixgbe_start_mac_link_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|autoneg_wait_to_complete
parameter_list|)
block|{
name|u32
name|autoc_reg
decl_stmt|;
name|u32
name|links_reg
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_start_mac_link_82599"
argument_list|)
expr_stmt|;
comment|/* Restart link */
name|autoc_reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC
argument_list|)
expr_stmt|;
name|autoc_reg
operator||=
name|IXGBE_AUTOC_AN_RESTART
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC
argument_list|,
name|autoc_reg
argument_list|)
expr_stmt|;
comment|/* Only poll for autoneg to complete if specified to do so */
if|if
condition|(
name|autoneg_wait_to_complete
condition|)
block|{
if|if
condition|(
operator|(
name|autoc_reg
operator|&
name|IXGBE_AUTOC_LMS_MASK
operator|)
operator|==
name|IXGBE_AUTOC_LMS_KX4_KX_KR
operator|||
operator|(
name|autoc_reg
operator|&
name|IXGBE_AUTOC_LMS_MASK
operator|)
operator|==
name|IXGBE_AUTOC_LMS_KX4_KX_KR_1G_AN
operator|||
operator|(
name|autoc_reg
operator|&
name|IXGBE_AUTOC_LMS_MASK
operator|)
operator|==
name|IXGBE_AUTOC_LMS_KX4_KX_KR_SGMII
condition|)
block|{
name|links_reg
operator|=
literal|0
expr_stmt|;
comment|/* Just in case Autoneg time = 0 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_AUTO_NEG_TIME
condition|;
name|i
operator|++
control|)
block|{
name|links_reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LINKS
argument_list|)
expr_stmt|;
if|if
condition|(
name|links_reg
operator|&
name|IXGBE_LINKS_KX_AN_COMP
condition|)
break|break;
name|msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|links_reg
operator|&
name|IXGBE_LINKS_KX_AN_COMP
operator|)
condition|)
block|{
name|status
operator|=
name|IXGBE_ERR_AUTONEG_NOT_COMPLETE
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Autoneg did not complete.\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Add delay to filter out noises during initial link setup */
name|msec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_disable_tx_laser_multispeed_fiber - Disable Tx laser  *  @hw: pointer to hardware structure  *  *  The base drivers may require better control over SFP+ module  *  PHY states.  This includes selectively shutting down the Tx  *  laser on the PHY, effectively halting physical link.  **/
end_comment

begin_function
name|void
name|ixgbe_disable_tx_laser_multispeed_fiber
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|esdp_reg
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|)
decl_stmt|;
comment|/* Disable tx laser; allow 100us to go dark per spec */
name|esdp_reg
operator||=
name|IXGBE_ESDP_SDP3
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|,
name|esdp_reg
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_enable_tx_laser_multispeed_fiber - Enable Tx laser  *  @hw: pointer to hardware structure  *  *  The base drivers may require better control over SFP+ module  *  PHY states.  This includes selectively turning on the Tx  *  laser on the PHY, effectively starting physical link.  **/
end_comment

begin_function
name|void
name|ixgbe_enable_tx_laser_multispeed_fiber
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|esdp_reg
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|)
decl_stmt|;
comment|/* Enable tx laser; allow 100ms to light up */
name|esdp_reg
operator|&=
operator|~
name|IXGBE_ESDP_SDP3
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|,
name|esdp_reg
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_flap_tx_laser_multispeed_fiber - Flap Tx laser  *  @hw: pointer to hardware structure  *  *  When the driver changes the link speeds that it can support,  *  it sets autotry_restart to TRUE to indicate that we need to  *  initiate a new autotry session with the link partner.  To do  *  so, we set the speed then disable and re-enable the tx laser, to  *  alert the link partner that it also needs to restart autotry on its  *  end.  This is consistent with TRUE clause 37 autoneg, which also  *  involves a loss of signal.  **/
end_comment

begin_function
name|void
name|ixgbe_flap_tx_laser_multispeed_fiber
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_flap_tx_laser_multispeed_fiber"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|autotry_restart
condition|)
block|{
name|ixgbe_disable_tx_laser_multispeed_fiber
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|ixgbe_enable_tx_laser_multispeed_fiber
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|autotry_restart
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *  ixgbe_setup_mac_link_multispeed_fiber - Set MAC link speed  *  @hw: pointer to hardware structure  *  @speed: new link speed  *  @autoneg: TRUE if autonegotiation enabled  *  @autoneg_wait_to_complete: TRUE when waiting for completion is needed  *  *  Set the link speed in the AUTOC register and restarts link.  **/
end_comment

begin_function
name|s32
name|ixgbe_setup_mac_link_multispeed_fiber
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
name|speed
parameter_list|,
name|bool
name|autoneg
parameter_list|,
name|bool
name|autoneg_wait_to_complete
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|ixgbe_link_speed
name|link_speed
init|=
name|IXGBE_LINK_SPEED_UNKNOWN
decl_stmt|;
name|ixgbe_link_speed
name|highest_link_speed
init|=
name|IXGBE_LINK_SPEED_UNKNOWN
decl_stmt|;
name|u32
name|speedcnt
init|=
literal|0
decl_stmt|;
name|u32
name|esdp_reg
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|)
decl_stmt|;
name|u32
name|i
init|=
literal|0
decl_stmt|;
name|bool
name|link_up
init|=
name|FALSE
decl_stmt|;
name|bool
name|negotiation
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_setup_mac_link_multispeed_fiber"
argument_list|)
expr_stmt|;
comment|/* Mask off requested but non-supported speeds */
name|status
operator|=
name|ixgbe_get_link_capabilities
argument_list|(
name|hw
argument_list|,
operator|&
name|link_speed
argument_list|,
operator|&
name|negotiation
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|speed
operator|&=
name|link_speed
expr_stmt|;
comment|/* 	 * Try each speed one by one, highest priority first.  We do this in 	 * software because 10gb fiber doesn't support speed autonegotiation. 	 */
if|if
condition|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_10GB_FULL
condition|)
block|{
name|speedcnt
operator|++
expr_stmt|;
name|highest_link_speed
operator|=
name|IXGBE_LINK_SPEED_10GB_FULL
expr_stmt|;
comment|/* If we already have link at this speed, just jump out */
name|status
operator|=
name|ixgbe_check_link
argument_list|(
name|hw
argument_list|,
operator|&
name|link_speed
argument_list|,
operator|&
name|link_up
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
if|if
condition|(
operator|(
name|link_speed
operator|==
name|IXGBE_LINK_SPEED_10GB_FULL
operator|)
operator|&&
name|link_up
condition|)
goto|goto
name|out
goto|;
comment|/* Set the module link speed */
name|esdp_reg
operator||=
operator|(
name|IXGBE_ESDP_SDP5_DIR
operator||
name|IXGBE_ESDP_SDP5
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|,
name|esdp_reg
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Allow module to change analog characteristics (1G->10G) */
name|msec_delay
argument_list|(
literal|40
argument_list|)
expr_stmt|;
name|status
operator|=
name|ixgbe_setup_mac_link_82599
argument_list|(
name|hw
argument_list|,
name|IXGBE_LINK_SPEED_10GB_FULL
argument_list|,
name|autoneg
argument_list|,
name|autoneg_wait_to_complete
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* Flap the tx laser if it has not already been done */
name|ixgbe_flap_tx_laser
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* 		 * Wait for the controller to acquire link.  Per IEEE 802.3ap, 		 * Section 73.10.2, we may have to wait up to 500ms if KR is 		 * attempted.  82599 uses the same timing for 10g SFI. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
comment|/* Wait for the link partner to also set speed */
name|msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* If we have link, just jump out */
name|status
operator|=
name|ixgbe_check_link
argument_list|(
name|hw
argument_list|,
operator|&
name|link_speed
argument_list|,
operator|&
name|link_up
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
if|if
condition|(
name|link_up
condition|)
goto|goto
name|out
goto|;
block|}
block|}
if|if
condition|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_1GB_FULL
condition|)
block|{
name|speedcnt
operator|++
expr_stmt|;
if|if
condition|(
name|highest_link_speed
operator|==
name|IXGBE_LINK_SPEED_UNKNOWN
condition|)
name|highest_link_speed
operator|=
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
comment|/* If we already have link at this speed, just jump out */
name|status
operator|=
name|ixgbe_check_link
argument_list|(
name|hw
argument_list|,
operator|&
name|link_speed
argument_list|,
operator|&
name|link_up
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
if|if
condition|(
operator|(
name|link_speed
operator|==
name|IXGBE_LINK_SPEED_1GB_FULL
operator|)
operator|&&
name|link_up
condition|)
goto|goto
name|out
goto|;
comment|/* Set the module link speed */
name|esdp_reg
operator|&=
operator|~
name|IXGBE_ESDP_SDP5
expr_stmt|;
name|esdp_reg
operator||=
name|IXGBE_ESDP_SDP5_DIR
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|,
name|esdp_reg
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Allow module to change analog characteristics (10G->1G) */
name|msec_delay
argument_list|(
literal|40
argument_list|)
expr_stmt|;
name|status
operator|=
name|ixgbe_setup_mac_link_82599
argument_list|(
name|hw
argument_list|,
name|IXGBE_LINK_SPEED_1GB_FULL
argument_list|,
name|autoneg
argument_list|,
name|autoneg_wait_to_complete
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* Flap the tx laser if it has not already been done */
name|ixgbe_flap_tx_laser
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Wait for the link partner to also set speed */
name|msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* If we have link, just jump out */
name|status
operator|=
name|ixgbe_check_link
argument_list|(
name|hw
argument_list|,
operator|&
name|link_speed
argument_list|,
operator|&
name|link_up
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
if|if
condition|(
name|link_up
condition|)
goto|goto
name|out
goto|;
block|}
comment|/* 	 * We didn't get link.  Configure back to the highest speed we tried, 	 * (if there was more than one).  We call ourselves back with just the 	 * single highest speed that the user requested. 	 */
if|if
condition|(
name|speedcnt
operator|>
literal|1
condition|)
name|status
operator|=
name|ixgbe_setup_mac_link_multispeed_fiber
argument_list|(
name|hw
argument_list|,
name|highest_link_speed
argument_list|,
name|autoneg
argument_list|,
name|autoneg_wait_to_complete
argument_list|)
expr_stmt|;
name|out
label|:
comment|/* Set autoneg_advertised value based on input link speed */
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_10GB_FULL
condition|)
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator||=
name|IXGBE_LINK_SPEED_10GB_FULL
expr_stmt|;
if|if
condition|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_1GB_FULL
condition|)
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator||=
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_setup_mac_link_smartspeed - Set MAC link speed using SmartSpeed  *  @hw: pointer to hardware structure  *  @speed: new link speed  *  @autoneg: TRUE if autonegotiation enabled  *  @autoneg_wait_to_complete: TRUE when waiting for completion is needed  *  *  Implements the Intel SmartSpeed algorithm.  **/
end_comment

begin_function
name|s32
name|ixgbe_setup_mac_link_smartspeed
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
name|speed
parameter_list|,
name|bool
name|autoneg
parameter_list|,
name|bool
name|autoneg_wait_to_complete
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|ixgbe_link_speed
name|link_speed
init|=
name|IXGBE_LINK_SPEED_UNKNOWN
decl_stmt|;
name|s32
name|i
decl_stmt|,
name|j
decl_stmt|;
name|bool
name|link_up
init|=
name|FALSE
decl_stmt|;
name|u32
name|autoc_reg
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC
argument_list|)
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_setup_mac_link_smartspeed"
argument_list|)
expr_stmt|;
comment|/* Set autoneg_advertised value based on input link speed */
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_10GB_FULL
condition|)
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator||=
name|IXGBE_LINK_SPEED_10GB_FULL
expr_stmt|;
if|if
condition|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_1GB_FULL
condition|)
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator||=
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
if|if
condition|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_100_FULL
condition|)
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator||=
name|IXGBE_LINK_SPEED_100_FULL
expr_stmt|;
comment|/* 	 * Implement Intel SmartSpeed algorithm.  SmartSpeed will reduce the 	 * autoneg advertisement if link is unable to be established at the 	 * highest negotiated rate.  This can sometimes happen due to integrity 	 * issues with the physical media connection. 	 */
comment|/* First, try to get link with full advertisement */
name|hw
operator|->
name|phy
operator|.
name|smart_speed_active
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|IXGBE_SMARTSPEED_MAX_RETRIES
condition|;
name|j
operator|++
control|)
block|{
name|status
operator|=
name|ixgbe_setup_mac_link_82599
argument_list|(
name|hw
argument_list|,
name|speed
argument_list|,
name|autoneg
argument_list|,
name|autoneg_wait_to_complete
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|out
goto|;
comment|/* 		 * Wait for the controller to acquire link.  Per IEEE 802.3ap, 		 * Section 73.10.2, we may have to wait up to 500ms if KR is 		 * attempted, or 200ms if KX/KX4/BX/BX4 is attempted, per 		 * Table 9 in the AN MAS. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* If we have link, just jump out */
name|status
operator|=
name|ixgbe_check_link
argument_list|(
name|hw
argument_list|,
operator|&
name|link_speed
argument_list|,
operator|&
name|link_up
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|link_up
condition|)
goto|goto
name|out
goto|;
block|}
block|}
comment|/* 	 * We didn't get link.  If we advertised KR plus one of KX4/KX 	 * (or BX4/BX), then disable KR and try again. 	 */
if|if
condition|(
operator|(
operator|(
name|autoc_reg
operator|&
name|IXGBE_AUTOC_KR_SUPP
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|autoc_reg
operator|&
name|IXGBE_AUTOC_KX4_KX_SUPP_MASK
operator|)
operator|==
literal|0
operator|)
condition|)
goto|goto
name|out
goto|;
comment|/* Turn SmartSpeed on to disable KR support */
name|hw
operator|->
name|phy
operator|.
name|smart_speed_active
operator|=
name|TRUE
expr_stmt|;
name|status
operator|=
name|ixgbe_setup_mac_link_82599
argument_list|(
name|hw
argument_list|,
name|speed
argument_list|,
name|autoneg
argument_list|,
name|autoneg_wait_to_complete
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Wait for the controller to acquire link.  600ms will allow for 	 * the AN link_fail_inhibit_timer as well for multiple cycles of 	 * parallel detect, both 10g and 1g. This allows for the maximum 	 * connect attempts as defined in the AN MAS table 73-7. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
name|msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* If we have link, just jump out */
name|status
operator|=
name|ixgbe_check_link
argument_list|(
name|hw
argument_list|,
operator|&
name|link_speed
argument_list|,
operator|&
name|link_up
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|link_up
condition|)
goto|goto
name|out
goto|;
block|}
comment|/* We didn't get link.  Turn SmartSpeed back off. */
name|hw
operator|->
name|phy
operator|.
name|smart_speed_active
operator|=
name|FALSE
expr_stmt|;
name|status
operator|=
name|ixgbe_setup_mac_link_82599
argument_list|(
name|hw
argument_list|,
name|speed
argument_list|,
name|autoneg
argument_list|,
name|autoneg_wait_to_complete
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|link_up
operator|&&
operator|(
name|link_speed
operator|==
name|IXGBE_LINK_SPEED_1GB_FULL
operator|)
condition|)
name|DEBUGOUT
argument_list|(
literal|"Smartspeed has downgraded the link speed "
literal|"from the maximum advertised\n"
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_setup_mac_link_82599 - Set MAC link speed  *  @hw: pointer to hardware structure  *  @speed: new link speed  *  @autoneg: TRUE if autonegotiation enabled  *  @autoneg_wait_to_complete: TRUE when waiting for completion is needed  *  *  Set the link speed in the AUTOC register and restarts link.  **/
end_comment

begin_function
name|s32
name|ixgbe_setup_mac_link_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
name|speed
parameter_list|,
name|bool
name|autoneg
parameter_list|,
name|bool
name|autoneg_wait_to_complete
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u32
name|autoc
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC
argument_list|)
decl_stmt|;
name|u32
name|autoc2
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC2
argument_list|)
decl_stmt|;
name|u32
name|start_autoc
init|=
name|autoc
decl_stmt|;
name|u32
name|orig_autoc
init|=
literal|0
decl_stmt|;
name|u32
name|link_mode
init|=
name|autoc
operator|&
name|IXGBE_AUTOC_LMS_MASK
decl_stmt|;
name|u32
name|pma_pmd_1g
init|=
name|autoc
operator|&
name|IXGBE_AUTOC_1G_PMA_PMD_MASK
decl_stmt|;
name|u32
name|pma_pmd_10g_serial
init|=
name|autoc2
operator|&
name|IXGBE_AUTOC2_10G_SERIAL_PMA_PMD_MASK
decl_stmt|;
name|u32
name|links_reg
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|ixgbe_link_speed
name|link_capabilities
init|=
name|IXGBE_LINK_SPEED_UNKNOWN
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_setup_mac_link_82599"
argument_list|)
expr_stmt|;
comment|/* Check to see if speed passed in is supported. */
name|status
operator|=
name|ixgbe_get_link_capabilities
argument_list|(
name|hw
argument_list|,
operator|&
name|link_capabilities
argument_list|,
operator|&
name|autoneg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|out
goto|;
name|speed
operator|&=
name|link_capabilities
expr_stmt|;
if|if
condition|(
name|speed
operator|==
name|IXGBE_LINK_SPEED_UNKNOWN
condition|)
block|{
name|status
operator|=
name|IXGBE_ERR_LINK_SETUP
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Use stored value (EEPROM defaults) of AUTOC to find KR/KX4 support*/
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|orig_link_settings_stored
condition|)
name|orig_autoc
operator|=
name|hw
operator|->
name|mac
operator|.
name|orig_autoc
expr_stmt|;
else|else
name|orig_autoc
operator|=
name|autoc
expr_stmt|;
if|if
condition|(
name|link_mode
operator|==
name|IXGBE_AUTOC_LMS_KX4_KX_KR
operator|||
name|link_mode
operator|==
name|IXGBE_AUTOC_LMS_KX4_KX_KR_1G_AN
operator|||
name|link_mode
operator|==
name|IXGBE_AUTOC_LMS_KX4_KX_KR_SGMII
condition|)
block|{
comment|/* Set KX4/KX/KR support according to speed requested */
name|autoc
operator|&=
operator|~
operator|(
name|IXGBE_AUTOC_KX4_KX_SUPP_MASK
operator||
name|IXGBE_AUTOC_KR_SUPP
operator|)
expr_stmt|;
if|if
condition|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_10GB_FULL
condition|)
block|{
if|if
condition|(
name|orig_autoc
operator|&
name|IXGBE_AUTOC_KX4_SUPP
condition|)
name|autoc
operator||=
name|IXGBE_AUTOC_KX4_SUPP
expr_stmt|;
if|if
condition|(
operator|(
name|orig_autoc
operator|&
name|IXGBE_AUTOC_KR_SUPP
operator|)
operator|&&
operator|(
name|hw
operator|->
name|phy
operator|.
name|smart_speed_active
operator|==
name|FALSE
operator|)
condition|)
name|autoc
operator||=
name|IXGBE_AUTOC_KR_SUPP
expr_stmt|;
block|}
if|if
condition|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_1GB_FULL
condition|)
name|autoc
operator||=
name|IXGBE_AUTOC_KX_SUPP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|pma_pmd_1g
operator|==
name|IXGBE_AUTOC_1G_SFI
operator|)
operator|&&
operator|(
name|link_mode
operator|==
name|IXGBE_AUTOC_LMS_1G_LINK_NO_AN
operator|||
name|link_mode
operator|==
name|IXGBE_AUTOC_LMS_1G_AN
operator|)
condition|)
block|{
comment|/* Switch from 1G SFI to 10G SFI if requested */
if|if
condition|(
operator|(
name|speed
operator|==
name|IXGBE_LINK_SPEED_10GB_FULL
operator|)
operator|&&
operator|(
name|pma_pmd_10g_serial
operator|==
name|IXGBE_AUTOC2_10G_SFI
operator|)
condition|)
block|{
name|autoc
operator|&=
operator|~
name|IXGBE_AUTOC_LMS_MASK
expr_stmt|;
name|autoc
operator||=
name|IXGBE_AUTOC_LMS_10G_SERIAL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|pma_pmd_10g_serial
operator|==
name|IXGBE_AUTOC2_10G_SFI
operator|)
operator|&&
operator|(
name|link_mode
operator|==
name|IXGBE_AUTOC_LMS_10G_SERIAL
operator|)
condition|)
block|{
comment|/* Switch from 10G SFI to 1G SFI if requested */
if|if
condition|(
operator|(
name|speed
operator|==
name|IXGBE_LINK_SPEED_1GB_FULL
operator|)
operator|&&
operator|(
name|pma_pmd_1g
operator|==
name|IXGBE_AUTOC_1G_SFI
operator|)
condition|)
block|{
name|autoc
operator|&=
operator|~
name|IXGBE_AUTOC_LMS_MASK
expr_stmt|;
if|if
condition|(
name|autoneg
condition|)
name|autoc
operator||=
name|IXGBE_AUTOC_LMS_1G_AN
expr_stmt|;
else|else
name|autoc
operator||=
name|IXGBE_AUTOC_LMS_1G_LINK_NO_AN
expr_stmt|;
block|}
block|}
if|if
condition|(
name|autoc
operator|!=
name|start_autoc
condition|)
block|{
comment|/* Restart link */
name|autoc
operator||=
name|IXGBE_AUTOC_AN_RESTART
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC
argument_list|,
name|autoc
argument_list|)
expr_stmt|;
comment|/* Only poll for autoneg to complete if specified to do so */
if|if
condition|(
name|autoneg_wait_to_complete
condition|)
block|{
if|if
condition|(
name|link_mode
operator|==
name|IXGBE_AUTOC_LMS_KX4_KX_KR
operator|||
name|link_mode
operator|==
name|IXGBE_AUTOC_LMS_KX4_KX_KR_1G_AN
operator|||
name|link_mode
operator|==
name|IXGBE_AUTOC_LMS_KX4_KX_KR_SGMII
condition|)
block|{
name|links_reg
operator|=
literal|0
expr_stmt|;
comment|/*Just in case Autoneg time=0*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_AUTO_NEG_TIME
condition|;
name|i
operator|++
control|)
block|{
name|links_reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LINKS
argument_list|)
expr_stmt|;
if|if
condition|(
name|links_reg
operator|&
name|IXGBE_LINKS_KX_AN_COMP
condition|)
break|break;
name|msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|links_reg
operator|&
name|IXGBE_LINKS_KX_AN_COMP
operator|)
condition|)
block|{
name|status
operator|=
name|IXGBE_ERR_AUTONEG_NOT_COMPLETE
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Autoneg did not complete.\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Add delay to filter out noises during initial link setup */
name|msec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
name|out
label|:
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_setup_copper_link_82599 - Set the PHY autoneg advertised field  *  @hw: pointer to hardware structure  *  @speed: new link speed  *  @autoneg: TRUE if autonegotiation enabled  *  @autoneg_wait_to_complete: TRUE if waiting is needed to complete  *  *  Restarts link on PHY and MAC based on settings passed in.  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_setup_copper_link_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
name|speed
parameter_list|,
name|bool
name|autoneg
parameter_list|,
name|bool
name|autoneg_wait_to_complete
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_setup_copper_link_82599"
argument_list|)
expr_stmt|;
comment|/* Setup the PHY according to input speed */
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|setup_link_speed
argument_list|(
name|hw
argument_list|,
name|speed
argument_list|,
name|autoneg
argument_list|,
name|autoneg_wait_to_complete
argument_list|)
expr_stmt|;
comment|/* Set up MAC */
name|ixgbe_start_mac_link_82599
argument_list|(
name|hw
argument_list|,
name|autoneg_wait_to_complete
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_reset_hw_82599 - Perform hardware reset  *  @hw: pointer to hardware structure  *  *  Resets the hardware by resetting the transmit and receive units, masks  *  and clears all interrupts, perform a PHY reset, and perform a link (MAC)  *  reset.  **/
end_comment

begin_function
name|s32
name|ixgbe_reset_hw_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|ixgbe_link_speed
name|link_speed
decl_stmt|;
name|s32
name|status
decl_stmt|;
name|u32
name|ctrl
decl_stmt|,
name|i
decl_stmt|,
name|autoc
decl_stmt|,
name|autoc2
decl_stmt|;
name|bool
name|link_up
init|=
name|FALSE
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_reset_hw_82599"
argument_list|)
expr_stmt|;
comment|/* Call adapter stop to disable tx/rx and clear interrupts */
name|status
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|stop_adapter
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|reset_hw_out
goto|;
comment|/* flush pending Tx transactions */
name|ixgbe_clear_tx_pending
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* PHY ops must be identified and initialized prior to reset */
comment|/* Identify PHY and related function pointers */
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|init
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|IXGBE_ERR_SFP_NOT_SUPPORTED
condition|)
goto|goto
name|reset_hw_out
goto|;
comment|/* Setup SFP module if there is one present. */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|sfp_setup_needed
condition|)
block|{
name|status
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|setup_sfp
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|sfp_setup_needed
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|==
name|IXGBE_ERR_SFP_NOT_SUPPORTED
condition|)
goto|goto
name|reset_hw_out
goto|;
comment|/* Reset PHY */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|reset_disable
operator|==
name|FALSE
operator|&&
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|reset
operator|!=
name|NULL
condition|)
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|reset
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|mac_reset_top
label|:
comment|/* 	 * Issue global reset to the MAC.  Needs to be SW reset if link is up. 	 * If link reset is used when link is up, it might reset the PHY when 	 * mng is using it.  If link is down or the flag to force full link 	 * reset is set, then perform link reset. 	 */
name|ctrl
operator|=
name|IXGBE_CTRL_LNK_RST
expr_stmt|;
if|if
condition|(
operator|!
name|hw
operator|->
name|force_full_reset
condition|)
block|{
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|check_link
argument_list|(
name|hw
argument_list|,
operator|&
name|link_speed
argument_list|,
operator|&
name|link_up
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_up
condition|)
name|ctrl
operator|=
name|IXGBE_CTRL_RST
expr_stmt|;
block|}
name|ctrl
operator||=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CTRL
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Poll for reset bit to self-clear indicating reset is complete */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ctrl
operator|&
name|IXGBE_CTRL_RST_MASK
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|ctrl
operator|&
name|IXGBE_CTRL_RST_MASK
condition|)
block|{
name|status
operator|=
name|IXGBE_ERR_RESET_FAILED
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Reset polling failed to complete.\n"
argument_list|)
expr_stmt|;
block|}
name|msec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
comment|/* 	 * Double resets are required for recovery from certain error 	 * conditions.  Between resets, it is necessary to stall to allow time 	 * for any pending HW events to complete. 	 */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|flags
operator|&
name|IXGBE_FLAGS_DOUBLE_RESET_REQUIRED
condition|)
block|{
name|hw
operator|->
name|mac
operator|.
name|flags
operator|&=
operator|~
name|IXGBE_FLAGS_DOUBLE_RESET_REQUIRED
expr_stmt|;
goto|goto
name|mac_reset_top
goto|;
block|}
comment|/* 	 * Store the original AUTOC/AUTOC2 values if they have not been 	 * stored off yet.  Otherwise restore the stored original 	 * values since the reset operation sets back to defaults. 	 */
name|autoc
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC
argument_list|)
expr_stmt|;
name|autoc2
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC2
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|orig_link_settings_stored
operator|==
name|FALSE
condition|)
block|{
name|hw
operator|->
name|mac
operator|.
name|orig_autoc
operator|=
name|autoc
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|orig_autoc2
operator|=
name|autoc2
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|orig_link_settings_stored
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|autoc
operator|!=
name|hw
operator|->
name|mac
operator|.
name|orig_autoc
condition|)
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC
argument_list|,
operator|(
name|hw
operator|->
name|mac
operator|.
name|orig_autoc
operator||
name|IXGBE_AUTOC_AN_RESTART
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|autoc2
operator|&
name|IXGBE_AUTOC2_UPPER_MASK
operator|)
operator|!=
operator|(
name|hw
operator|->
name|mac
operator|.
name|orig_autoc2
operator|&
name|IXGBE_AUTOC2_UPPER_MASK
operator|)
condition|)
block|{
name|autoc2
operator|&=
operator|~
name|IXGBE_AUTOC2_UPPER_MASK
expr_stmt|;
name|autoc2
operator||=
operator|(
name|hw
operator|->
name|mac
operator|.
name|orig_autoc2
operator|&
name|IXGBE_AUTOC2_UPPER_MASK
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC2
argument_list|,
name|autoc2
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Store the permanent mac address */
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|get_mac_addr
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|perm_addr
argument_list|)
expr_stmt|;
comment|/* 	 * Store MAC address from RAR0, clear receive address registers, and 	 * clear the multicast table.  Also reset num_rar_entries to 128, 	 * since we modify this value when programming the SAN MAC address. 	 */
name|hw
operator|->
name|mac
operator|.
name|num_rar_entries
operator|=
literal|128
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|init_rx_addrs
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Store the permanent SAN mac address */
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|get_san_mac_addr
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|san_addr
argument_list|)
expr_stmt|;
comment|/* Add the SAN MAC address to the RAR only if it's a valid address */
if|if
condition|(
name|ixgbe_validate_mac_addr
argument_list|(
name|hw
operator|->
name|mac
operator|.
name|san_addr
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|set_rar
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|num_rar_entries
operator|-
literal|1
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|san_addr
argument_list|,
literal|0
argument_list|,
name|IXGBE_RAH_AV
argument_list|)
expr_stmt|;
comment|/* Save the SAN MAC RAR index */
name|hw
operator|->
name|mac
operator|.
name|san_mac_rar_index
operator|=
name|hw
operator|->
name|mac
operator|.
name|num_rar_entries
operator|-
literal|1
expr_stmt|;
comment|/* Reserve the last RAR for the SAN MAC address */
name|hw
operator|->
name|mac
operator|.
name|num_rar_entries
operator|--
expr_stmt|;
block|}
comment|/* Store the alternative WWNN/WWPN prefix */
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|get_wwn_prefix
argument_list|(
name|hw
argument_list|,
operator|&
name|hw
operator|->
name|mac
operator|.
name|wwnn_prefix
argument_list|,
operator|&
name|hw
operator|->
name|mac
operator|.
name|wwpn_prefix
argument_list|)
expr_stmt|;
name|reset_hw_out
label|:
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_reinit_fdir_tables_82599 - Reinitialize Flow Director tables.  *  @hw: pointer to hardware structure  **/
end_comment

begin_function
name|s32
name|ixgbe_reinit_fdir_tables_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u32
name|fdirctrl
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRCTRL
argument_list|)
decl_stmt|;
name|fdirctrl
operator|&=
operator|~
name|IXGBE_FDIRCTRL_INIT_DONE
expr_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_reinit_fdir_tables_82599"
argument_list|)
expr_stmt|;
comment|/* 	 * Before starting reinitialization process, 	 * FDIRCMD.CMD must be zero. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_FDIRCMD_CMD_POLL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRCMD
argument_list|)
operator|&
name|IXGBE_FDIRCMD_CMD_MASK
operator|)
condition|)
break|break;
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>=
name|IXGBE_FDIRCMD_CMD_POLL
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Flow Director previous command isn't complete, "
literal|"aborting table re-initialization.\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_FDIR_REINIT_FAILED
return|;
block|}
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRFREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* 	 * 82599 adapters flow director init flow cannot be restarted, 	 * Workaround 82599 silicon errata by performing the following steps 	 * before re-writing the FDIRCTRL control register with the same value. 	 * - write 1 to bit 8 of FDIRCMD register& 	 * - write 0 to bit 8 of FDIRCMD register 	 */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRCMD
argument_list|,
operator|(
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRCMD
argument_list|)
operator||
name|IXGBE_FDIRCMD_CLEARHT
operator|)
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRCMD
argument_list|,
operator|(
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRCMD
argument_list|)
operator|&
operator|~
name|IXGBE_FDIRCMD_CLEARHT
operator|)
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* 	 * Clear FDIR Hash register to clear any leftover hashes 	 * waiting to be programmed. 	 */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRHASH
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRCTRL
argument_list|,
name|fdirctrl
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Poll init-done after we write FDIRCTRL register */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_FDIR_INIT_DONE_POLL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRCTRL
argument_list|)
operator|&
name|IXGBE_FDIRCTRL_INIT_DONE
condition|)
break|break;
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>=
name|IXGBE_FDIR_INIT_DONE_POLL
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Flow Director Signature poll time exceeded!\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_FDIR_REINIT_FAILED
return|;
block|}
comment|/* Clear FDIR statistics registers (read to clear) */
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRUSTAT
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRFSTAT
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRMATCH
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRMISS
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRLEN
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_fdir_enable_82599 - Initialize Flow Director control registers  *  @hw: pointer to hardware structure  *  @fdirctrl: value to write to flow director control register  **/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_fdir_enable_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|fdirctrl
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_fdir_enable_82599"
argument_list|)
expr_stmt|;
comment|/* Prime the keys for hashing */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRHKEY
argument_list|,
name|IXGBE_ATR_BUCKET_HASH_KEY
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRSKEY
argument_list|,
name|IXGBE_ATR_SIGNATURE_HASH_KEY
argument_list|)
expr_stmt|;
comment|/* 	 * Poll init-done after we write the register.  Estimated times: 	 *      10G: PBALLOC = 11b, timing is 60us 	 *       1G: PBALLOC = 11b, timing is 600us 	 *     100M: PBALLOC = 11b, timing is 6ms 	 * 	 *     Multiple these timings by 4 if under full Rx load 	 * 	 * So we'll poll for IXGBE_FDIR_INIT_DONE_POLL times, sleeping for 	 * 1 msec per poll time.  If we're at line rate and drop to 100M, then 	 * this might not finish in our poll time, but we can live with that 	 * for now. 	 */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRCTRL
argument_list|,
name|fdirctrl
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_FDIR_INIT_DONE_POLL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRCTRL
argument_list|)
operator|&
name|IXGBE_FDIRCTRL_INIT_DONE
condition|)
break|break;
name|msec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>=
name|IXGBE_FDIR_INIT_DONE_POLL
condition|)
name|DEBUGOUT
argument_list|(
literal|"Flow Director poll time exceeded!\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_init_fdir_signature_82599 - Initialize Flow Director signature filters  *  @hw: pointer to hardware structure  *  @fdirctrl: value to write to flow director control register, initially  *	     contains just the value of the Rx packet buffer allocation  **/
end_comment

begin_function
name|s32
name|ixgbe_init_fdir_signature_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|fdirctrl
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_init_fdir_signature_82599"
argument_list|)
expr_stmt|;
comment|/* 	 * Continue setup of fdirctrl register bits: 	 *  Move the flexible bytes to use the ethertype - shift 6 words 	 *  Set the maximum length per hash bucket to 0xA filters 	 *  Send interrupt when 64 filters are left 	 */
name|fdirctrl
operator||=
operator|(
literal|0x6
operator|<<
name|IXGBE_FDIRCTRL_FLEX_SHIFT
operator|)
operator||
operator|(
literal|0xA
operator|<<
name|IXGBE_FDIRCTRL_MAX_LENGTH_SHIFT
operator|)
operator||
operator|(
literal|4
operator|<<
name|IXGBE_FDIRCTRL_FULL_THRESH_SHIFT
operator|)
expr_stmt|;
comment|/* write hashes and fdirctrl register, poll for completion */
name|ixgbe_fdir_enable_82599
argument_list|(
name|hw
argument_list|,
name|fdirctrl
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_init_fdir_perfect_82599 - Initialize Flow Director perfect filters  *  @hw: pointer to hardware structure  *  @fdirctrl: value to write to flow director control register, initially  *	     contains just the value of the Rx packet buffer allocation  **/
end_comment

begin_function
name|s32
name|ixgbe_init_fdir_perfect_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|fdirctrl
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_init_fdir_perfect_82599"
argument_list|)
expr_stmt|;
comment|/* 	 * Continue setup of fdirctrl register bits: 	 *  Turn perfect match filtering on 	 *  Report hash in RSS field of Rx wb descriptor 	 *  Initialize the drop queue 	 *  Move the flexible bytes to use the ethertype - shift 6 words 	 *  Set the maximum length per hash bucket to 0xA filters 	 *  Send interrupt when 64 (0x4 * 16) filters are left 	 */
name|fdirctrl
operator||=
name|IXGBE_FDIRCTRL_PERFECT_MATCH
operator||
name|IXGBE_FDIRCTRL_REPORT_STATUS
operator||
operator|(
name|IXGBE_FDIR_DROP_QUEUE
operator|<<
name|IXGBE_FDIRCTRL_DROP_Q_SHIFT
operator|)
operator||
operator|(
literal|0x6
operator|<<
name|IXGBE_FDIRCTRL_FLEX_SHIFT
operator|)
operator||
operator|(
literal|0xA
operator|<<
name|IXGBE_FDIRCTRL_MAX_LENGTH_SHIFT
operator|)
operator||
operator|(
literal|4
operator|<<
name|IXGBE_FDIRCTRL_FULL_THRESH_SHIFT
operator|)
expr_stmt|;
comment|/* write hashes and fdirctrl register, poll for completion */
name|ixgbe_fdir_enable_82599
argument_list|(
name|hw
argument_list|,
name|fdirctrl
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*  * These defines allow us to quickly generate all of the necessary instructions  * in the function below by simply calling out IXGBE_COMPUTE_SIG_HASH_ITERATION  * for values 0 through 15  */
end_comment

begin_define
define|#
directive|define
name|IXGBE_ATR_COMMON_HASH_KEY
define|\
value|(IXGBE_ATR_BUCKET_HASH_KEY& IXGBE_ATR_SIGNATURE_HASH_KEY)
end_define

begin_define
define|#
directive|define
name|IXGBE_COMPUTE_SIG_HASH_ITERATION
parameter_list|(
name|_n
parameter_list|)
define|\
value|do { \ 	u32 n = (_n); \ 	if (IXGBE_ATR_COMMON_HASH_KEY& (0x01<< n)) \ 		common_hash ^= lo_hash_dword>> n; \ 	else if (IXGBE_ATR_BUCKET_HASH_KEY& (0x01<< n)) \ 		bucket_hash ^= lo_hash_dword>> n; \ 	else if (IXGBE_ATR_SIGNATURE_HASH_KEY& (0x01<< n)) \ 		sig_hash ^= lo_hash_dword<< (16 - n); \ 	if (IXGBE_ATR_COMMON_HASH_KEY& (0x01<< (n + 16))) \ 		common_hash ^= hi_hash_dword>> n; \ 	else if (IXGBE_ATR_BUCKET_HASH_KEY& (0x01<< (n + 16))) \ 		bucket_hash ^= hi_hash_dword>> n; \ 	else if (IXGBE_ATR_SIGNATURE_HASH_KEY& (0x01<< (n + 16))) \ 		sig_hash ^= hi_hash_dword<< (16 - n); \ } while (0);
end_define

begin_comment
comment|/**  *  ixgbe_atr_compute_sig_hash_82599 - Compute the signature hash  *  @stream: input bitstream to compute the hash on  *  *  This function is almost identical to the function above but contains  *  several optomizations such as unwinding all of the loops, letting the  *  compiler work out all of the conditional ifs since the keys are static  *  defines, and computing two keys at once since the hashed dword stream  *  will be the same for both keys.  **/
end_comment

begin_function
name|u32
name|ixgbe_atr_compute_sig_hash_82599
parameter_list|(
name|union
name|ixgbe_atr_hash_dword
name|input
parameter_list|,
name|union
name|ixgbe_atr_hash_dword
name|common
parameter_list|)
block|{
name|u32
name|hi_hash_dword
decl_stmt|,
name|lo_hash_dword
decl_stmt|,
name|flow_vm_vlan
decl_stmt|;
name|u32
name|sig_hash
init|=
literal|0
decl_stmt|,
name|bucket_hash
init|=
literal|0
decl_stmt|,
name|common_hash
init|=
literal|0
decl_stmt|;
comment|/* record the flow_vm_vlan bits as they are a key part to the hash */
name|flow_vm_vlan
operator|=
name|IXGBE_NTOHL
argument_list|(
name|input
operator|.
name|dword
argument_list|)
expr_stmt|;
comment|/* generate common hash dword */
name|hi_hash_dword
operator|=
name|IXGBE_NTOHL
argument_list|(
name|common
operator|.
name|dword
argument_list|)
expr_stmt|;
comment|/* low dword is word swapped version of common */
name|lo_hash_dword
operator|=
operator|(
name|hi_hash_dword
operator|>>
literal|16
operator|)
operator||
operator|(
name|hi_hash_dword
operator|<<
literal|16
operator|)
expr_stmt|;
comment|/* apply flow ID/VM pool/VLAN ID bits to hash words */
name|hi_hash_dword
operator|^=
name|flow_vm_vlan
operator|^
operator|(
name|flow_vm_vlan
operator|>>
literal|16
operator|)
expr_stmt|;
comment|/* Process bits 0 and 16 */
name|IXGBE_COMPUTE_SIG_HASH_ITERATION
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * apply flow ID/VM pool/VLAN ID bits to lo hash dword, we had to 	 * delay this because bit 0 of the stream should not be processed 	 * so we do not add the vlan until after bit 0 was processed 	 */
name|lo_hash_dword
operator|^=
name|flow_vm_vlan
operator|^
operator|(
name|flow_vm_vlan
operator|<<
literal|16
operator|)
expr_stmt|;
comment|/* Process remaining 30 bit of the key */
name|IXGBE_COMPUTE_SIG_HASH_ITERATION
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|IXGBE_COMPUTE_SIG_HASH_ITERATION
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|IXGBE_COMPUTE_SIG_HASH_ITERATION
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|IXGBE_COMPUTE_SIG_HASH_ITERATION
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|IXGBE_COMPUTE_SIG_HASH_ITERATION
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|IXGBE_COMPUTE_SIG_HASH_ITERATION
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|IXGBE_COMPUTE_SIG_HASH_ITERATION
argument_list|(
literal|7
argument_list|)
expr_stmt|;
name|IXGBE_COMPUTE_SIG_HASH_ITERATION
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|IXGBE_COMPUTE_SIG_HASH_ITERATION
argument_list|(
literal|9
argument_list|)
expr_stmt|;
name|IXGBE_COMPUTE_SIG_HASH_ITERATION
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|IXGBE_COMPUTE_SIG_HASH_ITERATION
argument_list|(
literal|11
argument_list|)
expr_stmt|;
name|IXGBE_COMPUTE_SIG_HASH_ITERATION
argument_list|(
literal|12
argument_list|)
expr_stmt|;
name|IXGBE_COMPUTE_SIG_HASH_ITERATION
argument_list|(
literal|13
argument_list|)
expr_stmt|;
name|IXGBE_COMPUTE_SIG_HASH_ITERATION
argument_list|(
literal|14
argument_list|)
expr_stmt|;
name|IXGBE_COMPUTE_SIG_HASH_ITERATION
argument_list|(
literal|15
argument_list|)
expr_stmt|;
comment|/* combine common_hash result with signature and bucket hashes */
name|bucket_hash
operator|^=
name|common_hash
expr_stmt|;
name|bucket_hash
operator|&=
name|IXGBE_ATR_HASH_MASK
expr_stmt|;
name|sig_hash
operator|^=
name|common_hash
operator|<<
literal|16
expr_stmt|;
name|sig_hash
operator|&=
name|IXGBE_ATR_HASH_MASK
operator|<<
literal|16
expr_stmt|;
comment|/* return completed signature hash */
return|return
name|sig_hash
operator|^
name|bucket_hash
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_atr_add_signature_filter_82599 - Adds a signature hash filter  *  @hw: pointer to hardware structure  *  @input: unique input dword  *  @common: compressed common input dword  *  @queue: queue index to direct traffic to  **/
end_comment

begin_function
name|s32
name|ixgbe_fdir_add_signature_filter_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|union
name|ixgbe_atr_hash_dword
name|input
parameter_list|,
name|union
name|ixgbe_atr_hash_dword
name|common
parameter_list|,
name|u8
name|queue
parameter_list|)
block|{
name|u64
name|fdirhashcmd
decl_stmt|;
name|u32
name|fdircmd
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_fdir_add_signature_filter_82599"
argument_list|)
expr_stmt|;
comment|/* 	 * Get the flow_type in order to program FDIRCMD properly 	 * lowest 2 bits are FDIRCMD.L4TYPE, third lowest bit is FDIRCMD.IPV6 	 */
switch|switch
condition|(
name|input
operator|.
name|formatted
operator|.
name|flow_type
condition|)
block|{
case|case
name|IXGBE_ATR_FLOW_TYPE_TCPV4
case|:
case|case
name|IXGBE_ATR_FLOW_TYPE_UDPV4
case|:
case|case
name|IXGBE_ATR_FLOW_TYPE_SCTPV4
case|:
case|case
name|IXGBE_ATR_FLOW_TYPE_TCPV6
case|:
case|case
name|IXGBE_ATR_FLOW_TYPE_UDPV6
case|:
case|case
name|IXGBE_ATR_FLOW_TYPE_SCTPV6
case|:
break|break;
default|default:
name|DEBUGOUT
argument_list|(
literal|" Error on flow type input\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_CONFIG
return|;
block|}
comment|/* configure FDIRCMD register */
name|fdircmd
operator|=
name|IXGBE_FDIRCMD_CMD_ADD_FLOW
operator||
name|IXGBE_FDIRCMD_FILTER_UPDATE
operator||
name|IXGBE_FDIRCMD_LAST
operator||
name|IXGBE_FDIRCMD_QUEUE_EN
expr_stmt|;
name|fdircmd
operator||=
name|input
operator|.
name|formatted
operator|.
name|flow_type
operator|<<
name|IXGBE_FDIRCMD_FLOW_TYPE_SHIFT
expr_stmt|;
name|fdircmd
operator||=
operator|(
name|u32
operator|)
name|queue
operator|<<
name|IXGBE_FDIRCMD_RX_QUEUE_SHIFT
expr_stmt|;
comment|/* 	 * The lower 32-bits of fdirhashcmd is for FDIRHASH, the upper 32-bits 	 * is for FDIRCMD.  Then do a 64-bit register write from FDIRHASH. 	 */
name|fdirhashcmd
operator|=
operator|(
name|u64
operator|)
name|fdircmd
operator|<<
literal|32
expr_stmt|;
name|fdirhashcmd
operator||=
name|ixgbe_atr_compute_sig_hash_82599
argument_list|(
name|input
argument_list|,
name|common
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG64
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRHASH
argument_list|,
name|fdirhashcmd
argument_list|)
expr_stmt|;
name|DEBUGOUT2
argument_list|(
literal|"Tx Queue=%x hash=%x\n"
argument_list|,
name|queue
argument_list|,
operator|(
name|u32
operator|)
name|fdirhashcmd
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_define
define|#
directive|define
name|IXGBE_COMPUTE_BKT_HASH_ITERATION
parameter_list|(
name|_n
parameter_list|)
define|\
value|do { \ 	u32 n = (_n); \ 	if (IXGBE_ATR_BUCKET_HASH_KEY& (0x01<< n)) \ 		bucket_hash ^= lo_hash_dword>> n; \ 	if (IXGBE_ATR_BUCKET_HASH_KEY& (0x01<< (n + 16))) \ 		bucket_hash ^= hi_hash_dword>> n; \ } while (0);
end_define

begin_comment
comment|/**  *  ixgbe_atr_compute_perfect_hash_82599 - Compute the perfect filter hash  *  @atr_input: input bitstream to compute the hash on  *  @input_mask: mask for the input bitstream  *  *  This function serves two main purposes.  First it applys the input_mask  *  to the atr_input resulting in a cleaned up atr_input data stream.  *  Secondly it computes the hash and stores it in the bkt_hash field at  *  the end of the input byte stream.  This way it will be available for  *  future use without needing to recompute the hash.  **/
end_comment

begin_function
name|void
name|ixgbe_atr_compute_perfect_hash_82599
parameter_list|(
name|union
name|ixgbe_atr_input
modifier|*
name|input
parameter_list|,
name|union
name|ixgbe_atr_input
modifier|*
name|input_mask
parameter_list|)
block|{
name|u32
name|hi_hash_dword
decl_stmt|,
name|lo_hash_dword
decl_stmt|,
name|flow_vm_vlan
decl_stmt|;
name|u32
name|bucket_hash
init|=
literal|0
decl_stmt|;
comment|/* Apply masks to input data */
name|input
operator|->
name|dword_stream
index|[
literal|0
index|]
operator|&=
name|input_mask
operator|->
name|dword_stream
index|[
literal|0
index|]
expr_stmt|;
name|input
operator|->
name|dword_stream
index|[
literal|1
index|]
operator|&=
name|input_mask
operator|->
name|dword_stream
index|[
literal|1
index|]
expr_stmt|;
name|input
operator|->
name|dword_stream
index|[
literal|2
index|]
operator|&=
name|input_mask
operator|->
name|dword_stream
index|[
literal|2
index|]
expr_stmt|;
name|input
operator|->
name|dword_stream
index|[
literal|3
index|]
operator|&=
name|input_mask
operator|->
name|dword_stream
index|[
literal|3
index|]
expr_stmt|;
name|input
operator|->
name|dword_stream
index|[
literal|4
index|]
operator|&=
name|input_mask
operator|->
name|dword_stream
index|[
literal|4
index|]
expr_stmt|;
name|input
operator|->
name|dword_stream
index|[
literal|5
index|]
operator|&=
name|input_mask
operator|->
name|dword_stream
index|[
literal|5
index|]
expr_stmt|;
name|input
operator|->
name|dword_stream
index|[
literal|6
index|]
operator|&=
name|input_mask
operator|->
name|dword_stream
index|[
literal|6
index|]
expr_stmt|;
name|input
operator|->
name|dword_stream
index|[
literal|7
index|]
operator|&=
name|input_mask
operator|->
name|dword_stream
index|[
literal|7
index|]
expr_stmt|;
name|input
operator|->
name|dword_stream
index|[
literal|8
index|]
operator|&=
name|input_mask
operator|->
name|dword_stream
index|[
literal|8
index|]
expr_stmt|;
name|input
operator|->
name|dword_stream
index|[
literal|9
index|]
operator|&=
name|input_mask
operator|->
name|dword_stream
index|[
literal|9
index|]
expr_stmt|;
name|input
operator|->
name|dword_stream
index|[
literal|10
index|]
operator|&=
name|input_mask
operator|->
name|dword_stream
index|[
literal|10
index|]
expr_stmt|;
comment|/* record the flow_vm_vlan bits as they are a key part to the hash */
name|flow_vm_vlan
operator|=
name|IXGBE_NTOHL
argument_list|(
name|input
operator|->
name|dword_stream
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* generate common hash dword */
name|hi_hash_dword
operator|=
name|IXGBE_NTOHL
argument_list|(
name|input
operator|->
name|dword_stream
index|[
literal|1
index|]
operator|^
name|input
operator|->
name|dword_stream
index|[
literal|2
index|]
operator|^
name|input
operator|->
name|dword_stream
index|[
literal|3
index|]
operator|^
name|input
operator|->
name|dword_stream
index|[
literal|4
index|]
operator|^
name|input
operator|->
name|dword_stream
index|[
literal|5
index|]
operator|^
name|input
operator|->
name|dword_stream
index|[
literal|6
index|]
operator|^
name|input
operator|->
name|dword_stream
index|[
literal|7
index|]
operator|^
name|input
operator|->
name|dword_stream
index|[
literal|8
index|]
operator|^
name|input
operator|->
name|dword_stream
index|[
literal|9
index|]
operator|^
name|input
operator|->
name|dword_stream
index|[
literal|10
index|]
argument_list|)
expr_stmt|;
comment|/* low dword is word swapped version of common */
name|lo_hash_dword
operator|=
operator|(
name|hi_hash_dword
operator|>>
literal|16
operator|)
operator||
operator|(
name|hi_hash_dword
operator|<<
literal|16
operator|)
expr_stmt|;
comment|/* apply flow ID/VM pool/VLAN ID bits to hash words */
name|hi_hash_dword
operator|^=
name|flow_vm_vlan
operator|^
operator|(
name|flow_vm_vlan
operator|>>
literal|16
operator|)
expr_stmt|;
comment|/* Process bits 0 and 16 */
name|IXGBE_COMPUTE_BKT_HASH_ITERATION
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * apply flow ID/VM pool/VLAN ID bits to lo hash dword, we had to 	 * delay this because bit 0 of the stream should not be processed 	 * so we do not add the vlan until after bit 0 was processed 	 */
name|lo_hash_dword
operator|^=
name|flow_vm_vlan
operator|^
operator|(
name|flow_vm_vlan
operator|<<
literal|16
operator|)
expr_stmt|;
comment|/* Process remaining 30 bit of the key */
name|IXGBE_COMPUTE_BKT_HASH_ITERATION
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|IXGBE_COMPUTE_BKT_HASH_ITERATION
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|IXGBE_COMPUTE_BKT_HASH_ITERATION
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|IXGBE_COMPUTE_BKT_HASH_ITERATION
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|IXGBE_COMPUTE_BKT_HASH_ITERATION
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|IXGBE_COMPUTE_BKT_HASH_ITERATION
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|IXGBE_COMPUTE_BKT_HASH_ITERATION
argument_list|(
literal|7
argument_list|)
expr_stmt|;
name|IXGBE_COMPUTE_BKT_HASH_ITERATION
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|IXGBE_COMPUTE_BKT_HASH_ITERATION
argument_list|(
literal|9
argument_list|)
expr_stmt|;
name|IXGBE_COMPUTE_BKT_HASH_ITERATION
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|IXGBE_COMPUTE_BKT_HASH_ITERATION
argument_list|(
literal|11
argument_list|)
expr_stmt|;
name|IXGBE_COMPUTE_BKT_HASH_ITERATION
argument_list|(
literal|12
argument_list|)
expr_stmt|;
name|IXGBE_COMPUTE_BKT_HASH_ITERATION
argument_list|(
literal|13
argument_list|)
expr_stmt|;
name|IXGBE_COMPUTE_BKT_HASH_ITERATION
argument_list|(
literal|14
argument_list|)
expr_stmt|;
name|IXGBE_COMPUTE_BKT_HASH_ITERATION
argument_list|(
literal|15
argument_list|)
expr_stmt|;
comment|/* 	 * Limit hash to 13 bits since max bucket count is 8K. 	 * Store result at the end of the input stream. 	 */
name|input
operator|->
name|formatted
operator|.
name|bkt_hash
operator|=
name|bucket_hash
operator|&
literal|0x1FFF
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_fdirtcpm_82599 - generate a tcp port from atr_input_masks  *  @input_mask: mask to be bit swapped  *  *  The source and destination port masks for flow director are bit swapped  *  in that bit 15 effects bit 0, 14 effects 1, 13, 2 etc.  In order to  *  generate a correctly swapped value we need to bit swap the mask and that  *  is what is accomplished by this function.  **/
end_comment

begin_function
specifier|static
name|u32
name|ixgbe_get_fdirtcpm_82599
parameter_list|(
name|union
name|ixgbe_atr_input
modifier|*
name|input_mask
parameter_list|)
block|{
name|u32
name|mask
init|=
name|IXGBE_NTOHS
argument_list|(
name|input_mask
operator|->
name|formatted
operator|.
name|dst_port
argument_list|)
decl_stmt|;
name|mask
operator|<<=
name|IXGBE_FDIRTCPM_DPORTM_SHIFT
expr_stmt|;
name|mask
operator||=
name|IXGBE_NTOHS
argument_list|(
name|input_mask
operator|->
name|formatted
operator|.
name|src_port
argument_list|)
expr_stmt|;
name|mask
operator|=
operator|(
operator|(
name|mask
operator|&
literal|0x55555555
operator|)
operator|<<
literal|1
operator|)
operator||
operator|(
operator|(
name|mask
operator|&
literal|0xAAAAAAAA
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
name|mask
operator|=
operator|(
operator|(
name|mask
operator|&
literal|0x33333333
operator|)
operator|<<
literal|2
operator|)
operator||
operator|(
operator|(
name|mask
operator|&
literal|0xCCCCCCCC
operator|)
operator|>>
literal|2
operator|)
expr_stmt|;
name|mask
operator|=
operator|(
operator|(
name|mask
operator|&
literal|0x0F0F0F0F
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
name|mask
operator|&
literal|0xF0F0F0F0
operator|)
operator|>>
literal|4
operator|)
expr_stmt|;
return|return
operator|(
operator|(
name|mask
operator|&
literal|0x00FF00FF
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|mask
operator|&
literal|0xFF00FF00
operator|)
operator|>>
literal|8
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * These two macros are meant to address the fact that we have registers  * that are either all or in part big-endian.  As a result on big-endian  * systems we will end up byte swapping the value to little-endian before  * it is byte swapped again and written to the hardware in the original  * big-endian format.  */
end_comment

begin_define
define|#
directive|define
name|IXGBE_STORE_AS_BE32
parameter_list|(
name|_value
parameter_list|)
define|\
value|(((u32)(_value)>> 24) | (((u32)(_value)& 0x00FF0000)>> 8) | \ 	 (((u32)(_value)& 0x0000FF00)<< 8) | ((u32)(_value)<< 24))
end_define

begin_define
define|#
directive|define
name|IXGBE_WRITE_REG_BE32
parameter_list|(
name|a
parameter_list|,
name|reg
parameter_list|,
name|value
parameter_list|)
define|\
value|IXGBE_WRITE_REG((a), (reg), IXGBE_STORE_AS_BE32(IXGBE_NTOHL(value)))
end_define

begin_define
define|#
directive|define
name|IXGBE_STORE_AS_BE16
parameter_list|(
name|_value
parameter_list|)
define|\
value|IXGBE_NTOHS(((u16)(_value)>> 8) | ((u16)(_value)<< 8))
end_define

begin_function
name|s32
name|ixgbe_fdir_set_input_mask_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|union
name|ixgbe_atr_input
modifier|*
name|input_mask
parameter_list|)
block|{
comment|/* mask IPv6 since it is currently not supported */
name|u32
name|fdirm
init|=
name|IXGBE_FDIRM_DIPv6
decl_stmt|;
name|u32
name|fdirtcpm
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_fdir_set_atr_input_mask_82599"
argument_list|)
expr_stmt|;
comment|/* 	 * Program the relevant mask registers.  If src/dst_port or src/dst_addr 	 * are zero, then assume a full mask for that field.  Also assume that 	 * a VLAN of 0 is unspecified, so mask that out as well.  L4type 	 * cannot be masked out in this implementation. 	 * 	 * This also assumes IPv4 only.  IPv6 masking isn't supported at this 	 * point in time. 	 */
comment|/* verify bucket hash is cleared on hash generation */
if|if
condition|(
name|input_mask
operator|->
name|formatted
operator|.
name|bkt_hash
condition|)
name|DEBUGOUT
argument_list|(
literal|" bucket hash should always be 0 in mask\n"
argument_list|)
expr_stmt|;
comment|/* Program FDIRM and verify partial masks */
switch|switch
condition|(
name|input_mask
operator|->
name|formatted
operator|.
name|vm_pool
operator|&
literal|0x7F
condition|)
block|{
case|case
literal|0x0
case|:
name|fdirm
operator||=
name|IXGBE_FDIRM_POOL
expr_stmt|;
case|case
literal|0x7F
case|:
break|break;
default|default:
name|DEBUGOUT
argument_list|(
literal|" Error on vm pool mask\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_CONFIG
return|;
block|}
switch|switch
condition|(
name|input_mask
operator|->
name|formatted
operator|.
name|flow_type
operator|&
name|IXGBE_ATR_L4TYPE_MASK
condition|)
block|{
case|case
literal|0x0
case|:
name|fdirm
operator||=
name|IXGBE_FDIRM_L4P
expr_stmt|;
if|if
condition|(
name|input_mask
operator|->
name|formatted
operator|.
name|dst_port
operator|||
name|input_mask
operator|->
name|formatted
operator|.
name|src_port
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|" Error on src/dst port mask\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_CONFIG
return|;
block|}
case|case
name|IXGBE_ATR_L4TYPE_MASK
case|:
break|break;
default|default:
name|DEBUGOUT
argument_list|(
literal|" Error on flow type mask\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_CONFIG
return|;
block|}
switch|switch
condition|(
name|IXGBE_NTOHS
argument_list|(
name|input_mask
operator|->
name|formatted
operator|.
name|vlan_id
argument_list|)
operator|&
literal|0xEFFF
condition|)
block|{
case|case
literal|0x0000
case|:
comment|/* mask VLAN ID, fall through to mask VLAN priority */
name|fdirm
operator||=
name|IXGBE_FDIRM_VLANID
expr_stmt|;
case|case
literal|0x0FFF
case|:
comment|/* mask VLAN priority */
name|fdirm
operator||=
name|IXGBE_FDIRM_VLANP
expr_stmt|;
break|break;
case|case
literal|0xE000
case|:
comment|/* mask VLAN ID only, fall through */
name|fdirm
operator||=
name|IXGBE_FDIRM_VLANID
expr_stmt|;
case|case
literal|0xEFFF
case|:
comment|/* no VLAN fields masked */
break|break;
default|default:
name|DEBUGOUT
argument_list|(
literal|" Error on VLAN mask\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_CONFIG
return|;
block|}
switch|switch
condition|(
name|input_mask
operator|->
name|formatted
operator|.
name|flex_bytes
operator|&
literal|0xFFFF
condition|)
block|{
case|case
literal|0x0000
case|:
comment|/* Mask Flex Bytes, fall through */
name|fdirm
operator||=
name|IXGBE_FDIRM_FLEX
expr_stmt|;
case|case
literal|0xFFFF
case|:
break|break;
default|default:
name|DEBUGOUT
argument_list|(
literal|" Error on flexible byte mask\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_CONFIG
return|;
block|}
comment|/* Now mask VM pool and destination IPv6 - bits 5 and 2 */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRM
argument_list|,
name|fdirm
argument_list|)
expr_stmt|;
comment|/* store the TCP/UDP port masks, bit reversed from port layout */
name|fdirtcpm
operator|=
name|ixgbe_get_fdirtcpm_82599
argument_list|(
name|input_mask
argument_list|)
expr_stmt|;
comment|/* write both the same so that UDP and TCP use the same mask */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRTCPM
argument_list|,
operator|~
name|fdirtcpm
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRUDPM
argument_list|,
operator|~
name|fdirtcpm
argument_list|)
expr_stmt|;
comment|/* store source and destination IP masks (big-enian) */
name|IXGBE_WRITE_REG_BE32
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRSIP4M
argument_list|,
operator|~
name|input_mask
operator|->
name|formatted
operator|.
name|src_ip
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG_BE32
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRDIP4M
argument_list|,
operator|~
name|input_mask
operator|->
name|formatted
operator|.
name|dst_ip
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_function
name|s32
name|ixgbe_fdir_write_perfect_filter_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|union
name|ixgbe_atr_input
modifier|*
name|input
parameter_list|,
name|u16
name|soft_id
parameter_list|,
name|u8
name|queue
parameter_list|)
block|{
name|u32
name|fdirport
decl_stmt|,
name|fdirvlan
decl_stmt|,
name|fdirhash
decl_stmt|,
name|fdircmd
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_fdir_write_perfect_filter_82599"
argument_list|)
expr_stmt|;
comment|/* currently IPv6 is not supported, must be programmed with 0 */
name|IXGBE_WRITE_REG_BE32
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRSIPv6
argument_list|(
literal|0
argument_list|)
argument_list|,
name|input
operator|->
name|formatted
operator|.
name|src_ip
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG_BE32
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRSIPv6
argument_list|(
literal|1
argument_list|)
argument_list|,
name|input
operator|->
name|formatted
operator|.
name|src_ip
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG_BE32
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRSIPv6
argument_list|(
literal|2
argument_list|)
argument_list|,
name|input
operator|->
name|formatted
operator|.
name|src_ip
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* record the source address (big-endian) */
name|IXGBE_WRITE_REG_BE32
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRIPSA
argument_list|,
name|input
operator|->
name|formatted
operator|.
name|src_ip
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* record the first 32 bits of the destination address (big-endian) */
name|IXGBE_WRITE_REG_BE32
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRIPDA
argument_list|,
name|input
operator|->
name|formatted
operator|.
name|dst_ip
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* record source and destination port (little-endian)*/
name|fdirport
operator|=
name|IXGBE_NTOHS
argument_list|(
name|input
operator|->
name|formatted
operator|.
name|dst_port
argument_list|)
expr_stmt|;
name|fdirport
operator|<<=
name|IXGBE_FDIRPORT_DESTINATION_SHIFT
expr_stmt|;
name|fdirport
operator||=
name|IXGBE_NTOHS
argument_list|(
name|input
operator|->
name|formatted
operator|.
name|src_port
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRPORT
argument_list|,
name|fdirport
argument_list|)
expr_stmt|;
comment|/* record vlan (little-endian) and flex_bytes(big-endian) */
name|fdirvlan
operator|=
name|IXGBE_STORE_AS_BE16
argument_list|(
name|input
operator|->
name|formatted
operator|.
name|flex_bytes
argument_list|)
expr_stmt|;
name|fdirvlan
operator|<<=
name|IXGBE_FDIRVLAN_FLEX_SHIFT
expr_stmt|;
name|fdirvlan
operator||=
name|IXGBE_NTOHS
argument_list|(
name|input
operator|->
name|formatted
operator|.
name|vlan_id
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRVLAN
argument_list|,
name|fdirvlan
argument_list|)
expr_stmt|;
comment|/* configure FDIRHASH register */
name|fdirhash
operator|=
name|input
operator|->
name|formatted
operator|.
name|bkt_hash
expr_stmt|;
name|fdirhash
operator||=
name|soft_id
operator|<<
name|IXGBE_FDIRHASH_SIG_SW_INDEX_SHIFT
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRHASH
argument_list|,
name|fdirhash
argument_list|)
expr_stmt|;
comment|/* 	 * flush all previous writes to make certain registers are 	 * programmed prior to issuing the command 	 */
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* configure FDIRCMD register */
name|fdircmd
operator|=
name|IXGBE_FDIRCMD_CMD_ADD_FLOW
operator||
name|IXGBE_FDIRCMD_FILTER_UPDATE
operator||
name|IXGBE_FDIRCMD_LAST
operator||
name|IXGBE_FDIRCMD_QUEUE_EN
expr_stmt|;
if|if
condition|(
name|queue
operator|==
name|IXGBE_FDIR_DROP_QUEUE
condition|)
name|fdircmd
operator||=
name|IXGBE_FDIRCMD_DROP
expr_stmt|;
name|fdircmd
operator||=
name|input
operator|->
name|formatted
operator|.
name|flow_type
operator|<<
name|IXGBE_FDIRCMD_FLOW_TYPE_SHIFT
expr_stmt|;
name|fdircmd
operator||=
operator|(
name|u32
operator|)
name|queue
operator|<<
name|IXGBE_FDIRCMD_RX_QUEUE_SHIFT
expr_stmt|;
name|fdircmd
operator||=
operator|(
name|u32
operator|)
name|input
operator|->
name|formatted
operator|.
name|vm_pool
operator|<<
name|IXGBE_FDIRCMD_VT_POOL_SHIFT
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRCMD
argument_list|,
name|fdircmd
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_function
name|s32
name|ixgbe_fdir_erase_perfect_filter_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|union
name|ixgbe_atr_input
modifier|*
name|input
parameter_list|,
name|u16
name|soft_id
parameter_list|)
block|{
name|u32
name|fdirhash
decl_stmt|;
name|u32
name|fdircmd
init|=
literal|0
decl_stmt|;
name|u32
name|retry_count
decl_stmt|;
name|s32
name|err
init|=
name|IXGBE_SUCCESS
decl_stmt|;
comment|/* configure FDIRHASH register */
name|fdirhash
operator|=
name|input
operator|->
name|formatted
operator|.
name|bkt_hash
expr_stmt|;
name|fdirhash
operator||=
name|soft_id
operator|<<
name|IXGBE_FDIRHASH_SIG_SW_INDEX_SHIFT
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRHASH
argument_list|,
name|fdirhash
argument_list|)
expr_stmt|;
comment|/* flush hash to HW */
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Query if filter is present */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRCMD
argument_list|,
name|IXGBE_FDIRCMD_CMD_QUERY_REM_FILT
argument_list|)
expr_stmt|;
for|for
control|(
name|retry_count
operator|=
literal|10
init|;
name|retry_count
condition|;
name|retry_count
operator|--
control|)
block|{
comment|/* allow 10us for query to process */
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* verify query completed successfully */
name|fdircmd
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRCMD
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fdircmd
operator|&
name|IXGBE_FDIRCMD_CMD_MASK
operator|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|retry_count
condition|)
name|err
operator|=
name|IXGBE_ERR_FDIR_REINIT_FAILED
expr_stmt|;
comment|/* if filter exists in hardware then remove it */
if|if
condition|(
name|fdircmd
operator|&
name|IXGBE_FDIRCMD_FILTER_VALID
condition|)
block|{
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRHASH
argument_list|,
name|fdirhash
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRCMD
argument_list|,
name|IXGBE_FDIRCMD_CMD_REMOVE_FLOW
argument_list|)
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_fdir_add_perfect_filter_82599 - Adds a perfect filter  *  @hw: pointer to hardware structure  *  @input: input bitstream  *  @input_mask: mask for the input bitstream  *  @soft_id: software index for the filters  *  @queue: queue index to direct traffic to  *  *  Note that the caller to this function must lock before calling, since the  *  hardware writes must be protected from one another.  **/
end_comment

begin_function
name|s32
name|ixgbe_fdir_add_perfect_filter_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|union
name|ixgbe_atr_input
modifier|*
name|input
parameter_list|,
name|union
name|ixgbe_atr_input
modifier|*
name|input_mask
parameter_list|,
name|u16
name|soft_id
parameter_list|,
name|u8
name|queue
parameter_list|)
block|{
name|s32
name|err
init|=
name|IXGBE_ERR_CONFIG
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_fdir_add_perfect_filter_82599"
argument_list|)
expr_stmt|;
comment|/* 	 * Check flow_type formatting, and bail out before we touch the hardware 	 * if there's a configuration issue 	 */
switch|switch
condition|(
name|input
operator|->
name|formatted
operator|.
name|flow_type
condition|)
block|{
case|case
name|IXGBE_ATR_FLOW_TYPE_IPV4
case|:
name|input_mask
operator|->
name|formatted
operator|.
name|flow_type
operator|=
name|IXGBE_ATR_L4TYPE_IPV6_MASK
expr_stmt|;
if|if
condition|(
name|input
operator|->
name|formatted
operator|.
name|dst_port
operator|||
name|input
operator|->
name|formatted
operator|.
name|src_port
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|" Error on src/dst port\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_CONFIG
return|;
block|}
break|break;
case|case
name|IXGBE_ATR_FLOW_TYPE_SCTPV4
case|:
if|if
condition|(
name|input
operator|->
name|formatted
operator|.
name|dst_port
operator|||
name|input
operator|->
name|formatted
operator|.
name|src_port
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|" Error on src/dst port\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_CONFIG
return|;
block|}
case|case
name|IXGBE_ATR_FLOW_TYPE_TCPV4
case|:
case|case
name|IXGBE_ATR_FLOW_TYPE_UDPV4
case|:
name|input_mask
operator|->
name|formatted
operator|.
name|flow_type
operator|=
name|IXGBE_ATR_L4TYPE_IPV6_MASK
operator||
name|IXGBE_ATR_L4TYPE_MASK
expr_stmt|;
break|break;
default|default:
name|DEBUGOUT
argument_list|(
literal|" Error on flow type input\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
comment|/* program input mask into the HW */
name|err
operator|=
name|ixgbe_fdir_set_input_mask_82599
argument_list|(
name|hw
argument_list|,
name|input_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
comment|/* apply mask and compute/store hash */
name|ixgbe_atr_compute_perfect_hash_82599
argument_list|(
name|input
argument_list|,
name|input_mask
argument_list|)
expr_stmt|;
comment|/* program filters to filter memory */
return|return
name|ixgbe_fdir_write_perfect_filter_82599
argument_list|(
name|hw
argument_list|,
name|input
argument_list|,
name|soft_id
argument_list|,
name|queue
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_read_analog_reg8_82599 - Reads 8 bit Omer analog register  *  @hw: pointer to hardware structure  *  @reg: analog register to read  *  @val: read value  *  *  Performs read operation to Omer analog register specified.  **/
end_comment

begin_function
name|s32
name|ixgbe_read_analog_reg8_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|reg
parameter_list|,
name|u8
modifier|*
name|val
parameter_list|)
block|{
name|u32
name|core_ctl
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_read_analog_reg8_82599"
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CORECTL
argument_list|,
name|IXGBE_CORECTL_WRITE_CMD
operator||
operator|(
name|reg
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|core_ctl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CORECTL
argument_list|)
expr_stmt|;
operator|*
name|val
operator|=
operator|(
name|u8
operator|)
name|core_ctl
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_write_analog_reg8_82599 - Writes 8 bit Omer analog register  *  @hw: pointer to hardware structure  *  @reg: atlas register to write  *  @val: value to write  *  *  Performs write operation to Omer analog register specified.  **/
end_comment

begin_function
name|s32
name|ixgbe_write_analog_reg8_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|reg
parameter_list|,
name|u8
name|val
parameter_list|)
block|{
name|u32
name|core_ctl
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_write_analog_reg8_82599"
argument_list|)
expr_stmt|;
name|core_ctl
operator|=
operator|(
name|reg
operator|<<
literal|8
operator|)
operator||
name|val
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CORECTL
argument_list|,
name|core_ctl
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_start_hw_82599 - Prepare hardware for Tx/Rx  *  @hw: pointer to hardware structure  *  *  Starts the hardware using the generic start_hw function  *  and the generation start_hw function.  *  Then performs revision-specific operations, if any.  **/
end_comment

begin_function
name|s32
name|ixgbe_start_hw_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_start_hw_82599"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|ixgbe_start_hw_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|ixgbe_start_hw_gen2
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|out
goto|;
comment|/* We need to run link autotry after the driver loads */
name|hw
operator|->
name|mac
operator|.
name|autotry_restart
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|ret_val
operator|==
name|IXGBE_SUCCESS
condition|)
name|ret_val
operator|=
name|ixgbe_verify_fw_version_82599
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_identify_phy_82599 - Get physical layer module  *  @hw: pointer to hardware structure  *  *  Determines the physical layer module found on the current adapter.  *  If PHY already detected, maintains current PHY type in hw struct,  *  otherwise executes the PHY detection routine.  **/
end_comment

begin_function
name|s32
name|ixgbe_identify_phy_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_ERR_PHY_ADDR_INVALID
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_identify_phy_82599"
argument_list|)
expr_stmt|;
comment|/* Detect PHY if not unknown - returns success if already detected. */
name|status
operator|=
name|ixgbe_identify_phy_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
block|{
comment|/* 82599 10GBASE-T requires an external PHY */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|get_media_type
argument_list|(
name|hw
argument_list|)
operator|==
name|ixgbe_media_type_copper
condition|)
goto|goto
name|out
goto|;
else|else
name|status
operator|=
name|ixgbe_identify_module_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
comment|/* Set PHY type none if no PHY detected */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|ixgbe_phy_unknown
condition|)
block|{
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|ixgbe_phy_none
expr_stmt|;
name|status
operator|=
name|IXGBE_SUCCESS
expr_stmt|;
block|}
comment|/* Return error if SFP module has been detected but is not supported */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|ixgbe_phy_sfp_unsupported
condition|)
name|status
operator|=
name|IXGBE_ERR_SFP_NOT_SUPPORTED
expr_stmt|;
name|out
label|:
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_supported_physical_layer_82599 - Returns physical layer type  *  @hw: pointer to hardware structure  *  *  Determines physical layer capabilities of the current configuration.  **/
end_comment

begin_function
name|u32
name|ixgbe_get_supported_physical_layer_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|physical_layer
init|=
name|IXGBE_PHYSICAL_LAYER_UNKNOWN
decl_stmt|;
name|u32
name|autoc
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC
argument_list|)
decl_stmt|;
name|u32
name|autoc2
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC2
argument_list|)
decl_stmt|;
name|u32
name|pma_pmd_10g_serial
init|=
name|autoc2
operator|&
name|IXGBE_AUTOC2_10G_SERIAL_PMA_PMD_MASK
decl_stmt|;
name|u32
name|pma_pmd_10g_parallel
init|=
name|autoc
operator|&
name|IXGBE_AUTOC_10G_PMA_PMD_MASK
decl_stmt|;
name|u32
name|pma_pmd_1g
init|=
name|autoc
operator|&
name|IXGBE_AUTOC_1G_PMA_PMD_MASK
decl_stmt|;
name|u16
name|ext_ability
init|=
literal|0
decl_stmt|;
name|u8
name|comp_codes_10g
init|=
literal|0
decl_stmt|;
name|u8
name|comp_codes_1g
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_support_physical_layer_82599"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|identify
argument_list|(
name|hw
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
condition|)
block|{
case|case
name|ixgbe_phy_tn
case|:
case|case
name|ixgbe_phy_cu_unknown
case|:
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_PHY_EXT_ABILITY
argument_list|,
name|IXGBE_MDIO_PMA_PMD_DEV_TYPE
argument_list|,
operator|&
name|ext_ability
argument_list|)
expr_stmt|;
if|if
condition|(
name|ext_ability
operator|&
name|IXGBE_MDIO_PHY_10GBASET_ABILITY
condition|)
name|physical_layer
operator||=
name|IXGBE_PHYSICAL_LAYER_10GBASE_T
expr_stmt|;
if|if
condition|(
name|ext_ability
operator|&
name|IXGBE_MDIO_PHY_1000BASET_ABILITY
condition|)
name|physical_layer
operator||=
name|IXGBE_PHYSICAL_LAYER_1000BASE_T
expr_stmt|;
if|if
condition|(
name|ext_ability
operator|&
name|IXGBE_MDIO_PHY_100BASETX_ABILITY
condition|)
name|physical_layer
operator||=
name|IXGBE_PHYSICAL_LAYER_100BASE_TX
expr_stmt|;
goto|goto
name|out
goto|;
default|default:
break|break;
block|}
switch|switch
condition|(
name|autoc
operator|&
name|IXGBE_AUTOC_LMS_MASK
condition|)
block|{
case|case
name|IXGBE_AUTOC_LMS_1G_AN
case|:
case|case
name|IXGBE_AUTOC_LMS_1G_LINK_NO_AN
case|:
if|if
condition|(
name|pma_pmd_1g
operator|==
name|IXGBE_AUTOC_1G_KX_BX
condition|)
block|{
name|physical_layer
operator|=
name|IXGBE_PHYSICAL_LAYER_1000BASE_KX
operator||
name|IXGBE_PHYSICAL_LAYER_1000BASE_BX
expr_stmt|;
goto|goto
name|out
goto|;
block|}
else|else
comment|/* SFI mode so read SFP module */
goto|goto
name|sfp_check
goto|;
break|break;
case|case
name|IXGBE_AUTOC_LMS_10G_LINK_NO_AN
case|:
if|if
condition|(
name|pma_pmd_10g_parallel
operator|==
name|IXGBE_AUTOC_10G_CX4
condition|)
name|physical_layer
operator|=
name|IXGBE_PHYSICAL_LAYER_10GBASE_CX4
expr_stmt|;
elseif|else
if|if
condition|(
name|pma_pmd_10g_parallel
operator|==
name|IXGBE_AUTOC_10G_KX4
condition|)
name|physical_layer
operator|=
name|IXGBE_PHYSICAL_LAYER_10GBASE_KX4
expr_stmt|;
elseif|else
if|if
condition|(
name|pma_pmd_10g_parallel
operator|==
name|IXGBE_AUTOC_10G_XAUI
condition|)
name|physical_layer
operator|=
name|IXGBE_PHYSICAL_LAYER_10GBASE_XAUI
expr_stmt|;
goto|goto
name|out
goto|;
break|break;
case|case
name|IXGBE_AUTOC_LMS_10G_SERIAL
case|:
if|if
condition|(
name|pma_pmd_10g_serial
operator|==
name|IXGBE_AUTOC2_10G_KR
condition|)
block|{
name|physical_layer
operator|=
name|IXGBE_PHYSICAL_LAYER_10GBASE_KR
expr_stmt|;
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
name|pma_pmd_10g_serial
operator|==
name|IXGBE_AUTOC2_10G_SFI
condition|)
goto|goto
name|sfp_check
goto|;
break|break;
case|case
name|IXGBE_AUTOC_LMS_KX4_KX_KR
case|:
case|case
name|IXGBE_AUTOC_LMS_KX4_KX_KR_1G_AN
case|:
if|if
condition|(
name|autoc
operator|&
name|IXGBE_AUTOC_KX_SUPP
condition|)
name|physical_layer
operator||=
name|IXGBE_PHYSICAL_LAYER_1000BASE_KX
expr_stmt|;
if|if
condition|(
name|autoc
operator|&
name|IXGBE_AUTOC_KX4_SUPP
condition|)
name|physical_layer
operator||=
name|IXGBE_PHYSICAL_LAYER_10GBASE_KX4
expr_stmt|;
if|if
condition|(
name|autoc
operator|&
name|IXGBE_AUTOC_KR_SUPP
condition|)
name|physical_layer
operator||=
name|IXGBE_PHYSICAL_LAYER_10GBASE_KR
expr_stmt|;
goto|goto
name|out
goto|;
break|break;
default|default:
goto|goto
name|out
goto|;
break|break;
block|}
name|sfp_check
label|:
comment|/* SFP check must be done last since DA modules are sometimes used to 	 * test KR mode -  we need to id KR mode correctly before SFP module. 	 * Call identify_sfp because the pluggable module may have changed */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|identify_sfp
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|==
name|ixgbe_sfp_type_not_present
condition|)
goto|goto
name|out
goto|;
switch|switch
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
condition|)
block|{
case|case
name|ixgbe_phy_sfp_passive_tyco
case|:
case|case
name|ixgbe_phy_sfp_passive_unknown
case|:
name|physical_layer
operator|=
name|IXGBE_PHYSICAL_LAYER_SFP_PLUS_CU
expr_stmt|;
break|break;
case|case
name|ixgbe_phy_sfp_ftl_active
case|:
case|case
name|ixgbe_phy_sfp_active_unknown
case|:
name|physical_layer
operator|=
name|IXGBE_PHYSICAL_LAYER_SFP_ACTIVE_DA
expr_stmt|;
break|break;
case|case
name|ixgbe_phy_sfp_avago
case|:
case|case
name|ixgbe_phy_sfp_ftl
case|:
case|case
name|ixgbe_phy_sfp_intel
case|:
case|case
name|ixgbe_phy_sfp_unknown
case|:
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_i2c_eeprom
argument_list|(
name|hw
argument_list|,
name|IXGBE_SFF_1GBE_COMP_CODES
argument_list|,
operator|&
name|comp_codes_1g
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_i2c_eeprom
argument_list|(
name|hw
argument_list|,
name|IXGBE_SFF_10GBE_COMP_CODES
argument_list|,
operator|&
name|comp_codes_10g
argument_list|)
expr_stmt|;
if|if
condition|(
name|comp_codes_10g
operator|&
name|IXGBE_SFF_10GBASESR_CAPABLE
condition|)
name|physical_layer
operator|=
name|IXGBE_PHYSICAL_LAYER_10GBASE_SR
expr_stmt|;
elseif|else
if|if
condition|(
name|comp_codes_10g
operator|&
name|IXGBE_SFF_10GBASELR_CAPABLE
condition|)
name|physical_layer
operator|=
name|IXGBE_PHYSICAL_LAYER_10GBASE_LR
expr_stmt|;
elseif|else
if|if
condition|(
name|comp_codes_1g
operator|&
name|IXGBE_SFF_1GBASET_CAPABLE
condition|)
name|physical_layer
operator|=
name|IXGBE_PHYSICAL_LAYER_1000BASE_T
expr_stmt|;
elseif|else
if|if
condition|(
name|comp_codes_1g
operator|&
name|IXGBE_SFF_1GBASESX_CAPABLE
condition|)
name|physical_layer
operator|=
name|IXGBE_PHYSICAL_LAYER_1000BASE_SX
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|out
label|:
return|return
name|physical_layer
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_enable_rx_dma_82599 - Enable the Rx DMA unit on 82599  *  @hw: pointer to hardware structure  *  @regval: register value to write to RXCTRL  *  *  Enables the Rx DMA unit for 82599  **/
end_comment

begin_function
name|s32
name|ixgbe_enable_rx_dma_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|regval
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_enable_rx_dma_82599"
argument_list|)
expr_stmt|;
comment|/* 	 * Workaround for 82599 silicon errata when enabling the Rx datapath. 	 * If traffic is incoming before we enable the Rx unit, it could hang 	 * the Rx DMA unit.  Therefore, make sure the security engine is 	 * completely disabled prior to enabling the Rx unit. 	 */
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|disable_sec_rx_path
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXCTRL
argument_list|,
name|regval
argument_list|)
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|enable_sec_rx_path
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_verify_fw_version_82599 - verify fw version for 82599  *  @hw: pointer to hardware structure  *  *  Verifies that installed the firmware version is 0.6 or higher  *  for SFI devices. All 82599 SFI devices should have version 0.6 or higher.  *  *  Returns IXGBE_ERR_EEPROM_VERSION if the FW is not present or  *  if the FW version is not supported.  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_verify_fw_version_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_ERR_EEPROM_VERSION
decl_stmt|;
name|u16
name|fw_offset
decl_stmt|,
name|fw_ptp_cfg_offset
decl_stmt|;
name|u16
name|fw_version
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_verify_fw_version_82599"
argument_list|)
expr_stmt|;
comment|/* firmware check is only necessary for SFI devices */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|!=
name|ixgbe_media_type_fiber
condition|)
block|{
name|status
operator|=
name|IXGBE_SUCCESS
expr_stmt|;
goto|goto
name|fw_version_out
goto|;
block|}
comment|/* get the offset to the Firmware Module block */
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|IXGBE_FW_PTR
argument_list|,
operator|&
name|fw_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fw_offset
operator|==
literal|0
operator|)
operator|||
operator|(
name|fw_offset
operator|==
literal|0xFFFF
operator|)
condition|)
goto|goto
name|fw_version_out
goto|;
comment|/* get the offset to the Pass Through Patch Configuration block */
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
operator|(
name|fw_offset
operator|+
name|IXGBE_FW_PASSTHROUGH_PATCH_CONFIG_PTR
operator|)
argument_list|,
operator|&
name|fw_ptp_cfg_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fw_ptp_cfg_offset
operator|==
literal|0
operator|)
operator|||
operator|(
name|fw_ptp_cfg_offset
operator|==
literal|0xFFFF
operator|)
condition|)
goto|goto
name|fw_version_out
goto|;
comment|/* get the firmware version */
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
operator|(
name|fw_ptp_cfg_offset
operator|+
name|IXGBE_FW_PATCH_VERSION_4
operator|)
argument_list|,
operator|&
name|fw_version
argument_list|)
expr_stmt|;
if|if
condition|(
name|fw_version
operator|>
literal|0x5
condition|)
name|status
operator|=
name|IXGBE_SUCCESS
expr_stmt|;
name|fw_version_out
label|:
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_verify_lesm_fw_enabled_82599 - Checks LESM FW module state.  *  @hw: pointer to hardware structure  *  *  Returns TRUE if the LESM FW module is present and enabled. Otherwise  *  returns FALSE. Smart Speed must be disabled if LESM FW module is enabled.  **/
end_comment

begin_function
name|bool
name|ixgbe_verify_lesm_fw_enabled_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|bool
name|lesm_enabled
init|=
name|FALSE
decl_stmt|;
name|u16
name|fw_offset
decl_stmt|,
name|fw_lesm_param_offset
decl_stmt|,
name|fw_lesm_state
decl_stmt|;
name|s32
name|status
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_verify_lesm_fw_enabled_82599"
argument_list|)
expr_stmt|;
comment|/* get the offset to the Firmware Module block */
name|status
operator|=
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|IXGBE_FW_PTR
argument_list|,
operator|&
name|fw_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|!=
name|IXGBE_SUCCESS
operator|)
operator|||
operator|(
name|fw_offset
operator|==
literal|0
operator|)
operator|||
operator|(
name|fw_offset
operator|==
literal|0xFFFF
operator|)
condition|)
goto|goto
name|out
goto|;
comment|/* get the offset to the LESM Parameters block */
name|status
operator|=
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
operator|(
name|fw_offset
operator|+
name|IXGBE_FW_LESM_PARAMETERS_PTR
operator|)
argument_list|,
operator|&
name|fw_lesm_param_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|!=
name|IXGBE_SUCCESS
operator|)
operator|||
operator|(
name|fw_lesm_param_offset
operator|==
literal|0
operator|)
operator|||
operator|(
name|fw_lesm_param_offset
operator|==
literal|0xFFFF
operator|)
condition|)
goto|goto
name|out
goto|;
comment|/* get the lesm state word */
name|status
operator|=
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
operator|(
name|fw_lesm_param_offset
operator|+
name|IXGBE_FW_LESM_STATE_1
operator|)
argument_list|,
operator|&
name|fw_lesm_state
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|==
name|IXGBE_SUCCESS
operator|)
operator|&&
operator|(
name|fw_lesm_state
operator|&
name|IXGBE_FW_LESM_STATE_ENABLED
operator|)
condition|)
name|lesm_enabled
operator|=
name|TRUE
expr_stmt|;
name|out
label|:
return|return
name|lesm_enabled
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_read_eeprom_buffer_82599 - Read EEPROM word(s) using  *  fastest available method  *  *  @hw: pointer to hardware structure  *  @offset: offset of  word in EEPROM to read  *  @words: number of words  *  @data: word(s) read from the EEPROM  *  *  Retrieves 16 bit word(s) read from EEPROM  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_read_eeprom_buffer_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
name|words
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ixgbe_eeprom_info
modifier|*
name|eeprom
init|=
operator|&
name|hw
operator|->
name|eeprom
decl_stmt|;
name|s32
name|ret_val
init|=
name|IXGBE_ERR_CONFIG
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_read_eeprom_buffer_82599"
argument_list|)
expr_stmt|;
comment|/* 	 * If EEPROM is detected and can be addressed using 14 bits, 	 * use EERD otherwise use bit bang 	 */
if|if
condition|(
operator|(
name|eeprom
operator|->
name|type
operator|==
name|ixgbe_eeprom_spi
operator|)
operator|&&
operator|(
name|offset
operator|+
operator|(
name|words
operator|-
literal|1
operator|)
operator|<=
name|IXGBE_EERD_MAX_ADDR
operator|)
condition|)
name|ret_val
operator|=
name|ixgbe_read_eerd_buffer_generic
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|words
argument_list|,
name|data
argument_list|)
expr_stmt|;
else|else
name|ret_val
operator|=
name|ixgbe_read_eeprom_buffer_bit_bang_generic
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|words
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_read_eeprom_82599 - Read EEPROM word using  *  fastest available method  *  *  @hw: pointer to hardware structure  *  @offset: offset of  word in the EEPROM to read  *  @data: word read from the EEPROM  *  *  Reads a 16 bit word from the EEPROM  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_read_eeprom_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ixgbe_eeprom_info
modifier|*
name|eeprom
init|=
operator|&
name|hw
operator|->
name|eeprom
decl_stmt|;
name|s32
name|ret_val
init|=
name|IXGBE_ERR_CONFIG
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_read_eeprom_82599"
argument_list|)
expr_stmt|;
comment|/* 	 * If EEPROM is detected and can be addressed using 14 bits, 	 * use EERD otherwise use bit bang 	 */
if|if
condition|(
operator|(
name|eeprom
operator|->
name|type
operator|==
name|ixgbe_eeprom_spi
operator|)
operator|&&
operator|(
name|offset
operator|<=
name|IXGBE_EERD_MAX_ADDR
operator|)
condition|)
name|ret_val
operator|=
name|ixgbe_read_eerd_generic
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
else|else
name|ret_val
operator|=
name|ixgbe_read_eeprom_bit_bang_generic
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

end_unit

