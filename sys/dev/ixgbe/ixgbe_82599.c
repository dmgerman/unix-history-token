begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************    Copyright (c) 2001-2009, Intel Corporation    All rights reserved.      Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are met:       1. Redistributions of source code must retain the above copyright notice,        this list of conditions and the following disclaimer.       2. Redistributions in binary form must reproduce the above copyright        notice, this list of conditions and the following disclaimer in the        documentation and/or other materials provided with the distribution.       3. Neither the name of the Intel Corporation nor the names of its        contributors may be used to endorse or promote products derived from        this software without specific prior written permission.      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  ******************************************************************************/
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_include
include|#
directive|include
file|"ixgbe_type.h"
end_include

begin_include
include|#
directive|include
file|"ixgbe_api.h"
end_include

begin_include
include|#
directive|include
file|"ixgbe_common.h"
end_include

begin_include
include|#
directive|include
file|"ixgbe_phy.h"
end_include

begin_function_decl
name|s32
name|ixgbe_init_ops_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|s32
name|ixgbe_get_link_capabilities_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
modifier|*
name|speed
parameter_list|,
name|bool
modifier|*
name|autoneg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|enum
name|ixgbe_media_type
name|ixgbe_get_media_type_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|s32
name|ixgbe_setup_mac_link_multispeed_fiber
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
name|speed
parameter_list|,
name|bool
name|autoneg
parameter_list|,
name|bool
name|autoneg_wait_to_complete
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|s32
name|ixgbe_setup_mac_link_smartspeed
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
name|speed
parameter_list|,
name|bool
name|autoneg
parameter_list|,
name|bool
name|autoneg_wait_to_complete
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|s32
name|ixgbe_start_mac_link_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|autoneg_wait_to_complete
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|s32
name|ixgbe_setup_mac_link_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
name|speed
parameter_list|,
name|bool
name|autoneg
parameter_list|,
name|bool
name|autoneg_wait_to_complete
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|ixgbe_setup_copper_link_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
name|speed
parameter_list|,
name|bool
name|autoneg
parameter_list|,
name|bool
name|autoneg_wait_to_complete
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|s32
name|ixgbe_setup_sfp_modules_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ixgbe_init_mac_link_ops_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|s32
name|ixgbe_reset_hw_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|s32
name|ixgbe_read_analog_reg8_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|reg
parameter_list|,
name|u8
modifier|*
name|val
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|s32
name|ixgbe_write_analog_reg8_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|reg
parameter_list|,
name|u8
name|val
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|s32
name|ixgbe_start_hw_rev_1_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|s32
name|ixgbe_identify_phy_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|s32
name|ixgbe_init_phy_ops_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|u32
name|ixgbe_get_supported_physical_layer_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|s32
name|ixgbe_enable_rx_dma_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|regval
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|s32
name|ixgbe_get_device_caps_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|device_caps
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|ixgbe_verify_fw_version_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|ixgbe_init_mac_link_ops_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|ixgbe_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_init_mac_link_ops_82599"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|multispeed_fiber
condition|)
block|{
comment|/* Set up dual speed SFP+ support */
name|mac
operator|->
name|ops
operator|.
name|setup_link
operator|=
operator|&
name|ixgbe_setup_mac_link_multispeed_fiber
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ixgbe_get_media_type
argument_list|(
name|hw
argument_list|)
operator|==
name|ixgbe_media_type_backplane
operator|)
operator|&&
operator|(
name|hw
operator|->
name|phy
operator|.
name|smart_speed
operator|==
name|ixgbe_smart_speed_auto
operator|||
name|hw
operator|->
name|phy
operator|.
name|smart_speed
operator|==
name|ixgbe_smart_speed_on
operator|)
condition|)
name|mac
operator|->
name|ops
operator|.
name|setup_link
operator|=
operator|&
name|ixgbe_setup_mac_link_smartspeed
expr_stmt|;
else|else
name|mac
operator|->
name|ops
operator|.
name|setup_link
operator|=
operator|&
name|ixgbe_setup_mac_link_82599
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *  ixgbe_init_phy_ops_82599 - PHY/SFP specific init  *  @hw: pointer to hardware structure  *  *  Initialize any function pointers that were not able to be  *  set during init_shared_code because the PHY/SFP type was  *  not known.  Perform the SFP init if necessary.  *  **/
end_comment

begin_function
name|s32
name|ixgbe_init_phy_ops_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|ixgbe_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|struct
name|ixgbe_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_init_phy_ops_82599"
argument_list|)
expr_stmt|;
comment|/* Identify the PHY or SFP module */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|identify
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|==
name|IXGBE_ERR_SFP_NOT_SUPPORTED
condition|)
goto|goto
name|init_phy_ops_out
goto|;
comment|/* Setup function pointers based on detected SFP module and speeds */
name|ixgbe_init_mac_link_ops_82599
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|!=
name|ixgbe_sfp_type_unknown
condition|)
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|reset
operator|=
name|NULL
expr_stmt|;
comment|/* If copper media, overwrite with copper function pointers */
if|if
condition|(
name|mac
operator|->
name|ops
operator|.
name|get_media_type
argument_list|(
name|hw
argument_list|)
operator|==
name|ixgbe_media_type_copper
condition|)
block|{
name|mac
operator|->
name|ops
operator|.
name|setup_link
operator|=
operator|&
name|ixgbe_setup_copper_link_82599
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_link_capabilities
operator|=
operator|&
name|ixgbe_get_copper_link_capabilities_generic
expr_stmt|;
block|}
comment|/* Set necessary function pointers based on phy type */
switch|switch
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
condition|)
block|{
case|case
name|ixgbe_phy_tn
case|:
name|phy
operator|->
name|ops
operator|.
name|setup_link
operator|=
operator|&
name|ixgbe_setup_phy_link_tnx
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|check_link
operator|=
operator|&
name|ixgbe_check_phy_link_tnx
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|get_firmware_version
operator|=
operator|&
name|ixgbe_get_phy_firmware_version_tnx
expr_stmt|;
break|break;
case|case
name|ixgbe_phy_aq
case|:
name|phy
operator|->
name|ops
operator|.
name|get_firmware_version
operator|=
operator|&
name|ixgbe_get_phy_firmware_version_generic
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|init_phy_ops_out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_function
name|s32
name|ixgbe_setup_sfp_modules_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u16
name|list_offset
decl_stmt|,
name|data_offset
decl_stmt|,
name|data_value
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_setup_sfp_modules_82599"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|!=
name|ixgbe_sfp_type_unknown
condition|)
block|{
name|ixgbe_init_mac_link_ops_82599
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|reset
operator|=
name|NULL
expr_stmt|;
name|ret_val
operator|=
name|ixgbe_get_sfp_init_sequence_offsets
argument_list|(
name|hw
argument_list|,
operator|&
name|list_offset
argument_list|,
operator|&
name|data_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|setup_sfp_out
goto|;
comment|/* PHY config will finish before releasing the semaphore */
name|ret_val
operator|=
name|ixgbe_acquire_swfw_sync
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR_MAC_CSR_SM
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|IXGBE_SUCCESS
condition|)
block|{
name|ret_val
operator|=
name|IXGBE_ERR_SWFW_SYNC
expr_stmt|;
goto|goto
name|setup_sfp_out
goto|;
block|}
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
operator|++
name|data_offset
argument_list|,
operator|&
name|data_value
argument_list|)
expr_stmt|;
while|while
condition|(
name|data_value
operator|!=
literal|0xffff
condition|)
block|{
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CORECTL
argument_list|,
name|data_value
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
operator|++
name|data_offset
argument_list|,
operator|&
name|data_value
argument_list|)
expr_stmt|;
block|}
comment|/* Now restart DSP by setting Restart_AN */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC
argument_list|,
operator|(
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC
argument_list|)
operator||
name|IXGBE_AUTOC_AN_RESTART
operator|)
argument_list|)
expr_stmt|;
comment|/* Release the semaphore */
name|ixgbe_release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR_MAC_CSR_SM
argument_list|)
expr_stmt|;
comment|/* Delay obtaining semaphore again to allow FW access */
name|msec_delay
argument_list|(
name|hw
operator|->
name|eeprom
operator|.
name|semaphore_delay
argument_list|)
expr_stmt|;
block|}
name|setup_sfp_out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_init_ops_82599 - Inits func ptrs and MAC type  *  @hw: pointer to hardware structure  *  *  Initialize the function pointers and assign the MAC type for 82599.  *  Does not touch the hardware.  **/
end_comment

begin_function
name|s32
name|ixgbe_init_ops_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|ixgbe_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|struct
name|ixgbe_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_init_ops_82599"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|ixgbe_init_phy_ops_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|ixgbe_init_ops_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* PHY */
name|phy
operator|->
name|ops
operator|.
name|identify
operator|=
operator|&
name|ixgbe_identify_phy_82599
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|init
operator|=
operator|&
name|ixgbe_init_phy_ops_82599
expr_stmt|;
comment|/* MAC */
name|mac
operator|->
name|ops
operator|.
name|reset_hw
operator|=
operator|&
name|ixgbe_reset_hw_82599
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_media_type
operator|=
operator|&
name|ixgbe_get_media_type_82599
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_supported_physical_layer
operator|=
operator|&
name|ixgbe_get_supported_physical_layer_82599
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|enable_rx_dma
operator|=
operator|&
name|ixgbe_enable_rx_dma_82599
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|read_analog_reg8
operator|=
operator|&
name|ixgbe_read_analog_reg8_82599
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|write_analog_reg8
operator|=
operator|&
name|ixgbe_write_analog_reg8_82599
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|start_hw
operator|=
operator|&
name|ixgbe_start_hw_rev_1_82599
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_san_mac_addr
operator|=
operator|&
name|ixgbe_get_san_mac_addr_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|set_san_mac_addr
operator|=
operator|&
name|ixgbe_set_san_mac_addr_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_device_caps
operator|=
operator|&
name|ixgbe_get_device_caps_82599
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_wwn_prefix
operator|=
operator|&
name|ixgbe_get_wwn_prefix_generic
expr_stmt|;
comment|/* RAR, Multicast, VLAN */
name|mac
operator|->
name|ops
operator|.
name|set_vmdq
operator|=
operator|&
name|ixgbe_set_vmdq_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|clear_vmdq
operator|=
operator|&
name|ixgbe_clear_vmdq_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|insert_mac_addr
operator|=
operator|&
name|ixgbe_insert_mac_addr_generic
expr_stmt|;
name|mac
operator|->
name|rar_highwater
operator|=
literal|1
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|set_vfta
operator|=
operator|&
name|ixgbe_set_vfta_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|clear_vfta
operator|=
operator|&
name|ixgbe_clear_vfta_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|init_uta_tables
operator|=
operator|&
name|ixgbe_init_uta_tables_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|setup_sfp
operator|=
operator|&
name|ixgbe_setup_sfp_modules_82599
expr_stmt|;
comment|/* Link */
name|mac
operator|->
name|ops
operator|.
name|get_link_capabilities
operator|=
operator|&
name|ixgbe_get_link_capabilities_82599
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|check_link
operator|=
operator|&
name|ixgbe_check_mac_link_generic
expr_stmt|;
name|ixgbe_init_mac_link_ops_82599
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|mac
operator|->
name|mcft_size
operator|=
literal|128
expr_stmt|;
name|mac
operator|->
name|vft_size
operator|=
literal|128
expr_stmt|;
name|mac
operator|->
name|num_rar_entries
operator|=
literal|128
expr_stmt|;
name|mac
operator|->
name|max_tx_queues
operator|=
literal|128
expr_stmt|;
name|mac
operator|->
name|max_rx_queues
operator|=
literal|128
expr_stmt|;
name|mac
operator|->
name|max_msix_vectors
operator|=
name|ixgbe_get_pcie_msix_count_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_link_capabilities_82599 - Determines link capabilities  *  @hw: pointer to hardware structure  *  @speed: pointer to link speed  *  @negotiation: TRUE when autoneg or autotry is enabled  *  *  Determines the link capabilities by reading the AUTOC register.  **/
end_comment

begin_function
name|s32
name|ixgbe_get_link_capabilities_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
modifier|*
name|speed
parameter_list|,
name|bool
modifier|*
name|negotiation
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u32
name|autoc
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_link_capabilities_82599"
argument_list|)
expr_stmt|;
comment|/* 	 * Determine link capabilities based on the stored value of AUTOC, 	 * which represents EEPROM defaults.  If AUTOC value has not 	 * been stored, use the current register values. 	 */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|orig_link_settings_stored
condition|)
name|autoc
operator|=
name|hw
operator|->
name|mac
operator|.
name|orig_autoc
expr_stmt|;
else|else
name|autoc
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|autoc
operator|&
name|IXGBE_AUTOC_LMS_MASK
condition|)
block|{
case|case
name|IXGBE_AUTOC_LMS_1G_LINK_NO_AN
case|:
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
operator|*
name|negotiation
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|IXGBE_AUTOC_LMS_10G_LINK_NO_AN
case|:
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_10GB_FULL
expr_stmt|;
operator|*
name|negotiation
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|IXGBE_AUTOC_LMS_1G_AN
case|:
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
operator|*
name|negotiation
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|IXGBE_AUTOC_LMS_10G_SERIAL
case|:
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_10GB_FULL
expr_stmt|;
operator|*
name|negotiation
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|IXGBE_AUTOC_LMS_KX4_KX_KR
case|:
case|case
name|IXGBE_AUTOC_LMS_KX4_KX_KR_1G_AN
case|:
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_UNKNOWN
expr_stmt|;
if|if
condition|(
name|autoc
operator|&
name|IXGBE_AUTOC_KR_SUPP
condition|)
operator|*
name|speed
operator||=
name|IXGBE_LINK_SPEED_10GB_FULL
expr_stmt|;
if|if
condition|(
name|autoc
operator|&
name|IXGBE_AUTOC_KX4_SUPP
condition|)
operator|*
name|speed
operator||=
name|IXGBE_LINK_SPEED_10GB_FULL
expr_stmt|;
if|if
condition|(
name|autoc
operator|&
name|IXGBE_AUTOC_KX_SUPP
condition|)
operator|*
name|speed
operator||=
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
operator|*
name|negotiation
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|IXGBE_AUTOC_LMS_KX4_KX_KR_SGMII
case|:
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_100_FULL
expr_stmt|;
if|if
condition|(
name|autoc
operator|&
name|IXGBE_AUTOC_KR_SUPP
condition|)
operator|*
name|speed
operator||=
name|IXGBE_LINK_SPEED_10GB_FULL
expr_stmt|;
if|if
condition|(
name|autoc
operator|&
name|IXGBE_AUTOC_KX4_SUPP
condition|)
operator|*
name|speed
operator||=
name|IXGBE_LINK_SPEED_10GB_FULL
expr_stmt|;
if|if
condition|(
name|autoc
operator|&
name|IXGBE_AUTOC_KX_SUPP
condition|)
operator|*
name|speed
operator||=
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
operator|*
name|negotiation
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|IXGBE_AUTOC_LMS_SGMII_1G_100M
case|:
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_1GB_FULL
operator||
name|IXGBE_LINK_SPEED_100_FULL
expr_stmt|;
operator|*
name|negotiation
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
name|status
operator|=
name|IXGBE_ERR_LINK_SETUP
expr_stmt|;
goto|goto
name|out
goto|;
break|break;
block|}
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|multispeed_fiber
condition|)
block|{
operator|*
name|speed
operator||=
name|IXGBE_LINK_SPEED_10GB_FULL
operator||
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
operator|*
name|negotiation
operator|=
name|TRUE
expr_stmt|;
block|}
name|out
label|:
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_media_type_82599 - Get media type  *  @hw: pointer to hardware structure  *  *  Returns the media type (fiber, copper, backplane)  **/
end_comment

begin_function
name|enum
name|ixgbe_media_type
name|ixgbe_get_media_type_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|enum
name|ixgbe_media_type
name|media_type
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_media_type_82599"
argument_list|)
expr_stmt|;
comment|/* Detect if there is a copper PHY attached. */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|ixgbe_phy_cu_unknown
operator|||
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|ixgbe_phy_tn
operator|||
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|ixgbe_phy_aq
condition|)
block|{
name|media_type
operator|=
name|ixgbe_media_type_copper
expr_stmt|;
goto|goto
name|out
goto|;
block|}
switch|switch
condition|(
name|hw
operator|->
name|device_id
condition|)
block|{
case|case
name|IXGBE_DEV_ID_82599_KX4
case|:
case|case
name|IXGBE_DEV_ID_82599_KX4_MEZZ
case|:
case|case
name|IXGBE_DEV_ID_82599_COMBO_BACKPLANE
case|:
case|case
name|IXGBE_DEV_ID_82599_XAUI_LOM
case|:
comment|/* Default device ID is mezzanine card KX/KX4 */
name|media_type
operator|=
name|ixgbe_media_type_backplane
expr_stmt|;
break|break;
case|case
name|IXGBE_DEV_ID_82599_SFP
case|:
name|media_type
operator|=
name|ixgbe_media_type_fiber
expr_stmt|;
break|break;
case|case
name|IXGBE_DEV_ID_82599_CX4
case|:
name|media_type
operator|=
name|ixgbe_media_type_cx4
expr_stmt|;
break|break;
default|default:
name|media_type
operator|=
name|ixgbe_media_type_unknown
expr_stmt|;
break|break;
block|}
name|out
label|:
return|return
name|media_type
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_start_mac_link_82599 - Setup MAC link settings  *  @hw: pointer to hardware structure  *  *  Configures link settings based on values in the ixgbe_hw struct.  *  Restarts the link.  Performs autonegotiation if needed.  **/
end_comment

begin_function
name|s32
name|ixgbe_start_mac_link_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|autoneg_wait_to_complete
parameter_list|)
block|{
name|u32
name|autoc_reg
decl_stmt|;
name|u32
name|links_reg
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_start_mac_link_82599"
argument_list|)
expr_stmt|;
comment|/* Restart link */
name|autoc_reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC
argument_list|)
expr_stmt|;
name|autoc_reg
operator||=
name|IXGBE_AUTOC_AN_RESTART
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC
argument_list|,
name|autoc_reg
argument_list|)
expr_stmt|;
comment|/* Only poll for autoneg to complete if specified to do so */
if|if
condition|(
name|autoneg_wait_to_complete
condition|)
block|{
if|if
condition|(
operator|(
name|autoc_reg
operator|&
name|IXGBE_AUTOC_LMS_MASK
operator|)
operator|==
name|IXGBE_AUTOC_LMS_KX4_KX_KR
operator|||
operator|(
name|autoc_reg
operator|&
name|IXGBE_AUTOC_LMS_MASK
operator|)
operator|==
name|IXGBE_AUTOC_LMS_KX4_KX_KR_1G_AN
operator|||
operator|(
name|autoc_reg
operator|&
name|IXGBE_AUTOC_LMS_MASK
operator|)
operator|==
name|IXGBE_AUTOC_LMS_KX4_KX_KR_SGMII
condition|)
block|{
name|links_reg
operator|=
literal|0
expr_stmt|;
comment|/* Just in case Autoneg time = 0 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_AUTO_NEG_TIME
condition|;
name|i
operator|++
control|)
block|{
name|links_reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LINKS
argument_list|)
expr_stmt|;
if|if
condition|(
name|links_reg
operator|&
name|IXGBE_LINKS_KX_AN_COMP
condition|)
break|break;
name|msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|links_reg
operator|&
name|IXGBE_LINKS_KX_AN_COMP
operator|)
condition|)
block|{
name|status
operator|=
name|IXGBE_ERR_AUTONEG_NOT_COMPLETE
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Autoneg did not complete.\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Add delay to filter out noises during initial link setup */
name|msec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_setup_mac_link_multispeed_fiber - Set MAC link speed  *  @hw: pointer to hardware structure  *  @speed: new link speed  *  @autoneg: TRUE if autonegotiation enabled  *  @autoneg_wait_to_complete: TRUE when waiting for completion is needed  *  *  Set the link speed in the AUTOC register and restarts link.  **/
end_comment

begin_function
name|s32
name|ixgbe_setup_mac_link_multispeed_fiber
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
name|speed
parameter_list|,
name|bool
name|autoneg
parameter_list|,
name|bool
name|autoneg_wait_to_complete
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|ixgbe_link_speed
name|link_speed
decl_stmt|;
name|ixgbe_link_speed
name|highest_link_speed
init|=
name|IXGBE_LINK_SPEED_UNKNOWN
decl_stmt|;
name|u32
name|speedcnt
init|=
literal|0
decl_stmt|;
name|u32
name|esdp_reg
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|)
decl_stmt|;
name|u32
name|i
init|=
literal|0
decl_stmt|;
name|bool
name|link_up
init|=
name|FALSE
decl_stmt|;
name|bool
name|negotiation
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_setup_mac_link_multispeed_fiber"
argument_list|)
expr_stmt|;
comment|/* Mask off requested but non-supported speeds */
name|status
operator|=
name|ixgbe_get_link_capabilities
argument_list|(
name|hw
argument_list|,
operator|&
name|link_speed
argument_list|,
operator|&
name|negotiation
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|speed
operator|&=
name|link_speed
expr_stmt|;
comment|/* 	 * When the driver changes the link speeds that it can support, 	 * it sets autotry_restart to TRUE to indicate that we need to 	 * initiate a new autotry session with the link partner.  To do 	 * so, we set the speed then disable and re-enable the tx laser, to 	 * alert the link partner that it also needs to restart autotry on its 	 * end.  This is consistent with TRUE clause 37 autoneg, which also 	 * involves a loss of signal. 	 */
comment|/* 	 * Try each speed one by one, highest priority first.  We do this in 	 * software because 10gb fiber doesn't support speed autonegotiation. 	 */
if|if
condition|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_10GB_FULL
condition|)
block|{
name|speedcnt
operator|++
expr_stmt|;
name|highest_link_speed
operator|=
name|IXGBE_LINK_SPEED_10GB_FULL
expr_stmt|;
comment|/* If we already have link at this speed, just jump out */
name|status
operator|=
name|ixgbe_check_link
argument_list|(
name|hw
argument_list|,
operator|&
name|link_speed
argument_list|,
operator|&
name|link_up
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
if|if
condition|(
operator|(
name|link_speed
operator|==
name|IXGBE_LINK_SPEED_10GB_FULL
operator|)
operator|&&
name|link_up
condition|)
goto|goto
name|out
goto|;
comment|/* Set the module link speed */
name|esdp_reg
operator||=
operator|(
name|IXGBE_ESDP_SDP5_DIR
operator||
name|IXGBE_ESDP_SDP5
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|,
name|esdp_reg
argument_list|)
expr_stmt|;
comment|/* Allow module to change analog characteristics (1G->10G) */
name|msec_delay
argument_list|(
literal|40
argument_list|)
expr_stmt|;
name|status
operator|=
name|ixgbe_setup_mac_link_82599
argument_list|(
name|hw
argument_list|,
name|IXGBE_LINK_SPEED_10GB_FULL
argument_list|,
name|autoneg
argument_list|,
name|autoneg_wait_to_complete
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* Flap the tx laser if it has not already been done */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|autotry_restart
condition|)
block|{
comment|/* Disable tx laser; allow 100us to go dark per spec */
name|esdp_reg
operator||=
name|IXGBE_ESDP_SDP3
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|,
name|esdp_reg
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* Enable tx laser; allow 2ms to light up per spec */
name|esdp_reg
operator|&=
operator|~
name|IXGBE_ESDP_SDP3
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|,
name|esdp_reg
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|autotry_restart
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* 		 * Wait for the controller to acquire link.  Per IEEE 802.3ap, 		 * Section 73.10.2, we may have to wait up to 500ms if KR is 		 * attempted.  82599 uses the same timing for 10g SFI. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
comment|/* Wait for the link partner to also set speed */
name|msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* If we have link, just jump out */
name|status
operator|=
name|ixgbe_check_link
argument_list|(
name|hw
argument_list|,
operator|&
name|link_speed
argument_list|,
operator|&
name|link_up
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
if|if
condition|(
name|link_up
condition|)
goto|goto
name|out
goto|;
block|}
block|}
if|if
condition|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_1GB_FULL
condition|)
block|{
name|speedcnt
operator|++
expr_stmt|;
if|if
condition|(
name|highest_link_speed
operator|==
name|IXGBE_LINK_SPEED_UNKNOWN
condition|)
name|highest_link_speed
operator|=
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
comment|/* If we already have link at this speed, just jump out */
name|status
operator|=
name|ixgbe_check_link
argument_list|(
name|hw
argument_list|,
operator|&
name|link_speed
argument_list|,
operator|&
name|link_up
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
if|if
condition|(
operator|(
name|link_speed
operator|==
name|IXGBE_LINK_SPEED_1GB_FULL
operator|)
operator|&&
name|link_up
condition|)
goto|goto
name|out
goto|;
comment|/* Set the module link speed */
name|esdp_reg
operator|&=
operator|~
name|IXGBE_ESDP_SDP5
expr_stmt|;
name|esdp_reg
operator||=
name|IXGBE_ESDP_SDP5_DIR
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|,
name|esdp_reg
argument_list|)
expr_stmt|;
comment|/* Allow module to change analog characteristics (10G->1G) */
name|msec_delay
argument_list|(
literal|40
argument_list|)
expr_stmt|;
name|status
operator|=
name|ixgbe_setup_mac_link_82599
argument_list|(
name|hw
argument_list|,
name|IXGBE_LINK_SPEED_1GB_FULL
argument_list|,
name|autoneg
argument_list|,
name|autoneg_wait_to_complete
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* Flap the tx laser if it has not already been done */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|autotry_restart
condition|)
block|{
comment|/* Disable tx laser; allow 100us to go dark per spec */
name|esdp_reg
operator||=
name|IXGBE_ESDP_SDP3
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|,
name|esdp_reg
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* Enable tx laser; allow 2ms to light up per spec */
name|esdp_reg
operator|&=
operator|~
name|IXGBE_ESDP_SDP3
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|,
name|esdp_reg
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|autotry_restart
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* Wait for the link partner to also set speed */
name|msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* If we have link, just jump out */
name|status
operator|=
name|ixgbe_check_link
argument_list|(
name|hw
argument_list|,
operator|&
name|link_speed
argument_list|,
operator|&
name|link_up
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
if|if
condition|(
name|link_up
condition|)
goto|goto
name|out
goto|;
block|}
comment|/* 	 * We didn't get link.  Configure back to the highest speed we tried, 	 * (if there was more than one).  We call ourselves back with just the 	 * single highest speed that the user requested. 	 */
if|if
condition|(
name|speedcnt
operator|>
literal|1
condition|)
name|status
operator|=
name|ixgbe_setup_mac_link_multispeed_fiber
argument_list|(
name|hw
argument_list|,
name|highest_link_speed
argument_list|,
name|autoneg
argument_list|,
name|autoneg_wait_to_complete
argument_list|)
expr_stmt|;
name|out
label|:
comment|/* Set autoneg_advertised value based on input link speed */
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_10GB_FULL
condition|)
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator||=
name|IXGBE_LINK_SPEED_10GB_FULL
expr_stmt|;
if|if
condition|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_1GB_FULL
condition|)
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator||=
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_setup_mac_link_smartspeed - Set MAC link speed using SmartSpeed  *  @hw: pointer to hardware structure  *  @speed: new link speed  *  @autoneg: TRUE if autonegotiation enabled  *  @autoneg_wait_to_complete: TRUE when waiting for completion is needed  *  *  Implements the Intel SmartSpeed algorithm.  **/
end_comment

begin_function
name|s32
name|ixgbe_setup_mac_link_smartspeed
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
name|speed
parameter_list|,
name|bool
name|autoneg
parameter_list|,
name|bool
name|autoneg_wait_to_complete
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|ixgbe_link_speed
name|link_speed
decl_stmt|;
name|s32
name|i
decl_stmt|,
name|j
decl_stmt|;
name|bool
name|link_up
init|=
name|FALSE
decl_stmt|;
name|u32
name|autoc_reg
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC
argument_list|)
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_setup_mac_link_smartspeed"
argument_list|)
expr_stmt|;
comment|/* Set autoneg_advertised value based on input link speed */
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_10GB_FULL
condition|)
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator||=
name|IXGBE_LINK_SPEED_10GB_FULL
expr_stmt|;
if|if
condition|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_1GB_FULL
condition|)
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator||=
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
if|if
condition|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_100_FULL
condition|)
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator||=
name|IXGBE_LINK_SPEED_100_FULL
expr_stmt|;
comment|/* 	 * Implement Intel SmartSpeed algorithm.  SmartSpeed will reduce the 	 * autoneg advertisement if link is unable to be established at the 	 * highest negotiated rate.  This can sometimes happen due to integrity 	 * issues with the physical media connection. 	 */
comment|/* First, try to get link with full advertisement */
name|hw
operator|->
name|phy
operator|.
name|smart_speed_active
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|IXGBE_SMARTSPEED_MAX_RETRIES
condition|;
name|j
operator|++
control|)
block|{
name|status
operator|=
name|ixgbe_setup_mac_link_82599
argument_list|(
name|hw
argument_list|,
name|speed
argument_list|,
name|autoneg
argument_list|,
name|autoneg_wait_to_complete
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|out
goto|;
comment|/* 		 * Wait for the controller to acquire link.  Per IEEE 802.3ap, 		 * Section 73.10.2, we may have to wait up to 500ms if KR is 		 * attempted, or 200ms if KX/KX4/BX/BX4 is attempted, per 		 * Table 9 in the AN MAS. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* If we have link, just jump out */
name|status
operator|=
name|ixgbe_check_link
argument_list|(
name|hw
argument_list|,
operator|&
name|link_speed
argument_list|,
operator|&
name|link_up
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|link_up
condition|)
goto|goto
name|out
goto|;
block|}
block|}
comment|/* 	 * We didn't get link.  If we advertised KR plus one of KX4/KX 	 * (or BX4/BX), then disable KR and try again. 	 */
if|if
condition|(
operator|(
operator|(
name|autoc_reg
operator|&
name|IXGBE_AUTOC_KR_SUPP
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|autoc_reg
operator|&
name|IXGBE_AUTOC_KX4_KX_SUPP_MASK
operator|)
operator|==
literal|0
operator|)
condition|)
goto|goto
name|out
goto|;
comment|/* Turn SmartSpeed on to disable KR support */
name|hw
operator|->
name|phy
operator|.
name|smart_speed_active
operator|=
name|TRUE
expr_stmt|;
name|status
operator|=
name|ixgbe_setup_mac_link_82599
argument_list|(
name|hw
argument_list|,
name|speed
argument_list|,
name|autoneg
argument_list|,
name|autoneg_wait_to_complete
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Wait for the controller to acquire link.  600ms will allow for 	 * the AN link_fail_inhibit_timer as well for multiple cycles of 	 * parallel detect, both 10g and 1g. This allows for the maximum 	 * connect attempts as defined in the AN MAS table 73-7. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
name|msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* If we have link, just jump out */
name|status
operator|=
name|ixgbe_check_link
argument_list|(
name|hw
argument_list|,
operator|&
name|link_speed
argument_list|,
operator|&
name|link_up
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|link_up
condition|)
goto|goto
name|out
goto|;
block|}
comment|/* We didn't get link.  Turn SmartSpeed back off. */
name|hw
operator|->
name|phy
operator|.
name|smart_speed_active
operator|=
name|FALSE
expr_stmt|;
name|status
operator|=
name|ixgbe_setup_mac_link_82599
argument_list|(
name|hw
argument_list|,
name|speed
argument_list|,
name|autoneg
argument_list|,
name|autoneg_wait_to_complete
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_setup_mac_link_82599 - Set MAC link speed  *  @hw: pointer to hardware structure  *  @speed: new link speed  *  @autoneg: TRUE if autonegotiation enabled  *  @autoneg_wait_to_complete: TRUE when waiting for completion is needed  *  *  Set the link speed in the AUTOC register and restarts link.  **/
end_comment

begin_function
name|s32
name|ixgbe_setup_mac_link_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
name|speed
parameter_list|,
name|bool
name|autoneg
parameter_list|,
name|bool
name|autoneg_wait_to_complete
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u32
name|autoc
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC
argument_list|)
decl_stmt|;
name|u32
name|autoc2
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC2
argument_list|)
decl_stmt|;
name|u32
name|start_autoc
init|=
name|autoc
decl_stmt|;
name|u32
name|orig_autoc
init|=
literal|0
decl_stmt|;
name|u32
name|link_mode
init|=
name|autoc
operator|&
name|IXGBE_AUTOC_LMS_MASK
decl_stmt|;
name|u32
name|pma_pmd_1g
init|=
name|autoc
operator|&
name|IXGBE_AUTOC_1G_PMA_PMD_MASK
decl_stmt|;
name|u32
name|pma_pmd_10g_serial
init|=
name|autoc2
operator|&
name|IXGBE_AUTOC2_10G_SERIAL_PMA_PMD_MASK
decl_stmt|;
name|u32
name|links_reg
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|ixgbe_link_speed
name|link_capabilities
init|=
name|IXGBE_LINK_SPEED_UNKNOWN
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_setup_mac_link_82599"
argument_list|)
expr_stmt|;
comment|/* Check to see if speed passed in is supported. */
name|status
operator|=
name|ixgbe_get_link_capabilities
argument_list|(
name|hw
argument_list|,
operator|&
name|link_capabilities
argument_list|,
operator|&
name|autoneg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|out
goto|;
name|speed
operator|&=
name|link_capabilities
expr_stmt|;
if|if
condition|(
name|speed
operator|==
name|IXGBE_LINK_SPEED_UNKNOWN
condition|)
block|{
name|status
operator|=
name|IXGBE_ERR_LINK_SETUP
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Use stored value (EEPROM defaults) of AUTOC to find KR/KX4 support*/
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|orig_link_settings_stored
condition|)
name|orig_autoc
operator|=
name|hw
operator|->
name|mac
operator|.
name|orig_autoc
expr_stmt|;
else|else
name|orig_autoc
operator|=
name|autoc
expr_stmt|;
if|if
condition|(
name|link_mode
operator|==
name|IXGBE_AUTOC_LMS_KX4_KX_KR
operator|||
name|link_mode
operator|==
name|IXGBE_AUTOC_LMS_KX4_KX_KR_1G_AN
operator|||
name|link_mode
operator|==
name|IXGBE_AUTOC_LMS_KX4_KX_KR_SGMII
condition|)
block|{
comment|/* Set KX4/KX/KR support according to speed requested */
name|autoc
operator|&=
operator|~
operator|(
name|IXGBE_AUTOC_KX4_KX_SUPP_MASK
operator||
name|IXGBE_AUTOC_KR_SUPP
operator|)
expr_stmt|;
if|if
condition|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_10GB_FULL
condition|)
if|if
condition|(
name|orig_autoc
operator|&
name|IXGBE_AUTOC_KX4_SUPP
condition|)
name|autoc
operator||=
name|IXGBE_AUTOC_KX4_SUPP
expr_stmt|;
if|if
condition|(
operator|(
name|orig_autoc
operator|&
name|IXGBE_AUTOC_KR_SUPP
operator|)
operator|&&
operator|(
name|hw
operator|->
name|phy
operator|.
name|smart_speed_active
operator|==
name|FALSE
operator|)
condition|)
name|autoc
operator||=
name|IXGBE_AUTOC_KR_SUPP
expr_stmt|;
if|if
condition|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_1GB_FULL
condition|)
name|autoc
operator||=
name|IXGBE_AUTOC_KX_SUPP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|pma_pmd_1g
operator|==
name|IXGBE_AUTOC_1G_SFI
operator|)
operator|&&
operator|(
name|link_mode
operator|==
name|IXGBE_AUTOC_LMS_1G_LINK_NO_AN
operator|||
name|link_mode
operator|==
name|IXGBE_AUTOC_LMS_1G_AN
operator|)
condition|)
block|{
comment|/* Switch from 1G SFI to 10G SFI if requested */
if|if
condition|(
operator|(
name|speed
operator|==
name|IXGBE_LINK_SPEED_10GB_FULL
operator|)
operator|&&
operator|(
name|pma_pmd_10g_serial
operator|==
name|IXGBE_AUTOC2_10G_SFI
operator|)
condition|)
block|{
name|autoc
operator|&=
operator|~
name|IXGBE_AUTOC_LMS_MASK
expr_stmt|;
name|autoc
operator||=
name|IXGBE_AUTOC_LMS_10G_SERIAL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|pma_pmd_10g_serial
operator|==
name|IXGBE_AUTOC2_10G_SFI
operator|)
operator|&&
operator|(
name|link_mode
operator|==
name|IXGBE_AUTOC_LMS_10G_SERIAL
operator|)
condition|)
block|{
comment|/* Switch from 10G SFI to 1G SFI if requested */
if|if
condition|(
operator|(
name|speed
operator|==
name|IXGBE_LINK_SPEED_1GB_FULL
operator|)
operator|&&
operator|(
name|pma_pmd_1g
operator|==
name|IXGBE_AUTOC_1G_SFI
operator|)
condition|)
block|{
name|autoc
operator|&=
operator|~
name|IXGBE_AUTOC_LMS_MASK
expr_stmt|;
if|if
condition|(
name|autoneg
condition|)
name|autoc
operator||=
name|IXGBE_AUTOC_LMS_1G_AN
expr_stmt|;
else|else
name|autoc
operator||=
name|IXGBE_AUTOC_LMS_1G_LINK_NO_AN
expr_stmt|;
block|}
block|}
if|if
condition|(
name|autoc
operator|!=
name|start_autoc
condition|)
block|{
comment|/* Restart link */
name|autoc
operator||=
name|IXGBE_AUTOC_AN_RESTART
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC
argument_list|,
name|autoc
argument_list|)
expr_stmt|;
comment|/* Only poll for autoneg to complete if specified to do so */
if|if
condition|(
name|autoneg_wait_to_complete
condition|)
block|{
if|if
condition|(
name|link_mode
operator|==
name|IXGBE_AUTOC_LMS_KX4_KX_KR
operator|||
name|link_mode
operator|==
name|IXGBE_AUTOC_LMS_KX4_KX_KR_1G_AN
operator|||
name|link_mode
operator|==
name|IXGBE_AUTOC_LMS_KX4_KX_KR_SGMII
condition|)
block|{
name|links_reg
operator|=
literal|0
expr_stmt|;
comment|/*Just in case Autoneg time=0*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_AUTO_NEG_TIME
condition|;
name|i
operator|++
control|)
block|{
name|links_reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LINKS
argument_list|)
expr_stmt|;
if|if
condition|(
name|links_reg
operator|&
name|IXGBE_LINKS_KX_AN_COMP
condition|)
break|break;
name|msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|links_reg
operator|&
name|IXGBE_LINKS_KX_AN_COMP
operator|)
condition|)
block|{
name|status
operator|=
name|IXGBE_ERR_AUTONEG_NOT_COMPLETE
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Autoneg did not complete.\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Add delay to filter out noises during initial link setup */
name|msec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
name|out
label|:
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_setup_copper_link_82599 - Set the PHY autoneg advertised field  *  @hw: pointer to hardware structure  *  @speed: new link speed  *  @autoneg: TRUE if autonegotiation enabled  *  @autoneg_wait_to_complete: TRUE if waiting is needed to complete  *  *  Restarts link on PHY and MAC based on settings passed in.  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_setup_copper_link_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
name|speed
parameter_list|,
name|bool
name|autoneg
parameter_list|,
name|bool
name|autoneg_wait_to_complete
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_setup_copper_link_82599"
argument_list|)
expr_stmt|;
comment|/* Setup the PHY according to input speed */
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|setup_link_speed
argument_list|(
name|hw
argument_list|,
name|speed
argument_list|,
name|autoneg
argument_list|,
name|autoneg_wait_to_complete
argument_list|)
expr_stmt|;
comment|/* Set up MAC */
name|ixgbe_start_mac_link_82599
argument_list|(
name|hw
argument_list|,
name|autoneg_wait_to_complete
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_reset_hw_82599 - Perform hardware reset  *  @hw: pointer to hardware structure  *  *  Resets the hardware by resetting the transmit and receive units, masks  *  and clears all interrupts, perform a PHY reset, and perform a link (MAC)  *  reset.  **/
end_comment

begin_function
name|s32
name|ixgbe_reset_hw_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u32
name|ctrl
decl_stmt|,
name|ctrl_ext
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|u32
name|autoc
decl_stmt|;
name|u32
name|autoc2
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_reset_hw_82599"
argument_list|)
expr_stmt|;
comment|/* Call adapter stop to disable tx/rx and clear interrupts */
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|stop_adapter
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* PHY ops must be identified and initialized prior to reset */
comment|/* Identify PHY and related function pointers */
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|init
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|IXGBE_ERR_SFP_NOT_SUPPORTED
condition|)
goto|goto
name|reset_hw_out
goto|;
comment|/* Setup SFP module if there is one present. */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|sfp_setup_needed
condition|)
block|{
name|status
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|setup_sfp
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|sfp_setup_needed
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|==
name|IXGBE_ERR_SFP_NOT_SUPPORTED
condition|)
goto|goto
name|reset_hw_out
goto|;
comment|/* Reset PHY */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|reset_disable
operator|==
name|FALSE
operator|&&
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|reset
operator|!=
name|NULL
condition|)
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|reset
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* 	 * Prevent the PCI-E bus from from hanging by disabling PCI-E master 	 * access and verify no pending requests before reset 	 */
name|status
operator|=
name|ixgbe_disable_pcie_master
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
block|{
name|status
operator|=
name|IXGBE_ERR_MASTER_REQUESTS_PENDING
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"PCI-E Master disable polling has failed.\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Issue global reset to the MAC.  This needs to be a SW reset. 	 * If link reset is used, it might reset the MAC when mng is using it 	 */
name|ctrl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CTRL
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CTRL
argument_list|,
operator|(
name|ctrl
operator||
name|IXGBE_CTRL_RST
operator|)
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Poll for reset bit to self-clear indicating reset is complete */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ctrl
operator|&
name|IXGBE_CTRL_RST
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|ctrl
operator|&
name|IXGBE_CTRL_RST
condition|)
block|{
name|status
operator|=
name|IXGBE_ERR_RESET_FAILED
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Reset polling failed to complete.\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Clear PF Reset Done bit so PF/VF Mail Ops can work */
name|ctrl_ext
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CTRL_EXT
argument_list|)
expr_stmt|;
name|ctrl_ext
operator||=
name|IXGBE_CTRL_EXT_PFRSTD
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CTRL_EXT
argument_list|,
name|ctrl_ext
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
comment|/* 	 * Store the original AUTOC/AUTOC2 values if they have not been 	 * stored off yet.  Otherwise restore the stored original 	 * values since the reset operation sets back to defaults. 	 */
name|autoc
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC
argument_list|)
expr_stmt|;
name|autoc2
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC2
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|orig_link_settings_stored
operator|==
name|FALSE
condition|)
block|{
name|hw
operator|->
name|mac
operator|.
name|orig_autoc
operator|=
name|autoc
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|orig_autoc2
operator|=
name|autoc2
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|orig_link_settings_stored
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|autoc
operator|!=
name|hw
operator|->
name|mac
operator|.
name|orig_autoc
condition|)
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC
argument_list|,
operator|(
name|hw
operator|->
name|mac
operator|.
name|orig_autoc
operator||
name|IXGBE_AUTOC_AN_RESTART
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|autoc2
operator|&
name|IXGBE_AUTOC2_UPPER_MASK
operator|)
operator|!=
operator|(
name|hw
operator|->
name|mac
operator|.
name|orig_autoc2
operator|&
name|IXGBE_AUTOC2_UPPER_MASK
operator|)
condition|)
block|{
name|autoc2
operator|&=
operator|~
name|IXGBE_AUTOC2_UPPER_MASK
expr_stmt|;
name|autoc2
operator||=
operator|(
name|hw
operator|->
name|mac
operator|.
name|orig_autoc2
operator|&
name|IXGBE_AUTOC2_UPPER_MASK
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC2
argument_list|,
name|autoc2
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Store the permanent mac address */
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|get_mac_addr
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|perm_addr
argument_list|)
expr_stmt|;
comment|/* 	 * Store MAC address from RAR0, clear receive address registers, and 	 * clear the multicast table.  Also reset num_rar_entries to 128, 	 * since we modify this value when programming the SAN MAC address. 	 */
name|hw
operator|->
name|mac
operator|.
name|num_rar_entries
operator|=
literal|128
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|init_rx_addrs
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Store the permanent SAN mac address */
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|get_san_mac_addr
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|san_addr
argument_list|)
expr_stmt|;
comment|/* Add the SAN MAC address to the RAR only if it's a valid address */
if|if
condition|(
name|ixgbe_validate_mac_addr
argument_list|(
name|hw
operator|->
name|mac
operator|.
name|san_addr
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|set_rar
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|num_rar_entries
operator|-
literal|1
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|san_addr
argument_list|,
literal|0
argument_list|,
name|IXGBE_RAH_AV
argument_list|)
expr_stmt|;
comment|/* Reserve the last RAR for the SAN MAC address */
name|hw
operator|->
name|mac
operator|.
name|num_rar_entries
operator|--
expr_stmt|;
block|}
comment|/* Store the alternative WWNN/WWPN prefix */
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|get_wwn_prefix
argument_list|(
name|hw
argument_list|,
operator|&
name|hw
operator|->
name|mac
operator|.
name|wwnn_prefix
argument_list|,
operator|&
name|hw
operator|->
name|mac
operator|.
name|wwpn_prefix
argument_list|)
expr_stmt|;
name|reset_hw_out
label|:
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_reinit_fdir_tables_82599 - Reinitialize Flow Director tables.  *  @hw: pointer to hardware structure  **/
end_comment

begin_function
name|s32
name|ixgbe_reinit_fdir_tables_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u32
name|fdirctrl
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRCTRL
argument_list|)
decl_stmt|;
name|fdirctrl
operator|&=
operator|~
name|IXGBE_FDIRCTRL_INIT_DONE
expr_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_reinit_fdir_tables_82599"
argument_list|)
expr_stmt|;
comment|/* 	 * Before starting reinitialization process, 	 * FDIRCMD.CMD must be zero. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_FDIRCMD_CMD_POLL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRCMD
argument_list|)
operator|&
name|IXGBE_FDIRCMD_CMD_MASK
operator|)
condition|)
break|break;
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>=
name|IXGBE_FDIRCMD_CMD_POLL
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Flow Director previous command isn't complete, "
literal|"aborting table re-initialization. \n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_FDIR_REINIT_FAILED
return|;
block|}
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRFREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* 	 * 82599 adapters flow director init flow cannot be restarted, 	 * Workaround 82599 silicon errata by performing the following steps 	 * before re-writing the FDIRCTRL control register with the same value. 	 * - write 1 to bit 8 of FDIRCMD register& 	 * - write 0 to bit 8 of FDIRCMD register 	 */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRCMD
argument_list|,
operator|(
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRCMD
argument_list|)
operator||
name|IXGBE_FDIRCMD_CLEARHT
operator|)
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRCMD
argument_list|,
operator|(
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRCMD
argument_list|)
operator|&
operator|~
name|IXGBE_FDIRCMD_CLEARHT
operator|)
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* 	 * Clear FDIR Hash register to clear any leftover hashes 	 * waiting to be programmed. 	 */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRHASH
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRCTRL
argument_list|,
name|fdirctrl
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Poll init-done after we write FDIRCTRL register */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_FDIR_INIT_DONE_POLL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRCTRL
argument_list|)
operator|&
name|IXGBE_FDIRCTRL_INIT_DONE
condition|)
break|break;
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>=
name|IXGBE_FDIR_INIT_DONE_POLL
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Flow Director Signature poll time exceeded!\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_FDIR_REINIT_FAILED
return|;
block|}
comment|/* Clear FDIR statistics registers (read to clear) */
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRUSTAT
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRFSTAT
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRMATCH
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRMISS
argument_list|)
expr_stmt|;
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRLEN
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_init_fdir_signature_82599 - Initialize Flow Director signature filters  *  @hw: pointer to hardware structure  *  @pballoc: which mode to allocate filters with  **/
end_comment

begin_function
name|s32
name|ixgbe_init_fdir_signature_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|pballoc
parameter_list|)
block|{
name|u32
name|fdirctrl
init|=
literal|0
decl_stmt|;
name|u32
name|pbsize
decl_stmt|;
name|int
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_init_fdir_signature_82599"
argument_list|)
expr_stmt|;
comment|/* 	 * Before enabling Flow Director, the Rx Packet Buffer size 	 * must be reduced.  The new value is the current size minus 	 * flow director memory usage size. 	 */
name|pbsize
operator|=
operator|(
literal|1
operator|<<
operator|(
name|IXGBE_FDIR_PBALLOC_SIZE_SHIFT
operator|+
name|pballoc
operator|)
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXPBSIZE
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|(
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXPBSIZE
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|-
name|pbsize
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * The defaults in the HW for RX PB 1-7 are not zero and so should be 	 * intialized to zero for non DCB mode otherwise actual total RX PB 	 * would be bigger than programmed and filter space would run into 	 * the PB 0 region. 	 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXPBSIZE
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Send interrupt when 64 filters are left */
name|fdirctrl
operator||=
literal|4
operator|<<
name|IXGBE_FDIRCTRL_FULL_THRESH_SHIFT
expr_stmt|;
comment|/* Set the maximum length per hash bucket to 0xA filters */
name|fdirctrl
operator||=
literal|0xA
operator|<<
name|IXGBE_FDIRCTRL_MAX_LENGTH_SHIFT
expr_stmt|;
switch|switch
condition|(
name|pballoc
condition|)
block|{
case|case
name|IXGBE_FDIR_PBALLOC_64K
case|:
comment|/* 8k - 1 signature filters */
name|fdirctrl
operator||=
name|IXGBE_FDIRCTRL_PBALLOC_64K
expr_stmt|;
break|break;
case|case
name|IXGBE_FDIR_PBALLOC_128K
case|:
comment|/* 16k - 1 signature filters */
name|fdirctrl
operator||=
name|IXGBE_FDIRCTRL_PBALLOC_128K
expr_stmt|;
break|break;
case|case
name|IXGBE_FDIR_PBALLOC_256K
case|:
comment|/* 32k - 1 signature filters */
name|fdirctrl
operator||=
name|IXGBE_FDIRCTRL_PBALLOC_256K
expr_stmt|;
break|break;
default|default:
comment|/* bad value */
return|return
name|IXGBE_ERR_CONFIG
return|;
block|}
empty_stmt|;
comment|/* Move the flexible bytes to use the ethertype - shift 6 words */
name|fdirctrl
operator||=
operator|(
literal|0x6
operator|<<
name|IXGBE_FDIRCTRL_FLEX_SHIFT
operator|)
expr_stmt|;
comment|/* Prime the keys for hashing */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRHKEY
argument_list|,
name|IXGBE_HTONL
argument_list|(
name|IXGBE_ATR_BUCKET_HASH_KEY
argument_list|)
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRSKEY
argument_list|,
name|IXGBE_HTONL
argument_list|(
name|IXGBE_ATR_SIGNATURE_HASH_KEY
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Poll init-done after we write the register.  Estimated times: 	 *      10G: PBALLOC = 11b, timing is 60us 	 *       1G: PBALLOC = 11b, timing is 600us 	 *     100M: PBALLOC = 11b, timing is 6ms 	 * 	 *     Multiple these timings by 4 if under full Rx load 	 * 	 * So we'll poll for IXGBE_FDIR_INIT_DONE_POLL times, sleeping for 	 * 1 msec per poll time.  If we're at line rate and drop to 100M, then 	 * this might not finish in our poll time, but we can live with that 	 * for now. 	 */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRCTRL
argument_list|,
name|fdirctrl
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_FDIR_INIT_DONE_POLL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRCTRL
argument_list|)
operator|&
name|IXGBE_FDIRCTRL_INIT_DONE
condition|)
break|break;
name|msec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>=
name|IXGBE_FDIR_INIT_DONE_POLL
condition|)
name|DEBUGOUT
argument_list|(
literal|"Flow Director Signature poll time exceeded!\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_init_fdir_perfect_82599 - Initialize Flow Director perfect filters  *  @hw: pointer to hardware structure  *  @pballoc: which mode to allocate filters with  **/
end_comment

begin_function
name|s32
name|ixgbe_init_fdir_perfect_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|pballoc
parameter_list|)
block|{
name|u32
name|fdirctrl
init|=
literal|0
decl_stmt|;
name|u32
name|pbsize
decl_stmt|;
name|int
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_init_fdir_perfect_82599"
argument_list|)
expr_stmt|;
comment|/* 	 * Before enabling Flow Director, the Rx Packet Buffer size 	 * must be reduced.  The new value is the current size minus 	 * flow director memory usage size. 	 */
name|pbsize
operator|=
operator|(
literal|1
operator|<<
operator|(
name|IXGBE_FDIR_PBALLOC_SIZE_SHIFT
operator|+
name|pballoc
operator|)
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXPBSIZE
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|(
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXPBSIZE
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|-
name|pbsize
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * The defaults in the HW for RX PB 1-7 are not zero and so should be 	 * intialized to zero for non DCB mode otherwise actual total RX PB 	 * would be bigger than programmed and filter space would run into 	 * the PB 0 region. 	 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXPBSIZE
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Send interrupt when 64 filters are left */
name|fdirctrl
operator||=
literal|4
operator|<<
name|IXGBE_FDIRCTRL_FULL_THRESH_SHIFT
expr_stmt|;
switch|switch
condition|(
name|pballoc
condition|)
block|{
case|case
name|IXGBE_FDIR_PBALLOC_64K
case|:
comment|/* 2k - 1 perfect filters */
name|fdirctrl
operator||=
name|IXGBE_FDIRCTRL_PBALLOC_64K
expr_stmt|;
break|break;
case|case
name|IXGBE_FDIR_PBALLOC_128K
case|:
comment|/* 4k - 1 perfect filters */
name|fdirctrl
operator||=
name|IXGBE_FDIRCTRL_PBALLOC_128K
expr_stmt|;
break|break;
case|case
name|IXGBE_FDIR_PBALLOC_256K
case|:
comment|/* 8k - 1 perfect filters */
name|fdirctrl
operator||=
name|IXGBE_FDIRCTRL_PBALLOC_256K
expr_stmt|;
break|break;
default|default:
comment|/* bad value */
return|return
name|IXGBE_ERR_CONFIG
return|;
block|}
empty_stmt|;
comment|/* Turn perfect match filtering on */
name|fdirctrl
operator||=
name|IXGBE_FDIRCTRL_PERFECT_MATCH
expr_stmt|;
name|fdirctrl
operator||=
name|IXGBE_FDIRCTRL_REPORT_STATUS
expr_stmt|;
comment|/* Move the flexible bytes to use the ethertype - shift 6 words */
name|fdirctrl
operator||=
operator|(
literal|0x6
operator|<<
name|IXGBE_FDIRCTRL_FLEX_SHIFT
operator|)
expr_stmt|;
comment|/* Prime the keys for hashing */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRHKEY
argument_list|,
name|IXGBE_HTONL
argument_list|(
name|IXGBE_ATR_BUCKET_HASH_KEY
argument_list|)
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRSKEY
argument_list|,
name|IXGBE_HTONL
argument_list|(
name|IXGBE_ATR_SIGNATURE_HASH_KEY
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Poll init-done after we write the register.  Estimated times: 	 *      10G: PBALLOC = 11b, timing is 60us 	 *       1G: PBALLOC = 11b, timing is 600us 	 *     100M: PBALLOC = 11b, timing is 6ms 	 * 	 *     Multiple these timings by 4 if under full Rx load 	 * 	 * So we'll poll for IXGBE_FDIR_INIT_DONE_POLL times, sleeping for 	 * 1 msec per poll time.  If we're at line rate and drop to 100M, then 	 * this might not finish in our poll time, but we can live with that 	 * for now. 	 */
comment|/* Set the maximum length per hash bucket to 0xA filters */
name|fdirctrl
operator||=
operator|(
literal|0xA
operator|<<
name|IXGBE_FDIRCTRL_MAX_LENGTH_SHIFT
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRCTRL
argument_list|,
name|fdirctrl
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_FDIR_INIT_DONE_POLL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRCTRL
argument_list|)
operator|&
name|IXGBE_FDIRCTRL_INIT_DONE
condition|)
break|break;
name|msec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>=
name|IXGBE_FDIR_INIT_DONE_POLL
condition|)
name|DEBUGOUT
argument_list|(
literal|"Flow Director Perfect poll time exceeded!\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_atr_compute_hash_82599 - Compute the hashes for SW ATR  *  @stream: input bitstream to compute the hash on  *  @key: 32-bit hash key  **/
end_comment

begin_function
name|u16
name|ixgbe_atr_compute_hash_82599
parameter_list|(
name|struct
name|ixgbe_atr_input
modifier|*
name|atr_input
parameter_list|,
name|u32
name|key
parameter_list|)
block|{
comment|/* 	 * The algorithm is as follows: 	 *    Hash[15:0] = Sum { S[n] x K[n+16] }, n = 0...350 	 *    where Sum {A[n]}, n = 0...n is bitwise XOR of A[0], A[1]...A[n] 	 *    and A[n] x B[n] is bitwise AND between same length strings 	 * 	 *    K[n] is 16 bits, defined as: 	 *       for n modulo 32>= 15, K[n] = K[n % 32 : (n % 32) - 15] 	 *       for n modulo 32< 15, K[n] = 	 *             K[(n % 32:0) | (31:31 - (14 - (n % 32)))] 	 * 	 *    S[n] is 16 bits, defined as: 	 *       for n>= 15, S[n] = S[n:n - 15] 	 *       for n< 15, S[n] = S[(n:0) | (350:350 - (14 - n))] 	 * 	 *    To simplify for programming, the algorithm is implemented 	 *    in software this way: 	 * 	 *    Key[31:0], Stream[335:0] 	 * 	 *    tmp_key[11 * 32 - 1:0] = 11{Key[31:0] = key concatenated 11 times 	 *    int_key[350:0] = tmp_key[351:1] 	 *    int_stream[365:0] = Stream[14:0] | Stream[335:0] | Stream[335:321] 	 * 	 *    hash[15:0] = 0; 	 *    for (i = 0; i< 351; i++) { 	 *        if (int_key[i]) 	 *            hash ^= int_stream[(i + 15):i]; 	 *    } 	 */
union|union
block|{
name|u64
name|fill
index|[
literal|6
index|]
decl_stmt|;
name|u32
name|key
index|[
literal|11
index|]
decl_stmt|;
name|u8
name|key_stream
index|[
literal|44
index|]
decl_stmt|;
block|}
name|tmp_key
union|;
name|u8
modifier|*
name|stream
init|=
operator|(
name|u8
operator|*
operator|)
name|atr_input
decl_stmt|;
name|u8
name|int_key
index|[
literal|44
index|]
decl_stmt|;
comment|/* upper-most bit unused */
name|u8
name|hash_str
index|[
literal|46
index|]
decl_stmt|;
comment|/* upper-most 2 bits unused */
name|u16
name|hash_result
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|h
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_atr_compute_hash_82599"
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the fill member to prevent warnings 	 * on some compilers 	 */
name|tmp_key
operator|.
name|fill
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* First load the temporary key stream */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
name|u64
name|fillkey
init|=
operator|(
operator|(
name|u64
operator|)
name|key
operator|<<
literal|32
operator|)
operator||
name|key
decl_stmt|;
name|tmp_key
operator|.
name|fill
index|[
name|i
index|]
operator|=
name|fillkey
expr_stmt|;
block|}
comment|/* 	 * Set the interim key for the hashing.  Bit 352 is unused, so we must 	 * shift and compensate when building the key. 	 */
name|int_key
index|[
literal|0
index|]
operator|=
name|tmp_key
operator|.
name|key_stream
index|[
literal|0
index|]
operator|>>
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
literal|44
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|this_key
init|=
name|tmp_key
operator|.
name|key_stream
index|[
name|j
index|]
operator|<<
literal|7
decl_stmt|;
name|j
operator|++
expr_stmt|;
name|int_key
index|[
name|i
index|]
operator|=
call|(
name|u8
call|)
argument_list|(
name|this_key
operator||
operator|(
name|tmp_key
operator|.
name|key_stream
index|[
name|j
index|]
operator|>>
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set the interim bit string for the hashing.  Bits 368 and 367 are 	 * unused, so shift and compensate when building the string. 	 */
name|hash_str
index|[
literal|0
index|]
operator|=
operator|(
name|stream
index|[
literal|40
index|]
operator|&
literal|0x7f
operator|)
operator|>>
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|j
operator|=
literal|40
init|;
name|i
operator|<
literal|46
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|this_str
init|=
name|stream
index|[
name|j
index|]
operator|<<
literal|7
decl_stmt|;
name|j
operator|++
expr_stmt|;
if|if
condition|(
name|j
operator|>
literal|41
condition|)
name|j
operator|=
literal|0
expr_stmt|;
name|hash_str
index|[
name|i
index|]
operator|=
call|(
name|u8
call|)
argument_list|(
name|this_str
operator||
operator|(
name|stream
index|[
name|j
index|]
operator|>>
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now compute the hash.  i is the index into hash_str, j is into our 	 * key stream, k is counting the number of bits, and h interates within 	 * each byte. 	 */
for|for
control|(
name|i
operator|=
literal|45
operator|,
name|j
operator|=
literal|43
operator|,
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|351
operator|&&
name|i
operator|>=
literal|2
operator|&&
name|j
operator|>=
literal|0
condition|;
name|i
operator|--
operator|,
name|j
operator|--
control|)
block|{
for|for
control|(
name|h
operator|=
literal|0
init|;
name|h
operator|<
literal|8
operator|&&
name|k
operator|<
literal|351
condition|;
name|h
operator|++
operator|,
name|k
operator|++
control|)
block|{
if|if
condition|(
name|int_key
index|[
name|j
index|]
operator|&
operator|(
literal|1
operator|<<
name|h
operator|)
condition|)
block|{
comment|/* 				 * Key bit is set, XOR in the current 16-bit 				 * string.  Example of processing: 				 *    h = 0, 				 *      tmp = (hash_str[i - 2]& 0<< 16) | 				 *            (hash_str[i - 1]& 0xff<< 8) | 				 *            (hash_str[i]& 0xff>> 0) 				 *      So tmp = hash_str[15 + k:k], since the 				 *      i + 2 clause rolls off the 16-bit value 				 *    h = 7, 				 *      tmp = (hash_str[i - 2]& 0x7f<< 9) | 				 *            (hash_str[i - 1]& 0xff<< 1) | 				 *            (hash_str[i]& 0x80>> 7) 				 */
name|int
name|tmp
init|=
operator|(
name|hash_str
index|[
name|i
index|]
operator|>>
name|h
operator|)
decl_stmt|;
name|tmp
operator||=
operator|(
name|hash_str
index|[
name|i
operator|-
literal|1
index|]
operator|<<
operator|(
literal|8
operator|-
name|h
operator|)
operator|)
expr_stmt|;
name|tmp
operator||=
call|(
name|int
call|)
argument_list|(
name|hash_str
index|[
name|i
operator|-
literal|2
index|]
operator|&
operator|(
operator|(
literal|1
operator|<<
name|h
operator|)
operator|-
literal|1
operator|)
argument_list|)
operator|<<
operator|(
literal|16
operator|-
name|h
operator|)
expr_stmt|;
name|hash_result
operator|^=
operator|(
name|u16
operator|)
name|tmp
expr_stmt|;
block|}
block|}
block|}
return|return
name|hash_result
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_atr_set_vlan_id_82599 - Sets the VLAN id in the ATR input stream  *  @input: input stream to modify  *  @vlan: the VLAN id to load  **/
end_comment

begin_function
name|s32
name|ixgbe_atr_set_vlan_id_82599
parameter_list|(
name|struct
name|ixgbe_atr_input
modifier|*
name|input
parameter_list|,
name|u16
name|vlan
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_atr_set_vlan_id_82599"
argument_list|)
expr_stmt|;
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_VLAN_OFFSET
operator|+
literal|1
index|]
operator|=
name|vlan
operator|>>
literal|8
expr_stmt|;
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_VLAN_OFFSET
index|]
operator|=
name|vlan
operator|&
literal|0xff
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_atr_set_src_ipv4_82599 - Sets the source IPv4 address  *  @input: input stream to modify  *  @src_addr: the IP address to load  **/
end_comment

begin_function
name|s32
name|ixgbe_atr_set_src_ipv4_82599
parameter_list|(
name|struct
name|ixgbe_atr_input
modifier|*
name|input
parameter_list|,
name|u32
name|src_addr
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_atr_set_src_ipv4_82599"
argument_list|)
expr_stmt|;
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_SRC_IPV4_OFFSET
operator|+
literal|3
index|]
operator|=
name|src_addr
operator|>>
literal|24
expr_stmt|;
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_SRC_IPV4_OFFSET
operator|+
literal|2
index|]
operator|=
operator|(
name|src_addr
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_SRC_IPV4_OFFSET
operator|+
literal|1
index|]
operator|=
operator|(
name|src_addr
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_SRC_IPV4_OFFSET
index|]
operator|=
name|src_addr
operator|&
literal|0xff
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_atr_set_dst_ipv4_82599 - Sets the destination IPv4 address  *  @input: input stream to modify  *  @dst_addr: the IP address to load  **/
end_comment

begin_function
name|s32
name|ixgbe_atr_set_dst_ipv4_82599
parameter_list|(
name|struct
name|ixgbe_atr_input
modifier|*
name|input
parameter_list|,
name|u32
name|dst_addr
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_atr_set_dst_ipv4_82599"
argument_list|)
expr_stmt|;
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_DST_IPV4_OFFSET
operator|+
literal|3
index|]
operator|=
name|dst_addr
operator|>>
literal|24
expr_stmt|;
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_DST_IPV4_OFFSET
operator|+
literal|2
index|]
operator|=
operator|(
name|dst_addr
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_DST_IPV4_OFFSET
operator|+
literal|1
index|]
operator|=
operator|(
name|dst_addr
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_DST_IPV4_OFFSET
index|]
operator|=
name|dst_addr
operator|&
literal|0xff
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_atr_set_src_ipv6_82599 - Sets the source IPv6 address  *  @input: input stream to modify  *  @src_addr_1: the first 4 bytes of the IP address to load  *  @src_addr_2: the second 4 bytes of the IP address to load  *  @src_addr_3: the third 4 bytes of the IP address to load  *  @src_addr_4: the fourth 4 bytes of the IP address to load  **/
end_comment

begin_function
name|s32
name|ixgbe_atr_set_src_ipv6_82599
parameter_list|(
name|struct
name|ixgbe_atr_input
modifier|*
name|input
parameter_list|,
name|u32
name|src_addr_1
parameter_list|,
name|u32
name|src_addr_2
parameter_list|,
name|u32
name|src_addr_3
parameter_list|,
name|u32
name|src_addr_4
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_atr_set_src_ipv6_82599"
argument_list|)
expr_stmt|;
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_SRC_IPV6_OFFSET
index|]
operator|=
name|src_addr_4
operator|&
literal|0xff
expr_stmt|;
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_SRC_IPV6_OFFSET
operator|+
literal|1
index|]
operator|=
operator|(
name|src_addr_4
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_SRC_IPV6_OFFSET
operator|+
literal|2
index|]
operator|=
operator|(
name|src_addr_4
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_SRC_IPV6_OFFSET
operator|+
literal|3
index|]
operator|=
name|src_addr_4
operator|>>
literal|24
expr_stmt|;
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_SRC_IPV6_OFFSET
operator|+
literal|4
index|]
operator|=
name|src_addr_3
operator|&
literal|0xff
expr_stmt|;
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_SRC_IPV6_OFFSET
operator|+
literal|5
index|]
operator|=
operator|(
name|src_addr_3
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_SRC_IPV6_OFFSET
operator|+
literal|6
index|]
operator|=
operator|(
name|src_addr_3
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_SRC_IPV6_OFFSET
operator|+
literal|7
index|]
operator|=
name|src_addr_3
operator|>>
literal|24
expr_stmt|;
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_SRC_IPV6_OFFSET
operator|+
literal|8
index|]
operator|=
name|src_addr_2
operator|&
literal|0xff
expr_stmt|;
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_SRC_IPV6_OFFSET
operator|+
literal|9
index|]
operator|=
operator|(
name|src_addr_2
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_SRC_IPV6_OFFSET
operator|+
literal|10
index|]
operator|=
operator|(
name|src_addr_2
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_SRC_IPV6_OFFSET
operator|+
literal|11
index|]
operator|=
name|src_addr_2
operator|>>
literal|24
expr_stmt|;
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_SRC_IPV6_OFFSET
operator|+
literal|12
index|]
operator|=
name|src_addr_1
operator|&
literal|0xff
expr_stmt|;
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_SRC_IPV6_OFFSET
operator|+
literal|13
index|]
operator|=
operator|(
name|src_addr_1
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_SRC_IPV6_OFFSET
operator|+
literal|14
index|]
operator|=
operator|(
name|src_addr_1
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_SRC_IPV6_OFFSET
operator|+
literal|15
index|]
operator|=
name|src_addr_1
operator|>>
literal|24
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_atr_set_dst_ipv6_82599 - Sets the destination IPv6 address  *  @input: input stream to modify  *  @dst_addr_1: the first 4 bytes of the IP address to load  *  @dst_addr_2: the second 4 bytes of the IP address to load  *  @dst_addr_3: the third 4 bytes of the IP address to load  *  @dst_addr_4: the fourth 4 bytes of the IP address to load  **/
end_comment

begin_function
name|s32
name|ixgbe_atr_set_dst_ipv6_82599
parameter_list|(
name|struct
name|ixgbe_atr_input
modifier|*
name|input
parameter_list|,
name|u32
name|dst_addr_1
parameter_list|,
name|u32
name|dst_addr_2
parameter_list|,
name|u32
name|dst_addr_3
parameter_list|,
name|u32
name|dst_addr_4
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_atr_set_dst_ipv6_82599"
argument_list|)
expr_stmt|;
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_DST_IPV6_OFFSET
index|]
operator|=
name|dst_addr_4
operator|&
literal|0xff
expr_stmt|;
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_DST_IPV6_OFFSET
operator|+
literal|1
index|]
operator|=
operator|(
name|dst_addr_4
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_DST_IPV6_OFFSET
operator|+
literal|2
index|]
operator|=
operator|(
name|dst_addr_4
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_DST_IPV6_OFFSET
operator|+
literal|3
index|]
operator|=
name|dst_addr_4
operator|>>
literal|24
expr_stmt|;
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_DST_IPV6_OFFSET
operator|+
literal|4
index|]
operator|=
name|dst_addr_3
operator|&
literal|0xff
expr_stmt|;
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_DST_IPV6_OFFSET
operator|+
literal|5
index|]
operator|=
operator|(
name|dst_addr_3
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_DST_IPV6_OFFSET
operator|+
literal|6
index|]
operator|=
operator|(
name|dst_addr_3
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_DST_IPV6_OFFSET
operator|+
literal|7
index|]
operator|=
name|dst_addr_3
operator|>>
literal|24
expr_stmt|;
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_DST_IPV6_OFFSET
operator|+
literal|8
index|]
operator|=
name|dst_addr_2
operator|&
literal|0xff
expr_stmt|;
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_DST_IPV6_OFFSET
operator|+
literal|9
index|]
operator|=
operator|(
name|dst_addr_2
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_DST_IPV6_OFFSET
operator|+
literal|10
index|]
operator|=
operator|(
name|dst_addr_2
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_DST_IPV6_OFFSET
operator|+
literal|11
index|]
operator|=
name|dst_addr_2
operator|>>
literal|24
expr_stmt|;
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_DST_IPV6_OFFSET
operator|+
literal|12
index|]
operator|=
name|dst_addr_1
operator|&
literal|0xff
expr_stmt|;
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_DST_IPV6_OFFSET
operator|+
literal|13
index|]
operator|=
operator|(
name|dst_addr_1
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_DST_IPV6_OFFSET
operator|+
literal|14
index|]
operator|=
operator|(
name|dst_addr_1
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_DST_IPV6_OFFSET
operator|+
literal|15
index|]
operator|=
name|dst_addr_1
operator|>>
literal|24
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_atr_set_src_port_82599 - Sets the source port  *  @input: input stream to modify  *  @src_port: the source port to load  **/
end_comment

begin_function
name|s32
name|ixgbe_atr_set_src_port_82599
parameter_list|(
name|struct
name|ixgbe_atr_input
modifier|*
name|input
parameter_list|,
name|u16
name|src_port
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_atr_set_src_port_82599"
argument_list|)
expr_stmt|;
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_SRC_PORT_OFFSET
operator|+
literal|1
index|]
operator|=
name|src_port
operator|>>
literal|8
expr_stmt|;
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_SRC_PORT_OFFSET
index|]
operator|=
name|src_port
operator|&
literal|0xff
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_atr_set_dst_port_82599 - Sets the destination port  *  @input: input stream to modify  *  @dst_port: the destination port to load  **/
end_comment

begin_function
name|s32
name|ixgbe_atr_set_dst_port_82599
parameter_list|(
name|struct
name|ixgbe_atr_input
modifier|*
name|input
parameter_list|,
name|u16
name|dst_port
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_atr_set_dst_port_82599"
argument_list|)
expr_stmt|;
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_DST_PORT_OFFSET
operator|+
literal|1
index|]
operator|=
name|dst_port
operator|>>
literal|8
expr_stmt|;
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_DST_PORT_OFFSET
index|]
operator|=
name|dst_port
operator|&
literal|0xff
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_atr_set_flex_byte_82599 - Sets the flexible bytes  *  @input: input stream to modify  *  @flex_bytes: the flexible bytes to load  **/
end_comment

begin_function
name|s32
name|ixgbe_atr_set_flex_byte_82599
parameter_list|(
name|struct
name|ixgbe_atr_input
modifier|*
name|input
parameter_list|,
name|u16
name|flex_byte
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_atr_set_flex_byte_82599"
argument_list|)
expr_stmt|;
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_FLEX_BYTE_OFFSET
operator|+
literal|1
index|]
operator|=
name|flex_byte
operator|>>
literal|8
expr_stmt|;
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_FLEX_BYTE_OFFSET
index|]
operator|=
name|flex_byte
operator|&
literal|0xff
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_atr_set_vm_pool_82599 - Sets the Virtual Machine pool  *  @input: input stream to modify  *  @vm_pool: the Virtual Machine pool to load  **/
end_comment

begin_function
name|s32
name|ixgbe_atr_set_vm_pool_82599
parameter_list|(
name|struct
name|ixgbe_atr_input
modifier|*
name|input
parameter_list|,
name|u8
name|vm_pool
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_atr_set_vm_pool_82599"
argument_list|)
expr_stmt|;
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_VM_POOL_OFFSET
index|]
operator|=
name|vm_pool
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_atr_set_l4type_82599 - Sets the layer 4 packet type  *  @input: input stream to modify  *  @l4type: the layer 4 type value to load  **/
end_comment

begin_function
name|s32
name|ixgbe_atr_set_l4type_82599
parameter_list|(
name|struct
name|ixgbe_atr_input
modifier|*
name|input
parameter_list|,
name|u8
name|l4type
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_atr_set_l4type_82599"
argument_list|)
expr_stmt|;
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_L4TYPE_OFFSET
index|]
operator|=
name|l4type
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_atr_get_vlan_id_82599 - Gets the VLAN id from the ATR input stream  *  @input: input stream to search  *  @vlan: the VLAN id to load  **/
end_comment

begin_function
name|s32
name|ixgbe_atr_get_vlan_id_82599
parameter_list|(
name|struct
name|ixgbe_atr_input
modifier|*
name|input
parameter_list|,
name|u16
modifier|*
name|vlan
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_atr_get_vlan_id_82599"
argument_list|)
expr_stmt|;
operator|*
name|vlan
operator|=
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_VLAN_OFFSET
index|]
expr_stmt|;
operator|*
name|vlan
operator||=
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_VLAN_OFFSET
operator|+
literal|1
index|]
operator|<<
literal|8
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_atr_get_src_ipv4_82599 - Gets the source IPv4 address  *  @input: input stream to search  *  @src_addr: the IP address to load  **/
end_comment

begin_function
name|s32
name|ixgbe_atr_get_src_ipv4_82599
parameter_list|(
name|struct
name|ixgbe_atr_input
modifier|*
name|input
parameter_list|,
name|u32
modifier|*
name|src_addr
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_atr_get_src_ipv4_82599"
argument_list|)
expr_stmt|;
operator|*
name|src_addr
operator|=
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_SRC_IPV4_OFFSET
index|]
expr_stmt|;
operator|*
name|src_addr
operator||=
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_SRC_IPV4_OFFSET
operator|+
literal|1
index|]
operator|<<
literal|8
expr_stmt|;
operator|*
name|src_addr
operator||=
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_SRC_IPV4_OFFSET
operator|+
literal|2
index|]
operator|<<
literal|16
expr_stmt|;
operator|*
name|src_addr
operator||=
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_SRC_IPV4_OFFSET
operator|+
literal|3
index|]
operator|<<
literal|24
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_atr_get_dst_ipv4_82599 - Gets the destination IPv4 address  *  @input: input stream to search  *  @dst_addr: the IP address to load  **/
end_comment

begin_function
name|s32
name|ixgbe_atr_get_dst_ipv4_82599
parameter_list|(
name|struct
name|ixgbe_atr_input
modifier|*
name|input
parameter_list|,
name|u32
modifier|*
name|dst_addr
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_atr_get_dst_ipv4_82599"
argument_list|)
expr_stmt|;
operator|*
name|dst_addr
operator|=
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_DST_IPV4_OFFSET
index|]
expr_stmt|;
operator|*
name|dst_addr
operator||=
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_DST_IPV4_OFFSET
operator|+
literal|1
index|]
operator|<<
literal|8
expr_stmt|;
operator|*
name|dst_addr
operator||=
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_DST_IPV4_OFFSET
operator|+
literal|2
index|]
operator|<<
literal|16
expr_stmt|;
operator|*
name|dst_addr
operator||=
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_DST_IPV4_OFFSET
operator|+
literal|3
index|]
operator|<<
literal|24
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_atr_get_src_ipv6_82599 - Gets the source IPv6 address  *  @input: input stream to search  *  @src_addr_1: the first 4 bytes of the IP address to load  *  @src_addr_2: the second 4 bytes of the IP address to load  *  @src_addr_3: the third 4 bytes of the IP address to load  *  @src_addr_4: the fourth 4 bytes of the IP address to load  **/
end_comment

begin_function
name|s32
name|ixgbe_atr_get_src_ipv6_82599
parameter_list|(
name|struct
name|ixgbe_atr_input
modifier|*
name|input
parameter_list|,
name|u32
modifier|*
name|src_addr_1
parameter_list|,
name|u32
modifier|*
name|src_addr_2
parameter_list|,
name|u32
modifier|*
name|src_addr_3
parameter_list|,
name|u32
modifier|*
name|src_addr_4
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_atr_get_src_ipv6_82599"
argument_list|)
expr_stmt|;
operator|*
name|src_addr_1
operator|=
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_SRC_IPV6_OFFSET
operator|+
literal|12
index|]
expr_stmt|;
operator|*
name|src_addr_1
operator|=
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_SRC_IPV6_OFFSET
operator|+
literal|13
index|]
operator|<<
literal|8
expr_stmt|;
operator|*
name|src_addr_1
operator|=
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_SRC_IPV6_OFFSET
operator|+
literal|14
index|]
operator|<<
literal|16
expr_stmt|;
operator|*
name|src_addr_1
operator|=
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_SRC_IPV6_OFFSET
operator|+
literal|15
index|]
operator|<<
literal|24
expr_stmt|;
operator|*
name|src_addr_2
operator|=
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_SRC_IPV6_OFFSET
operator|+
literal|8
index|]
expr_stmt|;
operator|*
name|src_addr_2
operator|=
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_SRC_IPV6_OFFSET
operator|+
literal|9
index|]
operator|<<
literal|8
expr_stmt|;
operator|*
name|src_addr_2
operator|=
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_SRC_IPV6_OFFSET
operator|+
literal|10
index|]
operator|<<
literal|16
expr_stmt|;
operator|*
name|src_addr_2
operator|=
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_SRC_IPV6_OFFSET
operator|+
literal|11
index|]
operator|<<
literal|24
expr_stmt|;
operator|*
name|src_addr_3
operator|=
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_SRC_IPV6_OFFSET
operator|+
literal|4
index|]
expr_stmt|;
operator|*
name|src_addr_3
operator|=
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_SRC_IPV6_OFFSET
operator|+
literal|5
index|]
operator|<<
literal|8
expr_stmt|;
operator|*
name|src_addr_3
operator|=
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_SRC_IPV6_OFFSET
operator|+
literal|6
index|]
operator|<<
literal|16
expr_stmt|;
operator|*
name|src_addr_3
operator|=
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_SRC_IPV6_OFFSET
operator|+
literal|7
index|]
operator|<<
literal|24
expr_stmt|;
operator|*
name|src_addr_4
operator|=
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_SRC_IPV6_OFFSET
index|]
expr_stmt|;
operator|*
name|src_addr_4
operator|=
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_SRC_IPV6_OFFSET
operator|+
literal|1
index|]
operator|<<
literal|8
expr_stmt|;
operator|*
name|src_addr_4
operator|=
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_SRC_IPV6_OFFSET
operator|+
literal|2
index|]
operator|<<
literal|16
expr_stmt|;
operator|*
name|src_addr_4
operator|=
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_SRC_IPV6_OFFSET
operator|+
literal|3
index|]
operator|<<
literal|24
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_atr_get_dst_ipv6_82599 - Gets the destination IPv6 address  *  @input: input stream to search  *  @dst_addr_1: the first 4 bytes of the IP address to load  *  @dst_addr_2: the second 4 bytes of the IP address to load  *  @dst_addr_3: the third 4 bytes of the IP address to load  *  @dst_addr_4: the fourth 4 bytes of the IP address to load  **/
end_comment

begin_function
name|s32
name|ixgbe_atr_get_dst_ipv6_82599
parameter_list|(
name|struct
name|ixgbe_atr_input
modifier|*
name|input
parameter_list|,
name|u32
modifier|*
name|dst_addr_1
parameter_list|,
name|u32
modifier|*
name|dst_addr_2
parameter_list|,
name|u32
modifier|*
name|dst_addr_3
parameter_list|,
name|u32
modifier|*
name|dst_addr_4
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_atr_get_dst_ipv6_82599"
argument_list|)
expr_stmt|;
operator|*
name|dst_addr_1
operator|=
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_DST_IPV6_OFFSET
operator|+
literal|12
index|]
expr_stmt|;
operator|*
name|dst_addr_1
operator|=
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_DST_IPV6_OFFSET
operator|+
literal|13
index|]
operator|<<
literal|8
expr_stmt|;
operator|*
name|dst_addr_1
operator|=
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_DST_IPV6_OFFSET
operator|+
literal|14
index|]
operator|<<
literal|16
expr_stmt|;
operator|*
name|dst_addr_1
operator|=
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_DST_IPV6_OFFSET
operator|+
literal|15
index|]
operator|<<
literal|24
expr_stmt|;
operator|*
name|dst_addr_2
operator|=
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_DST_IPV6_OFFSET
operator|+
literal|8
index|]
expr_stmt|;
operator|*
name|dst_addr_2
operator|=
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_DST_IPV6_OFFSET
operator|+
literal|9
index|]
operator|<<
literal|8
expr_stmt|;
operator|*
name|dst_addr_2
operator|=
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_DST_IPV6_OFFSET
operator|+
literal|10
index|]
operator|<<
literal|16
expr_stmt|;
operator|*
name|dst_addr_2
operator|=
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_DST_IPV6_OFFSET
operator|+
literal|11
index|]
operator|<<
literal|24
expr_stmt|;
operator|*
name|dst_addr_3
operator|=
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_DST_IPV6_OFFSET
operator|+
literal|4
index|]
expr_stmt|;
operator|*
name|dst_addr_3
operator|=
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_DST_IPV6_OFFSET
operator|+
literal|5
index|]
operator|<<
literal|8
expr_stmt|;
operator|*
name|dst_addr_3
operator|=
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_DST_IPV6_OFFSET
operator|+
literal|6
index|]
operator|<<
literal|16
expr_stmt|;
operator|*
name|dst_addr_3
operator|=
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_DST_IPV6_OFFSET
operator|+
literal|7
index|]
operator|<<
literal|24
expr_stmt|;
operator|*
name|dst_addr_4
operator|=
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_DST_IPV6_OFFSET
index|]
expr_stmt|;
operator|*
name|dst_addr_4
operator|=
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_DST_IPV6_OFFSET
operator|+
literal|1
index|]
operator|<<
literal|8
expr_stmt|;
operator|*
name|dst_addr_4
operator|=
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_DST_IPV6_OFFSET
operator|+
literal|2
index|]
operator|<<
literal|16
expr_stmt|;
operator|*
name|dst_addr_4
operator|=
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_DST_IPV6_OFFSET
operator|+
literal|3
index|]
operator|<<
literal|24
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_atr_get_src_port_82599 - Gets the source port  *  @input: input stream to modify  *  @src_port: the source port to load  *  *  Even though the input is given in big-endian, the FDIRPORT registers  *  expect the ports to be programmed in little-endian.  Hence the need to swap  *  endianness when retrieving the data.  This can be confusing since the  *  internal hash engine expects it to be big-endian.  **/
end_comment

begin_function
name|s32
name|ixgbe_atr_get_src_port_82599
parameter_list|(
name|struct
name|ixgbe_atr_input
modifier|*
name|input
parameter_list|,
name|u16
modifier|*
name|src_port
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_atr_get_src_port_82599"
argument_list|)
expr_stmt|;
operator|*
name|src_port
operator|=
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_SRC_PORT_OFFSET
index|]
operator|<<
literal|8
expr_stmt|;
operator|*
name|src_port
operator||=
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_SRC_PORT_OFFSET
operator|+
literal|1
index|]
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_atr_get_dst_port_82599 - Gets the destination port  *  @input: input stream to modify  *  @dst_port: the destination port to load  *  *  Even though the input is given in big-endian, the FDIRPORT registers  *  expect the ports to be programmed in little-endian.  Hence the need to swap  *  endianness when retrieving the data.  This can be confusing since the  *  internal hash engine expects it to be big-endian.  **/
end_comment

begin_function
name|s32
name|ixgbe_atr_get_dst_port_82599
parameter_list|(
name|struct
name|ixgbe_atr_input
modifier|*
name|input
parameter_list|,
name|u16
modifier|*
name|dst_port
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_atr_get_dst_port_82599"
argument_list|)
expr_stmt|;
operator|*
name|dst_port
operator|=
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_DST_PORT_OFFSET
index|]
operator|<<
literal|8
expr_stmt|;
operator|*
name|dst_port
operator||=
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_DST_PORT_OFFSET
operator|+
literal|1
index|]
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_atr_get_flex_byte_82599 - Gets the flexible bytes  *  @input: input stream to modify  *  @flex_bytes: the flexible bytes to load  **/
end_comment

begin_function
name|s32
name|ixgbe_atr_get_flex_byte_82599
parameter_list|(
name|struct
name|ixgbe_atr_input
modifier|*
name|input
parameter_list|,
name|u16
modifier|*
name|flex_byte
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_atr_get_flex_byte_82599"
argument_list|)
expr_stmt|;
operator|*
name|flex_byte
operator|=
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_FLEX_BYTE_OFFSET
index|]
expr_stmt|;
operator|*
name|flex_byte
operator||=
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_FLEX_BYTE_OFFSET
operator|+
literal|1
index|]
operator|<<
literal|8
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_atr_get_vm_pool_82599 - Gets the Virtual Machine pool  *  @input: input stream to modify  *  @vm_pool: the Virtual Machine pool to load  **/
end_comment

begin_function
name|s32
name|ixgbe_atr_get_vm_pool_82599
parameter_list|(
name|struct
name|ixgbe_atr_input
modifier|*
name|input
parameter_list|,
name|u8
modifier|*
name|vm_pool
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_atr_get_vm_pool_82599"
argument_list|)
expr_stmt|;
operator|*
name|vm_pool
operator|=
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_VM_POOL_OFFSET
index|]
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_atr_get_l4type_82599 - Gets the layer 4 packet type  *  @input: input stream to modify  *  @l4type: the layer 4 type value to load  **/
end_comment

begin_function
name|s32
name|ixgbe_atr_get_l4type_82599
parameter_list|(
name|struct
name|ixgbe_atr_input
modifier|*
name|input
parameter_list|,
name|u8
modifier|*
name|l4type
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_atr_get_l4type__82599"
argument_list|)
expr_stmt|;
operator|*
name|l4type
operator|=
name|input
operator|->
name|byte_stream
index|[
name|IXGBE_ATR_L4TYPE_OFFSET
index|]
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_atr_add_signature_filter_82599 - Adds a signature hash filter  *  @hw: pointer to hardware structure  *  @stream: input bitstream  *  @queue: queue index to direct traffic to  **/
end_comment

begin_function
name|s32
name|ixgbe_fdir_add_signature_filter_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|struct
name|ixgbe_atr_input
modifier|*
name|input
parameter_list|,
name|u8
name|queue
parameter_list|)
block|{
name|u64
name|fdirhashcmd
decl_stmt|;
name|u64
name|fdircmd
decl_stmt|;
name|u32
name|fdirhash
decl_stmt|;
name|u16
name|bucket_hash
decl_stmt|,
name|sig_hash
decl_stmt|;
name|u8
name|l4type
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_fdir_add_signature_filter_82599"
argument_list|)
expr_stmt|;
name|bucket_hash
operator|=
name|ixgbe_atr_compute_hash_82599
argument_list|(
name|input
argument_list|,
name|IXGBE_ATR_BUCKET_HASH_KEY
argument_list|)
expr_stmt|;
comment|/* bucket_hash is only 15 bits */
name|bucket_hash
operator|&=
name|IXGBE_ATR_HASH_MASK
expr_stmt|;
name|sig_hash
operator|=
name|ixgbe_atr_compute_hash_82599
argument_list|(
name|input
argument_list|,
name|IXGBE_ATR_SIGNATURE_HASH_KEY
argument_list|)
expr_stmt|;
comment|/* Get the l4type in order to program FDIRCMD properly */
comment|/* lowest 2 bits are FDIRCMD.L4TYPE, third lowest bit is FDIRCMD.IPV6 */
name|ixgbe_atr_get_l4type_82599
argument_list|(
name|input
argument_list|,
operator|&
name|l4type
argument_list|)
expr_stmt|;
comment|/* 	 * The lower 32-bits of fdirhashcmd is for FDIRHASH, the upper 32-bits 	 * is for FDIRCMD.  Then do a 64-bit register write from FDIRHASH. 	 */
name|fdirhash
operator|=
name|sig_hash
operator|<<
name|IXGBE_FDIRHASH_SIG_SW_INDEX_SHIFT
operator||
name|bucket_hash
expr_stmt|;
name|fdircmd
operator|=
operator|(
name|IXGBE_FDIRCMD_CMD_ADD_FLOW
operator||
name|IXGBE_FDIRCMD_FILTER_UPDATE
operator||
name|IXGBE_FDIRCMD_LAST
operator||
name|IXGBE_FDIRCMD_QUEUE_EN
operator|)
expr_stmt|;
switch|switch
condition|(
name|l4type
operator|&
name|IXGBE_ATR_L4TYPE_MASK
condition|)
block|{
case|case
name|IXGBE_ATR_L4TYPE_TCP
case|:
name|fdircmd
operator||=
name|IXGBE_FDIRCMD_L4TYPE_TCP
expr_stmt|;
break|break;
case|case
name|IXGBE_ATR_L4TYPE_UDP
case|:
name|fdircmd
operator||=
name|IXGBE_FDIRCMD_L4TYPE_UDP
expr_stmt|;
break|break;
case|case
name|IXGBE_ATR_L4TYPE_SCTP
case|:
name|fdircmd
operator||=
name|IXGBE_FDIRCMD_L4TYPE_SCTP
expr_stmt|;
break|break;
default|default:
name|DEBUGOUT
argument_list|(
literal|" Error on l4type input\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_CONFIG
return|;
block|}
if|if
condition|(
name|l4type
operator|&
name|IXGBE_ATR_L4TYPE_IPV6_MASK
condition|)
name|fdircmd
operator||=
name|IXGBE_FDIRCMD_IPV6
expr_stmt|;
name|fdircmd
operator||=
operator|(
operator|(
name|u64
operator|)
name|queue
operator|<<
name|IXGBE_FDIRCMD_RX_QUEUE_SHIFT
operator|)
expr_stmt|;
name|fdirhashcmd
operator|=
operator|(
operator|(
name|fdircmd
operator|<<
literal|32
operator|)
operator||
name|fdirhash
operator|)
expr_stmt|;
name|DEBUGOUT2
argument_list|(
literal|"Tx Queue=%x hash=%x\n"
argument_list|,
name|queue
argument_list|,
name|fdirhash
operator|&
literal|0x7FFF7FFF
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG64
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRHASH
argument_list|,
name|fdirhashcmd
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_fdir_add_perfect_filter_82599 - Adds a perfect filter  *  @hw: pointer to hardware structure  *  @input: input bitstream  *  @queue: queue index to direct traffic to  *  *  Note that the caller to this function must lock before calling, since the  *  hardware writes must be protected from one another.  **/
end_comment

begin_function
name|s32
name|ixgbe_fdir_add_perfect_filter_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|struct
name|ixgbe_atr_input
modifier|*
name|input
parameter_list|,
name|u16
name|soft_id
parameter_list|,
name|u8
name|queue
parameter_list|)
block|{
name|u32
name|fdircmd
init|=
literal|0
decl_stmt|;
name|u32
name|fdirhash
decl_stmt|;
name|u32
name|src_ipv4
decl_stmt|,
name|dst_ipv4
decl_stmt|;
name|u32
name|src_ipv6_1
decl_stmt|,
name|src_ipv6_2
decl_stmt|,
name|src_ipv6_3
decl_stmt|,
name|src_ipv6_4
decl_stmt|;
name|u16
name|src_port
decl_stmt|,
name|dst_port
decl_stmt|,
name|vlan_id
decl_stmt|,
name|flex_bytes
decl_stmt|;
name|u16
name|bucket_hash
decl_stmt|;
name|u8
name|l4type
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_fdir_add_perfect_filter_82599"
argument_list|)
expr_stmt|;
comment|/* Get our input values */
name|ixgbe_atr_get_l4type_82599
argument_list|(
name|input
argument_list|,
operator|&
name|l4type
argument_list|)
expr_stmt|;
comment|/* 	 * Check l4type formatting, and bail out before we touch the hardware 	 * if there's a configuration issue 	 */
switch|switch
condition|(
name|l4type
operator|&
name|IXGBE_ATR_L4TYPE_MASK
condition|)
block|{
case|case
name|IXGBE_ATR_L4TYPE_TCP
case|:
name|fdircmd
operator||=
name|IXGBE_FDIRCMD_L4TYPE_TCP
expr_stmt|;
break|break;
case|case
name|IXGBE_ATR_L4TYPE_UDP
case|:
name|fdircmd
operator||=
name|IXGBE_FDIRCMD_L4TYPE_UDP
expr_stmt|;
break|break;
case|case
name|IXGBE_ATR_L4TYPE_SCTP
case|:
name|fdircmd
operator||=
name|IXGBE_FDIRCMD_L4TYPE_SCTP
expr_stmt|;
break|break;
default|default:
name|DEBUGOUT
argument_list|(
literal|" Error on l4type input\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_CONFIG
return|;
block|}
name|bucket_hash
operator|=
name|ixgbe_atr_compute_hash_82599
argument_list|(
name|input
argument_list|,
name|IXGBE_ATR_BUCKET_HASH_KEY
argument_list|)
expr_stmt|;
comment|/* bucket_hash is only 15 bits */
name|bucket_hash
operator|&=
name|IXGBE_ATR_HASH_MASK
expr_stmt|;
name|ixgbe_atr_get_vlan_id_82599
argument_list|(
name|input
argument_list|,
operator|&
name|vlan_id
argument_list|)
expr_stmt|;
name|ixgbe_atr_get_src_port_82599
argument_list|(
name|input
argument_list|,
operator|&
name|src_port
argument_list|)
expr_stmt|;
name|ixgbe_atr_get_dst_port_82599
argument_list|(
name|input
argument_list|,
operator|&
name|dst_port
argument_list|)
expr_stmt|;
name|ixgbe_atr_get_flex_byte_82599
argument_list|(
name|input
argument_list|,
operator|&
name|flex_bytes
argument_list|)
expr_stmt|;
name|fdirhash
operator|=
name|soft_id
operator|<<
name|IXGBE_FDIRHASH_SIG_SW_INDEX_SHIFT
operator||
name|bucket_hash
expr_stmt|;
comment|/* Now figure out if we're IPv4 or IPv6 */
if|if
condition|(
name|l4type
operator|&
name|IXGBE_ATR_L4TYPE_IPV6_MASK
condition|)
block|{
comment|/* IPv6 */
name|ixgbe_atr_get_src_ipv6_82599
argument_list|(
name|input
argument_list|,
operator|&
name|src_ipv6_1
argument_list|,
operator|&
name|src_ipv6_2
argument_list|,
operator|&
name|src_ipv6_3
argument_list|,
operator|&
name|src_ipv6_4
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRSIPv6
argument_list|(
literal|0
argument_list|)
argument_list|,
name|src_ipv6_1
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRSIPv6
argument_list|(
literal|1
argument_list|)
argument_list|,
name|src_ipv6_2
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRSIPv6
argument_list|(
literal|2
argument_list|)
argument_list|,
name|src_ipv6_3
argument_list|)
expr_stmt|;
comment|/* The last 4 bytes is the same register as IPv4 */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRIPSA
argument_list|,
name|src_ipv6_4
argument_list|)
expr_stmt|;
name|fdircmd
operator||=
name|IXGBE_FDIRCMD_IPV6
expr_stmt|;
name|fdircmd
operator||=
name|IXGBE_FDIRCMD_IPv6DMATCH
expr_stmt|;
block|}
else|else
block|{
comment|/* IPv4 */
name|ixgbe_atr_get_src_ipv4_82599
argument_list|(
name|input
argument_list|,
operator|&
name|src_ipv4
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRIPSA
argument_list|,
name|src_ipv4
argument_list|)
expr_stmt|;
block|}
name|ixgbe_atr_get_dst_ipv4_82599
argument_list|(
name|input
argument_list|,
operator|&
name|dst_ipv4
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRIPDA
argument_list|,
name|dst_ipv4
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRVLAN
argument_list|,
operator|(
name|vlan_id
operator||
operator|(
name|flex_bytes
operator|<<
name|IXGBE_FDIRVLAN_FLEX_SHIFT
operator|)
operator|)
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRPORT
argument_list|,
operator|(
name|src_port
operator||
operator|(
name|dst_port
operator|<<
name|IXGBE_FDIRPORT_DESTINATION_SHIFT
operator|)
operator|)
argument_list|)
expr_stmt|;
name|fdircmd
operator||=
name|IXGBE_FDIRCMD_CMD_ADD_FLOW
expr_stmt|;
name|fdircmd
operator||=
name|IXGBE_FDIRCMD_FILTER_UPDATE
expr_stmt|;
name|fdircmd
operator||=
name|IXGBE_FDIRCMD_LAST
expr_stmt|;
name|fdircmd
operator||=
name|IXGBE_FDIRCMD_QUEUE_EN
expr_stmt|;
name|fdircmd
operator||=
name|queue
operator|<<
name|IXGBE_FDIRCMD_RX_QUEUE_SHIFT
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRHASH
argument_list|,
name|fdirhash
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FDIRCMD
argument_list|,
name|fdircmd
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_read_analog_reg8_82599 - Reads 8 bit Omer analog register  *  @hw: pointer to hardware structure  *  @reg: analog register to read  *  @val: read value  *  *  Performs read operation to Omer analog register specified.  **/
end_comment

begin_function
name|s32
name|ixgbe_read_analog_reg8_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|reg
parameter_list|,
name|u8
modifier|*
name|val
parameter_list|)
block|{
name|u32
name|core_ctl
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_read_analog_reg8_82599"
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CORECTL
argument_list|,
name|IXGBE_CORECTL_WRITE_CMD
operator||
operator|(
name|reg
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|core_ctl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CORECTL
argument_list|)
expr_stmt|;
operator|*
name|val
operator|=
operator|(
name|u8
operator|)
name|core_ctl
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_write_analog_reg8_82599 - Writes 8 bit Omer analog register  *  @hw: pointer to hardware structure  *  @reg: atlas register to write  *  @val: value to write  *  *  Performs write operation to Omer analog register specified.  **/
end_comment

begin_function
name|s32
name|ixgbe_write_analog_reg8_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|reg
parameter_list|,
name|u8
name|val
parameter_list|)
block|{
name|u32
name|core_ctl
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_write_analog_reg8_82599"
argument_list|)
expr_stmt|;
name|core_ctl
operator|=
operator|(
name|reg
operator|<<
literal|8
operator|)
operator||
name|val
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CORECTL
argument_list|,
name|core_ctl
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_start_hw_rev_1_82599 - Prepare hardware for Tx/Rx  *  @hw: pointer to hardware structure  *  *  Starts the hardware using the generic start_hw function.  *  Then performs revision-specific operations:  *  Clears the rate limiter registers.  **/
end_comment

begin_function
name|s32
name|ixgbe_start_hw_rev_1_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|i
decl_stmt|;
name|u32
name|regval
decl_stmt|;
name|s32
name|ret_val
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_start_hw_rev_1__82599"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|ixgbe_start_hw_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Clear the rate limiters */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hw
operator|->
name|mac
operator|.
name|max_tx_queues
condition|;
name|i
operator|++
control|)
block|{
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RTTDQSEL
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RTTBCNRC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Disable relaxed ordering */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hw
operator|->
name|mac
operator|.
name|max_tx_queues
condition|;
name|i
operator|++
control|)
block|{
name|regval
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DCA_TXCTRL_82599
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|regval
operator|&=
operator|~
name|IXGBE_DCA_TXCTRL_TX_WB_RO_EN
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DCA_TXCTRL_82599
argument_list|(
name|i
argument_list|)
argument_list|,
name|regval
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hw
operator|->
name|mac
operator|.
name|max_rx_queues
condition|;
name|i
operator|++
control|)
block|{
name|regval
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DCA_RXCTRL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|regval
operator|&=
operator|~
operator|(
name|IXGBE_DCA_RXCTRL_DESC_WRO_EN
operator||
name|IXGBE_DCA_RXCTRL_DESC_HSRO_EN
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DCA_RXCTRL
argument_list|(
name|i
argument_list|)
argument_list|,
name|regval
argument_list|)
expr_stmt|;
block|}
comment|/* We need to run link autotry after the driver loads */
name|hw
operator|->
name|mac
operator|.
name|autotry_restart
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|ret_val
operator|==
name|IXGBE_SUCCESS
condition|)
name|ret_val
operator|=
name|ixgbe_verify_fw_version_82599
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_identify_phy_82599 - Get physical layer module  *  @hw: pointer to hardware structure  *  *  Determines the physical layer module found on the current adapter.  *  If PHY already detected, maintains current PHY type in hw struct,  *  otherwise executes the PHY detection routine.  **/
end_comment

begin_function
name|s32
name|ixgbe_identify_phy_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_ERR_PHY_ADDR_INVALID
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_identify_phy_82599"
argument_list|)
expr_stmt|;
comment|/* Detect PHY if not unknown - returns success if already detected. */
name|status
operator|=
name|ixgbe_identify_phy_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
name|status
operator|=
name|ixgbe_identify_sfp_module_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Set PHY type none if no PHY detected */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|ixgbe_phy_unknown
condition|)
block|{
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|ixgbe_phy_none
expr_stmt|;
name|status
operator|=
name|IXGBE_SUCCESS
expr_stmt|;
block|}
comment|/* Return error if SFP module has been detected but is not supported */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|ixgbe_phy_sfp_unsupported
condition|)
name|status
operator|=
name|IXGBE_ERR_SFP_NOT_SUPPORTED
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_supported_physical_layer_82599 - Returns physical layer type  *  @hw: pointer to hardware structure  *  *  Determines physical layer capabilities of the current configuration.  **/
end_comment

begin_function
name|u32
name|ixgbe_get_supported_physical_layer_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|physical_layer
init|=
name|IXGBE_PHYSICAL_LAYER_UNKNOWN
decl_stmt|;
name|u32
name|autoc
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC
argument_list|)
decl_stmt|;
name|u32
name|autoc2
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC2
argument_list|)
decl_stmt|;
name|u32
name|pma_pmd_10g_serial
init|=
name|autoc2
operator|&
name|IXGBE_AUTOC2_10G_SERIAL_PMA_PMD_MASK
decl_stmt|;
name|u32
name|pma_pmd_10g_parallel
init|=
name|autoc
operator|&
name|IXGBE_AUTOC_10G_PMA_PMD_MASK
decl_stmt|;
name|u32
name|pma_pmd_1g
init|=
name|autoc
operator|&
name|IXGBE_AUTOC_1G_PMA_PMD_MASK
decl_stmt|;
name|u16
name|ext_ability
init|=
literal|0
decl_stmt|;
name|u8
name|comp_codes_10g
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_support_physical_layer_82599"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|identify
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|ixgbe_phy_tn
operator|||
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|ixgbe_phy_aq
operator|||
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|ixgbe_phy_cu_unknown
condition|)
block|{
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_PHY_EXT_ABILITY
argument_list|,
name|IXGBE_MDIO_PMA_PMD_DEV_TYPE
argument_list|,
operator|&
name|ext_ability
argument_list|)
expr_stmt|;
if|if
condition|(
name|ext_ability
operator|&
name|IXGBE_MDIO_PHY_10GBASET_ABILITY
condition|)
name|physical_layer
operator||=
name|IXGBE_PHYSICAL_LAYER_10GBASE_T
expr_stmt|;
if|if
condition|(
name|ext_ability
operator|&
name|IXGBE_MDIO_PHY_1000BASET_ABILITY
condition|)
name|physical_layer
operator||=
name|IXGBE_PHYSICAL_LAYER_1000BASE_T
expr_stmt|;
if|if
condition|(
name|ext_ability
operator|&
name|IXGBE_MDIO_PHY_100BASETX_ABILITY
condition|)
name|physical_layer
operator||=
name|IXGBE_PHYSICAL_LAYER_100BASE_TX
expr_stmt|;
goto|goto
name|out
goto|;
block|}
switch|switch
condition|(
name|autoc
operator|&
name|IXGBE_AUTOC_LMS_MASK
condition|)
block|{
case|case
name|IXGBE_AUTOC_LMS_1G_AN
case|:
case|case
name|IXGBE_AUTOC_LMS_1G_LINK_NO_AN
case|:
if|if
condition|(
name|pma_pmd_1g
operator|==
name|IXGBE_AUTOC_1G_KX_BX
condition|)
block|{
name|physical_layer
operator|=
name|IXGBE_PHYSICAL_LAYER_1000BASE_KX
operator||
name|IXGBE_PHYSICAL_LAYER_1000BASE_BX
expr_stmt|;
goto|goto
name|out
goto|;
block|}
else|else
comment|/* SFI mode so read SFP module */
goto|goto
name|sfp_check
goto|;
break|break;
case|case
name|IXGBE_AUTOC_LMS_10G_LINK_NO_AN
case|:
if|if
condition|(
name|pma_pmd_10g_parallel
operator|==
name|IXGBE_AUTOC_10G_CX4
condition|)
name|physical_layer
operator|=
name|IXGBE_PHYSICAL_LAYER_10GBASE_CX4
expr_stmt|;
elseif|else
if|if
condition|(
name|pma_pmd_10g_parallel
operator|==
name|IXGBE_AUTOC_10G_KX4
condition|)
name|physical_layer
operator|=
name|IXGBE_PHYSICAL_LAYER_10GBASE_KX4
expr_stmt|;
elseif|else
if|if
condition|(
name|pma_pmd_10g_parallel
operator|==
name|IXGBE_AUTOC_10G_XAUI
condition|)
name|physical_layer
operator|=
name|IXGBE_PHYSICAL_LAYER_10GBASE_XAUI
expr_stmt|;
goto|goto
name|out
goto|;
break|break;
case|case
name|IXGBE_AUTOC_LMS_10G_SERIAL
case|:
if|if
condition|(
name|pma_pmd_10g_serial
operator|==
name|IXGBE_AUTOC2_10G_KR
condition|)
block|{
name|physical_layer
operator|=
name|IXGBE_PHYSICAL_LAYER_10GBASE_KR
expr_stmt|;
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
name|pma_pmd_10g_serial
operator|==
name|IXGBE_AUTOC2_10G_SFI
condition|)
goto|goto
name|sfp_check
goto|;
break|break;
case|case
name|IXGBE_AUTOC_LMS_KX4_KX_KR
case|:
case|case
name|IXGBE_AUTOC_LMS_KX4_KX_KR_1G_AN
case|:
if|if
condition|(
name|autoc
operator|&
name|IXGBE_AUTOC_KX_SUPP
condition|)
name|physical_layer
operator||=
name|IXGBE_PHYSICAL_LAYER_1000BASE_KX
expr_stmt|;
if|if
condition|(
name|autoc
operator|&
name|IXGBE_AUTOC_KX4_SUPP
condition|)
name|physical_layer
operator||=
name|IXGBE_PHYSICAL_LAYER_10GBASE_KX4
expr_stmt|;
if|if
condition|(
name|autoc
operator|&
name|IXGBE_AUTOC_KR_SUPP
condition|)
name|physical_layer
operator||=
name|IXGBE_PHYSICAL_LAYER_10GBASE_KR
expr_stmt|;
goto|goto
name|out
goto|;
break|break;
default|default:
goto|goto
name|out
goto|;
break|break;
block|}
name|sfp_check
label|:
comment|/* SFP check must be done last since DA modules are sometimes used to 	 * test KR mode -  we need to id KR mode correctly before SFP module. 	 * Call identify_sfp because the pluggable module may have changed */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|identify_sfp
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|==
name|ixgbe_sfp_type_not_present
condition|)
goto|goto
name|out
goto|;
switch|switch
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
condition|)
block|{
case|case
name|ixgbe_phy_tw_tyco
case|:
case|case
name|ixgbe_phy_tw_unknown
case|:
name|physical_layer
operator|=
name|IXGBE_PHYSICAL_LAYER_SFP_PLUS_CU
expr_stmt|;
break|break;
case|case
name|ixgbe_phy_sfp_avago
case|:
case|case
name|ixgbe_phy_sfp_ftl
case|:
case|case
name|ixgbe_phy_sfp_intel
case|:
case|case
name|ixgbe_phy_sfp_unknown
case|:
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_i2c_eeprom
argument_list|(
name|hw
argument_list|,
name|IXGBE_SFF_10GBE_COMP_CODES
argument_list|,
operator|&
name|comp_codes_10g
argument_list|)
expr_stmt|;
if|if
condition|(
name|comp_codes_10g
operator|&
name|IXGBE_SFF_10GBASESR_CAPABLE
condition|)
name|physical_layer
operator|=
name|IXGBE_PHYSICAL_LAYER_10GBASE_SR
expr_stmt|;
elseif|else
if|if
condition|(
name|comp_codes_10g
operator|&
name|IXGBE_SFF_10GBASELR_CAPABLE
condition|)
name|physical_layer
operator|=
name|IXGBE_PHYSICAL_LAYER_10GBASE_LR
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|out
label|:
return|return
name|physical_layer
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_enable_rx_dma_82599 - Enable the Rx DMA unit on 82599  *  @hw: pointer to hardware structure  *  @regval: register value to write to RXCTRL  *  *  Enables the Rx DMA unit for 82599  **/
end_comment

begin_function
name|s32
name|ixgbe_enable_rx_dma_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|regval
parameter_list|)
block|{
define|#
directive|define
name|IXGBE_MAX_SECRX_POLL
value|30
name|int
name|i
decl_stmt|;
name|int
name|secrxreg
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_enable_rx_dma_82599"
argument_list|)
expr_stmt|;
comment|/* 	 * Workaround for 82599 silicon errata when enabling the Rx datapath. 	 * If traffic is incoming before we enable the Rx unit, it could hang 	 * the Rx DMA unit.  Therefore, make sure the security engine is 	 * completely disabled prior to enabling the Rx unit. 	 */
name|secrxreg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SECRXCTRL
argument_list|)
expr_stmt|;
name|secrxreg
operator||=
name|IXGBE_SECRXCTRL_RX_DIS
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SECRXCTRL
argument_list|,
name|secrxreg
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_MAX_SECRX_POLL
condition|;
name|i
operator|++
control|)
block|{
name|secrxreg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SECRXSTAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|secrxreg
operator|&
name|IXGBE_SECRXSTAT_SECRX_RDY
condition|)
break|break;
else|else
comment|/* Use interrupt-safe sleep just in case */
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
comment|/* For informational purposes only */
if|if
condition|(
name|i
operator|>=
name|IXGBE_MAX_SECRX_POLL
condition|)
name|DEBUGOUT
argument_list|(
literal|"Rx unit being enabled before security "
literal|"path fully disabled.  Continuing with init.\n"
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXCTRL
argument_list|,
name|regval
argument_list|)
expr_stmt|;
name|secrxreg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SECRXCTRL
argument_list|)
expr_stmt|;
name|secrxreg
operator|&=
operator|~
name|IXGBE_SECRXCTRL_RX_DIS
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SECRXCTRL
argument_list|,
name|secrxreg
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_device_caps_82599 - Get additional device capabilities  *  @hw: pointer to hardware structure  *  @device_caps: the EEPROM word with the extra device capabilities  *  *  This function will read the EEPROM location for the device capabilities,  *  and return the word through device_caps.  **/
end_comment

begin_function
name|s32
name|ixgbe_get_device_caps_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|device_caps
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_device_caps_82599"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|IXGBE_DEVICE_CAPS
argument_list|,
name|device_caps
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_verify_fw_version_82599 - verify fw version for 82599  *  @hw: pointer to hardware structure  *  *  Verifies that installed the firmware version is 0.6 or higher  *  for SFI devices. All 82599 SFI devices should have version 0.6 or higher.  *  *  Returns IXGBE_ERR_EEPROM_VERSION if the FW is not present or  *  if the FW version is not supported.  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_verify_fw_version_82599
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_ERR_EEPROM_VERSION
decl_stmt|;
name|u16
name|fw_offset
decl_stmt|,
name|fw_ptp_cfg_offset
decl_stmt|;
name|u16
name|fw_version
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_verify_fw_version_82599"
argument_list|)
expr_stmt|;
comment|/* firmware check is only necessary for SFI devices */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|!=
name|ixgbe_media_type_fiber
condition|)
block|{
name|status
operator|=
name|IXGBE_SUCCESS
expr_stmt|;
goto|goto
name|fw_version_out
goto|;
block|}
comment|/* get the offset to the Firmware Module block */
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|IXGBE_FW_PTR
argument_list|,
operator|&
name|fw_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fw_offset
operator|==
literal|0
operator|)
operator|||
operator|(
name|fw_offset
operator|==
literal|0xFFFF
operator|)
condition|)
goto|goto
name|fw_version_out
goto|;
comment|/* get the offset to the Pass Through Patch Configuration block */
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
operator|(
name|fw_offset
operator|+
name|IXGBE_FW_PASSTHROUGH_PATCH_CONFIG_PTR
operator|)
argument_list|,
operator|&
name|fw_ptp_cfg_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fw_ptp_cfg_offset
operator|==
literal|0
operator|)
operator|||
operator|(
name|fw_ptp_cfg_offset
operator|==
literal|0xFFFF
operator|)
condition|)
goto|goto
name|fw_version_out
goto|;
comment|/* get the firmware version */
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
operator|(
name|fw_ptp_cfg_offset
operator|+
name|IXGBE_FW_PATCH_VERSION_4
operator|)
argument_list|,
operator|&
name|fw_version
argument_list|)
expr_stmt|;
if|if
condition|(
name|fw_version
operator|>
literal|0x5
condition|)
name|status
operator|=
name|IXGBE_SUCCESS
expr_stmt|;
name|fw_version_out
label|:
return|return
name|status
return|;
block|}
end_function

end_unit

