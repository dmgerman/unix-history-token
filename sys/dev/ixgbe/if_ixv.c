begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************    Copyright (c) 2001-2015, Intel Corporation    All rights reserved.      Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are met:       1. Redistributions of source code must retain the above copyright notice,        this list of conditions and the following disclaimer.       2. Redistributions in binary form must reproduce the above copyright        notice, this list of conditions and the following disclaimer in the        documentation and/or other materials provided with the distribution.       3. Neither the name of the Intel Corporation nor the names of its        contributors may be used to endorse or promote products derived from        this software without specific prior written permission.      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  ******************************************************************************/
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|IXGBE_STANDALONE_BUILD
end_ifndef

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ixgbe.h"
end_include

begin_comment
comment|/*********************************************************************  *  Driver version  *********************************************************************/
end_comment

begin_decl_stmt
name|char
name|ixv_driver_version
index|[]
init|=
literal|"1.4.6-k"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************  *  PCI Device ID Table  *  *  Used by probe to select devices to load on  *  Last field stores an index into ixv_strings  *  Last entry must be all 0s  *  *  { Vendor ID, Device ID, SubVendor ID, SubDevice ID, String Index }  *********************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|ixgbe_vendor_info_t
name|ixv_vendor_info_array
index|[]
init|=
block|{
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_82599_VF
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_X540_VF
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_X550_VF
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IXGBE_INTEL_VENDOR_ID
block|,
name|IXGBE_DEV_ID_X550EM_X_VF
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* required last entry */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************  *  Table of branding strings  *********************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ixv_strings
index|[]
init|=
block|{
literal|"Intel(R) PRO/10GbE Virtual Function Network Driver"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************  *  Function prototypes  *********************************************************************/
end_comment

begin_function_decl
specifier|static
name|int
name|ixv_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixv_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixv_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixv_shutdown
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixv_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixv_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixv_init_locked
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixv_stop
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixv_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|ifmediareq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixv_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixv_identify_hardware
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixv_allocate_pci_resources
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixv_allocate_msix
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixv_setup_msix
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixv_free_pci_resources
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixv_local_timer
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixv_setup_interface
parameter_list|(
name|device_t
parameter_list|,
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixv_config_link
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixv_initialize_transmit_units
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixv_initialize_receive_units
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixv_enable_intr
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixv_disable_intr
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixv_set_multi
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixv_update_link_status
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixv_sysctl_debug
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixv_set_ivar
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|u8
parameter_list|,
name|u8
parameter_list|,
name|s8
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixv_configure_ivars
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u8
modifier|*
name|ixv_mc_array_itr
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
parameter_list|,
name|u8
modifier|*
modifier|*
parameter_list|,
name|u32
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixv_setup_vlan_support
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixv_register_vlan
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u16
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixv_unregister_vlan
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u16
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixv_save_stats
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixv_init_stats
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixv_update_stats
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixv_add_stats_sysctls
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixv_set_sysctl_value
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The MSI/X Interrupt handlers */
end_comment

begin_function_decl
specifier|static
name|void
name|ixv_msix_que
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixv_msix_mbx
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Deferred interrupt tasklets */
end_comment

begin_function_decl
specifier|static
name|void
name|ixv_handle_que
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixv_handle_mbx
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|DEV_NETMAP
end_ifdef

begin_comment
comment|/*  * This is defined in<dev/netmap/ixgbe_netmap.h>, which is included by  * if_ix.c.  */
end_comment

begin_function_decl
specifier|extern
name|void
name|ixgbe_netmap_attach
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
function_decl|;
end_function_decl

begin_include
include|#
directive|include
file|<net/netmap.h>
end_include

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<dev/netmap/netmap_kern.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEV_NETMAP */
end_comment

begin_comment
comment|/*********************************************************************  *  FreeBSD Device Interface Entry Points  *********************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|device_method_t
name|ixv_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ixv_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ixv_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|ixv_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|ixv_shutdown
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|ixv_driver
init|=
block|{
literal|"ixv"
block|,
name|ixv_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|adapter
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|devclass_t
name|ixv_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|ixv
argument_list|,
name|pci
argument_list|,
name|ixv_driver
argument_list|,
name|ixv_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ixv
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ixv
argument_list|,
name|ether
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEV_NETMAP
end_ifdef

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ix
argument_list|,
name|netmap
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEV_NETMAP */
end_comment

begin_comment
comment|/* XXX depend on 'ix' ? */
end_comment

begin_comment
comment|/* ** TUNEABLE PARAMETERS: */
end_comment

begin_comment
comment|/* Number of Queues - do not exceed MSIX vectors - 1 */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ixv_num_queues
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ixv.num_queues"
argument_list|,
operator|&
name|ixv_num_queues
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ** AIM: Adaptive Interrupt Moderation ** which means that the interrupt rate ** is varied over time based on the ** traffic for that interrupt vector */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ixv_enable_aim
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ixv.enable_aim"
argument_list|,
operator|&
name|ixv_enable_aim
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* How many packets rxeof tries to clean at a time */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ixv_rx_process_limit
init|=
literal|256
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ixv.rx_process_limit"
argument_list|,
operator|&
name|ixv_rx_process_limit
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* How many packets txeof tries to clean at a time */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ixv_tx_process_limit
init|=
literal|256
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ixv.tx_process_limit"
argument_list|,
operator|&
name|ixv_tx_process_limit
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Flow control setting, default to full */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ixv_flow_control
init|=
name|ixgbe_fc_full
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ixv.flow_control"
argument_list|,
operator|&
name|ixv_flow_control
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Header split: this causes the hardware to DMA  * the header into a seperate mbuf from the payload,  * it can be a performance win in some workloads, but  * in others it actually hurts, its off by default.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ixv_header_split
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ixv.hdr_split"
argument_list|,
operator|&
name|ixv_header_split
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ** Number of TX descriptors per ring, ** setting higher than RX as this seems ** the better performing choice. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ixv_txd
init|=
name|DEFAULT_TXD
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ixv.txd"
argument_list|,
operator|&
name|ixv_txd
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Number of RX descriptors per ring */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ixv_rxd
init|=
name|DEFAULT_RXD
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ixv.rxd"
argument_list|,
operator|&
name|ixv_rxd
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ** Shadow VFTA table, this is needed because ** the real filter table gets cleared during ** a soft reset and we need to repopulate it. */
end_comment

begin_decl_stmt
specifier|static
name|u32
name|ixv_shadow_vfta
index|[
name|IXGBE_VFTA_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************  *  Device identification routine  *  *  ixv_probe determines if the driver should be loaded on  *  adapter based on PCI vendor/device id of the adapter.  *  *  return BUS_PROBE_DEFAULT on success, positive on failure  *********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixv_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|ixgbe_vendor_info_t
modifier|*
name|ent
decl_stmt|;
name|u16
name|pci_vendor_id
init|=
literal|0
decl_stmt|;
name|u16
name|pci_device_id
init|=
literal|0
decl_stmt|;
name|u16
name|pci_subvendor_id
init|=
literal|0
decl_stmt|;
name|u16
name|pci_subdevice_id
init|=
literal|0
decl_stmt|;
name|char
name|adapter_name
index|[
literal|256
index|]
decl_stmt|;
name|pci_vendor_id
operator|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_vendor_id
operator|!=
name|IXGBE_INTEL_VENDOR_ID
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|pci_device_id
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_subvendor_id
operator|=
name|pci_get_subvendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_subdevice_id
operator|=
name|pci_get_subdevice
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ent
operator|=
name|ixv_vendor_info_array
expr_stmt|;
while|while
condition|(
name|ent
operator|->
name|vendor_id
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|pci_vendor_id
operator|==
name|ent
operator|->
name|vendor_id
operator|)
operator|&&
operator|(
name|pci_device_id
operator|==
name|ent
operator|->
name|device_id
operator|)
operator|&&
operator|(
operator|(
name|pci_subvendor_id
operator|==
name|ent
operator|->
name|subvendor_id
operator|)
operator|||
operator|(
name|ent
operator|->
name|subvendor_id
operator|==
literal|0
operator|)
operator|)
operator|&&
operator|(
operator|(
name|pci_subdevice_id
operator|==
name|ent
operator|->
name|subdevice_id
operator|)
operator|||
operator|(
name|ent
operator|->
name|subdevice_id
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|adapter_name
argument_list|,
literal|"%s, Version - %s"
argument_list|,
name|ixv_strings
index|[
name|ent
operator|->
name|index
index|]
argument_list|,
name|ixv_driver_version
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|adapter_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
name|ent
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Device initialization routine  *  *  The attach entry point is called when the driver is being loaded.  *  This routine identifies the type of hardware, allocates all resources  *  and initializes the hardware.  *  *  return 0 on success, positive on failure  *********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixv_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixv_attach: begin"
argument_list|)
expr_stmt|;
comment|/* Allocate, clear, and link in our adapter structure */
name|adapter
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|hw
operator|=
operator|&
name|adapter
operator|->
name|hw
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|adapter
operator|->
name|init_locked
operator|=
name|ixv_init_locked
expr_stmt|;
name|adapter
operator|->
name|stop_locked
operator|=
name|ixv_stop
expr_stmt|;
endif|#
directive|endif
comment|/* Core Lock Init*/
name|IXGBE_CORE_LOCK_INIT
argument_list|(
name|adapter
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* SYSCTL APIs */
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"debug"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|adapter
argument_list|,
literal|0
argument_list|,
name|ixv_sysctl_debug
argument_list|,
literal|"I"
argument_list|,
literal|"Debug Info"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"enable_aim"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ixv_enable_aim
argument_list|,
literal|1
argument_list|,
literal|"Interrupt Moderation"
argument_list|)
expr_stmt|;
comment|/* Set up the timer callout */
name|callout_init_mtx
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|,
operator|&
name|adapter
operator|->
name|core_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Determine hardware revision */
name|ixv_identify_hardware
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Do base PCI setup - map BAR0 */
if|if
condition|(
name|ixv_allocate_pci_resources
argument_list|(
name|adapter
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ixv_allocate_pci_resources() failed!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
comment|/* Sysctls for limiting the amount of work done in the taskqueues */
name|ixv_set_sysctl_value
argument_list|(
name|adapter
argument_list|,
literal|"rx_processing_limit"
argument_list|,
literal|"max number of rx packets to process"
argument_list|,
operator|&
name|adapter
operator|->
name|rx_process_limit
argument_list|,
name|ixv_rx_process_limit
argument_list|)
expr_stmt|;
name|ixv_set_sysctl_value
argument_list|(
name|adapter
argument_list|,
literal|"tx_processing_limit"
argument_list|,
literal|"max number of tx packets to process"
argument_list|,
operator|&
name|adapter
operator|->
name|tx_process_limit
argument_list|,
name|ixv_tx_process_limit
argument_list|)
expr_stmt|;
comment|/* Do descriptor calc and sanity checks */
if|if
condition|(
operator|(
operator|(
name|ixv_txd
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|ixgbe_adv_tx_desc
argument_list|)
operator|)
operator|%
name|DBA_ALIGN
operator|)
operator|!=
literal|0
operator|||
name|ixv_txd
operator|<
name|MIN_TXD
operator|||
name|ixv_txd
operator|>
name|MAX_TXD
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"TXD config issue, using default!\n"
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|num_tx_desc
operator|=
name|DEFAULT_TXD
expr_stmt|;
block|}
else|else
name|adapter
operator|->
name|num_tx_desc
operator|=
name|ixv_txd
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|ixv_rxd
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|ixgbe_adv_rx_desc
argument_list|)
operator|)
operator|%
name|DBA_ALIGN
operator|)
operator|!=
literal|0
operator|||
name|ixv_rxd
operator|<
name|MIN_RXD
operator|||
name|ixv_rxd
operator|>
name|MAX_RXD
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"RXD config issue, using default!\n"
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|num_rx_desc
operator|=
name|DEFAULT_RXD
expr_stmt|;
block|}
else|else
name|adapter
operator|->
name|num_rx_desc
operator|=
name|ixv_rxd
expr_stmt|;
comment|/* Allocate our TX/RX Queues */
if|if
condition|(
name|ixgbe_allocate_queues
argument_list|(
name|adapter
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ixgbe_allocate_queues() failed!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
comment|/* 	** Initialize the shared code: its 	** at this point the mac type is set. 	*/
name|error
operator|=
name|ixgbe_init_shared_code
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ixgbe_init_shared_code() failed!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|err_late
goto|;
block|}
comment|/* Setup the mailbox */
name|ixgbe_init_mbx_params_vf
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Reset mbox api to 1.0 */
name|error
operator|=
name|ixgbe_reset_hw
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|IXGBE_ERR_RESET_FAILED
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ixgbe_reset_hw() failure: Reset Failed!\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|error
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ixgbe_reset_hw() failed with error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|err_late
goto|;
block|}
comment|/* Negotiate mailbox API version */
name|error
operator|=
name|ixgbevf_negotiate_api_version
argument_list|(
name|hw
argument_list|,
name|ixgbe_mbox_api_11
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"MBX API 1.1 negotiation failed! Error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|err_late
goto|;
block|}
name|error
operator|=
name|ixgbe_init_hw
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ixgbe_init_hw() failed!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|err_late
goto|;
block|}
name|error
operator|=
name|ixv_allocate_msix
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ixv_allocate_msix() failed!\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_late
goto|;
block|}
comment|/* If no mac address was assigned, make a random one */
if|if
condition|(
operator|!
name|ixv_check_ether_addr
argument_list|(
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|)
condition|)
block|{
name|u8
name|addr
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
name|arc4rand
argument_list|(
operator|&
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr
index|[
literal|0
index|]
operator|&=
literal|0xFE
expr_stmt|;
name|addr
index|[
literal|0
index|]
operator||=
literal|0x02
expr_stmt|;
name|bcopy
argument_list|(
name|addr
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Setup OS specific network interface */
name|ixv_setup_interface
argument_list|(
name|dev
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
comment|/* Do the stats setup */
name|ixv_save_stats
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixv_init_stats
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixv_add_stats_sysctls
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Register for VLAN events */
name|adapter
operator|->
name|vlan_attach
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|vlan_config
argument_list|,
name|ixv_register_vlan
argument_list|,
name|adapter
argument_list|,
name|EVENTHANDLER_PRI_FIRST
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|vlan_detach
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|vlan_unconfig
argument_list|,
name|ixv_unregister_vlan
argument_list|,
name|adapter
argument_list|,
name|EVENTHANDLER_PRI_FIRST
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|ixgbe_netmap_attach
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEV_NETMAP */
name|INIT_DEBUGOUT
argument_list|(
literal|"ixv_attach: end"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|err_late
label|:
name|ixgbe_free_transmit_structures
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixgbe_free_receive_structures
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|err_out
label|:
name|ixv_free_pci_resources
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Device removal routine  *  *  The detach entry point is called when the driver is being removed.  *  This routine stops the adapter and deallocates all the resources  *  that were allocated for driver operation.  *  *  return 0 on success, positive on failure  *********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixv_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ix_queue
modifier|*
name|que
init|=
name|adapter
operator|->
name|queues
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixv_detach: begin"
argument_list|)
expr_stmt|;
comment|/* Make sure VLANS are not using driver */
if|if
condition|(
name|adapter
operator|->
name|ifp
operator|->
name|if_vlantrunk
operator|!=
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Vlan in use, detach first\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|IXGBE_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixv_stop
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|IXGBE_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
block|{
if|if
condition|(
name|que
operator|->
name|tq
condition|)
block|{
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|que
operator|->
name|txr
decl_stmt|;
name|taskqueue_drain
argument_list|(
name|que
operator|->
name|tq
argument_list|,
operator|&
name|txr
operator|->
name|txq_task
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|que
operator|->
name|tq
argument_list|,
operator|&
name|que
operator|->
name|que_task
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|que
operator|->
name|tq
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Drain the Mailbox(link) queue */
if|if
condition|(
name|adapter
operator|->
name|tq
condition|)
block|{
name|taskqueue_drain
argument_list|(
name|adapter
operator|->
name|tq
argument_list|,
operator|&
name|adapter
operator|->
name|link_task
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|adapter
operator|->
name|tq
argument_list|)
expr_stmt|;
block|}
comment|/* Unregister VLAN events */
if|if
condition|(
name|adapter
operator|->
name|vlan_attach
operator|!=
name|NULL
condition|)
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|vlan_config
argument_list|,
name|adapter
operator|->
name|vlan_attach
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|vlan_detach
operator|!=
name|NULL
condition|)
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|vlan_unconfig
argument_list|,
name|adapter
operator|->
name|vlan_detach
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|netmap_detach
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEV_NETMAP */
name|ixv_free_pci_resources
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|bus_generic_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|ixgbe_free_transmit_structures
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixgbe_free_receive_structures
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|IXGBE_CORE_LOCK_DESTROY
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Shutdown entry point  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixv_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|IXGBE_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixv_stop
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|IXGBE_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Ioctl entry point  *  *  ixv_ioctl is called when the user wants to configure the  *  interface.  *  *  return 0 on success, positive on failure  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixv_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
name|bool
name|avoid_reset
init|=
name|FALSE
decl_stmt|;
endif|#
directive|endif
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
name|avoid_reset
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
name|avoid_reset
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
comment|/* 		** Calling init results in link renegotiation, 		** so we avoid doing it when possible. 		*/
if|if
condition|(
name|avoid_reset
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
name|ixv_init
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_NOARP
operator|)
condition|)
name|arp_ifinit
argument_list|(
name|ifp
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|SIOCSIFMTU
case|:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl: SIOCSIFMTU (Set Interface MTU)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|>
name|IXGBE_MAX_FRAME_SIZE
operator|-
name|IXGBE_MTU_HDR
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|IXGBE_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
name|adapter
operator|->
name|max_frame_size
operator|=
name|ifp
operator|->
name|if_mtu
operator|+
name|IXGBE_MTU_HDR
expr_stmt|;
name|ixv_init_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|IXGBE_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFFLAGS
case|:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl: SIOCSIFFLAGS (Set Interface Flags)"
argument_list|)
expr_stmt|;
name|IXGBE_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
name|ixv_init_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|ixv_stop
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|if_flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
name|IXGBE_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl: SIOC(ADD|DEL)MULTI"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|IXGBE_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixv_disable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixv_set_multi
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixv_enable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|IXGBE_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl: SIOCxIFMEDIA (Get/Set Interface Media)"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
block|{
name|int
name|mask
init|=
name|ifr
operator|->
name|ifr_reqcap
operator|^
name|ifp
operator|->
name|if_capenable
decl_stmt|;
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl: SIOCSIFCAP (Set Capabilities)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_HWCSUM
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_HWCSUM
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO4
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TSO4
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_LRO
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_LRO
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWTAGGING
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWTAGGING
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|IXGBE_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixv_init_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|IXGBE_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
name|VLAN_CAPABILITIES
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|IOCTL_DEBUGOUT1
argument_list|(
literal|"ioctl: UNKNOWN (0x%X)\n"
argument_list|,
operator|(
name|int
operator|)
name|command
argument_list|)
expr_stmt|;
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Init entry point  *  *  This routine is used in two ways. It is used by the stack as  *  init entry point in network interface structure. It is also used  *  by the driver as a hw/sw initialization routine to get to a  *  consistent state.  *  *  return 0 on success, positive on failure  **********************************************************************/
end_comment

begin_define
define|#
directive|define
name|IXGBE_MHADD_MFS_SHIFT
value|16
end_define

begin_function
specifier|static
name|void
name|ixv_init_locked
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixv_init_locked: begin"
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|adapter
operator|->
name|core_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|hw
operator|->
name|adapter_stopped
operator|=
name|FALSE
expr_stmt|;
name|ixgbe_stop_adapter
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|)
expr_stmt|;
comment|/* reprogram the RAR[0] in case user changed it. */
name|ixgbe_set_rar
argument_list|(
name|hw
argument_list|,
literal|0
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|,
literal|0
argument_list|,
name|IXGBE_RAH_AV
argument_list|)
expr_stmt|;
comment|/* Get the latest mac address, User can use a LAA */
name|bcopy
argument_list|(
name|IF_LLADDR
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|)
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|,
name|IXGBE_ETH_LENGTH_OF_ADDRESS
argument_list|)
expr_stmt|;
name|ixgbe_set_rar
argument_list|(
name|hw
argument_list|,
literal|0
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hw
operator|->
name|addr_ctrl
operator|.
name|rar_used_count
operator|=
literal|1
expr_stmt|;
comment|/* Prepare transmit descriptors and buffers */
if|if
condition|(
name|ixgbe_setup_transmit_structures
argument_list|(
name|adapter
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not setup transmit structures\n"
argument_list|)
expr_stmt|;
name|ixv_stop
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Reset VF and renegotiate mailbox API version */
name|ixgbe_reset_hw
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|error
operator|=
name|ixgbevf_negotiate_api_version
argument_list|(
name|hw
argument_list|,
name|ixgbe_mbox_api_11
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"MBX API 1.1 negotiation failed! Error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ixv_initialize_transmit_units
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Setup Multicast table */
name|ixv_set_multi
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* 	** Determine the correct mbuf pool 	** for doing jumbo/headersplit 	*/
if|if
condition|(
name|ifp
operator|->
name|if_mtu
operator|>
name|ETHERMTU
condition|)
name|adapter
operator|->
name|rx_mbuf_sz
operator|=
name|MJUMPAGESIZE
expr_stmt|;
else|else
name|adapter
operator|->
name|rx_mbuf_sz
operator|=
name|MCLBYTES
expr_stmt|;
comment|/* Prepare receive descriptors and buffers */
if|if
condition|(
name|ixgbe_setup_receive_structures
argument_list|(
name|adapter
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not setup receive structures\n"
argument_list|)
expr_stmt|;
name|ixv_stop
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Configure RX settings */
name|ixv_initialize_receive_units
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Set the various hardware offload abilities */
name|ifp
operator|->
name|if_hwassist
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO4
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
name|CSUM_TSO
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM
condition|)
block|{
name|ifp
operator|->
name|if_hwassist
operator||=
operator|(
name|CSUM_TCP
operator||
name|CSUM_UDP
operator|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800000
name|ifp
operator|->
name|if_hwassist
operator||=
name|CSUM_SCTP
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Set up VLAN offload and filter */
name|ixv_setup_vlan_support
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Set up MSI/X routing */
name|ixv_configure_ivars
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Set up auto-mask */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VTEIAM
argument_list|,
name|IXGBE_EICS_RTX_QUEUE
argument_list|)
expr_stmt|;
comment|/* Set moderation on the Link interrupt */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VTEITR
argument_list|(
name|adapter
operator|->
name|vector
argument_list|)
argument_list|,
name|IXGBE_LINK_ITR
argument_list|)
expr_stmt|;
comment|/* Stats init */
name|ixv_init_stats
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Config/Enable Link */
name|ixv_config_link
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Start watchdog */
name|callout_reset
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|,
name|hz
argument_list|,
name|ixv_local_timer
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
comment|/* And now turn on interrupts */
name|ixv_enable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Now inform the stack we're ready */
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ixv_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|arg
decl_stmt|;
name|IXGBE_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixv_init_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|IXGBE_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ** ** MSIX Interrupt Handlers and Tasklets ** */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ixv_enable_queue
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|u32
name|vector
parameter_list|)
block|{
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|u32
name|queue
init|=
literal|1
operator|<<
name|vector
decl_stmt|;
name|u32
name|mask
decl_stmt|;
name|mask
operator|=
operator|(
name|IXGBE_EIMS_RTX_QUEUE
operator|&
name|queue
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VTEIMS
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ixv_disable_queue
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|u32
name|vector
parameter_list|)
block|{
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|u64
name|queue
init|=
call|(
name|u64
call|)
argument_list|(
literal|1
operator|<<
name|vector
argument_list|)
decl_stmt|;
name|u32
name|mask
decl_stmt|;
name|mask
operator|=
operator|(
name|IXGBE_EIMS_RTX_QUEUE
operator|&
name|queue
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VTEIMC
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ixv_rearm_queues
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|u64
name|queues
parameter_list|)
block|{
name|u32
name|mask
init|=
operator|(
name|IXGBE_EIMS_RTX_QUEUE
operator|&
name|queues
operator|)
decl_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_VTEICS
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixv_handle_que
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|ix_queue
modifier|*
name|que
init|=
name|context
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|que
operator|->
name|adapter
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|que
operator|->
name|txr
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|bool
name|more
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|more
operator|=
name|ixgbe_rxeof
argument_list|(
name|que
argument_list|)
expr_stmt|;
name|IXGBE_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|ixgbe_txeof
argument_list|(
name|txr
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800000
if|if
condition|(
operator|!
name|drbr_empty
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|)
condition|)
name|ixgbe_mq_start_locked
argument_list|(
name|ifp
argument_list|,
name|txr
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
name|ixgbe_start_locked
argument_list|(
name|txr
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|IXGBE_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
if|if
condition|(
name|more
condition|)
block|{
name|taskqueue_enqueue
argument_list|(
name|que
operator|->
name|tq
argument_list|,
operator|&
name|que
operator|->
name|que_task
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Reenable this interrupt */
name|ixv_enable_queue
argument_list|(
name|adapter
argument_list|,
name|que
operator|->
name|msix
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  MSI Queue Interrupt Service routine  *  **********************************************************************/
end_comment

begin_function
name|void
name|ixv_msix_que
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ix_queue
modifier|*
name|que
init|=
name|arg
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|que
operator|->
name|adapter
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|que
operator|->
name|txr
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
name|que
operator|->
name|rxr
decl_stmt|;
name|bool
name|more
decl_stmt|;
name|u32
name|newitr
init|=
literal|0
decl_stmt|;
name|ixv_disable_queue
argument_list|(
name|adapter
argument_list|,
name|que
operator|->
name|msix
argument_list|)
expr_stmt|;
operator|++
name|que
operator|->
name|irqs
expr_stmt|;
name|more
operator|=
name|ixgbe_rxeof
argument_list|(
name|que
argument_list|)
expr_stmt|;
name|IXGBE_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|ixgbe_txeof
argument_list|(
name|txr
argument_list|)
expr_stmt|;
comment|/* 	** Make certain that if the stack 	** has anything queued the task gets 	** scheduled to handle it. 	*/
ifdef|#
directive|ifdef
name|IXGBE_LEGACY_TX
if|if
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|adapter
operator|->
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
name|ixgbe_start_locked
argument_list|(
name|txr
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|drbr_empty
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|)
condition|)
name|ixgbe_mq_start_locked
argument_list|(
name|ifp
argument_list|,
name|txr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|IXGBE_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
comment|/* Do AIM now? */
if|if
condition|(
name|ixv_enable_aim
operator|==
name|FALSE
condition|)
goto|goto
name|no_calc
goto|;
comment|/* 	** Do Adaptive Interrupt Moderation:         **  - Write out last calculated setting 	**  - Calculate based on average size over 	**    the last interval. 	*/
if|if
condition|(
name|que
operator|->
name|eitr_setting
condition|)
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_VTEITR
argument_list|(
name|que
operator|->
name|msix
argument_list|)
argument_list|,
name|que
operator|->
name|eitr_setting
argument_list|)
expr_stmt|;
name|que
operator|->
name|eitr_setting
operator|=
literal|0
expr_stmt|;
comment|/* Idle, do nothing */
if|if
condition|(
operator|(
name|txr
operator|->
name|bytes
operator|==
literal|0
operator|)
operator|&&
operator|(
name|rxr
operator|->
name|bytes
operator|==
literal|0
operator|)
condition|)
goto|goto
name|no_calc
goto|;
if|if
condition|(
operator|(
name|txr
operator|->
name|bytes
operator|)
operator|&&
operator|(
name|txr
operator|->
name|packets
operator|)
condition|)
name|newitr
operator|=
name|txr
operator|->
name|bytes
operator|/
name|txr
operator|->
name|packets
expr_stmt|;
if|if
condition|(
operator|(
name|rxr
operator|->
name|bytes
operator|)
operator|&&
operator|(
name|rxr
operator|->
name|packets
operator|)
condition|)
name|newitr
operator|=
name|max
argument_list|(
name|newitr
argument_list|,
operator|(
name|rxr
operator|->
name|bytes
operator|/
name|rxr
operator|->
name|packets
operator|)
argument_list|)
expr_stmt|;
name|newitr
operator|+=
literal|24
expr_stmt|;
comment|/* account for hardware frame, crc */
comment|/* set an upper boundary */
name|newitr
operator|=
name|min
argument_list|(
name|newitr
argument_list|,
literal|3000
argument_list|)
expr_stmt|;
comment|/* Be nice to the mid range */
if|if
condition|(
operator|(
name|newitr
operator|>
literal|300
operator|)
operator|&&
operator|(
name|newitr
operator|<
literal|1200
operator|)
condition|)
name|newitr
operator|=
operator|(
name|newitr
operator|/
literal|3
operator|)
expr_stmt|;
else|else
name|newitr
operator|=
operator|(
name|newitr
operator|/
literal|2
operator|)
expr_stmt|;
name|newitr
operator||=
name|newitr
operator|<<
literal|16
expr_stmt|;
comment|/* save for next interrupt */
name|que
operator|->
name|eitr_setting
operator|=
name|newitr
expr_stmt|;
comment|/* Reset state */
name|txr
operator|->
name|bytes
operator|=
literal|0
expr_stmt|;
name|txr
operator|->
name|packets
operator|=
literal|0
expr_stmt|;
name|rxr
operator|->
name|bytes
operator|=
literal|0
expr_stmt|;
name|rxr
operator|->
name|packets
operator|=
literal|0
expr_stmt|;
name|no_calc
label|:
if|if
condition|(
name|more
condition|)
name|taskqueue_enqueue
argument_list|(
name|que
operator|->
name|tq
argument_list|,
operator|&
name|que
operator|->
name|que_task
argument_list|)
expr_stmt|;
else|else
comment|/* Reenable this interrupt */
name|ixv_enable_queue
argument_list|(
name|adapter
argument_list|,
name|que
operator|->
name|msix
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ixv_msix_mbx
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|arg
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|u32
name|reg
decl_stmt|;
operator|++
name|adapter
operator|->
name|link_irq
expr_stmt|;
comment|/* First get the cause */
name|reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VTEICS
argument_list|)
expr_stmt|;
comment|/* Clear interrupt with write */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VTEICR
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Link status change */
if|if
condition|(
name|reg
operator|&
name|IXGBE_EICR_LSC
condition|)
name|taskqueue_enqueue
argument_list|(
name|adapter
operator|->
name|tq
argument_list|,
operator|&
name|adapter
operator|->
name|link_task
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VTEIMS
argument_list|,
name|IXGBE_EIMS_OTHER
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Media Ioctl callback  *  *  This routine is called whenever the user queries the status of  *  the interface using ifconfig.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixv_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixv_media_status: begin"
argument_list|)
expr_stmt|;
name|IXGBE_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixv_update_link_status
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
expr_stmt|;
if|if
condition|(
operator|!
name|adapter
operator|->
name|link_active
condition|)
block|{
name|IXGBE_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return;
block|}
name|ifmr
operator|->
name|ifm_status
operator||=
name|IFM_ACTIVE
expr_stmt|;
switch|switch
condition|(
name|adapter
operator|->
name|link_speed
condition|)
block|{
case|case
name|IXGBE_LINK_SPEED_1GB_FULL
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_1000_T
operator||
name|IFM_FDX
expr_stmt|;
break|break;
case|case
name|IXGBE_LINK_SPEED_10GB_FULL
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_FDX
expr_stmt|;
break|break;
block|}
name|IXGBE_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Media Ioctl callback  *  *  This routine is called when the user changes speed/duplex using  *  media/mediopt option with ifconfig.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixv_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifmedia
modifier|*
name|ifm
init|=
operator|&
name|adapter
operator|->
name|media
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixv_media_change: begin"
argument_list|)
expr_stmt|;
if|if
condition|(
name|IFM_TYPE
argument_list|(
name|ifm
operator|->
name|ifm_media
argument_list|)
operator|!=
name|IFM_ETHER
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
switch|switch
condition|(
name|IFM_SUBTYPE
argument_list|(
name|ifm
operator|->
name|ifm_media
argument_list|)
condition|)
block|{
case|case
name|IFM_AUTO
case|:
break|break;
default|default:
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"Only auto media type\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Multicast Update  *  *  This routine is called whenever multicast address list is updated.  *  **********************************************************************/
end_comment

begin_define
define|#
directive|define
name|IXGBE_RAR_ENTRIES
value|16
end_define

begin_function
specifier|static
name|void
name|ixv_set_multi
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|u8
name|mta
index|[
name|MAX_NUM_MULTICAST_ADDRESSES
operator|*
name|IXGBE_ETH_LENGTH_OF_ADDRESS
index|]
decl_stmt|;
name|u8
modifier|*
name|update_ptr
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|int
name|mcnt
init|=
literal|0
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ixv_set_multi: begin"
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|800000
name|IF_ADDR_LOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
else|#
directive|else
name|if_maddr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|bcopy
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|,
operator|&
name|mta
index|[
name|mcnt
operator|*
name|IXGBE_ETH_LENGTH_OF_ADDRESS
index|]
argument_list|,
name|IXGBE_ETH_LENGTH_OF_ADDRESS
argument_list|)
expr_stmt|;
name|mcnt
operator|++
expr_stmt|;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|800000
name|IF_ADDR_UNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
else|#
directive|else
name|if_maddr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|update_ptr
operator|=
name|mta
expr_stmt|;
name|ixgbe_update_mc_addr_list
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|update_ptr
argument_list|,
name|mcnt
argument_list|,
name|ixv_mc_array_itr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * This is an iterator function now needed by the multicast  * shared code. It simply feeds the shared code routine the  * addresses in the array of ixv_set_multi() one by one.  */
end_comment

begin_function
specifier|static
name|u8
modifier|*
name|ixv_mc_array_itr
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
modifier|*
name|update_ptr
parameter_list|,
name|u32
modifier|*
name|vmdq
parameter_list|)
block|{
name|u8
modifier|*
name|addr
init|=
operator|*
name|update_ptr
decl_stmt|;
name|u8
modifier|*
name|newptr
decl_stmt|;
operator|*
name|vmdq
operator|=
literal|0
expr_stmt|;
name|newptr
operator|=
name|addr
operator|+
name|IXGBE_ETH_LENGTH_OF_ADDRESS
expr_stmt|;
operator|*
name|update_ptr
operator|=
name|newptr
expr_stmt|;
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Timer routine  *  *  This routine checks for link status,updates statistics,  *  and runs the watchdog check.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixv_local_timer
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|arg
decl_stmt|;
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|struct
name|ix_queue
modifier|*
name|que
init|=
name|adapter
operator|->
name|queues
decl_stmt|;
name|u64
name|queues
init|=
literal|0
decl_stmt|;
name|int
name|hung
init|=
literal|0
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|adapter
operator|->
name|core_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|ixv_update_link_status
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Stats Update */
name|ixv_update_stats
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* 	** Check the TX queues status 	**      - mark hung queues so we don't schedule on them 	**      - watchdog only if all queues show hung 	*/
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
block|{
comment|/* Keep track of queues with work for soft irq */
if|if
condition|(
name|que
operator|->
name|txr
operator|->
name|busy
condition|)
name|queues
operator||=
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|que
operator|->
name|me
operator|)
expr_stmt|;
comment|/* 		** Each time txeof runs without cleaning, but there 		** are uncleaned descriptors it increments busy. If 		** we get to the MAX we declare it hung. 		*/
if|if
condition|(
name|que
operator|->
name|busy
operator|==
name|IXGBE_QUEUE_HUNG
condition|)
block|{
operator|++
name|hung
expr_stmt|;
comment|/* Mark the queue as inactive */
name|adapter
operator|->
name|active_queues
operator|&=
operator|~
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|que
operator|->
name|me
operator|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
comment|/* Check if we've come back from hung */
if|if
condition|(
operator|(
name|adapter
operator|->
name|active_queues
operator|&
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|que
operator|->
name|me
operator|)
operator|)
operator|==
literal|0
condition|)
name|adapter
operator|->
name|active_queues
operator||=
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|que
operator|->
name|me
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|que
operator|->
name|busy
operator|>=
name|IXGBE_MAX_TX_BUSY
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Warning queue %d "
literal|"appears to be hung!\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|que
operator|->
name|txr
operator|->
name|busy
operator|=
name|IXGBE_QUEUE_HUNG
expr_stmt|;
operator|++
name|hung
expr_stmt|;
block|}
block|}
comment|/* Only truely watchdog if all queues show hung */
if|if
condition|(
name|hung
operator|==
name|adapter
operator|->
name|num_queues
condition|)
goto|goto
name|watchdog
goto|;
elseif|else
if|if
condition|(
name|queues
operator|!=
literal|0
condition|)
block|{
comment|/* Force an IRQ on queues with work */
name|ixv_rearm_queues
argument_list|(
name|adapter
argument_list|,
name|queues
argument_list|)
expr_stmt|;
block|}
name|callout_reset
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|,
name|hz
argument_list|,
name|ixv_local_timer
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
return|return;
name|watchdog
label|:
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"Watchdog timeout -- resetting\n"
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|adapter
operator|->
name|watchdog_events
operator|++
expr_stmt|;
name|ixv_init_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Note: this routine updates the OS on the link state **	the real check of the hardware only happens with **	a link interrupt. */
end_comment

begin_function
specifier|static
name|void
name|ixv_update_link_status
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
if|if
condition|(
name|adapter
operator|->
name|link_up
condition|)
block|{
if|if
condition|(
name|adapter
operator|->
name|link_active
operator|==
name|FALSE
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Link is up %d Gbps %s \n"
argument_list|,
operator|(
operator|(
name|adapter
operator|->
name|link_speed
operator|==
literal|128
operator|)
condition|?
literal|10
else|:
literal|1
operator|)
argument_list|,
literal|"Full Duplex"
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|link_active
operator|=
name|TRUE
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_UP
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Link down */
if|if
condition|(
name|adapter
operator|->
name|link_active
operator|==
name|TRUE
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Link is Down\n"
argument_list|)
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_DOWN
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|link_active
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  This routine disables all traffic on the adapter by issuing a  *  global reset on the MAC and deallocates TX/RX buffers.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixv_stop
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|arg
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|ifp
operator|=
name|adapter
operator|->
name|ifp
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|adapter
operator|->
name|core_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixv_stop: begin\n"
argument_list|)
expr_stmt|;
name|ixv_disable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Tell the stack that the interface is no longer active */
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
name|ixgbe_reset_hw
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|adapter_stopped
operator|=
name|FALSE
expr_stmt|;
name|ixgbe_stop_adapter
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|)
expr_stmt|;
comment|/* reprogram the RAR[0] in case user changed it. */
name|ixgbe_set_rar
argument_list|(
name|hw
argument_list|,
literal|0
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|,
literal|0
argument_list|,
name|IXGBE_RAH_AV
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Determine hardware revision.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixv_identify_hardware
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
comment|/* 	** Make sure BUSMASTER is set, on a VM under 	** KVM it may not be and will break things. 	*/
name|pci_enable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Save off the information about this board */
name|hw
operator|->
name|vendor_id
operator|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|hw
operator|->
name|device_id
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|hw
operator|->
name|revision_id
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_REVID
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hw
operator|->
name|subsystem_vendor_id
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SUBVEND_0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|hw
operator|->
name|subsystem_device_id
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SUBDEV_0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* We need this to determine device-specific things */
name|ixgbe_set_mac_type
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Set the right number of segments */
name|adapter
operator|->
name|num_segs
operator|=
name|IXGBE_82599_SCATTER
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Setup MSIX Interrupt resources and handlers   *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixv_allocate_msix
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|struct
name|ix_queue
modifier|*
name|que
init|=
name|adapter
operator|->
name|queues
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
name|int
name|error
decl_stmt|,
name|rid
decl_stmt|,
name|vector
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|vector
operator|++
operator|,
name|que
operator|++
operator|,
name|txr
operator|++
control|)
block|{
name|rid
operator|=
name|vector
operator|+
literal|1
expr_stmt|;
name|que
operator|->
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|que
operator|->
name|res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate"
literal|" bus resource: que interrupt [%d]\n"
argument_list|,
name|vector
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Set the handler function */
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|que
operator|->
name|res
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|ixv_msix_que
argument_list|,
name|que
argument_list|,
operator|&
name|que
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|que
operator|->
name|res
operator|=
name|NULL
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to register QUE handler"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800504
name|bus_describe_intr
argument_list|(
name|dev
argument_list|,
name|que
operator|->
name|res
argument_list|,
name|que
operator|->
name|tag
argument_list|,
literal|"que %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|que
operator|->
name|msix
operator|=
name|vector
expr_stmt|;
name|adapter
operator|->
name|active_queues
operator||=
call|(
name|u64
call|)
argument_list|(
literal|1
operator|<<
name|que
operator|->
name|msix
argument_list|)
expr_stmt|;
comment|/* 		** Bind the msix vector, and thus the 		** ring to the corresponding cpu. 		*/
if|if
condition|(
name|adapter
operator|->
name|num_queues
operator|>
literal|1
condition|)
name|bus_bind_intr
argument_list|(
name|dev
argument_list|,
name|que
operator|->
name|res
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|txr
operator|->
name|txq_task
argument_list|,
literal|0
argument_list|,
name|ixgbe_deferred_mq_start
argument_list|,
name|txr
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|que
operator|->
name|que_task
argument_list|,
literal|0
argument_list|,
name|ixv_handle_que
argument_list|,
name|que
argument_list|)
expr_stmt|;
name|que
operator|->
name|tq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"ixv_que"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|que
operator|->
name|tq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|que
operator|->
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s que"
argument_list|,
name|device_get_nameunit
argument_list|(
name|adapter
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* and Mailbox */
name|rid
operator|=
name|vector
operator|+
literal|1
expr_stmt|;
name|adapter
operator|->
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|adapter
operator|->
name|res
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate"
literal|" bus resource: MBX interrupt [%d]\n"
argument_list|,
name|rid
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Set the mbx handler function */
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|adapter
operator|->
name|res
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|ixv_msix_mbx
argument_list|,
name|adapter
argument_list|,
operator|&
name|adapter
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|adapter
operator|->
name|res
operator|=
name|NULL
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to register LINK handler"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800504
name|bus_describe_intr
argument_list|(
name|dev
argument_list|,
name|adapter
operator|->
name|res
argument_list|,
name|adapter
operator|->
name|tag
argument_list|,
literal|"mbx"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|adapter
operator|->
name|vector
operator|=
name|vector
expr_stmt|;
comment|/* Tasklets for Mailbox */
name|TASK_INIT
argument_list|(
operator|&
name|adapter
operator|->
name|link_task
argument_list|,
literal|0
argument_list|,
name|ixv_handle_mbx
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|tq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"ixv_mbx"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|adapter
operator|->
name|tq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|adapter
operator|->
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s mbxq"
argument_list|,
name|device_get_nameunit
argument_list|(
name|adapter
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	** Due to a broken design QEMU will fail to properly 	** enable the guest for MSIX unless the vectors in 	** the table are all set up, so we must rewrite the 	** ENABLE in the MSIX control register again at this 	** point to cause it to successfully initialize us. 	*/
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_82599_vf
condition|)
block|{
name|int
name|msix_ctrl
decl_stmt|;
name|pci_find_cap
argument_list|(
name|dev
argument_list|,
name|PCIY_MSIX
argument_list|,
operator|&
name|rid
argument_list|)
expr_stmt|;
name|rid
operator|+=
name|PCIR_MSIX_CTRL
expr_stmt|;
name|msix_ctrl
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|rid
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|msix_ctrl
operator||=
name|PCIM_MSIXCTRL_MSIX_ENABLE
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|rid
argument_list|,
name|msix_ctrl
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Setup MSIX resources, note that the VF  * device MUST use MSIX, there is no fallback.  */
end_comment

begin_function
specifier|static
name|int
name|ixv_setup_msix
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|int
name|rid
decl_stmt|,
name|want
decl_stmt|,
name|msgs
decl_stmt|;
comment|/* Must have at least 2 MSIX vectors */
name|msgs
operator|=
name|pci_msix_count
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|msgs
operator|<
literal|2
condition|)
goto|goto
name|out
goto|;
name|rid
operator|=
name|PCIR_BAR
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|msix_mem
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|msix_mem
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"Unable to map MSIX table \n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	** Want vectors for the queues, 	** plus an additional for mailbox. 	*/
name|want
operator|=
name|adapter
operator|->
name|num_queues
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|want
operator|>
name|msgs
condition|)
block|{
name|want
operator|=
name|msgs
expr_stmt|;
name|adapter
operator|->
name|num_queues
operator|=
name|msgs
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|msgs
operator|=
name|want
expr_stmt|;
if|if
condition|(
operator|(
name|pci_alloc_msix
argument_list|(
name|dev
argument_list|,
operator|&
name|msgs
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|msgs
operator|==
name|want
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"Using MSIX interrupts with %d vectors\n"
argument_list|,
name|want
argument_list|)
expr_stmt|;
return|return
operator|(
name|want
operator|)
return|;
block|}
comment|/* Release in case alloc was insufficient */
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|adapter
operator|->
name|msix_mem
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|rid
argument_list|,
name|adapter
operator|->
name|msix_mem
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|msix_mem
operator|=
name|NULL
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"MSIX config error\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixv_allocate_pci_resources
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|int
name|rid
decl_stmt|;
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|rid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|pci_mem
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|adapter
operator|->
name|pci_mem
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate bus resource: memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|adapter
operator|->
name|osdep
operator|.
name|mem_bus_space_tag
operator|=
name|rman_get_bustag
argument_list|(
name|adapter
operator|->
name|pci_mem
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|osdep
operator|.
name|mem_bus_space_handle
operator|=
name|rman_get_bushandle
argument_list|(
name|adapter
operator|->
name|pci_mem
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|hw_addr
operator|=
operator|(
name|u8
operator|*
operator|)
operator|&
name|adapter
operator|->
name|osdep
operator|.
name|mem_bus_space_handle
expr_stmt|;
comment|/* Pick up the tuneable queues */
name|adapter
operator|->
name|num_queues
operator|=
name|ixv_num_queues
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|back
operator|=
name|adapter
expr_stmt|;
comment|/* 	** Now setup MSI/X, should 	** return us the number of 	** configured vectors. 	*/
name|adapter
operator|->
name|msix
operator|=
name|ixv_setup_msix
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|msix
operator|==
name|ENXIO
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixv_free_pci_resources
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ix_queue
modifier|*
name|que
init|=
name|adapter
operator|->
name|queues
decl_stmt|;
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|int
name|rid
decl_stmt|,
name|memrid
decl_stmt|;
name|memrid
operator|=
name|PCIR_BAR
argument_list|(
name|MSIX_82598_BAR
argument_list|)
expr_stmt|;
comment|/* 	** There is a slight possibility of a failure mode 	** in attach that will result in entering this function 	** before interrupt resources have been initialized, and 	** in that case we do not want to execute the loops below 	** We can detect this reliably by the state of the adapter 	** res pointer. 	*/
if|if
condition|(
name|adapter
operator|->
name|res
operator|==
name|NULL
condition|)
goto|goto
name|mem
goto|;
comment|/* 	**  Release all msix queue resources: 	*/
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
block|{
name|rid
operator|=
name|que
operator|->
name|msix
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|que
operator|->
name|tag
operator|!=
name|NULL
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|que
operator|->
name|res
argument_list|,
name|que
operator|->
name|tag
argument_list|)
expr_stmt|;
name|que
operator|->
name|tag
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|que
operator|->
name|res
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rid
argument_list|,
name|que
operator|->
name|res
argument_list|)
expr_stmt|;
block|}
comment|/* Clean the Legacy or Link interrupt last */
if|if
condition|(
name|adapter
operator|->
name|vector
condition|)
comment|/* we are doing MSIX */
name|rid
operator|=
name|adapter
operator|->
name|vector
operator|+
literal|1
expr_stmt|;
else|else
operator|(
name|adapter
operator|->
name|msix
operator|!=
literal|0
operator|)
condition|?
operator|(
name|rid
operator|=
literal|1
operator|)
else|:
operator|(
name|rid
operator|=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|tag
operator|!=
name|NULL
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|adapter
operator|->
name|res
argument_list|,
name|adapter
operator|->
name|tag
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|tag
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|adapter
operator|->
name|res
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rid
argument_list|,
name|adapter
operator|->
name|res
argument_list|)
expr_stmt|;
name|mem
label|:
if|if
condition|(
name|adapter
operator|->
name|msix
condition|)
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|msix_mem
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|memrid
argument_list|,
name|adapter
operator|->
name|msix_mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|pci_mem
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|adapter
operator|->
name|pci_mem
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Setup networking device structure and register an interface.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixv_setup_interface
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixv_setup_interface: begin"
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|adapter
operator|->
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"%s: can not if_alloc()\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_baudrate
operator|=
literal|1000000000
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|ixv_init
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|adapter
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|ixv_ioctl
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800000
name|ifp
operator|->
name|if_transmit
operator|=
name|ixgbe_mq_start
expr_stmt|;
name|ifp
operator|->
name|if_qflush
operator|=
name|ixgbe_qflush
expr_stmt|;
else|#
directive|else
name|ifp
operator|->
name|if_start
operator|=
name|ixgbe_start
expr_stmt|;
endif|#
directive|endif
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|adapter
operator|->
name|num_tx_desc
operator|-
literal|2
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|addr
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|max_frame_size
operator|=
name|ifp
operator|->
name|if_mtu
operator|+
name|IXGBE_MTU_HDR_VLAN
expr_stmt|;
comment|/* 	 * Tell the upper layer(s) we support long frames. 	 */
name|ifp
operator|->
name|if_hdrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_vlan_header
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_HWCSUM
operator||
name|IFCAP_TSO4
operator||
name|IFCAP_VLAN_HWCSUM
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_JUMBO_MTU
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_VLAN_HWTAGGING
operator||
name|IFCAP_VLAN_HWTSO
operator||
name|IFCAP_VLAN_MTU
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_LRO
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|=
name|ifp
operator|->
name|if_capabilities
expr_stmt|;
comment|/* 	 * Specify the media types supported by this adapter and register 	 * callbacks to update media and link information 	 */
name|ifmedia_init
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_IMASK
argument_list|,
name|ixv_media_change
argument_list|,
name|ixv_media_status
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ixv_config_link
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|u32
name|autoneg
decl_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|check_link
condition|)
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|check_link
argument_list|(
name|hw
argument_list|,
operator|&
name|autoneg
argument_list|,
operator|&
name|adapter
operator|->
name|link_up
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Enable transmit unit.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixv_initialize_transmit_units
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|txr
operator|++
control|)
block|{
name|u64
name|tdba
init|=
name|txr
operator|->
name|txdma
operator|.
name|dma_paddr
decl_stmt|;
name|u32
name|txctrl
decl_stmt|,
name|txdctl
decl_stmt|;
comment|/* Set WTHRESH to 8, burst writeback */
name|txdctl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VFTXDCTL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|txdctl
operator||=
operator|(
literal|8
operator|<<
literal|16
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VFTXDCTL
argument_list|(
name|i
argument_list|)
argument_list|,
name|txdctl
argument_list|)
expr_stmt|;
comment|/* Set the HW Tx Head and Tail indices */
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_VFTDH
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_VFTDT
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set Tx Tail register */
name|txr
operator|->
name|tail
operator|=
name|IXGBE_VFTDT
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* Set Ring parameters */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VFTDBAL
argument_list|(
name|i
argument_list|)
argument_list|,
operator|(
name|tdba
operator|&
literal|0x00000000ffffffffULL
operator|)
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VFTDBAH
argument_list|(
name|i
argument_list|)
argument_list|,
operator|(
name|tdba
operator|>>
literal|32
operator|)
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VFTDLEN
argument_list|(
name|i
argument_list|)
argument_list|,
name|adapter
operator|->
name|num_tx_desc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ixgbe_legacy_tx_desc
argument_list|)
argument_list|)
expr_stmt|;
name|txctrl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VFDCA_TXCTRL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|txctrl
operator|&=
operator|~
name|IXGBE_DCA_TXCTRL_DESC_WRO_EN
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VFDCA_TXCTRL
argument_list|(
name|i
argument_list|)
argument_list|,
name|txctrl
argument_list|)
expr_stmt|;
comment|/* Now enable */
name|txdctl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VFTXDCTL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|txdctl
operator||=
name|IXGBE_TXDCTL_ENABLE
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VFTXDCTL
argument_list|(
name|i
argument_list|)
argument_list|,
name|txdctl
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Setup receive registers and features.  *  **********************************************************************/
end_comment

begin_define
define|#
directive|define
name|IXGBE_SRRCTL_BSIZEHDRSIZE_SHIFT
value|2
end_define

begin_function
specifier|static
name|void
name|ixv_initialize_receive_units
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
name|adapter
operator|->
name|rx_rings
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|u32
name|bufsz
decl_stmt|,
name|rxcsum
decl_stmt|,
name|psrtype
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_mtu
operator|>
name|ETHERMTU
condition|)
name|bufsz
operator|=
literal|4096
operator|>>
name|IXGBE_SRRCTL_BSIZEPKT_SHIFT
expr_stmt|;
else|else
name|bufsz
operator|=
literal|2048
operator|>>
name|IXGBE_SRRCTL_BSIZEPKT_SHIFT
expr_stmt|;
name|psrtype
operator|=
name|IXGBE_PSRTYPE_TCPHDR
operator||
name|IXGBE_PSRTYPE_UDPHDR
operator||
name|IXGBE_PSRTYPE_IPV4HDR
operator||
name|IXGBE_PSRTYPE_IPV6HDR
operator||
name|IXGBE_PSRTYPE_L2HDR
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VFPSRTYPE
argument_list|,
name|psrtype
argument_list|)
expr_stmt|;
comment|/* Tell PF our max_frame size */
name|ixgbevf_rlpml_set_vf
argument_list|(
name|hw
argument_list|,
name|adapter
operator|->
name|max_frame_size
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|rxr
operator|++
control|)
block|{
name|u64
name|rdba
init|=
name|rxr
operator|->
name|rxdma
operator|.
name|dma_paddr
decl_stmt|;
name|u32
name|reg
decl_stmt|,
name|rxdctl
decl_stmt|;
comment|/* Disable the queue */
name|rxdctl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VFRXDCTL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|rxdctl
operator|&=
operator|~
name|IXGBE_RXDCTL_ENABLE
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VFRXDCTL
argument_list|(
name|i
argument_list|)
argument_list|,
name|rxdctl
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|10
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VFRXDCTL
argument_list|(
name|i
argument_list|)
argument_list|)
operator|&
name|IXGBE_RXDCTL_ENABLE
condition|)
name|msec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
name|wmb
argument_list|()
expr_stmt|;
comment|/* Setup the Base and Length of the Rx Descriptor Ring */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VFRDBAL
argument_list|(
name|i
argument_list|)
argument_list|,
operator|(
name|rdba
operator|&
literal|0x00000000ffffffffULL
operator|)
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VFRDBAH
argument_list|(
name|i
argument_list|)
argument_list|,
operator|(
name|rdba
operator|>>
literal|32
operator|)
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VFRDLEN
argument_list|(
name|i
argument_list|)
argument_list|,
name|adapter
operator|->
name|num_rx_desc
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|ixgbe_adv_rx_desc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Reset the ring indices */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VFRDH
argument_list|(
name|rxr
operator|->
name|me
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VFRDT
argument_list|(
name|rxr
operator|->
name|me
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set up the SRRCTL register */
name|reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VFSRRCTL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|IXGBE_SRRCTL_BSIZEHDR_MASK
expr_stmt|;
name|reg
operator|&=
operator|~
name|IXGBE_SRRCTL_BSIZEPKT_MASK
expr_stmt|;
name|reg
operator||=
name|bufsz
expr_stmt|;
name|reg
operator||=
name|IXGBE_SRRCTL_DESCTYPE_ADV_ONEBUF
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VFSRRCTL
argument_list|(
name|i
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Capture Rx Tail index */
name|rxr
operator|->
name|tail
operator|=
name|IXGBE_VFRDT
argument_list|(
name|rxr
operator|->
name|me
argument_list|)
expr_stmt|;
comment|/* Do the queue enabling last */
name|rxdctl
operator||=
name|IXGBE_RXDCTL_ENABLE
operator||
name|IXGBE_RXDCTL_VME
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VFRXDCTL
argument_list|(
name|i
argument_list|)
argument_list|,
name|rxdctl
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
literal|10
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VFRXDCTL
argument_list|(
name|i
argument_list|)
argument_list|)
operator|&
name|IXGBE_RXDCTL_ENABLE
condition|)
break|break;
else|else
name|msec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|wmb
argument_list|()
expr_stmt|;
comment|/* Set the Tail Pointer */
ifdef|#
directive|ifdef
name|DEV_NETMAP
comment|/* 		 * In netmap mode, we must preserve the buffers made 		 * available to userspace before the if_init() 		 * (this is true by default on the TX side, because 		 * init makes all buffers available to userspace). 		 * 		 * netmap_reset() and the device specific routines 		 * (e.g. ixgbe_setup_receive_rings()) map these 		 * buffers at the end of the NIC ring, so here we 		 * must set the RDT (tail) register to make sure 		 * they are not overwritten. 		 * 		 * In this driver the NIC ring starts at RDH = 0, 		 * RDT points to the last slot available for reception (?), 		 * so RDT = num_rx_desc - 1 means the whole ring is available. 		 */
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_NETMAP
condition|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
decl_stmt|;
name|int
name|t
init|=
name|na
operator|->
name|num_rx_desc
operator|-
literal|1
operator|-
name|nm_kr_rxspace
argument_list|(
name|kring
argument_list|)
decl_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VFRDT
argument_list|(
name|rxr
operator|->
name|me
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* DEV_NETMAP */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VFRDT
argument_list|(
name|rxr
operator|->
name|me
argument_list|)
argument_list|,
name|adapter
operator|->
name|num_rx_desc
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|rxcsum
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXCSUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_RXCSUM
condition|)
name|rxcsum
operator||=
name|IXGBE_RXCSUM_PCSD
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|rxcsum
operator|&
name|IXGBE_RXCSUM_PCSD
operator|)
condition|)
name|rxcsum
operator||=
name|IXGBE_RXCSUM_IPPCSE
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXCSUM
argument_list|,
name|rxcsum
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ixv_setup_vlan_support
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|u32
name|ctrl
decl_stmt|,
name|vid
decl_stmt|,
name|vfta
decl_stmt|,
name|retry
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
decl_stmt|;
comment|/* 	** We get here thru init_locked, meaning 	** a soft reset, this has already cleared 	** the VFTA and other state, so if there 	** have been no vlan's registered do nothing. 	*/
if|if
condition|(
name|adapter
operator|->
name|num_vlans
operator|==
literal|0
condition|)
return|return;
comment|/* Enable the queues */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|ctrl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VFRXDCTL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|ctrl
operator||=
name|IXGBE_RXDCTL_VME
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VFRXDCTL
argument_list|(
name|i
argument_list|)
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
comment|/* 		 * Let Rx path know that it needs to store VLAN tag 		 * as part of extra mbuf info. 		 */
name|rxr
operator|=
operator|&
name|adapter
operator|->
name|rx_rings
index|[
name|i
index|]
expr_stmt|;
name|rxr
operator|->
name|vtag_strip
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* 	** A soft reset zero's out the VFTA, so 	** we need to repopulate it now. 	*/
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|IXGBE_VFTA_SIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ixv_shadow_vfta
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
name|vfta
operator|=
name|ixv_shadow_vfta
index|[
name|i
index|]
expr_stmt|;
comment|/* 		** Reconstruct the vlan id's 		** based on the bits set in each 		** of the array ints. 		*/
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|32
condition|;
name|j
operator|++
control|)
block|{
name|retry
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|vfta
operator|&
operator|(
literal|1
operator|<<
name|j
operator|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|vid
operator|=
operator|(
name|i
operator|*
literal|32
operator|)
operator|+
name|j
expr_stmt|;
comment|/* Call the shared code mailbox routine */
while|while
condition|(
name|ixgbe_set_vfta
argument_list|(
name|hw
argument_list|,
name|vid
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
if|if
condition|(
operator|++
name|retry
operator|>
literal|5
condition|)
break|break;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* ** This routine is run via an vlan config EVENT, ** it enables us to use the HW Filter table since ** we can get the vlan id. This just creates the ** entry in the soft version of the VFTA, init will ** repopulate the real table. */
end_comment

begin_function
specifier|static
name|void
name|ixv_register_vlan
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u16
name|vtag
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|u16
name|index
decl_stmt|,
name|bit
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_softc
operator|!=
name|arg
condition|)
comment|/* Not our event */
return|return;
if|if
condition|(
operator|(
name|vtag
operator|==
literal|0
operator|)
operator|||
operator|(
name|vtag
operator|>
literal|4095
operator|)
condition|)
comment|/* Invalid */
return|return;
name|IXGBE_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|index
operator|=
operator|(
name|vtag
operator|>>
literal|5
operator|)
operator|&
literal|0x7F
expr_stmt|;
name|bit
operator|=
name|vtag
operator|&
literal|0x1F
expr_stmt|;
name|ixv_shadow_vfta
index|[
name|index
index|]
operator||=
operator|(
literal|1
operator|<<
name|bit
operator|)
expr_stmt|;
operator|++
name|adapter
operator|->
name|num_vlans
expr_stmt|;
comment|/* Re-init to load the changes */
name|ixv_init_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|IXGBE_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** This routine is run via an vlan ** unconfig EVENT, remove our entry ** in the soft vfta. */
end_comment

begin_function
specifier|static
name|void
name|ixv_unregister_vlan
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u16
name|vtag
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|u16
name|index
decl_stmt|,
name|bit
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_softc
operator|!=
name|arg
condition|)
return|return;
if|if
condition|(
operator|(
name|vtag
operator|==
literal|0
operator|)
operator|||
operator|(
name|vtag
operator|>
literal|4095
operator|)
condition|)
comment|/* Invalid */
return|return;
name|IXGBE_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|index
operator|=
operator|(
name|vtag
operator|>>
literal|5
operator|)
operator|&
literal|0x7F
expr_stmt|;
name|bit
operator|=
name|vtag
operator|&
literal|0x1F
expr_stmt|;
name|ixv_shadow_vfta
index|[
name|index
index|]
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|bit
operator|)
expr_stmt|;
operator|--
name|adapter
operator|->
name|num_vlans
expr_stmt|;
comment|/* Re-init to load the changes */
name|ixv_init_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|IXGBE_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixv_enable_intr
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|struct
name|ix_queue
modifier|*
name|que
init|=
name|adapter
operator|->
name|queues
decl_stmt|;
name|u32
name|mask
init|=
operator|(
name|IXGBE_EIMS_ENABLE_MASK
operator|&
operator|~
name|IXGBE_EIMS_RTX_QUEUE
operator|)
decl_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VTEIMS
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|mask
operator|=
name|IXGBE_EIMS_ENABLE_MASK
expr_stmt|;
name|mask
operator|&=
operator|~
operator|(
name|IXGBE_EIMS_OTHER
operator||
name|IXGBE_EIMS_LSC
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VTEIAC
argument_list|,
name|mask
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
name|ixv_enable_queue
argument_list|(
name|adapter
argument_list|,
name|que
operator|->
name|msix
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ixv_disable_intr
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_VTEIAC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_VTEIMC
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ** Setup the correct IVAR register for a particular MSIX interrupt **  - entry is the register array entry **  - vector is the MSIX vector for this queue **  - type is RX/TX/MISC */
end_comment

begin_function
specifier|static
name|void
name|ixv_set_ivar
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|u8
name|entry
parameter_list|,
name|u8
name|vector
parameter_list|,
name|s8
name|type
parameter_list|)
block|{
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|u32
name|ivar
decl_stmt|,
name|index
decl_stmt|;
name|vector
operator||=
name|IXGBE_IVAR_ALLOC_VAL
expr_stmt|;
if|if
condition|(
name|type
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* MISC IVAR */
name|ivar
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VTIVAR_MISC
argument_list|)
expr_stmt|;
name|ivar
operator|&=
operator|~
literal|0xFF
expr_stmt|;
name|ivar
operator||=
name|vector
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VTIVAR_MISC
argument_list|,
name|ivar
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* RX/TX IVARS */
name|index
operator|=
operator|(
literal|16
operator|*
operator|(
name|entry
operator|&
literal|1
operator|)
operator|)
operator|+
operator|(
literal|8
operator|*
name|type
operator|)
expr_stmt|;
name|ivar
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VTIVAR
argument_list|(
name|entry
operator|>>
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ivar
operator|&=
operator|~
operator|(
literal|0xFF
operator|<<
name|index
operator|)
expr_stmt|;
name|ivar
operator||=
operator|(
name|vector
operator|<<
name|index
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VTIVAR
argument_list|(
name|entry
operator|>>
literal|1
argument_list|)
argument_list|,
name|ivar
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ixv_configure_ivars
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ix_queue
modifier|*
name|que
init|=
name|adapter
operator|->
name|queues
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
block|{
comment|/* First the RX queue entry */
name|ixv_set_ivar
argument_list|(
name|adapter
argument_list|,
name|i
argument_list|,
name|que
operator|->
name|msix
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ... and the TX */
name|ixv_set_ivar
argument_list|(
name|adapter
argument_list|,
name|i
argument_list|,
name|que
operator|->
name|msix
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Set an initial value in EITR */
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IXGBE_VTEITR
argument_list|(
name|que
operator|->
name|msix
argument_list|)
argument_list|,
name|IXV_EITR_DEFAULT
argument_list|)
expr_stmt|;
block|}
comment|/* For the mailbox interrupt */
name|ixv_set_ivar
argument_list|(
name|adapter
argument_list|,
literal|1
argument_list|,
name|adapter
operator|->
name|vector
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Tasklet handler for MSIX MBX interrupts **  - do outside interrupt since it might sleep */
end_comment

begin_function
specifier|static
name|void
name|ixv_handle_mbx
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|context
decl_stmt|;
name|ixgbe_check_link
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
operator|&
name|adapter
operator|->
name|link_speed
argument_list|,
operator|&
name|adapter
operator|->
name|link_up
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ixv_update_link_status
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** The VF stats registers never have a truely virgin ** starting point, so this routine tries to make an ** artificial one, marking ground zero on attach as ** it were. */
end_comment

begin_function
specifier|static
name|void
name|ixv_save_stats
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
if|if
condition|(
name|adapter
operator|->
name|stats
operator|.
name|vf
operator|.
name|vfgprc
operator|||
name|adapter
operator|->
name|stats
operator|.
name|vf
operator|.
name|vfgptc
condition|)
block|{
name|adapter
operator|->
name|stats
operator|.
name|vf
operator|.
name|saved_reset_vfgprc
operator|+=
name|adapter
operator|->
name|stats
operator|.
name|vf
operator|.
name|vfgprc
operator|-
name|adapter
operator|->
name|stats
operator|.
name|vf
operator|.
name|base_vfgprc
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|vf
operator|.
name|saved_reset_vfgptc
operator|+=
name|adapter
operator|->
name|stats
operator|.
name|vf
operator|.
name|vfgptc
operator|-
name|adapter
operator|->
name|stats
operator|.
name|vf
operator|.
name|base_vfgptc
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|vf
operator|.
name|saved_reset_vfgorc
operator|+=
name|adapter
operator|->
name|stats
operator|.
name|vf
operator|.
name|vfgorc
operator|-
name|adapter
operator|->
name|stats
operator|.
name|vf
operator|.
name|base_vfgorc
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|vf
operator|.
name|saved_reset_vfgotc
operator|+=
name|adapter
operator|->
name|stats
operator|.
name|vf
operator|.
name|vfgotc
operator|-
name|adapter
operator|->
name|stats
operator|.
name|vf
operator|.
name|base_vfgotc
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|vf
operator|.
name|saved_reset_vfmprc
operator|+=
name|adapter
operator|->
name|stats
operator|.
name|vf
operator|.
name|vfmprc
operator|-
name|adapter
operator|->
name|stats
operator|.
name|vf
operator|.
name|base_vfmprc
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ixv_init_stats
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|vf
operator|.
name|last_vfgprc
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VFGPRC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|vf
operator|.
name|last_vfgorc
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VFGORC_LSB
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|vf
operator|.
name|last_vfgorc
operator||=
operator|(
operator|(
call|(
name|u64
call|)
argument_list|(
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VFGORC_MSB
argument_list|)
argument_list|)
operator|)
operator|<<
literal|32
operator|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|vf
operator|.
name|last_vfgptc
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VFGPTC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|vf
operator|.
name|last_vfgotc
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VFGOTC_LSB
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|vf
operator|.
name|last_vfgotc
operator||=
operator|(
operator|(
call|(
name|u64
call|)
argument_list|(
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VFGOTC_MSB
argument_list|)
argument_list|)
operator|)
operator|<<
literal|32
operator|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|vf
operator|.
name|last_vfmprc
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VFMPRC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|vf
operator|.
name|base_vfgprc
operator|=
name|adapter
operator|->
name|stats
operator|.
name|vf
operator|.
name|last_vfgprc
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|vf
operator|.
name|base_vfgorc
operator|=
name|adapter
operator|->
name|stats
operator|.
name|vf
operator|.
name|last_vfgorc
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|vf
operator|.
name|base_vfgptc
operator|=
name|adapter
operator|->
name|stats
operator|.
name|vf
operator|.
name|last_vfgptc
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|vf
operator|.
name|base_vfgotc
operator|=
name|adapter
operator|->
name|stats
operator|.
name|vf
operator|.
name|last_vfgotc
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|vf
operator|.
name|base_vfmprc
operator|=
name|adapter
operator|->
name|stats
operator|.
name|vf
operator|.
name|last_vfmprc
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|UPDATE_STAT_32
parameter_list|(
name|reg
parameter_list|,
name|last
parameter_list|,
name|count
parameter_list|)
define|\
value|{							\ 	u32 current = IXGBE_READ_REG(hw, reg);		\ 	if (current< last)				\ 		count += 0x100000000LL;			\ 	last = current;					\ 	count&= 0xFFFFFFFF00000000LL;			\ 	count |= current;				\ }
end_define

begin_define
define|#
directive|define
name|UPDATE_STAT_36
parameter_list|(
name|lsb
parameter_list|,
name|msb
parameter_list|,
name|last
parameter_list|,
name|count
parameter_list|)
define|\
value|{							\ 	u64 cur_lsb = IXGBE_READ_REG(hw, lsb);		\ 	u64 cur_msb = IXGBE_READ_REG(hw, msb);		\ 	u64 current = ((cur_msb<< 32) | cur_lsb);	\ 	if (current< last)				\ 		count += 0x1000000000LL;		\ 	last = current;					\ 	count&= 0xFFFFFFF000000000LL;			\ 	count |= current;				\ }
end_define

begin_comment
comment|/* ** ixv_update_stats - Update the board statistics counters. */
end_comment

begin_function
name|void
name|ixv_update_stats
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|UPDATE_STAT_32
argument_list|(
name|IXGBE_VFGPRC
argument_list|,
name|adapter
operator|->
name|stats
operator|.
name|vf
operator|.
name|last_vfgprc
argument_list|,
name|adapter
operator|->
name|stats
operator|.
name|vf
operator|.
name|vfgprc
argument_list|)
expr_stmt|;
name|UPDATE_STAT_32
argument_list|(
name|IXGBE_VFGPTC
argument_list|,
name|adapter
operator|->
name|stats
operator|.
name|vf
operator|.
name|last_vfgptc
argument_list|,
name|adapter
operator|->
name|stats
operator|.
name|vf
operator|.
name|vfgptc
argument_list|)
expr_stmt|;
name|UPDATE_STAT_36
argument_list|(
name|IXGBE_VFGORC_LSB
argument_list|,
name|IXGBE_VFGORC_MSB
argument_list|,
name|adapter
operator|->
name|stats
operator|.
name|vf
operator|.
name|last_vfgorc
argument_list|,
name|adapter
operator|->
name|stats
operator|.
name|vf
operator|.
name|vfgorc
argument_list|)
expr_stmt|;
name|UPDATE_STAT_36
argument_list|(
name|IXGBE_VFGOTC_LSB
argument_list|,
name|IXGBE_VFGOTC_MSB
argument_list|,
name|adapter
operator|->
name|stats
operator|.
name|vf
operator|.
name|last_vfgotc
argument_list|,
name|adapter
operator|->
name|stats
operator|.
name|vf
operator|.
name|vfgotc
argument_list|)
expr_stmt|;
name|UPDATE_STAT_32
argument_list|(
name|IXGBE_VFMPRC
argument_list|,
name|adapter
operator|->
name|stats
operator|.
name|vf
operator|.
name|last_vfmprc
argument_list|,
name|adapter
operator|->
name|stats
operator|.
name|vf
operator|.
name|vfmprc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add statistic sysctls for the VF.  */
end_comment

begin_function
specifier|static
name|void
name|ixv_add_stats_sysctls
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|struct
name|ix_queue
modifier|*
name|que
init|=
operator|&
name|adapter
operator|->
name|queues
index|[
literal|0
index|]
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|que
operator|->
name|txr
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
name|que
operator|->
name|rxr
decl_stmt|;
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
init|=
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|tree
init|=
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|child
init|=
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
decl_stmt|;
name|struct
name|ixgbevf_hw_stats
modifier|*
name|stats
init|=
operator|&
name|adapter
operator|->
name|stats
operator|.
name|vf
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|stat_node
decl_stmt|,
modifier|*
name|queue_node
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|stat_list
decl_stmt|,
modifier|*
name|queue_list
decl_stmt|;
comment|/* Driver Statistics */
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dropped"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|dropped_pkts
argument_list|,
literal|"Driver dropped packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mbuf_defrag_failed"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|mbuf_defrag_failed
argument_list|,
literal|"m_defrag() failed"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"watchdog_events"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|watchdog_events
argument_list|,
literal|"Watchdog timeouts"
argument_list|)
expr_stmt|;
name|stat_node
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mac"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"VF Statistics (read from HW registers)"
argument_list|)
expr_stmt|;
name|stat_list
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|stat_node
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"good_pkts_rcvd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|vfgprc
argument_list|,
literal|"Good Packets Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"good_octets_rcvd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|vfgorc
argument_list|,
literal|"Good Octets Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mcast_pkts_rcvd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|vfmprc
argument_list|,
literal|"Multicast Packets Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"good_pkts_txd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|vfgptc
argument_list|,
literal|"Good Packets Transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"good_octets_txd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|vfgotc
argument_list|,
literal|"Good Octets Transmitted"
argument_list|)
expr_stmt|;
name|queue_node
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"que"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"Queue Statistics (collected by SW)"
argument_list|)
expr_stmt|;
name|queue_list
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|queue_node
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"irqs"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|que
operator|->
name|irqs
operator|)
argument_list|,
literal|"IRQs on queue"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_irqs"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|rxr
operator|->
name|rx_irq
operator|)
argument_list|,
literal|"RX irqs on queue"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_packets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|rxr
operator|->
name|rx_packets
operator|)
argument_list|,
literal|"RX packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_bytes"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|rxr
operator|->
name|rx_bytes
operator|)
argument_list|,
literal|"RX bytes"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_discarded"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|rxr
operator|->
name|rx_discarded
operator|)
argument_list|,
literal|"Discarded RX packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_packets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|txr
operator|->
name|total_packets
operator|)
argument_list|,
literal|"TX Packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_no_desc"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|txr
operator|->
name|no_desc_avail
operator|)
argument_list|,
literal|"# of times not enough descriptors were available during TX"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixv_set_sysctl_value
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|description
parameter_list|,
name|int
modifier|*
name|limit
parameter_list|,
name|int
name|value
parameter_list|)
block|{
operator|*
name|limit
operator|=
name|value
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|adapter
operator|->
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|adapter
operator|->
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|name
argument_list|,
name|CTLFLAG_RW
argument_list|,
name|limit
argument_list|,
name|value
argument_list|,
name|description
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  *  *  This routine is called only when em_display_debug_stats is enabled.  *  This routine provides a way to take a look at important statistics  *  maintained by the driver and hardware.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixv_print_debug_info
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|struct
name|ix_queue
modifier|*
name|que
init|=
name|adapter
operator|->
name|queues
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
decl_stmt|;
name|struct
name|lro_ctrl
modifier|*
name|lro
decl_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Error Byte Count = %u \n"
argument_list|,
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ERRBC
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
block|{
name|txr
operator|=
name|que
operator|->
name|txr
expr_stmt|;
name|rxr
operator|=
name|que
operator|->
name|rxr
expr_stmt|;
name|lro
operator|=
operator|&
name|rxr
operator|->
name|lro
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"QUE(%d) IRQs Handled: %lu\n"
argument_list|,
name|que
operator|->
name|msix
argument_list|,
operator|(
name|long
operator|)
name|que
operator|->
name|irqs
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"RX(%d) Packets Received: %lld\n"
argument_list|,
name|rxr
operator|->
name|me
argument_list|,
operator|(
name|long
name|long
operator|)
name|rxr
operator|->
name|rx_packets
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"RX(%d) Bytes Received: %lu\n"
argument_list|,
name|rxr
operator|->
name|me
argument_list|,
operator|(
name|long
operator|)
name|rxr
operator|->
name|rx_bytes
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"RX(%d) LRO Queued= %d\n"
argument_list|,
name|rxr
operator|->
name|me
argument_list|,
name|lro
operator|->
name|lro_queued
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"RX(%d) LRO Flushed= %d\n"
argument_list|,
name|rxr
operator|->
name|me
argument_list|,
name|lro
operator|->
name|lro_flushed
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"TX(%d) Packets Sent: %lu\n"
argument_list|,
name|txr
operator|->
name|me
argument_list|,
operator|(
name|long
operator|)
name|txr
operator|->
name|total_packets
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"TX(%d) NO Desc Avail: %lu\n"
argument_list|,
name|txr
operator|->
name|me
argument_list|,
operator|(
name|long
operator|)
name|txr
operator|->
name|no_desc_avail
argument_list|)
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"MBX IRQ Handled: %lu\n"
argument_list|,
operator|(
name|long
operator|)
name|adapter
operator|->
name|link_irq
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|ixv_sysctl_debug
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|result
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
decl_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|result
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|result
operator|==
literal|1
condition|)
block|{
name|adapter
operator|=
operator|(
expr|struct
name|adapter
operator|*
operator|)
name|arg1
expr_stmt|;
name|ixv_print_debug_info
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

end_unit

