begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************    Copyright (c) 2001-2015, Intel Corporation    All rights reserved.      Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are met:       1. Redistributions of source code must retain the above copyright notice,        this list of conditions and the following disclaimer.       2. Redistributions in binary form must reproduce the above copyright        notice, this list of conditions and the following disclaimer in the        documentation and/or other materials provided with the distribution.       3. Neither the name of the Intel Corporation nor the names of its        contributors may be used to endorse or promote products derived from        this software without specific prior written permission.      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  ******************************************************************************/
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_include
include|#
directive|include
file|"ixgbe_x550.h"
end_include

begin_include
include|#
directive|include
file|"ixgbe_x540.h"
end_include

begin_include
include|#
directive|include
file|"ixgbe_type.h"
end_include

begin_include
include|#
directive|include
file|"ixgbe_api.h"
end_include

begin_include
include|#
directive|include
file|"ixgbe_common.h"
end_include

begin_include
include|#
directive|include
file|"ixgbe_phy.h"
end_include

begin_function_decl
specifier|static
name|s32
name|ixgbe_setup_ixfi_x550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
modifier|*
name|speed
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  *  ixgbe_init_ops_X550 - Inits func ptrs and MAC type  *  @hw: pointer to hardware structure  *  *  Initialize the function pointers and assign the MAC type for X550.  *  Does not touch the hardware.  **/
end_comment

begin_function
name|s32
name|ixgbe_init_ops_X550
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|ixgbe_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|struct
name|ixgbe_eeprom_info
modifier|*
name|eeprom
init|=
operator|&
name|hw
operator|->
name|eeprom
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_init_ops_X550"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|ixgbe_init_ops_X540
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|dmac_config
operator|=
name|ixgbe_dmac_config_X550
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|dmac_config_tcs
operator|=
name|ixgbe_dmac_config_tcs_X550
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|dmac_update_tcs
operator|=
name|ixgbe_dmac_update_tcs_X550
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|setup_eee
operator|=
name|ixgbe_setup_eee_X550
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|set_source_address_pruning
operator|=
name|ixgbe_set_source_address_pruning_X550
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|set_ethertype_anti_spoofing
operator|=
name|ixgbe_set_ethertype_anti_spoofing_X550
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_rtrup2tc
operator|=
name|ixgbe_dcb_get_rtrup2tc_generic
expr_stmt|;
name|eeprom
operator|->
name|ops
operator|.
name|init_params
operator|=
name|ixgbe_init_eeprom_params_X550
expr_stmt|;
name|eeprom
operator|->
name|ops
operator|.
name|calc_checksum
operator|=
name|ixgbe_calc_eeprom_checksum_X550
expr_stmt|;
name|eeprom
operator|->
name|ops
operator|.
name|read
operator|=
name|ixgbe_read_ee_hostif_X550
expr_stmt|;
name|eeprom
operator|->
name|ops
operator|.
name|read_buffer
operator|=
name|ixgbe_read_ee_hostif_buffer_X550
expr_stmt|;
name|eeprom
operator|->
name|ops
operator|.
name|write
operator|=
name|ixgbe_write_ee_hostif_X550
expr_stmt|;
name|eeprom
operator|->
name|ops
operator|.
name|write_buffer
operator|=
name|ixgbe_write_ee_hostif_buffer_X550
expr_stmt|;
name|eeprom
operator|->
name|ops
operator|.
name|update_checksum
operator|=
name|ixgbe_update_eeprom_checksum_X550
expr_stmt|;
name|eeprom
operator|->
name|ops
operator|.
name|validate_checksum
operator|=
name|ixgbe_validate_eeprom_checksum_X550
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|disable_mdd
operator|=
name|ixgbe_disable_mdd_X550
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|enable_mdd
operator|=
name|ixgbe_enable_mdd_X550
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|mdd_event
operator|=
name|ixgbe_mdd_event_X550
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|restore_mdd_vf
operator|=
name|ixgbe_restore_mdd_vf_X550
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|disable_rx
operator|=
name|ixgbe_disable_rx_x550
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|device_id
operator|==
name|IXGBE_DEV_ID_X550EM_X_10G_T
condition|)
block|{
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|led_on
operator|=
name|ixgbe_led_on_t_X550em
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|led_off
operator|=
name|ixgbe_led_off_t_X550em
expr_stmt|;
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_read_cs4227 - Read CS4227 register  * @hw: pointer to hardware structure  * @reg: register number to write  * @value: pointer to receive value read  *  * Returns status code  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_read_cs4227
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|reg
parameter_list|,
name|u16
modifier|*
name|value
parameter_list|)
block|{
return|return
name|ixgbe_read_i2c_combined_unlocked
argument_list|(
name|hw
argument_list|,
name|IXGBE_CS4227
argument_list|,
name|reg
argument_list|,
name|value
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_write_cs4227 - Write CS4227 register  * @hw: pointer to hardware structure  * @reg: register number to write  * @value: value to write to register  *  * Returns status code  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_write_cs4227
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|reg
parameter_list|,
name|u16
name|value
parameter_list|)
block|{
return|return
name|ixgbe_write_i2c_combined_unlocked
argument_list|(
name|hw
argument_list|,
name|IXGBE_CS4227
argument_list|,
name|reg
argument_list|,
name|value
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_read_pe - Read register from port expander  * @hw: pointer to hardware structure  * @reg: register number to read  * @value: pointer to receive read value  *  * Returns status code  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_read_pe
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|reg
parameter_list|,
name|u8
modifier|*
name|value
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|status
operator|=
name|ixgbe_read_i2c_byte_unlocked
argument_list|(
name|hw
argument_list|,
name|reg
argument_list|,
name|IXGBE_PE
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
name|ERROR_REPORT2
argument_list|(
name|IXGBE_ERROR_CAUTION
argument_list|,
literal|"port expander access failed with %d\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_write_pe - Write register to port expander  * @hw: pointer to hardware structure  * @reg: register number to write  * @value: value to write  *  * Returns status code  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_write_pe
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|reg
parameter_list|,
name|u8
name|value
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|status
operator|=
name|ixgbe_write_i2c_byte_unlocked
argument_list|(
name|hw
argument_list|,
name|reg
argument_list|,
name|IXGBE_PE
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
name|ERROR_REPORT2
argument_list|(
name|IXGBE_ERROR_CAUTION
argument_list|,
literal|"port expander access failed with %d\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_reset_cs4227 - Reset CS4227 using port expander  * @hw: pointer to hardware structure  *  * This function assumes that the caller has acquired the proper semaphore.  * Returns error code  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_reset_cs4227
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|u32
name|retry
decl_stmt|;
name|u16
name|value
decl_stmt|;
name|u8
name|reg
decl_stmt|;
comment|/* Trigger hard reset. */
name|status
operator|=
name|ixgbe_read_pe
argument_list|(
name|hw
argument_list|,
name|IXGBE_PE_OUTPUT
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|reg
operator||=
name|IXGBE_PE_BIT1
expr_stmt|;
name|status
operator|=
name|ixgbe_write_pe
argument_list|(
name|hw
argument_list|,
name|IXGBE_PE_OUTPUT
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|status
operator|=
name|ixgbe_read_pe
argument_list|(
name|hw
argument_list|,
name|IXGBE_PE_CONFIG
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|reg
operator|&=
operator|~
name|IXGBE_PE_BIT1
expr_stmt|;
name|status
operator|=
name|ixgbe_write_pe
argument_list|(
name|hw
argument_list|,
name|IXGBE_PE_CONFIG
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|status
operator|=
name|ixgbe_read_pe
argument_list|(
name|hw
argument_list|,
name|IXGBE_PE_OUTPUT
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|reg
operator|&=
operator|~
name|IXGBE_PE_BIT1
expr_stmt|;
name|status
operator|=
name|ixgbe_write_pe
argument_list|(
name|hw
argument_list|,
name|IXGBE_PE_OUTPUT
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|usec_delay
argument_list|(
name|IXGBE_CS4227_RESET_HOLD
argument_list|)
expr_stmt|;
name|status
operator|=
name|ixgbe_read_pe
argument_list|(
name|hw
argument_list|,
name|IXGBE_PE_OUTPUT
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|reg
operator||=
name|IXGBE_PE_BIT1
expr_stmt|;
name|status
operator|=
name|ixgbe_write_pe
argument_list|(
name|hw
argument_list|,
name|IXGBE_PE_OUTPUT
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* Wait for the reset to complete. */
name|msec_delay
argument_list|(
name|IXGBE_CS4227_RESET_DELAY
argument_list|)
expr_stmt|;
for|for
control|(
name|retry
operator|=
literal|0
init|;
name|retry
operator|<
name|IXGBE_CS4227_RETRIES
condition|;
name|retry
operator|++
control|)
block|{
name|status
operator|=
name|ixgbe_read_cs4227
argument_list|(
name|hw
argument_list|,
name|IXGBE_CS4227_EFUSE_STATUS
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
operator|&&
name|value
operator|==
name|IXGBE_CS4227_EEPROM_LOAD_OK
condition|)
break|break;
name|msec_delay
argument_list|(
name|IXGBE_CS4227_CHECK_DELAY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|retry
operator|==
name|IXGBE_CS4227_RETRIES
condition|)
block|{
name|ERROR_REPORT1
argument_list|(
name|IXGBE_ERROR_INVALID_STATE
argument_list|,
literal|"CS4227 reset did not complete."
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_PHY
return|;
block|}
name|status
operator|=
name|ixgbe_read_cs4227
argument_list|(
name|hw
argument_list|,
name|IXGBE_CS4227_EEPROM_STATUS
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
operator|||
operator|!
operator|(
name|value
operator|&
name|IXGBE_CS4227_EEPROM_LOAD_OK
operator|)
condition|)
block|{
name|ERROR_REPORT1
argument_list|(
name|IXGBE_ERROR_INVALID_STATE
argument_list|,
literal|"CS4227 EEPROM did not load successfully."
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_PHY
return|;
block|}
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_check_cs4227 - Check CS4227 and reset as needed  * @hw: pointer to hardware structure  **/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_check_cs4227
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u32
name|swfw_mask
init|=
name|hw
operator|->
name|phy
operator|.
name|phy_semaphore_mask
decl_stmt|;
name|u16
name|value
init|=
literal|0
decl_stmt|;
name|u8
name|retry
decl_stmt|;
for|for
control|(
name|retry
operator|=
literal|0
init|;
name|retry
operator|<
name|IXGBE_CS4227_RETRIES
condition|;
name|retry
operator|++
control|)
block|{
name|status
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|acquire_swfw_sync
argument_list|(
name|hw
argument_list|,
name|swfw_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
block|{
name|ERROR_REPORT2
argument_list|(
name|IXGBE_ERROR_CAUTION
argument_list|,
literal|"semaphore failed with %d"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
name|IXGBE_CS4227_CHECK_DELAY
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Get status of reset flow. */
name|status
operator|=
name|ixgbe_read_cs4227
argument_list|(
name|hw
argument_list|,
name|IXGBE_CS4227_SCRATCH
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
operator|&&
name|value
operator|==
name|IXGBE_CS4227_RESET_COMPLETE
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
operator|||
name|value
operator|!=
name|IXGBE_CS4227_RESET_PENDING
condition|)
break|break;
comment|/* Reset is pending. Wait and check again. */
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|swfw_mask
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
name|IXGBE_CS4227_CHECK_DELAY
argument_list|)
expr_stmt|;
block|}
comment|/* If still pending, assume other instance failed. */
if|if
condition|(
name|retry
operator|==
name|IXGBE_CS4227_RETRIES
condition|)
block|{
name|status
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|acquire_swfw_sync
argument_list|(
name|hw
argument_list|,
name|swfw_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
block|{
name|ERROR_REPORT2
argument_list|(
name|IXGBE_ERROR_CAUTION
argument_list|,
literal|"semaphore failed with %d"
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Reset the CS4227. */
name|status
operator|=
name|ixgbe_reset_cs4227
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
block|{
name|ERROR_REPORT2
argument_list|(
name|IXGBE_ERROR_INVALID_STATE
argument_list|,
literal|"CS4227 reset failed: %d"
argument_list|,
name|status
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Reset takes so long, temporarily release semaphore in case the 	 * other driver instance is waiting for the reset indication. 	 */
name|ixgbe_write_cs4227
argument_list|(
name|hw
argument_list|,
name|IXGBE_CS4227_SCRATCH
argument_list|,
name|IXGBE_CS4227_RESET_PENDING
argument_list|)
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|swfw_mask
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|status
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|acquire_swfw_sync
argument_list|(
name|hw
argument_list|,
name|swfw_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
block|{
name|ERROR_REPORT2
argument_list|(
name|IXGBE_ERROR_CAUTION
argument_list|,
literal|"semaphore failed with %d"
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Record completion for next time. */
name|status
operator|=
name|ixgbe_write_cs4227
argument_list|(
name|hw
argument_list|,
name|IXGBE_CS4227_SCRATCH
argument_list|,
name|IXGBE_CS4227_RESET_COMPLETE
argument_list|)
expr_stmt|;
name|out
label|:
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|swfw_mask
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
name|hw
operator|->
name|eeprom
operator|.
name|semaphore_delay
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_setup_mux_ctl - Setup ESDP register for I2C mux control  * @hw: pointer to hardware structure  **/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_setup_mux_ctl
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|esdp
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|)
decl_stmt|;
if|if
condition|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
condition|)
block|{
name|esdp
operator|&=
operator|~
operator|(
name|IXGBE_ESDP_SDP1_NATIVE
operator||
name|IXGBE_ESDP_SDP1
operator|)
expr_stmt|;
name|esdp
operator||=
name|IXGBE_ESDP_SDP1_DIR
expr_stmt|;
block|}
name|esdp
operator|&=
operator|~
operator|(
name|IXGBE_ESDP_SDP0_NATIVE
operator||
name|IXGBE_ESDP_SDP0_DIR
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|,
name|esdp
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_identify_phy_x550em - Get PHY type based on device id  * @hw: pointer to hardware structure  *  * Returns error code  */
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_identify_phy_x550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
switch|switch
condition|(
name|hw
operator|->
name|device_id
condition|)
block|{
case|case
name|IXGBE_DEV_ID_X550EM_X_SFP
case|:
comment|/* set up for CS4227 usage */
name|hw
operator|->
name|phy
operator|.
name|phy_semaphore_mask
operator|=
name|IXGBE_GSSR_SHARED_I2C_SM
expr_stmt|;
name|ixgbe_setup_mux_ctl
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|ixgbe_check_cs4227
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|ixgbe_identify_module_generic
argument_list|(
name|hw
argument_list|)
return|;
break|break;
case|case
name|IXGBE_DEV_ID_X550EM_X_KX4
case|:
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|ixgbe_phy_x550em_kx4
expr_stmt|;
break|break;
case|case
name|IXGBE_DEV_ID_X550EM_X_KR
case|:
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|ixgbe_phy_x550em_kr
expr_stmt|;
break|break;
case|case
name|IXGBE_DEV_ID_X550EM_X_1G_T
case|:
case|case
name|IXGBE_DEV_ID_X550EM_X_10G_T
case|:
return|return
name|ixgbe_identify_phy_generic
argument_list|(
name|hw
argument_list|)
return|;
default|default:
break|break;
block|}
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|s32
name|ixgbe_read_phy_reg_x550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|reg_addr
parameter_list|,
name|u32
name|device_type
parameter_list|,
name|u16
modifier|*
name|phy_data
parameter_list|)
block|{
name|UNREFERENCED_4PARAMETER
argument_list|(
operator|*
name|hw
argument_list|,
name|reg_addr
argument_list|,
name|device_type
argument_list|,
operator|*
name|phy_data
argument_list|)
expr_stmt|;
return|return
name|IXGBE_NOT_IMPLEMENTED
return|;
block|}
end_function

begin_function
specifier|static
name|s32
name|ixgbe_write_phy_reg_x550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|reg_addr
parameter_list|,
name|u32
name|device_type
parameter_list|,
name|u16
name|phy_data
parameter_list|)
block|{
name|UNREFERENCED_4PARAMETER
argument_list|(
operator|*
name|hw
argument_list|,
name|reg_addr
argument_list|,
name|device_type
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
return|return
name|IXGBE_NOT_IMPLEMENTED
return|;
block|}
end_function

begin_comment
comment|/** *  ixgbe_init_ops_X550EM - Inits func ptrs and MAC type *  @hw: pointer to hardware structure * *  Initialize the function pointers and for MAC type X550EM. *  Does not touch the hardware. **/
end_comment

begin_function
name|s32
name|ixgbe_init_ops_X550EM
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|ixgbe_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|struct
name|ixgbe_eeprom_info
modifier|*
name|eeprom
init|=
operator|&
name|hw
operator|->
name|eeprom
decl_stmt|;
name|struct
name|ixgbe_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_init_ops_X550EM"
argument_list|)
expr_stmt|;
comment|/* Similar to X550 so start there. */
name|ret_val
operator|=
name|ixgbe_init_ops_X550
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Since this function eventually calls 	 * ixgbe_init_ops_540 by design, we are setting 	 * the pointers to NULL explicitly here to overwrite 	 * the values being set in the x540 function. 	 */
comment|/* FCOE not supported in x550EM */
name|mac
operator|->
name|ops
operator|.
name|get_san_mac_addr
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|set_san_mac_addr
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_wwn_prefix
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_fcoe_boot_status
operator|=
name|NULL
expr_stmt|;
comment|/* IPsec not supported in x550EM */
name|mac
operator|->
name|ops
operator|.
name|disable_sec_rx_path
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|enable_sec_rx_path
operator|=
name|NULL
expr_stmt|;
comment|/* AUTOC register is not present in x550EM. */
name|mac
operator|->
name|ops
operator|.
name|prot_autoc_read
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|prot_autoc_write
operator|=
name|NULL
expr_stmt|;
comment|/* X550EM bus type is internal*/
name|hw
operator|->
name|bus
operator|.
name|type
operator|=
name|ixgbe_bus_type_internal
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_bus_info
operator|=
name|ixgbe_get_bus_info_X550em
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_X550EM_x
condition|)
block|{
name|mac
operator|->
name|ops
operator|.
name|read_iosf_sb_reg
operator|=
name|ixgbe_read_iosf_sb_reg_x550
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|write_iosf_sb_reg
operator|=
name|ixgbe_write_iosf_sb_reg_x550
expr_stmt|;
block|}
name|mac
operator|->
name|ops
operator|.
name|get_media_type
operator|=
name|ixgbe_get_media_type_X550em
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|setup_sfp
operator|=
name|ixgbe_setup_sfp_modules_X550em
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_link_capabilities
operator|=
name|ixgbe_get_link_capabilities_X550em
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|reset_hw
operator|=
name|ixgbe_reset_hw_X550em
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_supported_physical_layer
operator|=
name|ixgbe_get_supported_physical_layer_X550em
expr_stmt|;
if|if
condition|(
name|mac
operator|->
name|ops
operator|.
name|get_media_type
argument_list|(
name|hw
argument_list|)
operator|==
name|ixgbe_media_type_copper
condition|)
name|mac
operator|->
name|ops
operator|.
name|setup_fc
operator|=
name|ixgbe_setup_fc_generic
expr_stmt|;
else|else
name|mac
operator|->
name|ops
operator|.
name|setup_fc
operator|=
name|ixgbe_setup_fc_X550em
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|acquire_swfw_sync
operator|=
name|ixgbe_acquire_swfw_sync_X550em
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|release_swfw_sync
operator|=
name|ixgbe_release_swfw_sync_X550em
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|device_id
operator|!=
name|IXGBE_DEV_ID_X550EM_X_KR
condition|)
name|mac
operator|->
name|ops
operator|.
name|setup_eee
operator|=
name|NULL
expr_stmt|;
comment|/* PHY */
name|phy
operator|->
name|ops
operator|.
name|init
operator|=
name|ixgbe_init_phy_ops_X550em
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|identify
operator|=
name|ixgbe_identify_phy_x550em
expr_stmt|;
if|if
condition|(
name|mac
operator|->
name|ops
operator|.
name|get_media_type
argument_list|(
name|hw
argument_list|)
operator|!=
name|ixgbe_media_type_copper
condition|)
name|phy
operator|->
name|ops
operator|.
name|set_phy_power
operator|=
name|NULL
expr_stmt|;
comment|/* EEPROM */
name|eeprom
operator|->
name|ops
operator|.
name|init_params
operator|=
name|ixgbe_init_eeprom_params_X540
expr_stmt|;
name|eeprom
operator|->
name|ops
operator|.
name|read
operator|=
name|ixgbe_read_ee_hostif_X550
expr_stmt|;
name|eeprom
operator|->
name|ops
operator|.
name|read_buffer
operator|=
name|ixgbe_read_ee_hostif_buffer_X550
expr_stmt|;
name|eeprom
operator|->
name|ops
operator|.
name|write
operator|=
name|ixgbe_write_ee_hostif_X550
expr_stmt|;
name|eeprom
operator|->
name|ops
operator|.
name|write_buffer
operator|=
name|ixgbe_write_ee_hostif_buffer_X550
expr_stmt|;
name|eeprom
operator|->
name|ops
operator|.
name|update_checksum
operator|=
name|ixgbe_update_eeprom_checksum_X550
expr_stmt|;
name|eeprom
operator|->
name|ops
operator|.
name|validate_checksum
operator|=
name|ixgbe_validate_eeprom_checksum_X550
expr_stmt|;
name|eeprom
operator|->
name|ops
operator|.
name|calc_checksum
operator|=
name|ixgbe_calc_eeprom_checksum_X550
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_dmac_config_X550  *  @hw: pointer to hardware structure  *  *  Configure DMA coalescing. If enabling dmac, dmac is activated.  *  When disabling dmac, dmac enable dmac bit is cleared.  **/
end_comment

begin_function
name|s32
name|ixgbe_dmac_config_X550
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|reg
decl_stmt|,
name|high_pri_tc
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_dmac_config_X550"
argument_list|)
expr_stmt|;
comment|/* Disable DMA coalescing before configuring */
name|reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DMACR
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|IXGBE_DMACR_DMAC_EN
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DMACR
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Disable DMA Coalescing if the watchdog timer is 0 */
if|if
condition|(
operator|!
name|hw
operator|->
name|mac
operator|.
name|dmac_config
operator|.
name|watchdog_timer
condition|)
goto|goto
name|out
goto|;
name|ixgbe_dmac_config_tcs_X550
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Configure DMA Coalescing Control Register */
name|reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DMACR
argument_list|)
expr_stmt|;
comment|/* Set the watchdog timer in units of 40.96 usec */
name|reg
operator|&=
operator|~
name|IXGBE_DMACR_DMACWT_MASK
expr_stmt|;
name|reg
operator||=
operator|(
name|hw
operator|->
name|mac
operator|.
name|dmac_config
operator|.
name|watchdog_timer
operator|*
literal|100
operator|)
operator|/
literal|4096
expr_stmt|;
name|reg
operator|&=
operator|~
name|IXGBE_DMACR_HIGH_PRI_TC_MASK
expr_stmt|;
comment|/* If fcoe is enabled, set high priority traffic class */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|dmac_config
operator|.
name|fcoe_en
condition|)
block|{
name|high_pri_tc
operator|=
literal|1
operator|<<
name|hw
operator|->
name|mac
operator|.
name|dmac_config
operator|.
name|fcoe_tc
expr_stmt|;
name|reg
operator||=
operator|(
operator|(
name|high_pri_tc
operator|<<
name|IXGBE_DMACR_HIGH_PRI_TC_SHIFT
operator|)
operator|&
name|IXGBE_DMACR_HIGH_PRI_TC_MASK
operator|)
expr_stmt|;
block|}
name|reg
operator||=
name|IXGBE_DMACR_EN_MNG_IND
expr_stmt|;
comment|/* Enable DMA coalescing after configuration */
name|reg
operator||=
name|IXGBE_DMACR_DMAC_EN
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DMACR
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_dmac_config_tcs_X550  *  @hw: pointer to hardware structure  *  *  Configure DMA coalescing threshold per TC. The dmac enable bit must  *  be cleared before configuring.  **/
end_comment

begin_function
name|s32
name|ixgbe_dmac_config_tcs_X550
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|tc
decl_stmt|,
name|reg
decl_stmt|,
name|pb_headroom
decl_stmt|,
name|rx_pb_size
decl_stmt|,
name|maxframe_size_kb
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_dmac_config_tcs_X550"
argument_list|)
expr_stmt|;
comment|/* Configure DMA coalescing enabled */
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|dmac_config
operator|.
name|link_speed
condition|)
block|{
case|case
name|IXGBE_LINK_SPEED_100_FULL
case|:
name|pb_headroom
operator|=
name|IXGBE_DMACRXT_100M
expr_stmt|;
break|break;
case|case
name|IXGBE_LINK_SPEED_1GB_FULL
case|:
name|pb_headroom
operator|=
name|IXGBE_DMACRXT_1G
expr_stmt|;
break|break;
default|default:
name|pb_headroom
operator|=
name|IXGBE_DMACRXT_10G
expr_stmt|;
break|break;
block|}
name|maxframe_size_kb
operator|=
operator|(
operator|(
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MAXFRS
argument_list|)
operator|>>
name|IXGBE_MHADD_MFS_SHIFT
operator|)
operator|/
literal|1024
operator|)
expr_stmt|;
comment|/* Set the per Rx packet buffer receive threshold */
for|for
control|(
name|tc
operator|=
literal|0
init|;
name|tc
operator|<
name|IXGBE_DCB_MAX_TRAFFIC_CLASS
condition|;
name|tc
operator|++
control|)
block|{
name|reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DMCTH
argument_list|(
name|tc
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|IXGBE_DMCTH_DMACRXT_MASK
expr_stmt|;
if|if
condition|(
name|tc
operator|<
name|hw
operator|->
name|mac
operator|.
name|dmac_config
operator|.
name|num_tcs
condition|)
block|{
comment|/* Get Rx PB size */
name|rx_pb_size
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXPBSIZE
argument_list|(
name|tc
argument_list|)
argument_list|)
expr_stmt|;
name|rx_pb_size
operator|=
operator|(
name|rx_pb_size
operator|&
name|IXGBE_RXPBSIZE_MASK
operator|)
operator|>>
name|IXGBE_RXPBSIZE_SHIFT
expr_stmt|;
comment|/* Calculate receive buffer threshold in kilobytes */
if|if
condition|(
name|rx_pb_size
operator|>
name|pb_headroom
condition|)
name|rx_pb_size
operator|=
name|rx_pb_size
operator|-
name|pb_headroom
expr_stmt|;
else|else
name|rx_pb_size
operator|=
literal|0
expr_stmt|;
comment|/* Minimum of MFS shall be set for DMCTH */
name|reg
operator||=
operator|(
name|rx_pb_size
operator|>
name|maxframe_size_kb
operator|)
condition|?
name|rx_pb_size
else|:
name|maxframe_size_kb
expr_stmt|;
block|}
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DMCTH
argument_list|(
name|tc
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_dmac_update_tcs_X550  *  @hw: pointer to hardware structure  *  *  Disables dmac, updates per TC settings, and then enables dmac.  **/
end_comment

begin_function
name|s32
name|ixgbe_dmac_update_tcs_X550
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|reg
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_dmac_update_tcs_X550"
argument_list|)
expr_stmt|;
comment|/* Disable DMA coalescing before configuring */
name|reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DMACR
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|IXGBE_DMACR_DMAC_EN
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DMACR
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|ixgbe_dmac_config_tcs_X550
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Enable DMA coalescing after configuration */
name|reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DMACR
argument_list|)
expr_stmt|;
name|reg
operator||=
name|IXGBE_DMACR_DMAC_EN
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DMACR
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_init_eeprom_params_X550 - Initialize EEPROM params  *  @hw: pointer to hardware structure  *  *  Initializes the EEPROM parameters ixgbe_eeprom_info within the  *  ixgbe_hw struct in order to set up EEPROM access.  **/
end_comment

begin_function
name|s32
name|ixgbe_init_eeprom_params_X550
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|ixgbe_eeprom_info
modifier|*
name|eeprom
init|=
operator|&
name|hw
operator|->
name|eeprom
decl_stmt|;
name|u32
name|eec
decl_stmt|;
name|u16
name|eeprom_size
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_init_eeprom_params_X550"
argument_list|)
expr_stmt|;
if|if
condition|(
name|eeprom
operator|->
name|type
operator|==
name|ixgbe_eeprom_uninitialized
condition|)
block|{
name|eeprom
operator|->
name|semaphore_delay
operator|=
literal|10
expr_stmt|;
name|eeprom
operator|->
name|type
operator|=
name|ixgbe_flash
expr_stmt|;
name|eec
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC
argument_list|)
expr_stmt|;
name|eeprom_size
operator|=
call|(
name|u16
call|)
argument_list|(
operator|(
name|eec
operator|&
name|IXGBE_EEC_SIZE
operator|)
operator|>>
name|IXGBE_EEC_SIZE_SHIFT
argument_list|)
expr_stmt|;
name|eeprom
operator|->
name|word_size
operator|=
literal|1
operator|<<
operator|(
name|eeprom_size
operator|+
name|IXGBE_EEPROM_WORD_SIZE_SHIFT
operator|)
expr_stmt|;
name|DEBUGOUT2
argument_list|(
literal|"Eeprom params: type = %d, size = %d\n"
argument_list|,
name|eeprom
operator|->
name|type
argument_list|,
name|eeprom
operator|->
name|word_size
argument_list|)
expr_stmt|;
block|}
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_setup_eee_X550 - Enable/disable EEE support  *  @hw: pointer to the HW structure  *  @enable_eee: boolean flag to enable EEE  *  *  Enable/disable EEE based on enable_eee flag.  *  Auto-negotiation must be started after BASE-T EEE bits in PHY register 7.3C  *  are modified.  *  **/
end_comment

begin_function
name|s32
name|ixgbe_setup_eee_X550
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|enable_eee
parameter_list|)
block|{
name|u32
name|eeer
decl_stmt|;
name|u16
name|autoneg_eee_reg
decl_stmt|;
name|u32
name|link_reg
decl_stmt|;
name|s32
name|status
decl_stmt|;
name|u32
name|fuse
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_setup_eee_X550"
argument_list|)
expr_stmt|;
name|eeer
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEER
argument_list|)
expr_stmt|;
comment|/* Enable or disable EEE per flag */
if|if
condition|(
name|enable_eee
condition|)
block|{
name|eeer
operator||=
operator|(
name|IXGBE_EEER_TX_LPI_EN
operator||
name|IXGBE_EEER_RX_LPI_EN
operator|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_X550
condition|)
block|{
comment|/* Advertise EEE capability */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_EEE_ADVT
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
operator|&
name|autoneg_eee_reg
argument_list|)
expr_stmt|;
name|autoneg_eee_reg
operator||=
operator|(
name|IXGBE_AUTO_NEG_10GBASE_EEE_ADVT
operator||
name|IXGBE_AUTO_NEG_1000BASE_EEE_ADVT
operator||
name|IXGBE_AUTO_NEG_100BASE_EEE_ADVT
operator|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_EEE_ADVT
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
name|autoneg_eee_reg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hw
operator|->
name|device_id
operator|==
name|IXGBE_DEV_ID_X550EM_X_KR
condition|)
block|{
comment|/* Not supported on first revision. */
name|fuse
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FUSES0_GROUP
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fuse
operator|&
name|IXGBE_FUSES0_REV1
operator|)
condition|)
return|return
name|IXGBE_SUCCESS
return|;
name|status
operator|=
name|ixgbe_read_iosf_sb_reg_x550
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_LINK_CTRL_1
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
operator|&
name|link_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|link_reg
operator||=
name|IXGBE_KRM_LINK_CTRL_1_TETH_EEE_CAP_KR
operator||
name|IXGBE_KRM_LINK_CTRL_1_TETH_EEE_CAP_KX
expr_stmt|;
comment|/* Don't advertise FEC capability when EEE enabled. */
name|link_reg
operator|&=
operator|~
name|IXGBE_KRM_LINK_CTRL_1_TETH_AN_CAP_FEC
expr_stmt|;
name|status
operator|=
name|ixgbe_write_iosf_sb_reg_x550
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_LINK_CTRL_1
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
name|link_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
block|}
block|}
else|else
block|{
name|eeer
operator|&=
operator|~
operator|(
name|IXGBE_EEER_TX_LPI_EN
operator||
name|IXGBE_EEER_RX_LPI_EN
operator|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_X550
condition|)
block|{
comment|/* Disable advertised EEE capability */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_EEE_ADVT
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
operator|&
name|autoneg_eee_reg
argument_list|)
expr_stmt|;
name|autoneg_eee_reg
operator|&=
operator|~
operator|(
name|IXGBE_AUTO_NEG_10GBASE_EEE_ADVT
operator||
name|IXGBE_AUTO_NEG_1000BASE_EEE_ADVT
operator||
name|IXGBE_AUTO_NEG_100BASE_EEE_ADVT
operator|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_EEE_ADVT
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
name|autoneg_eee_reg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hw
operator|->
name|device_id
operator|==
name|IXGBE_DEV_ID_X550EM_X_KR
condition|)
block|{
name|status
operator|=
name|ixgbe_read_iosf_sb_reg_x550
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_LINK_CTRL_1
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
operator|&
name|link_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|link_reg
operator|&=
operator|~
operator|(
name|IXGBE_KRM_LINK_CTRL_1_TETH_EEE_CAP_KR
operator||
name|IXGBE_KRM_LINK_CTRL_1_TETH_EEE_CAP_KX
operator|)
expr_stmt|;
comment|/* Advertise FEC capability when EEE is disabled. */
name|link_reg
operator||=
name|IXGBE_KRM_LINK_CTRL_1_TETH_AN_CAP_FEC
expr_stmt|;
name|status
operator|=
name|ixgbe_write_iosf_sb_reg_x550
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_LINK_CTRL_1
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
name|link_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
block|}
block|}
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEER
argument_list|,
name|eeer
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_set_source_address_pruning_X550 - Enable/Disbale source address pruning  * @hw: pointer to hardware structure  * @enable: enable or disable source address pruning  * @pool: Rx pool to set source address pruning for  **/
end_comment

begin_function
name|void
name|ixgbe_set_source_address_pruning_X550
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|enable
parameter_list|,
name|unsigned
name|int
name|pool
parameter_list|)
block|{
name|u64
name|pfflp
decl_stmt|;
comment|/* max rx pool is 63 */
if|if
condition|(
name|pool
operator|>
literal|63
condition|)
return|return;
name|pfflp
operator|=
operator|(
name|u64
operator|)
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PFFLPL
argument_list|)
expr_stmt|;
name|pfflp
operator||=
operator|(
name|u64
operator|)
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PFFLPH
argument_list|)
operator|<<
literal|32
expr_stmt|;
if|if
condition|(
name|enable
condition|)
name|pfflp
operator||=
operator|(
literal|1ULL
operator|<<
name|pool
operator|)
expr_stmt|;
else|else
name|pfflp
operator|&=
operator|~
operator|(
literal|1ULL
operator|<<
name|pool
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PFFLPL
argument_list|,
operator|(
name|u32
operator|)
name|pfflp
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PFFLPH
argument_list|,
call|(
name|u32
call|)
argument_list|(
name|pfflp
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_set_ethertype_anti_spoofing_X550 - Enable/Disable Ethertype anti-spoofing  *  @hw: pointer to hardware structure  *  @enable: enable or disable switch for Ethertype anti-spoofing  *  @vf: Virtual Function pool - VF Pool to set for Ethertype anti-spoofing  *  **/
end_comment

begin_function
name|void
name|ixgbe_set_ethertype_anti_spoofing_X550
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|enable
parameter_list|,
name|int
name|vf
parameter_list|)
block|{
name|int
name|vf_target_reg
init|=
name|vf
operator|>>
literal|3
decl_stmt|;
name|int
name|vf_target_shift
init|=
name|vf
operator|%
literal|8
operator|+
name|IXGBE_SPOOF_ETHERTYPEAS_SHIFT
decl_stmt|;
name|u32
name|pfvfspoof
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_set_ethertype_anti_spoofing_X550"
argument_list|)
expr_stmt|;
name|pfvfspoof
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PFVFSPOOF
argument_list|(
name|vf_target_reg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
name|pfvfspoof
operator||=
operator|(
literal|1
operator|<<
name|vf_target_shift
operator|)
expr_stmt|;
else|else
name|pfvfspoof
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|vf_target_shift
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PFVFSPOOF
argument_list|(
name|vf_target_reg
argument_list|)
argument_list|,
name|pfvfspoof
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_iosf_wait - Wait for IOSF command completion  * @hw: pointer to hardware structure  * @ctrl: pointer to location to receive final IOSF control value  *  * Returns failing status on timeout  *  * Note: ctrl can be NULL if the IOSF control register value is not needed  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_iosf_wait
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|ctrl
parameter_list|)
block|{
name|u32
name|i
decl_stmt|,
name|command
init|=
literal|0
decl_stmt|;
comment|/* Check every 10 usec to see if the address cycle completed. 	 * The SB IOSF BUSY bit will clear when the operation is 	 * complete 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_MDIO_COMMAND_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|command
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SB_IOSF_INDIRECT_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|command
operator|&
name|IXGBE_SB_IOSF_CTRL_BUSY
operator|)
operator|==
literal|0
condition|)
break|break;
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctrl
condition|)
operator|*
name|ctrl
operator|=
name|command
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|IXGBE_MDIO_COMMAND_TIMEOUT
condition|)
block|{
name|ERROR_REPORT1
argument_list|(
name|IXGBE_ERROR_POLLING
argument_list|,
literal|"Wait timed out\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_PHY
return|;
block|}
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_write_iosf_sb_reg_x550 - Writes a value to specified register of the IOSF  *  device  *  @hw: pointer to hardware structure  *  @reg_addr: 32 bit PHY register to write  *  @device_type: 3 bit device type  *  @data: Data to write to the register  **/
end_comment

begin_function
name|s32
name|ixgbe_write_iosf_sb_reg_x550
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|reg_addr
parameter_list|,
name|u32
name|device_type
parameter_list|,
name|u32
name|data
parameter_list|)
block|{
name|u32
name|gssr
init|=
name|IXGBE_GSSR_PHY1_SM
operator||
name|IXGBE_GSSR_PHY0_SM
decl_stmt|;
name|u32
name|command
decl_stmt|,
name|error
decl_stmt|;
name|s32
name|ret
decl_stmt|;
name|ret
operator|=
name|ixgbe_acquire_swfw_semaphore
argument_list|(
name|hw
argument_list|,
name|gssr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|ixgbe_iosf_wait
argument_list|(
name|hw
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|out
goto|;
name|command
operator|=
operator|(
operator|(
name|reg_addr
operator|<<
name|IXGBE_SB_IOSF_CTRL_ADDR_SHIFT
operator|)
operator||
operator|(
name|device_type
operator|<<
name|IXGBE_SB_IOSF_CTRL_TARGET_SELECT_SHIFT
operator|)
operator|)
expr_stmt|;
comment|/* Write IOSF control register */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SB_IOSF_INDIRECT_CTRL
argument_list|,
name|command
argument_list|)
expr_stmt|;
comment|/* Write IOSF data register */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SB_IOSF_INDIRECT_DATA
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ixgbe_iosf_wait
argument_list|(
name|hw
argument_list|,
operator|&
name|command
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|command
operator|&
name|IXGBE_SB_IOSF_CTRL_RESP_STAT_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
operator|(
name|command
operator|&
name|IXGBE_SB_IOSF_CTRL_CMPL_ERR_MASK
operator|)
operator|>>
name|IXGBE_SB_IOSF_CTRL_CMPL_ERR_SHIFT
expr_stmt|;
name|ERROR_REPORT2
argument_list|(
name|IXGBE_ERROR_POLLING
argument_list|,
literal|"Failed to write, error %x\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ret
operator|=
name|IXGBE_ERR_PHY
expr_stmt|;
block|}
name|out
label|:
name|ixgbe_release_swfw_semaphore
argument_list|(
name|hw
argument_list|,
name|gssr
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_read_iosf_sb_reg_x550 - Writes a value to specified register of the IOSF  *  device  *  @hw: pointer to hardware structure  *  @reg_addr: 32 bit PHY register to write  *  @device_type: 3 bit device type  *  @phy_data: Pointer to read data from the register  **/
end_comment

begin_function
name|s32
name|ixgbe_read_iosf_sb_reg_x550
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|reg_addr
parameter_list|,
name|u32
name|device_type
parameter_list|,
name|u32
modifier|*
name|data
parameter_list|)
block|{
name|u32
name|gssr
init|=
name|IXGBE_GSSR_PHY1_SM
operator||
name|IXGBE_GSSR_PHY0_SM
decl_stmt|;
name|u32
name|command
decl_stmt|,
name|error
decl_stmt|;
name|s32
name|ret
decl_stmt|;
name|ret
operator|=
name|ixgbe_acquire_swfw_semaphore
argument_list|(
name|hw
argument_list|,
name|gssr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|ixgbe_iosf_wait
argument_list|(
name|hw
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|out
goto|;
name|command
operator|=
operator|(
operator|(
name|reg_addr
operator|<<
name|IXGBE_SB_IOSF_CTRL_ADDR_SHIFT
operator|)
operator||
operator|(
name|device_type
operator|<<
name|IXGBE_SB_IOSF_CTRL_TARGET_SELECT_SHIFT
operator|)
operator|)
expr_stmt|;
comment|/* Write IOSF control register */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SB_IOSF_INDIRECT_CTRL
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ixgbe_iosf_wait
argument_list|(
name|hw
argument_list|,
operator|&
name|command
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|command
operator|&
name|IXGBE_SB_IOSF_CTRL_RESP_STAT_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
operator|(
name|command
operator|&
name|IXGBE_SB_IOSF_CTRL_CMPL_ERR_MASK
operator|)
operator|>>
name|IXGBE_SB_IOSF_CTRL_CMPL_ERR_SHIFT
expr_stmt|;
name|ERROR_REPORT2
argument_list|(
name|IXGBE_ERROR_POLLING
argument_list|,
literal|"Failed to read, error %x\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ret
operator|=
name|IXGBE_ERR_PHY
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
name|IXGBE_SUCCESS
condition|)
operator|*
name|data
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SB_IOSF_INDIRECT_DATA
argument_list|)
expr_stmt|;
name|out
label|:
name|ixgbe_release_swfw_semaphore
argument_list|(
name|hw
argument_list|,
name|gssr
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_disable_mdd_X550  *  @hw: pointer to hardware structure  *  *  Disable malicious driver detection  **/
end_comment

begin_function
name|void
name|ixgbe_disable_mdd_X550
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|reg
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_disable_mdd_X550"
argument_list|)
expr_stmt|;
comment|/* Disable MDD for TX DMA and interrupt */
name|reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DMATXCTL
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
operator|(
name|IXGBE_DMATXCTL_MDP_EN
operator||
name|IXGBE_DMATXCTL_MBINTEN
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DMATXCTL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Disable MDD for RX and interrupt */
name|reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RDRXCTL
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
operator|(
name|IXGBE_RDRXCTL_MDP_EN
operator||
name|IXGBE_RDRXCTL_MBINTEN
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RDRXCTL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_enable_mdd_X550  *  @hw: pointer to hardware structure  *  *  Enable malicious driver detection  **/
end_comment

begin_function
name|void
name|ixgbe_enable_mdd_X550
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|reg
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_enable_mdd_X550"
argument_list|)
expr_stmt|;
comment|/* Enable MDD for TX DMA and interrupt */
name|reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DMATXCTL
argument_list|)
expr_stmt|;
name|reg
operator||=
operator|(
name|IXGBE_DMATXCTL_MDP_EN
operator||
name|IXGBE_DMATXCTL_MBINTEN
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DMATXCTL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Enable MDD for RX and interrupt */
name|reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RDRXCTL
argument_list|)
expr_stmt|;
name|reg
operator||=
operator|(
name|IXGBE_RDRXCTL_MDP_EN
operator||
name|IXGBE_RDRXCTL_MBINTEN
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RDRXCTL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_restore_mdd_vf_X550  *  @hw: pointer to hardware structure  *  @vf: vf index  *  *  Restore VF that was disabled during malicious driver detection event  **/
end_comment

begin_function
name|void
name|ixgbe_restore_mdd_vf_X550
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|vf
parameter_list|)
block|{
name|u32
name|idx
decl_stmt|,
name|reg
decl_stmt|,
name|num_qs
decl_stmt|,
name|start_q
decl_stmt|,
name|bitmask
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_restore_mdd_vf_X550"
argument_list|)
expr_stmt|;
comment|/* Map VF to queues */
name|reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MRQC
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|reg
operator|&
name|IXGBE_MRQC_MRQE_MASK
condition|)
block|{
case|case
name|IXGBE_MRQC_VMDQRT8TCEN
case|:
name|num_qs
operator|=
literal|8
expr_stmt|;
comment|/* 16 VFs / pools */
name|bitmask
operator|=
literal|0x000000FF
expr_stmt|;
break|break;
case|case
name|IXGBE_MRQC_VMDQRSS32EN
case|:
case|case
name|IXGBE_MRQC_VMDQRT4TCEN
case|:
name|num_qs
operator|=
literal|4
expr_stmt|;
comment|/* 32 VFs / pools */
name|bitmask
operator|=
literal|0x0000000F
expr_stmt|;
break|break;
default|default:
comment|/* 64 VFs / pools */
name|num_qs
operator|=
literal|2
expr_stmt|;
name|bitmask
operator|=
literal|0x00000003
expr_stmt|;
break|break;
block|}
name|start_q
operator|=
name|vf
operator|*
name|num_qs
expr_stmt|;
comment|/* Release vf's queues by clearing WQBR_TX and WQBR_RX (RW1C) */
name|idx
operator|=
name|start_q
operator|/
literal|32
expr_stmt|;
name|reg
operator|=
literal|0
expr_stmt|;
name|reg
operator||=
operator|(
name|bitmask
operator|<<
operator|(
name|start_q
operator|%
literal|32
operator|)
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_WQBR_TX
argument_list|(
name|idx
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_WQBR_RX
argument_list|(
name|idx
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_mdd_event_X550  *  @hw: pointer to hardware structure  *  @vf_bitmap: vf bitmap of malicious vfs  *  *  Handle malicious driver detection event.  **/
end_comment

begin_function
name|void
name|ixgbe_mdd_event_X550
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|vf_bitmap
parameter_list|)
block|{
name|u32
name|wqbr
decl_stmt|;
name|u32
name|i
decl_stmt|,
name|j
decl_stmt|,
name|reg
decl_stmt|,
name|q
decl_stmt|,
name|shift
decl_stmt|,
name|vf
decl_stmt|,
name|idx
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_mdd_event_X550"
argument_list|)
expr_stmt|;
comment|/* figure out pool size for mapping to vf's */
name|reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MRQC
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|reg
operator|&
name|IXGBE_MRQC_MRQE_MASK
condition|)
block|{
case|case
name|IXGBE_MRQC_VMDQRT8TCEN
case|:
name|shift
operator|=
literal|3
expr_stmt|;
comment|/* 16 VFs / pools */
break|break;
case|case
name|IXGBE_MRQC_VMDQRSS32EN
case|:
case|case
name|IXGBE_MRQC_VMDQRT4TCEN
case|:
name|shift
operator|=
literal|2
expr_stmt|;
comment|/* 32 VFs / pools */
break|break;
default|default:
name|shift
operator|=
literal|1
expr_stmt|;
comment|/* 64 VFs / pools */
break|break;
block|}
comment|/* Read WQBR_TX and WQBR_RX and check for malicious queues */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|wqbr
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_WQBR_TX
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|wqbr
operator||=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_WQBR_RX
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wqbr
condition|)
continue|continue;
comment|/* Get malicious queue */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|32
operator|&&
name|wqbr
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|wqbr
operator|&
operator|(
literal|1
operator|<<
name|j
operator|)
operator|)
condition|)
continue|continue;
comment|/* Get queue from bitmask */
name|q
operator|=
name|j
operator|+
operator|(
name|i
operator|*
literal|32
operator|)
expr_stmt|;
comment|/* Map queue to vf */
name|vf
operator|=
operator|(
name|q
operator|>>
name|shift
operator|)
expr_stmt|;
comment|/* Set vf bit in vf_bitmap */
name|idx
operator|=
name|vf
operator|/
literal|32
expr_stmt|;
name|vf_bitmap
index|[
name|idx
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|vf
operator|%
literal|32
operator|)
operator|)
expr_stmt|;
name|wqbr
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|j
operator|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_media_type_X550em - Get media type  *  @hw: pointer to hardware structure  *  *  Returns the media type (fiber, copper, backplane)  */
end_comment

begin_function
name|enum
name|ixgbe_media_type
name|ixgbe_get_media_type_X550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|enum
name|ixgbe_media_type
name|media_type
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_media_type_X550em"
argument_list|)
expr_stmt|;
comment|/* Detect if there is a copper PHY attached. */
switch|switch
condition|(
name|hw
operator|->
name|device_id
condition|)
block|{
case|case
name|IXGBE_DEV_ID_X550EM_X_KR
case|:
case|case
name|IXGBE_DEV_ID_X550EM_X_KX4
case|:
name|media_type
operator|=
name|ixgbe_media_type_backplane
expr_stmt|;
break|break;
case|case
name|IXGBE_DEV_ID_X550EM_X_SFP
case|:
name|media_type
operator|=
name|ixgbe_media_type_fiber
expr_stmt|;
break|break;
case|case
name|IXGBE_DEV_ID_X550EM_X_1G_T
case|:
case|case
name|IXGBE_DEV_ID_X550EM_X_10G_T
case|:
name|media_type
operator|=
name|ixgbe_media_type_copper
expr_stmt|;
break|break;
default|default:
name|media_type
operator|=
name|ixgbe_media_type_unknown
expr_stmt|;
break|break;
block|}
return|return
name|media_type
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_supported_sfp_modules_X550em - Check if SFP module type is supported  *  @hw: pointer to hardware structure  *  @linear: TRUE if SFP module is linear  */
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_supported_sfp_modules_X550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|bool
modifier|*
name|linear
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_supported_sfp_modules_X550em"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|phy
operator|.
name|sfp_type
condition|)
block|{
case|case
name|ixgbe_sfp_type_not_present
case|:
return|return
name|IXGBE_ERR_SFP_NOT_PRESENT
return|;
case|case
name|ixgbe_sfp_type_da_cu_core0
case|:
case|case
name|ixgbe_sfp_type_da_cu_core1
case|:
operator|*
name|linear
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|ixgbe_sfp_type_srlr_core0
case|:
case|case
name|ixgbe_sfp_type_srlr_core1
case|:
case|case
name|ixgbe_sfp_type_da_act_lmt_core0
case|:
case|case
name|ixgbe_sfp_type_da_act_lmt_core1
case|:
case|case
name|ixgbe_sfp_type_1g_sx_core0
case|:
case|case
name|ixgbe_sfp_type_1g_sx_core1
case|:
case|case
name|ixgbe_sfp_type_1g_lx_core0
case|:
case|case
name|ixgbe_sfp_type_1g_lx_core1
case|:
operator|*
name|linear
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|ixgbe_sfp_type_unknown
case|:
case|case
name|ixgbe_sfp_type_1g_cu_core0
case|:
case|case
name|ixgbe_sfp_type_1g_cu_core1
case|:
default|default:
return|return
name|IXGBE_ERR_SFP_NOT_SUPPORTED
return|;
block|}
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_identify_sfp_module_X550em - Identifies SFP modules  *  @hw: pointer to hardware structure  *  *  Searches for and identifies the SFP module and assigns appropriate PHY type.  **/
end_comment

begin_function
name|s32
name|ixgbe_identify_sfp_module_X550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|bool
name|linear
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_identify_sfp_module_X550em"
argument_list|)
expr_stmt|;
name|status
operator|=
name|ixgbe_identify_module_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* Check if SFP module is supported */
name|status
operator|=
name|ixgbe_supported_sfp_modules_X550em
argument_list|(
name|hw
argument_list|,
operator|&
name|linear
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_setup_sfp_modules_X550em - Setup MAC link ops  *  @hw: pointer to hardware structure  */
end_comment

begin_function
name|s32
name|ixgbe_setup_sfp_modules_X550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|bool
name|linear
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_setup_sfp_modules_X550em"
argument_list|)
expr_stmt|;
comment|/* Check if SFP module is supported */
name|status
operator|=
name|ixgbe_supported_sfp_modules_X550em
argument_list|(
name|hw
argument_list|,
operator|&
name|linear
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|ixgbe_init_mac_link_ops_X550em
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|reset
operator|=
name|NULL
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_init_mac_link_ops_X550em - init mac link function pointers  *  @hw: pointer to hardware structure  */
end_comment

begin_function
name|void
name|ixgbe_init_mac_link_ops_X550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|ixgbe_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_init_mac_link_ops_X550em"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|get_media_type
argument_list|(
name|hw
argument_list|)
condition|)
block|{
case|case
name|ixgbe_media_type_fiber
case|:
comment|/* CS4227 does not support autoneg, so disable the laser control 		 * functions for SFP+ fiber 		 */
name|mac
operator|->
name|ops
operator|.
name|disable_tx_laser
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|enable_tx_laser
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|flap_tx_laser
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|setup_link
operator|=
name|ixgbe_setup_mac_link_multispeed_fiber
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|setup_mac_link
operator|=
name|ixgbe_setup_mac_link_sfp_x550em
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|set_rate_select_speed
operator|=
name|ixgbe_set_soft_rate_select_speed
expr_stmt|;
break|break;
case|case
name|ixgbe_media_type_copper
case|:
name|mac
operator|->
name|ops
operator|.
name|setup_link
operator|=
name|ixgbe_setup_mac_link_t_X550em
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|check_link
operator|=
name|ixgbe_check_link_t_X550em
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_link_capabilities_x550em - Determines link capabilities  *  @hw: pointer to hardware structure  *  @speed: pointer to link speed  *  @autoneg: TRUE when autoneg or autotry is enabled  */
end_comment

begin_function
name|s32
name|ixgbe_get_link_capabilities_X550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
modifier|*
name|speed
parameter_list|,
name|bool
modifier|*
name|autoneg
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_link_capabilities_X550em"
argument_list|)
expr_stmt|;
comment|/* SFP */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|==
name|ixgbe_media_type_fiber
condition|)
block|{
comment|/* CS4227 SFP must not enable auto-negotiation */
operator|*
name|autoneg
operator|=
name|FALSE
expr_stmt|;
comment|/* Check if 1G SFP module. */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|==
name|ixgbe_sfp_type_1g_sx_core0
operator|||
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|==
name|ixgbe_sfp_type_1g_sx_core1
operator|||
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|==
name|ixgbe_sfp_type_1g_lx_core0
operator|||
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|==
name|ixgbe_sfp_type_1g_lx_core1
condition|)
block|{
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
comment|/* Link capabilities are based on SFP */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|multispeed_fiber
condition|)
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_10GB_FULL
operator||
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
else|else
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_10GB_FULL
expr_stmt|;
block|}
else|else
block|{
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_10GB_FULL
operator||
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
operator|*
name|autoneg
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_get_lasi_ext_t_x550em - Determime external Base T PHY interrupt cause  * @hw: pointer to hardware structure  * @lsc: pointer to boolean flag which indicates whether external Base T  *       PHY interrupt is lsc  *  * Determime if external Base T PHY interrupt cause is high temperature  * failure alarm or link status change.  *  * Return IXGBE_ERR_OVERTEMP if interrupt is high temperature  * failure alarm, else return PHY access status.  */
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_get_lasi_ext_t_x550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|bool
modifier|*
name|lsc
parameter_list|)
block|{
name|u32
name|status
decl_stmt|;
name|u16
name|reg
decl_stmt|;
operator|*
name|lsc
operator|=
name|FALSE
expr_stmt|;
comment|/* Vendor alarm triggered */
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_GLOBAL_CHIP_STD_INT_FLAG
argument_list|,
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
operator|||
operator|!
operator|(
name|reg
operator|&
name|IXGBE_MDIO_GLOBAL_VEN_ALM_INT_EN
operator|)
condition|)
return|return
name|status
return|;
comment|/* Vendor Auto-Neg alarm triggered or Global alarm 1 triggered */
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_GLOBAL_INT_CHIP_VEN_FLAG
argument_list|,
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
operator|||
operator|!
operator|(
name|reg
operator|&
operator|(
name|IXGBE_MDIO_GLOBAL_AN_VEN_ALM_INT_EN
operator||
name|IXGBE_MDIO_GLOBAL_ALARM_1_INT
operator|)
operator|)
condition|)
return|return
name|status
return|;
comment|/* High temperature failure alarm triggered */
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_GLOBAL_ALARM_1
argument_list|,
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* If high temperature failure, then return over temp error and exit */
if|if
condition|(
name|reg
operator|&
name|IXGBE_MDIO_GLOBAL_ALM_1_HI_TMP_FAIL
condition|)
block|{
comment|/* power down the PHY in case the PHY FW didn't already */
name|ixgbe_set_copper_phy_power
argument_list|(
name|hw
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_OVERTEMP
return|;
block|}
comment|/* Vendor alarm 2 triggered */
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_GLOBAL_CHIP_STD_INT_FLAG
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
operator|||
operator|!
operator|(
name|reg
operator|&
name|IXGBE_MDIO_GLOBAL_STD_ALM2_INT
operator|)
condition|)
return|return
name|status
return|;
comment|/* link connect/disconnect event occurred */
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_VENDOR_TX_ALARM2
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* Indicate LSC */
if|if
condition|(
name|reg
operator|&
name|IXGBE_MDIO_AUTO_NEG_VEN_LSC
condition|)
operator|*
name|lsc
operator|=
name|TRUE
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_enable_lasi_ext_t_x550em - Enable external Base T PHY interrupts  * @hw: pointer to hardware structure  *  * Enable link status change and temperature failure alarm for the external  * Base T PHY  *  * Returns PHY access status  */
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_enable_lasi_ext_t_x550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|status
decl_stmt|;
name|u16
name|reg
decl_stmt|;
name|bool
name|lsc
decl_stmt|;
comment|/* Clear interrupt flags */
name|status
operator|=
name|ixgbe_get_lasi_ext_t_x550em
argument_list|(
name|hw
argument_list|,
operator|&
name|lsc
argument_list|)
expr_stmt|;
comment|/* Enable link status change alarm */
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_PMA_TX_VEN_LASI_INT_MASK
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|reg
operator||=
name|IXGBE_MDIO_PMA_TX_VEN_LASI_INT_EN
expr_stmt|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_PMA_TX_VEN_LASI_INT_MASK
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* Enables high temperature failure alarm */
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_GLOBAL_INT_MASK
argument_list|,
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|reg
operator||=
name|IXGBE_MDIO_GLOBAL_INT_HI_TEMP_EN
expr_stmt|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_GLOBAL_INT_MASK
argument_list|,
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* Enable vendor Auto-Neg alarm and Global Interrupt Mask 1 alarm */
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_GLOBAL_INT_CHIP_VEN_MASK
argument_list|,
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|reg
operator||=
operator|(
name|IXGBE_MDIO_GLOBAL_AN_VEN_ALM_INT_EN
operator||
name|IXGBE_MDIO_GLOBAL_ALARM_1_INT
operator|)
expr_stmt|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_GLOBAL_INT_CHIP_VEN_MASK
argument_list|,
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* Enable chip-wide vendor alarm */
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_GLOBAL_INT_CHIP_STD_MASK
argument_list|,
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|reg
operator||=
name|IXGBE_MDIO_GLOBAL_VEN_ALM_INT_EN
expr_stmt|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_GLOBAL_INT_CHIP_STD_MASK
argument_list|,
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_setup_kr_speed_x550em - Configure the KR PHY for link speed.  *  @hw: pointer to hardware structure  *  @speed: link speed  *  *  Configures the integrated KR PHY.  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_setup_kr_speed_x550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
name|speed
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|u32
name|reg_val
decl_stmt|;
name|status
operator|=
name|ixgbe_read_iosf_sb_reg_x550
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_LINK_CTRL_1
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
operator|&
name|reg_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|status
return|;
name|reg_val
operator||=
name|IXGBE_KRM_LINK_CTRL_1_TETH_AN_ENABLE
expr_stmt|;
name|reg_val
operator|&=
operator|~
operator|(
name|IXGBE_KRM_LINK_CTRL_1_TETH_AN_CAP_KR
operator||
name|IXGBE_KRM_LINK_CTRL_1_TETH_AN_CAP_KX
operator|)
expr_stmt|;
comment|/* Advertise 10G support. */
if|if
condition|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_10GB_FULL
condition|)
name|reg_val
operator||=
name|IXGBE_KRM_LINK_CTRL_1_TETH_AN_CAP_KR
expr_stmt|;
comment|/* Advertise 1G support. */
if|if
condition|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_1GB_FULL
condition|)
name|reg_val
operator||=
name|IXGBE_KRM_LINK_CTRL_1_TETH_AN_CAP_KX
expr_stmt|;
comment|/* Restart auto-negotiation. */
name|reg_val
operator||=
name|IXGBE_KRM_LINK_CTRL_1_TETH_AN_RESTART
expr_stmt|;
name|status
operator|=
name|ixgbe_write_iosf_sb_reg_x550
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_LINK_CTRL_1
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_init_phy_ops_X550em - PHY/SFP specific init  *  @hw: pointer to hardware structure  *  *  Initialize any function pointers that were not able to be  *  set during init_shared_code because the PHY/SFP type was  *  not known.  Perform the SFP init if necessary.  */
end_comment

begin_function
name|s32
name|ixgbe_init_phy_ops_X550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|ixgbe_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|ixgbe_link_speed
name|speed
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_init_phy_ops_X550em"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|set_lan_id
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|get_media_type
argument_list|(
name|hw
argument_list|)
operator|==
name|ixgbe_media_type_fiber
condition|)
block|{
name|phy
operator|->
name|phy_semaphore_mask
operator|=
name|IXGBE_GSSR_SHARED_I2C_SM
expr_stmt|;
name|ixgbe_setup_mux_ctl
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Save NW management interface connected on board. This is used 		 * to determine internal PHY mode. 		 */
name|phy
operator|->
name|nw_mng_if_sel
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_NW_MNG_IF_SEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|nw_mng_if_sel
operator|&
name|IXGBE_NW_MNG_IF_SEL_INT_PHY_MODE
condition|)
block|{
name|speed
operator|=
name|IXGBE_LINK_SPEED_10GB_FULL
operator||
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
block|}
name|phy
operator|->
name|ops
operator|.
name|identify_sfp
operator|=
name|ixgbe_identify_sfp_module_X550em
expr_stmt|;
block|}
comment|/* Identify the PHY or SFP module */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|identify
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|==
name|IXGBE_ERR_SFP_NOT_SUPPORTED
condition|)
return|return
name|ret_val
return|;
comment|/* Setup function pointers based on detected hardware */
name|ixgbe_init_mac_link_ops_X550em
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|sfp_type
operator|!=
name|ixgbe_sfp_type_unknown
condition|)
name|phy
operator|->
name|ops
operator|.
name|reset
operator|=
name|NULL
expr_stmt|;
comment|/* Set functions pointers based on phy type */
switch|switch
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
condition|)
block|{
case|case
name|ixgbe_phy_x550em_kx4
case|:
name|phy
operator|->
name|ops
operator|.
name|setup_link
operator|=
name|NULL
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|read_reg
operator|=
name|ixgbe_read_phy_reg_x550em
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|write_reg
operator|=
name|ixgbe_write_phy_reg_x550em
expr_stmt|;
break|break;
case|case
name|ixgbe_phy_x550em_kr
case|:
name|phy
operator|->
name|ops
operator|.
name|setup_link
operator|=
name|ixgbe_setup_kr_x550em
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|read_reg
operator|=
name|ixgbe_read_phy_reg_x550em
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|write_reg
operator|=
name|ixgbe_write_phy_reg_x550em
expr_stmt|;
break|break;
case|case
name|ixgbe_phy_x550em_ext_t
case|:
comment|/* Save NW management interface connected on board. This is used 		 * to determine internal PHY mode 		 */
name|phy
operator|->
name|nw_mng_if_sel
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_NW_MNG_IF_SEL
argument_list|)
expr_stmt|;
comment|/* If internal link mode is XFI, then setup iXFI internal link, 		 * else setup KR now. 		 */
if|if
condition|(
operator|!
operator|(
name|phy
operator|->
name|nw_mng_if_sel
operator|&
name|IXGBE_NW_MNG_IF_SEL_INT_PHY_MODE
operator|)
condition|)
block|{
name|phy
operator|->
name|ops
operator|.
name|setup_internal_link
operator|=
name|ixgbe_setup_internal_phy_t_x550em
expr_stmt|;
block|}
else|else
block|{
name|speed
operator|=
name|IXGBE_LINK_SPEED_10GB_FULL
operator||
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
name|ret_val
operator|=
name|ixgbe_setup_kr_speed_x550em
argument_list|(
name|hw
argument_list|,
name|speed
argument_list|)
expr_stmt|;
block|}
comment|/* setup SW LPLU only for first revision */
if|if
condition|(
operator|!
operator|(
name|IXGBE_FUSES0_REV1
operator|&
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FUSES0_GROUP
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
name|phy
operator|->
name|ops
operator|.
name|enter_lplu
operator|=
name|ixgbe_enter_lplu_t_x550em
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|handle_lasi
operator|=
name|ixgbe_handle_lasi_ext_t_x550em
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|reset
operator|=
name|ixgbe_reset_phy_t_X550em
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_reset_hw_X550em - Perform hardware reset  *  @hw: pointer to hardware structure  *  *  Resets the hardware by resetting the transmit and receive units, masks  *  and clears all interrupts, perform a PHY reset, and perform a link (MAC)  *  reset.  */
end_comment

begin_function
name|s32
name|ixgbe_reset_hw_X550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|ixgbe_link_speed
name|link_speed
decl_stmt|;
name|s32
name|status
decl_stmt|;
name|u32
name|ctrl
init|=
literal|0
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|u32
name|hlreg0
decl_stmt|;
name|bool
name|link_up
init|=
name|FALSE
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_reset_hw_X550em"
argument_list|)
expr_stmt|;
comment|/* Call adapter stop to disable Tx/Rx and clear interrupts */
name|status
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|stop_adapter
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* flush pending Tx transactions */
name|ixgbe_clear_tx_pending
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|device_id
operator|==
name|IXGBE_DEV_ID_X550EM_X_10G_T
condition|)
block|{
comment|/* Config MDIO clock speed before the first MDIO PHY access */
name|hlreg0
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_HLREG0
argument_list|)
expr_stmt|;
name|hlreg0
operator|&=
operator|~
name|IXGBE_HLREG0_MDCSPD
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_HLREG0
argument_list|,
name|hlreg0
argument_list|)
expr_stmt|;
block|}
comment|/* PHY ops must be identified and initialized prior to reset */
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|init
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|IXGBE_ERR_SFP_NOT_SUPPORTED
condition|)
return|return
name|status
return|;
comment|/* start the external PHY */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|ixgbe_phy_x550em_ext_t
condition|)
block|{
name|status
operator|=
name|ixgbe_init_ext_t_x550em
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|status
return|;
block|}
comment|/* Setup SFP module if there is one present. */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|sfp_setup_needed
condition|)
block|{
name|status
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|setup_sfp
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|sfp_setup_needed
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|==
name|IXGBE_ERR_SFP_NOT_SUPPORTED
condition|)
return|return
name|status
return|;
comment|/* Reset PHY */
if|if
condition|(
operator|!
name|hw
operator|->
name|phy
operator|.
name|reset_disable
operator|&&
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|reset
condition|)
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|reset
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|mac_reset_top
label|:
comment|/* Issue global reset to the MAC.  Needs to be SW reset if link is up. 	 * If link reset is used when link is up, it might reset the PHY when 	 * mng is using it.  If link is down or the flag to force full link 	 * reset is set, then perform link reset. 	 */
name|ctrl
operator|=
name|IXGBE_CTRL_LNK_RST
expr_stmt|;
if|if
condition|(
operator|!
name|hw
operator|->
name|force_full_reset
condition|)
block|{
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|check_link
argument_list|(
name|hw
argument_list|,
operator|&
name|link_speed
argument_list|,
operator|&
name|link_up
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_up
condition|)
name|ctrl
operator|=
name|IXGBE_CTRL_RST
expr_stmt|;
block|}
name|ctrl
operator||=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CTRL
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Poll for reset bit to self-clear meaning reset is complete */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ctrl
operator|&
name|IXGBE_CTRL_RST_MASK
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|ctrl
operator|&
name|IXGBE_CTRL_RST_MASK
condition|)
block|{
name|status
operator|=
name|IXGBE_ERR_RESET_FAILED
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Reset polling failed to complete.\n"
argument_list|)
expr_stmt|;
block|}
name|msec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
comment|/* Double resets are required for recovery from certain error 	 * conditions.  Between resets, it is necessary to stall to 	 * allow time for any pending HW events to complete. 	 */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|flags
operator|&
name|IXGBE_FLAGS_DOUBLE_RESET_REQUIRED
condition|)
block|{
name|hw
operator|->
name|mac
operator|.
name|flags
operator|&=
operator|~
name|IXGBE_FLAGS_DOUBLE_RESET_REQUIRED
expr_stmt|;
goto|goto
name|mac_reset_top
goto|;
block|}
comment|/* Store the permanent mac address */
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|get_mac_addr
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|perm_addr
argument_list|)
expr_stmt|;
comment|/* Store MAC address from RAR0, clear receive address registers, and 	 * clear the multicast table.  Also reset num_rar_entries to 128, 	 * since we modify this value when programming the SAN MAC address. 	 */
name|hw
operator|->
name|mac
operator|.
name|num_rar_entries
operator|=
literal|128
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|init_rx_addrs
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|device_id
operator|==
name|IXGBE_DEV_ID_X550EM_X_SFP
condition|)
name|ixgbe_setup_mux_ctl
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_init_ext_t_x550em - Start (unstall) the external Base T PHY.  * @hw: pointer to hardware structure  */
end_comment

begin_function
name|s32
name|ixgbe_init_ext_t_x550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|status
decl_stmt|;
name|u16
name|reg
decl_stmt|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_TX_VENDOR_ALARMS_3
argument_list|,
name|IXGBE_MDIO_PMA_PMD_DEV_TYPE
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* If PHY FW reset completed bit is set then this is the first 	 * SW instance after a power on so the PHY FW must be un-stalled. 	 */
if|if
condition|(
name|reg
operator|&
name|IXGBE_MDIO_TX_VENDOR_ALARMS_3_RST_MASK
condition|)
block|{
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_GLOBAL_RES_PR_10
argument_list|,
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|reg
operator|&=
operator|~
name|IXGBE_MDIO_POWER_UP_STALL
expr_stmt|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_GLOBAL_RES_PR_10
argument_list|,
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_setup_kr_x550em - Configure the KR PHY.  *  @hw: pointer to hardware structure  *  *  Configures the integrated KR PHY.  **/
end_comment

begin_function
name|s32
name|ixgbe_setup_kr_x550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
return|return
name|ixgbe_setup_kr_speed_x550em
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_setup_mac_link_sfp_x550em - Setup internal/external the PHY for SFP  *  @hw: pointer to hardware structure  *  *  Configure the external PHY and the integrated KR PHY for SFP support.  **/
end_comment

begin_function
name|s32
name|ixgbe_setup_mac_link_sfp_x550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
name|speed
parameter_list|,
name|bool
name|autoneg_wait_to_complete
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u16
name|reg_slice
decl_stmt|,
name|reg_val
decl_stmt|;
name|bool
name|setup_linear
init|=
name|FALSE
decl_stmt|;
name|UNREFERENCED_1PARAMETER
argument_list|(
name|autoneg_wait_to_complete
argument_list|)
expr_stmt|;
comment|/* Check if SFP module is supported and linear */
name|ret_val
operator|=
name|ixgbe_supported_sfp_modules_X550em
argument_list|(
name|hw
argument_list|,
operator|&
name|setup_linear
argument_list|)
expr_stmt|;
comment|/* If no SFP module present, then return success. Return success since 	 * there is no reason to configure CS4227 and SFP not present error is 	 * not excepted in the setup MAC link flow. 	 */
if|if
condition|(
name|ret_val
operator|==
name|IXGBE_ERR_SFP_NOT_PRESENT
condition|)
return|return
name|IXGBE_SUCCESS
return|;
if|if
condition|(
name|ret_val
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
operator|!
operator|(
name|hw
operator|->
name|phy
operator|.
name|nw_mng_if_sel
operator|&
name|IXGBE_NW_MNG_IF_SEL_INT_PHY_MODE
operator|)
condition|)
block|{
comment|/* Configure CS4227 LINE side to 10G SR. */
name|reg_slice
operator|=
name|IXGBE_CS4227_LINE_SPARE22_MSB
operator|+
operator|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
operator|<<
literal|12
operator|)
expr_stmt|;
name|reg_val
operator|=
name|IXGBE_CS4227_SPEED_10G
expr_stmt|;
name|ret_val
operator|=
name|ixgbe_write_i2c_combined
argument_list|(
name|hw
argument_list|,
name|IXGBE_CS4227
argument_list|,
name|reg_slice
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
name|reg_slice
operator|=
name|IXGBE_CS4227_LINE_SPARE24_LSB
operator|+
operator|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
operator|<<
literal|12
operator|)
expr_stmt|;
name|reg_val
operator|=
operator|(
name|IXGBE_CS4227_EDC_MODE_SR
operator|<<
literal|1
operator|)
operator||
literal|0x1
expr_stmt|;
name|ret_val
operator|=
name|ixgbe_write_i2c_combined
argument_list|(
name|hw
argument_list|,
name|IXGBE_CS4227
argument_list|,
name|reg_slice
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
comment|/* Configure CS4227 for HOST connection rate then type. */
name|reg_slice
operator|=
name|IXGBE_CS4227_HOST_SPARE22_MSB
operator|+
operator|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
operator|<<
literal|12
operator|)
expr_stmt|;
name|reg_val
operator|=
operator|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_10GB_FULL
operator|)
condition|?
name|IXGBE_CS4227_SPEED_10G
else|:
name|IXGBE_CS4227_SPEED_1G
expr_stmt|;
name|ret_val
operator|=
name|ixgbe_write_i2c_combined
argument_list|(
name|hw
argument_list|,
name|IXGBE_CS4227
argument_list|,
name|reg_slice
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
name|reg_slice
operator|=
name|IXGBE_CS4227_HOST_SPARE24_LSB
operator|+
operator|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
operator|<<
literal|12
operator|)
expr_stmt|;
if|if
condition|(
name|setup_linear
condition|)
name|reg_val
operator|=
operator|(
name|IXGBE_CS4227_EDC_MODE_CX1
operator|<<
literal|1
operator|)
operator||
literal|0x1
expr_stmt|;
else|else
name|reg_val
operator|=
operator|(
name|IXGBE_CS4227_EDC_MODE_SR
operator|<<
literal|1
operator|)
operator||
literal|0x1
expr_stmt|;
name|ret_val
operator|=
name|ixgbe_write_i2c_combined
argument_list|(
name|hw
argument_list|,
name|IXGBE_CS4227
argument_list|,
name|reg_slice
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
comment|/* Setup XFI internal link. */
name|ret_val
operator|=
name|ixgbe_setup_ixfi_x550em
argument_list|(
name|hw
argument_list|,
operator|&
name|speed
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Configure internal PHY for KR/KX. */
name|ixgbe_setup_kr_speed_x550em
argument_list|(
name|hw
argument_list|,
name|speed
argument_list|)
expr_stmt|;
comment|/* Configure CS4227 LINE side to proper mode. */
name|reg_slice
operator|=
name|IXGBE_CS4227_LINE_SPARE24_LSB
operator|+
operator|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
operator|<<
literal|12
operator|)
expr_stmt|;
if|if
condition|(
name|setup_linear
condition|)
name|reg_val
operator|=
operator|(
name|IXGBE_CS4227_EDC_MODE_CX1
operator|<<
literal|1
operator|)
operator||
literal|0x1
expr_stmt|;
else|else
name|reg_val
operator|=
operator|(
name|IXGBE_CS4227_EDC_MODE_SR
operator|<<
literal|1
operator|)
operator||
literal|0x1
expr_stmt|;
name|ret_val
operator|=
name|ixgbe_write_i2c_combined
argument_list|(
name|hw
argument_list|,
name|IXGBE_CS4227
argument_list|,
name|reg_slice
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_setup_ixfi_x550em - Configure the KR PHY for iXFI mode.  *  @hw: pointer to hardware structure  *  @speed: the link speed to force  *  *  Configures the integrated KR PHY to use iXFI mode. Used to connect an  *  internal and external PHY at a specific speed, without autonegotiation.  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_setup_ixfi_x550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
modifier|*
name|speed
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|u32
name|reg_val
decl_stmt|;
comment|/* Disable AN and force speed to 10G Serial. */
name|status
operator|=
name|ixgbe_read_iosf_sb_reg_x550
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_LINK_CTRL_1
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
operator|&
name|reg_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|reg_val
operator|&=
operator|~
name|IXGBE_KRM_LINK_CTRL_1_TETH_AN_ENABLE
expr_stmt|;
name|reg_val
operator|&=
operator|~
name|IXGBE_KRM_LINK_CTRL_1_TETH_FORCE_SPEED_MASK
expr_stmt|;
comment|/* Select forced link speed for internal PHY. */
switch|switch
condition|(
operator|*
name|speed
condition|)
block|{
case|case
name|IXGBE_LINK_SPEED_10GB_FULL
case|:
name|reg_val
operator||=
name|IXGBE_KRM_LINK_CTRL_1_TETH_FORCE_SPEED_10G
expr_stmt|;
break|break;
case|case
name|IXGBE_LINK_SPEED_1GB_FULL
case|:
name|reg_val
operator||=
name|IXGBE_KRM_LINK_CTRL_1_TETH_FORCE_SPEED_1G
expr_stmt|;
break|break;
default|default:
comment|/* Other link speeds are not supported by internal KR PHY. */
return|return
name|IXGBE_ERR_LINK_SETUP
return|;
block|}
name|status
operator|=
name|ixgbe_write_iosf_sb_reg_x550
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_LINK_CTRL_1
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* Disable training protocol FSM. */
name|status
operator|=
name|ixgbe_read_iosf_sb_reg_x550
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_RX_TRN_LINKUP_CTRL
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
operator|&
name|reg_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|reg_val
operator||=
name|IXGBE_KRM_RX_TRN_LINKUP_CTRL_CONV_WO_PROTOCOL
expr_stmt|;
name|status
operator|=
name|ixgbe_write_iosf_sb_reg_x550
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_RX_TRN_LINKUP_CTRL
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* Disable Flex from training TXFFE. */
name|status
operator|=
name|ixgbe_read_iosf_sb_reg_x550
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_DSP_TXFFE_STATE_4
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
operator|&
name|reg_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|reg_val
operator|&=
operator|~
name|IXGBE_KRM_DSP_TXFFE_STATE_C0_EN
expr_stmt|;
name|reg_val
operator|&=
operator|~
name|IXGBE_KRM_DSP_TXFFE_STATE_CP1_CN1_EN
expr_stmt|;
name|reg_val
operator|&=
operator|~
name|IXGBE_KRM_DSP_TXFFE_STATE_CO_ADAPT_EN
expr_stmt|;
name|status
operator|=
name|ixgbe_write_iosf_sb_reg_x550
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_DSP_TXFFE_STATE_4
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|status
operator|=
name|ixgbe_read_iosf_sb_reg_x550
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_DSP_TXFFE_STATE_5
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
operator|&
name|reg_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|reg_val
operator|&=
operator|~
name|IXGBE_KRM_DSP_TXFFE_STATE_C0_EN
expr_stmt|;
name|reg_val
operator|&=
operator|~
name|IXGBE_KRM_DSP_TXFFE_STATE_CP1_CN1_EN
expr_stmt|;
name|reg_val
operator|&=
operator|~
name|IXGBE_KRM_DSP_TXFFE_STATE_CO_ADAPT_EN
expr_stmt|;
name|status
operator|=
name|ixgbe_write_iosf_sb_reg_x550
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_DSP_TXFFE_STATE_5
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* Enable override for coefficients. */
name|status
operator|=
name|ixgbe_read_iosf_sb_reg_x550
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_TX_COEFF_CTRL_1
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
operator|&
name|reg_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|reg_val
operator||=
name|IXGBE_KRM_TX_COEFF_CTRL_1_OVRRD_EN
expr_stmt|;
name|reg_val
operator||=
name|IXGBE_KRM_TX_COEFF_CTRL_1_CZERO_EN
expr_stmt|;
name|reg_val
operator||=
name|IXGBE_KRM_TX_COEFF_CTRL_1_CPLUS1_OVRRD_EN
expr_stmt|;
name|reg_val
operator||=
name|IXGBE_KRM_TX_COEFF_CTRL_1_CMINUS1_OVRRD_EN
expr_stmt|;
name|status
operator|=
name|ixgbe_write_iosf_sb_reg_x550
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_TX_COEFF_CTRL_1
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* Toggle port SW reset by AN reset. */
name|status
operator|=
name|ixgbe_read_iosf_sb_reg_x550
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_LINK_CTRL_1
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
operator|&
name|reg_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|reg_val
operator||=
name|IXGBE_KRM_LINK_CTRL_1_TETH_AN_RESTART
expr_stmt|;
name|status
operator|=
name|ixgbe_write_iosf_sb_reg_x550
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_LINK_CTRL_1
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_ext_phy_t_x550em_get_link - Get ext phy link status  * @hw: address of hardware structure  * @link_up: address of boolean to indicate link status  *  * Returns error code if unable to get link status.  */
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_ext_phy_t_x550em_get_link
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|bool
modifier|*
name|link_up
parameter_list|)
block|{
name|u32
name|ret
decl_stmt|;
name|u16
name|autoneg_status
decl_stmt|;
operator|*
name|link_up
operator|=
name|FALSE
expr_stmt|;
comment|/* read this twice back to back to indicate current status */
name|ret
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_STATUS
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
operator|&
name|autoneg_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_STATUS
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
operator|&
name|autoneg_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|ret
return|;
operator|*
name|link_up
operator|=
operator|!
operator|!
operator|(
name|autoneg_status
operator|&
name|IXGBE_MDIO_AUTO_NEG_LINK_STATUS
operator|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_setup_internal_phy_t_x550em - Configure KR PHY to X557 link  * @hw: point to hardware structure  *  * Configures the link between the integrated KR PHY and the external X557 PHY  * The driver will call this function when it gets a link status change  * interrupt from the X557 PHY. This function configures the link speed  * between the PHYs to match the link speed of the BASE-T link.  *  * A return of a non-zero value indicates an error, and the base driver should  * not report link up.  */
end_comment

begin_function
name|s32
name|ixgbe_setup_internal_phy_t_x550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|ixgbe_link_speed
name|force_speed
decl_stmt|;
name|bool
name|link_up
decl_stmt|;
name|u32
name|status
decl_stmt|;
name|u16
name|speed
decl_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|get_media_type
argument_list|(
name|hw
argument_list|)
operator|!=
name|ixgbe_media_type_copper
condition|)
return|return
name|IXGBE_ERR_CONFIG
return|;
comment|/* If link is not up, then there is no setup necessary so return  */
name|status
operator|=
name|ixgbe_ext_phy_t_x550em_get_link
argument_list|(
name|hw
argument_list|,
operator|&
name|link_up
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
if|if
condition|(
operator|!
name|link_up
condition|)
return|return
name|IXGBE_SUCCESS
return|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_VENDOR_STAT
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
operator|&
name|speed
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* If link is not still up, then no setup is necessary so return */
name|status
operator|=
name|ixgbe_ext_phy_t_x550em_get_link
argument_list|(
name|hw
argument_list|,
operator|&
name|link_up
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
if|if
condition|(
operator|!
name|link_up
condition|)
return|return
name|IXGBE_SUCCESS
return|;
comment|/* clear everything but the speed and duplex bits */
name|speed
operator|&=
name|IXGBE_MDIO_AUTO_NEG_VENDOR_STATUS_MASK
expr_stmt|;
switch|switch
condition|(
name|speed
condition|)
block|{
case|case
name|IXGBE_MDIO_AUTO_NEG_VENDOR_STATUS_10GB_FULL
case|:
name|force_speed
operator|=
name|IXGBE_LINK_SPEED_10GB_FULL
expr_stmt|;
break|break;
case|case
name|IXGBE_MDIO_AUTO_NEG_VENDOR_STATUS_1GB_FULL
case|:
name|force_speed
operator|=
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
break|break;
default|default:
comment|/* Internal PHY does not support anything else */
return|return
name|IXGBE_ERR_INVALID_LINK_SETTINGS
return|;
block|}
return|return
name|ixgbe_setup_ixfi_x550em
argument_list|(
name|hw
argument_list|,
operator|&
name|force_speed
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_setup_phy_loopback_x550em - Configure the KR PHY for loopback.  *  @hw: pointer to hardware structure  *  *  Configures the integrated KR PHY to use internal loopback mode.  **/
end_comment

begin_function
name|s32
name|ixgbe_setup_phy_loopback_x550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|u32
name|reg_val
decl_stmt|;
comment|/* Disable AN and force speed to 10G Serial. */
name|status
operator|=
name|ixgbe_read_iosf_sb_reg_x550
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_LINK_CTRL_1
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
operator|&
name|reg_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|reg_val
operator|&=
operator|~
name|IXGBE_KRM_LINK_CTRL_1_TETH_AN_ENABLE
expr_stmt|;
name|reg_val
operator|&=
operator|~
name|IXGBE_KRM_LINK_CTRL_1_TETH_FORCE_SPEED_MASK
expr_stmt|;
name|reg_val
operator||=
name|IXGBE_KRM_LINK_CTRL_1_TETH_FORCE_SPEED_10G
expr_stmt|;
name|status
operator|=
name|ixgbe_write_iosf_sb_reg_x550
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_LINK_CTRL_1
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* Set near-end loopback clocks. */
name|status
operator|=
name|ixgbe_read_iosf_sb_reg_x550
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_PORT_CAR_GEN_CTRL
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
operator|&
name|reg_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|reg_val
operator||=
name|IXGBE_KRM_PORT_CAR_GEN_CTRL_NELB_32B
expr_stmt|;
name|reg_val
operator||=
name|IXGBE_KRM_PORT_CAR_GEN_CTRL_NELB_KRPCS
expr_stmt|;
name|status
operator|=
name|ixgbe_write_iosf_sb_reg_x550
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_PORT_CAR_GEN_CTRL
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* Set loopback enable. */
name|status
operator|=
name|ixgbe_read_iosf_sb_reg_x550
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_PMD_DFX_BURNIN
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
operator|&
name|reg_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|reg_val
operator||=
name|IXGBE_KRM_PMD_DFX_BURNIN_TX_RX_KR_LB_MASK
expr_stmt|;
name|status
operator|=
name|ixgbe_write_iosf_sb_reg_x550
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_PMD_DFX_BURNIN
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* Training bypass. */
name|status
operator|=
name|ixgbe_read_iosf_sb_reg_x550
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_RX_TRN_LINKUP_CTRL
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
operator|&
name|reg_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|reg_val
operator||=
name|IXGBE_KRM_RX_TRN_LINKUP_CTRL_PROTOCOL_BYPASS
expr_stmt|;
name|status
operator|=
name|ixgbe_write_iosf_sb_reg_x550
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_RX_TRN_LINKUP_CTRL
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_read_ee_hostif_X550 - Read EEPROM word using a host interface command  *  assuming that the semaphore is already obtained.  *  @hw: pointer to hardware structure  *  @offset: offset of  word in the EEPROM to read  *  @data: word read from the EEPROM  *  *  Reads a 16 bit word from the EEPROM using the hostif.  **/
end_comment

begin_function
name|s32
name|ixgbe_read_ee_hostif_data_X550
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|struct
name|ixgbe_hic_read_shadow_ram
name|buffer
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_read_ee_hostif_data_X550"
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|hdr
operator|.
name|req
operator|.
name|cmd
operator|=
name|FW_READ_SHADOW_RAM_CMD
expr_stmt|;
name|buffer
operator|.
name|hdr
operator|.
name|req
operator|.
name|buf_lenh
operator|=
literal|0
expr_stmt|;
name|buffer
operator|.
name|hdr
operator|.
name|req
operator|.
name|buf_lenl
operator|=
name|FW_READ_SHADOW_RAM_LEN
expr_stmt|;
name|buffer
operator|.
name|hdr
operator|.
name|req
operator|.
name|checksum
operator|=
name|FW_DEFAULT_CHECKSUM
expr_stmt|;
comment|/* convert offset from words to bytes */
name|buffer
operator|.
name|address
operator|=
name|IXGBE_CPU_TO_BE32
argument_list|(
name|offset
operator|*
literal|2
argument_list|)
expr_stmt|;
comment|/* one word */
name|buffer
operator|.
name|length
operator|=
name|IXGBE_CPU_TO_BE16
argument_list|(
sizeof|sizeof
argument_list|(
name|u16
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|ixgbe_host_interface_command
argument_list|(
name|hw
argument_list|,
operator|(
name|u32
operator|*
operator|)
operator|&
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|IXGBE_HI_COMMAND_TIMEOUT
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|status
return|;
operator|*
name|data
operator|=
operator|(
name|u16
operator|)
name|IXGBE_READ_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|IXGBE_FLEX_MNG
argument_list|,
name|FW_NVM_DATA_OFFSET
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_read_ee_hostif_X550 - Read EEPROM word using a host interface command  *  @hw: pointer to hardware structure  *  @offset: offset of  word in the EEPROM to read  *  @data: word read from the EEPROM  *  *  Reads a 16 bit word from the EEPROM using the hostif.  **/
end_comment

begin_function
name|s32
name|ixgbe_read_ee_hostif_X550
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_read_ee_hostif_X550"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|acquire_swfw_sync
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR_EEP_SM
argument_list|)
operator|==
name|IXGBE_SUCCESS
condition|)
block|{
name|status
operator|=
name|ixgbe_read_ee_hostif_data_X550
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR_EEP_SM
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|IXGBE_ERR_SWFW_SYNC
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_read_ee_hostif_buffer_X550- Read EEPROM word(s) using hostif  *  @hw: pointer to hardware structure  *  @offset: offset of  word in the EEPROM to read  *  @words: number of words  *  @data: word(s) read from the EEPROM  *  *  Reads a 16 bit word(s) from the EEPROM using the hostif.  **/
end_comment

begin_function
name|s32
name|ixgbe_read_ee_hostif_buffer_X550
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
name|words
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ixgbe_hic_read_shadow_ram
name|buffer
decl_stmt|;
name|u32
name|current_word
init|=
literal|0
decl_stmt|;
name|u16
name|words_to_read
decl_stmt|;
name|s32
name|status
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_read_ee_hostif_buffer_X550"
argument_list|)
expr_stmt|;
comment|/* Take semaphore for the entire operation. */
name|status
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|acquire_swfw_sync
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR_EEP_SM
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM read buffer - semaphore failed\n"
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
while|while
condition|(
name|words
condition|)
block|{
if|if
condition|(
name|words
operator|>
name|FW_MAX_READ_BUFFER_SIZE
operator|/
literal|2
condition|)
name|words_to_read
operator|=
name|FW_MAX_READ_BUFFER_SIZE
operator|/
literal|2
expr_stmt|;
else|else
name|words_to_read
operator|=
name|words
expr_stmt|;
name|buffer
operator|.
name|hdr
operator|.
name|req
operator|.
name|cmd
operator|=
name|FW_READ_SHADOW_RAM_CMD
expr_stmt|;
name|buffer
operator|.
name|hdr
operator|.
name|req
operator|.
name|buf_lenh
operator|=
literal|0
expr_stmt|;
name|buffer
operator|.
name|hdr
operator|.
name|req
operator|.
name|buf_lenl
operator|=
name|FW_READ_SHADOW_RAM_LEN
expr_stmt|;
name|buffer
operator|.
name|hdr
operator|.
name|req
operator|.
name|checksum
operator|=
name|FW_DEFAULT_CHECKSUM
expr_stmt|;
comment|/* convert offset from words to bytes */
name|buffer
operator|.
name|address
operator|=
name|IXGBE_CPU_TO_BE32
argument_list|(
operator|(
name|offset
operator|+
name|current_word
operator|)
operator|*
literal|2
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|length
operator|=
name|IXGBE_CPU_TO_BE16
argument_list|(
name|words_to_read
operator|*
literal|2
argument_list|)
expr_stmt|;
name|status
operator|=
name|ixgbe_host_interface_command
argument_list|(
name|hw
argument_list|,
operator|(
name|u32
operator|*
operator|)
operator|&
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|IXGBE_HI_COMMAND_TIMEOUT
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Host interface command failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words_to_read
condition|;
name|i
operator|++
control|)
block|{
name|u32
name|reg
init|=
name|IXGBE_FLEX_MNG
operator|+
operator|(
name|FW_NVM_DATA_OFFSET
operator|<<
literal|2
operator|)
operator|+
literal|2
operator|*
name|i
decl_stmt|;
name|u32
name|value
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|reg
argument_list|)
decl_stmt|;
name|data
index|[
name|current_word
index|]
operator|=
call|(
name|u16
call|)
argument_list|(
name|value
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|current_word
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|words_to_read
condition|)
block|{
name|value
operator|>>=
literal|16
expr_stmt|;
name|data
index|[
name|current_word
index|]
operator|=
call|(
name|u16
call|)
argument_list|(
name|value
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|current_word
operator|++
expr_stmt|;
block|}
block|}
name|words
operator|-=
name|words_to_read
expr_stmt|;
block|}
name|out
label|:
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR_EEP_SM
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_write_ee_hostif_X550 - Write EEPROM word using hostif  *  @hw: pointer to hardware structure  *  @offset: offset of  word in the EEPROM to write  *  @data: word write to the EEPROM  *  *  Write a 16 bit word to the EEPROM using the hostif.  **/
end_comment

begin_function
name|s32
name|ixgbe_write_ee_hostif_data_X550
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
name|data
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|struct
name|ixgbe_hic_write_shadow_ram
name|buffer
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_write_ee_hostif_data_X550"
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|hdr
operator|.
name|req
operator|.
name|cmd
operator|=
name|FW_WRITE_SHADOW_RAM_CMD
expr_stmt|;
name|buffer
operator|.
name|hdr
operator|.
name|req
operator|.
name|buf_lenh
operator|=
literal|0
expr_stmt|;
name|buffer
operator|.
name|hdr
operator|.
name|req
operator|.
name|buf_lenl
operator|=
name|FW_WRITE_SHADOW_RAM_LEN
expr_stmt|;
name|buffer
operator|.
name|hdr
operator|.
name|req
operator|.
name|checksum
operator|=
name|FW_DEFAULT_CHECKSUM
expr_stmt|;
comment|/* one word */
name|buffer
operator|.
name|length
operator|=
name|IXGBE_CPU_TO_BE16
argument_list|(
sizeof|sizeof
argument_list|(
name|u16
argument_list|)
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|data
operator|=
name|data
expr_stmt|;
name|buffer
operator|.
name|address
operator|=
name|IXGBE_CPU_TO_BE32
argument_list|(
name|offset
operator|*
literal|2
argument_list|)
expr_stmt|;
name|status
operator|=
name|ixgbe_host_interface_command
argument_list|(
name|hw
argument_list|,
operator|(
name|u32
operator|*
operator|)
operator|&
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|IXGBE_HI_COMMAND_TIMEOUT
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_write_ee_hostif_X550 - Write EEPROM word using hostif  *  @hw: pointer to hardware structure  *  @offset: offset of  word in the EEPROM to write  *  @data: word write to the EEPROM  *  *  Write a 16 bit word to the EEPROM using the hostif.  **/
end_comment

begin_function
name|s32
name|ixgbe_write_ee_hostif_X550
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
name|data
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_write_ee_hostif_X550"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|acquire_swfw_sync
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR_EEP_SM
argument_list|)
operator|==
name|IXGBE_SUCCESS
condition|)
block|{
name|status
operator|=
name|ixgbe_write_ee_hostif_data_X550
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR_EEP_SM
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"write ee hostif failed to get semaphore"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IXGBE_ERR_SWFW_SYNC
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_write_ee_hostif_buffer_X550 - Write EEPROM word(s) using hostif  *  @hw: pointer to hardware structure  *  @offset: offset of  word in the EEPROM to write  *  @words: number of words  *  @data: word(s) write to the EEPROM  *  *  Write a 16 bit word(s) to the EEPROM using the hostif.  **/
end_comment

begin_function
name|s32
name|ixgbe_write_ee_hostif_buffer_X550
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
name|words
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u32
name|i
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_write_ee_hostif_buffer_X550"
argument_list|)
expr_stmt|;
comment|/* Take semaphore for the entire operation. */
name|status
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|acquire_swfw_sync
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR_EEP_SM
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM write buffer - semaphore failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|++
control|)
block|{
name|status
operator|=
name|ixgbe_write_ee_hostif_data_X550
argument_list|(
name|hw
argument_list|,
name|offset
operator|+
name|i
argument_list|,
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Eeprom buffered write failed\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR_EEP_SM
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_checksum_ptr_x550 - Checksum one pointer region  * @hw: pointer to hardware structure  * @ptr: pointer offset in eeprom  * @size: size of section pointed by ptr, if 0 first word will be used as size  * @csum: address of checksum to update  *  * Returns error status for any failure  */
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_checksum_ptr_x550
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|ptr
parameter_list|,
name|u16
name|size
parameter_list|,
name|u16
modifier|*
name|csum
parameter_list|,
name|u16
modifier|*
name|buffer
parameter_list|,
name|u32
name|buffer_size
parameter_list|)
block|{
name|u16
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|s32
name|status
decl_stmt|;
name|u16
name|length
decl_stmt|,
name|bufsz
decl_stmt|,
name|i
decl_stmt|,
name|start
decl_stmt|;
name|u16
modifier|*
name|local_buffer
decl_stmt|;
name|bufsz
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|buf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Read a chunk at the pointer location */
if|if
condition|(
operator|!
name|buffer
condition|)
block|{
name|status
operator|=
name|ixgbe_read_ee_hostif_buffer_X550
argument_list|(
name|hw
argument_list|,
name|ptr
argument_list|,
name|bufsz
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Failed to read EEPROM image\n"
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
name|local_buffer
operator|=
name|buf
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|buffer_size
operator|<
name|ptr
condition|)
return|return
name|IXGBE_ERR_PARAM
return|;
name|local_buffer
operator|=
operator|&
name|buffer
index|[
name|ptr
index|]
expr_stmt|;
block|}
if|if
condition|(
name|size
condition|)
block|{
name|start
operator|=
literal|0
expr_stmt|;
name|length
operator|=
name|size
expr_stmt|;
block|}
else|else
block|{
name|start
operator|=
literal|1
expr_stmt|;
name|length
operator|=
name|local_buffer
index|[
literal|0
index|]
expr_stmt|;
comment|/* Skip pointer section if length is invalid. */
if|if
condition|(
name|length
operator|==
literal|0xFFFF
operator|||
name|length
operator|==
literal|0
operator|||
operator|(
name|ptr
operator|+
name|length
operator|)
operator|>=
name|hw
operator|->
name|eeprom
operator|.
name|word_size
condition|)
return|return
name|IXGBE_SUCCESS
return|;
block|}
if|if
condition|(
name|buffer
operator|&&
operator|(
operator|(
name|u32
operator|)
name|start
operator|+
operator|(
name|u32
operator|)
name|length
operator|>
name|buffer_size
operator|)
condition|)
return|return
name|IXGBE_ERR_PARAM
return|;
for|for
control|(
name|i
operator|=
name|start
init|;
name|length
condition|;
name|i
operator|++
operator|,
name|length
operator|--
control|)
block|{
if|if
condition|(
name|i
operator|==
name|bufsz
operator|&&
operator|!
name|buffer
condition|)
block|{
name|ptr
operator|+=
name|bufsz
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|length
operator|<
name|bufsz
condition|)
name|bufsz
operator|=
name|length
expr_stmt|;
comment|/* Read a chunk at the pointer location */
name|status
operator|=
name|ixgbe_read_ee_hostif_buffer_X550
argument_list|(
name|hw
argument_list|,
name|ptr
argument_list|,
name|bufsz
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Failed to read EEPROM image\n"
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
block|}
operator|*
name|csum
operator|+=
name|local_buffer
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_calc_checksum_X550 - Calculates and returns the checksum  *  @hw: pointer to hardware structure  *  @buffer: pointer to buffer containing calculated checksum  *  @buffer_size: size of buffer  *  *  Returns a negative error code on error, or the 16-bit checksum  **/
end_comment

begin_function
name|s32
name|ixgbe_calc_checksum_X550
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|buffer
parameter_list|,
name|u32
name|buffer_size
parameter_list|)
block|{
name|u16
name|eeprom_ptrs
index|[
name|IXGBE_EEPROM_LAST_WORD
operator|+
literal|1
index|]
decl_stmt|;
name|u16
modifier|*
name|local_buffer
decl_stmt|;
name|s32
name|status
decl_stmt|;
name|u16
name|checksum
init|=
literal|0
decl_stmt|;
name|u16
name|pointer
decl_stmt|,
name|i
decl_stmt|,
name|size
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_calc_eeprom_checksum_X550"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|init_params
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buffer
condition|)
block|{
comment|/* Read pointer area */
name|status
operator|=
name|ixgbe_read_ee_hostif_buffer_X550
argument_list|(
name|hw
argument_list|,
literal|0
argument_list|,
name|IXGBE_EEPROM_LAST_WORD
operator|+
literal|1
argument_list|,
name|eeprom_ptrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Failed to read EEPROM image\n"
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
name|local_buffer
operator|=
name|eeprom_ptrs
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|buffer_size
operator|<
name|IXGBE_EEPROM_LAST_WORD
condition|)
return|return
name|IXGBE_ERR_PARAM
return|;
name|local_buffer
operator|=
name|buffer
expr_stmt|;
block|}
comment|/* 	 * For X550 hardware include 0x0-0x41 in the checksum, skip the 	 * checksum word itself 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|IXGBE_EEPROM_LAST_WORD
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|i
operator|!=
name|IXGBE_EEPROM_CHECKSUM
condition|)
name|checksum
operator|+=
name|local_buffer
index|[
name|i
index|]
expr_stmt|;
comment|/* 	 * Include all data from pointers 0x3, 0x6-0xE.  This excludes the 	 * FW, PHY module, and PCIe Expansion/Option ROM pointers. 	 */
for|for
control|(
name|i
operator|=
name|IXGBE_PCIE_ANALOG_PTR_X550
init|;
name|i
operator|<
name|IXGBE_FW_PTR
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|IXGBE_PHY_PTR
operator|||
name|i
operator|==
name|IXGBE_OPTION_ROM_PTR
condition|)
continue|continue;
name|pointer
operator|=
name|local_buffer
index|[
name|i
index|]
expr_stmt|;
comment|/* Skip pointer section if the pointer is invalid. */
if|if
condition|(
name|pointer
operator|==
literal|0xFFFF
operator|||
name|pointer
operator|==
literal|0
operator|||
name|pointer
operator|>=
name|hw
operator|->
name|eeprom
operator|.
name|word_size
condition|)
continue|continue;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|IXGBE_PCIE_GENERAL_PTR
case|:
name|size
operator|=
name|IXGBE_IXGBE_PCIE_GENERAL_SIZE
expr_stmt|;
break|break;
case|case
name|IXGBE_PCIE_CONFIG0_PTR
case|:
case|case
name|IXGBE_PCIE_CONFIG1_PTR
case|:
name|size
operator|=
name|IXGBE_PCIE_CONFIG_SIZE
expr_stmt|;
break|break;
default|default:
name|size
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|status
operator|=
name|ixgbe_checksum_ptr_x550
argument_list|(
name|hw
argument_list|,
name|pointer
argument_list|,
name|size
argument_list|,
operator|&
name|checksum
argument_list|,
name|buffer
argument_list|,
name|buffer_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|status
return|;
block|}
name|checksum
operator|=
operator|(
name|u16
operator|)
name|IXGBE_EEPROM_SUM
operator|-
name|checksum
expr_stmt|;
return|return
operator|(
name|s32
operator|)
name|checksum
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_calc_eeprom_checksum_X550 - Calculates and returns the checksum  *  @hw: pointer to hardware structure  *  *  Returns a negative error code on error, or the 16-bit checksum  **/
end_comment

begin_function
name|s32
name|ixgbe_calc_eeprom_checksum_X550
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
return|return
name|ixgbe_calc_checksum_X550
argument_list|(
name|hw
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_validate_eeprom_checksum_X550 - Validate EEPROM checksum  *  @hw: pointer to hardware structure  *  @checksum_val: calculated checksum  *  *  Performs checksum calculation and validates the EEPROM checksum.  If the  *  caller does not need checksum_val, the value can be NULL.  **/
end_comment

begin_function
name|s32
name|ixgbe_validate_eeprom_checksum_X550
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|checksum_val
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|u16
name|checksum
decl_stmt|;
name|u16
name|read_checksum
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_validate_eeprom_checksum_X550"
argument_list|)
expr_stmt|;
comment|/* Read the first word from the EEPROM. If this times out or fails, do 	 * not continue or we could be in for a very long wait while every 	 * EEPROM read fails 	 */
name|status
operator|=
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
literal|0
argument_list|,
operator|&
name|checksum
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM read failed\n"
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
name|status
operator|=
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|calc_checksum
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
condition|)
return|return
name|status
return|;
name|checksum
operator|=
call|(
name|u16
call|)
argument_list|(
name|status
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|status
operator|=
name|ixgbe_read_ee_hostif_X550
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEPROM_CHECKSUM
argument_list|,
operator|&
name|read_checksum
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|status
return|;
comment|/* Verify read checksum from EEPROM is the same as 	 * calculated checksum 	 */
if|if
condition|(
name|read_checksum
operator|!=
name|checksum
condition|)
block|{
name|status
operator|=
name|IXGBE_ERR_EEPROM_CHECKSUM
expr_stmt|;
name|ERROR_REPORT1
argument_list|(
name|IXGBE_ERROR_INVALID_STATE
argument_list|,
literal|"Invalid EEPROM checksum"
argument_list|)
expr_stmt|;
block|}
comment|/* If the user cares, return the calculated checksum */
if|if
condition|(
name|checksum_val
condition|)
operator|*
name|checksum_val
operator|=
name|checksum
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_update_eeprom_checksum_X550 - Updates the EEPROM checksum and flash  * @hw: pointer to hardware structure  *  * After writing EEPROM to shadow RAM using EEWR register, software calculates  * checksum and updates the EEPROM and instructs the hardware to update  * the flash.  **/
end_comment

begin_function
name|s32
name|ixgbe_update_eeprom_checksum_X550
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|u16
name|checksum
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_update_eeprom_checksum_X550"
argument_list|)
expr_stmt|;
comment|/* Read the first word from the EEPROM. If this times out or fails, do 	 * not continue or we could be in for a very long wait while every 	 * EEPROM read fails 	 */
name|status
operator|=
name|ixgbe_read_ee_hostif_X550
argument_list|(
name|hw
argument_list|,
literal|0
argument_list|,
operator|&
name|checksum
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM read failed\n"
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
name|status
operator|=
name|ixgbe_calc_eeprom_checksum_X550
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
condition|)
return|return
name|status
return|;
name|checksum
operator|=
call|(
name|u16
call|)
argument_list|(
name|status
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|status
operator|=
name|ixgbe_write_ee_hostif_X550
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEPROM_CHECKSUM
argument_list|,
name|checksum
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|status
return|;
name|status
operator|=
name|ixgbe_update_flash_X550
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_update_flash_X550 - Instruct HW to copy EEPROM to Flash device  *  @hw: pointer to hardware structure  *  *  Issue a shadow RAM dump to FW to copy EEPROM from shadow RAM to the flash.  **/
end_comment

begin_function
name|s32
name|ixgbe_update_flash_X550
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|union
name|ixgbe_hic_hdr2
name|buffer
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_update_flash_X550"
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|req
operator|.
name|cmd
operator|=
name|FW_SHADOW_RAM_DUMP_CMD
expr_stmt|;
name|buffer
operator|.
name|req
operator|.
name|buf_lenh
operator|=
literal|0
expr_stmt|;
name|buffer
operator|.
name|req
operator|.
name|buf_lenl
operator|=
name|FW_SHADOW_RAM_DUMP_LEN
expr_stmt|;
name|buffer
operator|.
name|req
operator|.
name|checksum
operator|=
name|FW_DEFAULT_CHECKSUM
expr_stmt|;
name|status
operator|=
name|ixgbe_host_interface_command
argument_list|(
name|hw
argument_list|,
operator|(
name|u32
operator|*
operator|)
operator|&
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|IXGBE_HI_COMMAND_TIMEOUT
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_supported_physical_layer_X550em - Returns physical layer type  *  @hw: pointer to hardware structure  *  *  Determines physical layer capabilities of the current configuration.  **/
end_comment

begin_function
name|u32
name|ixgbe_get_supported_physical_layer_X550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|physical_layer
init|=
name|IXGBE_PHYSICAL_LAYER_UNKNOWN
decl_stmt|;
name|u16
name|ext_ability
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_supported_physical_layer_X550em"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|identify
argument_list|(
name|hw
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
condition|)
block|{
case|case
name|ixgbe_phy_x550em_kr
case|:
name|physical_layer
operator|=
name|IXGBE_PHYSICAL_LAYER_10GBASE_KR
operator||
name|IXGBE_PHYSICAL_LAYER_1000BASE_KX
expr_stmt|;
break|break;
case|case
name|ixgbe_phy_x550em_kx4
case|:
name|physical_layer
operator|=
name|IXGBE_PHYSICAL_LAYER_10GBASE_KX4
operator||
name|IXGBE_PHYSICAL_LAYER_1000BASE_KX
expr_stmt|;
break|break;
case|case
name|ixgbe_phy_x550em_ext_t
case|:
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_PHY_EXT_ABILITY
argument_list|,
name|IXGBE_MDIO_PMA_PMD_DEV_TYPE
argument_list|,
operator|&
name|ext_ability
argument_list|)
expr_stmt|;
if|if
condition|(
name|ext_ability
operator|&
name|IXGBE_MDIO_PHY_10GBASET_ABILITY
condition|)
name|physical_layer
operator||=
name|IXGBE_PHYSICAL_LAYER_10GBASE_T
expr_stmt|;
if|if
condition|(
name|ext_ability
operator|&
name|IXGBE_MDIO_PHY_1000BASET_ABILITY
condition|)
name|physical_layer
operator||=
name|IXGBE_PHYSICAL_LAYER_1000BASE_T
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|get_media_type
argument_list|(
name|hw
argument_list|)
operator|==
name|ixgbe_media_type_fiber
condition|)
name|physical_layer
operator|=
name|ixgbe_get_supported_phy_sfp_layer_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|physical_layer
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_get_bus_info_x550em - Set PCI bus info  * @hw: pointer to hardware structure  *  * Sets bus link width and speed to unknown because X550em is  * not a PCI device.  **/
end_comment

begin_function
name|s32
name|ixgbe_get_bus_info_X550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_bus_info_x550em"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|bus
operator|.
name|width
operator|=
name|ixgbe_bus_width_unknown
expr_stmt|;
name|hw
operator|->
name|bus
operator|.
name|speed
operator|=
name|ixgbe_bus_speed_unknown
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|set_lan_id
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_disable_rx_x550 - Disable RX unit  *  * Enables the Rx DMA unit for x550  **/
end_comment

begin_function
name|void
name|ixgbe_disable_rx_x550
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|rxctrl
decl_stmt|,
name|pfdtxgswc
decl_stmt|;
name|s32
name|status
decl_stmt|;
name|struct
name|ixgbe_hic_disable_rxen
name|fw_cmd
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_enable_rx_dma_x550"
argument_list|)
expr_stmt|;
name|rxctrl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXCTRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rxctrl
operator|&
name|IXGBE_RXCTRL_RXEN
condition|)
block|{
name|pfdtxgswc
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PFDTXGSWC
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfdtxgswc
operator|&
name|IXGBE_PFDTXGSWC_VT_LBEN
condition|)
block|{
name|pfdtxgswc
operator|&=
operator|~
name|IXGBE_PFDTXGSWC_VT_LBEN
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PFDTXGSWC
argument_list|,
name|pfdtxgswc
argument_list|)
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|set_lben
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|hw
operator|->
name|mac
operator|.
name|set_lben
operator|=
name|FALSE
expr_stmt|;
block|}
name|fw_cmd
operator|.
name|hdr
operator|.
name|cmd
operator|=
name|FW_DISABLE_RXEN_CMD
expr_stmt|;
name|fw_cmd
operator|.
name|hdr
operator|.
name|buf_len
operator|=
name|FW_DISABLE_RXEN_LEN
expr_stmt|;
name|fw_cmd
operator|.
name|hdr
operator|.
name|checksum
operator|=
name|FW_DEFAULT_CHECKSUM
expr_stmt|;
name|fw_cmd
operator|.
name|port_number
operator|=
operator|(
name|u8
operator|)
name|hw
operator|->
name|bus
operator|.
name|lan_id
expr_stmt|;
name|status
operator|=
name|ixgbe_host_interface_command
argument_list|(
name|hw
argument_list|,
operator|(
name|u32
operator|*
operator|)
operator|&
name|fw_cmd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ixgbe_hic_disable_rxen
argument_list|)
argument_list|,
name|IXGBE_HI_COMMAND_TIMEOUT
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* If we fail - disable RX using register write */
if|if
condition|(
name|status
condition|)
block|{
name|rxctrl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXCTRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rxctrl
operator|&
name|IXGBE_RXCTRL_RXEN
condition|)
block|{
name|rxctrl
operator|&=
operator|~
name|IXGBE_RXCTRL_RXEN
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXCTRL
argument_list|,
name|rxctrl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * ixgbe_enter_lplu_x550em - Transition to low power states  *  @hw: pointer to hardware structure  *  * Configures Low Power Link Up on transition to low power states  * (from D0 to non-D0). Link is required to enter LPLU so avoid resetting the  * X557 PHY immediately prior to entering LPLU.  **/
end_comment

begin_function
name|s32
name|ixgbe_enter_lplu_t_x550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u16
name|an_10g_cntl_reg
decl_stmt|,
name|autoneg_reg
decl_stmt|,
name|speed
decl_stmt|;
name|s32
name|status
decl_stmt|;
name|ixgbe_link_speed
name|lcd_speed
decl_stmt|;
name|u32
name|save_autoneg
decl_stmt|;
name|bool
name|link_up
decl_stmt|;
comment|/* SW LPLU not required on later HW revisions. */
if|if
condition|(
name|IXGBE_FUSES0_REV1
operator|&
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FUSES0_GROUP
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|IXGBE_SUCCESS
return|;
comment|/* If blocked by MNG FW, then don't restart AN */
if|if
condition|(
name|ixgbe_check_reset_blocked
argument_list|(
name|hw
argument_list|)
condition|)
return|return
name|IXGBE_SUCCESS
return|;
name|status
operator|=
name|ixgbe_ext_phy_t_x550em_get_link
argument_list|(
name|hw
argument_list|,
operator|&
name|link_up
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|status
operator|=
name|ixgbe_read_eeprom
argument_list|(
name|hw
argument_list|,
name|NVM_INIT_CTRL_3
argument_list|,
operator|&
name|hw
operator|->
name|eeprom
operator|.
name|ctrl_word_3
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* If link is down, LPLU disabled in NVM, WoL disabled, or manageability 	 * disabled, then force link down by entering low power mode. 	 */
if|if
condition|(
operator|!
name|link_up
operator|||
operator|!
operator|(
name|hw
operator|->
name|eeprom
operator|.
name|ctrl_word_3
operator|&
name|NVM_INIT_CTRL_3_LPLU
operator|)
operator|||
operator|!
operator|(
name|hw
operator|->
name|wol_enabled
operator|||
name|ixgbe_mng_present
argument_list|(
name|hw
argument_list|)
operator|)
condition|)
return|return
name|ixgbe_set_copper_phy_power
argument_list|(
name|hw
argument_list|,
name|FALSE
argument_list|)
return|;
comment|/* Determine LCD */
name|status
operator|=
name|ixgbe_get_lcd_t_x550em
argument_list|(
name|hw
argument_list|,
operator|&
name|lcd_speed
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* If no valid LCD link speed, then force link down and exit. */
if|if
condition|(
name|lcd_speed
operator|==
name|IXGBE_LINK_SPEED_UNKNOWN
condition|)
return|return
name|ixgbe_set_copper_phy_power
argument_list|(
name|hw
argument_list|,
name|FALSE
argument_list|)
return|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_VENDOR_STAT
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
operator|&
name|speed
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* If no link now, speed is invalid so take link down */
name|status
operator|=
name|ixgbe_ext_phy_t_x550em_get_link
argument_list|(
name|hw
argument_list|,
operator|&
name|link_up
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|ixgbe_set_copper_phy_power
argument_list|(
name|hw
argument_list|,
name|FALSE
argument_list|)
return|;
comment|/* clear everything but the speed bits */
name|speed
operator|&=
name|IXGBE_MDIO_AUTO_NEG_VEN_STAT_SPEED_MASK
expr_stmt|;
comment|/* If current speed is already LCD, then exit. */
if|if
condition|(
operator|(
operator|(
name|speed
operator|==
name|IXGBE_MDIO_AUTO_NEG_VENDOR_STATUS_1GB
operator|)
operator|&&
operator|(
name|lcd_speed
operator|==
name|IXGBE_LINK_SPEED_1GB_FULL
operator|)
operator|)
operator|||
operator|(
operator|(
name|speed
operator|==
name|IXGBE_MDIO_AUTO_NEG_VENDOR_STATUS_10GB
operator|)
operator|&&
operator|(
name|lcd_speed
operator|==
name|IXGBE_LINK_SPEED_10GB_FULL
operator|)
operator|)
condition|)
return|return
name|status
return|;
comment|/* Clear AN completed indication */
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_VENDOR_TX_ALARM
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
operator|&
name|autoneg_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MII_10GBASE_T_AUTONEG_CTRL_REG
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
operator|&
name|an_10g_cntl_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MII_AUTONEG_VENDOR_PROVISION_1_REG
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
operator|&
name|autoneg_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|save_autoneg
operator|=
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
expr_stmt|;
comment|/* Setup link at least common link speed */
name|status
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|setup_link
argument_list|(
name|hw
argument_list|,
name|lcd_speed
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* restore autoneg from before setting lplu speed */
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator|=
name|save_autoneg
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_get_lcd_x550em - Determine lowest common denominator  *  @hw: pointer to hardware structure  *  @lcd_speed: pointer to lowest common link speed  *  * Determine lowest common link speed with link partner.  **/
end_comment

begin_function
name|s32
name|ixgbe_get_lcd_t_x550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
modifier|*
name|lcd_speed
parameter_list|)
block|{
name|u16
name|an_lp_status
decl_stmt|;
name|s32
name|status
decl_stmt|;
name|u16
name|word
init|=
name|hw
operator|->
name|eeprom
operator|.
name|ctrl_word_3
decl_stmt|;
operator|*
name|lcd_speed
operator|=
name|IXGBE_LINK_SPEED_UNKNOWN
expr_stmt|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTO_NEG_LP_STATUS
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
operator|&
name|an_lp_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* If link partner advertised 1G, return 1G */
if|if
condition|(
name|an_lp_status
operator|&
name|IXGBE_AUTO_NEG_LP_1000BASE_CAP
condition|)
block|{
operator|*
name|lcd_speed
operator|=
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
return|return
name|status
return|;
block|}
comment|/* If 10G disabled for LPLU via NVM D10GMP, then return no valid LCD */
if|if
condition|(
operator|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
operator|&&
operator|(
name|word
operator|&
name|NVM_INIT_CTRL_3_D10GMP_PORT1
operator|)
operator|)
operator|||
operator|(
name|word
operator|&
name|NVM_INIT_CTRL_3_D10GMP_PORT0
operator|)
condition|)
return|return
name|status
return|;
comment|/* Link partner not capable of lower speeds, return 10G */
operator|*
name|lcd_speed
operator|=
name|IXGBE_LINK_SPEED_10GB_FULL
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_setup_fc_X550em - Set up flow control  *  @hw: pointer to hardware structure  *  *  Called at init time to set up flow control.  **/
end_comment

begin_function
name|s32
name|ixgbe_setup_fc_X550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u32
name|pause
decl_stmt|,
name|asm_dir
decl_stmt|,
name|reg_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_setup_fc_X550em"
argument_list|)
expr_stmt|;
comment|/* Validate the requested mode */
if|if
condition|(
name|hw
operator|->
name|fc
operator|.
name|strict_ieee
operator|&&
name|hw
operator|->
name|fc
operator|.
name|requested_mode
operator|==
name|ixgbe_fc_rx_pause
condition|)
block|{
name|ERROR_REPORT1
argument_list|(
name|IXGBE_ERROR_UNSUPPORTED
argument_list|,
literal|"ixgbe_fc_rx_pause not valid in strict IEEE mode\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|IXGBE_ERR_INVALID_LINK_SETTINGS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 10gig parts do not have a word in the EEPROM to determine the 	 * default flow control setting, so we explicitly set it to full. 	 */
if|if
condition|(
name|hw
operator|->
name|fc
operator|.
name|requested_mode
operator|==
name|ixgbe_fc_default
condition|)
name|hw
operator|->
name|fc
operator|.
name|requested_mode
operator|=
name|ixgbe_fc_full
expr_stmt|;
comment|/* Determine PAUSE and ASM_DIR bits. */
switch|switch
condition|(
name|hw
operator|->
name|fc
operator|.
name|requested_mode
condition|)
block|{
case|case
name|ixgbe_fc_none
case|:
name|pause
operator|=
literal|0
expr_stmt|;
name|asm_dir
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ixgbe_fc_tx_pause
case|:
name|pause
operator|=
literal|0
expr_stmt|;
name|asm_dir
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ixgbe_fc_rx_pause
case|:
comment|/* Rx Flow control is enabled and Tx Flow control is 		 * disabled by software override. Since there really 		 * isn't a way to advertise that we are capable of RX 		 * Pause ONLY, we will advertise that we support both 		 * symmetric and asymmetric Rx PAUSE, as such we fall 		 * through to the fc_full statement.  Later, we will 		 * disable the adapter's ability to send PAUSE frames. 		 */
case|case
name|ixgbe_fc_full
case|:
name|pause
operator|=
literal|1
expr_stmt|;
name|asm_dir
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|ERROR_REPORT1
argument_list|(
name|IXGBE_ERROR_ARGUMENT
argument_list|,
literal|"Flow control param set incorrectly\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|IXGBE_ERR_CONFIG
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|hw
operator|->
name|device_id
operator|==
name|IXGBE_DEV_ID_X550EM_X_KR
condition|)
block|{
name|ret_val
operator|=
name|ixgbe_read_iosf_sb_reg_x550
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_AN_CNTL_1
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
operator|&
name|reg_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|out
goto|;
name|reg_val
operator|&=
operator|~
operator|(
name|IXGBE_KRM_AN_CNTL_1_SYM_PAUSE
operator||
name|IXGBE_KRM_AN_CNTL_1_ASM_PAUSE
operator|)
expr_stmt|;
if|if
condition|(
name|pause
condition|)
name|reg_val
operator||=
name|IXGBE_KRM_AN_CNTL_1_SYM_PAUSE
expr_stmt|;
if|if
condition|(
name|asm_dir
condition|)
name|reg_val
operator||=
name|IXGBE_KRM_AN_CNTL_1_ASM_PAUSE
expr_stmt|;
name|ret_val
operator|=
name|ixgbe_write_iosf_sb_reg_x550
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_AN_CNTL_1
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
comment|/* This device does not fully support AN. */
name|hw
operator|->
name|fc
operator|.
name|disable_fc_autoneg
operator|=
name|TRUE
expr_stmt|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_set_mux - Set mux for port 1 access with CS4227  * @hw: pointer to hardware structure  * @state: set mux if 1, clear if 0  */
end_comment

begin_function
specifier|static
name|void
name|ixgbe_set_mux
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|state
parameter_list|)
block|{
name|u32
name|esdp
decl_stmt|;
if|if
condition|(
operator|!
name|hw
operator|->
name|bus
operator|.
name|lan_id
condition|)
return|return;
name|esdp
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
condition|)
name|esdp
operator||=
name|IXGBE_ESDP_SDP1
expr_stmt|;
else|else
name|esdp
operator|&=
operator|~
name|IXGBE_ESDP_SDP1
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|,
name|esdp
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_acquire_swfw_sync_X550em - Acquire SWFW semaphore  *  @hw: pointer to hardware structure  *  @mask: Mask to specify which semaphore to acquire  *  *  Acquires the SWFW semaphore and sets the I2C MUX  **/
end_comment

begin_function
name|s32
name|ixgbe_acquire_swfw_sync_X550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|mask
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_acquire_swfw_sync_X550em"
argument_list|)
expr_stmt|;
name|status
operator|=
name|ixgbe_acquire_swfw_sync_X540
argument_list|(
name|hw
argument_list|,
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|status
return|;
if|if
condition|(
name|mask
operator|&
name|IXGBE_GSSR_I2C_MASK
condition|)
name|ixgbe_set_mux
argument_list|(
name|hw
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_release_swfw_sync_X550em - Release SWFW semaphore  *  @hw: pointer to hardware structure  *  @mask: Mask to specify which semaphore to release  *  *  Releases the SWFW semaphore and sets the I2C MUX  **/
end_comment

begin_function
name|void
name|ixgbe_release_swfw_sync_X550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|mask
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_release_swfw_sync_X550em"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IXGBE_GSSR_I2C_MASK
condition|)
name|ixgbe_set_mux
argument_list|(
name|hw
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ixgbe_release_swfw_sync_X540
argument_list|(
name|hw
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_handle_lasi_ext_t_x550em - Handle external Base T PHY interrupt  * @hw: pointer to hardware structure  *  * Handle external Base T PHY interrupt. If high temperature  * failure alarm then return error, else if link status change  * then setup internal/external PHY link  *  * Return IXGBE_ERR_OVERTEMP if interrupt is high temperature  * failure alarm, else return PHY access status.  */
end_comment

begin_function
name|s32
name|ixgbe_handle_lasi_ext_t_x550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|bool
name|lsc
decl_stmt|;
name|u32
name|status
decl_stmt|;
name|status
operator|=
name|ixgbe_get_lasi_ext_t_x550em
argument_list|(
name|hw
argument_list|,
operator|&
name|lsc
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
if|if
condition|(
name|lsc
condition|)
return|return
name|ixgbe_setup_internal_phy
argument_list|(
name|hw
argument_list|)
return|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_setup_mac_link_t_X550em - Sets the auto advertised link speed  * @hw: pointer to hardware structure  * @speed: new link speed  * @autoneg_wait_to_complete: TRUE when waiting for completion is needed  *  * Setup internal/external PHY link speed based on link speed, then set  * external PHY auto advertised link speed.  *  * Returns error status for any failure  **/
end_comment

begin_function
name|s32
name|ixgbe_setup_mac_link_t_X550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
name|speed
parameter_list|,
name|bool
name|autoneg_wait_to_complete
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|ixgbe_link_speed
name|force_speed
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_setup_mac_link_t_X550em"
argument_list|)
expr_stmt|;
comment|/* Setup internal/external PHY link speed to iXFI (10G), unless 	 * only 1G is auto advertised then setup KX link. 	 */
if|if
condition|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_10GB_FULL
condition|)
name|force_speed
operator|=
name|IXGBE_LINK_SPEED_10GB_FULL
expr_stmt|;
else|else
name|force_speed
operator|=
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
comment|/* If internal link mode is XFI, then setup XFI internal link. */
if|if
condition|(
operator|!
operator|(
name|hw
operator|->
name|phy
operator|.
name|nw_mng_if_sel
operator|&
name|IXGBE_NW_MNG_IF_SEL_INT_PHY_MODE
operator|)
condition|)
block|{
name|status
operator|=
name|ixgbe_setup_ixfi_x550em
argument_list|(
name|hw
argument_list|,
operator|&
name|force_speed
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
block|}
return|return
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|setup_link_speed
argument_list|(
name|hw
argument_list|,
name|speed
argument_list|,
name|autoneg_wait_to_complete
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_check_link_t_X550em - Determine link and speed status  * @hw: pointer to hardware structure  * @speed: pointer to link speed  * @link_up: TRUE when link is up  * @link_up_wait_to_complete: bool used to wait for link up or not  *  * Check that both the MAC and X557 external PHY have link.  **/
end_comment

begin_function
name|s32
name|ixgbe_check_link_t_X550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
modifier|*
name|speed
parameter_list|,
name|bool
modifier|*
name|link_up
parameter_list|,
name|bool
name|link_up_wait_to_complete
parameter_list|)
block|{
name|u32
name|status
decl_stmt|;
name|u16
name|autoneg_status
decl_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|get_media_type
argument_list|(
name|hw
argument_list|)
operator|!=
name|ixgbe_media_type_copper
condition|)
return|return
name|IXGBE_ERR_CONFIG
return|;
name|status
operator|=
name|ixgbe_check_mac_link_generic
argument_list|(
name|hw
argument_list|,
name|speed
argument_list|,
name|link_up
argument_list|,
name|link_up_wait_to_complete
argument_list|)
expr_stmt|;
comment|/* If check link fails or MAC link is not up, then return */
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
operator|||
operator|!
operator|(
operator|*
name|link_up
operator|)
condition|)
return|return
name|status
return|;
comment|/* MAC link is up, so check external PHY link. 	 * Read this twice back to back to indicate current status. 	 */
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_STATUS
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
operator|&
name|autoneg_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_STATUS
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
operator|&
name|autoneg_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* If external PHY link is not up, then indicate link not up */
if|if
condition|(
operator|!
operator|(
name|autoneg_status
operator|&
name|IXGBE_MDIO_AUTO_NEG_LINK_STATUS
operator|)
condition|)
operator|*
name|link_up
operator|=
name|FALSE
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_reset_phy_t_X550em - Performs X557 PHY reset and enables LASI  *  @hw: pointer to hardware structure  **/
end_comment

begin_function
name|s32
name|ixgbe_reset_phy_t_X550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|status
operator|=
name|ixgbe_reset_phy_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* Configure Link Status Alarm and Temperature Threshold interrupts */
return|return
name|ixgbe_enable_lasi_ext_t_x550em
argument_list|(
name|hw
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_led_on_t_X550em - Turns on the software controllable LEDs.  *  @hw: pointer to hardware structure  *  @led_idx: led number to turn on  **/
end_comment

begin_function
name|s32
name|ixgbe_led_on_t_X550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|led_idx
parameter_list|)
block|{
name|u16
name|phy_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_led_on_t_X550em"
argument_list|)
expr_stmt|;
if|if
condition|(
name|led_idx
operator|>=
name|IXGBE_X557_MAX_LED_INDEX
condition|)
return|return
name|IXGBE_ERR_PARAM
return|;
comment|/* To turn on the LED, set mode to ON. */
name|ixgbe_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_X557_LED_PROVISIONING
operator|+
name|led_idx
argument_list|,
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
name|phy_data
operator||=
name|IXGBE_X557_LED_MANUAL_SET_MASK
expr_stmt|;
name|ixgbe_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_X557_LED_PROVISIONING
operator|+
name|led_idx
argument_list|,
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_led_off_t_X550em - Turns off the software controllable LEDs.  *  @hw: pointer to hardware structure  *  @led_idx: led number to turn off  **/
end_comment

begin_function
name|s32
name|ixgbe_led_off_t_X550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|led_idx
parameter_list|)
block|{
name|u16
name|phy_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_led_off_t_X550em"
argument_list|)
expr_stmt|;
if|if
condition|(
name|led_idx
operator|>=
name|IXGBE_X557_MAX_LED_INDEX
condition|)
return|return
name|IXGBE_ERR_PARAM
return|;
comment|/* To turn on the LED, set mode to ON. */
name|ixgbe_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_X557_LED_PROVISIONING
operator|+
name|led_idx
argument_list|,
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
name|phy_data
operator|&=
operator|~
name|IXGBE_X557_LED_MANUAL_SET_MASK
expr_stmt|;
name|ixgbe_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_X557_LED_PROVISIONING
operator|+
name|led_idx
argument_list|,
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

end_unit

