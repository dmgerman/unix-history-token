begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************    Copyright (c) 2001-2017, Intel Corporation   All rights reserved.    Redistribution and use in source and binary forms, with or without   modification, are permitted provided that the following conditions are met:     1. Redistributions of source code must retain the above copyright notice,       this list of conditions and the following disclaimer.     2. Redistributions in binary form must reproduce the above copyright       notice, this list of conditions and the following disclaimer in the       documentation and/or other materials provided with the distribution.     3. Neither the name of the Intel Corporation nor the names of its       contributors may be used to endorse or promote products derived from       this software without specific prior written permission.    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  ******************************************************************************/
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_include
include|#
directive|include
file|"ixgbe_x550.h"
end_include

begin_include
include|#
directive|include
file|"ixgbe_x540.h"
end_include

begin_include
include|#
directive|include
file|"ixgbe_type.h"
end_include

begin_include
include|#
directive|include
file|"ixgbe_api.h"
end_include

begin_include
include|#
directive|include
file|"ixgbe_common.h"
end_include

begin_include
include|#
directive|include
file|"ixgbe_phy.h"
end_include

begin_function_decl
specifier|static
name|s32
name|ixgbe_setup_ixfi_x550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
modifier|*
name|speed
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|ixgbe_acquire_swfw_sync_X550a
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
parameter_list|,
name|u32
name|mask
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_release_swfw_sync_X550a
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
parameter_list|,
name|u32
name|mask
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|ixgbe_read_mng_if_sel_x550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  *  ixgbe_init_ops_X550 - Inits func ptrs and MAC type  *  @hw: pointer to hardware structure  *  *  Initialize the function pointers and assign the MAC type for X550.  *  Does not touch the hardware.  **/
end_comment

begin_function
name|s32
name|ixgbe_init_ops_X550
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|ixgbe_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|struct
name|ixgbe_eeprom_info
modifier|*
name|eeprom
init|=
operator|&
name|hw
operator|->
name|eeprom
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_init_ops_X550"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|ixgbe_init_ops_X540
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|dmac_config
operator|=
name|ixgbe_dmac_config_X550
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|dmac_config_tcs
operator|=
name|ixgbe_dmac_config_tcs_X550
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|dmac_update_tcs
operator|=
name|ixgbe_dmac_update_tcs_X550
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|setup_eee
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|set_source_address_pruning
operator|=
name|ixgbe_set_source_address_pruning_X550
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|set_ethertype_anti_spoofing
operator|=
name|ixgbe_set_ethertype_anti_spoofing_X550
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_rtrup2tc
operator|=
name|ixgbe_dcb_get_rtrup2tc_generic
expr_stmt|;
name|eeprom
operator|->
name|ops
operator|.
name|init_params
operator|=
name|ixgbe_init_eeprom_params_X550
expr_stmt|;
name|eeprom
operator|->
name|ops
operator|.
name|calc_checksum
operator|=
name|ixgbe_calc_eeprom_checksum_X550
expr_stmt|;
name|eeprom
operator|->
name|ops
operator|.
name|read
operator|=
name|ixgbe_read_ee_hostif_X550
expr_stmt|;
name|eeprom
operator|->
name|ops
operator|.
name|read_buffer
operator|=
name|ixgbe_read_ee_hostif_buffer_X550
expr_stmt|;
name|eeprom
operator|->
name|ops
operator|.
name|write
operator|=
name|ixgbe_write_ee_hostif_X550
expr_stmt|;
name|eeprom
operator|->
name|ops
operator|.
name|write_buffer
operator|=
name|ixgbe_write_ee_hostif_buffer_X550
expr_stmt|;
name|eeprom
operator|->
name|ops
operator|.
name|update_checksum
operator|=
name|ixgbe_update_eeprom_checksum_X550
expr_stmt|;
name|eeprom
operator|->
name|ops
operator|.
name|validate_checksum
operator|=
name|ixgbe_validate_eeprom_checksum_X550
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|disable_mdd
operator|=
name|ixgbe_disable_mdd_X550
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|enable_mdd
operator|=
name|ixgbe_enable_mdd_X550
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|mdd_event
operator|=
name|ixgbe_mdd_event_X550
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|restore_mdd_vf
operator|=
name|ixgbe_restore_mdd_vf_X550
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|disable_rx
operator|=
name|ixgbe_disable_rx_x550
expr_stmt|;
comment|/* Manageability interface */
name|mac
operator|->
name|ops
operator|.
name|set_fw_drv_ver
operator|=
name|ixgbe_set_fw_drv_ver_x550
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|device_id
condition|)
block|{
case|case
name|IXGBE_DEV_ID_X550EM_X_10G_T
case|:
case|case
name|IXGBE_DEV_ID_X550EM_A_10G_T
case|:
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|led_on
operator|=
name|ixgbe_led_on_t_X550em
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|led_off
operator|=
name|ixgbe_led_off_t_X550em
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_read_cs4227 - Read CS4227 register  * @hw: pointer to hardware structure  * @reg: register number to write  * @value: pointer to receive value read  *  * Returns status code  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_read_cs4227
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|reg
parameter_list|,
name|u16
modifier|*
name|value
parameter_list|)
block|{
return|return
name|hw
operator|->
name|link
operator|.
name|ops
operator|.
name|read_link_unlocked
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|link
operator|.
name|addr
argument_list|,
name|reg
argument_list|,
name|value
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_write_cs4227 - Write CS4227 register  * @hw: pointer to hardware structure  * @reg: register number to write  * @value: value to write to register  *  * Returns status code  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_write_cs4227
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|reg
parameter_list|,
name|u16
name|value
parameter_list|)
block|{
return|return
name|hw
operator|->
name|link
operator|.
name|ops
operator|.
name|write_link_unlocked
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|link
operator|.
name|addr
argument_list|,
name|reg
argument_list|,
name|value
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_read_pe - Read register from port expander  * @hw: pointer to hardware structure  * @reg: register number to read  * @value: pointer to receive read value  *  * Returns status code  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_read_pe
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|reg
parameter_list|,
name|u8
modifier|*
name|value
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|status
operator|=
name|ixgbe_read_i2c_byte_unlocked
argument_list|(
name|hw
argument_list|,
name|reg
argument_list|,
name|IXGBE_PE
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
name|ERROR_REPORT2
argument_list|(
name|IXGBE_ERROR_CAUTION
argument_list|,
literal|"port expander access failed with %d\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_write_pe - Write register to port expander  * @hw: pointer to hardware structure  * @reg: register number to write  * @value: value to write  *  * Returns status code  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_write_pe
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|reg
parameter_list|,
name|u8
name|value
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|status
operator|=
name|ixgbe_write_i2c_byte_unlocked
argument_list|(
name|hw
argument_list|,
name|reg
argument_list|,
name|IXGBE_PE
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
name|ERROR_REPORT2
argument_list|(
name|IXGBE_ERROR_CAUTION
argument_list|,
literal|"port expander access failed with %d\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_reset_cs4227 - Reset CS4227 using port expander  * @hw: pointer to hardware structure  *  * This function assumes that the caller has acquired the proper semaphore.  * Returns error code  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_reset_cs4227
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|u32
name|retry
decl_stmt|;
name|u16
name|value
decl_stmt|;
name|u8
name|reg
decl_stmt|;
comment|/* Trigger hard reset. */
name|status
operator|=
name|ixgbe_read_pe
argument_list|(
name|hw
argument_list|,
name|IXGBE_PE_OUTPUT
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|reg
operator||=
name|IXGBE_PE_BIT1
expr_stmt|;
name|status
operator|=
name|ixgbe_write_pe
argument_list|(
name|hw
argument_list|,
name|IXGBE_PE_OUTPUT
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|status
operator|=
name|ixgbe_read_pe
argument_list|(
name|hw
argument_list|,
name|IXGBE_PE_CONFIG
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|reg
operator|&=
operator|~
name|IXGBE_PE_BIT1
expr_stmt|;
name|status
operator|=
name|ixgbe_write_pe
argument_list|(
name|hw
argument_list|,
name|IXGBE_PE_CONFIG
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|status
operator|=
name|ixgbe_read_pe
argument_list|(
name|hw
argument_list|,
name|IXGBE_PE_OUTPUT
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|reg
operator|&=
operator|~
name|IXGBE_PE_BIT1
expr_stmt|;
name|status
operator|=
name|ixgbe_write_pe
argument_list|(
name|hw
argument_list|,
name|IXGBE_PE_OUTPUT
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|usec_delay
argument_list|(
name|IXGBE_CS4227_RESET_HOLD
argument_list|)
expr_stmt|;
name|status
operator|=
name|ixgbe_read_pe
argument_list|(
name|hw
argument_list|,
name|IXGBE_PE_OUTPUT
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|reg
operator||=
name|IXGBE_PE_BIT1
expr_stmt|;
name|status
operator|=
name|ixgbe_write_pe
argument_list|(
name|hw
argument_list|,
name|IXGBE_PE_OUTPUT
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* Wait for the reset to complete. */
name|msec_delay
argument_list|(
name|IXGBE_CS4227_RESET_DELAY
argument_list|)
expr_stmt|;
for|for
control|(
name|retry
operator|=
literal|0
init|;
name|retry
operator|<
name|IXGBE_CS4227_RETRIES
condition|;
name|retry
operator|++
control|)
block|{
name|status
operator|=
name|ixgbe_read_cs4227
argument_list|(
name|hw
argument_list|,
name|IXGBE_CS4227_EFUSE_STATUS
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
operator|&&
name|value
operator|==
name|IXGBE_CS4227_EEPROM_LOAD_OK
condition|)
break|break;
name|msec_delay
argument_list|(
name|IXGBE_CS4227_CHECK_DELAY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|retry
operator|==
name|IXGBE_CS4227_RETRIES
condition|)
block|{
name|ERROR_REPORT1
argument_list|(
name|IXGBE_ERROR_INVALID_STATE
argument_list|,
literal|"CS4227 reset did not complete."
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_PHY
return|;
block|}
name|status
operator|=
name|ixgbe_read_cs4227
argument_list|(
name|hw
argument_list|,
name|IXGBE_CS4227_EEPROM_STATUS
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
operator|||
operator|!
operator|(
name|value
operator|&
name|IXGBE_CS4227_EEPROM_LOAD_OK
operator|)
condition|)
block|{
name|ERROR_REPORT1
argument_list|(
name|IXGBE_ERROR_INVALID_STATE
argument_list|,
literal|"CS4227 EEPROM did not load successfully."
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_PHY
return|;
block|}
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_check_cs4227 - Check CS4227 and reset as needed  * @hw: pointer to hardware structure  **/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_check_cs4227
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u32
name|swfw_mask
init|=
name|hw
operator|->
name|phy
operator|.
name|phy_semaphore_mask
decl_stmt|;
name|u16
name|value
init|=
literal|0
decl_stmt|;
name|u8
name|retry
decl_stmt|;
for|for
control|(
name|retry
operator|=
literal|0
init|;
name|retry
operator|<
name|IXGBE_CS4227_RETRIES
condition|;
name|retry
operator|++
control|)
block|{
name|status
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|acquire_swfw_sync
argument_list|(
name|hw
argument_list|,
name|swfw_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
block|{
name|ERROR_REPORT2
argument_list|(
name|IXGBE_ERROR_CAUTION
argument_list|,
literal|"semaphore failed with %d"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
name|IXGBE_CS4227_CHECK_DELAY
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Get status of reset flow. */
name|status
operator|=
name|ixgbe_read_cs4227
argument_list|(
name|hw
argument_list|,
name|IXGBE_CS4227_SCRATCH
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
operator|&&
name|value
operator|==
name|IXGBE_CS4227_RESET_COMPLETE
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
operator|||
name|value
operator|!=
name|IXGBE_CS4227_RESET_PENDING
condition|)
break|break;
comment|/* Reset is pending. Wait and check again. */
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|swfw_mask
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
name|IXGBE_CS4227_CHECK_DELAY
argument_list|)
expr_stmt|;
block|}
comment|/* If still pending, assume other instance failed. */
if|if
condition|(
name|retry
operator|==
name|IXGBE_CS4227_RETRIES
condition|)
block|{
name|status
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|acquire_swfw_sync
argument_list|(
name|hw
argument_list|,
name|swfw_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
block|{
name|ERROR_REPORT2
argument_list|(
name|IXGBE_ERROR_CAUTION
argument_list|,
literal|"semaphore failed with %d"
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Reset the CS4227. */
name|status
operator|=
name|ixgbe_reset_cs4227
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
block|{
name|ERROR_REPORT2
argument_list|(
name|IXGBE_ERROR_INVALID_STATE
argument_list|,
literal|"CS4227 reset failed: %d"
argument_list|,
name|status
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Reset takes so long, temporarily release semaphore in case the 	 * other driver instance is waiting for the reset indication. 	 */
name|ixgbe_write_cs4227
argument_list|(
name|hw
argument_list|,
name|IXGBE_CS4227_SCRATCH
argument_list|,
name|IXGBE_CS4227_RESET_PENDING
argument_list|)
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|swfw_mask
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|status
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|acquire_swfw_sync
argument_list|(
name|hw
argument_list|,
name|swfw_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
block|{
name|ERROR_REPORT2
argument_list|(
name|IXGBE_ERROR_CAUTION
argument_list|,
literal|"semaphore failed with %d"
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Record completion for next time. */
name|status
operator|=
name|ixgbe_write_cs4227
argument_list|(
name|hw
argument_list|,
name|IXGBE_CS4227_SCRATCH
argument_list|,
name|IXGBE_CS4227_RESET_COMPLETE
argument_list|)
expr_stmt|;
name|out
label|:
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|swfw_mask
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
name|hw
operator|->
name|eeprom
operator|.
name|semaphore_delay
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_setup_mux_ctl - Setup ESDP register for I2C mux control  * @hw: pointer to hardware structure  **/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_setup_mux_ctl
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|esdp
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|)
decl_stmt|;
if|if
condition|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
condition|)
block|{
name|esdp
operator|&=
operator|~
operator|(
name|IXGBE_ESDP_SDP1_NATIVE
operator||
name|IXGBE_ESDP_SDP1
operator|)
expr_stmt|;
name|esdp
operator||=
name|IXGBE_ESDP_SDP1_DIR
expr_stmt|;
block|}
name|esdp
operator|&=
operator|~
operator|(
name|IXGBE_ESDP_SDP0_NATIVE
operator||
name|IXGBE_ESDP_SDP0_DIR
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|,
name|esdp
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_read_phy_reg_mdi_22 - Read from a clause 22 PHY register without lock  * @hw: pointer to hardware structure  * @reg_addr: 32 bit address of PHY register to read  * @dev_type: always unused  * @phy_data: Pointer to read data from PHY register  */
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_read_phy_reg_mdi_22
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|reg_addr
parameter_list|,
name|u32
name|dev_type
parameter_list|,
name|u16
modifier|*
name|phy_data
parameter_list|)
block|{
name|u32
name|i
decl_stmt|,
name|data
decl_stmt|,
name|command
decl_stmt|;
name|UNREFERENCED_1PARAMETER
argument_list|(
name|dev_type
argument_list|)
expr_stmt|;
comment|/* Setup and write the read command */
name|command
operator|=
operator|(
name|reg_addr
operator|<<
name|IXGBE_MSCA_DEV_TYPE_SHIFT
operator|)
operator||
operator|(
name|hw
operator|->
name|phy
operator|.
name|addr
operator|<<
name|IXGBE_MSCA_PHY_ADDR_SHIFT
operator|)
operator||
name|IXGBE_MSCA_OLD_PROTOCOL
operator||
name|IXGBE_MSCA_READ_AUTOINC
operator||
name|IXGBE_MSCA_MDI_COMMAND
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MSCA
argument_list|,
name|command
argument_list|)
expr_stmt|;
comment|/* Check every 10 usec to see if the access completed. 	 * The MDI Command bit will clear when the operation is 	 * complete 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_MDIO_COMMAND_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|command
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MSCA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|command
operator|&
name|IXGBE_MSCA_MDI_COMMAND
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|command
operator|&
name|IXGBE_MSCA_MDI_COMMAND
condition|)
block|{
name|ERROR_REPORT1
argument_list|(
name|IXGBE_ERROR_POLLING
argument_list|,
literal|"PHY read command did not complete.\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_PHY
return|;
block|}
comment|/* Read operation is complete.  Get the data from MSRWD */
name|data
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MSRWD
argument_list|)
expr_stmt|;
name|data
operator|>>=
name|IXGBE_MSRWD_READ_DATA_SHIFT
expr_stmt|;
operator|*
name|phy_data
operator|=
operator|(
name|u16
operator|)
name|data
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_write_phy_reg_mdi_22 - Write to a clause 22 PHY register without lock  * @hw: pointer to hardware structure  * @reg_addr: 32 bit PHY register to write  * @dev_type: always unused  * @phy_data: Data to write to the PHY register  */
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_write_phy_reg_mdi_22
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|reg_addr
parameter_list|,
name|u32
name|dev_type
parameter_list|,
name|u16
name|phy_data
parameter_list|)
block|{
name|u32
name|i
decl_stmt|,
name|command
decl_stmt|;
name|UNREFERENCED_1PARAMETER
argument_list|(
name|dev_type
argument_list|)
expr_stmt|;
comment|/* Put the data in the MDI single read and write data register*/
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MSRWD
argument_list|,
operator|(
name|u32
operator|)
name|phy_data
argument_list|)
expr_stmt|;
comment|/* Setup and write the write command */
name|command
operator|=
operator|(
name|reg_addr
operator|<<
name|IXGBE_MSCA_DEV_TYPE_SHIFT
operator|)
operator||
operator|(
name|hw
operator|->
name|phy
operator|.
name|addr
operator|<<
name|IXGBE_MSCA_PHY_ADDR_SHIFT
operator|)
operator||
name|IXGBE_MSCA_OLD_PROTOCOL
operator||
name|IXGBE_MSCA_WRITE
operator||
name|IXGBE_MSCA_MDI_COMMAND
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MSCA
argument_list|,
name|command
argument_list|)
expr_stmt|;
comment|/* Check every 10 usec to see if the access completed. 	 * The MDI Command bit will clear when the operation is 	 * complete 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_MDIO_COMMAND_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|command
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MSCA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|command
operator|&
name|IXGBE_MSCA_MDI_COMMAND
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|command
operator|&
name|IXGBE_MSCA_MDI_COMMAND
condition|)
block|{
name|ERROR_REPORT1
argument_list|(
name|IXGBE_ERROR_POLLING
argument_list|,
literal|"PHY write cmd didn't complete\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_PHY
return|;
block|}
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_identify_phy_x550em - Get PHY type based on device id  * @hw: pointer to hardware structure  *  * Returns error code  */
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_identify_phy_x550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|set_lan_id
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|ixgbe_read_mng_if_sel_x550em
argument_list|(
name|hw
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|device_id
condition|)
block|{
case|case
name|IXGBE_DEV_ID_X550EM_A_SFP
case|:
return|return
name|ixgbe_identify_module_generic
argument_list|(
name|hw
argument_list|)
return|;
case|case
name|IXGBE_DEV_ID_X550EM_X_SFP
case|:
comment|/* set up for CS4227 usage */
name|ixgbe_setup_mux_ctl
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|ixgbe_check_cs4227
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Fallthrough */
case|case
name|IXGBE_DEV_ID_X550EM_A_SFP_N
case|:
return|return
name|ixgbe_identify_module_generic
argument_list|(
name|hw
argument_list|)
return|;
break|break;
case|case
name|IXGBE_DEV_ID_X550EM_X_KX4
case|:
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|ixgbe_phy_x550em_kx4
expr_stmt|;
break|break;
case|case
name|IXGBE_DEV_ID_X550EM_X_XFI
case|:
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|ixgbe_phy_x550em_xfi
expr_stmt|;
break|break;
case|case
name|IXGBE_DEV_ID_X550EM_X_KR
case|:
case|case
name|IXGBE_DEV_ID_X550EM_A_KR
case|:
case|case
name|IXGBE_DEV_ID_X550EM_A_KR_L
case|:
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|ixgbe_phy_x550em_kr
expr_stmt|;
break|break;
case|case
name|IXGBE_DEV_ID_X550EM_A_10G_T
case|:
case|case
name|IXGBE_DEV_ID_X550EM_X_1G_T
case|:
case|case
name|IXGBE_DEV_ID_X550EM_X_10G_T
case|:
return|return
name|ixgbe_identify_phy_generic
argument_list|(
name|hw
argument_list|)
return|;
case|case
name|IXGBE_DEV_ID_X550EM_A_1G_T
case|:
case|case
name|IXGBE_DEV_ID_X550EM_A_1G_T_L
case|:
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|ixgbe_phy_fw
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
operator|=
name|NULL
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
condition|)
name|hw
operator|->
name|phy
operator|.
name|phy_semaphore_mask
operator||=
name|IXGBE_GSSR_PHY1_SM
expr_stmt|;
else|else
name|hw
operator|->
name|phy
operator|.
name|phy_semaphore_mask
operator||=
name|IXGBE_GSSR_PHY0_SM
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_fw_phy_activity - Perform an activity on a PHY  * @hw: pointer to hardware structure  * @activity: activity to perform  * @data: Pointer to 4 32-bit words of data  */
end_comment

begin_decl_stmt
name|s32
name|ixgbe_fw_phy_activity
argument_list|(
expr|struct
name|ixgbe_hw
operator|*
name|hw
argument_list|,
name|u16
name|activity
argument_list|,
name|u32
argument_list|(
operator|*
name|data
argument_list|)
index|[
name|FW_PHY_ACT_DATA_COUNT
index|]
argument_list|)
block|{
union|union
block|{
name|struct
name|ixgbe_hic_phy_activity_req
name|cmd
decl_stmt|;
name|struct
name|ixgbe_hic_phy_activity_resp
name|rsp
decl_stmt|;
block|}
name|hic
union|;
name|u16
name|retries
init|=
name|FW_PHY_ACT_RETRIES
decl_stmt|;
name|s32
name|rc
decl_stmt|;
name|u16
name|i
decl_stmt|;
do|do
block|{
name|memset
argument_list|(
operator|&
name|hic
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hic
argument_list|)
argument_list|)
expr_stmt|;
name|hic
operator|.
name|cmd
operator|.
name|hdr
operator|.
name|cmd
operator|=
name|FW_PHY_ACT_REQ_CMD
expr_stmt|;
name|hic
operator|.
name|cmd
operator|.
name|hdr
operator|.
name|buf_len
operator|=
name|FW_PHY_ACT_REQ_LEN
expr_stmt|;
name|hic
operator|.
name|cmd
operator|.
name|hdr
operator|.
name|checksum
operator|=
name|FW_DEFAULT_CHECKSUM
expr_stmt|;
name|hic
operator|.
name|cmd
operator|.
name|port_number
operator|=
name|hw
operator|->
name|bus
operator|.
name|lan_id
expr_stmt|;
name|hic
operator|.
name|cmd
operator|.
name|activity_id
operator|=
name|IXGBE_CPU_TO_LE16
argument_list|(
name|activity
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FW_PHY_ACT_DATA_COUNT
condition|;
operator|++
name|i
control|)
name|hic
operator|.
name|cmd
operator|.
name|data
index|[
name|i
index|]
operator|=
name|IXGBE_CPU_TO_BE32
argument_list|(
operator|(
operator|*
name|data
operator|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ixgbe_host_interface_command
argument_list|(
name|hw
argument_list|,
operator|(
name|u32
operator|*
operator|)
operator|&
name|hic
operator|.
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|hic
operator|.
name|cmd
argument_list|)
argument_list|,
name|IXGBE_HI_COMMAND_TIMEOUT
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|rc
return|;
if|if
condition|(
name|hic
operator|.
name|rsp
operator|.
name|hdr
operator|.
name|cmd_or_resp
operator|.
name|ret_status
operator|==
name|FW_CEM_RESP_STATUS_SUCCESS
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FW_PHY_ACT_DATA_COUNT
condition|;
operator|++
name|i
control|)
operator|(
operator|*
name|data
operator|)
index|[
name|i
index|]
operator|=
name|IXGBE_BE32_TO_CPU
argument_list|(
name|hic
operator|.
name|rsp
operator|.
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
name|usec_delay
argument_list|(
literal|20
argument_list|)
expr_stmt|;
operator|--
name|retries
expr_stmt|;
block|}
do|while
condition|(
name|retries
operator|>
literal|0
condition|)
do|;
return|return
name|IXGBE_ERR_HOST_INTERFACE_COMMAND
return|;
block|}
end_decl_stmt

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|u16
name|fw_speed
decl_stmt|;
name|ixgbe_link_speed
name|phy_speed
decl_stmt|;
block|}
name|ixgbe_fw_map
index|[]
init|=
block|{
block|{
name|FW_PHY_ACT_LINK_SPEED_10
block|,
name|IXGBE_LINK_SPEED_10_FULL
block|}
block|,
block|{
name|FW_PHY_ACT_LINK_SPEED_100
block|,
name|IXGBE_LINK_SPEED_100_FULL
block|}
block|,
block|{
name|FW_PHY_ACT_LINK_SPEED_1G
block|,
name|IXGBE_LINK_SPEED_1GB_FULL
block|}
block|,
block|{
name|FW_PHY_ACT_LINK_SPEED_2_5G
block|,
name|IXGBE_LINK_SPEED_2_5GB_FULL
block|}
block|,
block|{
name|FW_PHY_ACT_LINK_SPEED_5G
block|,
name|IXGBE_LINK_SPEED_5GB_FULL
block|}
block|,
block|{
name|FW_PHY_ACT_LINK_SPEED_10G
block|,
name|IXGBE_LINK_SPEED_10GB_FULL
block|}
block|, }
struct|;
end_struct

begin_comment
comment|/**  * ixgbe_get_phy_id_fw - Get the phy ID via firmware command  * @hw: pointer to hardware structure  *  * Returns error code  */
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_get_phy_id_fw
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|info
index|[
name|FW_PHY_ACT_DATA_COUNT
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|u16
name|phy_speeds
decl_stmt|;
name|u16
name|phy_id_lo
decl_stmt|;
name|s32
name|rc
decl_stmt|;
name|u16
name|i
decl_stmt|;
name|rc
operator|=
name|ixgbe_fw_phy_activity
argument_list|(
name|hw
argument_list|,
name|FW_PHY_ACT_GET_PHY_INFO
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
name|rc
return|;
name|hw
operator|->
name|phy
operator|.
name|speeds_supported
operator|=
literal|0
expr_stmt|;
name|phy_speeds
operator|=
name|info
index|[
literal|0
index|]
operator|&
name|FW_PHY_INFO_SPEED_MASK
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|ixgbe_fw_map
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ixgbe_fw_map
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|phy_speeds
operator|&
name|ixgbe_fw_map
index|[
name|i
index|]
operator|.
name|fw_speed
condition|)
name|hw
operator|->
name|phy
operator|.
name|speeds_supported
operator||=
name|ixgbe_fw_map
index|[
name|i
index|]
operator|.
name|phy_speed
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
condition|)
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator|=
name|hw
operator|->
name|phy
operator|.
name|speeds_supported
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|id
operator|=
name|info
index|[
literal|0
index|]
operator|&
name|FW_PHY_INFO_ID_HI_MASK
expr_stmt|;
name|phy_id_lo
operator|=
name|info
index|[
literal|1
index|]
operator|&
name|FW_PHY_INFO_ID_LO_MASK
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|id
operator||=
name|phy_id_lo
operator|&
name|IXGBE_PHY_REVISION_MASK
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|revision
operator|=
name|phy_id_lo
operator|&
operator|~
name|IXGBE_PHY_REVISION_MASK
expr_stmt|;
if|if
condition|(
operator|!
name|hw
operator|->
name|phy
operator|.
name|id
operator|||
name|hw
operator|->
name|phy
operator|.
name|id
operator|==
name|IXGBE_PHY_REVISION_MASK
condition|)
return|return
name|IXGBE_ERR_PHY_ADDR_INVALID
return|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_identify_phy_fw - Get PHY type based on firmware command  * @hw: pointer to hardware structure  *  * Returns error code  */
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_identify_phy_fw
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
if|if
condition|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
condition|)
name|hw
operator|->
name|phy
operator|.
name|phy_semaphore_mask
operator|=
name|IXGBE_GSSR_PHY1_SM
expr_stmt|;
else|else
name|hw
operator|->
name|phy
operator|.
name|phy_semaphore_mask
operator|=
name|IXGBE_GSSR_PHY0_SM
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|ixgbe_phy_fw
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
operator|=
name|NULL
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
operator|=
name|NULL
expr_stmt|;
return|return
name|ixgbe_get_phy_id_fw
argument_list|(
name|hw
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_shutdown_fw_phy - Shutdown a firmware-controlled PHY  * @hw: pointer to hardware structure  *  * Returns error code  */
end_comment

begin_function
name|s32
name|ixgbe_shutdown_fw_phy
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|setup
index|[
name|FW_PHY_ACT_DATA_COUNT
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|setup
index|[
literal|0
index|]
operator|=
name|FW_PHY_ACT_FORCE_LINK_DOWN_OFF
expr_stmt|;
return|return
name|ixgbe_fw_phy_activity
argument_list|(
name|hw
argument_list|,
name|FW_PHY_ACT_FORCE_LINK_DOWN
argument_list|,
operator|&
name|setup
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|s32
name|ixgbe_read_phy_reg_x550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|reg_addr
parameter_list|,
name|u32
name|device_type
parameter_list|,
name|u16
modifier|*
name|phy_data
parameter_list|)
block|{
name|UNREFERENCED_4PARAMETER
argument_list|(
operator|*
name|hw
argument_list|,
name|reg_addr
argument_list|,
name|device_type
argument_list|,
operator|*
name|phy_data
argument_list|)
expr_stmt|;
return|return
name|IXGBE_NOT_IMPLEMENTED
return|;
block|}
end_function

begin_function
specifier|static
name|s32
name|ixgbe_write_phy_reg_x550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|reg_addr
parameter_list|,
name|u32
name|device_type
parameter_list|,
name|u16
name|phy_data
parameter_list|)
block|{
name|UNREFERENCED_4PARAMETER
argument_list|(
operator|*
name|hw
argument_list|,
name|reg_addr
argument_list|,
name|device_type
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
return|return
name|IXGBE_NOT_IMPLEMENTED
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_read_i2c_combined_generic - Perform I2C read combined operation  * @hw: pointer to the hardware structure  * @addr: I2C bus address to read from  * @reg: I2C device register to read from  * @val: pointer to location to receive read value  *  * Returns an error code on error.  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_read_i2c_combined_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|addr
parameter_list|,
name|u16
name|reg
parameter_list|,
name|u16
modifier|*
name|val
parameter_list|)
block|{
return|return
name|ixgbe_read_i2c_combined_generic_int
argument_list|(
name|hw
argument_list|,
name|addr
argument_list|,
name|reg
argument_list|,
name|val
argument_list|,
name|TRUE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_read_i2c_combined_generic_unlocked - Do I2C read combined operation  * @hw: pointer to the hardware structure  * @addr: I2C bus address to read from  * @reg: I2C device register to read from  * @val: pointer to location to receive read value  *  * Returns an error code on error.  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_read_i2c_combined_generic_unlocked
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|addr
parameter_list|,
name|u16
name|reg
parameter_list|,
name|u16
modifier|*
name|val
parameter_list|)
block|{
return|return
name|ixgbe_read_i2c_combined_generic_int
argument_list|(
name|hw
argument_list|,
name|addr
argument_list|,
name|reg
argument_list|,
name|val
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_write_i2c_combined_generic - Perform I2C write combined operation  * @hw: pointer to the hardware structure  * @addr: I2C bus address to write to  * @reg: I2C device register to write to  * @val: value to write  *  * Returns an error code on error.  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_write_i2c_combined_generic
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|addr
parameter_list|,
name|u16
name|reg
parameter_list|,
name|u16
name|val
parameter_list|)
block|{
return|return
name|ixgbe_write_i2c_combined_generic_int
argument_list|(
name|hw
argument_list|,
name|addr
argument_list|,
name|reg
argument_list|,
name|val
argument_list|,
name|TRUE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_write_i2c_combined_generic_unlocked - Do I2C write combined operation  * @hw: pointer to the hardware structure  * @addr: I2C bus address to write to  * @reg: I2C device register to write to  * @val: value to write  *  * Returns an error code on error.  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_write_i2c_combined_generic_unlocked
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|addr
parameter_list|,
name|u16
name|reg
parameter_list|,
name|u16
name|val
parameter_list|)
block|{
return|return
name|ixgbe_write_i2c_combined_generic_int
argument_list|(
name|hw
argument_list|,
name|addr
argument_list|,
name|reg
argument_list|,
name|val
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** *  ixgbe_init_ops_X550EM - Inits func ptrs and MAC type *  @hw: pointer to hardware structure * *  Initialize the function pointers and for MAC type X550EM. *  Does not touch the hardware. **/
end_comment

begin_function
name|s32
name|ixgbe_init_ops_X550EM
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|ixgbe_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|struct
name|ixgbe_eeprom_info
modifier|*
name|eeprom
init|=
operator|&
name|hw
operator|->
name|eeprom
decl_stmt|;
name|struct
name|ixgbe_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_init_ops_X550EM"
argument_list|)
expr_stmt|;
comment|/* Similar to X550 so start there. */
name|ret_val
operator|=
name|ixgbe_init_ops_X550
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Since this function eventually calls 	 * ixgbe_init_ops_540 by design, we are setting 	 * the pointers to NULL explicitly here to overwrite 	 * the values being set in the x540 function. 	 */
comment|/* Bypass not supported in x550EM */
name|mac
operator|->
name|ops
operator|.
name|bypass_rw
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|bypass_valid_rd
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|bypass_set
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|bypass_rd_eep
operator|=
name|NULL
expr_stmt|;
comment|/* FCOE not supported in x550EM */
name|mac
operator|->
name|ops
operator|.
name|get_san_mac_addr
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|set_san_mac_addr
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_wwn_prefix
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_fcoe_boot_status
operator|=
name|NULL
expr_stmt|;
comment|/* IPsec not supported in x550EM */
name|mac
operator|->
name|ops
operator|.
name|disable_sec_rx_path
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|enable_sec_rx_path
operator|=
name|NULL
expr_stmt|;
comment|/* AUTOC register is not present in x550EM. */
name|mac
operator|->
name|ops
operator|.
name|prot_autoc_read
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|prot_autoc_write
operator|=
name|NULL
expr_stmt|;
comment|/* X550EM bus type is internal*/
name|hw
operator|->
name|bus
operator|.
name|type
operator|=
name|ixgbe_bus_type_internal
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_bus_info
operator|=
name|ixgbe_get_bus_info_X550em
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_media_type
operator|=
name|ixgbe_get_media_type_X550em
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|setup_sfp
operator|=
name|ixgbe_setup_sfp_modules_X550em
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_link_capabilities
operator|=
name|ixgbe_get_link_capabilities_X550em
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|reset_hw
operator|=
name|ixgbe_reset_hw_X550em
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_supported_physical_layer
operator|=
name|ixgbe_get_supported_physical_layer_X550em
expr_stmt|;
if|if
condition|(
name|mac
operator|->
name|ops
operator|.
name|get_media_type
argument_list|(
name|hw
argument_list|)
operator|==
name|ixgbe_media_type_copper
condition|)
name|mac
operator|->
name|ops
operator|.
name|setup_fc
operator|=
name|ixgbe_setup_fc_generic
expr_stmt|;
else|else
name|mac
operator|->
name|ops
operator|.
name|setup_fc
operator|=
name|ixgbe_setup_fc_X550em
expr_stmt|;
comment|/* PHY */
name|phy
operator|->
name|ops
operator|.
name|init
operator|=
name|ixgbe_init_phy_ops_X550em
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|device_id
condition|)
block|{
case|case
name|IXGBE_DEV_ID_X550EM_A_1G_T
case|:
case|case
name|IXGBE_DEV_ID_X550EM_A_1G_T_L
case|:
name|mac
operator|->
name|ops
operator|.
name|setup_fc
operator|=
name|NULL
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|identify
operator|=
name|ixgbe_identify_phy_fw
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|set_phy_power
operator|=
name|NULL
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|get_firmware_version
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
name|phy
operator|->
name|ops
operator|.
name|identify
operator|=
name|ixgbe_identify_phy_x550em
expr_stmt|;
block|}
if|if
condition|(
name|mac
operator|->
name|ops
operator|.
name|get_media_type
argument_list|(
name|hw
argument_list|)
operator|!=
name|ixgbe_media_type_copper
condition|)
name|phy
operator|->
name|ops
operator|.
name|set_phy_power
operator|=
name|NULL
expr_stmt|;
comment|/* EEPROM */
name|eeprom
operator|->
name|ops
operator|.
name|init_params
operator|=
name|ixgbe_init_eeprom_params_X540
expr_stmt|;
name|eeprom
operator|->
name|ops
operator|.
name|read
operator|=
name|ixgbe_read_ee_hostif_X550
expr_stmt|;
name|eeprom
operator|->
name|ops
operator|.
name|read_buffer
operator|=
name|ixgbe_read_ee_hostif_buffer_X550
expr_stmt|;
name|eeprom
operator|->
name|ops
operator|.
name|write
operator|=
name|ixgbe_write_ee_hostif_X550
expr_stmt|;
name|eeprom
operator|->
name|ops
operator|.
name|write_buffer
operator|=
name|ixgbe_write_ee_hostif_buffer_X550
expr_stmt|;
name|eeprom
operator|->
name|ops
operator|.
name|update_checksum
operator|=
name|ixgbe_update_eeprom_checksum_X550
expr_stmt|;
name|eeprom
operator|->
name|ops
operator|.
name|validate_checksum
operator|=
name|ixgbe_validate_eeprom_checksum_X550
expr_stmt|;
name|eeprom
operator|->
name|ops
operator|.
name|calc_checksum
operator|=
name|ixgbe_calc_eeprom_checksum_X550
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_setup_fw_link - Setup firmware-controlled PHYs  * @hw: pointer to hardware structure  */
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_setup_fw_link
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|setup
index|[
name|FW_PHY_ACT_DATA_COUNT
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|s32
name|rc
decl_stmt|;
name|u16
name|i
decl_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|reset_disable
operator|||
name|ixgbe_check_reset_blocked
argument_list|(
name|hw
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|hw
operator|->
name|fc
operator|.
name|strict_ieee
operator|&&
name|hw
operator|->
name|fc
operator|.
name|requested_mode
operator|==
name|ixgbe_fc_rx_pause
condition|)
block|{
name|ERROR_REPORT1
argument_list|(
name|IXGBE_ERROR_UNSUPPORTED
argument_list|,
literal|"ixgbe_fc_rx_pause not valid in strict IEEE mode\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_INVALID_LINK_SETTINGS
return|;
block|}
switch|switch
condition|(
name|hw
operator|->
name|fc
operator|.
name|requested_mode
condition|)
block|{
case|case
name|ixgbe_fc_full
case|:
name|setup
index|[
literal|0
index|]
operator||=
name|FW_PHY_ACT_SETUP_LINK_PAUSE_RXTX
operator|<<
name|FW_PHY_ACT_SETUP_LINK_PAUSE_SHIFT
expr_stmt|;
break|break;
case|case
name|ixgbe_fc_rx_pause
case|:
name|setup
index|[
literal|0
index|]
operator||=
name|FW_PHY_ACT_SETUP_LINK_PAUSE_RX
operator|<<
name|FW_PHY_ACT_SETUP_LINK_PAUSE_SHIFT
expr_stmt|;
break|break;
case|case
name|ixgbe_fc_tx_pause
case|:
name|setup
index|[
literal|0
index|]
operator||=
name|FW_PHY_ACT_SETUP_LINK_PAUSE_TX
operator|<<
name|FW_PHY_ACT_SETUP_LINK_PAUSE_SHIFT
expr_stmt|;
break|break;
default|default:
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|ixgbe_fw_map
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ixgbe_fw_map
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator|&
name|ixgbe_fw_map
index|[
name|i
index|]
operator|.
name|phy_speed
condition|)
name|setup
index|[
literal|0
index|]
operator||=
name|ixgbe_fw_map
index|[
name|i
index|]
operator|.
name|fw_speed
expr_stmt|;
block|}
name|setup
index|[
literal|0
index|]
operator||=
name|FW_PHY_ACT_SETUP_LINK_HP
operator||
name|FW_PHY_ACT_SETUP_LINK_AN
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|eee_speeds_advertised
condition|)
name|setup
index|[
literal|0
index|]
operator||=
name|FW_PHY_ACT_SETUP_LINK_EEE
expr_stmt|;
name|rc
operator|=
name|ixgbe_fw_phy_activity
argument_list|(
name|hw
argument_list|,
name|FW_PHY_ACT_SETUP_LINK
argument_list|,
operator|&
name|setup
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
name|rc
return|;
if|if
condition|(
name|setup
index|[
literal|0
index|]
operator|==
name|FW_PHY_ACT_SETUP_LINK_RSP_DOWN
condition|)
return|return
name|IXGBE_ERR_OVERTEMP
return|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_fc_autoneg_fw _ Set up flow control for FW-controlled PHYs  * @hw: pointer to hardware structure  *  *  Called at init time to set up flow control.  */
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_fc_autoneg_fw
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
if|if
condition|(
name|hw
operator|->
name|fc
operator|.
name|requested_mode
operator|==
name|ixgbe_fc_default
condition|)
name|hw
operator|->
name|fc
operator|.
name|requested_mode
operator|=
name|ixgbe_fc_full
expr_stmt|;
return|return
name|ixgbe_setup_fw_link
argument_list|(
name|hw
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_setup_eee_fw - Enable/disable EEE support  * @hw: pointer to the HW structure  * @enable_eee: boolean flag to enable EEE  *  * Enable/disable EEE based on enable_eee flag.  * This function controls EEE for firmware-based PHY implementations.  */
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_setup_eee_fw
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|enable_eee
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|!
name|hw
operator|->
name|phy
operator|.
name|eee_speeds_advertised
operator|==
name|enable_eee
condition|)
return|return
name|IXGBE_SUCCESS
return|;
if|if
condition|(
name|enable_eee
condition|)
name|hw
operator|->
name|phy
operator|.
name|eee_speeds_advertised
operator|=
name|hw
operator|->
name|phy
operator|.
name|eee_speeds_supported
expr_stmt|;
else|else
name|hw
operator|->
name|phy
operator|.
name|eee_speeds_advertised
operator|=
literal|0
expr_stmt|;
return|return
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|setup_link
argument_list|(
name|hw
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** *  ixgbe_init_ops_X550EM_a - Inits func ptrs and MAC type *  @hw: pointer to hardware structure * *  Initialize the function pointers and for MAC type X550EM_a. *  Does not touch the hardware. **/
end_comment

begin_function
name|s32
name|ixgbe_init_ops_X550EM_a
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|ixgbe_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_init_ops_X550EM_a"
argument_list|)
expr_stmt|;
comment|/* Start with generic X550EM init */
name|ret_val
operator|=
name|ixgbe_init_ops_X550EM
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|device_id
operator|==
name|IXGBE_DEV_ID_X550EM_A_SGMII
operator|||
name|hw
operator|->
name|device_id
operator|==
name|IXGBE_DEV_ID_X550EM_A_SGMII_L
condition|)
block|{
name|mac
operator|->
name|ops
operator|.
name|read_iosf_sb_reg
operator|=
name|ixgbe_read_iosf_sb_reg_x550
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|write_iosf_sb_reg
operator|=
name|ixgbe_write_iosf_sb_reg_x550
expr_stmt|;
block|}
else|else
block|{
name|mac
operator|->
name|ops
operator|.
name|read_iosf_sb_reg
operator|=
name|ixgbe_read_iosf_sb_reg_x550a
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|write_iosf_sb_reg
operator|=
name|ixgbe_write_iosf_sb_reg_x550a
expr_stmt|;
block|}
name|mac
operator|->
name|ops
operator|.
name|acquire_swfw_sync
operator|=
name|ixgbe_acquire_swfw_sync_X550a
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|release_swfw_sync
operator|=
name|ixgbe_release_swfw_sync_X550a
expr_stmt|;
switch|switch
condition|(
name|mac
operator|->
name|ops
operator|.
name|get_media_type
argument_list|(
name|hw
argument_list|)
condition|)
block|{
case|case
name|ixgbe_media_type_fiber
case|:
name|mac
operator|->
name|ops
operator|.
name|setup_fc
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|fc_autoneg
operator|=
name|ixgbe_fc_autoneg_fiber_x550em_a
expr_stmt|;
break|break;
case|case
name|ixgbe_media_type_backplane
case|:
name|mac
operator|->
name|ops
operator|.
name|fc_autoneg
operator|=
name|ixgbe_fc_autoneg_backplane_x550em_a
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|setup_fc
operator|=
name|ixgbe_setup_fc_backplane_x550em_a
expr_stmt|;
break|break;
default|default:
break|break;
block|}
switch|switch
condition|(
name|hw
operator|->
name|device_id
condition|)
block|{
case|case
name|IXGBE_DEV_ID_X550EM_A_1G_T
case|:
case|case
name|IXGBE_DEV_ID_X550EM_A_1G_T_L
case|:
name|mac
operator|->
name|ops
operator|.
name|fc_autoneg
operator|=
name|ixgbe_fc_autoneg_sgmii_x550em_a
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|setup_fc
operator|=
name|ixgbe_fc_autoneg_fw
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|setup_eee
operator|=
name|ixgbe_setup_eee_fw
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|eee_speeds_supported
operator|=
name|IXGBE_LINK_SPEED_100_FULL
operator||
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|eee_speeds_advertised
operator|=
name|hw
operator|->
name|phy
operator|.
name|eee_speeds_supported
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/** *  ixgbe_init_ops_X550EM_x - Inits func ptrs and MAC type *  @hw: pointer to hardware structure * *  Initialize the function pointers and for MAC type X550EM_x. *  Does not touch the hardware. **/
end_comment

begin_function
name|s32
name|ixgbe_init_ops_X550EM_x
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|ixgbe_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|struct
name|ixgbe_link_info
modifier|*
name|link
init|=
operator|&
name|hw
operator|->
name|link
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_init_ops_X550EM_x"
argument_list|)
expr_stmt|;
comment|/* Start with generic X550EM init */
name|ret_val
operator|=
name|ixgbe_init_ops_X550EM
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|read_iosf_sb_reg
operator|=
name|ixgbe_read_iosf_sb_reg_x550
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|write_iosf_sb_reg
operator|=
name|ixgbe_write_iosf_sb_reg_x550
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|acquire_swfw_sync
operator|=
name|ixgbe_acquire_swfw_sync_X550em
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|release_swfw_sync
operator|=
name|ixgbe_release_swfw_sync_X550em
expr_stmt|;
name|link
operator|->
name|ops
operator|.
name|read_link
operator|=
name|ixgbe_read_i2c_combined_generic
expr_stmt|;
name|link
operator|->
name|ops
operator|.
name|read_link_unlocked
operator|=
name|ixgbe_read_i2c_combined_generic_unlocked
expr_stmt|;
name|link
operator|->
name|ops
operator|.
name|write_link
operator|=
name|ixgbe_write_i2c_combined_generic
expr_stmt|;
name|link
operator|->
name|ops
operator|.
name|write_link_unlocked
operator|=
name|ixgbe_write_i2c_combined_generic_unlocked
expr_stmt|;
name|link
operator|->
name|addr
operator|=
name|IXGBE_CS4227
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_dmac_config_X550  *  @hw: pointer to hardware structure  *  *  Configure DMA coalescing. If enabling dmac, dmac is activated.  *  When disabling dmac, dmac enable dmac bit is cleared.  **/
end_comment

begin_function
name|s32
name|ixgbe_dmac_config_X550
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|reg
decl_stmt|,
name|high_pri_tc
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_dmac_config_X550"
argument_list|)
expr_stmt|;
comment|/* Disable DMA coalescing before configuring */
name|reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DMACR
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|IXGBE_DMACR_DMAC_EN
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DMACR
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Disable DMA Coalescing if the watchdog timer is 0 */
if|if
condition|(
operator|!
name|hw
operator|->
name|mac
operator|.
name|dmac_config
operator|.
name|watchdog_timer
condition|)
goto|goto
name|out
goto|;
name|ixgbe_dmac_config_tcs_X550
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Configure DMA Coalescing Control Register */
name|reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DMACR
argument_list|)
expr_stmt|;
comment|/* Set the watchdog timer in units of 40.96 usec */
name|reg
operator|&=
operator|~
name|IXGBE_DMACR_DMACWT_MASK
expr_stmt|;
name|reg
operator||=
operator|(
name|hw
operator|->
name|mac
operator|.
name|dmac_config
operator|.
name|watchdog_timer
operator|*
literal|100
operator|)
operator|/
literal|4096
expr_stmt|;
name|reg
operator|&=
operator|~
name|IXGBE_DMACR_HIGH_PRI_TC_MASK
expr_stmt|;
comment|/* If fcoe is enabled, set high priority traffic class */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|dmac_config
operator|.
name|fcoe_en
condition|)
block|{
name|high_pri_tc
operator|=
literal|1
operator|<<
name|hw
operator|->
name|mac
operator|.
name|dmac_config
operator|.
name|fcoe_tc
expr_stmt|;
name|reg
operator||=
operator|(
operator|(
name|high_pri_tc
operator|<<
name|IXGBE_DMACR_HIGH_PRI_TC_SHIFT
operator|)
operator|&
name|IXGBE_DMACR_HIGH_PRI_TC_MASK
operator|)
expr_stmt|;
block|}
name|reg
operator||=
name|IXGBE_DMACR_EN_MNG_IND
expr_stmt|;
comment|/* Enable DMA coalescing after configuration */
name|reg
operator||=
name|IXGBE_DMACR_DMAC_EN
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DMACR
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_dmac_config_tcs_X550  *  @hw: pointer to hardware structure  *  *  Configure DMA coalescing threshold per TC. The dmac enable bit must  *  be cleared before configuring.  **/
end_comment

begin_function
name|s32
name|ixgbe_dmac_config_tcs_X550
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|tc
decl_stmt|,
name|reg
decl_stmt|,
name|pb_headroom
decl_stmt|,
name|rx_pb_size
decl_stmt|,
name|maxframe_size_kb
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_dmac_config_tcs_X550"
argument_list|)
expr_stmt|;
comment|/* Configure DMA coalescing enabled */
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|dmac_config
operator|.
name|link_speed
condition|)
block|{
case|case
name|IXGBE_LINK_SPEED_10_FULL
case|:
case|case
name|IXGBE_LINK_SPEED_100_FULL
case|:
name|pb_headroom
operator|=
name|IXGBE_DMACRXT_100M
expr_stmt|;
break|break;
case|case
name|IXGBE_LINK_SPEED_1GB_FULL
case|:
name|pb_headroom
operator|=
name|IXGBE_DMACRXT_1G
expr_stmt|;
break|break;
default|default:
name|pb_headroom
operator|=
name|IXGBE_DMACRXT_10G
expr_stmt|;
break|break;
block|}
name|maxframe_size_kb
operator|=
operator|(
operator|(
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MAXFRS
argument_list|)
operator|>>
name|IXGBE_MHADD_MFS_SHIFT
operator|)
operator|/
literal|1024
operator|)
expr_stmt|;
comment|/* Set the per Rx packet buffer receive threshold */
for|for
control|(
name|tc
operator|=
literal|0
init|;
name|tc
operator|<
name|IXGBE_DCB_MAX_TRAFFIC_CLASS
condition|;
name|tc
operator|++
control|)
block|{
name|reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DMCTH
argument_list|(
name|tc
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|IXGBE_DMCTH_DMACRXT_MASK
expr_stmt|;
if|if
condition|(
name|tc
operator|<
name|hw
operator|->
name|mac
operator|.
name|dmac_config
operator|.
name|num_tcs
condition|)
block|{
comment|/* Get Rx PB size */
name|rx_pb_size
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXPBSIZE
argument_list|(
name|tc
argument_list|)
argument_list|)
expr_stmt|;
name|rx_pb_size
operator|=
operator|(
name|rx_pb_size
operator|&
name|IXGBE_RXPBSIZE_MASK
operator|)
operator|>>
name|IXGBE_RXPBSIZE_SHIFT
expr_stmt|;
comment|/* Calculate receive buffer threshold in kilobytes */
if|if
condition|(
name|rx_pb_size
operator|>
name|pb_headroom
condition|)
name|rx_pb_size
operator|=
name|rx_pb_size
operator|-
name|pb_headroom
expr_stmt|;
else|else
name|rx_pb_size
operator|=
literal|0
expr_stmt|;
comment|/* Minimum of MFS shall be set for DMCTH */
name|reg
operator||=
operator|(
name|rx_pb_size
operator|>
name|maxframe_size_kb
operator|)
condition|?
name|rx_pb_size
else|:
name|maxframe_size_kb
expr_stmt|;
block|}
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DMCTH
argument_list|(
name|tc
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_dmac_update_tcs_X550  *  @hw: pointer to hardware structure  *  *  Disables dmac, updates per TC settings, and then enables dmac.  **/
end_comment

begin_function
name|s32
name|ixgbe_dmac_update_tcs_X550
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|reg
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_dmac_update_tcs_X550"
argument_list|)
expr_stmt|;
comment|/* Disable DMA coalescing before configuring */
name|reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DMACR
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|IXGBE_DMACR_DMAC_EN
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DMACR
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|ixgbe_dmac_config_tcs_X550
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Enable DMA coalescing after configuration */
name|reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DMACR
argument_list|)
expr_stmt|;
name|reg
operator||=
name|IXGBE_DMACR_DMAC_EN
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DMACR
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_init_eeprom_params_X550 - Initialize EEPROM params  *  @hw: pointer to hardware structure  *  *  Initializes the EEPROM parameters ixgbe_eeprom_info within the  *  ixgbe_hw struct in order to set up EEPROM access.  **/
end_comment

begin_function
name|s32
name|ixgbe_init_eeprom_params_X550
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|ixgbe_eeprom_info
modifier|*
name|eeprom
init|=
operator|&
name|hw
operator|->
name|eeprom
decl_stmt|;
name|u32
name|eec
decl_stmt|;
name|u16
name|eeprom_size
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_init_eeprom_params_X550"
argument_list|)
expr_stmt|;
if|if
condition|(
name|eeprom
operator|->
name|type
operator|==
name|ixgbe_eeprom_uninitialized
condition|)
block|{
name|eeprom
operator|->
name|semaphore_delay
operator|=
literal|10
expr_stmt|;
name|eeprom
operator|->
name|type
operator|=
name|ixgbe_flash
expr_stmt|;
name|eec
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEC
argument_list|)
expr_stmt|;
name|eeprom_size
operator|=
call|(
name|u16
call|)
argument_list|(
operator|(
name|eec
operator|&
name|IXGBE_EEC_SIZE
operator|)
operator|>>
name|IXGBE_EEC_SIZE_SHIFT
argument_list|)
expr_stmt|;
name|eeprom
operator|->
name|word_size
operator|=
literal|1
operator|<<
operator|(
name|eeprom_size
operator|+
name|IXGBE_EEPROM_WORD_SIZE_SHIFT
operator|)
expr_stmt|;
name|DEBUGOUT2
argument_list|(
literal|"Eeprom params: type = %d, size = %d\n"
argument_list|,
name|eeprom
operator|->
name|type
argument_list|,
name|eeprom
operator|->
name|word_size
argument_list|)
expr_stmt|;
block|}
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_set_source_address_pruning_X550 - Enable/Disbale source address pruning  * @hw: pointer to hardware structure  * @enable: enable or disable source address pruning  * @pool: Rx pool to set source address pruning for  **/
end_comment

begin_function
name|void
name|ixgbe_set_source_address_pruning_X550
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|enable
parameter_list|,
name|unsigned
name|int
name|pool
parameter_list|)
block|{
name|u64
name|pfflp
decl_stmt|;
comment|/* max rx pool is 63 */
if|if
condition|(
name|pool
operator|>
literal|63
condition|)
return|return;
name|pfflp
operator|=
operator|(
name|u64
operator|)
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PFFLPL
argument_list|)
expr_stmt|;
name|pfflp
operator||=
operator|(
name|u64
operator|)
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PFFLPH
argument_list|)
operator|<<
literal|32
expr_stmt|;
if|if
condition|(
name|enable
condition|)
name|pfflp
operator||=
operator|(
literal|1ULL
operator|<<
name|pool
operator|)
expr_stmt|;
else|else
name|pfflp
operator|&=
operator|~
operator|(
literal|1ULL
operator|<<
name|pool
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PFFLPL
argument_list|,
operator|(
name|u32
operator|)
name|pfflp
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PFFLPH
argument_list|,
call|(
name|u32
call|)
argument_list|(
name|pfflp
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_set_ethertype_anti_spoofing_X550 - Enable/Disable Ethertype anti-spoofing  *  @hw: pointer to hardware structure  *  @enable: enable or disable switch for Ethertype anti-spoofing  *  @vf: Virtual Function pool - VF Pool to set for Ethertype anti-spoofing  *  **/
end_comment

begin_function
name|void
name|ixgbe_set_ethertype_anti_spoofing_X550
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|enable
parameter_list|,
name|int
name|vf
parameter_list|)
block|{
name|int
name|vf_target_reg
init|=
name|vf
operator|>>
literal|3
decl_stmt|;
name|int
name|vf_target_shift
init|=
name|vf
operator|%
literal|8
operator|+
name|IXGBE_SPOOF_ETHERTYPEAS_SHIFT
decl_stmt|;
name|u32
name|pfvfspoof
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_set_ethertype_anti_spoofing_X550"
argument_list|)
expr_stmt|;
name|pfvfspoof
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PFVFSPOOF
argument_list|(
name|vf_target_reg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
name|pfvfspoof
operator||=
operator|(
literal|1
operator|<<
name|vf_target_shift
operator|)
expr_stmt|;
else|else
name|pfvfspoof
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|vf_target_shift
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PFVFSPOOF
argument_list|(
name|vf_target_reg
argument_list|)
argument_list|,
name|pfvfspoof
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_iosf_wait - Wait for IOSF command completion  * @hw: pointer to hardware structure  * @ctrl: pointer to location to receive final IOSF control value  *  * Returns failing status on timeout  *  * Note: ctrl can be NULL if the IOSF control register value is not needed  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_iosf_wait
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|ctrl
parameter_list|)
block|{
name|u32
name|i
decl_stmt|,
name|command
init|=
literal|0
decl_stmt|;
comment|/* Check every 10 usec to see if the address cycle completed. 	 * The SB IOSF BUSY bit will clear when the operation is 	 * complete 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_MDIO_COMMAND_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|command
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SB_IOSF_INDIRECT_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|command
operator|&
name|IXGBE_SB_IOSF_CTRL_BUSY
operator|)
operator|==
literal|0
condition|)
break|break;
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctrl
condition|)
operator|*
name|ctrl
operator|=
name|command
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|IXGBE_MDIO_COMMAND_TIMEOUT
condition|)
block|{
name|ERROR_REPORT1
argument_list|(
name|IXGBE_ERROR_POLLING
argument_list|,
literal|"Wait timed out\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_PHY
return|;
block|}
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_write_iosf_sb_reg_x550 - Writes a value to specified register  *  of the IOSF device  *  @hw: pointer to hardware structure  *  @reg_addr: 32 bit PHY register to write  *  @device_type: 3 bit device type  *  @data: Data to write to the register  **/
end_comment

begin_function
name|s32
name|ixgbe_write_iosf_sb_reg_x550
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|reg_addr
parameter_list|,
name|u32
name|device_type
parameter_list|,
name|u32
name|data
parameter_list|)
block|{
name|u32
name|gssr
init|=
name|IXGBE_GSSR_PHY1_SM
operator||
name|IXGBE_GSSR_PHY0_SM
decl_stmt|;
name|u32
name|command
decl_stmt|,
name|error
decl_stmt|;
name|s32
name|ret
decl_stmt|;
name|ret
operator|=
name|ixgbe_acquire_swfw_semaphore
argument_list|(
name|hw
argument_list|,
name|gssr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|ixgbe_iosf_wait
argument_list|(
name|hw
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|out
goto|;
name|command
operator|=
operator|(
operator|(
name|reg_addr
operator|<<
name|IXGBE_SB_IOSF_CTRL_ADDR_SHIFT
operator|)
operator||
operator|(
name|device_type
operator|<<
name|IXGBE_SB_IOSF_CTRL_TARGET_SELECT_SHIFT
operator|)
operator|)
expr_stmt|;
comment|/* Write IOSF control register */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SB_IOSF_INDIRECT_CTRL
argument_list|,
name|command
argument_list|)
expr_stmt|;
comment|/* Write IOSF data register */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SB_IOSF_INDIRECT_DATA
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ixgbe_iosf_wait
argument_list|(
name|hw
argument_list|,
operator|&
name|command
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|command
operator|&
name|IXGBE_SB_IOSF_CTRL_RESP_STAT_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
operator|(
name|command
operator|&
name|IXGBE_SB_IOSF_CTRL_CMPL_ERR_MASK
operator|)
operator|>>
name|IXGBE_SB_IOSF_CTRL_CMPL_ERR_SHIFT
expr_stmt|;
name|ERROR_REPORT2
argument_list|(
name|IXGBE_ERROR_POLLING
argument_list|,
literal|"Failed to write, error %x\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ret
operator|=
name|IXGBE_ERR_PHY
expr_stmt|;
block|}
name|out
label|:
name|ixgbe_release_swfw_semaphore
argument_list|(
name|hw
argument_list|,
name|gssr
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_read_iosf_sb_reg_x550 - Reads specified register of the IOSF device  *  @hw: pointer to hardware structure  *  @reg_addr: 32 bit PHY register to write  *  @device_type: 3 bit device type  *  @data: Pointer to read data from the register  **/
end_comment

begin_function
name|s32
name|ixgbe_read_iosf_sb_reg_x550
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|reg_addr
parameter_list|,
name|u32
name|device_type
parameter_list|,
name|u32
modifier|*
name|data
parameter_list|)
block|{
name|u32
name|gssr
init|=
name|IXGBE_GSSR_PHY1_SM
operator||
name|IXGBE_GSSR_PHY0_SM
decl_stmt|;
name|u32
name|command
decl_stmt|,
name|error
decl_stmt|;
name|s32
name|ret
decl_stmt|;
name|ret
operator|=
name|ixgbe_acquire_swfw_semaphore
argument_list|(
name|hw
argument_list|,
name|gssr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|ixgbe_iosf_wait
argument_list|(
name|hw
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|out
goto|;
name|command
operator|=
operator|(
operator|(
name|reg_addr
operator|<<
name|IXGBE_SB_IOSF_CTRL_ADDR_SHIFT
operator|)
operator||
operator|(
name|device_type
operator|<<
name|IXGBE_SB_IOSF_CTRL_TARGET_SELECT_SHIFT
operator|)
operator|)
expr_stmt|;
comment|/* Write IOSF control register */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SB_IOSF_INDIRECT_CTRL
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ixgbe_iosf_wait
argument_list|(
name|hw
argument_list|,
operator|&
name|command
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|command
operator|&
name|IXGBE_SB_IOSF_CTRL_RESP_STAT_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
operator|(
name|command
operator|&
name|IXGBE_SB_IOSF_CTRL_CMPL_ERR_MASK
operator|)
operator|>>
name|IXGBE_SB_IOSF_CTRL_CMPL_ERR_SHIFT
expr_stmt|;
name|ERROR_REPORT2
argument_list|(
name|IXGBE_ERROR_POLLING
argument_list|,
literal|"Failed to read, error %x\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ret
operator|=
name|IXGBE_ERR_PHY
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
name|IXGBE_SUCCESS
condition|)
operator|*
name|data
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_SB_IOSF_INDIRECT_DATA
argument_list|)
expr_stmt|;
name|out
label|:
name|ixgbe_release_swfw_semaphore
argument_list|(
name|hw
argument_list|,
name|gssr
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_get_phy_token - Get the token for shared phy access  * @hw: Pointer to hardware structure  */
end_comment

begin_function
name|s32
name|ixgbe_get_phy_token
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|ixgbe_hic_phy_token_req
name|token_cmd
decl_stmt|;
name|s32
name|status
decl_stmt|;
name|token_cmd
operator|.
name|hdr
operator|.
name|cmd
operator|=
name|FW_PHY_TOKEN_REQ_CMD
expr_stmt|;
name|token_cmd
operator|.
name|hdr
operator|.
name|buf_len
operator|=
name|FW_PHY_TOKEN_REQ_LEN
expr_stmt|;
name|token_cmd
operator|.
name|hdr
operator|.
name|cmd_or_resp
operator|.
name|cmd_resv
operator|=
literal|0
expr_stmt|;
name|token_cmd
operator|.
name|hdr
operator|.
name|checksum
operator|=
name|FW_DEFAULT_CHECKSUM
expr_stmt|;
name|token_cmd
operator|.
name|port_number
operator|=
name|hw
operator|->
name|bus
operator|.
name|lan_id
expr_stmt|;
name|token_cmd
operator|.
name|command_type
operator|=
name|FW_PHY_TOKEN_REQ
expr_stmt|;
name|token_cmd
operator|.
name|pad
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|ixgbe_host_interface_command
argument_list|(
name|hw
argument_list|,
operator|(
name|u32
operator|*
operator|)
operator|&
name|token_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|token_cmd
argument_list|)
argument_list|,
name|IXGBE_HI_COMMAND_TIMEOUT
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|DEBUGOUT1
argument_list|(
literal|"Issuing host interface command failed with Status = %d\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
if|if
condition|(
name|token_cmd
operator|.
name|hdr
operator|.
name|cmd_or_resp
operator|.
name|ret_status
operator|==
name|FW_PHY_TOKEN_OK
condition|)
return|return
name|IXGBE_SUCCESS
return|;
if|if
condition|(
name|token_cmd
operator|.
name|hdr
operator|.
name|cmd_or_resp
operator|.
name|ret_status
operator|!=
name|FW_PHY_TOKEN_RETRY
condition|)
block|{
name|DEBUGOUT1
argument_list|(
literal|"Host interface command returned 0x%08x , returning IXGBE_ERR_FW_RESP_INVALID\n"
argument_list|,
name|token_cmd
operator|.
name|hdr
operator|.
name|cmd_or_resp
operator|.
name|ret_status
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_FW_RESP_INVALID
return|;
block|}
name|DEBUGOUT
argument_list|(
literal|"Returning  IXGBE_ERR_TOKEN_RETRY\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_TOKEN_RETRY
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_put_phy_token - Put the token for shared phy access  * @hw: Pointer to hardware structure  */
end_comment

begin_function
name|s32
name|ixgbe_put_phy_token
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|ixgbe_hic_phy_token_req
name|token_cmd
decl_stmt|;
name|s32
name|status
decl_stmt|;
name|token_cmd
operator|.
name|hdr
operator|.
name|cmd
operator|=
name|FW_PHY_TOKEN_REQ_CMD
expr_stmt|;
name|token_cmd
operator|.
name|hdr
operator|.
name|buf_len
operator|=
name|FW_PHY_TOKEN_REQ_LEN
expr_stmt|;
name|token_cmd
operator|.
name|hdr
operator|.
name|cmd_or_resp
operator|.
name|cmd_resv
operator|=
literal|0
expr_stmt|;
name|token_cmd
operator|.
name|hdr
operator|.
name|checksum
operator|=
name|FW_DEFAULT_CHECKSUM
expr_stmt|;
name|token_cmd
operator|.
name|port_number
operator|=
name|hw
operator|->
name|bus
operator|.
name|lan_id
expr_stmt|;
name|token_cmd
operator|.
name|command_type
operator|=
name|FW_PHY_TOKEN_REL
expr_stmt|;
name|token_cmd
operator|.
name|pad
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|ixgbe_host_interface_command
argument_list|(
name|hw
argument_list|,
operator|(
name|u32
operator|*
operator|)
operator|&
name|token_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|token_cmd
argument_list|)
argument_list|,
name|IXGBE_HI_COMMAND_TIMEOUT
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|status
return|;
if|if
condition|(
name|token_cmd
operator|.
name|hdr
operator|.
name|cmd_or_resp
operator|.
name|ret_status
operator|==
name|FW_PHY_TOKEN_OK
condition|)
return|return
name|IXGBE_SUCCESS
return|;
name|DEBUGOUT
argument_list|(
literal|"Put PHY Token host interface command failed"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_FW_RESP_INVALID
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_write_iosf_sb_reg_x550a - Writes a value to specified register  *  of the IOSF device  *  @hw: pointer to hardware structure  *  @reg_addr: 32 bit PHY register to write  *  @device_type: 3 bit device type  *  @data: Data to write to the register  **/
end_comment

begin_function
name|s32
name|ixgbe_write_iosf_sb_reg_x550a
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|reg_addr
parameter_list|,
name|u32
name|device_type
parameter_list|,
name|u32
name|data
parameter_list|)
block|{
name|struct
name|ixgbe_hic_internal_phy_req
name|write_cmd
decl_stmt|;
name|s32
name|status
decl_stmt|;
name|UNREFERENCED_1PARAMETER
argument_list|(
name|device_type
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|write_cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|write_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|write_cmd
operator|.
name|hdr
operator|.
name|cmd
operator|=
name|FW_INT_PHY_REQ_CMD
expr_stmt|;
name|write_cmd
operator|.
name|hdr
operator|.
name|buf_len
operator|=
name|FW_INT_PHY_REQ_LEN
expr_stmt|;
name|write_cmd
operator|.
name|hdr
operator|.
name|checksum
operator|=
name|FW_DEFAULT_CHECKSUM
expr_stmt|;
name|write_cmd
operator|.
name|port_number
operator|=
name|hw
operator|->
name|bus
operator|.
name|lan_id
expr_stmt|;
name|write_cmd
operator|.
name|command_type
operator|=
name|FW_INT_PHY_REQ_WRITE
expr_stmt|;
name|write_cmd
operator|.
name|address
operator|=
name|IXGBE_CPU_TO_BE16
argument_list|(
name|reg_addr
argument_list|)
expr_stmt|;
name|write_cmd
operator|.
name|write_data
operator|=
name|IXGBE_CPU_TO_BE32
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|status
operator|=
name|ixgbe_host_interface_command
argument_list|(
name|hw
argument_list|,
operator|(
name|u32
operator|*
operator|)
operator|&
name|write_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|write_cmd
argument_list|)
argument_list|,
name|IXGBE_HI_COMMAND_TIMEOUT
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_read_iosf_sb_reg_x550a - Reads specified register of the IOSF device  *  @hw: pointer to hardware structure  *  @reg_addr: 32 bit PHY register to write  *  @device_type: 3 bit device type  *  @data: Pointer to read data from the register  **/
end_comment

begin_function
name|s32
name|ixgbe_read_iosf_sb_reg_x550a
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|reg_addr
parameter_list|,
name|u32
name|device_type
parameter_list|,
name|u32
modifier|*
name|data
parameter_list|)
block|{
union|union
block|{
name|struct
name|ixgbe_hic_internal_phy_req
name|cmd
decl_stmt|;
name|struct
name|ixgbe_hic_internal_phy_resp
name|rsp
decl_stmt|;
block|}
name|hic
union|;
name|s32
name|status
decl_stmt|;
name|UNREFERENCED_1PARAMETER
argument_list|(
name|device_type
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|hic
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hic
argument_list|)
argument_list|)
expr_stmt|;
name|hic
operator|.
name|cmd
operator|.
name|hdr
operator|.
name|cmd
operator|=
name|FW_INT_PHY_REQ_CMD
expr_stmt|;
name|hic
operator|.
name|cmd
operator|.
name|hdr
operator|.
name|buf_len
operator|=
name|FW_INT_PHY_REQ_LEN
expr_stmt|;
name|hic
operator|.
name|cmd
operator|.
name|hdr
operator|.
name|checksum
operator|=
name|FW_DEFAULT_CHECKSUM
expr_stmt|;
name|hic
operator|.
name|cmd
operator|.
name|port_number
operator|=
name|hw
operator|->
name|bus
operator|.
name|lan_id
expr_stmt|;
name|hic
operator|.
name|cmd
operator|.
name|command_type
operator|=
name|FW_INT_PHY_REQ_READ
expr_stmt|;
name|hic
operator|.
name|cmd
operator|.
name|address
operator|=
name|IXGBE_CPU_TO_BE16
argument_list|(
name|reg_addr
argument_list|)
expr_stmt|;
name|status
operator|=
name|ixgbe_host_interface_command
argument_list|(
name|hw
argument_list|,
operator|(
name|u32
operator|*
operator|)
operator|&
name|hic
operator|.
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|hic
operator|.
name|cmd
argument_list|)
argument_list|,
name|IXGBE_HI_COMMAND_TIMEOUT
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Extract the register value from the response. */
operator|*
name|data
operator|=
name|IXGBE_BE32_TO_CPU
argument_list|(
name|hic
operator|.
name|rsp
operator|.
name|read_data
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_disable_mdd_X550  *  @hw: pointer to hardware structure  *  *  Disable malicious driver detection  **/
end_comment

begin_function
name|void
name|ixgbe_disable_mdd_X550
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|reg
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_disable_mdd_X550"
argument_list|)
expr_stmt|;
comment|/* Disable MDD for TX DMA and interrupt */
name|reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DMATXCTL
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
operator|(
name|IXGBE_DMATXCTL_MDP_EN
operator||
name|IXGBE_DMATXCTL_MBINTEN
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DMATXCTL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Disable MDD for RX and interrupt */
name|reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RDRXCTL
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
operator|(
name|IXGBE_RDRXCTL_MDP_EN
operator||
name|IXGBE_RDRXCTL_MBINTEN
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RDRXCTL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_enable_mdd_X550  *  @hw: pointer to hardware structure  *  *  Enable malicious driver detection  **/
end_comment

begin_function
name|void
name|ixgbe_enable_mdd_X550
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|reg
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_enable_mdd_X550"
argument_list|)
expr_stmt|;
comment|/* Enable MDD for TX DMA and interrupt */
name|reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DMATXCTL
argument_list|)
expr_stmt|;
name|reg
operator||=
operator|(
name|IXGBE_DMATXCTL_MDP_EN
operator||
name|IXGBE_DMATXCTL_MBINTEN
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DMATXCTL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Enable MDD for RX and interrupt */
name|reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RDRXCTL
argument_list|)
expr_stmt|;
name|reg
operator||=
operator|(
name|IXGBE_RDRXCTL_MDP_EN
operator||
name|IXGBE_RDRXCTL_MBINTEN
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RDRXCTL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_restore_mdd_vf_X550  *  @hw: pointer to hardware structure  *  @vf: vf index  *  *  Restore VF that was disabled during malicious driver detection event  **/
end_comment

begin_function
name|void
name|ixgbe_restore_mdd_vf_X550
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|vf
parameter_list|)
block|{
name|u32
name|idx
decl_stmt|,
name|reg
decl_stmt|,
name|num_qs
decl_stmt|,
name|start_q
decl_stmt|,
name|bitmask
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_restore_mdd_vf_X550"
argument_list|)
expr_stmt|;
comment|/* Map VF to queues */
name|reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MRQC
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|reg
operator|&
name|IXGBE_MRQC_MRQE_MASK
condition|)
block|{
case|case
name|IXGBE_MRQC_VMDQRT8TCEN
case|:
name|num_qs
operator|=
literal|8
expr_stmt|;
comment|/* 16 VFs / pools */
name|bitmask
operator|=
literal|0x000000FF
expr_stmt|;
break|break;
case|case
name|IXGBE_MRQC_VMDQRSS32EN
case|:
case|case
name|IXGBE_MRQC_VMDQRT4TCEN
case|:
name|num_qs
operator|=
literal|4
expr_stmt|;
comment|/* 32 VFs / pools */
name|bitmask
operator|=
literal|0x0000000F
expr_stmt|;
break|break;
default|default:
comment|/* 64 VFs / pools */
name|num_qs
operator|=
literal|2
expr_stmt|;
name|bitmask
operator|=
literal|0x00000003
expr_stmt|;
break|break;
block|}
name|start_q
operator|=
name|vf
operator|*
name|num_qs
expr_stmt|;
comment|/* Release vf's queues by clearing WQBR_TX and WQBR_RX (RW1C) */
name|idx
operator|=
name|start_q
operator|/
literal|32
expr_stmt|;
name|reg
operator|=
literal|0
expr_stmt|;
name|reg
operator||=
operator|(
name|bitmask
operator|<<
operator|(
name|start_q
operator|%
literal|32
operator|)
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_WQBR_TX
argument_list|(
name|idx
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_WQBR_RX
argument_list|(
name|idx
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_mdd_event_X550  *  @hw: pointer to hardware structure  *  @vf_bitmap: vf bitmap of malicious vfs  *  *  Handle malicious driver detection event.  **/
end_comment

begin_function
name|void
name|ixgbe_mdd_event_X550
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|vf_bitmap
parameter_list|)
block|{
name|u32
name|wqbr
decl_stmt|;
name|u32
name|i
decl_stmt|,
name|j
decl_stmt|,
name|reg
decl_stmt|,
name|q
decl_stmt|,
name|shift
decl_stmt|,
name|vf
decl_stmt|,
name|idx
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_mdd_event_X550"
argument_list|)
expr_stmt|;
comment|/* figure out pool size for mapping to vf's */
name|reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_MRQC
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|reg
operator|&
name|IXGBE_MRQC_MRQE_MASK
condition|)
block|{
case|case
name|IXGBE_MRQC_VMDQRT8TCEN
case|:
name|shift
operator|=
literal|3
expr_stmt|;
comment|/* 16 VFs / pools */
break|break;
case|case
name|IXGBE_MRQC_VMDQRSS32EN
case|:
case|case
name|IXGBE_MRQC_VMDQRT4TCEN
case|:
name|shift
operator|=
literal|2
expr_stmt|;
comment|/* 32 VFs / pools */
break|break;
default|default:
name|shift
operator|=
literal|1
expr_stmt|;
comment|/* 64 VFs / pools */
break|break;
block|}
comment|/* Read WQBR_TX and WQBR_RX and check for malicious queues */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|wqbr
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_WQBR_TX
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|wqbr
operator||=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_WQBR_RX
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wqbr
condition|)
continue|continue;
comment|/* Get malicious queue */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|32
operator|&&
name|wqbr
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|wqbr
operator|&
operator|(
literal|1
operator|<<
name|j
operator|)
operator|)
condition|)
continue|continue;
comment|/* Get queue from bitmask */
name|q
operator|=
name|j
operator|+
operator|(
name|i
operator|*
literal|32
operator|)
expr_stmt|;
comment|/* Map queue to vf */
name|vf
operator|=
operator|(
name|q
operator|>>
name|shift
operator|)
expr_stmt|;
comment|/* Set vf bit in vf_bitmap */
name|idx
operator|=
name|vf
operator|/
literal|32
expr_stmt|;
name|vf_bitmap
index|[
name|idx
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|vf
operator|%
literal|32
operator|)
operator|)
expr_stmt|;
name|wqbr
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|j
operator|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_media_type_X550em - Get media type  *  @hw: pointer to hardware structure  *  *  Returns the media type (fiber, copper, backplane)  */
end_comment

begin_function
name|enum
name|ixgbe_media_type
name|ixgbe_get_media_type_X550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|enum
name|ixgbe_media_type
name|media_type
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_media_type_X550em"
argument_list|)
expr_stmt|;
comment|/* Detect if there is a copper PHY attached. */
switch|switch
condition|(
name|hw
operator|->
name|device_id
condition|)
block|{
case|case
name|IXGBE_DEV_ID_X550EM_X_KR
case|:
case|case
name|IXGBE_DEV_ID_X550EM_X_KX4
case|:
case|case
name|IXGBE_DEV_ID_X550EM_X_XFI
case|:
case|case
name|IXGBE_DEV_ID_X550EM_A_KR
case|:
case|case
name|IXGBE_DEV_ID_X550EM_A_KR_L
case|:
name|media_type
operator|=
name|ixgbe_media_type_backplane
expr_stmt|;
break|break;
case|case
name|IXGBE_DEV_ID_X550EM_X_SFP
case|:
case|case
name|IXGBE_DEV_ID_X550EM_A_SFP
case|:
case|case
name|IXGBE_DEV_ID_X550EM_A_SFP_N
case|:
case|case
name|IXGBE_DEV_ID_X550EM_A_QSFP
case|:
case|case
name|IXGBE_DEV_ID_X550EM_A_QSFP_N
case|:
name|media_type
operator|=
name|ixgbe_media_type_fiber
expr_stmt|;
break|break;
case|case
name|IXGBE_DEV_ID_X550EM_X_1G_T
case|:
case|case
name|IXGBE_DEV_ID_X550EM_X_10G_T
case|:
case|case
name|IXGBE_DEV_ID_X550EM_A_10G_T
case|:
name|media_type
operator|=
name|ixgbe_media_type_copper
expr_stmt|;
break|break;
case|case
name|IXGBE_DEV_ID_X550EM_A_SGMII
case|:
case|case
name|IXGBE_DEV_ID_X550EM_A_SGMII_L
case|:
name|media_type
operator|=
name|ixgbe_media_type_backplane
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|ixgbe_phy_sgmii
expr_stmt|;
break|break;
case|case
name|IXGBE_DEV_ID_X550EM_A_1G_T
case|:
case|case
name|IXGBE_DEV_ID_X550EM_A_1G_T_L
case|:
name|media_type
operator|=
name|ixgbe_media_type_copper
expr_stmt|;
break|break;
default|default:
name|media_type
operator|=
name|ixgbe_media_type_unknown
expr_stmt|;
break|break;
block|}
return|return
name|media_type
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_supported_sfp_modules_X550em - Check if SFP module type is supported  *  @hw: pointer to hardware structure  *  @linear: TRUE if SFP module is linear  */
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_supported_sfp_modules_X550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|bool
modifier|*
name|linear
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_supported_sfp_modules_X550em"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|phy
operator|.
name|sfp_type
condition|)
block|{
case|case
name|ixgbe_sfp_type_not_present
case|:
return|return
name|IXGBE_ERR_SFP_NOT_PRESENT
return|;
case|case
name|ixgbe_sfp_type_da_cu_core0
case|:
case|case
name|ixgbe_sfp_type_da_cu_core1
case|:
operator|*
name|linear
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|ixgbe_sfp_type_srlr_core0
case|:
case|case
name|ixgbe_sfp_type_srlr_core1
case|:
case|case
name|ixgbe_sfp_type_da_act_lmt_core0
case|:
case|case
name|ixgbe_sfp_type_da_act_lmt_core1
case|:
case|case
name|ixgbe_sfp_type_1g_sx_core0
case|:
case|case
name|ixgbe_sfp_type_1g_sx_core1
case|:
case|case
name|ixgbe_sfp_type_1g_lx_core0
case|:
case|case
name|ixgbe_sfp_type_1g_lx_core1
case|:
operator|*
name|linear
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|ixgbe_sfp_type_unknown
case|:
case|case
name|ixgbe_sfp_type_1g_cu_core0
case|:
case|case
name|ixgbe_sfp_type_1g_cu_core1
case|:
default|default:
return|return
name|IXGBE_ERR_SFP_NOT_SUPPORTED
return|;
block|}
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_identify_sfp_module_X550em - Identifies SFP modules  *  @hw: pointer to hardware structure  *  *  Searches for and identifies the SFP module and assigns appropriate PHY type.  **/
end_comment

begin_function
name|s32
name|ixgbe_identify_sfp_module_X550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|bool
name|linear
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_identify_sfp_module_X550em"
argument_list|)
expr_stmt|;
name|status
operator|=
name|ixgbe_identify_module_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* Check if SFP module is supported */
name|status
operator|=
name|ixgbe_supported_sfp_modules_X550em
argument_list|(
name|hw
argument_list|,
operator|&
name|linear
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_setup_sfp_modules_X550em - Setup MAC link ops  *  @hw: pointer to hardware structure  */
end_comment

begin_function
name|s32
name|ixgbe_setup_sfp_modules_X550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|bool
name|linear
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_setup_sfp_modules_X550em"
argument_list|)
expr_stmt|;
comment|/* Check if SFP module is supported */
name|status
operator|=
name|ixgbe_supported_sfp_modules_X550em
argument_list|(
name|hw
argument_list|,
operator|&
name|linear
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|ixgbe_init_mac_link_ops_X550em
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|reset
operator|=
name|NULL
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/** *  ixgbe_restart_an_internal_phy_x550em - restart autonegotiation for the *  internal PHY *  @hw: pointer to hardware structure **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_restart_an_internal_phy_x550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|u32
name|link_ctrl
decl_stmt|;
comment|/* Restart auto-negotiation. */
name|status
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|read_iosf_sb_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_LINK_CTRL_1
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
operator|&
name|link_ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Auto-negotiation did not complete\n"
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
name|link_ctrl
operator||=
name|IXGBE_KRM_LINK_CTRL_1_TETH_AN_RESTART
expr_stmt|;
name|status
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|write_iosf_sb_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_LINK_CTRL_1
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
name|link_ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_X550EM_a
condition|)
block|{
name|u32
name|flx_mask_st20
decl_stmt|;
comment|/* Indicate to FW that AN restart has been asserted */
name|status
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|read_iosf_sb_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_PMD_FLX_MASK_ST20
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
operator|&
name|flx_mask_st20
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Auto-negotiation did not complete\n"
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
name|flx_mask_st20
operator||=
name|IXGBE_KRM_PMD_FLX_MASK_ST20_FW_AN_RESTART
expr_stmt|;
name|status
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|write_iosf_sb_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_PMD_FLX_MASK_ST20
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
name|flx_mask_st20
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_setup_sgmii - Set up link for sgmii  * @hw: pointer to hardware structure  */
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_setup_sgmii
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
name|speed
parameter_list|,
name|bool
name|autoneg_wait
parameter_list|)
block|{
name|struct
name|ixgbe_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|u32
name|lval
decl_stmt|,
name|sval
decl_stmt|,
name|flx_val
decl_stmt|;
name|s32
name|rc
decl_stmt|;
name|rc
operator|=
name|mac
operator|->
name|ops
operator|.
name|read_iosf_sb_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_LINK_CTRL_1
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
operator|&
name|lval
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
name|rc
return|;
name|lval
operator|&=
operator|~
name|IXGBE_KRM_LINK_CTRL_1_TETH_AN_ENABLE
expr_stmt|;
name|lval
operator|&=
operator|~
name|IXGBE_KRM_LINK_CTRL_1_TETH_FORCE_SPEED_MASK
expr_stmt|;
name|lval
operator||=
name|IXGBE_KRM_LINK_CTRL_1_TETH_AN_SGMII_EN
expr_stmt|;
name|lval
operator||=
name|IXGBE_KRM_LINK_CTRL_1_TETH_AN_CLAUSE_37_EN
expr_stmt|;
name|lval
operator||=
name|IXGBE_KRM_LINK_CTRL_1_TETH_FORCE_SPEED_1G
expr_stmt|;
name|rc
operator|=
name|mac
operator|->
name|ops
operator|.
name|write_iosf_sb_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_LINK_CTRL_1
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
name|lval
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
name|rc
return|;
name|rc
operator|=
name|mac
operator|->
name|ops
operator|.
name|read_iosf_sb_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_SGMII_CTRL
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
operator|&
name|sval
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
name|rc
return|;
name|sval
operator||=
name|IXGBE_KRM_SGMII_CTRL_MAC_TAR_FORCE_10_D
expr_stmt|;
name|sval
operator||=
name|IXGBE_KRM_SGMII_CTRL_MAC_TAR_FORCE_100_D
expr_stmt|;
name|rc
operator|=
name|mac
operator|->
name|ops
operator|.
name|write_iosf_sb_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_SGMII_CTRL
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
name|sval
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
name|rc
return|;
name|rc
operator|=
name|mac
operator|->
name|ops
operator|.
name|read_iosf_sb_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_PMD_FLX_MASK_ST20
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
operator|&
name|flx_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
name|rc
return|;
name|flx_val
operator|&=
operator|~
name|IXGBE_KRM_PMD_FLX_MASK_ST20_SPEED_MASK
expr_stmt|;
name|flx_val
operator||=
name|IXGBE_KRM_PMD_FLX_MASK_ST20_SPEED_1G
expr_stmt|;
name|flx_val
operator|&=
operator|~
name|IXGBE_KRM_PMD_FLX_MASK_ST20_AN_EN
expr_stmt|;
name|flx_val
operator||=
name|IXGBE_KRM_PMD_FLX_MASK_ST20_SGMII_EN
expr_stmt|;
name|flx_val
operator||=
name|IXGBE_KRM_PMD_FLX_MASK_ST20_AN37_EN
expr_stmt|;
name|rc
operator|=
name|mac
operator|->
name|ops
operator|.
name|write_iosf_sb_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_PMD_FLX_MASK_ST20
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
name|flx_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
name|rc
return|;
name|rc
operator|=
name|ixgbe_restart_an_internal_phy_x550em
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
name|rc
return|;
return|return
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|setup_link_speed
argument_list|(
name|hw
argument_list|,
name|speed
argument_list|,
name|autoneg_wait
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_setup_sgmii_fw - Set up link for sgmii with firmware-controlled PHYs  * @hw: pointer to hardware structure  */
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_setup_sgmii_fw
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
name|speed
parameter_list|,
name|bool
name|autoneg_wait
parameter_list|)
block|{
name|struct
name|ixgbe_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|u32
name|lval
decl_stmt|,
name|sval
decl_stmt|,
name|flx_val
decl_stmt|;
name|s32
name|rc
decl_stmt|;
name|rc
operator|=
name|mac
operator|->
name|ops
operator|.
name|read_iosf_sb_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_LINK_CTRL_1
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
operator|&
name|lval
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
name|rc
return|;
name|lval
operator|&=
operator|~
name|IXGBE_KRM_LINK_CTRL_1_TETH_AN_ENABLE
expr_stmt|;
name|lval
operator|&=
operator|~
name|IXGBE_KRM_LINK_CTRL_1_TETH_FORCE_SPEED_MASK
expr_stmt|;
name|lval
operator||=
name|IXGBE_KRM_LINK_CTRL_1_TETH_AN_SGMII_EN
expr_stmt|;
name|lval
operator||=
name|IXGBE_KRM_LINK_CTRL_1_TETH_AN_CLAUSE_37_EN
expr_stmt|;
name|lval
operator|&=
operator|~
name|IXGBE_KRM_LINK_CTRL_1_TETH_FORCE_SPEED_1G
expr_stmt|;
name|rc
operator|=
name|mac
operator|->
name|ops
operator|.
name|write_iosf_sb_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_LINK_CTRL_1
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
name|lval
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
name|rc
return|;
name|rc
operator|=
name|mac
operator|->
name|ops
operator|.
name|read_iosf_sb_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_SGMII_CTRL
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
operator|&
name|sval
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
name|rc
return|;
name|sval
operator|&=
operator|~
name|IXGBE_KRM_SGMII_CTRL_MAC_TAR_FORCE_10_D
expr_stmt|;
name|sval
operator|&=
operator|~
name|IXGBE_KRM_SGMII_CTRL_MAC_TAR_FORCE_100_D
expr_stmt|;
name|rc
operator|=
name|mac
operator|->
name|ops
operator|.
name|write_iosf_sb_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_SGMII_CTRL
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
name|sval
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
name|rc
return|;
name|rc
operator|=
name|mac
operator|->
name|ops
operator|.
name|write_iosf_sb_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_LINK_CTRL_1
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
name|lval
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
name|rc
return|;
name|rc
operator|=
name|mac
operator|->
name|ops
operator|.
name|read_iosf_sb_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_PMD_FLX_MASK_ST20
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
operator|&
name|flx_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
name|rc
return|;
name|flx_val
operator|&=
operator|~
name|IXGBE_KRM_PMD_FLX_MASK_ST20_SPEED_MASK
expr_stmt|;
name|flx_val
operator||=
name|IXGBE_KRM_PMD_FLX_MASK_ST20_SPEED_AN
expr_stmt|;
name|flx_val
operator|&=
operator|~
name|IXGBE_KRM_PMD_FLX_MASK_ST20_AN_EN
expr_stmt|;
name|flx_val
operator||=
name|IXGBE_KRM_PMD_FLX_MASK_ST20_SGMII_EN
expr_stmt|;
name|flx_val
operator||=
name|IXGBE_KRM_PMD_FLX_MASK_ST20_AN37_EN
expr_stmt|;
name|rc
operator|=
name|mac
operator|->
name|ops
operator|.
name|write_iosf_sb_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_PMD_FLX_MASK_ST20
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
name|flx_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
name|rc
return|;
name|rc
operator|=
name|ixgbe_restart_an_internal_phy_x550em
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|setup_link_speed
argument_list|(
name|hw
argument_list|,
name|speed
argument_list|,
name|autoneg_wait
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_init_mac_link_ops_X550em - init mac link function pointers  *  @hw: pointer to hardware structure  */
end_comment

begin_function
name|void
name|ixgbe_init_mac_link_ops_X550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|ixgbe_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_init_mac_link_ops_X550em"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|get_media_type
argument_list|(
name|hw
argument_list|)
condition|)
block|{
case|case
name|ixgbe_media_type_fiber
case|:
comment|/* CS4227 does not support autoneg, so disable the laser control 		 * functions for SFP+ fiber 		 */
name|mac
operator|->
name|ops
operator|.
name|disable_tx_laser
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|enable_tx_laser
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|flap_tx_laser
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|setup_link
operator|=
name|ixgbe_setup_mac_link_multispeed_fiber
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|set_rate_select_speed
operator|=
name|ixgbe_set_soft_rate_select_speed
expr_stmt|;
if|if
condition|(
operator|(
name|hw
operator|->
name|device_id
operator|==
name|IXGBE_DEV_ID_X550EM_A_SFP_N
operator|)
operator|||
operator|(
name|hw
operator|->
name|device_id
operator|==
name|IXGBE_DEV_ID_X550EM_A_SFP
operator|)
condition|)
name|mac
operator|->
name|ops
operator|.
name|setup_mac_link
operator|=
name|ixgbe_setup_mac_link_sfp_x550a
expr_stmt|;
else|else
name|mac
operator|->
name|ops
operator|.
name|setup_mac_link
operator|=
name|ixgbe_setup_mac_link_sfp_x550em
expr_stmt|;
break|break;
case|case
name|ixgbe_media_type_copper
case|:
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_X550EM_a
condition|)
block|{
if|if
condition|(
name|hw
operator|->
name|device_id
operator|==
name|IXGBE_DEV_ID_X550EM_A_1G_T
operator|||
name|hw
operator|->
name|device_id
operator|==
name|IXGBE_DEV_ID_X550EM_A_1G_T_L
condition|)
block|{
name|mac
operator|->
name|ops
operator|.
name|setup_link
operator|=
name|ixgbe_setup_sgmii_fw
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|check_link
operator|=
name|ixgbe_check_mac_link_generic
expr_stmt|;
block|}
else|else
block|{
name|mac
operator|->
name|ops
operator|.
name|setup_link
operator|=
name|ixgbe_setup_mac_link_t_X550em
expr_stmt|;
block|}
block|}
else|else
block|{
name|mac
operator|->
name|ops
operator|.
name|setup_link
operator|=
name|ixgbe_setup_mac_link_t_X550em
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|check_link
operator|=
name|ixgbe_check_link_t_X550em
expr_stmt|;
block|}
break|break;
case|case
name|ixgbe_media_type_backplane
case|:
if|if
condition|(
name|hw
operator|->
name|device_id
operator|==
name|IXGBE_DEV_ID_X550EM_A_SGMII
operator|||
name|hw
operator|->
name|device_id
operator|==
name|IXGBE_DEV_ID_X550EM_A_SGMII_L
condition|)
name|mac
operator|->
name|ops
operator|.
name|setup_link
operator|=
name|ixgbe_setup_sgmii
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_link_capabilities_x550em - Determines link capabilities  *  @hw: pointer to hardware structure  *  @speed: pointer to link speed  *  @autoneg: TRUE when autoneg or autotry is enabled  */
end_comment

begin_function
name|s32
name|ixgbe_get_link_capabilities_X550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
modifier|*
name|speed
parameter_list|,
name|bool
modifier|*
name|autoneg
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_link_capabilities_X550em"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|ixgbe_phy_fw
condition|)
block|{
operator|*
name|autoneg
operator|=
name|TRUE
expr_stmt|;
operator|*
name|speed
operator|=
name|hw
operator|->
name|phy
operator|.
name|speeds_supported
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* SFP */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|==
name|ixgbe_media_type_fiber
condition|)
block|{
comment|/* CS4227 SFP must not enable auto-negotiation */
operator|*
name|autoneg
operator|=
name|FALSE
expr_stmt|;
comment|/* Check if 1G SFP module. */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|==
name|ixgbe_sfp_type_1g_sx_core0
operator|||
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|==
name|ixgbe_sfp_type_1g_sx_core1
operator|||
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|==
name|ixgbe_sfp_type_1g_lx_core0
operator|||
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|==
name|ixgbe_sfp_type_1g_lx_core1
condition|)
block|{
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
comment|/* Link capabilities are based on SFP */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|multispeed_fiber
condition|)
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_10GB_FULL
operator||
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
else|else
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_10GB_FULL
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
condition|)
block|{
case|case
name|ixgbe_phy_sgmii
case|:
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
break|break;
case|case
name|ixgbe_phy_x550em_kr
case|:
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_X550EM_a
condition|)
block|{
comment|/* check different backplane modes */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|nw_mng_if_sel
operator|&
name|IXGBE_NW_MNG_IF_SEL_PHY_SPEED_2_5G
condition|)
block|{
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_2_5GB_FULL
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|hw
operator|->
name|device_id
operator|==
name|IXGBE_DEV_ID_X550EM_A_KR_L
condition|)
block|{
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
break|break;
block|}
block|}
comment|/* fall through */
default|default:
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_10GB_FULL
operator||
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
break|break;
block|}
operator|*
name|autoneg
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_get_lasi_ext_t_x550em - Determime external Base T PHY interrupt cause  * @hw: pointer to hardware structure  * @lsc: pointer to boolean flag which indicates whether external Base T  *       PHY interrupt is lsc  *  * Determime if external Base T PHY interrupt cause is high temperature  * failure alarm or link status change.  *  * Return IXGBE_ERR_OVERTEMP if interrupt is high temperature  * failure alarm, else return PHY access status.  */
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_get_lasi_ext_t_x550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|bool
modifier|*
name|lsc
parameter_list|)
block|{
name|u32
name|status
decl_stmt|;
name|u16
name|reg
decl_stmt|;
operator|*
name|lsc
operator|=
name|FALSE
expr_stmt|;
comment|/* Vendor alarm triggered */
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_GLOBAL_CHIP_STD_INT_FLAG
argument_list|,
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
operator|||
operator|!
operator|(
name|reg
operator|&
name|IXGBE_MDIO_GLOBAL_VEN_ALM_INT_EN
operator|)
condition|)
return|return
name|status
return|;
comment|/* Vendor Auto-Neg alarm triggered or Global alarm 1 triggered */
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_GLOBAL_INT_CHIP_VEN_FLAG
argument_list|,
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
operator|||
operator|!
operator|(
name|reg
operator|&
operator|(
name|IXGBE_MDIO_GLOBAL_AN_VEN_ALM_INT_EN
operator||
name|IXGBE_MDIO_GLOBAL_ALARM_1_INT
operator|)
operator|)
condition|)
return|return
name|status
return|;
comment|/* Global alarm triggered */
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_GLOBAL_ALARM_1
argument_list|,
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* If high temperature failure, then return over temp error and exit */
if|if
condition|(
name|reg
operator|&
name|IXGBE_MDIO_GLOBAL_ALM_1_HI_TMP_FAIL
condition|)
block|{
comment|/* power down the PHY in case the PHY FW didn't already */
name|ixgbe_set_copper_phy_power
argument_list|(
name|hw
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_OVERTEMP
return|;
block|}
elseif|else
if|if
condition|(
name|reg
operator|&
name|IXGBE_MDIO_GLOBAL_ALM_1_DEV_FAULT
condition|)
block|{
comment|/*  device fault alarm triggered */
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_GLOBAL_FAULT_MSG
argument_list|,
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* if device fault was due to high temp alarm handle and exit */
if|if
condition|(
name|reg
operator|==
name|IXGBE_MDIO_GLOBAL_FAULT_MSG_HI_TMP
condition|)
block|{
comment|/* power down the PHY in case the PHY FW didn't */
name|ixgbe_set_copper_phy_power
argument_list|(
name|hw
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_OVERTEMP
return|;
block|}
block|}
comment|/* Vendor alarm 2 triggered */
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_GLOBAL_CHIP_STD_INT_FLAG
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
operator|||
operator|!
operator|(
name|reg
operator|&
name|IXGBE_MDIO_GLOBAL_STD_ALM2_INT
operator|)
condition|)
return|return
name|status
return|;
comment|/* link connect/disconnect event occurred */
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_VENDOR_TX_ALARM2
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* Indicate LSC */
if|if
condition|(
name|reg
operator|&
name|IXGBE_MDIO_AUTO_NEG_VEN_LSC
condition|)
operator|*
name|lsc
operator|=
name|TRUE
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_enable_lasi_ext_t_x550em - Enable external Base T PHY interrupts  * @hw: pointer to hardware structure  *  * Enable link status change and temperature failure alarm for the external  * Base T PHY  *  * Returns PHY access status  */
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_enable_lasi_ext_t_x550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|status
decl_stmt|;
name|u16
name|reg
decl_stmt|;
name|bool
name|lsc
decl_stmt|;
comment|/* Clear interrupt flags */
name|status
operator|=
name|ixgbe_get_lasi_ext_t_x550em
argument_list|(
name|hw
argument_list|,
operator|&
name|lsc
argument_list|)
expr_stmt|;
comment|/* Enable link status change alarm */
comment|/* Enable the LASI interrupts on X552 devices to receive notifications 	 * of the link configurations of the external PHY and correspondingly 	 * support the configuration of the internal iXFI link, since iXFI does 	 * not support auto-negotiation. This is not required for X553 devices 	 * having KR support, which performs auto-negotiations and which is used 	 * as the internal link to the external PHY. Hence adding a check here 	 * to avoid enabling LASI interrupts for X553 devices. 	 */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|!=
name|ixgbe_mac_X550EM_a
condition|)
block|{
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_PMA_TX_VEN_LASI_INT_MASK
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|reg
operator||=
name|IXGBE_MDIO_PMA_TX_VEN_LASI_INT_EN
expr_stmt|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_PMA_TX_VEN_LASI_INT_MASK
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
block|}
comment|/* Enable high temperature failure and global fault alarms */
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_GLOBAL_INT_MASK
argument_list|,
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|reg
operator||=
operator|(
name|IXGBE_MDIO_GLOBAL_INT_HI_TEMP_EN
operator||
name|IXGBE_MDIO_GLOBAL_INT_DEV_FAULT_EN
operator|)
expr_stmt|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_GLOBAL_INT_MASK
argument_list|,
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* Enable vendor Auto-Neg alarm and Global Interrupt Mask 1 alarm */
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_GLOBAL_INT_CHIP_VEN_MASK
argument_list|,
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|reg
operator||=
operator|(
name|IXGBE_MDIO_GLOBAL_AN_VEN_ALM_INT_EN
operator||
name|IXGBE_MDIO_GLOBAL_ALARM_1_INT
operator|)
expr_stmt|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_GLOBAL_INT_CHIP_VEN_MASK
argument_list|,
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* Enable chip-wide vendor alarm */
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_GLOBAL_INT_CHIP_STD_MASK
argument_list|,
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|reg
operator||=
name|IXGBE_MDIO_GLOBAL_VEN_ALM_INT_EN
expr_stmt|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_GLOBAL_INT_CHIP_STD_MASK
argument_list|,
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_setup_kr_speed_x550em - Configure the KR PHY for link speed.  *  @hw: pointer to hardware structure  *  @speed: link speed  *  *  Configures the integrated KR PHY.  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_setup_kr_speed_x550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
name|speed
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|u32
name|reg_val
decl_stmt|;
name|status
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|read_iosf_sb_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_LINK_CTRL_1
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
operator|&
name|reg_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|status
return|;
name|reg_val
operator||=
name|IXGBE_KRM_LINK_CTRL_1_TETH_AN_ENABLE
expr_stmt|;
name|reg_val
operator|&=
operator|~
operator|(
name|IXGBE_KRM_LINK_CTRL_1_TETH_AN_CAP_KR
operator||
name|IXGBE_KRM_LINK_CTRL_1_TETH_AN_CAP_KX
operator|)
expr_stmt|;
comment|/* Advertise 10G support. */
if|if
condition|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_10GB_FULL
condition|)
name|reg_val
operator||=
name|IXGBE_KRM_LINK_CTRL_1_TETH_AN_CAP_KR
expr_stmt|;
comment|/* Advertise 1G support. */
if|if
condition|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_1GB_FULL
condition|)
name|reg_val
operator||=
name|IXGBE_KRM_LINK_CTRL_1_TETH_AN_CAP_KX
expr_stmt|;
name|status
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|write_iosf_sb_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_LINK_CTRL_1
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_X550EM_a
condition|)
block|{
comment|/* Set lane mode  to KR auto negotiation */
name|status
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|read_iosf_sb_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_PMD_FLX_MASK_ST20
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
operator|&
name|reg_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|status
return|;
name|reg_val
operator|&=
operator|~
name|IXGBE_KRM_PMD_FLX_MASK_ST20_SPEED_MASK
expr_stmt|;
name|reg_val
operator||=
name|IXGBE_KRM_PMD_FLX_MASK_ST20_SPEED_AN
expr_stmt|;
name|reg_val
operator||=
name|IXGBE_KRM_PMD_FLX_MASK_ST20_AN_EN
expr_stmt|;
name|reg_val
operator|&=
operator|~
name|IXGBE_KRM_PMD_FLX_MASK_ST20_AN37_EN
expr_stmt|;
name|reg_val
operator|&=
operator|~
name|IXGBE_KRM_PMD_FLX_MASK_ST20_SGMII_EN
expr_stmt|;
name|status
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|write_iosf_sb_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_PMD_FLX_MASK_ST20
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
block|}
return|return
name|ixgbe_restart_an_internal_phy_x550em
argument_list|(
name|hw
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_reset_phy_fw - Reset firmware-controlled PHYs  * @hw: pointer to hardware structure  */
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_reset_phy_fw
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|store
index|[
name|FW_PHY_ACT_DATA_COUNT
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|s32
name|rc
decl_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|reset_disable
operator|||
name|ixgbe_check_reset_blocked
argument_list|(
name|hw
argument_list|)
condition|)
return|return
name|IXGBE_SUCCESS
return|;
name|rc
operator|=
name|ixgbe_fw_phy_activity
argument_list|(
name|hw
argument_list|,
name|FW_PHY_ACT_PHY_SW_RESET
argument_list|,
operator|&
name|store
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
name|rc
return|;
name|memset
argument_list|(
name|store
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|store
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ixgbe_fw_phy_activity
argument_list|(
name|hw
argument_list|,
name|FW_PHY_ACT_INIT_PHY
argument_list|,
operator|&
name|store
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
name|rc
return|;
return|return
name|ixgbe_setup_fw_link
argument_list|(
name|hw
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_check_overtemp_fw - Check firmware-controlled PHYs for overtemp  * @hw: pointer to hardware structure  */
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_check_overtemp_fw
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|store
index|[
name|FW_PHY_ACT_DATA_COUNT
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|s32
name|rc
decl_stmt|;
name|rc
operator|=
name|ixgbe_fw_phy_activity
argument_list|(
name|hw
argument_list|,
name|FW_PHY_ACT_GET_LINK_INFO
argument_list|,
operator|&
name|store
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
name|rc
return|;
if|if
condition|(
name|store
index|[
literal|0
index|]
operator|&
name|FW_PHY_ACT_GET_LINK_INFO_TEMP
condition|)
block|{
name|ixgbe_shutdown_fw_phy
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_OVERTEMP
return|;
block|}
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_read_mng_if_sel_x550em - Read NW_MNG_IF_SEL register  *  @hw: pointer to hardware structure  *  *  Read NW_MNG_IF_SEL register and save field values, and check for valid field  *  values.  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_read_mng_if_sel_x550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
comment|/* Save NW management interface connected on board. This is used 	 * to determine internal PHY mode. 	 */
name|hw
operator|->
name|phy
operator|.
name|nw_mng_if_sel
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_NW_MNG_IF_SEL
argument_list|)
expr_stmt|;
comment|/* If X552 (X550EM_a) and MDIO is connected to external PHY, then set 	 * PHY address. This register field was has only been used for X552. 	 */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_X550EM_a
operator|&&
name|hw
operator|->
name|phy
operator|.
name|nw_mng_if_sel
operator|&
name|IXGBE_NW_MNG_IF_SEL_MDIO_ACT
condition|)
block|{
name|hw
operator|->
name|phy
operator|.
name|addr
operator|=
operator|(
name|hw
operator|->
name|phy
operator|.
name|nw_mng_if_sel
operator|&
name|IXGBE_NW_MNG_IF_SEL_MDIO_PHY_ADD
operator|)
operator|>>
name|IXGBE_NW_MNG_IF_SEL_MDIO_PHY_ADD_SHIFT
expr_stmt|;
block|}
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_init_phy_ops_X550em - PHY/SFP specific init  *  @hw: pointer to hardware structure  *  *  Initialize any function pointers that were not able to be  *  set during init_shared_code because the PHY/SFP type was  *  not known.  Perform the SFP init if necessary.  */
end_comment

begin_function
name|s32
name|ixgbe_init_phy_ops_X550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|ixgbe_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_init_phy_ops_X550em"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|set_lan_id
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|ixgbe_read_mng_if_sel_x550em
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|get_media_type
argument_list|(
name|hw
argument_list|)
operator|==
name|ixgbe_media_type_fiber
condition|)
block|{
name|phy
operator|->
name|phy_semaphore_mask
operator|=
name|IXGBE_GSSR_SHARED_I2C_SM
expr_stmt|;
name|ixgbe_setup_mux_ctl
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|identify_sfp
operator|=
name|ixgbe_identify_sfp_module_X550em
expr_stmt|;
block|}
switch|switch
condition|(
name|hw
operator|->
name|device_id
condition|)
block|{
case|case
name|IXGBE_DEV_ID_X550EM_A_1G_T
case|:
case|case
name|IXGBE_DEV_ID_X550EM_A_1G_T_L
case|:
name|phy
operator|->
name|ops
operator|.
name|read_reg_mdi
operator|=
name|ixgbe_read_phy_reg_mdi_22
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|write_reg_mdi
operator|=
name|ixgbe_write_phy_reg_mdi_22
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
operator|=
name|ixgbe_read_phy_reg_x550a
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
operator|=
name|ixgbe_write_phy_reg_x550a
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|check_overtemp
operator|=
name|ixgbe_check_overtemp_fw
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
condition|)
name|hw
operator|->
name|phy
operator|.
name|phy_semaphore_mask
operator||=
name|IXGBE_GSSR_PHY1_SM
expr_stmt|;
else|else
name|hw
operator|->
name|phy
operator|.
name|phy_semaphore_mask
operator||=
name|IXGBE_GSSR_PHY0_SM
expr_stmt|;
break|break;
case|case
name|IXGBE_DEV_ID_X550EM_A_10G_T
case|:
case|case
name|IXGBE_DEV_ID_X550EM_A_SFP
case|:
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
operator|=
name|ixgbe_read_phy_reg_x550a
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
operator|=
name|ixgbe_write_phy_reg_x550a
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
condition|)
name|hw
operator|->
name|phy
operator|.
name|phy_semaphore_mask
operator||=
name|IXGBE_GSSR_PHY1_SM
expr_stmt|;
else|else
name|hw
operator|->
name|phy
operator|.
name|phy_semaphore_mask
operator||=
name|IXGBE_GSSR_PHY0_SM
expr_stmt|;
break|break;
case|case
name|IXGBE_DEV_ID_X550EM_X_SFP
case|:
comment|/* set up for CS4227 usage */
name|hw
operator|->
name|phy
operator|.
name|phy_semaphore_mask
operator|=
name|IXGBE_GSSR_SHARED_I2C_SM
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Identify the PHY or SFP module */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|identify
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|==
name|IXGBE_ERR_SFP_NOT_SUPPORTED
operator|||
name|ret_val
operator|==
name|IXGBE_ERR_PHY_ADDR_INVALID
condition|)
return|return
name|ret_val
return|;
comment|/* Setup function pointers based on detected hardware */
name|ixgbe_init_mac_link_ops_X550em
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|sfp_type
operator|!=
name|ixgbe_sfp_type_unknown
condition|)
name|phy
operator|->
name|ops
operator|.
name|reset
operator|=
name|NULL
expr_stmt|;
comment|/* Set functions pointers based on phy type */
switch|switch
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
condition|)
block|{
case|case
name|ixgbe_phy_x550em_kx4
case|:
name|phy
operator|->
name|ops
operator|.
name|setup_link
operator|=
name|NULL
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|read_reg
operator|=
name|ixgbe_read_phy_reg_x550em
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|write_reg
operator|=
name|ixgbe_write_phy_reg_x550em
expr_stmt|;
break|break;
case|case
name|ixgbe_phy_x550em_kr
case|:
name|phy
operator|->
name|ops
operator|.
name|setup_link
operator|=
name|ixgbe_setup_kr_x550em
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|read_reg
operator|=
name|ixgbe_read_phy_reg_x550em
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|write_reg
operator|=
name|ixgbe_write_phy_reg_x550em
expr_stmt|;
break|break;
case|case
name|ixgbe_phy_x550em_xfi
case|:
comment|/* link is managed by HW */
name|phy
operator|->
name|ops
operator|.
name|setup_link
operator|=
name|NULL
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|read_reg
operator|=
name|ixgbe_read_phy_reg_x550em
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|write_reg
operator|=
name|ixgbe_write_phy_reg_x550em
expr_stmt|;
break|break;
case|case
name|ixgbe_phy_x550em_ext_t
case|:
comment|/* If internal link mode is XFI, then setup iXFI internal link, 		 * else setup KR now. 		 */
name|phy
operator|->
name|ops
operator|.
name|setup_internal_link
operator|=
name|ixgbe_setup_internal_phy_t_x550em
expr_stmt|;
comment|/* setup SW LPLU only for first revision of X550EM_x */
if|if
condition|(
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_X550EM_x
operator|)
operator|&&
operator|!
operator|(
name|IXGBE_FUSES0_REV_MASK
operator|&
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FUSES0_GROUP
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
name|phy
operator|->
name|ops
operator|.
name|enter_lplu
operator|=
name|ixgbe_enter_lplu_t_x550em
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|handle_lasi
operator|=
name|ixgbe_handle_lasi_ext_t_x550em
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|reset
operator|=
name|ixgbe_reset_phy_t_X550em
expr_stmt|;
break|break;
case|case
name|ixgbe_phy_sgmii
case|:
name|phy
operator|->
name|ops
operator|.
name|setup_link
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|ixgbe_phy_fw
case|:
name|phy
operator|->
name|ops
operator|.
name|setup_link
operator|=
name|ixgbe_setup_fw_link
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|reset
operator|=
name|ixgbe_reset_phy_fw
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_set_mdio_speed - Set MDIO clock speed  *  @hw: pointer to hardware structure  */
end_comment

begin_function
specifier|static
name|void
name|ixgbe_set_mdio_speed
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|hlreg0
decl_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|device_id
condition|)
block|{
case|case
name|IXGBE_DEV_ID_X550EM_X_10G_T
case|:
case|case
name|IXGBE_DEV_ID_X550EM_A_SGMII
case|:
case|case
name|IXGBE_DEV_ID_X550EM_A_SGMII_L
case|:
case|case
name|IXGBE_DEV_ID_X550EM_A_10G_T
case|:
case|case
name|IXGBE_DEV_ID_X550EM_A_SFP
case|:
case|case
name|IXGBE_DEV_ID_X550EM_A_QSFP
case|:
comment|/* Config MDIO clock speed before the first MDIO PHY access */
name|hlreg0
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_HLREG0
argument_list|)
expr_stmt|;
name|hlreg0
operator|&=
operator|~
name|IXGBE_HLREG0_MDCSPD
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_HLREG0
argument_list|,
name|hlreg0
argument_list|)
expr_stmt|;
break|break;
case|case
name|IXGBE_DEV_ID_X550EM_A_1G_T
case|:
case|case
name|IXGBE_DEV_ID_X550EM_A_1G_T_L
case|:
comment|/* Select fast MDIO clock speed for these devices */
name|hlreg0
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_HLREG0
argument_list|)
expr_stmt|;
name|hlreg0
operator||=
name|IXGBE_HLREG0_MDCSPD
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_HLREG0
argument_list|,
name|hlreg0
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/**  *  ixgbe_reset_hw_X550em - Perform hardware reset  *  @hw: pointer to hardware structure  *  *  Resets the hardware by resetting the transmit and receive units, masks  *  and clears all interrupts, perform a PHY reset, and perform a link (MAC)  *  reset.  */
end_comment

begin_function
name|s32
name|ixgbe_reset_hw_X550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|ixgbe_link_speed
name|link_speed
decl_stmt|;
name|s32
name|status
decl_stmt|;
name|u32
name|ctrl
init|=
literal|0
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|bool
name|link_up
init|=
name|FALSE
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_reset_hw_X550em"
argument_list|)
expr_stmt|;
comment|/* Call adapter stop to disable Tx/Rx and clear interrupts */
name|status
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|stop_adapter
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
block|{
name|DEBUGOUT1
argument_list|(
literal|"Failed to stop adapter, STATUS = %d\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
comment|/* flush pending Tx transactions */
name|ixgbe_clear_tx_pending
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|ixgbe_set_mdio_speed
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* PHY ops must be identified and initialized prior to reset */
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|init
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
name|DEBUGOUT1
argument_list|(
literal|"Failed to initialize PHY ops, STATUS = %d\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|IXGBE_ERR_SFP_NOT_SUPPORTED
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Returning from reset HW due to PHY init failure\n"
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
comment|/* start the external PHY */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|ixgbe_phy_x550em_ext_t
condition|)
block|{
name|status
operator|=
name|ixgbe_init_ext_t_x550em
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|DEBUGOUT1
argument_list|(
literal|"Failed to start the external PHY, STATUS = %d\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
block|}
comment|/* Setup SFP module if there is one present. */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|sfp_setup_needed
condition|)
block|{
name|status
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|setup_sfp
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|sfp_setup_needed
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|==
name|IXGBE_ERR_SFP_NOT_SUPPORTED
condition|)
return|return
name|status
return|;
comment|/* Reset PHY */
if|if
condition|(
operator|!
name|hw
operator|->
name|phy
operator|.
name|reset_disable
operator|&&
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|reset
condition|)
block|{
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|reset
argument_list|(
name|hw
argument_list|)
operator|==
name|IXGBE_ERR_OVERTEMP
condition|)
return|return
name|IXGBE_ERR_OVERTEMP
return|;
block|}
name|mac_reset_top
label|:
comment|/* Issue global reset to the MAC.  Needs to be SW reset if link is up. 	 * If link reset is used when link is up, it might reset the PHY when 	 * mng is using it.  If link is down or the flag to force full link 	 * reset is set, then perform link reset. 	 */
name|ctrl
operator|=
name|IXGBE_CTRL_LNK_RST
expr_stmt|;
if|if
condition|(
operator|!
name|hw
operator|->
name|force_full_reset
condition|)
block|{
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|check_link
argument_list|(
name|hw
argument_list|,
operator|&
name|link_speed
argument_list|,
operator|&
name|link_up
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_up
condition|)
name|ctrl
operator|=
name|IXGBE_CTRL_RST
expr_stmt|;
block|}
name|ctrl
operator||=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CTRL
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Poll for reset bit to self-clear meaning reset is complete */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ctrl
operator|&
name|IXGBE_CTRL_RST_MASK
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|ctrl
operator|&
name|IXGBE_CTRL_RST_MASK
condition|)
block|{
name|status
operator|=
name|IXGBE_ERR_RESET_FAILED
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Reset polling failed to complete.\n"
argument_list|)
expr_stmt|;
block|}
name|msec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
comment|/* Double resets are required for recovery from certain error 	 * conditions.  Between resets, it is necessary to stall to 	 * allow time for any pending HW events to complete. 	 */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|flags
operator|&
name|IXGBE_FLAGS_DOUBLE_RESET_REQUIRED
condition|)
block|{
name|hw
operator|->
name|mac
operator|.
name|flags
operator|&=
operator|~
name|IXGBE_FLAGS_DOUBLE_RESET_REQUIRED
expr_stmt|;
goto|goto
name|mac_reset_top
goto|;
block|}
comment|/* Store the permanent mac address */
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|get_mac_addr
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|perm_addr
argument_list|)
expr_stmt|;
comment|/* Store MAC address from RAR0, clear receive address registers, and 	 * clear the multicast table.  Also reset num_rar_entries to 128, 	 * since we modify this value when programming the SAN MAC address. 	 */
name|hw
operator|->
name|mac
operator|.
name|num_rar_entries
operator|=
literal|128
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|init_rx_addrs
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|ixgbe_set_mdio_speed
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|device_id
operator|==
name|IXGBE_DEV_ID_X550EM_X_SFP
condition|)
name|ixgbe_setup_mux_ctl
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
name|DEBUGOUT1
argument_list|(
literal|"Reset HW failed, STATUS = %d\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_init_ext_t_x550em - Start (unstall) the external Base T PHY.  * @hw: pointer to hardware structure  */
end_comment

begin_function
name|s32
name|ixgbe_init_ext_t_x550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|status
decl_stmt|;
name|u16
name|reg
decl_stmt|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_TX_VENDOR_ALARMS_3
argument_list|,
name|IXGBE_MDIO_PMA_PMD_DEV_TYPE
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* If PHY FW reset completed bit is set then this is the first 	 * SW instance after a power on so the PHY FW must be un-stalled. 	 */
if|if
condition|(
name|reg
operator|&
name|IXGBE_MDIO_TX_VENDOR_ALARMS_3_RST_MASK
condition|)
block|{
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_GLOBAL_RES_PR_10
argument_list|,
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|reg
operator|&=
operator|~
name|IXGBE_MDIO_POWER_UP_STALL
expr_stmt|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_GLOBAL_RES_PR_10
argument_list|,
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_setup_kr_x550em - Configure the KR PHY.  *  @hw: pointer to hardware structure  **/
end_comment

begin_function
name|s32
name|ixgbe_setup_kr_x550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
comment|/* leave link alone for 2.5G */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator|&
name|IXGBE_LINK_SPEED_2_5GB_FULL
condition|)
return|return
name|IXGBE_SUCCESS
return|;
return|return
name|ixgbe_setup_kr_speed_x550em
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_setup_mac_link_sfp_x550em - Setup internal/external the PHY for SFP  *  @hw: pointer to hardware structure  *  *  Configure the external PHY and the integrated KR PHY for SFP support.  **/
end_comment

begin_function
name|s32
name|ixgbe_setup_mac_link_sfp_x550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
name|speed
parameter_list|,
name|bool
name|autoneg_wait_to_complete
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u16
name|reg_slice
decl_stmt|,
name|reg_val
decl_stmt|;
name|bool
name|setup_linear
init|=
name|FALSE
decl_stmt|;
name|UNREFERENCED_1PARAMETER
argument_list|(
name|autoneg_wait_to_complete
argument_list|)
expr_stmt|;
comment|/* Check if SFP module is supported and linear */
name|ret_val
operator|=
name|ixgbe_supported_sfp_modules_X550em
argument_list|(
name|hw
argument_list|,
operator|&
name|setup_linear
argument_list|)
expr_stmt|;
comment|/* If no SFP module present, then return success. Return success since 	 * there is no reason to configure CS4227 and SFP not present error is 	 * not excepted in the setup MAC link flow. 	 */
if|if
condition|(
name|ret_val
operator|==
name|IXGBE_ERR_SFP_NOT_PRESENT
condition|)
return|return
name|IXGBE_SUCCESS
return|;
if|if
condition|(
name|ret_val
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|ret_val
return|;
comment|/* Configure internal PHY for KR/KX. */
name|ixgbe_setup_kr_speed_x550em
argument_list|(
name|hw
argument_list|,
name|speed
argument_list|)
expr_stmt|;
comment|/* Configure CS4227 LINE side to proper mode. */
name|reg_slice
operator|=
name|IXGBE_CS4227_LINE_SPARE24_LSB
operator|+
operator|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
operator|<<
literal|12
operator|)
expr_stmt|;
if|if
condition|(
name|setup_linear
condition|)
name|reg_val
operator|=
operator|(
name|IXGBE_CS4227_EDC_MODE_CX1
operator|<<
literal|1
operator|)
operator||
literal|0x1
expr_stmt|;
else|else
name|reg_val
operator|=
operator|(
name|IXGBE_CS4227_EDC_MODE_SR
operator|<<
literal|1
operator|)
operator||
literal|0x1
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|link
operator|.
name|ops
operator|.
name|write_link
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|link
operator|.
name|addr
argument_list|,
name|reg_slice
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_setup_sfi_x550a - Configure the internal PHY for native SFI mode  *  @hw: pointer to hardware structure  *  @speed: the link speed to force  *  *  Configures the integrated PHY for native SFI mode. Used to connect the  *  internal PHY directly to an SFP cage, without autonegotiation.  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_setup_sfi_x550a
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
modifier|*
name|speed
parameter_list|)
block|{
name|struct
name|ixgbe_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|s32
name|status
decl_stmt|;
name|u32
name|reg_val
decl_stmt|;
comment|/* Disable all AN and force speed to 10G Serial. */
name|status
operator|=
name|mac
operator|->
name|ops
operator|.
name|read_iosf_sb_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_PMD_FLX_MASK_ST20
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
operator|&
name|reg_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|reg_val
operator|&=
operator|~
name|IXGBE_KRM_PMD_FLX_MASK_ST20_AN_EN
expr_stmt|;
name|reg_val
operator|&=
operator|~
name|IXGBE_KRM_PMD_FLX_MASK_ST20_AN37_EN
expr_stmt|;
name|reg_val
operator|&=
operator|~
name|IXGBE_KRM_PMD_FLX_MASK_ST20_SGMII_EN
expr_stmt|;
name|reg_val
operator|&=
operator|~
name|IXGBE_KRM_PMD_FLX_MASK_ST20_SPEED_MASK
expr_stmt|;
comment|/* Select forced link speed for internal PHY. */
switch|switch
condition|(
operator|*
name|speed
condition|)
block|{
case|case
name|IXGBE_LINK_SPEED_10GB_FULL
case|:
name|reg_val
operator||=
name|IXGBE_KRM_PMD_FLX_MASK_ST20_SPEED_10G
expr_stmt|;
break|break;
case|case
name|IXGBE_LINK_SPEED_1GB_FULL
case|:
name|reg_val
operator||=
name|IXGBE_KRM_PMD_FLX_MASK_ST20_SPEED_1G
expr_stmt|;
break|break;
default|default:
comment|/* Other link speeds are not supported by internal PHY. */
return|return
name|IXGBE_ERR_LINK_SETUP
return|;
block|}
name|status
operator|=
name|mac
operator|->
name|ops
operator|.
name|write_iosf_sb_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_PMD_FLX_MASK_ST20
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
comment|/* Toggle port SW reset by AN reset. */
name|status
operator|=
name|ixgbe_restart_an_internal_phy_x550em
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_setup_mac_link_sfp_x550a - Setup internal PHY for SFP  *  @hw: pointer to hardware structure  *  *  Configure the the integrated PHY for SFP support.  **/
end_comment

begin_function
name|s32
name|ixgbe_setup_mac_link_sfp_x550a
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
name|speed
parameter_list|,
name|bool
name|autoneg_wait_to_complete
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u16
name|reg_phy_ext
decl_stmt|;
name|bool
name|setup_linear
init|=
name|FALSE
decl_stmt|;
name|u32
name|reg_slice
decl_stmt|,
name|reg_phy_int
decl_stmt|,
name|slice_offset
decl_stmt|;
name|UNREFERENCED_1PARAMETER
argument_list|(
name|autoneg_wait_to_complete
argument_list|)
expr_stmt|;
comment|/* Check if SFP module is supported and linear */
name|ret_val
operator|=
name|ixgbe_supported_sfp_modules_X550em
argument_list|(
name|hw
argument_list|,
operator|&
name|setup_linear
argument_list|)
expr_stmt|;
comment|/* If no SFP module present, then return success. Return success since 	 * SFP not present error is not excepted in the setup MAC link flow. 	 */
if|if
condition|(
name|ret_val
operator|==
name|IXGBE_ERR_SFP_NOT_PRESENT
condition|)
return|return
name|IXGBE_SUCCESS
return|;
if|if
condition|(
name|ret_val
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
name|hw
operator|->
name|device_id
operator|==
name|IXGBE_DEV_ID_X550EM_A_SFP_N
condition|)
block|{
comment|/* Configure internal PHY for native SFI based on module type */
name|ret_val
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|read_iosf_sb_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_PMD_FLX_MASK_ST20
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
operator|&
name|reg_phy_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|ret_val
return|;
name|reg_phy_int
operator|&=
name|IXGBE_KRM_PMD_FLX_MASK_ST20_SFI_10G_DA
expr_stmt|;
if|if
condition|(
operator|!
name|setup_linear
condition|)
name|reg_phy_int
operator||=
name|IXGBE_KRM_PMD_FLX_MASK_ST20_SFI_10G_SR
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|write_iosf_sb_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_PMD_FLX_MASK_ST20
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
name|reg_phy_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|ret_val
return|;
comment|/* Setup SFI internal link. */
name|ret_val
operator|=
name|ixgbe_setup_sfi_x550a
argument_list|(
name|hw
argument_list|,
operator|&
name|speed
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Configure internal PHY for KR/KX. */
name|ixgbe_setup_kr_speed_x550em
argument_list|(
name|hw
argument_list|,
name|speed
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|addr
operator|==
literal|0x0
operator|||
name|hw
operator|->
name|phy
operator|.
name|addr
operator|==
literal|0xFFFF
condition|)
block|{
comment|/* Find Address */
name|DEBUGOUT
argument_list|(
literal|"Invalid NW_MNG_IF_SEL.MDIO_PHY_ADD value\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_PHY_ADDR_INVALID
return|;
block|}
comment|/* Get external PHY SKU id */
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_CS4227_EFUSE_PDF_SKU
argument_list|,
name|IXGBE_MDIO_ZERO_DEV_TYPE
argument_list|,
operator|&
name|reg_phy_ext
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|ret_val
return|;
comment|/* When configuring quad port CS4223, the MAC instance is part 		 * of the slice offset. 		 */
if|if
condition|(
name|reg_phy_ext
operator|==
name|IXGBE_CS4223_SKU_ID
condition|)
name|slice_offset
operator|=
operator|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
operator|+
operator|(
name|hw
operator|->
name|bus
operator|.
name|instance_id
operator|<<
literal|1
operator|)
operator|)
operator|<<
literal|12
expr_stmt|;
else|else
name|slice_offset
operator|=
name|hw
operator|->
name|bus
operator|.
name|lan_id
operator|<<
literal|12
expr_stmt|;
comment|/* Configure CS4227/CS4223 LINE side to proper mode. */
name|reg_slice
operator|=
name|IXGBE_CS4227_LINE_SPARE24_LSB
operator|+
name|slice_offset
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|reg_slice
argument_list|,
name|IXGBE_MDIO_ZERO_DEV_TYPE
argument_list|,
operator|&
name|reg_phy_ext
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|ret_val
return|;
name|reg_phy_ext
operator|&=
operator|~
operator|(
operator|(
name|IXGBE_CS4227_EDC_MODE_CX1
operator|<<
literal|1
operator|)
operator||
operator|(
name|IXGBE_CS4227_EDC_MODE_SR
operator|<<
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|setup_linear
condition|)
name|reg_phy_ext
operator|=
operator|(
name|IXGBE_CS4227_EDC_MODE_CX1
operator|<<
literal|1
operator|)
operator||
literal|0x1
expr_stmt|;
else|else
name|reg_phy_ext
operator|=
operator|(
name|IXGBE_CS4227_EDC_MODE_SR
operator|<<
literal|1
operator|)
operator||
literal|0x1
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|reg_slice
argument_list|,
name|IXGBE_MDIO_ZERO_DEV_TYPE
argument_list|,
name|reg_phy_ext
argument_list|)
expr_stmt|;
comment|/* Flush previous write with a read */
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|reg_slice
argument_list|,
name|IXGBE_MDIO_ZERO_DEV_TYPE
argument_list|,
operator|&
name|reg_phy_ext
argument_list|)
expr_stmt|;
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_setup_ixfi_x550em_x - MAC specific iXFI configuration  *  @hw: pointer to hardware structure  *  *  iXfI configuration needed for ixgbe_mac_X550EM_x devices.  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_setup_ixfi_x550em_x
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|ixgbe_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|s32
name|status
decl_stmt|;
name|u32
name|reg_val
decl_stmt|;
comment|/* Disable training protocol FSM. */
name|status
operator|=
name|mac
operator|->
name|ops
operator|.
name|read_iosf_sb_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_RX_TRN_LINKUP_CTRL
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
operator|&
name|reg_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|reg_val
operator||=
name|IXGBE_KRM_RX_TRN_LINKUP_CTRL_CONV_WO_PROTOCOL
expr_stmt|;
name|status
operator|=
name|mac
operator|->
name|ops
operator|.
name|write_iosf_sb_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_RX_TRN_LINKUP_CTRL
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* Disable Flex from training TXFFE. */
name|status
operator|=
name|mac
operator|->
name|ops
operator|.
name|read_iosf_sb_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_DSP_TXFFE_STATE_4
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
operator|&
name|reg_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|reg_val
operator|&=
operator|~
name|IXGBE_KRM_DSP_TXFFE_STATE_C0_EN
expr_stmt|;
name|reg_val
operator|&=
operator|~
name|IXGBE_KRM_DSP_TXFFE_STATE_CP1_CN1_EN
expr_stmt|;
name|reg_val
operator|&=
operator|~
name|IXGBE_KRM_DSP_TXFFE_STATE_CO_ADAPT_EN
expr_stmt|;
name|status
operator|=
name|mac
operator|->
name|ops
operator|.
name|write_iosf_sb_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_DSP_TXFFE_STATE_4
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|status
operator|=
name|mac
operator|->
name|ops
operator|.
name|read_iosf_sb_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_DSP_TXFFE_STATE_5
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
operator|&
name|reg_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|reg_val
operator|&=
operator|~
name|IXGBE_KRM_DSP_TXFFE_STATE_C0_EN
expr_stmt|;
name|reg_val
operator|&=
operator|~
name|IXGBE_KRM_DSP_TXFFE_STATE_CP1_CN1_EN
expr_stmt|;
name|reg_val
operator|&=
operator|~
name|IXGBE_KRM_DSP_TXFFE_STATE_CO_ADAPT_EN
expr_stmt|;
name|status
operator|=
name|mac
operator|->
name|ops
operator|.
name|write_iosf_sb_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_DSP_TXFFE_STATE_5
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* Enable override for coefficients. */
name|status
operator|=
name|mac
operator|->
name|ops
operator|.
name|read_iosf_sb_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_TX_COEFF_CTRL_1
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
operator|&
name|reg_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|reg_val
operator||=
name|IXGBE_KRM_TX_COEFF_CTRL_1_OVRRD_EN
expr_stmt|;
name|reg_val
operator||=
name|IXGBE_KRM_TX_COEFF_CTRL_1_CZERO_EN
expr_stmt|;
name|reg_val
operator||=
name|IXGBE_KRM_TX_COEFF_CTRL_1_CPLUS1_OVRRD_EN
expr_stmt|;
name|reg_val
operator||=
name|IXGBE_KRM_TX_COEFF_CTRL_1_CMINUS1_OVRRD_EN
expr_stmt|;
name|status
operator|=
name|mac
operator|->
name|ops
operator|.
name|write_iosf_sb_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_TX_COEFF_CTRL_1
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_setup_ixfi_x550em - Configure the KR PHY for iXFI mode.  *  @hw: pointer to hardware structure  *  @speed: the link speed to force  *  *  Configures the integrated KR PHY to use iXFI mode. Used to connect an  *  internal and external PHY at a specific speed, without autonegotiation.  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_setup_ixfi_x550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
modifier|*
name|speed
parameter_list|)
block|{
name|struct
name|ixgbe_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|s32
name|status
decl_stmt|;
name|u32
name|reg_val
decl_stmt|;
comment|/* iXFI is only supported with X552 */
if|if
condition|(
name|mac
operator|->
name|type
operator|!=
name|ixgbe_mac_X550EM_x
condition|)
return|return
name|IXGBE_ERR_LINK_SETUP
return|;
comment|/* Disable AN and force speed to 10G Serial. */
name|status
operator|=
name|mac
operator|->
name|ops
operator|.
name|read_iosf_sb_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_LINK_CTRL_1
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
operator|&
name|reg_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|reg_val
operator|&=
operator|~
name|IXGBE_KRM_LINK_CTRL_1_TETH_AN_ENABLE
expr_stmt|;
name|reg_val
operator|&=
operator|~
name|IXGBE_KRM_LINK_CTRL_1_TETH_FORCE_SPEED_MASK
expr_stmt|;
comment|/* Select forced link speed for internal PHY. */
switch|switch
condition|(
operator|*
name|speed
condition|)
block|{
case|case
name|IXGBE_LINK_SPEED_10GB_FULL
case|:
name|reg_val
operator||=
name|IXGBE_KRM_LINK_CTRL_1_TETH_FORCE_SPEED_10G
expr_stmt|;
break|break;
case|case
name|IXGBE_LINK_SPEED_1GB_FULL
case|:
name|reg_val
operator||=
name|IXGBE_KRM_LINK_CTRL_1_TETH_FORCE_SPEED_1G
expr_stmt|;
break|break;
default|default:
comment|/* Other link speeds are not supported by internal KR PHY. */
return|return
name|IXGBE_ERR_LINK_SETUP
return|;
block|}
name|status
operator|=
name|mac
operator|->
name|ops
operator|.
name|write_iosf_sb_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_LINK_CTRL_1
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* Additional configuration needed for x550em_x */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_X550EM_x
condition|)
block|{
name|status
operator|=
name|ixgbe_setup_ixfi_x550em_x
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
block|}
comment|/* Toggle port SW reset by AN reset. */
name|status
operator|=
name|ixgbe_restart_an_internal_phy_x550em
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_ext_phy_t_x550em_get_link - Get ext phy link status  * @hw: address of hardware structure  * @link_up: address of boolean to indicate link status  *  * Returns error code if unable to get link status.  */
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_ext_phy_t_x550em_get_link
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|bool
modifier|*
name|link_up
parameter_list|)
block|{
name|u32
name|ret
decl_stmt|;
name|u16
name|autoneg_status
decl_stmt|;
operator|*
name|link_up
operator|=
name|FALSE
expr_stmt|;
comment|/* read this twice back to back to indicate current status */
name|ret
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_STATUS
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
operator|&
name|autoneg_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_STATUS
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
operator|&
name|autoneg_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|ret
return|;
operator|*
name|link_up
operator|=
operator|!
operator|!
operator|(
name|autoneg_status
operator|&
name|IXGBE_MDIO_AUTO_NEG_LINK_STATUS
operator|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_setup_internal_phy_t_x550em - Configure KR PHY to X557 link  * @hw: point to hardware structure  *  * Configures the link between the integrated KR PHY and the external X557 PHY  * The driver will call this function when it gets a link status change  * interrupt from the X557 PHY. This function configures the link speed  * between the PHYs to match the link speed of the BASE-T link.  *  * A return of a non-zero value indicates an error, and the base driver should  * not report link up.  */
end_comment

begin_function
name|s32
name|ixgbe_setup_internal_phy_t_x550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|ixgbe_link_speed
name|force_speed
decl_stmt|;
name|bool
name|link_up
decl_stmt|;
name|u32
name|status
decl_stmt|;
name|u16
name|speed
decl_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|get_media_type
argument_list|(
name|hw
argument_list|)
operator|!=
name|ixgbe_media_type_copper
condition|)
return|return
name|IXGBE_ERR_CONFIG
return|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_X550EM_x
operator|&&
operator|!
operator|(
name|hw
operator|->
name|phy
operator|.
name|nw_mng_if_sel
operator|&
name|IXGBE_NW_MNG_IF_SEL_INT_PHY_MODE
operator|)
condition|)
block|{
comment|/* If link is down, there is no setup necessary so return  */
name|status
operator|=
name|ixgbe_ext_phy_t_x550em_get_link
argument_list|(
name|hw
argument_list|,
operator|&
name|link_up
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
if|if
condition|(
operator|!
name|link_up
condition|)
return|return
name|IXGBE_SUCCESS
return|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_VENDOR_STAT
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
operator|&
name|speed
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* If link is still down - no setup is required so return */
name|status
operator|=
name|ixgbe_ext_phy_t_x550em_get_link
argument_list|(
name|hw
argument_list|,
operator|&
name|link_up
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
if|if
condition|(
operator|!
name|link_up
condition|)
return|return
name|IXGBE_SUCCESS
return|;
comment|/* clear everything but the speed and duplex bits */
name|speed
operator|&=
name|IXGBE_MDIO_AUTO_NEG_VENDOR_STATUS_MASK
expr_stmt|;
switch|switch
condition|(
name|speed
condition|)
block|{
case|case
name|IXGBE_MDIO_AUTO_NEG_VENDOR_STATUS_10GB_FULL
case|:
name|force_speed
operator|=
name|IXGBE_LINK_SPEED_10GB_FULL
expr_stmt|;
break|break;
case|case
name|IXGBE_MDIO_AUTO_NEG_VENDOR_STATUS_1GB_FULL
case|:
name|force_speed
operator|=
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
break|break;
default|default:
comment|/* Internal PHY does not support anything else */
return|return
name|IXGBE_ERR_INVALID_LINK_SETTINGS
return|;
block|}
return|return
name|ixgbe_setup_ixfi_x550em
argument_list|(
name|hw
argument_list|,
operator|&
name|force_speed
argument_list|)
return|;
block|}
else|else
block|{
name|speed
operator|=
name|IXGBE_LINK_SPEED_10GB_FULL
operator||
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
return|return
name|ixgbe_setup_kr_speed_x550em
argument_list|(
name|hw
argument_list|,
name|speed
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/**  *  ixgbe_setup_phy_loopback_x550em - Configure the KR PHY for loopback.  *  @hw: pointer to hardware structure  *  *  Configures the integrated KR PHY to use internal loopback mode.  **/
end_comment

begin_function
name|s32
name|ixgbe_setup_phy_loopback_x550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|u32
name|reg_val
decl_stmt|;
comment|/* Disable AN and force speed to 10G Serial. */
name|status
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|read_iosf_sb_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_LINK_CTRL_1
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
operator|&
name|reg_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|reg_val
operator|&=
operator|~
name|IXGBE_KRM_LINK_CTRL_1_TETH_AN_ENABLE
expr_stmt|;
name|reg_val
operator|&=
operator|~
name|IXGBE_KRM_LINK_CTRL_1_TETH_FORCE_SPEED_MASK
expr_stmt|;
name|reg_val
operator||=
name|IXGBE_KRM_LINK_CTRL_1_TETH_FORCE_SPEED_10G
expr_stmt|;
name|status
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|write_iosf_sb_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_LINK_CTRL_1
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* Set near-end loopback clocks. */
name|status
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|read_iosf_sb_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_PORT_CAR_GEN_CTRL
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
operator|&
name|reg_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|reg_val
operator||=
name|IXGBE_KRM_PORT_CAR_GEN_CTRL_NELB_32B
expr_stmt|;
name|reg_val
operator||=
name|IXGBE_KRM_PORT_CAR_GEN_CTRL_NELB_KRPCS
expr_stmt|;
name|status
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|write_iosf_sb_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_PORT_CAR_GEN_CTRL
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* Set loopback enable. */
name|status
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|read_iosf_sb_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_PMD_DFX_BURNIN
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
operator|&
name|reg_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|reg_val
operator||=
name|IXGBE_KRM_PMD_DFX_BURNIN_TX_RX_KR_LB_MASK
expr_stmt|;
name|status
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|write_iosf_sb_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_PMD_DFX_BURNIN
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* Training bypass. */
name|status
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|read_iosf_sb_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_RX_TRN_LINKUP_CTRL
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
operator|&
name|reg_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|reg_val
operator||=
name|IXGBE_KRM_RX_TRN_LINKUP_CTRL_PROTOCOL_BYPASS
expr_stmt|;
name|status
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|write_iosf_sb_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_RX_TRN_LINKUP_CTRL
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_read_ee_hostif_X550 - Read EEPROM word using a host interface command  *  assuming that the semaphore is already obtained.  *  @hw: pointer to hardware structure  *  @offset: offset of  word in the EEPROM to read  *  @data: word read from the EEPROM  *  *  Reads a 16 bit word from the EEPROM using the hostif.  **/
end_comment

begin_function
name|s32
name|ixgbe_read_ee_hostif_X550
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
specifier|const
name|u32
name|mask
init|=
name|IXGBE_GSSR_SW_MNG_SM
operator||
name|IXGBE_GSSR_EEP_SM
decl_stmt|;
name|struct
name|ixgbe_hic_read_shadow_ram
name|buffer
decl_stmt|;
name|s32
name|status
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_read_ee_hostif_X550"
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|hdr
operator|.
name|req
operator|.
name|cmd
operator|=
name|FW_READ_SHADOW_RAM_CMD
expr_stmt|;
name|buffer
operator|.
name|hdr
operator|.
name|req
operator|.
name|buf_lenh
operator|=
literal|0
expr_stmt|;
name|buffer
operator|.
name|hdr
operator|.
name|req
operator|.
name|buf_lenl
operator|=
name|FW_READ_SHADOW_RAM_LEN
expr_stmt|;
name|buffer
operator|.
name|hdr
operator|.
name|req
operator|.
name|checksum
operator|=
name|FW_DEFAULT_CHECKSUM
expr_stmt|;
comment|/* convert offset from words to bytes */
name|buffer
operator|.
name|address
operator|=
name|IXGBE_CPU_TO_BE32
argument_list|(
name|offset
operator|*
literal|2
argument_list|)
expr_stmt|;
comment|/* one word */
name|buffer
operator|.
name|length
operator|=
name|IXGBE_CPU_TO_BE16
argument_list|(
sizeof|sizeof
argument_list|(
name|u16
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|acquire_swfw_sync
argument_list|(
name|hw
argument_list|,
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|status
return|;
name|status
operator|=
name|ixgbe_hic_unlocked
argument_list|(
name|hw
argument_list|,
operator|(
name|u32
operator|*
operator|)
operator|&
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|IXGBE_HI_COMMAND_TIMEOUT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|status
condition|)
block|{
operator|*
name|data
operator|=
operator|(
name|u16
operator|)
name|IXGBE_READ_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|IXGBE_FLEX_MNG
argument_list|,
name|FW_NVM_DATA_OFFSET
argument_list|)
expr_stmt|;
block|}
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|mask
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_read_ee_hostif_buffer_X550- Read EEPROM word(s) using hostif  *  @hw: pointer to hardware structure  *  @offset: offset of  word in the EEPROM to read  *  @words: number of words  *  @data: word(s) read from the EEPROM  *  *  Reads a 16 bit word(s) from the EEPROM using the hostif.  **/
end_comment

begin_function
name|s32
name|ixgbe_read_ee_hostif_buffer_X550
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
name|words
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
specifier|const
name|u32
name|mask
init|=
name|IXGBE_GSSR_SW_MNG_SM
operator||
name|IXGBE_GSSR_EEP_SM
decl_stmt|;
name|struct
name|ixgbe_hic_read_shadow_ram
name|buffer
decl_stmt|;
name|u32
name|current_word
init|=
literal|0
decl_stmt|;
name|u16
name|words_to_read
decl_stmt|;
name|s32
name|status
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_read_ee_hostif_buffer_X550"
argument_list|)
expr_stmt|;
comment|/* Take semaphore for the entire operation. */
name|status
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|acquire_swfw_sync
argument_list|(
name|hw
argument_list|,
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM read buffer - semaphore failed\n"
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
while|while
condition|(
name|words
condition|)
block|{
if|if
condition|(
name|words
operator|>
name|FW_MAX_READ_BUFFER_SIZE
operator|/
literal|2
condition|)
name|words_to_read
operator|=
name|FW_MAX_READ_BUFFER_SIZE
operator|/
literal|2
expr_stmt|;
else|else
name|words_to_read
operator|=
name|words
expr_stmt|;
name|buffer
operator|.
name|hdr
operator|.
name|req
operator|.
name|cmd
operator|=
name|FW_READ_SHADOW_RAM_CMD
expr_stmt|;
name|buffer
operator|.
name|hdr
operator|.
name|req
operator|.
name|buf_lenh
operator|=
literal|0
expr_stmt|;
name|buffer
operator|.
name|hdr
operator|.
name|req
operator|.
name|buf_lenl
operator|=
name|FW_READ_SHADOW_RAM_LEN
expr_stmt|;
name|buffer
operator|.
name|hdr
operator|.
name|req
operator|.
name|checksum
operator|=
name|FW_DEFAULT_CHECKSUM
expr_stmt|;
comment|/* convert offset from words to bytes */
name|buffer
operator|.
name|address
operator|=
name|IXGBE_CPU_TO_BE32
argument_list|(
operator|(
name|offset
operator|+
name|current_word
operator|)
operator|*
literal|2
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|length
operator|=
name|IXGBE_CPU_TO_BE16
argument_list|(
name|words_to_read
operator|*
literal|2
argument_list|)
expr_stmt|;
name|status
operator|=
name|ixgbe_hic_unlocked
argument_list|(
name|hw
argument_list|,
operator|(
name|u32
operator|*
operator|)
operator|&
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|IXGBE_HI_COMMAND_TIMEOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Host interface command failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words_to_read
condition|;
name|i
operator|++
control|)
block|{
name|u32
name|reg
init|=
name|IXGBE_FLEX_MNG
operator|+
operator|(
name|FW_NVM_DATA_OFFSET
operator|<<
literal|2
operator|)
operator|+
literal|2
operator|*
name|i
decl_stmt|;
name|u32
name|value
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|reg
argument_list|)
decl_stmt|;
name|data
index|[
name|current_word
index|]
operator|=
call|(
name|u16
call|)
argument_list|(
name|value
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|current_word
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|words_to_read
condition|)
block|{
name|value
operator|>>=
literal|16
expr_stmt|;
name|data
index|[
name|current_word
index|]
operator|=
call|(
name|u16
call|)
argument_list|(
name|value
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|current_word
operator|++
expr_stmt|;
block|}
block|}
name|words
operator|-=
name|words_to_read
expr_stmt|;
block|}
name|out
label|:
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|mask
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_write_ee_hostif_X550 - Write EEPROM word using hostif  *  @hw: pointer to hardware structure  *  @offset: offset of  word in the EEPROM to write  *  @data: word write to the EEPROM  *  *  Write a 16 bit word to the EEPROM using the hostif.  **/
end_comment

begin_function
name|s32
name|ixgbe_write_ee_hostif_data_X550
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
name|data
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|struct
name|ixgbe_hic_write_shadow_ram
name|buffer
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_write_ee_hostif_data_X550"
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|hdr
operator|.
name|req
operator|.
name|cmd
operator|=
name|FW_WRITE_SHADOW_RAM_CMD
expr_stmt|;
name|buffer
operator|.
name|hdr
operator|.
name|req
operator|.
name|buf_lenh
operator|=
literal|0
expr_stmt|;
name|buffer
operator|.
name|hdr
operator|.
name|req
operator|.
name|buf_lenl
operator|=
name|FW_WRITE_SHADOW_RAM_LEN
expr_stmt|;
name|buffer
operator|.
name|hdr
operator|.
name|req
operator|.
name|checksum
operator|=
name|FW_DEFAULT_CHECKSUM
expr_stmt|;
comment|/* one word */
name|buffer
operator|.
name|length
operator|=
name|IXGBE_CPU_TO_BE16
argument_list|(
sizeof|sizeof
argument_list|(
name|u16
argument_list|)
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|data
operator|=
name|data
expr_stmt|;
name|buffer
operator|.
name|address
operator|=
name|IXGBE_CPU_TO_BE32
argument_list|(
name|offset
operator|*
literal|2
argument_list|)
expr_stmt|;
name|status
operator|=
name|ixgbe_host_interface_command
argument_list|(
name|hw
argument_list|,
operator|(
name|u32
operator|*
operator|)
operator|&
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|IXGBE_HI_COMMAND_TIMEOUT
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_write_ee_hostif_X550 - Write EEPROM word using hostif  *  @hw: pointer to hardware structure  *  @offset: offset of  word in the EEPROM to write  *  @data: word write to the EEPROM  *  *  Write a 16 bit word to the EEPROM using the hostif.  **/
end_comment

begin_function
name|s32
name|ixgbe_write_ee_hostif_X550
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
name|data
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_write_ee_hostif_X550"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|acquire_swfw_sync
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR_EEP_SM
argument_list|)
operator|==
name|IXGBE_SUCCESS
condition|)
block|{
name|status
operator|=
name|ixgbe_write_ee_hostif_data_X550
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR_EEP_SM
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"write ee hostif failed to get semaphore"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IXGBE_ERR_SWFW_SYNC
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_write_ee_hostif_buffer_X550 - Write EEPROM word(s) using hostif  *  @hw: pointer to hardware structure  *  @offset: offset of  word in the EEPROM to write  *  @words: number of words  *  @data: word(s) write to the EEPROM  *  *  Write a 16 bit word(s) to the EEPROM using the hostif.  **/
end_comment

begin_function
name|s32
name|ixgbe_write_ee_hostif_buffer_X550
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
name|words
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u32
name|i
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_write_ee_hostif_buffer_X550"
argument_list|)
expr_stmt|;
comment|/* Take semaphore for the entire operation. */
name|status
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|acquire_swfw_sync
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR_EEP_SM
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM write buffer - semaphore failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|++
control|)
block|{
name|status
operator|=
name|ixgbe_write_ee_hostif_data_X550
argument_list|(
name|hw
argument_list|,
name|offset
operator|+
name|i
argument_list|,
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Eeprom buffered write failed\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|IXGBE_GSSR_EEP_SM
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_checksum_ptr_x550 - Checksum one pointer region  * @hw: pointer to hardware structure  * @ptr: pointer offset in eeprom  * @size: size of section pointed by ptr, if 0 first word will be used as size  * @csum: address of checksum to update  *  * Returns error status for any failure  */
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_checksum_ptr_x550
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|ptr
parameter_list|,
name|u16
name|size
parameter_list|,
name|u16
modifier|*
name|csum
parameter_list|,
name|u16
modifier|*
name|buffer
parameter_list|,
name|u32
name|buffer_size
parameter_list|)
block|{
name|u16
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|s32
name|status
decl_stmt|;
name|u16
name|length
decl_stmt|,
name|bufsz
decl_stmt|,
name|i
decl_stmt|,
name|start
decl_stmt|;
name|u16
modifier|*
name|local_buffer
decl_stmt|;
name|bufsz
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|buf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Read a chunk at the pointer location */
if|if
condition|(
operator|!
name|buffer
condition|)
block|{
name|status
operator|=
name|ixgbe_read_ee_hostif_buffer_X550
argument_list|(
name|hw
argument_list|,
name|ptr
argument_list|,
name|bufsz
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Failed to read EEPROM image\n"
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
name|local_buffer
operator|=
name|buf
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|buffer_size
operator|<
name|ptr
condition|)
return|return
name|IXGBE_ERR_PARAM
return|;
name|local_buffer
operator|=
operator|&
name|buffer
index|[
name|ptr
index|]
expr_stmt|;
block|}
if|if
condition|(
name|size
condition|)
block|{
name|start
operator|=
literal|0
expr_stmt|;
name|length
operator|=
name|size
expr_stmt|;
block|}
else|else
block|{
name|start
operator|=
literal|1
expr_stmt|;
name|length
operator|=
name|local_buffer
index|[
literal|0
index|]
expr_stmt|;
comment|/* Skip pointer section if length is invalid. */
if|if
condition|(
name|length
operator|==
literal|0xFFFF
operator|||
name|length
operator|==
literal|0
operator|||
operator|(
name|ptr
operator|+
name|length
operator|)
operator|>=
name|hw
operator|->
name|eeprom
operator|.
name|word_size
condition|)
return|return
name|IXGBE_SUCCESS
return|;
block|}
if|if
condition|(
name|buffer
operator|&&
operator|(
operator|(
name|u32
operator|)
name|start
operator|+
operator|(
name|u32
operator|)
name|length
operator|>
name|buffer_size
operator|)
condition|)
return|return
name|IXGBE_ERR_PARAM
return|;
for|for
control|(
name|i
operator|=
name|start
init|;
name|length
condition|;
name|i
operator|++
operator|,
name|length
operator|--
control|)
block|{
if|if
condition|(
name|i
operator|==
name|bufsz
operator|&&
operator|!
name|buffer
condition|)
block|{
name|ptr
operator|+=
name|bufsz
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|length
operator|<
name|bufsz
condition|)
name|bufsz
operator|=
name|length
expr_stmt|;
comment|/* Read a chunk at the pointer location */
name|status
operator|=
name|ixgbe_read_ee_hostif_buffer_X550
argument_list|(
name|hw
argument_list|,
name|ptr
argument_list|,
name|bufsz
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Failed to read EEPROM image\n"
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
block|}
operator|*
name|csum
operator|+=
name|local_buffer
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_calc_checksum_X550 - Calculates and returns the checksum  *  @hw: pointer to hardware structure  *  @buffer: pointer to buffer containing calculated checksum  *  @buffer_size: size of buffer  *  *  Returns a negative error code on error, or the 16-bit checksum  **/
end_comment

begin_function
name|s32
name|ixgbe_calc_checksum_X550
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|buffer
parameter_list|,
name|u32
name|buffer_size
parameter_list|)
block|{
name|u16
name|eeprom_ptrs
index|[
name|IXGBE_EEPROM_LAST_WORD
operator|+
literal|1
index|]
decl_stmt|;
name|u16
modifier|*
name|local_buffer
decl_stmt|;
name|s32
name|status
decl_stmt|;
name|u16
name|checksum
init|=
literal|0
decl_stmt|;
name|u16
name|pointer
decl_stmt|,
name|i
decl_stmt|,
name|size
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_calc_eeprom_checksum_X550"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|init_params
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buffer
condition|)
block|{
comment|/* Read pointer area */
name|status
operator|=
name|ixgbe_read_ee_hostif_buffer_X550
argument_list|(
name|hw
argument_list|,
literal|0
argument_list|,
name|IXGBE_EEPROM_LAST_WORD
operator|+
literal|1
argument_list|,
name|eeprom_ptrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Failed to read EEPROM image\n"
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
name|local_buffer
operator|=
name|eeprom_ptrs
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|buffer_size
operator|<
name|IXGBE_EEPROM_LAST_WORD
condition|)
return|return
name|IXGBE_ERR_PARAM
return|;
name|local_buffer
operator|=
name|buffer
expr_stmt|;
block|}
comment|/* 	 * For X550 hardware include 0x0-0x41 in the checksum, skip the 	 * checksum word itself 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|IXGBE_EEPROM_LAST_WORD
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|i
operator|!=
name|IXGBE_EEPROM_CHECKSUM
condition|)
name|checksum
operator|+=
name|local_buffer
index|[
name|i
index|]
expr_stmt|;
comment|/* 	 * Include all data from pointers 0x3, 0x6-0xE.  This excludes the 	 * FW, PHY module, and PCIe Expansion/Option ROM pointers. 	 */
for|for
control|(
name|i
operator|=
name|IXGBE_PCIE_ANALOG_PTR_X550
init|;
name|i
operator|<
name|IXGBE_FW_PTR
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|IXGBE_PHY_PTR
operator|||
name|i
operator|==
name|IXGBE_OPTION_ROM_PTR
condition|)
continue|continue;
name|pointer
operator|=
name|local_buffer
index|[
name|i
index|]
expr_stmt|;
comment|/* Skip pointer section if the pointer is invalid. */
if|if
condition|(
name|pointer
operator|==
literal|0xFFFF
operator|||
name|pointer
operator|==
literal|0
operator|||
name|pointer
operator|>=
name|hw
operator|->
name|eeprom
operator|.
name|word_size
condition|)
continue|continue;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|IXGBE_PCIE_GENERAL_PTR
case|:
name|size
operator|=
name|IXGBE_IXGBE_PCIE_GENERAL_SIZE
expr_stmt|;
break|break;
case|case
name|IXGBE_PCIE_CONFIG0_PTR
case|:
case|case
name|IXGBE_PCIE_CONFIG1_PTR
case|:
name|size
operator|=
name|IXGBE_PCIE_CONFIG_SIZE
expr_stmt|;
break|break;
default|default:
name|size
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|status
operator|=
name|ixgbe_checksum_ptr_x550
argument_list|(
name|hw
argument_list|,
name|pointer
argument_list|,
name|size
argument_list|,
operator|&
name|checksum
argument_list|,
name|buffer
argument_list|,
name|buffer_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|status
return|;
block|}
name|checksum
operator|=
operator|(
name|u16
operator|)
name|IXGBE_EEPROM_SUM
operator|-
name|checksum
expr_stmt|;
return|return
operator|(
name|s32
operator|)
name|checksum
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_calc_eeprom_checksum_X550 - Calculates and returns the checksum  *  @hw: pointer to hardware structure  *  *  Returns a negative error code on error, or the 16-bit checksum  **/
end_comment

begin_function
name|s32
name|ixgbe_calc_eeprom_checksum_X550
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
return|return
name|ixgbe_calc_checksum_X550
argument_list|(
name|hw
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_validate_eeprom_checksum_X550 - Validate EEPROM checksum  *  @hw: pointer to hardware structure  *  @checksum_val: calculated checksum  *  *  Performs checksum calculation and validates the EEPROM checksum.  If the  *  caller does not need checksum_val, the value can be NULL.  **/
end_comment

begin_function
name|s32
name|ixgbe_validate_eeprom_checksum_X550
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|checksum_val
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|u16
name|checksum
decl_stmt|;
name|u16
name|read_checksum
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_validate_eeprom_checksum_X550"
argument_list|)
expr_stmt|;
comment|/* Read the first word from the EEPROM. If this times out or fails, do 	 * not continue or we could be in for a very long wait while every 	 * EEPROM read fails 	 */
name|status
operator|=
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
literal|0
argument_list|,
operator|&
name|checksum
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM read failed\n"
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
name|status
operator|=
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|calc_checksum
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
condition|)
return|return
name|status
return|;
name|checksum
operator|=
call|(
name|u16
call|)
argument_list|(
name|status
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|status
operator|=
name|ixgbe_read_ee_hostif_X550
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEPROM_CHECKSUM
argument_list|,
operator|&
name|read_checksum
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|status
return|;
comment|/* Verify read checksum from EEPROM is the same as 	 * calculated checksum 	 */
if|if
condition|(
name|read_checksum
operator|!=
name|checksum
condition|)
block|{
name|status
operator|=
name|IXGBE_ERR_EEPROM_CHECKSUM
expr_stmt|;
name|ERROR_REPORT1
argument_list|(
name|IXGBE_ERROR_INVALID_STATE
argument_list|,
literal|"Invalid EEPROM checksum"
argument_list|)
expr_stmt|;
block|}
comment|/* If the user cares, return the calculated checksum */
if|if
condition|(
name|checksum_val
condition|)
operator|*
name|checksum_val
operator|=
name|checksum
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_update_eeprom_checksum_X550 - Updates the EEPROM checksum and flash  * @hw: pointer to hardware structure  *  * After writing EEPROM to shadow RAM using EEWR register, software calculates  * checksum and updates the EEPROM and instructs the hardware to update  * the flash.  **/
end_comment

begin_function
name|s32
name|ixgbe_update_eeprom_checksum_X550
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|u16
name|checksum
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_update_eeprom_checksum_X550"
argument_list|)
expr_stmt|;
comment|/* Read the first word from the EEPROM. If this times out or fails, do 	 * not continue or we could be in for a very long wait while every 	 * EEPROM read fails 	 */
name|status
operator|=
name|ixgbe_read_ee_hostif_X550
argument_list|(
name|hw
argument_list|,
literal|0
argument_list|,
operator|&
name|checksum
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM read failed\n"
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
name|status
operator|=
name|ixgbe_calc_eeprom_checksum_X550
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
condition|)
return|return
name|status
return|;
name|checksum
operator|=
call|(
name|u16
call|)
argument_list|(
name|status
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|status
operator|=
name|ixgbe_write_ee_hostif_X550
argument_list|(
name|hw
argument_list|,
name|IXGBE_EEPROM_CHECKSUM
argument_list|,
name|checksum
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|status
return|;
name|status
operator|=
name|ixgbe_update_flash_X550
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_update_flash_X550 - Instruct HW to copy EEPROM to Flash device  *  @hw: pointer to hardware structure  *  *  Issue a shadow RAM dump to FW to copy EEPROM from shadow RAM to the flash.  **/
end_comment

begin_function
name|s32
name|ixgbe_update_flash_X550
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|union
name|ixgbe_hic_hdr2
name|buffer
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_update_flash_X550"
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|req
operator|.
name|cmd
operator|=
name|FW_SHADOW_RAM_DUMP_CMD
expr_stmt|;
name|buffer
operator|.
name|req
operator|.
name|buf_lenh
operator|=
literal|0
expr_stmt|;
name|buffer
operator|.
name|req
operator|.
name|buf_lenl
operator|=
name|FW_SHADOW_RAM_DUMP_LEN
expr_stmt|;
name|buffer
operator|.
name|req
operator|.
name|checksum
operator|=
name|FW_DEFAULT_CHECKSUM
expr_stmt|;
name|status
operator|=
name|ixgbe_host_interface_command
argument_list|(
name|hw
argument_list|,
operator|(
name|u32
operator|*
operator|)
operator|&
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|IXGBE_HI_COMMAND_TIMEOUT
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_supported_physical_layer_X550em - Returns physical layer type  *  @hw: pointer to hardware structure  *  *  Determines physical layer capabilities of the current configuration.  **/
end_comment

begin_function
name|u32
name|ixgbe_get_supported_physical_layer_X550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|physical_layer
init|=
name|IXGBE_PHYSICAL_LAYER_UNKNOWN
decl_stmt|;
name|u16
name|ext_ability
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_supported_physical_layer_X550em"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|identify
argument_list|(
name|hw
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
condition|)
block|{
case|case
name|ixgbe_phy_x550em_kr
case|:
case|case
name|ixgbe_phy_x550em_xfi
case|:
name|physical_layer
operator|=
name|IXGBE_PHYSICAL_LAYER_10GBASE_KR
operator||
name|IXGBE_PHYSICAL_LAYER_1000BASE_KX
expr_stmt|;
break|break;
case|case
name|ixgbe_phy_x550em_kx4
case|:
name|physical_layer
operator|=
name|IXGBE_PHYSICAL_LAYER_10GBASE_KX4
operator||
name|IXGBE_PHYSICAL_LAYER_1000BASE_KX
expr_stmt|;
break|break;
case|case
name|ixgbe_phy_x550em_ext_t
case|:
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_PHY_EXT_ABILITY
argument_list|,
name|IXGBE_MDIO_PMA_PMD_DEV_TYPE
argument_list|,
operator|&
name|ext_ability
argument_list|)
expr_stmt|;
if|if
condition|(
name|ext_ability
operator|&
name|IXGBE_MDIO_PHY_10GBASET_ABILITY
condition|)
name|physical_layer
operator||=
name|IXGBE_PHYSICAL_LAYER_10GBASE_T
expr_stmt|;
if|if
condition|(
name|ext_ability
operator|&
name|IXGBE_MDIO_PHY_1000BASET_ABILITY
condition|)
name|physical_layer
operator||=
name|IXGBE_PHYSICAL_LAYER_1000BASE_T
expr_stmt|;
break|break;
case|case
name|ixgbe_phy_fw
case|:
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|speeds_supported
operator|&
name|IXGBE_LINK_SPEED_1GB_FULL
condition|)
name|physical_layer
operator||=
name|IXGBE_PHYSICAL_LAYER_1000BASE_T
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|speeds_supported
operator|&
name|IXGBE_LINK_SPEED_100_FULL
condition|)
name|physical_layer
operator||=
name|IXGBE_PHYSICAL_LAYER_100BASE_TX
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|speeds_supported
operator|&
name|IXGBE_LINK_SPEED_10_FULL
condition|)
name|physical_layer
operator||=
name|IXGBE_PHYSICAL_LAYER_10BASE_T
expr_stmt|;
break|break;
case|case
name|ixgbe_phy_sgmii
case|:
name|physical_layer
operator|=
name|IXGBE_PHYSICAL_LAYER_1000BASE_KX
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|get_media_type
argument_list|(
name|hw
argument_list|)
operator|==
name|ixgbe_media_type_fiber
condition|)
name|physical_layer
operator|=
name|ixgbe_get_supported_phy_sfp_layer_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|physical_layer
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_get_bus_info_x550em - Set PCI bus info  * @hw: pointer to hardware structure  *  * Sets bus link width and speed to unknown because X550em is  * not a PCI device.  **/
end_comment

begin_function
name|s32
name|ixgbe_get_bus_info_X550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_bus_info_x550em"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|bus
operator|.
name|width
operator|=
name|ixgbe_bus_width_unknown
expr_stmt|;
name|hw
operator|->
name|bus
operator|.
name|speed
operator|=
name|ixgbe_bus_speed_unknown
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|set_lan_id
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_disable_rx_x550 - Disable RX unit  *  * Enables the Rx DMA unit for x550  **/
end_comment

begin_function
name|void
name|ixgbe_disable_rx_x550
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|rxctrl
decl_stmt|,
name|pfdtxgswc
decl_stmt|;
name|s32
name|status
decl_stmt|;
name|struct
name|ixgbe_hic_disable_rxen
name|fw_cmd
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_enable_rx_dma_x550"
argument_list|)
expr_stmt|;
name|rxctrl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXCTRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rxctrl
operator|&
name|IXGBE_RXCTRL_RXEN
condition|)
block|{
name|pfdtxgswc
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PFDTXGSWC
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfdtxgswc
operator|&
name|IXGBE_PFDTXGSWC_VT_LBEN
condition|)
block|{
name|pfdtxgswc
operator|&=
operator|~
name|IXGBE_PFDTXGSWC_VT_LBEN
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PFDTXGSWC
argument_list|,
name|pfdtxgswc
argument_list|)
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|set_lben
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|hw
operator|->
name|mac
operator|.
name|set_lben
operator|=
name|FALSE
expr_stmt|;
block|}
name|fw_cmd
operator|.
name|hdr
operator|.
name|cmd
operator|=
name|FW_DISABLE_RXEN_CMD
expr_stmt|;
name|fw_cmd
operator|.
name|hdr
operator|.
name|buf_len
operator|=
name|FW_DISABLE_RXEN_LEN
expr_stmt|;
name|fw_cmd
operator|.
name|hdr
operator|.
name|checksum
operator|=
name|FW_DEFAULT_CHECKSUM
expr_stmt|;
name|fw_cmd
operator|.
name|port_number
operator|=
operator|(
name|u8
operator|)
name|hw
operator|->
name|bus
operator|.
name|lan_id
expr_stmt|;
name|status
operator|=
name|ixgbe_host_interface_command
argument_list|(
name|hw
argument_list|,
operator|(
name|u32
operator|*
operator|)
operator|&
name|fw_cmd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ixgbe_hic_disable_rxen
argument_list|)
argument_list|,
name|IXGBE_HI_COMMAND_TIMEOUT
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* If we fail - disable RX using register write */
if|if
condition|(
name|status
condition|)
block|{
name|rxctrl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXCTRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rxctrl
operator|&
name|IXGBE_RXCTRL_RXEN
condition|)
block|{
name|rxctrl
operator|&=
operator|~
name|IXGBE_RXCTRL_RXEN
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXCTRL
argument_list|,
name|rxctrl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * ixgbe_enter_lplu_x550em - Transition to low power states  *  @hw: pointer to hardware structure  *  * Configures Low Power Link Up on transition to low power states  * (from D0 to non-D0). Link is required to enter LPLU so avoid resetting the  * X557 PHY immediately prior to entering LPLU.  **/
end_comment

begin_function
name|s32
name|ixgbe_enter_lplu_t_x550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u16
name|an_10g_cntl_reg
decl_stmt|,
name|autoneg_reg
decl_stmt|,
name|speed
decl_stmt|;
name|s32
name|status
decl_stmt|;
name|ixgbe_link_speed
name|lcd_speed
decl_stmt|;
name|u32
name|save_autoneg
decl_stmt|;
name|bool
name|link_up
decl_stmt|;
comment|/* SW LPLU not required on later HW revisions. */
if|if
condition|(
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_X550EM_x
operator|)
operator|&&
operator|(
name|IXGBE_FUSES0_REV_MASK
operator|&
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FUSES0_GROUP
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|IXGBE_SUCCESS
return|;
comment|/* If blocked by MNG FW, then don't restart AN */
if|if
condition|(
name|ixgbe_check_reset_blocked
argument_list|(
name|hw
argument_list|)
condition|)
return|return
name|IXGBE_SUCCESS
return|;
name|status
operator|=
name|ixgbe_ext_phy_t_x550em_get_link
argument_list|(
name|hw
argument_list|,
operator|&
name|link_up
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|status
operator|=
name|ixgbe_read_eeprom
argument_list|(
name|hw
argument_list|,
name|NVM_INIT_CTRL_3
argument_list|,
operator|&
name|hw
operator|->
name|eeprom
operator|.
name|ctrl_word_3
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* If link is down, LPLU disabled in NVM, WoL disabled, or manageability 	 * disabled, then force link down by entering low power mode. 	 */
if|if
condition|(
operator|!
name|link_up
operator|||
operator|!
operator|(
name|hw
operator|->
name|eeprom
operator|.
name|ctrl_word_3
operator|&
name|NVM_INIT_CTRL_3_LPLU
operator|)
operator|||
operator|!
operator|(
name|hw
operator|->
name|wol_enabled
operator|||
name|ixgbe_mng_present
argument_list|(
name|hw
argument_list|)
operator|)
condition|)
return|return
name|ixgbe_set_copper_phy_power
argument_list|(
name|hw
argument_list|,
name|FALSE
argument_list|)
return|;
comment|/* Determine LCD */
name|status
operator|=
name|ixgbe_get_lcd_t_x550em
argument_list|(
name|hw
argument_list|,
operator|&
name|lcd_speed
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* If no valid LCD link speed, then force link down and exit. */
if|if
condition|(
name|lcd_speed
operator|==
name|IXGBE_LINK_SPEED_UNKNOWN
condition|)
return|return
name|ixgbe_set_copper_phy_power
argument_list|(
name|hw
argument_list|,
name|FALSE
argument_list|)
return|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_VENDOR_STAT
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
operator|&
name|speed
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* If no link now, speed is invalid so take link down */
name|status
operator|=
name|ixgbe_ext_phy_t_x550em_get_link
argument_list|(
name|hw
argument_list|,
operator|&
name|link_up
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|ixgbe_set_copper_phy_power
argument_list|(
name|hw
argument_list|,
name|FALSE
argument_list|)
return|;
comment|/* clear everything but the speed bits */
name|speed
operator|&=
name|IXGBE_MDIO_AUTO_NEG_VEN_STAT_SPEED_MASK
expr_stmt|;
comment|/* If current speed is already LCD, then exit. */
if|if
condition|(
operator|(
operator|(
name|speed
operator|==
name|IXGBE_MDIO_AUTO_NEG_VENDOR_STATUS_1GB
operator|)
operator|&&
operator|(
name|lcd_speed
operator|==
name|IXGBE_LINK_SPEED_1GB_FULL
operator|)
operator|)
operator|||
operator|(
operator|(
name|speed
operator|==
name|IXGBE_MDIO_AUTO_NEG_VENDOR_STATUS_10GB
operator|)
operator|&&
operator|(
name|lcd_speed
operator|==
name|IXGBE_LINK_SPEED_10GB_FULL
operator|)
operator|)
condition|)
return|return
name|status
return|;
comment|/* Clear AN completed indication */
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_VENDOR_TX_ALARM
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
operator|&
name|autoneg_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MII_10GBASE_T_AUTONEG_CTRL_REG
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
operator|&
name|an_10g_cntl_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MII_AUTONEG_VENDOR_PROVISION_1_REG
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
operator|&
name|autoneg_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
name|save_autoneg
operator|=
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
expr_stmt|;
comment|/* Setup link at least common link speed */
name|status
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|setup_link
argument_list|(
name|hw
argument_list|,
name|lcd_speed
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* restore autoneg from before setting lplu speed */
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator|=
name|save_autoneg
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_get_lcd_x550em - Determine lowest common denominator  *  @hw: pointer to hardware structure  *  @lcd_speed: pointer to lowest common link speed  *  * Determine lowest common link speed with link partner.  **/
end_comment

begin_function
name|s32
name|ixgbe_get_lcd_t_x550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
modifier|*
name|lcd_speed
parameter_list|)
block|{
name|u16
name|an_lp_status
decl_stmt|;
name|s32
name|status
decl_stmt|;
name|u16
name|word
init|=
name|hw
operator|->
name|eeprom
operator|.
name|ctrl_word_3
decl_stmt|;
operator|*
name|lcd_speed
operator|=
name|IXGBE_LINK_SPEED_UNKNOWN
expr_stmt|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTO_NEG_LP_STATUS
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
operator|&
name|an_lp_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* If link partner advertised 1G, return 1G */
if|if
condition|(
name|an_lp_status
operator|&
name|IXGBE_AUTO_NEG_LP_1000BASE_CAP
condition|)
block|{
operator|*
name|lcd_speed
operator|=
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
return|return
name|status
return|;
block|}
comment|/* If 10G disabled for LPLU via NVM D10GMP, then return no valid LCD */
if|if
condition|(
operator|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
operator|&&
operator|(
name|word
operator|&
name|NVM_INIT_CTRL_3_D10GMP_PORT1
operator|)
operator|)
operator|||
operator|(
name|word
operator|&
name|NVM_INIT_CTRL_3_D10GMP_PORT0
operator|)
condition|)
return|return
name|status
return|;
comment|/* Link partner not capable of lower speeds, return 10G */
operator|*
name|lcd_speed
operator|=
name|IXGBE_LINK_SPEED_10GB_FULL
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_setup_fc_X550em - Set up flow control  *  @hw: pointer to hardware structure  *  *  Called at init time to set up flow control.  **/
end_comment

begin_function
name|s32
name|ixgbe_setup_fc_X550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u32
name|pause
decl_stmt|,
name|asm_dir
decl_stmt|,
name|reg_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_setup_fc_X550em"
argument_list|)
expr_stmt|;
comment|/* Validate the requested mode */
if|if
condition|(
name|hw
operator|->
name|fc
operator|.
name|strict_ieee
operator|&&
name|hw
operator|->
name|fc
operator|.
name|requested_mode
operator|==
name|ixgbe_fc_rx_pause
condition|)
block|{
name|ERROR_REPORT1
argument_list|(
name|IXGBE_ERROR_UNSUPPORTED
argument_list|,
literal|"ixgbe_fc_rx_pause not valid in strict IEEE mode\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|IXGBE_ERR_INVALID_LINK_SETTINGS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 10gig parts do not have a word in the EEPROM to determine the 	 * default flow control setting, so we explicitly set it to full. 	 */
if|if
condition|(
name|hw
operator|->
name|fc
operator|.
name|requested_mode
operator|==
name|ixgbe_fc_default
condition|)
name|hw
operator|->
name|fc
operator|.
name|requested_mode
operator|=
name|ixgbe_fc_full
expr_stmt|;
comment|/* Determine PAUSE and ASM_DIR bits. */
switch|switch
condition|(
name|hw
operator|->
name|fc
operator|.
name|requested_mode
condition|)
block|{
case|case
name|ixgbe_fc_none
case|:
name|pause
operator|=
literal|0
expr_stmt|;
name|asm_dir
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ixgbe_fc_tx_pause
case|:
name|pause
operator|=
literal|0
expr_stmt|;
name|asm_dir
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ixgbe_fc_rx_pause
case|:
comment|/* Rx Flow control is enabled and Tx Flow control is 		 * disabled by software override. Since there really 		 * isn't a way to advertise that we are capable of RX 		 * Pause ONLY, we will advertise that we support both 		 * symmetric and asymmetric Rx PAUSE, as such we fall 		 * through to the fc_full statement.  Later, we will 		 * disable the adapter's ability to send PAUSE frames. 		 */
case|case
name|ixgbe_fc_full
case|:
name|pause
operator|=
literal|1
expr_stmt|;
name|asm_dir
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|ERROR_REPORT1
argument_list|(
name|IXGBE_ERROR_ARGUMENT
argument_list|,
literal|"Flow control param set incorrectly\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|IXGBE_ERR_CONFIG
expr_stmt|;
goto|goto
name|out
goto|;
block|}
switch|switch
condition|(
name|hw
operator|->
name|device_id
condition|)
block|{
case|case
name|IXGBE_DEV_ID_X550EM_X_KR
case|:
case|case
name|IXGBE_DEV_ID_X550EM_A_KR
case|:
case|case
name|IXGBE_DEV_ID_X550EM_A_KR_L
case|:
name|ret_val
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|read_iosf_sb_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_AN_CNTL_1
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
operator|&
name|reg_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|out
goto|;
name|reg_val
operator|&=
operator|~
operator|(
name|IXGBE_KRM_AN_CNTL_1_SYM_PAUSE
operator||
name|IXGBE_KRM_AN_CNTL_1_ASM_PAUSE
operator|)
expr_stmt|;
if|if
condition|(
name|pause
condition|)
name|reg_val
operator||=
name|IXGBE_KRM_AN_CNTL_1_SYM_PAUSE
expr_stmt|;
if|if
condition|(
name|asm_dir
condition|)
name|reg_val
operator||=
name|IXGBE_KRM_AN_CNTL_1_ASM_PAUSE
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|write_iosf_sb_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_AN_CNTL_1
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
comment|/* This device does not fully support AN. */
name|hw
operator|->
name|fc
operator|.
name|disable_fc_autoneg
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_fc_autoneg_backplane_x550em_a - Enable flow control IEEE clause 37  *  @hw: pointer to hardware structure  *  *  Enable flow control according to IEEE clause 37.  **/
end_comment

begin_function
name|void
name|ixgbe_fc_autoneg_backplane_x550em_a
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|link_s1
decl_stmt|,
name|lp_an_page_low
decl_stmt|,
name|an_cntl_1
decl_stmt|;
name|s32
name|status
init|=
name|IXGBE_ERR_FC_NOT_NEGOTIATED
decl_stmt|;
name|ixgbe_link_speed
name|speed
decl_stmt|;
name|bool
name|link_up
decl_stmt|;
comment|/* AN should have completed when the cable was plugged in. 	 * Look for reasons to bail out.  Bail out if: 	 * - FC autoneg is disabled, or if 	 * - link is not up. 	 */
if|if
condition|(
name|hw
operator|->
name|fc
operator|.
name|disable_fc_autoneg
condition|)
block|{
name|ERROR_REPORT1
argument_list|(
name|IXGBE_ERROR_UNSUPPORTED
argument_list|,
literal|"Flow control autoneg is disabled"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|check_link
argument_list|(
name|hw
argument_list|,
operator|&
name|speed
argument_list|,
operator|&
name|link_up
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|link_up
condition|)
block|{
name|ERROR_REPORT1
argument_list|(
name|IXGBE_ERROR_SOFTWARE
argument_list|,
literal|"The link is down"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Check at auto-negotiation has completed */
name|status
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|read_iosf_sb_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_LINK_S1
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
operator|&
name|link_s1
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
operator|||
operator|(
name|link_s1
operator|&
name|IXGBE_KRM_LINK_S1_MAC_AN_COMPLETE
operator|)
operator|==
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Auto-Negotiation did not complete\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IXGBE_ERR_FC_NOT_NEGOTIATED
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Read the 10g AN autoc and LP ability registers and resolve 	 * local flow control settings accordingly 	 */
name|status
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|read_iosf_sb_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_AN_CNTL_1
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
operator|&
name|an_cntl_1
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Auto-Negotiation did not complete\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|status
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|read_iosf_sb_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_LP_BASE_PAGE_HIGH
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
operator|&
name|lp_an_page_low
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Auto-Negotiation did not complete\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|status
operator|=
name|ixgbe_negotiate_fc
argument_list|(
name|hw
argument_list|,
name|an_cntl_1
argument_list|,
name|lp_an_page_low
argument_list|,
name|IXGBE_KRM_AN_CNTL_1_SYM_PAUSE
argument_list|,
name|IXGBE_KRM_AN_CNTL_1_ASM_PAUSE
argument_list|,
name|IXGBE_KRM_LP_BASE_PAGE_HIGH_SYM_PAUSE
argument_list|,
name|IXGBE_KRM_LP_BASE_PAGE_HIGH_ASM_PAUSE
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
condition|)
block|{
name|hw
operator|->
name|fc
operator|.
name|fc_was_autonegged
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|hw
operator|->
name|fc
operator|.
name|fc_was_autonegged
operator|=
name|FALSE
expr_stmt|;
name|hw
operator|->
name|fc
operator|.
name|current_mode
operator|=
name|hw
operator|->
name|fc
operator|.
name|requested_mode
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *  ixgbe_fc_autoneg_fiber_x550em_a - passthrough FC settings  *  @hw: pointer to hardware structure  *  **/
end_comment

begin_function
name|void
name|ixgbe_fc_autoneg_fiber_x550em_a
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|hw
operator|->
name|fc
operator|.
name|fc_was_autonegged
operator|=
name|FALSE
expr_stmt|;
name|hw
operator|->
name|fc
operator|.
name|current_mode
operator|=
name|hw
operator|->
name|fc
operator|.
name|requested_mode
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_fc_autoneg_sgmii_x550em_a - Enable flow control IEEE clause 37  *  @hw: pointer to hardware structure  *  *  Enable flow control according to IEEE clause 37.  **/
end_comment

begin_function
name|void
name|ixgbe_fc_autoneg_sgmii_x550em_a
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_ERR_FC_NOT_NEGOTIATED
decl_stmt|;
name|u32
name|info
index|[
name|FW_PHY_ACT_DATA_COUNT
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|ixgbe_link_speed
name|speed
decl_stmt|;
name|bool
name|link_up
decl_stmt|;
comment|/* AN should have completed when the cable was plugged in. 	 * Look for reasons to bail out.  Bail out if: 	 * - FC autoneg is disabled, or if 	 * - link is not up. 	 */
if|if
condition|(
name|hw
operator|->
name|fc
operator|.
name|disable_fc_autoneg
condition|)
block|{
name|ERROR_REPORT1
argument_list|(
name|IXGBE_ERROR_UNSUPPORTED
argument_list|,
literal|"Flow control autoneg is disabled"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|check_link
argument_list|(
name|hw
argument_list|,
operator|&
name|speed
argument_list|,
operator|&
name|link_up
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|link_up
condition|)
block|{
name|ERROR_REPORT1
argument_list|(
name|IXGBE_ERROR_SOFTWARE
argument_list|,
literal|"The link is down"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Check if auto-negotiation has completed */
name|status
operator|=
name|ixgbe_fw_phy_activity
argument_list|(
name|hw
argument_list|,
name|FW_PHY_ACT_GET_LINK_INFO
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
operator|||
operator|!
operator|(
name|info
index|[
literal|0
index|]
operator|&
name|FW_PHY_ACT_GET_LINK_INFO_AN_COMPLETE
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Auto-Negotiation did not complete\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IXGBE_ERR_FC_NOT_NEGOTIATED
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Negotiate the flow control */
name|status
operator|=
name|ixgbe_negotiate_fc
argument_list|(
name|hw
argument_list|,
name|info
index|[
literal|0
index|]
argument_list|,
name|info
index|[
literal|0
index|]
argument_list|,
name|FW_PHY_ACT_GET_LINK_INFO_FC_RX
argument_list|,
name|FW_PHY_ACT_GET_LINK_INFO_FC_TX
argument_list|,
name|FW_PHY_ACT_GET_LINK_INFO_LP_FC_RX
argument_list|,
name|FW_PHY_ACT_GET_LINK_INFO_LP_FC_TX
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
condition|)
block|{
name|hw
operator|->
name|fc
operator|.
name|fc_was_autonegged
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|hw
operator|->
name|fc
operator|.
name|fc_was_autonegged
operator|=
name|FALSE
expr_stmt|;
name|hw
operator|->
name|fc
operator|.
name|current_mode
operator|=
name|hw
operator|->
name|fc
operator|.
name|requested_mode
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *  ixgbe_setup_fc_backplane_x550em_a - Set up flow control  *  @hw: pointer to hardware structure  *  *  Called at init time to set up flow control.  **/
end_comment

begin_function
name|s32
name|ixgbe_setup_fc_backplane_x550em_a
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u32
name|an_cntl
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_setup_fc_backplane_x550em_a"
argument_list|)
expr_stmt|;
comment|/* Validate the requested mode */
if|if
condition|(
name|hw
operator|->
name|fc
operator|.
name|strict_ieee
operator|&&
name|hw
operator|->
name|fc
operator|.
name|requested_mode
operator|==
name|ixgbe_fc_rx_pause
condition|)
block|{
name|ERROR_REPORT1
argument_list|(
name|IXGBE_ERROR_UNSUPPORTED
argument_list|,
literal|"ixgbe_fc_rx_pause not valid in strict IEEE mode\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_INVALID_LINK_SETTINGS
return|;
block|}
if|if
condition|(
name|hw
operator|->
name|fc
operator|.
name|requested_mode
operator|==
name|ixgbe_fc_default
condition|)
name|hw
operator|->
name|fc
operator|.
name|requested_mode
operator|=
name|ixgbe_fc_full
expr_stmt|;
comment|/* Set up the 1G and 10G flow control advertisement registers so the 	 * HW will be able to do FC autoneg once the cable is plugged in.  If 	 * we link at 10G, the 1G advertisement is harmless and vice versa. 	 */
name|status
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|read_iosf_sb_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_AN_CNTL_1
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
operator|&
name|an_cntl
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Auto-Negotiation did not complete\n"
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
comment|/* The possible values of fc.requested_mode are: 	 * 0: Flow control is completely disabled 	 * 1: Rx flow control is enabled (we can receive pause frames, 	 *    but not send pause frames). 	 * 2: Tx flow control is enabled (we can send pause frames but 	 *    we do not support receiving pause frames). 	 * 3: Both Rx and Tx flow control (symmetric) are enabled. 	 * other: Invalid. 	 */
switch|switch
condition|(
name|hw
operator|->
name|fc
operator|.
name|requested_mode
condition|)
block|{
case|case
name|ixgbe_fc_none
case|:
comment|/* Flow control completely disabled by software override. */
name|an_cntl
operator|&=
operator|~
operator|(
name|IXGBE_KRM_AN_CNTL_1_SYM_PAUSE
operator||
name|IXGBE_KRM_AN_CNTL_1_ASM_PAUSE
operator|)
expr_stmt|;
break|break;
case|case
name|ixgbe_fc_tx_pause
case|:
comment|/* Tx Flow control is enabled, and Rx Flow control is 		 * disabled by software override. 		 */
name|an_cntl
operator||=
name|IXGBE_KRM_AN_CNTL_1_ASM_PAUSE
expr_stmt|;
name|an_cntl
operator|&=
operator|~
name|IXGBE_KRM_AN_CNTL_1_SYM_PAUSE
expr_stmt|;
break|break;
case|case
name|ixgbe_fc_rx_pause
case|:
comment|/* Rx Flow control is enabled and Tx Flow control is 		 * disabled by software override. Since there really 		 * isn't a way to advertise that we are capable of RX 		 * Pause ONLY, we will advertise that we support both 		 * symmetric and asymmetric Rx PAUSE, as such we fall 		 * through to the fc_full statement.  Later, we will 		 * disable the adapter's ability to send PAUSE frames. 		 */
case|case
name|ixgbe_fc_full
case|:
comment|/* Flow control (both Rx and Tx) is enabled by SW override. */
name|an_cntl
operator||=
name|IXGBE_KRM_AN_CNTL_1_SYM_PAUSE
operator||
name|IXGBE_KRM_AN_CNTL_1_ASM_PAUSE
expr_stmt|;
break|break;
default|default:
name|ERROR_REPORT1
argument_list|(
name|IXGBE_ERROR_ARGUMENT
argument_list|,
literal|"Flow control param set incorrectly\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_CONFIG
return|;
block|}
name|status
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|write_iosf_sb_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_KRM_AN_CNTL_1
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|lan_id
argument_list|)
argument_list|,
name|IXGBE_SB_IOSF_TARGET_KR_PHY
argument_list|,
name|an_cntl
argument_list|)
expr_stmt|;
comment|/* Restart auto-negotiation. */
name|status
operator|=
name|ixgbe_restart_an_internal_phy_x550em
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_set_mux - Set mux for port 1 access with CS4227  * @hw: pointer to hardware structure  * @state: set mux if 1, clear if 0  */
end_comment

begin_function
specifier|static
name|void
name|ixgbe_set_mux
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|state
parameter_list|)
block|{
name|u32
name|esdp
decl_stmt|;
if|if
condition|(
operator|!
name|hw
operator|->
name|bus
operator|.
name|lan_id
condition|)
return|return;
name|esdp
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
condition|)
name|esdp
operator||=
name|IXGBE_ESDP_SDP1
expr_stmt|;
else|else
name|esdp
operator|&=
operator|~
name|IXGBE_ESDP_SDP1
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ESDP
argument_list|,
name|esdp
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_acquire_swfw_sync_X550em - Acquire SWFW semaphore  *  @hw: pointer to hardware structure  *  @mask: Mask to specify which semaphore to acquire  *  *  Acquires the SWFW semaphore and sets the I2C MUX  **/
end_comment

begin_function
name|s32
name|ixgbe_acquire_swfw_sync_X550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|mask
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_acquire_swfw_sync_X550em"
argument_list|)
expr_stmt|;
name|status
operator|=
name|ixgbe_acquire_swfw_sync_X540
argument_list|(
name|hw
argument_list|,
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|status
return|;
if|if
condition|(
name|mask
operator|&
name|IXGBE_GSSR_I2C_MASK
condition|)
name|ixgbe_set_mux
argument_list|(
name|hw
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_release_swfw_sync_X550em - Release SWFW semaphore  *  @hw: pointer to hardware structure  *  @mask: Mask to specify which semaphore to release  *  *  Releases the SWFW semaphore and sets the I2C MUX  **/
end_comment

begin_function
name|void
name|ixgbe_release_swfw_sync_X550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|mask
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_release_swfw_sync_X550em"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IXGBE_GSSR_I2C_MASK
condition|)
name|ixgbe_set_mux
argument_list|(
name|hw
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ixgbe_release_swfw_sync_X540
argument_list|(
name|hw
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_acquire_swfw_sync_X550a - Acquire SWFW semaphore  *  @hw: pointer to hardware structure  *  @mask: Mask to specify which semaphore to acquire  *  *  Acquires the SWFW semaphore and get the shared phy token as needed  */
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_acquire_swfw_sync_X550a
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|mask
parameter_list|)
block|{
name|u32
name|hmask
init|=
name|mask
operator|&
operator|~
name|IXGBE_GSSR_TOKEN_SM
decl_stmt|;
name|int
name|retries
init|=
name|FW_PHY_TOKEN_RETRIES
decl_stmt|;
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_acquire_swfw_sync_X550a"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|retries
condition|)
block|{
name|status
operator|=
name|IXGBE_SUCCESS
expr_stmt|;
if|if
condition|(
name|hmask
condition|)
name|status
operator|=
name|ixgbe_acquire_swfw_sync_X540
argument_list|(
name|hw
argument_list|,
name|hmask
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|DEBUGOUT1
argument_list|(
literal|"Could not acquire SWFW semaphore, Status = %d\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|mask
operator|&
name|IXGBE_GSSR_TOKEN_SM
operator|)
condition|)
return|return
name|IXGBE_SUCCESS
return|;
name|status
operator|=
name|ixgbe_get_phy_token
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|IXGBE_ERR_TOKEN_RETRY
condition|)
name|DEBUGOUT1
argument_list|(
literal|"Could not acquire PHY token, Status = %d\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
condition|)
return|return
name|IXGBE_SUCCESS
return|;
if|if
condition|(
name|hmask
condition|)
name|ixgbe_release_swfw_sync_X540
argument_list|(
name|hw
argument_list|,
name|hmask
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_ERR_TOKEN_RETRY
condition|)
block|{
name|DEBUGOUT1
argument_list|(
literal|"Unable to retry acquiring the PHY token, Status = %d\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
block|}
name|DEBUGOUT1
argument_list|(
literal|"Semaphore acquisition retries failed!: PHY ID = 0x%08X\n"
argument_list|,
name|hw
operator|->
name|phy
operator|.
name|id
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_release_swfw_sync_X550a - Release SWFW semaphore  *  @hw: pointer to hardware structure  *  @mask: Mask to specify which semaphore to release  *  *  Releases the SWFW semaphore and puts the shared phy token as needed  */
end_comment

begin_function
specifier|static
name|void
name|ixgbe_release_swfw_sync_X550a
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|mask
parameter_list|)
block|{
name|u32
name|hmask
init|=
name|mask
operator|&
operator|~
name|IXGBE_GSSR_TOKEN_SM
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_release_swfw_sync_X550a"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IXGBE_GSSR_TOKEN_SM
condition|)
name|ixgbe_put_phy_token
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|hmask
condition|)
name|ixgbe_release_swfw_sync_X540
argument_list|(
name|hw
argument_list|,
name|hmask
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_read_phy_reg_x550a  - Reads specified PHY register  *  @hw: pointer to hardware structure  *  @reg_addr: 32 bit address of PHY register to read  *  @phy_data: Pointer to read data from PHY register  *  *  Reads a value from a specified PHY register using the SWFW lock and PHY  *  Token. The PHY Token is needed since the MDIO is shared between to MAC  *  instances.  **/
end_comment

begin_function
name|s32
name|ixgbe_read_phy_reg_x550a
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|reg_addr
parameter_list|,
name|u32
name|device_type
parameter_list|,
name|u16
modifier|*
name|phy_data
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|u32
name|mask
init|=
name|hw
operator|->
name|phy
operator|.
name|phy_semaphore_mask
operator||
name|IXGBE_GSSR_TOKEN_SM
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_read_phy_reg_x550a"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|acquire_swfw_sync
argument_list|(
name|hw
argument_list|,
name|mask
argument_list|)
condition|)
return|return
name|IXGBE_ERR_SWFW_SYNC
return|;
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg_mdi
argument_list|(
name|hw
argument_list|,
name|reg_addr
argument_list|,
name|device_type
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|mask
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_write_phy_reg_x550a - Writes specified PHY register  *  @hw: pointer to hardware structure  *  @reg_addr: 32 bit PHY register to write  *  @device_type: 5 bit device type  *  @phy_data: Data to write to the PHY register  *  *  Writes a value to specified PHY register using the SWFW lock and PHY Token.  *  The PHY Token is needed since the MDIO is shared between to MAC instances.  **/
end_comment

begin_function
name|s32
name|ixgbe_write_phy_reg_x550a
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|reg_addr
parameter_list|,
name|u32
name|device_type
parameter_list|,
name|u16
name|phy_data
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|u32
name|mask
init|=
name|hw
operator|->
name|phy
operator|.
name|phy_semaphore_mask
operator||
name|IXGBE_GSSR_TOKEN_SM
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_write_phy_reg_x550a"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|acquire_swfw_sync
argument_list|(
name|hw
argument_list|,
name|mask
argument_list|)
operator|==
name|IXGBE_SUCCESS
condition|)
block|{
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg_mdi
argument_list|(
name|hw
argument_list|,
name|reg_addr
argument_list|,
name|device_type
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|IXGBE_ERR_SWFW_SYNC
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_handle_lasi_ext_t_x550em - Handle external Base T PHY interrupt  * @hw: pointer to hardware structure  *  * Handle external Base T PHY interrupt. If high temperature  * failure alarm then return error, else if link status change  * then setup internal/external PHY link  *  * Return IXGBE_ERR_OVERTEMP if interrupt is high temperature  * failure alarm, else return PHY access status.  */
end_comment

begin_function
name|s32
name|ixgbe_handle_lasi_ext_t_x550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|bool
name|lsc
decl_stmt|;
name|u32
name|status
decl_stmt|;
name|status
operator|=
name|ixgbe_get_lasi_ext_t_x550em
argument_list|(
name|hw
argument_list|,
operator|&
name|lsc
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
if|if
condition|(
name|lsc
condition|)
return|return
name|ixgbe_setup_internal_phy
argument_list|(
name|hw
argument_list|)
return|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_setup_mac_link_t_X550em - Sets the auto advertised link speed  * @hw: pointer to hardware structure  * @speed: new link speed  * @autoneg_wait_to_complete: TRUE when waiting for completion is needed  *  * Setup internal/external PHY link speed based on link speed, then set  * external PHY auto advertised link speed.  *  * Returns error status for any failure  **/
end_comment

begin_function
name|s32
name|ixgbe_setup_mac_link_t_X550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
name|speed
parameter_list|,
name|bool
name|autoneg_wait_to_complete
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|ixgbe_link_speed
name|force_speed
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_setup_mac_link_t_X550em"
argument_list|)
expr_stmt|;
comment|/* Setup internal/external PHY link speed to iXFI (10G), unless 	 * only 1G is auto advertised then setup KX link. 	 */
if|if
condition|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_10GB_FULL
condition|)
name|force_speed
operator|=
name|IXGBE_LINK_SPEED_10GB_FULL
expr_stmt|;
else|else
name|force_speed
operator|=
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
comment|/* If X552 and internal link mode is XFI, then setup XFI internal link. 	 */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|ixgbe_mac_X550EM_x
operator|&&
operator|!
operator|(
name|hw
operator|->
name|phy
operator|.
name|nw_mng_if_sel
operator|&
name|IXGBE_NW_MNG_IF_SEL_INT_PHY_MODE
operator|)
condition|)
block|{
name|status
operator|=
name|ixgbe_setup_ixfi_x550em
argument_list|(
name|hw
argument_list|,
operator|&
name|force_speed
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
block|}
return|return
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|setup_link_speed
argument_list|(
name|hw
argument_list|,
name|speed
argument_list|,
name|autoneg_wait_to_complete
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * ixgbe_check_link_t_X550em - Determine link and speed status  * @hw: pointer to hardware structure  * @speed: pointer to link speed  * @link_up: TRUE when link is up  * @link_up_wait_to_complete: bool used to wait for link up or not  *  * Check that both the MAC and X557 external PHY have link.  **/
end_comment

begin_function
name|s32
name|ixgbe_check_link_t_X550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
modifier|*
name|speed
parameter_list|,
name|bool
modifier|*
name|link_up
parameter_list|,
name|bool
name|link_up_wait_to_complete
parameter_list|)
block|{
name|u32
name|status
decl_stmt|;
name|u16
name|i
decl_stmt|,
name|autoneg_status
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|get_media_type
argument_list|(
name|hw
argument_list|)
operator|!=
name|ixgbe_media_type_copper
condition|)
return|return
name|IXGBE_ERR_CONFIG
return|;
name|status
operator|=
name|ixgbe_check_mac_link_generic
argument_list|(
name|hw
argument_list|,
name|speed
argument_list|,
name|link_up
argument_list|,
name|link_up_wait_to_complete
argument_list|)
expr_stmt|;
comment|/* If check link fails or MAC link is not up, then return */
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
operator|||
operator|!
operator|(
operator|*
name|link_up
operator|)
condition|)
return|return
name|status
return|;
comment|/* MAC link is up, so check external PHY link. 	 * X557 PHY. Link status is latching low, and can only be used to detect 	 * link drop, and not the current status of the link without performing 	 * back-to-back reads. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_STATUS
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
operator|&
name|autoneg_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
block|}
comment|/* If external PHY link is not up, then indicate link not up */
if|if
condition|(
operator|!
operator|(
name|autoneg_status
operator|&
name|IXGBE_MDIO_AUTO_NEG_LINK_STATUS
operator|)
condition|)
operator|*
name|link_up
operator|=
name|FALSE
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_reset_phy_t_X550em - Performs X557 PHY reset and enables LASI  *  @hw: pointer to hardware structure  **/
end_comment

begin_function
name|s32
name|ixgbe_reset_phy_t_X550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|status
operator|=
name|ixgbe_reset_phy_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* Configure Link Status Alarm and Temperature Threshold interrupts */
return|return
name|ixgbe_enable_lasi_ext_t_x550em
argument_list|(
name|hw
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_led_on_t_X550em - Turns on the software controllable LEDs.  *  @hw: pointer to hardware structure  *  @led_idx: led number to turn on  **/
end_comment

begin_function
name|s32
name|ixgbe_led_on_t_X550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|led_idx
parameter_list|)
block|{
name|u16
name|phy_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_led_on_t_X550em"
argument_list|)
expr_stmt|;
if|if
condition|(
name|led_idx
operator|>=
name|IXGBE_X557_MAX_LED_INDEX
condition|)
return|return
name|IXGBE_ERR_PARAM
return|;
comment|/* To turn on the LED, set mode to ON. */
name|ixgbe_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_X557_LED_PROVISIONING
operator|+
name|led_idx
argument_list|,
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
name|phy_data
operator||=
name|IXGBE_X557_LED_MANUAL_SET_MASK
expr_stmt|;
name|ixgbe_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_X557_LED_PROVISIONING
operator|+
name|led_idx
argument_list|,
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_led_off_t_X550em - Turns off the software controllable LEDs.  *  @hw: pointer to hardware structure  *  @led_idx: led number to turn off  **/
end_comment

begin_function
name|s32
name|ixgbe_led_off_t_X550em
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|led_idx
parameter_list|)
block|{
name|u16
name|phy_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_led_off_t_X550em"
argument_list|)
expr_stmt|;
if|if
condition|(
name|led_idx
operator|>=
name|IXGBE_X557_MAX_LED_INDEX
condition|)
return|return
name|IXGBE_ERR_PARAM
return|;
comment|/* To turn on the LED, set mode to ON. */
name|ixgbe_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_X557_LED_PROVISIONING
operator|+
name|led_idx
argument_list|,
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
name|phy_data
operator|&=
operator|~
name|IXGBE_X557_LED_MANUAL_SET_MASK
expr_stmt|;
name|ixgbe_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_X557_LED_PROVISIONING
operator|+
name|led_idx
argument_list|,
name|IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_set_fw_drv_ver_x550 - Sends driver version to firmware  *  @hw: pointer to the HW structure  *  @maj: driver version major number  *  @min: driver version minor number  *  @build: driver version build number  *  @sub: driver version sub build number  *  @len: length of driver_ver string  *  @driver_ver: driver string  *  *  Sends driver version number to firmware through the manageability  *  block.  On success return IXGBE_SUCCESS  *  else returns IXGBE_ERR_SWFW_SYNC when encountering an error acquiring  *  semaphore or IXGBE_ERR_HOST_INTERFACE_COMMAND when command fails.  **/
end_comment

begin_function
name|s32
name|ixgbe_set_fw_drv_ver_x550
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|maj
parameter_list|,
name|u8
name|min
parameter_list|,
name|u8
name|build
parameter_list|,
name|u8
name|sub
parameter_list|,
name|u16
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|driver_ver
parameter_list|)
block|{
name|struct
name|ixgbe_hic_drv_info2
name|fw_cmd
decl_stmt|;
name|s32
name|ret_val
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|int
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_set_fw_drv_ver_x550"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|==
literal|0
operator|)
operator|||
operator|(
name|driver_ver
operator|==
name|NULL
operator|)
operator|||
operator|(
name|len
operator|>
sizeof|sizeof
argument_list|(
name|fw_cmd
operator|.
name|driver_string
argument_list|)
operator|)
condition|)
return|return
name|IXGBE_ERR_INVALID_ARGUMENT
return|;
name|fw_cmd
operator|.
name|hdr
operator|.
name|cmd
operator|=
name|FW_CEM_CMD_DRIVER_INFO
expr_stmt|;
name|fw_cmd
operator|.
name|hdr
operator|.
name|buf_len
operator|=
name|FW_CEM_CMD_DRIVER_INFO_LEN
operator|+
name|len
expr_stmt|;
name|fw_cmd
operator|.
name|hdr
operator|.
name|cmd_or_resp
operator|.
name|cmd_resv
operator|=
name|FW_CEM_CMD_RESERVED
expr_stmt|;
name|fw_cmd
operator|.
name|port_num
operator|=
operator|(
name|u8
operator|)
name|hw
operator|->
name|bus
operator|.
name|func
expr_stmt|;
name|fw_cmd
operator|.
name|ver_maj
operator|=
name|maj
expr_stmt|;
name|fw_cmd
operator|.
name|ver_min
operator|=
name|min
expr_stmt|;
name|fw_cmd
operator|.
name|ver_build
operator|=
name|build
expr_stmt|;
name|fw_cmd
operator|.
name|ver_sub
operator|=
name|sub
expr_stmt|;
name|fw_cmd
operator|.
name|hdr
operator|.
name|checksum
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
name|fw_cmd
operator|.
name|driver_string
argument_list|,
name|driver_ver
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|fw_cmd
operator|.
name|hdr
operator|.
name|checksum
operator|=
name|ixgbe_calculate_checksum
argument_list|(
operator|(
name|u8
operator|*
operator|)
operator|&
name|fw_cmd
argument_list|,
operator|(
name|FW_CEM_HDR_LEN
operator|+
name|fw_cmd
operator|.
name|hdr
operator|.
name|buf_len
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|FW_CEM_MAX_RETRIES
condition|;
name|i
operator|++
control|)
block|{
name|ret_val
operator|=
name|ixgbe_host_interface_command
argument_list|(
name|hw
argument_list|,
operator|(
name|u32
operator|*
operator|)
operator|&
name|fw_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|fw_cmd
argument_list|)
argument_list|,
name|IXGBE_HI_COMMAND_TIMEOUT
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|IXGBE_SUCCESS
condition|)
continue|continue;
if|if
condition|(
name|fw_cmd
operator|.
name|hdr
operator|.
name|cmd_or_resp
operator|.
name|ret_status
operator|==
name|FW_CEM_RESP_STATUS_SUCCESS
condition|)
name|ret_val
operator|=
name|IXGBE_SUCCESS
expr_stmt|;
else|else
name|ret_val
operator|=
name|IXGBE_ERR_HOST_INTERFACE_COMMAND
expr_stmt|;
break|break;
block|}
return|return
name|ret_val
return|;
block|}
end_function

end_unit

