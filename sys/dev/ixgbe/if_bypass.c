begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************    Copyright (c) 2001-2017, Intel Corporation   All rights reserved.    Redistribution and use in source and binary forms, with or without   modification, are permitted provided that the following conditions are met:     1. Redistributions of source code must retain the above copyright notice,       this list of conditions and the following disclaimer.     2. Redistributions in binary form must reproduce the above copyright       notice, this list of conditions and the following disclaimer in the       documentation and/or other materials provided with the distribution.     3. Neither the name of the Intel Corporation nor the names of its       contributors may be used to endorse or promote products derived from       this software without specific prior written permission.    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  ******************************************************************************/
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_include
include|#
directive|include
file|"ixgbe.h"
end_include

begin_comment
comment|/************************************************************************  * ixgbe_bypass_mutex_enter  *  *   Mutex support for the bypass feature. Using a dual lock  *   to facilitate a privileged access to the watchdog update  *   over other threads.  ************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_bypass_mutex_enter
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
while|while
condition|(
name|atomic_cmpset_int
argument_list|(
operator|&
name|adapter
operator|->
name|bypass
operator|.
name|low
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|usec_delay
argument_list|(
literal|3000
argument_list|)
expr_stmt|;
while|while
condition|(
name|atomic_cmpset_int
argument_list|(
operator|&
name|adapter
operator|->
name|bypass
operator|.
name|high
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|usec_delay
argument_list|(
literal|3000
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ixgbe_bypass_mutex_enter */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_bypass_mutex_clear  ************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_bypass_mutex_clear
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
while|while
condition|(
name|atomic_cmpset_int
argument_list|(
operator|&
name|adapter
operator|->
name|bypass
operator|.
name|high
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
name|usec_delay
argument_list|(
literal|6000
argument_list|)
expr_stmt|;
while|while
condition|(
name|atomic_cmpset_int
argument_list|(
operator|&
name|adapter
operator|->
name|bypass
operator|.
name|low
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
name|usec_delay
argument_list|(
literal|6000
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ixgbe_bypass_mutex_clear */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_bypass_wd_mutex_enter  *  *   Watchdog entry is allowed to simply grab the high priority  ************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_bypass_wd_mutex_enter
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
while|while
condition|(
name|atomic_cmpset_int
argument_list|(
operator|&
name|adapter
operator|->
name|bypass
operator|.
name|high
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|usec_delay
argument_list|(
literal|3000
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ixgbe_bypass_wd_mutex_enter */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_bypass_wd_mutex_clear  ************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_bypass_wd_mutex_clear
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
while|while
condition|(
name|atomic_cmpset_int
argument_list|(
operator|&
name|adapter
operator|->
name|bypass
operator|.
name|high
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
name|usec_delay
argument_list|(
literal|6000
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ixgbe_bypass_wd_mutex_clear */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_get_bypass_time  ************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_get_bypass_time
parameter_list|(
name|u32
modifier|*
name|year
parameter_list|,
name|u32
modifier|*
name|sec
parameter_list|)
block|{
name|struct
name|timespec
name|current
decl_stmt|;
operator|*
name|year
operator|=
literal|1970
expr_stmt|;
comment|/* time starts at 01/01/1970 */
name|nanotime
argument_list|(
operator|&
name|current
argument_list|)
expr_stmt|;
operator|*
name|sec
operator|=
name|current
operator|.
name|tv_sec
expr_stmt|;
while|while
condition|(
operator|*
name|sec
operator|>
name|SEC_THIS_YEAR
argument_list|(
operator|*
name|year
argument_list|)
condition|)
block|{
operator|*
name|sec
operator|-=
name|SEC_THIS_YEAR
argument_list|(
operator|*
name|year
argument_list|)
expr_stmt|;
operator|(
operator|*
name|year
operator|)
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ixgbe_get_bypass_time */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_bp_version  *  *   Display the feature version  ************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_bp_version
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
operator|(
expr|struct
name|adapter
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|version
init|=
literal|0
decl_stmt|;
name|u32
name|cmd
decl_stmt|;
name|ixgbe_bypass_mutex_enter
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|BYPASS_PAGE_CTL2
operator||
name|BYPASS_WE
expr_stmt|;
name|cmd
operator||=
operator|(
name|BYPASS_EEPROM_VER_ADD
operator|<<
name|BYPASS_CTL2_OFFSET_SHIFT
operator|)
operator|&
name|BYPASS_CTL2_OFFSET_M
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|bypass_rw
argument_list|(
name|hw
argument_list|,
name|cmd
argument_list|,
operator|&
name|version
argument_list|)
operator|!=
literal|0
operator|)
condition|)
goto|goto
name|err
goto|;
name|msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|cmd
operator|&=
operator|~
name|BYPASS_WE
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|bypass_rw
argument_list|(
name|hw
argument_list|,
name|cmd
argument_list|,
operator|&
name|version
argument_list|)
operator|!=
literal|0
operator|)
condition|)
goto|goto
name|err
goto|;
name|ixgbe_bypass_mutex_clear
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|version
operator|&=
name|BYPASS_CTL2_DATA_M
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|version
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
name|err
label|:
name|ixgbe_bypass_mutex_clear
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ixgbe_bp_version */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_bp_set_state  *  *   Show/Set the Bypass State:  *	1 = NORMAL  *	2 = BYPASS  *	3 = ISOLATE  *  *	With no argument the state is displayed,  *	passing a value will set it.  ************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_bp_set_state
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
operator|(
expr|struct
name|adapter
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|state
init|=
literal|0
decl_stmt|;
comment|/* Get the current state */
name|ixgbe_bypass_mutex_enter
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|error
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|bypass_rw
argument_list|(
name|hw
argument_list|,
name|BYPASS_PAGE_CTL0
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
name|ixgbe_bypass_mutex_clear
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|state
operator|=
operator|(
name|state
operator|>>
name|BYPASS_STATUS_OFF_SHIFT
operator|)
operator|&
literal|0x3
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|state
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|)
operator|||
operator|(
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Sanity check new state */
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|BYPASS_NORM
case|:
case|case
name|BYPASS_BYPASS
case|:
case|case
name|BYPASS_ISOLATE
case|:
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|ixgbe_bypass_mutex_enter
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|bypass_set
argument_list|(
name|hw
argument_list|,
name|BYPASS_PAGE_CTL0
argument_list|,
name|BYPASS_MODE_OFF_M
argument_list|,
name|state
argument_list|)
operator|!=
literal|0
operator|)
condition|)
goto|goto
name|out
goto|;
comment|/* Set AUTO back on so FW can receive events */
name|error
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|bypass_set
argument_list|(
name|hw
argument_list|,
name|BYPASS_PAGE_CTL0
argument_list|,
name|BYPASS_MODE_OFF_M
argument_list|,
name|BYPASS_AUTO
argument_list|)
expr_stmt|;
name|out
label|:
name|ixgbe_bypass_mutex_clear
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|6000
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ixgbe_bp_set_state */
end_comment

begin_comment
comment|/************************************************************************  * The following routines control the operational  * "rules" of the feature, what behavior will occur  * when particular events occur.  * 	Values are:  *		0 - no change for the event (NOP)  *		1 - go to Normal operation  *		2 - go to Bypass operation  *		3 - go to Isolate operation  * Calling the entry with no argument just displays  * the current rule setting.  ************************************************************************/
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_bp_timeout  *  * This is to set the Rule for the watchdog,  * not the actual watchdog timeout value.  ************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_bp_timeout
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
operator|(
expr|struct
name|adapter
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|timeout
init|=
literal|0
decl_stmt|;
comment|/* Get the current value */
name|ixgbe_bypass_mutex_enter
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|error
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|bypass_rw
argument_list|(
name|hw
argument_list|,
name|BYPASS_PAGE_CTL0
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
name|ixgbe_bypass_mutex_clear
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|timeout
operator|=
operator|(
name|timeout
operator|>>
name|BYPASS_WDTIMEOUT_SHIFT
operator|)
operator|&
literal|0x3
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|timeout
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|)
operator|||
operator|(
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Sanity check on the setting */
switch|switch
condition|(
name|timeout
condition|)
block|{
case|case
name|BYPASS_NOP
case|:
case|case
name|BYPASS_NORM
case|:
case|case
name|BYPASS_BYPASS
case|:
case|case
name|BYPASS_ISOLATE
case|:
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Set the new state */
name|ixgbe_bypass_mutex_enter
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|error
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|bypass_set
argument_list|(
name|hw
argument_list|,
name|BYPASS_PAGE_CTL0
argument_list|,
name|BYPASS_WDTIMEOUT_M
argument_list|,
name|timeout
operator|<<
name|BYPASS_WDTIMEOUT_SHIFT
argument_list|)
expr_stmt|;
name|ixgbe_bypass_mutex_clear
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|6000
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ixgbe_bp_timeout */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_bp_main_on  ************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_bp_main_on
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
operator|(
expr|struct
name|adapter
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|main_on
init|=
literal|0
decl_stmt|;
name|ixgbe_bypass_mutex_enter
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|error
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|bypass_rw
argument_list|(
name|hw
argument_list|,
name|BYPASS_PAGE_CTL0
argument_list|,
operator|&
name|main_on
argument_list|)
expr_stmt|;
name|main_on
operator|=
operator|(
name|main_on
operator|>>
name|BYPASS_MAIN_ON_SHIFT
operator|)
operator|&
literal|0x3
expr_stmt|;
name|ixgbe_bypass_mutex_clear
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|main_on
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|)
operator|||
operator|(
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Sanity check on the setting */
switch|switch
condition|(
name|main_on
condition|)
block|{
case|case
name|BYPASS_NOP
case|:
case|case
name|BYPASS_NORM
case|:
case|case
name|BYPASS_BYPASS
case|:
case|case
name|BYPASS_ISOLATE
case|:
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Set the new state */
name|ixgbe_bypass_mutex_enter
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|error
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|bypass_set
argument_list|(
name|hw
argument_list|,
name|BYPASS_PAGE_CTL0
argument_list|,
name|BYPASS_MAIN_ON_M
argument_list|,
name|main_on
operator|<<
name|BYPASS_MAIN_ON_SHIFT
argument_list|)
expr_stmt|;
name|ixgbe_bypass_mutex_clear
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|6000
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ixgbe_bp_main_on */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_bp_main_off  ************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_bp_main_off
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
operator|(
expr|struct
name|adapter
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|main_off
init|=
literal|0
decl_stmt|;
name|ixgbe_bypass_mutex_enter
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|error
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|bypass_rw
argument_list|(
name|hw
argument_list|,
name|BYPASS_PAGE_CTL0
argument_list|,
operator|&
name|main_off
argument_list|)
expr_stmt|;
name|ixgbe_bypass_mutex_clear
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|main_off
operator|=
operator|(
name|main_off
operator|>>
name|BYPASS_MAIN_OFF_SHIFT
operator|)
operator|&
literal|0x3
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|main_off
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|)
operator|||
operator|(
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Sanity check on the setting */
switch|switch
condition|(
name|main_off
condition|)
block|{
case|case
name|BYPASS_NOP
case|:
case|case
name|BYPASS_NORM
case|:
case|case
name|BYPASS_BYPASS
case|:
case|case
name|BYPASS_ISOLATE
case|:
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Set the new state */
name|ixgbe_bypass_mutex_enter
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|error
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|bypass_set
argument_list|(
name|hw
argument_list|,
name|BYPASS_PAGE_CTL0
argument_list|,
name|BYPASS_MAIN_OFF_M
argument_list|,
name|main_off
operator|<<
name|BYPASS_MAIN_OFF_SHIFT
argument_list|)
expr_stmt|;
name|ixgbe_bypass_mutex_clear
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|6000
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ixgbe_bp_main_off */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_bp_aux_on  ************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_bp_aux_on
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
operator|(
expr|struct
name|adapter
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|aux_on
init|=
literal|0
decl_stmt|;
name|ixgbe_bypass_mutex_enter
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|error
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|bypass_rw
argument_list|(
name|hw
argument_list|,
name|BYPASS_PAGE_CTL0
argument_list|,
operator|&
name|aux_on
argument_list|)
expr_stmt|;
name|ixgbe_bypass_mutex_clear
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|aux_on
operator|=
operator|(
name|aux_on
operator|>>
name|BYPASS_AUX_ON_SHIFT
operator|)
operator|&
literal|0x3
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|aux_on
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|)
operator|||
operator|(
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Sanity check on the setting */
switch|switch
condition|(
name|aux_on
condition|)
block|{
case|case
name|BYPASS_NOP
case|:
case|case
name|BYPASS_NORM
case|:
case|case
name|BYPASS_BYPASS
case|:
case|case
name|BYPASS_ISOLATE
case|:
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Set the new state */
name|ixgbe_bypass_mutex_enter
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|error
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|bypass_set
argument_list|(
name|hw
argument_list|,
name|BYPASS_PAGE_CTL0
argument_list|,
name|BYPASS_AUX_ON_M
argument_list|,
name|aux_on
operator|<<
name|BYPASS_AUX_ON_SHIFT
argument_list|)
expr_stmt|;
name|ixgbe_bypass_mutex_clear
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|6000
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ixgbe_bp_aux_on */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_bp_aux_off  ************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_bp_aux_off
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
operator|(
expr|struct
name|adapter
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|aux_off
init|=
literal|0
decl_stmt|;
name|ixgbe_bypass_mutex_enter
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|error
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|bypass_rw
argument_list|(
name|hw
argument_list|,
name|BYPASS_PAGE_CTL0
argument_list|,
operator|&
name|aux_off
argument_list|)
expr_stmt|;
name|ixgbe_bypass_mutex_clear
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|aux_off
operator|=
operator|(
name|aux_off
operator|>>
name|BYPASS_AUX_OFF_SHIFT
operator|)
operator|&
literal|0x3
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|aux_off
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|)
operator|||
operator|(
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Sanity check on the setting */
switch|switch
condition|(
name|aux_off
condition|)
block|{
case|case
name|BYPASS_NOP
case|:
case|case
name|BYPASS_NORM
case|:
case|case
name|BYPASS_BYPASS
case|:
case|case
name|BYPASS_ISOLATE
case|:
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Set the new state */
name|ixgbe_bypass_mutex_enter
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|error
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|bypass_set
argument_list|(
name|hw
argument_list|,
name|BYPASS_PAGE_CTL0
argument_list|,
name|BYPASS_AUX_OFF_M
argument_list|,
name|aux_off
operator|<<
name|BYPASS_AUX_OFF_SHIFT
argument_list|)
expr_stmt|;
name|ixgbe_bypass_mutex_clear
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|6000
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ixgbe_bp_aux_off */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_bp_wd_set - Set the Watchdog timer value  *  *   Valid settings are:  *	- 0 will disable the watchdog  *	- 1, 2, 3, 4, 8, 16, 32  *	- anything else is invalid and will be ignored  ************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_bp_wd_set
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
operator|(
expr|struct
name|adapter
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|int
name|error
decl_stmt|,
name|tmp
decl_stmt|;
specifier|static
name|int
name|timeout
init|=
literal|0
decl_stmt|;
name|u32
name|mask
decl_stmt|,
name|arg
init|=
name|BYPASS_PAGE_CTL0
decl_stmt|;
comment|/* Get the current hardware value */
name|ixgbe_bypass_mutex_enter
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|error
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|bypass_rw
argument_list|(
name|hw
argument_list|,
name|BYPASS_PAGE_CTL0
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|ixgbe_bypass_mutex_clear
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * If armed keep the displayed value, 	 * else change the display to zero. 	 */
if|if
condition|(
operator|(
name|tmp
operator|&
operator|(
literal|0x1
operator|<<
name|BYPASS_WDT_ENABLE_SHIFT
operator|)
operator|)
operator|==
literal|0
condition|)
name|timeout
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|timeout
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|)
operator|||
operator|(
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|mask
operator|=
name|BYPASS_WDT_ENABLE_M
expr_stmt|;
switch|switch
condition|(
name|timeout
condition|)
block|{
case|case
literal|0
case|:
comment|/* disables the timer */
break|break;
case|case
literal|1
case|:
name|arg
operator|=
name|BYPASS_WDT_1_5
operator|<<
name|BYPASS_WDT_TIME_SHIFT
expr_stmt|;
name|arg
operator||=
literal|0x1
operator|<<
name|BYPASS_WDT_ENABLE_SHIFT
expr_stmt|;
name|mask
operator||=
name|BYPASS_WDT_VALUE_M
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|arg
operator|=
name|BYPASS_WDT_2
operator|<<
name|BYPASS_WDT_TIME_SHIFT
expr_stmt|;
name|arg
operator||=
literal|0x1
operator|<<
name|BYPASS_WDT_ENABLE_SHIFT
expr_stmt|;
name|mask
operator||=
name|BYPASS_WDT_VALUE_M
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|arg
operator|=
name|BYPASS_WDT_3
operator|<<
name|BYPASS_WDT_TIME_SHIFT
expr_stmt|;
name|arg
operator||=
literal|0x1
operator|<<
name|BYPASS_WDT_ENABLE_SHIFT
expr_stmt|;
name|mask
operator||=
name|BYPASS_WDT_VALUE_M
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|arg
operator|=
name|BYPASS_WDT_4
operator|<<
name|BYPASS_WDT_TIME_SHIFT
expr_stmt|;
name|arg
operator||=
literal|0x1
operator|<<
name|BYPASS_WDT_ENABLE_SHIFT
expr_stmt|;
name|mask
operator||=
name|BYPASS_WDT_VALUE_M
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|arg
operator|=
name|BYPASS_WDT_8
operator|<<
name|BYPASS_WDT_TIME_SHIFT
expr_stmt|;
name|arg
operator||=
literal|0x1
operator|<<
name|BYPASS_WDT_ENABLE_SHIFT
expr_stmt|;
name|mask
operator||=
name|BYPASS_WDT_VALUE_M
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|arg
operator|=
name|BYPASS_WDT_16
operator|<<
name|BYPASS_WDT_TIME_SHIFT
expr_stmt|;
name|arg
operator||=
literal|0x1
operator|<<
name|BYPASS_WDT_ENABLE_SHIFT
expr_stmt|;
name|mask
operator||=
name|BYPASS_WDT_VALUE_M
expr_stmt|;
break|break;
case|case
literal|32
case|:
name|arg
operator|=
name|BYPASS_WDT_32
operator|<<
name|BYPASS_WDT_TIME_SHIFT
expr_stmt|;
name|arg
operator||=
literal|0x1
operator|<<
name|BYPASS_WDT_ENABLE_SHIFT
expr_stmt|;
name|mask
operator||=
name|BYPASS_WDT_VALUE_M
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Set the new watchdog */
name|ixgbe_bypass_mutex_enter
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|error
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|bypass_set
argument_list|(
name|hw
argument_list|,
name|BYPASS_PAGE_CTL0
argument_list|,
name|mask
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|ixgbe_bypass_mutex_clear
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ixgbe_bp_wd_set */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_bp_wd_reset - Reset the Watchdog timer  *  *    To activate this it must be called with any argument.  ************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_bp_wd_reset
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
operator|(
expr|struct
name|adapter
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|u32
name|sec
decl_stmt|,
name|year
decl_stmt|;
name|int
name|cmd
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|int
name|reset_wd
init|=
literal|0
decl_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|reset_wd
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|)
operator|||
operator|(
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|cmd
operator|=
name|BYPASS_PAGE_CTL1
operator||
name|BYPASS_WE
operator||
name|BYPASS_CTL1_WDT_PET
expr_stmt|;
comment|/* Resync the FW time while writing to CTL1 anyway */
name|ixgbe_get_bypass_time
argument_list|(
operator|&
name|year
argument_list|,
operator|&
name|sec
argument_list|)
expr_stmt|;
name|cmd
operator||=
operator|(
name|sec
operator|&
name|BYPASS_CTL1_TIME_M
operator|)
operator||
name|BYPASS_CTL1_VALID
expr_stmt|;
name|cmd
operator||=
name|BYPASS_CTL1_OFFTRST
expr_stmt|;
name|ixgbe_bypass_wd_mutex_enter
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|error
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|bypass_rw
argument_list|(
name|hw
argument_list|,
name|cmd
argument_list|,
operator|&
name|reset_wd
argument_list|)
expr_stmt|;
comment|/* Read until it matches what we wrote, or we time out */
do|do
block|{
if|if
condition|(
name|count
operator|++
operator|>
literal|10
condition|)
block|{
name|error
operator|=
name|IXGBE_BYPASS_FW_WRITE_FAILURE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|bypass_rw
argument_list|(
name|hw
argument_list|,
name|BYPASS_PAGE_CTL1
argument_list|,
operator|&
name|reset_wd
argument_list|)
condition|)
block|{
name|error
operator|=
name|IXGBE_ERR_INVALID_ARGUMENT
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
operator|!
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|bypass_valid_rd
argument_list|(
name|cmd
argument_list|,
name|reset_wd
argument_list|)
condition|)
do|;
name|reset_wd
operator|=
literal|0
expr_stmt|;
name|ixgbe_bypass_wd_mutex_clear
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ixgbe_bp_wd_reset */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_bp_log - Display the bypass log  *  *   You must pass a non-zero arg to sysctl  ************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgbe_bp_log
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
operator|(
expr|struct
name|adapter
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|u32
name|cmd
decl_stmt|,
name|base
decl_stmt|,
name|head
decl_stmt|;
name|u32
name|log_off
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|status
init|=
literal|0
decl_stmt|;
name|u8
name|data
decl_stmt|;
name|struct
name|ixgbe_bypass_eeprom
name|eeprom
index|[
name|BYPASS_MAX_LOGS
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|status
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|)
operator|||
operator|(
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Keep the log display single-threaded */
while|while
condition|(
name|atomic_cmpset_int
argument_list|(
operator|&
name|adapter
operator|->
name|bypass
operator|.
name|log
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|usec_delay
argument_list|(
literal|3000
argument_list|)
expr_stmt|;
name|ixgbe_bypass_mutex_enter
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Find Current head of the log eeprom offset */
name|cmd
operator|=
name|BYPASS_PAGE_CTL2
operator||
name|BYPASS_WE
expr_stmt|;
name|cmd
operator||=
operator|(
literal|0x1
operator|<<
name|BYPASS_CTL2_OFFSET_SHIFT
operator|)
operator|&
name|BYPASS_CTL2_OFFSET_M
expr_stmt|;
name|error
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|bypass_rw
argument_list|(
name|hw
argument_list|,
name|cmd
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|unlock_err
goto|;
comment|/* wait for the write to stick */
name|msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* Now read the results */
name|cmd
operator|&=
operator|~
name|BYPASS_WE
expr_stmt|;
name|error
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|bypass_rw
argument_list|(
name|hw
argument_list|,
name|cmd
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|unlock_err
goto|;
name|ixgbe_bypass_mutex_clear
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|base
operator|=
name|status
operator|&
name|BYPASS_CTL2_DATA_M
expr_stmt|;
name|head
operator|=
operator|(
name|status
operator|&
name|BYPASS_CTL2_HEAD_M
operator|)
operator|>>
name|BYPASS_CTL2_HEAD_SHIFT
expr_stmt|;
comment|/* address of the first log */
name|log_off
operator|=
name|base
operator|+
operator|(
name|head
operator|*
literal|5
operator|)
expr_stmt|;
comment|/* extract all the log entries */
while|while
condition|(
name|count
operator|<
name|BYPASS_MAX_LOGS
condition|)
block|{
name|eeprom
index|[
name|count
index|]
operator|.
name|logs
operator|=
literal|0
expr_stmt|;
name|eeprom
index|[
name|count
index|]
operator|.
name|actions
operator|=
literal|0
expr_stmt|;
comment|/* Log 5 bytes store in on u32 and a u8 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|ixgbe_bypass_mutex_enter
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|error
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|bypass_rd_eep
argument_list|(
name|hw
argument_list|,
name|log_off
operator|+
name|i
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|ixgbe_bypass_mutex_clear
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
operator|-
name|EINVAL
operator|)
return|;
name|eeprom
index|[
name|count
index|]
operator|.
name|logs
operator|+=
name|data
operator|<<
operator|(
literal|8
operator|*
name|i
operator|)
expr_stmt|;
block|}
name|ixgbe_bypass_mutex_enter
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|error
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|bypass_rd_eep
argument_list|(
name|hw
argument_list|,
name|log_off
operator|+
name|i
argument_list|,
operator|&
name|eeprom
index|[
name|count
index|]
operator|.
name|actions
argument_list|)
expr_stmt|;
name|ixgbe_bypass_mutex_clear
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
operator|-
name|EINVAL
operator|)
return|;
comment|/* Quit if not a unread log */
if|if
condition|(
operator|!
operator|(
name|eeprom
index|[
name|count
index|]
operator|.
name|logs
operator|&
name|BYPASS_LOG_CLEAR_M
operator|)
condition|)
break|break;
comment|/* 		 * Log looks good so store the address where it's 		 * Unread Log bit is so we can clear it after safely 		 * pulling out all of the log data. 		 */
name|eeprom
index|[
name|count
index|]
operator|.
name|clear_off
operator|=
name|log_off
expr_stmt|;
name|count
operator|++
expr_stmt|;
name|head
operator|=
name|head
condition|?
name|head
operator|-
literal|1
else|:
name|BYPASS_MAX_LOGS
expr_stmt|;
name|log_off
operator|=
name|base
operator|+
operator|(
name|head
operator|*
literal|5
operator|)
expr_stmt|;
block|}
comment|/* reverse order (oldest first) for output */
while|while
condition|(
name|count
operator|--
condition|)
block|{
name|int
name|year
decl_stmt|;
name|u32
name|mon
decl_stmt|,
name|days
decl_stmt|,
name|hours
decl_stmt|,
name|min
decl_stmt|,
name|sec
decl_stmt|;
name|u32
name|time
init|=
name|eeprom
index|[
name|count
index|]
operator|.
name|logs
operator|&
name|BYPASS_LOG_TIME_M
decl_stmt|;
name|u32
name|event
init|=
operator|(
name|eeprom
index|[
name|count
index|]
operator|.
name|logs
operator|&
name|BYPASS_LOG_EVENT_M
operator|)
operator|>>
name|BYPASS_LOG_EVENT_SHIFT
decl_stmt|;
name|u8
name|action
init|=
name|eeprom
index|[
name|count
index|]
operator|.
name|actions
operator|&
name|BYPASS_LOG_ACTION_M
decl_stmt|;
name|u16
name|day_mon
index|[
literal|2
index|]
index|[
literal|13
index|]
init|=
block|{
block|{
literal|0
block|,
literal|31
block|,
literal|59
block|,
literal|90
block|,
literal|120
block|,
literal|151
block|,
literal|181
block|,
literal|212
block|,
literal|243
block|,
literal|273
block|,
literal|304
block|,
literal|334
block|,
literal|365
block|}
block|,
block|{
literal|0
block|,
literal|31
block|,
literal|59
block|,
literal|91
block|,
literal|121
block|,
literal|152
block|,
literal|182
block|,
literal|213
block|,
literal|244
block|,
literal|274
block|,
literal|305
block|,
literal|335
block|,
literal|366
block|}
block|}
decl_stmt|;
name|char
modifier|*
name|event_str
index|[]
init|=
block|{
literal|"unknown"
block|,
literal|"main on"
block|,
literal|"aux on"
block|,
literal|"main off"
block|,
literal|"aux off"
block|,
literal|"WDT"
block|,
literal|"user"
block|}
decl_stmt|;
name|char
modifier|*
name|action_str
index|[]
init|=
block|{
literal|"ignore"
block|,
literal|"normal"
block|,
literal|"bypass"
block|,
literal|"isolate"
block|,}
decl_stmt|;
comment|/* verify vaild data  1 - 6 */
if|if
condition|(
name|event
operator|<
name|BYPASS_EVENT_MAIN_ON
operator|||
name|event
operator|>
name|BYPASS_EVENT_USR
condition|)
name|event
operator|=
literal|0
expr_stmt|;
comment|/* 		 * time is in sec's this year, so convert to something 		 * printable. 		 */
name|ixgbe_get_bypass_time
argument_list|(
operator|&
name|year
argument_list|,
operator|&
name|sec
argument_list|)
expr_stmt|;
name|days
operator|=
name|time
operator|/
name|SEC_PER_DAY
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|11
init|;
name|days
operator|<
name|day_mon
index|[
name|LEAP_YR
argument_list|(
name|year
argument_list|)
index|]
index|[
name|i
index|]
condition|;
name|i
operator|--
control|)
continue|continue;
name|mon
operator|=
name|i
operator|+
literal|1
expr_stmt|;
comment|/* display month as 1-12 */
name|time
operator|-=
operator|(
name|day_mon
index|[
name|LEAP_YR
argument_list|(
name|year
argument_list|)
index|]
index|[
name|i
index|]
operator|*
name|SEC_PER_DAY
operator|)
expr_stmt|;
name|days
operator|=
operator|(
name|time
operator|/
name|SEC_PER_DAY
operator|)
operator|+
literal|1
expr_stmt|;
comment|/* first day is 1 */
name|time
operator|%=
name|SEC_PER_DAY
expr_stmt|;
name|hours
operator|=
name|time
operator|/
operator|(
literal|60
operator|*
literal|60
operator|)
expr_stmt|;
name|time
operator|%=
operator|(
literal|60
operator|*
literal|60
operator|)
expr_stmt|;
name|min
operator|=
name|time
operator|/
literal|60
expr_stmt|;
name|sec
operator|=
name|time
operator|%
literal|60
expr_stmt|;
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"UT %02d/%02d %02d:%02d:%02d %8.8s -> %7.7s\n"
argument_list|,
name|mon
argument_list|,
name|days
argument_list|,
name|hours
argument_list|,
name|min
argument_list|,
name|sec
argument_list|,
name|event_str
index|[
name|event
index|]
argument_list|,
name|action_str
index|[
name|action
index|]
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|BYPASS_PAGE_CTL2
operator||
name|BYPASS_WE
operator||
name|BYPASS_CTL2_RW
expr_stmt|;
name|cmd
operator||=
operator|(
operator|(
name|eeprom
index|[
name|count
index|]
operator|.
name|clear_off
operator|+
literal|3
operator|)
operator|<<
name|BYPASS_CTL2_OFFSET_SHIFT
operator|)
operator|&
name|BYPASS_CTL2_OFFSET_M
expr_stmt|;
name|cmd
operator||=
operator|(
operator|(
name|eeprom
index|[
name|count
index|]
operator|.
name|logs
operator|&
operator|~
name|BYPASS_LOG_CLEAR_M
operator|)
operator|>>
literal|24
operator|)
expr_stmt|;
name|ixgbe_bypass_mutex_enter
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|error
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|bypass_rw
argument_list|(
name|hw
argument_list|,
name|cmd
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
comment|/* wait for the write to stick */
name|msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|ixgbe_bypass_mutex_clear
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
operator|-
name|EINVAL
operator|)
return|;
block|}
name|status
operator|=
literal|0
expr_stmt|;
comment|/* reset */
comment|/* Another log command can now run */
while|while
condition|(
name|atomic_cmpset_int
argument_list|(
operator|&
name|adapter
operator|->
name|bypass
operator|.
name|log
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
name|usec_delay
argument_list|(
literal|3000
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
name|unlock_err
label|:
name|ixgbe_bypass_mutex_clear
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
comment|/* reset */
while|while
condition|(
name|atomic_cmpset_int
argument_list|(
operator|&
name|adapter
operator|->
name|bypass
operator|.
name|log
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
name|usec_delay
argument_list|(
literal|3000
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ixgbe_bp_log */
end_comment

begin_comment
comment|/************************************************************************  * ixgbe_bypass_init - Set up infrastructure for the bypass feature  *  *   Do time and sysctl initialization here.  This feature is  *   only enabled for the first port of a bypass adapter.  ************************************************************************/
end_comment

begin_function
name|void
name|ixgbe_bypass_init
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|bp_node
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|bp_list
decl_stmt|;
name|u32
name|mask
decl_stmt|,
name|value
decl_stmt|,
name|sec
decl_stmt|,
name|year
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|adapter
operator|->
name|feat_cap
operator|&
name|IXGBE_FEATURE_BYPASS
operator|)
condition|)
return|return;
comment|/* First set up time for the hardware */
name|ixgbe_get_bypass_time
argument_list|(
operator|&
name|year
argument_list|,
operator|&
name|sec
argument_list|)
expr_stmt|;
name|mask
operator|=
name|BYPASS_CTL1_TIME_M
operator||
name|BYPASS_CTL1_VALID_M
operator||
name|BYPASS_CTL1_OFFTRST_M
expr_stmt|;
name|value
operator|=
operator|(
name|sec
operator|&
name|BYPASS_CTL1_TIME_M
operator|)
operator||
name|BYPASS_CTL1_VALID
operator||
name|BYPASS_CTL1_OFFTRST
expr_stmt|;
name|ixgbe_bypass_mutex_enter
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|bypass_set
argument_list|(
name|hw
argument_list|,
name|BYPASS_PAGE_CTL1
argument_list|,
name|mask
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|ixgbe_bypass_mutex_clear
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Now set up the SYSCTL infrastructure */
comment|/* 	 * The log routine is kept separate from the other 	 * children so a general display command like: 	 * `sysctl dev.ix.0.bypass` will not show the log. 	 */
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"bypass_log"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|adapter
argument_list|,
literal|0
argument_list|,
name|ixgbe_bp_log
argument_list|,
literal|"I"
argument_list|,
literal|"Bypass Log"
argument_list|)
expr_stmt|;
comment|/* All other setting are hung from the 'bypass' node */
name|bp_node
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"bypass"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"Bypass"
argument_list|)
expr_stmt|;
name|bp_list
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|bp_node
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|bp_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"version"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
name|adapter
argument_list|,
literal|0
argument_list|,
name|ixgbe_bp_version
argument_list|,
literal|"I"
argument_list|,
literal|"Bypass Version"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|bp_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"state"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|adapter
argument_list|,
literal|0
argument_list|,
name|ixgbe_bp_set_state
argument_list|,
literal|"I"
argument_list|,
literal|"Bypass State"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|bp_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"timeout"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|adapter
argument_list|,
literal|0
argument_list|,
name|ixgbe_bp_timeout
argument_list|,
literal|"I"
argument_list|,
literal|"Bypass Timeout"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|bp_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"main_on"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|adapter
argument_list|,
literal|0
argument_list|,
name|ixgbe_bp_main_on
argument_list|,
literal|"I"
argument_list|,
literal|"Bypass Main On"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|bp_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"main_off"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|adapter
argument_list|,
literal|0
argument_list|,
name|ixgbe_bp_main_off
argument_list|,
literal|"I"
argument_list|,
literal|"Bypass Main Off"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|bp_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"aux_on"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|adapter
argument_list|,
literal|0
argument_list|,
name|ixgbe_bp_aux_on
argument_list|,
literal|"I"
argument_list|,
literal|"Bypass Aux On"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|bp_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"aux_off"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|adapter
argument_list|,
literal|0
argument_list|,
name|ixgbe_bp_aux_off
argument_list|,
literal|"I"
argument_list|,
literal|"Bypass Aux Off"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|bp_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"wd_set"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|adapter
argument_list|,
literal|0
argument_list|,
name|ixgbe_bp_wd_set
argument_list|,
literal|"I"
argument_list|,
literal|"Set BP Watchdog"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|bp_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"wd_reset"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_WR
argument_list|,
name|adapter
argument_list|,
literal|0
argument_list|,
name|ixgbe_bp_wd_reset
argument_list|,
literal|"S"
argument_list|,
literal|"Bypass WD Reset"
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|feat_en
operator||=
name|IXGBE_FEATURE_BYPASS
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ixgbe_bypass_init */
end_comment

end_unit

